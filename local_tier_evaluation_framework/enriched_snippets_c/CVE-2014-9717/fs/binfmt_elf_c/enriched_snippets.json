[
  {
    "function_name": "exit_elf_binfmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
    "lines": "2323-2327",
    "snippet": "static void __exit exit_elf_binfmt(void)\n{\n\t/* Remove the COFF and ELF loaders. */\n\tunregister_binfmt(&elf_format);\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct linux_binfmt elf_format = {\n\t.module\t\t= THIS_MODULE,\n\t.load_binary\t= load_elf_binary,\n\t.load_shlib\t= load_elf_library,\n\t.core_dump\t= elf_core_dump,\n\t.min_coredump\t= ELF_EXEC_PAGESIZE,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_binfmt",
          "args": [
            "&elf_format"
          ],
          "line": 2326
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_binfmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "87-92",
          "snippet": "void unregister_binfmt(struct linux_binfmt * fmt)\n{\n\twrite_lock(&binfmt_lock);\n\tlist_del(&fmt->lh);\n\twrite_unlock(&binfmt_lock);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(binfmt_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic DEFINE_RWLOCK(binfmt_lock);\n\nvoid unregister_binfmt(struct linux_binfmt * fmt)\n{\n\twrite_lock(&binfmt_lock);\n\tlist_del(&fmt->lh);\n\twrite_unlock(&binfmt_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic struct linux_binfmt elf_format = {\n\t.module\t\t= THIS_MODULE,\n\t.load_binary\t= load_elf_binary,\n\t.load_shlib\t= load_elf_library,\n\t.core_dump\t= elf_core_dump,\n\t.min_coredump\t= ELF_EXEC_PAGESIZE,\n};\n\nstatic void __exit exit_elf_binfmt(void)\n{\n\t/* Remove the COFF and ELF loaders. */\n\tunregister_binfmt(&elf_format);\n}"
  },
  {
    "function_name": "init_elf_binfmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
    "lines": "2317-2321",
    "snippet": "static int __init init_elf_binfmt(void)\n{\n\tregister_binfmt(&elf_format);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct linux_binfmt elf_format = {\n\t.module\t\t= THIS_MODULE,\n\t.load_binary\t= load_elf_binary,\n\t.load_shlib\t= load_elf_library,\n\t.core_dump\t= elf_core_dump,\n\t.min_coredump\t= ELF_EXEC_PAGESIZE,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_binfmt",
          "args": [
            "&elf_format"
          ],
          "line": 2319
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_binfmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "87-92",
          "snippet": "void unregister_binfmt(struct linux_binfmt * fmt)\n{\n\twrite_lock(&binfmt_lock);\n\tlist_del(&fmt->lh);\n\twrite_unlock(&binfmt_lock);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(binfmt_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic DEFINE_RWLOCK(binfmt_lock);\n\nvoid unregister_binfmt(struct linux_binfmt * fmt)\n{\n\twrite_lock(&binfmt_lock);\n\tlist_del(&fmt->lh);\n\twrite_unlock(&binfmt_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic struct linux_binfmt elf_format = {\n\t.module\t\t= THIS_MODULE,\n\t.load_binary\t= load_elf_binary,\n\t.load_shlib\t= load_elf_library,\n\t.core_dump\t= elf_core_dump,\n\t.min_coredump\t= ELF_EXEC_PAGESIZE,\n};\n\nstatic int __init init_elf_binfmt(void)\n{\n\tregister_binfmt(&elf_format);\n\treturn 0;\n}"
  },
  {
    "function_name": "elf_core_dump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
    "lines": "2119-2313",
    "snippet": "static int elf_core_dump(struct coredump_params *cprm)\n{\n\tint has_dumped = 0;\n\tmm_segment_t fs;\n\tint segs, i;\n\tsize_t vma_data_size = 0;\n\tstruct vm_area_struct *vma, *gate_vma;\n\tstruct elfhdr *elf = NULL;\n\tloff_t offset = 0, dataoff;\n\tstruct elf_note_info info = { };\n\tstruct elf_phdr *phdr4note = NULL;\n\tstruct elf_shdr *shdr4extnum = NULL;\n\tElf_Half e_phnum;\n\telf_addr_t e_shoff;\n\telf_addr_t *vma_filesz = NULL;\n\n\t/*\n\t * We no longer stop all VM operations.\n\t * \n\t * This is because those proceses that could possibly change map_count\n\t * or the mmap / vma pages are now blocked in do_exit on current\n\t * finishing this core dump.\n\t *\n\t * Only ptrace can touch these memory addresses, but it doesn't change\n\t * the map_count or the pages allocated. So no possibility of crashing\n\t * exists while dumping the mm->vm_next areas to the core file.\n\t */\n  \n\t/* alloc memory for large data structures: too large to be on stack */\n\telf = kmalloc(sizeof(*elf), GFP_KERNEL);\n\tif (!elf)\n\t\tgoto out;\n\t/*\n\t * The number of segs are recored into ELF header as 16bit value.\n\t * Please check DEFAULT_MAX_MAP_COUNT definition when you modify here.\n\t */\n\tsegs = current->mm->map_count;\n\tsegs += elf_core_extra_phdrs();\n\n\tgate_vma = get_gate_vma(current->mm);\n\tif (gate_vma != NULL)\n\t\tsegs++;\n\n\t/* for notes section */\n\tsegs++;\n\n\t/* If segs > PN_XNUM(0xffff), then e_phnum overflows. To avoid\n\t * this, kernel supports extended numbering. Have a look at\n\t * include/linux/elf.h for further information. */\n\te_phnum = segs > PN_XNUM ? PN_XNUM : segs;\n\n\t/*\n\t * Collect all the non-memory information about the process for the\n\t * notes.  This also sets up the file header.\n\t */\n\tif (!fill_note_info(elf, e_phnum, &info, cprm->siginfo, cprm->regs))\n\t\tgoto cleanup;\n\n\thas_dumped = 1;\n\n\tfs = get_fs();\n\tset_fs(KERNEL_DS);\n\n\toffset += sizeof(*elf);\t\t\t\t/* Elf header */\n\toffset += segs * sizeof(struct elf_phdr);\t/* Program headers */\n\n\t/* Write notes phdr entry */\n\t{\n\t\tsize_t sz = get_note_info_size(&info);\n\n\t\tsz += elf_coredump_extra_notes_size();\n\n\t\tphdr4note = kmalloc(sizeof(*phdr4note), GFP_KERNEL);\n\t\tif (!phdr4note)\n\t\t\tgoto end_coredump;\n\n\t\tfill_elf_note_phdr(phdr4note, sz, offset);\n\t\toffset += sz;\n\t}\n\n\tdataoff = offset = roundup(offset, ELF_EXEC_PAGESIZE);\n\n\tvma_filesz = kmalloc_array(segs - 1, sizeof(*vma_filesz), GFP_KERNEL);\n\tif (!vma_filesz)\n\t\tgoto end_coredump;\n\n\tfor (i = 0, vma = first_vma(current, gate_vma); vma != NULL;\n\t\t\tvma = next_vma(vma, gate_vma)) {\n\t\tunsigned long dump_size;\n\n\t\tdump_size = vma_dump_size(vma, cprm->mm_flags);\n\t\tvma_filesz[i++] = dump_size;\n\t\tvma_data_size += dump_size;\n\t}\n\n\toffset += vma_data_size;\n\toffset += elf_core_extra_data_size();\n\te_shoff = offset;\n\n\tif (e_phnum == PN_XNUM) {\n\t\tshdr4extnum = kmalloc(sizeof(*shdr4extnum), GFP_KERNEL);\n\t\tif (!shdr4extnum)\n\t\t\tgoto end_coredump;\n\t\tfill_extnum_info(elf, shdr4extnum, e_shoff, segs);\n\t}\n\n\toffset = dataoff;\n\n\tif (!dump_emit(cprm, elf, sizeof(*elf)))\n\t\tgoto end_coredump;\n\n\tif (!dump_emit(cprm, phdr4note, sizeof(*phdr4note)))\n\t\tgoto end_coredump;\n\n\t/* Write program headers for segments dump */\n\tfor (i = 0, vma = first_vma(current, gate_vma); vma != NULL;\n\t\t\tvma = next_vma(vma, gate_vma)) {\n\t\tstruct elf_phdr phdr;\n\n\t\tphdr.p_type = PT_LOAD;\n\t\tphdr.p_offset = offset;\n\t\tphdr.p_vaddr = vma->vm_start;\n\t\tphdr.p_paddr = 0;\n\t\tphdr.p_filesz = vma_filesz[i++];\n\t\tphdr.p_memsz = vma->vm_end - vma->vm_start;\n\t\toffset += phdr.p_filesz;\n\t\tphdr.p_flags = vma->vm_flags & VM_READ ? PF_R : 0;\n\t\tif (vma->vm_flags & VM_WRITE)\n\t\t\tphdr.p_flags |= PF_W;\n\t\tif (vma->vm_flags & VM_EXEC)\n\t\t\tphdr.p_flags |= PF_X;\n\t\tphdr.p_align = ELF_EXEC_PAGESIZE;\n\n\t\tif (!dump_emit(cprm, &phdr, sizeof(phdr)))\n\t\t\tgoto end_coredump;\n\t}\n\n\tif (!elf_core_write_extra_phdrs(cprm, offset))\n\t\tgoto end_coredump;\n\n \t/* write out the notes section */\n\tif (!write_note_info(&info, cprm))\n\t\tgoto end_coredump;\n\n\tif (elf_coredump_extra_notes_write(cprm))\n\t\tgoto end_coredump;\n\n\t/* Align to page */\n\tif (!dump_skip(cprm, dataoff - cprm->written))\n\t\tgoto end_coredump;\n\n\tfor (i = 0, vma = first_vma(current, gate_vma); vma != NULL;\n\t\t\tvma = next_vma(vma, gate_vma)) {\n\t\tunsigned long addr;\n\t\tunsigned long end;\n\n\t\tend = vma->vm_start + vma_filesz[i++];\n\n\t\tfor (addr = vma->vm_start; addr < end; addr += PAGE_SIZE) {\n\t\t\tstruct page *page;\n\t\t\tint stop;\n\n\t\t\tpage = get_dump_page(addr);\n\t\t\tif (page) {\n\t\t\t\tvoid *kaddr = kmap(page);\n\t\t\t\tstop = !dump_emit(cprm, kaddr, PAGE_SIZE);\n\t\t\t\tkunmap(page);\n\t\t\t\tpage_cache_release(page);\n\t\t\t} else\n\t\t\t\tstop = !dump_skip(cprm, PAGE_SIZE);\n\t\t\tif (stop)\n\t\t\t\tgoto end_coredump;\n\t\t}\n\t}\n\n\tif (!elf_core_write_extra_data(cprm))\n\t\tgoto end_coredump;\n\n\tif (e_phnum == PN_XNUM) {\n\t\tif (!dump_emit(cprm, shdr4extnum, sizeof(*shdr4extnum)))\n\t\t\tgoto end_coredump;\n\t}\n\nend_coredump:\n\tset_fs(fs);\n\ncleanup:\n\tfree_note_info(&info);\n\tkfree(shdr4extnum);\n\tkfree(vma_filesz);\n\tkfree(phdr4note);\n\tkfree(elf);\nout:\n\treturn has_dumped;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define elf_core_dump\tNULL"
    ],
    "globals_used": [
      "static unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "elf"
          ],
          "line": 2310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "phdr4note"
          ],
          "line": 2309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "vma_filesz"
          ],
          "line": 2308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "shdr4extnum"
          ],
          "line": 2307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_note_info",
          "args": [
            "&info"
          ],
          "line": 2306
        },
        "resolved": true,
        "details": {
          "function_name": "free_note_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "2047-2066",
          "snippet": "static void free_note_info(struct elf_note_info *info)\n{\n\twhile (!list_empty(&info->thread_list)) {\n\t\tstruct list_head *tmp = info->thread_list.next;\n\t\tlist_del(tmp);\n\t\tkfree(list_entry(tmp, struct elf_thread_status, list));\n\t}\n\n\t/* Free data possibly allocated by fill_files_note(): */\n\tif (info->notes_files)\n\t\tvfree(info->notes_files->data);\n\n\tkfree(info->prstatus);\n\tkfree(info->psinfo);\n\tkfree(info->notes);\n\tkfree(info->fpu);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tkfree(info->xfpu);\n#endif\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void free_note_info(struct elf_note_info *info)\n{\n\twhile (!list_empty(&info->thread_list)) {\n\t\tstruct list_head *tmp = info->thread_list.next;\n\t\tlist_del(tmp);\n\t\tkfree(list_entry(tmp, struct elf_thread_status, list));\n\t}\n\n\t/* Free data possibly allocated by fill_files_note(): */\n\tif (info->notes_files)\n\t\tvfree(info->notes_files->data);\n\n\tkfree(info->prstatus);\n\tkfree(info->psinfo);\n\tkfree(info->notes);\n\tkfree(info->fpu);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tkfree(info->xfpu);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "fs"
          ],
          "line": 2303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_emit",
          "args": [
            "cprm",
            "shdr4extnum",
            "sizeof(*shdr4extnum)"
          ],
          "line": 2298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elf_core_write_extra_data",
          "args": [
            "cprm"
          ],
          "line": 2294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_skip",
          "args": [
            "cprm",
            "PAGE_SIZE"
          ],
          "line": 2288
        },
        "resolved": true,
        "details": {
          "function_name": "dump_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coredump.c",
          "lines": "721-741",
          "snippet": "int dump_skip(struct coredump_params *cprm, size_t nr)\n{\n\tstatic char zeroes[PAGE_SIZE];\n\tstruct file *file = cprm->file;\n\tif (file->f_op->llseek && file->f_op->llseek != no_llseek) {\n\t\tif (cprm->written + nr > cprm->limit)\n\t\t\treturn 0;\n\t\tif (dump_interrupted() ||\n\t\t    file->f_op->llseek(file, nr, SEEK_CUR) < 0)\n\t\t\treturn 0;\n\t\tcprm->written += nr;\n\t\treturn 1;\n\t} else {\n\t\twhile (nr > PAGE_SIZE) {\n\t\t\tif (!dump_emit(cprm, zeroes, PAGE_SIZE))\n\t\t\t\treturn 0;\n\t\t\tnr -= PAGE_SIZE;\n\t\t}\n\t\treturn dump_emit(cprm, zeroes, nr);\n\t}\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/exec.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/exec.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint dump_skip(struct coredump_params *cprm, size_t nr)\n{\n\tstatic char zeroes[PAGE_SIZE];\n\tstruct file *file = cprm->file;\n\tif (file->f_op->llseek && file->f_op->llseek != no_llseek) {\n\t\tif (cprm->written + nr > cprm->limit)\n\t\t\treturn 0;\n\t\tif (dump_interrupted() ||\n\t\t    file->f_op->llseek(file, nr, SEEK_CUR) < 0)\n\t\t\treturn 0;\n\t\tcprm->written += nr;\n\t\treturn 1;\n\t} else {\n\t\twhile (nr > PAGE_SIZE) {\n\t\t\tif (!dump_emit(cprm, zeroes, PAGE_SIZE))\n\t\t\t\treturn 0;\n\t\t\tnr -= PAGE_SIZE;\n\t\t}\n\t\treturn dump_emit(cprm, zeroes, nr);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 2286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 2285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_emit",
          "args": [
            "cprm",
            "kaddr",
            "PAGE_SIZE"
          ],
          "line": 2284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 2283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dump_page",
          "args": [
            "addr"
          ],
          "line": 2281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_vma",
          "args": [
            "vma",
            "gate_vma"
          ],
          "line": 2271
        },
        "resolved": true,
        "details": {
          "function_name": "next_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "2083-2094",
          "snippet": "static struct vm_area_struct *next_vma(struct vm_area_struct *this_vma,\n\t\t\t\t\tstruct vm_area_struct *gate_vma)\n{\n\tstruct vm_area_struct *ret;\n\n\tret = this_vma->vm_next;\n\tif (ret)\n\t\treturn ret;\n\tif (this_vma == gate_vma)\n\t\treturn NULL;\n\treturn gate_vma;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic struct vm_area_struct *next_vma(struct vm_area_struct *this_vma,\n\t\t\t\t\tstruct vm_area_struct *gate_vma)\n{\n\tstruct vm_area_struct *ret;\n\n\tret = this_vma->vm_next;\n\tif (ret)\n\t\treturn ret;\n\tif (this_vma == gate_vma)\n\t\treturn NULL;\n\treturn gate_vma;\n}"
        }
      },
      {
        "call_info": {
          "callee": "first_vma",
          "args": [
            "current",
            "gate_vma"
          ],
          "line": 2270
        },
        "resolved": true,
        "details": {
          "function_name": "first_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "2070-2078",
          "snippet": "static struct vm_area_struct *first_vma(struct task_struct *tsk,\n\t\t\t\t\tstruct vm_area_struct *gate_vma)\n{\n\tstruct vm_area_struct *ret = tsk->mm->mmap;\n\n\tif (ret)\n\t\treturn ret;\n\treturn gate_vma;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic struct vm_area_struct *first_vma(struct task_struct *tsk,\n\t\t\t\t\tstruct vm_area_struct *gate_vma)\n{\n\tstruct vm_area_struct *ret = tsk->mm->mmap;\n\n\tif (ret)\n\t\treturn ret;\n\treturn gate_vma;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elf_coredump_extra_notes_write",
          "args": [
            "cprm"
          ],
          "line": 2263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_note_info",
          "args": [
            "&info",
            "cprm"
          ],
          "line": 2260
        },
        "resolved": true,
        "details": {
          "function_name": "write_note_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "2024-2045",
          "snippet": "static int write_note_info(struct elf_note_info *info,\n\t\t\t   struct coredump_params *cprm)\n{\n\tint i;\n\tstruct list_head *t;\n\n\tfor (i = 0; i < info->numnote; i++)\n\t\tif (!writenote(info->notes + i, cprm))\n\t\t\treturn 0;\n\n\t/* write out the thread status notes section */\n\tlist_for_each(t, &info->thread_list) {\n\t\tstruct elf_thread_status *tmp =\n\t\t\t\tlist_entry(t, struct elf_thread_status, list);\n\n\t\tfor (i = 0; i < tmp->num_notes; i++)\n\t\t\tif (!writenote(&tmp->notes[i], cprm))\n\t\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int write_note_info(struct elf_note_info *info,\n\t\t\t   struct coredump_params *cprm)\n{\n\tint i;\n\tstruct list_head *t;\n\n\tfor (i = 0; i < info->numnote; i++)\n\t\tif (!writenote(info->notes + i, cprm))\n\t\t\treturn 0;\n\n\t/* write out the thread status notes section */\n\tlist_for_each(t, &info->thread_list) {\n\t\tstruct elf_thread_status *tmp =\n\t\t\t\tlist_entry(t, struct elf_thread_status, list);\n\n\t\tfor (i = 0; i < tmp->num_notes; i++)\n\t\t\tif (!writenote(&tmp->notes[i], cprm))\n\t\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elf_core_write_extra_phdrs",
          "args": [
            "cprm",
            "offset"
          ],
          "line": 2256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_emit",
          "args": [
            "cprm",
            "&phdr",
            "sizeof(phdr)"
          ],
          "line": 2252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_emit",
          "args": [
            "cprm",
            "phdr4note",
            "sizeof(*phdr4note)"
          ],
          "line": 2230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_emit",
          "args": [
            "cprm",
            "elf",
            "sizeof(*elf)"
          ],
          "line": 2227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill_extnum_info",
          "args": [
            "elf",
            "shdr4extnum",
            "e_shoff",
            "segs"
          ],
          "line": 2222
        },
        "resolved": true,
        "details": {
          "function_name": "fill_extnum_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "2096-2110",
          "snippet": "static void fill_extnum_info(struct elfhdr *elf, struct elf_shdr *shdr4extnum,\n\t\t\t     elf_addr_t e_shoff, int segs)\n{\n\telf->e_shoff = e_shoff;\n\telf->e_shentsize = sizeof(*shdr4extnum);\n\telf->e_shnum = 1;\n\telf->e_shstrndx = SHN_UNDEF;\n\n\tmemset(shdr4extnum, 0, sizeof(*shdr4extnum));\n\n\tshdr4extnum->sh_type = SHT_NULL;\n\tshdr4extnum->sh_size = elf->e_shnum;\n\tshdr4extnum->sh_link = elf->e_shstrndx;\n\tshdr4extnum->sh_info = segs;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void fill_extnum_info(struct elfhdr *elf, struct elf_shdr *shdr4extnum,\n\t\t\t     elf_addr_t e_shoff, int segs)\n{\n\telf->e_shoff = e_shoff;\n\telf->e_shentsize = sizeof(*shdr4extnum);\n\telf->e_shnum = 1;\n\telf->e_shstrndx = SHN_UNDEF;\n\n\tmemset(shdr4extnum, 0, sizeof(*shdr4extnum));\n\n\tshdr4extnum->sh_type = SHT_NULL;\n\tshdr4extnum->sh_size = elf->e_shnum;\n\tshdr4extnum->sh_link = elf->e_shstrndx;\n\tshdr4extnum->sh_info = segs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*shdr4extnum)",
            "GFP_KERNEL"
          ],
          "line": 2219
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elf_core_extra_data_size",
          "args": [],
          "line": 2215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_dump_size",
          "args": [
            "vma",
            "cprm->mm_flags"
          ],
          "line": 2209
        },
        "resolved": true,
        "details": {
          "function_name": "vma_dump_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "1232-1314",
          "snippet": "static unsigned long vma_dump_size(struct vm_area_struct *vma,\n\t\t\t\t   unsigned long mm_flags)\n{\n#define FILTER(type)\t(mm_flags & (1UL << MMF_DUMP_##type))\n\n\t/* always dump the vdso and vsyscall sections */\n\tif (always_dump_vma(vma))\n\t\tgoto whole;\n\n\tif (vma->vm_flags & VM_DONTDUMP)\n\t\treturn 0;\n\n\t/* Hugetlb memory check */\n\tif (vma->vm_flags & VM_HUGETLB) {\n\t\tif ((vma->vm_flags & VM_SHARED) && FILTER(HUGETLB_SHARED))\n\t\t\tgoto whole;\n\t\tif (!(vma->vm_flags & VM_SHARED) && FILTER(HUGETLB_PRIVATE))\n\t\t\tgoto whole;\n\t\treturn 0;\n\t}\n\n\t/* Do not dump I/O mapped devices or special mappings */\n\tif (vma->vm_flags & VM_IO)\n\t\treturn 0;\n\n\t/* By default, dump shared memory if mapped from an anonymous file. */\n\tif (vma->vm_flags & VM_SHARED) {\n\t\tif (file_inode(vma->vm_file)->i_nlink == 0 ?\n\t\t    FILTER(ANON_SHARED) : FILTER(MAPPED_SHARED))\n\t\t\tgoto whole;\n\t\treturn 0;\n\t}\n\n\t/* Dump segments that have been written to.  */\n\tif (vma->anon_vma && FILTER(ANON_PRIVATE))\n\t\tgoto whole;\n\tif (vma->vm_file == NULL)\n\t\treturn 0;\n\n\tif (FILTER(MAPPED_PRIVATE))\n\t\tgoto whole;\n\n\t/*\n\t * If this looks like the beginning of a DSO or executable mapping,\n\t * check for an ELF header.  If we find one, dump the first page to\n\t * aid in determining what was mapped here.\n\t */\n\tif (FILTER(ELF_HEADERS) &&\n\t    vma->vm_pgoff == 0 && (vma->vm_flags & VM_READ)) {\n\t\tu32 __user *header = (u32 __user *) vma->vm_start;\n\t\tu32 word;\n\t\tmm_segment_t fs = get_fs();\n\t\t/*\n\t\t * Doing it this way gets the constant folded by GCC.\n\t\t */\n\t\tunion {\n\t\t\tu32 cmp;\n\t\t\tchar elfmag[SELFMAG];\n\t\t} magic;\n\t\tBUILD_BUG_ON(SELFMAG != sizeof word);\n\t\tmagic.elfmag[EI_MAG0] = ELFMAG0;\n\t\tmagic.elfmag[EI_MAG1] = ELFMAG1;\n\t\tmagic.elfmag[EI_MAG2] = ELFMAG2;\n\t\tmagic.elfmag[EI_MAG3] = ELFMAG3;\n\t\t/*\n\t\t * Switch to the user \"segment\" for get_user(),\n\t\t * then put back what elf_core_dump() had in place.\n\t\t */\n\t\tset_fs(USER_DS);\n\t\tif (unlikely(get_user(word, header)))\n\t\t\tword = 0;\n\t\tset_fs(fs);\n\t\tif (word == magic.cmp)\n\t\t\treturn PAGE_SIZE;\n\t}\n\n#undef\tFILTER\n\n\treturn 0;\n\nwhole:\n\treturn vma->vm_end - vma->vm_start;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define elf_core_dump\tNULL"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define elf_core_dump\tNULL\n\nstatic unsigned long vma_dump_size(struct vm_area_struct *vma,\n\t\t\t\t   unsigned long mm_flags)\n{\n#define FILTER(type)\t(mm_flags & (1UL << MMF_DUMP_##type))\n\n\t/* always dump the vdso and vsyscall sections */\n\tif (always_dump_vma(vma))\n\t\tgoto whole;\n\n\tif (vma->vm_flags & VM_DONTDUMP)\n\t\treturn 0;\n\n\t/* Hugetlb memory check */\n\tif (vma->vm_flags & VM_HUGETLB) {\n\t\tif ((vma->vm_flags & VM_SHARED) && FILTER(HUGETLB_SHARED))\n\t\t\tgoto whole;\n\t\tif (!(vma->vm_flags & VM_SHARED) && FILTER(HUGETLB_PRIVATE))\n\t\t\tgoto whole;\n\t\treturn 0;\n\t}\n\n\t/* Do not dump I/O mapped devices or special mappings */\n\tif (vma->vm_flags & VM_IO)\n\t\treturn 0;\n\n\t/* By default, dump shared memory if mapped from an anonymous file. */\n\tif (vma->vm_flags & VM_SHARED) {\n\t\tif (file_inode(vma->vm_file)->i_nlink == 0 ?\n\t\t    FILTER(ANON_SHARED) : FILTER(MAPPED_SHARED))\n\t\t\tgoto whole;\n\t\treturn 0;\n\t}\n\n\t/* Dump segments that have been written to.  */\n\tif (vma->anon_vma && FILTER(ANON_PRIVATE))\n\t\tgoto whole;\n\tif (vma->vm_file == NULL)\n\t\treturn 0;\n\n\tif (FILTER(MAPPED_PRIVATE))\n\t\tgoto whole;\n\n\t/*\n\t * If this looks like the beginning of a DSO or executable mapping,\n\t * check for an ELF header.  If we find one, dump the first page to\n\t * aid in determining what was mapped here.\n\t */\n\tif (FILTER(ELF_HEADERS) &&\n\t    vma->vm_pgoff == 0 && (vma->vm_flags & VM_READ)) {\n\t\tu32 __user *header = (u32 __user *) vma->vm_start;\n\t\tu32 word;\n\t\tmm_segment_t fs = get_fs();\n\t\t/*\n\t\t * Doing it this way gets the constant folded by GCC.\n\t\t */\n\t\tunion {\n\t\t\tu32 cmp;\n\t\t\tchar elfmag[SELFMAG];\n\t\t} magic;\n\t\tBUILD_BUG_ON(SELFMAG != sizeof word);\n\t\tmagic.elfmag[EI_MAG0] = ELFMAG0;\n\t\tmagic.elfmag[EI_MAG1] = ELFMAG1;\n\t\tmagic.elfmag[EI_MAG2] = ELFMAG2;\n\t\tmagic.elfmag[EI_MAG3] = ELFMAG3;\n\t\t/*\n\t\t * Switch to the user \"segment\" for get_user(),\n\t\t * then put back what elf_core_dump() had in place.\n\t\t */\n\t\tset_fs(USER_DS);\n\t\tif (unlikely(get_user(word, header)))\n\t\t\tword = 0;\n\t\tset_fs(fs);\n\t\tif (word == magic.cmp)\n\t\t\treturn PAGE_SIZE;\n\t}\n\n#undef\tFILTER\n\n\treturn 0;\n\nwhole:\n\treturn vma->vm_end - vma->vm_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "segs - 1",
            "sizeof(*vma_filesz)",
            "GFP_KERNEL"
          ],
          "line": 2201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "offset",
            "ELF_EXEC_PAGESIZE"
          ],
          "line": 2199
        },
        "resolved": true,
        "details": {
          "function_name": "roundup_64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "333-338",
          "snippet": "static inline __uint64_t roundup_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline __uint64_t roundup_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_elf_note_phdr",
          "args": [
            "phdr4note",
            "sz",
            "offset"
          ],
          "line": 2195
        },
        "resolved": true,
        "details": {
          "function_name": "fill_elf_note_phdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "1371-1382",
          "snippet": "static void fill_elf_note_phdr(struct elf_phdr *phdr, int sz, loff_t offset)\n{\n\tphdr->p_type = PT_NOTE;\n\tphdr->p_offset = offset;\n\tphdr->p_vaddr = 0;\n\tphdr->p_paddr = 0;\n\tphdr->p_filesz = sz;\n\tphdr->p_memsz = 0;\n\tphdr->p_flags = 0;\n\tphdr->p_align = 0;\n\treturn;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);\n\nstatic void fill_elf_note_phdr(struct elf_phdr *phdr, int sz, loff_t offset)\n{\n\tphdr->p_type = PT_NOTE;\n\tphdr->p_offset = offset;\n\tphdr->p_vaddr = 0;\n\tphdr->p_paddr = 0;\n\tphdr->p_filesz = sz;\n\tphdr->p_memsz = 0;\n\tphdr->p_flags = 0;\n\tphdr->p_align = 0;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elf_coredump_extra_notes_size",
          "args": [],
          "line": 2189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_note_info_size",
          "args": [
            "&info"
          ],
          "line": 2187
        },
        "resolved": true,
        "details": {
          "function_name": "get_note_info_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "2011-2022",
          "snippet": "static size_t get_note_info_size(struct elf_note_info *info)\n{\n\tint sz = 0;\n\tint i;\n\n\tfor (i = 0; i < info->numnote; i++)\n\t\tsz += notesize(info->notes + i);\n\n\tsz += info->thread_status_size;\n\n\treturn sz;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic size_t get_note_info_size(struct elf_note_info *info)\n{\n\tint sz = 0;\n\tint i;\n\n\tfor (i = 0; i < info->numnote; i++)\n\t\tsz += notesize(info->notes + i);\n\n\tsz += info->thread_status_size;\n\n\treturn sz;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "KERNEL_DS"
          ],
          "line": 2180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fs",
          "args": [],
          "line": 2179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill_note_info",
          "args": [
            "elf",
            "e_phnum",
            "&info",
            "cprm->siginfo",
            "cprm->regs"
          ],
          "line": 2174
        },
        "resolved": true,
        "details": {
          "function_name": "fill_note_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "1939-2009",
          "snippet": "static int fill_note_info(struct elfhdr *elf, int phdrs,\n\t\t\t  struct elf_note_info *info,\n\t\t\t  const siginfo_t *siginfo, struct pt_regs *regs)\n{\n\tstruct list_head *t;\n\tstruct core_thread *ct;\n\tstruct elf_thread_status *ets;\n\n\tif (!elf_note_info_init(info))\n\t\treturn 0;\n\n\tfor (ct = current->mm->core_state->dumper.next;\n\t\t\t\t\tct; ct = ct->next) {\n\t\tets = kzalloc(sizeof(*ets), GFP_KERNEL);\n\t\tif (!ets)\n\t\t\treturn 0;\n\n\t\tets->thread = ct->task;\n\t\tlist_add(&ets->list, &info->thread_list);\n\t}\n\n\tlist_for_each(t, &info->thread_list) {\n\t\tint sz;\n\n\t\tets = list_entry(t, struct elf_thread_status, list);\n\t\tsz = elf_dump_thread_status(siginfo->si_signo, ets);\n\t\tinfo->thread_status_size += sz;\n\t}\n\t/* now collect the dump for the current */\n\tmemset(info->prstatus, 0, sizeof(*info->prstatus));\n\tfill_prstatus(info->prstatus, current, siginfo->si_signo);\n\telf_core_copy_regs(&info->prstatus->pr_reg, regs);\n\n\t/* Set up header */\n\tfill_elf_header(elf, phdrs, ELF_ARCH, ELF_CORE_EFLAGS);\n\n\t/*\n\t * Set up the notes in similar form to SVR4 core dumps made\n\t * with info from their /proc.\n\t */\n\n\tfill_note(info->notes + 0, \"CORE\", NT_PRSTATUS,\n\t\t  sizeof(*info->prstatus), info->prstatus);\n\tfill_psinfo(info->psinfo, current->group_leader, current->mm);\n\tfill_note(info->notes + 1, \"CORE\", NT_PRPSINFO,\n\t\t  sizeof(*info->psinfo), info->psinfo);\n\n\tfill_siginfo_note(info->notes + 2, &info->csigdata, siginfo);\n\tfill_auxv_note(info->notes + 3, current->mm);\n\tinfo->numnote = 4;\n\n\tif (fill_files_note(info->notes + info->numnote) == 0) {\n\t\tinfo->notes_files = info->notes + info->numnote;\n\t\tinfo->numnote++;\n\t}\n\n\t/* Try to dump the FPU. */\n\tinfo->prstatus->pr_fpvalid = elf_core_copy_task_fpregs(current, regs,\n\t\t\t\t\t\t\t       info->fpu);\n\tif (info->prstatus->pr_fpvalid)\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"CORE\", NT_PRFPREG, sizeof(*info->fpu), info->fpu);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(current, info->xfpu))\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(*info->xfpu), info->xfpu);\n#endif\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define ELF_CORE_EFLAGS\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define ELF_CORE_EFLAGS\t0\n\nstatic int fill_note_info(struct elfhdr *elf, int phdrs,\n\t\t\t  struct elf_note_info *info,\n\t\t\t  const siginfo_t *siginfo, struct pt_regs *regs)\n{\n\tstruct list_head *t;\n\tstruct core_thread *ct;\n\tstruct elf_thread_status *ets;\n\n\tif (!elf_note_info_init(info))\n\t\treturn 0;\n\n\tfor (ct = current->mm->core_state->dumper.next;\n\t\t\t\t\tct; ct = ct->next) {\n\t\tets = kzalloc(sizeof(*ets), GFP_KERNEL);\n\t\tif (!ets)\n\t\t\treturn 0;\n\n\t\tets->thread = ct->task;\n\t\tlist_add(&ets->list, &info->thread_list);\n\t}\n\n\tlist_for_each(t, &info->thread_list) {\n\t\tint sz;\n\n\t\tets = list_entry(t, struct elf_thread_status, list);\n\t\tsz = elf_dump_thread_status(siginfo->si_signo, ets);\n\t\tinfo->thread_status_size += sz;\n\t}\n\t/* now collect the dump for the current */\n\tmemset(info->prstatus, 0, sizeof(*info->prstatus));\n\tfill_prstatus(info->prstatus, current, siginfo->si_signo);\n\telf_core_copy_regs(&info->prstatus->pr_reg, regs);\n\n\t/* Set up header */\n\tfill_elf_header(elf, phdrs, ELF_ARCH, ELF_CORE_EFLAGS);\n\n\t/*\n\t * Set up the notes in similar form to SVR4 core dumps made\n\t * with info from their /proc.\n\t */\n\n\tfill_note(info->notes + 0, \"CORE\", NT_PRSTATUS,\n\t\t  sizeof(*info->prstatus), info->prstatus);\n\tfill_psinfo(info->psinfo, current->group_leader, current->mm);\n\tfill_note(info->notes + 1, \"CORE\", NT_PRPSINFO,\n\t\t  sizeof(*info->psinfo), info->psinfo);\n\n\tfill_siginfo_note(info->notes + 2, &info->csigdata, siginfo);\n\tfill_auxv_note(info->notes + 3, current->mm);\n\tinfo->numnote = 4;\n\n\tif (fill_files_note(info->notes + info->numnote) == 0) {\n\t\tinfo->notes_files = info->notes + info->numnote;\n\t\tinfo->numnote++;\n\t}\n\n\t/* Try to dump the FPU. */\n\tinfo->prstatus->pr_fpvalid = elf_core_copy_task_fpregs(current, regs,\n\t\t\t\t\t\t\t       info->fpu);\n\tif (info->prstatus->pr_fpvalid)\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"CORE\", NT_PRFPREG, sizeof(*info->fpu), info->fpu);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(current, info->xfpu))\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(*info->xfpu), info->xfpu);\n#endif\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_gate_vma",
          "args": [
            "current->mm"
          ],
          "line": 2158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elf_core_extra_phdrs",
          "args": [],
          "line": 2156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define elf_core_dump\tNULL\n\nstatic unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);\n\nstatic int elf_core_dump(struct coredump_params *cprm)\n{\n\tint has_dumped = 0;\n\tmm_segment_t fs;\n\tint segs, i;\n\tsize_t vma_data_size = 0;\n\tstruct vm_area_struct *vma, *gate_vma;\n\tstruct elfhdr *elf = NULL;\n\tloff_t offset = 0, dataoff;\n\tstruct elf_note_info info = { };\n\tstruct elf_phdr *phdr4note = NULL;\n\tstruct elf_shdr *shdr4extnum = NULL;\n\tElf_Half e_phnum;\n\telf_addr_t e_shoff;\n\telf_addr_t *vma_filesz = NULL;\n\n\t/*\n\t * We no longer stop all VM operations.\n\t * \n\t * This is because those proceses that could possibly change map_count\n\t * or the mmap / vma pages are now blocked in do_exit on current\n\t * finishing this core dump.\n\t *\n\t * Only ptrace can touch these memory addresses, but it doesn't change\n\t * the map_count or the pages allocated. So no possibility of crashing\n\t * exists while dumping the mm->vm_next areas to the core file.\n\t */\n  \n\t/* alloc memory for large data structures: too large to be on stack */\n\telf = kmalloc(sizeof(*elf), GFP_KERNEL);\n\tif (!elf)\n\t\tgoto out;\n\t/*\n\t * The number of segs are recored into ELF header as 16bit value.\n\t * Please check DEFAULT_MAX_MAP_COUNT definition when you modify here.\n\t */\n\tsegs = current->mm->map_count;\n\tsegs += elf_core_extra_phdrs();\n\n\tgate_vma = get_gate_vma(current->mm);\n\tif (gate_vma != NULL)\n\t\tsegs++;\n\n\t/* for notes section */\n\tsegs++;\n\n\t/* If segs > PN_XNUM(0xffff), then e_phnum overflows. To avoid\n\t * this, kernel supports extended numbering. Have a look at\n\t * include/linux/elf.h for further information. */\n\te_phnum = segs > PN_XNUM ? PN_XNUM : segs;\n\n\t/*\n\t * Collect all the non-memory information about the process for the\n\t * notes.  This also sets up the file header.\n\t */\n\tif (!fill_note_info(elf, e_phnum, &info, cprm->siginfo, cprm->regs))\n\t\tgoto cleanup;\n\n\thas_dumped = 1;\n\n\tfs = get_fs();\n\tset_fs(KERNEL_DS);\n\n\toffset += sizeof(*elf);\t\t\t\t/* Elf header */\n\toffset += segs * sizeof(struct elf_phdr);\t/* Program headers */\n\n\t/* Write notes phdr entry */\n\t{\n\t\tsize_t sz = get_note_info_size(&info);\n\n\t\tsz += elf_coredump_extra_notes_size();\n\n\t\tphdr4note = kmalloc(sizeof(*phdr4note), GFP_KERNEL);\n\t\tif (!phdr4note)\n\t\t\tgoto end_coredump;\n\n\t\tfill_elf_note_phdr(phdr4note, sz, offset);\n\t\toffset += sz;\n\t}\n\n\tdataoff = offset = roundup(offset, ELF_EXEC_PAGESIZE);\n\n\tvma_filesz = kmalloc_array(segs - 1, sizeof(*vma_filesz), GFP_KERNEL);\n\tif (!vma_filesz)\n\t\tgoto end_coredump;\n\n\tfor (i = 0, vma = first_vma(current, gate_vma); vma != NULL;\n\t\t\tvma = next_vma(vma, gate_vma)) {\n\t\tunsigned long dump_size;\n\n\t\tdump_size = vma_dump_size(vma, cprm->mm_flags);\n\t\tvma_filesz[i++] = dump_size;\n\t\tvma_data_size += dump_size;\n\t}\n\n\toffset += vma_data_size;\n\toffset += elf_core_extra_data_size();\n\te_shoff = offset;\n\n\tif (e_phnum == PN_XNUM) {\n\t\tshdr4extnum = kmalloc(sizeof(*shdr4extnum), GFP_KERNEL);\n\t\tif (!shdr4extnum)\n\t\t\tgoto end_coredump;\n\t\tfill_extnum_info(elf, shdr4extnum, e_shoff, segs);\n\t}\n\n\toffset = dataoff;\n\n\tif (!dump_emit(cprm, elf, sizeof(*elf)))\n\t\tgoto end_coredump;\n\n\tif (!dump_emit(cprm, phdr4note, sizeof(*phdr4note)))\n\t\tgoto end_coredump;\n\n\t/* Write program headers for segments dump */\n\tfor (i = 0, vma = first_vma(current, gate_vma); vma != NULL;\n\t\t\tvma = next_vma(vma, gate_vma)) {\n\t\tstruct elf_phdr phdr;\n\n\t\tphdr.p_type = PT_LOAD;\n\t\tphdr.p_offset = offset;\n\t\tphdr.p_vaddr = vma->vm_start;\n\t\tphdr.p_paddr = 0;\n\t\tphdr.p_filesz = vma_filesz[i++];\n\t\tphdr.p_memsz = vma->vm_end - vma->vm_start;\n\t\toffset += phdr.p_filesz;\n\t\tphdr.p_flags = vma->vm_flags & VM_READ ? PF_R : 0;\n\t\tif (vma->vm_flags & VM_WRITE)\n\t\t\tphdr.p_flags |= PF_W;\n\t\tif (vma->vm_flags & VM_EXEC)\n\t\t\tphdr.p_flags |= PF_X;\n\t\tphdr.p_align = ELF_EXEC_PAGESIZE;\n\n\t\tif (!dump_emit(cprm, &phdr, sizeof(phdr)))\n\t\t\tgoto end_coredump;\n\t}\n\n\tif (!elf_core_write_extra_phdrs(cprm, offset))\n\t\tgoto end_coredump;\n\n \t/* write out the notes section */\n\tif (!write_note_info(&info, cprm))\n\t\tgoto end_coredump;\n\n\tif (elf_coredump_extra_notes_write(cprm))\n\t\tgoto end_coredump;\n\n\t/* Align to page */\n\tif (!dump_skip(cprm, dataoff - cprm->written))\n\t\tgoto end_coredump;\n\n\tfor (i = 0, vma = first_vma(current, gate_vma); vma != NULL;\n\t\t\tvma = next_vma(vma, gate_vma)) {\n\t\tunsigned long addr;\n\t\tunsigned long end;\n\n\t\tend = vma->vm_start + vma_filesz[i++];\n\n\t\tfor (addr = vma->vm_start; addr < end; addr += PAGE_SIZE) {\n\t\t\tstruct page *page;\n\t\t\tint stop;\n\n\t\t\tpage = get_dump_page(addr);\n\t\t\tif (page) {\n\t\t\t\tvoid *kaddr = kmap(page);\n\t\t\t\tstop = !dump_emit(cprm, kaddr, PAGE_SIZE);\n\t\t\t\tkunmap(page);\n\t\t\t\tpage_cache_release(page);\n\t\t\t} else\n\t\t\t\tstop = !dump_skip(cprm, PAGE_SIZE);\n\t\t\tif (stop)\n\t\t\t\tgoto end_coredump;\n\t\t}\n\t}\n\n\tif (!elf_core_write_extra_data(cprm))\n\t\tgoto end_coredump;\n\n\tif (e_phnum == PN_XNUM) {\n\t\tif (!dump_emit(cprm, shdr4extnum, sizeof(*shdr4extnum)))\n\t\t\tgoto end_coredump;\n\t}\n\nend_coredump:\n\tset_fs(fs);\n\ncleanup:\n\tfree_note_info(&info);\n\tkfree(shdr4extnum);\n\tkfree(vma_filesz);\n\tkfree(phdr4note);\n\tkfree(elf);\nout:\n\treturn has_dumped;\n}"
  },
  {
    "function_name": "fill_extnum_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
    "lines": "2096-2110",
    "snippet": "static void fill_extnum_info(struct elfhdr *elf, struct elf_shdr *shdr4extnum,\n\t\t\t     elf_addr_t e_shoff, int segs)\n{\n\telf->e_shoff = e_shoff;\n\telf->e_shentsize = sizeof(*shdr4extnum);\n\telf->e_shnum = 1;\n\telf->e_shstrndx = SHN_UNDEF;\n\n\tmemset(shdr4extnum, 0, sizeof(*shdr4extnum));\n\n\tshdr4extnum->sh_type = SHT_NULL;\n\tshdr4extnum->sh_size = elf->e_shnum;\n\tshdr4extnum->sh_link = elf->e_shstrndx;\n\tshdr4extnum->sh_info = segs;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "shdr4extnum",
            "0",
            "sizeof(*shdr4extnum)"
          ],
          "line": 2104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void fill_extnum_info(struct elfhdr *elf, struct elf_shdr *shdr4extnum,\n\t\t\t     elf_addr_t e_shoff, int segs)\n{\n\telf->e_shoff = e_shoff;\n\telf->e_shentsize = sizeof(*shdr4extnum);\n\telf->e_shnum = 1;\n\telf->e_shstrndx = SHN_UNDEF;\n\n\tmemset(shdr4extnum, 0, sizeof(*shdr4extnum));\n\n\tshdr4extnum->sh_type = SHT_NULL;\n\tshdr4extnum->sh_size = elf->e_shnum;\n\tshdr4extnum->sh_link = elf->e_shstrndx;\n\tshdr4extnum->sh_info = segs;\n}"
  },
  {
    "function_name": "next_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
    "lines": "2083-2094",
    "snippet": "static struct vm_area_struct *next_vma(struct vm_area_struct *this_vma,\n\t\t\t\t\tstruct vm_area_struct *gate_vma)\n{\n\tstruct vm_area_struct *ret;\n\n\tret = this_vma->vm_next;\n\tif (ret)\n\t\treturn ret;\n\tif (this_vma == gate_vma)\n\t\treturn NULL;\n\treturn gate_vma;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic struct vm_area_struct *next_vma(struct vm_area_struct *this_vma,\n\t\t\t\t\tstruct vm_area_struct *gate_vma)\n{\n\tstruct vm_area_struct *ret;\n\n\tret = this_vma->vm_next;\n\tif (ret)\n\t\treturn ret;\n\tif (this_vma == gate_vma)\n\t\treturn NULL;\n\treturn gate_vma;\n}"
  },
  {
    "function_name": "first_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
    "lines": "2070-2078",
    "snippet": "static struct vm_area_struct *first_vma(struct task_struct *tsk,\n\t\t\t\t\tstruct vm_area_struct *gate_vma)\n{\n\tstruct vm_area_struct *ret = tsk->mm->mmap;\n\n\tif (ret)\n\t\treturn ret;\n\treturn gate_vma;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic struct vm_area_struct *first_vma(struct task_struct *tsk,\n\t\t\t\t\tstruct vm_area_struct *gate_vma)\n{\n\tstruct vm_area_struct *ret = tsk->mm->mmap;\n\n\tif (ret)\n\t\treturn ret;\n\treturn gate_vma;\n}"
  },
  {
    "function_name": "free_note_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
    "lines": "2047-2066",
    "snippet": "static void free_note_info(struct elf_note_info *info)\n{\n\twhile (!list_empty(&info->thread_list)) {\n\t\tstruct list_head *tmp = info->thread_list.next;\n\t\tlist_del(tmp);\n\t\tkfree(list_entry(tmp, struct elf_thread_status, list));\n\t}\n\n\t/* Free data possibly allocated by fill_files_note(): */\n\tif (info->notes_files)\n\t\tvfree(info->notes_files->data);\n\n\tkfree(info->prstatus);\n\tkfree(info->psinfo);\n\tkfree(info->notes);\n\tkfree(info->fpu);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tkfree(info->xfpu);\n#endif\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "info->xfpu"
          ],
          "line": 2064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "info->fpu"
          ],
          "line": 2062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "info->notes"
          ],
          "line": 2061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "info->psinfo"
          ],
          "line": 2060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "info->prstatus"
          ],
          "line": 2059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "info->notes_files->data"
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "tmp"
          ],
          "line": 2051
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&info->thread_list"
          ],
          "line": 2049
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void free_note_info(struct elf_note_info *info)\n{\n\twhile (!list_empty(&info->thread_list)) {\n\t\tstruct list_head *tmp = info->thread_list.next;\n\t\tlist_del(tmp);\n\t\tkfree(list_entry(tmp, struct elf_thread_status, list));\n\t}\n\n\t/* Free data possibly allocated by fill_files_note(): */\n\tif (info->notes_files)\n\t\tvfree(info->notes_files->data);\n\n\tkfree(info->prstatus);\n\tkfree(info->psinfo);\n\tkfree(info->notes);\n\tkfree(info->fpu);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tkfree(info->xfpu);\n#endif\n}"
  },
  {
    "function_name": "write_note_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
    "lines": "2024-2045",
    "snippet": "static int write_note_info(struct elf_note_info *info,\n\t\t\t   struct coredump_params *cprm)\n{\n\tint i;\n\tstruct list_head *t;\n\n\tfor (i = 0; i < info->numnote; i++)\n\t\tif (!writenote(info->notes + i, cprm))\n\t\t\treturn 0;\n\n\t/* write out the thread status notes section */\n\tlist_for_each(t, &info->thread_list) {\n\t\tstruct elf_thread_status *tmp =\n\t\t\t\tlist_entry(t, struct elf_thread_status, list);\n\n\t\tfor (i = 0; i < tmp->num_notes; i++)\n\t\t\tif (!writenote(&tmp->notes[i], cprm))\n\t\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writenote",
          "args": [
            "&tmp->notes[i]",
            "cprm"
          ],
          "line": 2040
        },
        "resolved": true,
        "details": {
          "function_name": "writenote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "1336-1346",
          "snippet": "static int writenote(struct memelfnote *men, struct coredump_params *cprm)\n{\n\tstruct elf_note en;\n\ten.n_namesz = strlen(men->name) + 1;\n\ten.n_descsz = men->datasz;\n\ten.n_type = men->type;\n\n\treturn dump_emit(cprm, &en, sizeof(en)) &&\n\t    dump_emit(cprm, men->name, en.n_namesz) && dump_align(cprm, 4) &&\n\t    dump_emit(cprm, men->data, men->datasz) && dump_align(cprm, 4);\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int writenote(struct memelfnote *men, struct coredump_params *cprm)\n{\n\tstruct elf_note en;\n\ten.n_namesz = strlen(men->name) + 1;\n\ten.n_descsz = men->datasz;\n\ten.n_type = men->type;\n\n\treturn dump_emit(cprm, &en, sizeof(en)) &&\n\t    dump_emit(cprm, men->name, en.n_namesz) && dump_align(cprm, 4) &&\n\t    dump_emit(cprm, men->data, men->datasz) && dump_align(cprm, 4);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "t",
            "structelf_thread_status",
            "list"
          ],
          "line": 2037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "t",
            "&info->thread_list"
          ],
          "line": 2035
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int write_note_info(struct elf_note_info *info,\n\t\t\t   struct coredump_params *cprm)\n{\n\tint i;\n\tstruct list_head *t;\n\n\tfor (i = 0; i < info->numnote; i++)\n\t\tif (!writenote(info->notes + i, cprm))\n\t\t\treturn 0;\n\n\t/* write out the thread status notes section */\n\tlist_for_each(t, &info->thread_list) {\n\t\tstruct elf_thread_status *tmp =\n\t\t\t\tlist_entry(t, struct elf_thread_status, list);\n\n\t\tfor (i = 0; i < tmp->num_notes; i++)\n\t\t\tif (!writenote(&tmp->notes[i], cprm))\n\t\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "get_note_info_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
    "lines": "2011-2022",
    "snippet": "static size_t get_note_info_size(struct elf_note_info *info)\n{\n\tint sz = 0;\n\tint i;\n\n\tfor (i = 0; i < info->numnote; i++)\n\t\tsz += notesize(info->notes + i);\n\n\tsz += info->thread_status_size;\n\n\treturn sz;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "notesize",
          "args": [
            "info->notes + i"
          ],
          "line": 2017
        },
        "resolved": true,
        "details": {
          "function_name": "notesize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "1325-1334",
          "snippet": "static int notesize(struct memelfnote *en)\n{\n\tint sz;\n\n\tsz = sizeof(struct elf_note);\n\tsz += roundup(strlen(en->name) + 1, 4);\n\tsz += roundup(en->datasz, 4);\n\n\treturn sz;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int notesize(struct memelfnote *en)\n{\n\tint sz;\n\n\tsz = sizeof(struct elf_note);\n\tsz += roundup(strlen(en->name) + 1, 4);\n\tsz += roundup(en->datasz, 4);\n\n\treturn sz;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic size_t get_note_info_size(struct elf_note_info *info)\n{\n\tint sz = 0;\n\tint i;\n\n\tfor (i = 0; i < info->numnote; i++)\n\t\tsz += notesize(info->notes + i);\n\n\tsz += info->thread_status_size;\n\n\treturn sz;\n}"
  },
  {
    "function_name": "fill_note_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
    "lines": "1939-2009",
    "snippet": "static int fill_note_info(struct elfhdr *elf, int phdrs,\n\t\t\t  struct elf_note_info *info,\n\t\t\t  const siginfo_t *siginfo, struct pt_regs *regs)\n{\n\tstruct list_head *t;\n\tstruct core_thread *ct;\n\tstruct elf_thread_status *ets;\n\n\tif (!elf_note_info_init(info))\n\t\treturn 0;\n\n\tfor (ct = current->mm->core_state->dumper.next;\n\t\t\t\t\tct; ct = ct->next) {\n\t\tets = kzalloc(sizeof(*ets), GFP_KERNEL);\n\t\tif (!ets)\n\t\t\treturn 0;\n\n\t\tets->thread = ct->task;\n\t\tlist_add(&ets->list, &info->thread_list);\n\t}\n\n\tlist_for_each(t, &info->thread_list) {\n\t\tint sz;\n\n\t\tets = list_entry(t, struct elf_thread_status, list);\n\t\tsz = elf_dump_thread_status(siginfo->si_signo, ets);\n\t\tinfo->thread_status_size += sz;\n\t}\n\t/* now collect the dump for the current */\n\tmemset(info->prstatus, 0, sizeof(*info->prstatus));\n\tfill_prstatus(info->prstatus, current, siginfo->si_signo);\n\telf_core_copy_regs(&info->prstatus->pr_reg, regs);\n\n\t/* Set up header */\n\tfill_elf_header(elf, phdrs, ELF_ARCH, ELF_CORE_EFLAGS);\n\n\t/*\n\t * Set up the notes in similar form to SVR4 core dumps made\n\t * with info from their /proc.\n\t */\n\n\tfill_note(info->notes + 0, \"CORE\", NT_PRSTATUS,\n\t\t  sizeof(*info->prstatus), info->prstatus);\n\tfill_psinfo(info->psinfo, current->group_leader, current->mm);\n\tfill_note(info->notes + 1, \"CORE\", NT_PRPSINFO,\n\t\t  sizeof(*info->psinfo), info->psinfo);\n\n\tfill_siginfo_note(info->notes + 2, &info->csigdata, siginfo);\n\tfill_auxv_note(info->notes + 3, current->mm);\n\tinfo->numnote = 4;\n\n\tif (fill_files_note(info->notes + info->numnote) == 0) {\n\t\tinfo->notes_files = info->notes + info->numnote;\n\t\tinfo->numnote++;\n\t}\n\n\t/* Try to dump the FPU. */\n\tinfo->prstatus->pr_fpvalid = elf_core_copy_task_fpregs(current, regs,\n\t\t\t\t\t\t\t       info->fpu);\n\tif (info->prstatus->pr_fpvalid)\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"CORE\", NT_PRFPREG, sizeof(*info->fpu), info->fpu);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(current, info->xfpu))\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(*info->xfpu), info->xfpu);\n#endif\n\n\treturn 1;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define ELF_CORE_EFLAGS\t0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fill_note",
          "args": [
            "info->notes + info->numnote++",
            "\"LINUX\"",
            "ELF_CORE_XFPREG_TYPE",
            "sizeof(*info->xfpu)",
            "info->xfpu"
          ],
          "line": 2003
        },
        "resolved": true,
        "details": {
          "function_name": "fill_note_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "1939-2009",
          "snippet": "static int fill_note_info(struct elfhdr *elf, int phdrs,\n\t\t\t  struct elf_note_info *info,\n\t\t\t  const siginfo_t *siginfo, struct pt_regs *regs)\n{\n\tstruct list_head *t;\n\tstruct core_thread *ct;\n\tstruct elf_thread_status *ets;\n\n\tif (!elf_note_info_init(info))\n\t\treturn 0;\n\n\tfor (ct = current->mm->core_state->dumper.next;\n\t\t\t\t\tct; ct = ct->next) {\n\t\tets = kzalloc(sizeof(*ets), GFP_KERNEL);\n\t\tif (!ets)\n\t\t\treturn 0;\n\n\t\tets->thread = ct->task;\n\t\tlist_add(&ets->list, &info->thread_list);\n\t}\n\n\tlist_for_each(t, &info->thread_list) {\n\t\tint sz;\n\n\t\tets = list_entry(t, struct elf_thread_status, list);\n\t\tsz = elf_dump_thread_status(siginfo->si_signo, ets);\n\t\tinfo->thread_status_size += sz;\n\t}\n\t/* now collect the dump for the current */\n\tmemset(info->prstatus, 0, sizeof(*info->prstatus));\n\tfill_prstatus(info->prstatus, current, siginfo->si_signo);\n\telf_core_copy_regs(&info->prstatus->pr_reg, regs);\n\n\t/* Set up header */\n\tfill_elf_header(elf, phdrs, ELF_ARCH, ELF_CORE_EFLAGS);\n\n\t/*\n\t * Set up the notes in similar form to SVR4 core dumps made\n\t * with info from their /proc.\n\t */\n\n\tfill_note(info->notes + 0, \"CORE\", NT_PRSTATUS,\n\t\t  sizeof(*info->prstatus), info->prstatus);\n\tfill_psinfo(info->psinfo, current->group_leader, current->mm);\n\tfill_note(info->notes + 1, \"CORE\", NT_PRPSINFO,\n\t\t  sizeof(*info->psinfo), info->psinfo);\n\n\tfill_siginfo_note(info->notes + 2, &info->csigdata, siginfo);\n\tfill_auxv_note(info->notes + 3, current->mm);\n\tinfo->numnote = 4;\n\n\tif (fill_files_note(info->notes + info->numnote) == 0) {\n\t\tinfo->notes_files = info->notes + info->numnote;\n\t\tinfo->numnote++;\n\t}\n\n\t/* Try to dump the FPU. */\n\tinfo->prstatus->pr_fpvalid = elf_core_copy_task_fpregs(current, regs,\n\t\t\t\t\t\t\t       info->fpu);\n\tif (info->prstatus->pr_fpvalid)\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"CORE\", NT_PRFPREG, sizeof(*info->fpu), info->fpu);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(current, info->xfpu))\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(*info->xfpu), info->xfpu);\n#endif\n\n\treturn 1;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "elf_core_copy_task_xfpregs",
          "args": [
            "current",
            "info->xfpu"
          ],
          "line": 2002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elf_core_copy_task_fpregs",
          "args": [
            "current",
            "regs",
            "info->fpu"
          ],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill_files_note",
          "args": [
            "info->notes + info->numnote"
          ],
          "line": 1990
        },
        "resolved": true,
        "details": {
          "function_name": "fill_files_note",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "1506-1579",
          "snippet": "static int fill_files_note(struct memelfnote *note)\n{\n\tstruct vm_area_struct *vma;\n\tunsigned count, size, names_ofs, remaining, n;\n\tuser_long_t *data;\n\tuser_long_t *start_end_ofs;\n\tchar *name_base, *name_curpos;\n\n\t/* *Estimated* file count and total data size needed */\n\tcount = current->mm->map_count;\n\tsize = count * 64;\n\n\tnames_ofs = (2 + 3 * count) * sizeof(data[0]);\n alloc:\n\tif (size >= MAX_FILE_NOTE_SIZE) /* paranoia check */\n\t\treturn -EINVAL;\n\tsize = round_up(size, PAGE_SIZE);\n\tdata = vmalloc(size);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tstart_end_ofs = data + 2;\n\tname_base = name_curpos = ((char *)data) + names_ofs;\n\tremaining = size - names_ofs;\n\tcount = 0;\n\tfor (vma = current->mm->mmap; vma != NULL; vma = vma->vm_next) {\n\t\tstruct file *file;\n\t\tconst char *filename;\n\n\t\tfile = vma->vm_file;\n\t\tif (!file)\n\t\t\tcontinue;\n\t\tfilename = d_path(&file->f_path, name_curpos, remaining);\n\t\tif (IS_ERR(filename)) {\n\t\t\tif (PTR_ERR(filename) == -ENAMETOOLONG) {\n\t\t\t\tvfree(data);\n\t\t\t\tsize = size * 5 / 4;\n\t\t\t\tgoto alloc;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* d_path() fills at the end, move name down */\n\t\t/* n = strlen(filename) + 1: */\n\t\tn = (name_curpos + remaining) - filename;\n\t\tremaining = filename - name_curpos;\n\t\tmemmove(name_curpos, filename, n);\n\t\tname_curpos += n;\n\n\t\t*start_end_ofs++ = vma->vm_start;\n\t\t*start_end_ofs++ = vma->vm_end;\n\t\t*start_end_ofs++ = vma->vm_pgoff;\n\t\tcount++;\n\t}\n\n\t/* Now we know exact count of files, can store it */\n\tdata[0] = count;\n\tdata[1] = PAGE_SIZE;\n\t/*\n\t * Count usually is less than current->mm->map_count,\n\t * we need to move filenames down.\n\t */\n\tn = current->mm->map_count - count;\n\tif (n != 0) {\n\t\tunsigned shift_bytes = n * 3 * sizeof(data[0]);\n\t\tmemmove(name_base - shift_bytes, name_base,\n\t\t\tname_curpos - name_base);\n\t\tname_curpos -= shift_bytes;\n\t}\n\n\tsize = name_curpos - (char *)data;\n\tfill_note(note, \"CORE\", NT_FILE, size, data);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define MAX_FILE_NOTE_SIZE (4*1024*1024)",
            "#define user_long_t long"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define MAX_FILE_NOTE_SIZE (4*1024*1024)\n#define user_long_t long\n\nstatic int fill_files_note(struct memelfnote *note)\n{\n\tstruct vm_area_struct *vma;\n\tunsigned count, size, names_ofs, remaining, n;\n\tuser_long_t *data;\n\tuser_long_t *start_end_ofs;\n\tchar *name_base, *name_curpos;\n\n\t/* *Estimated* file count and total data size needed */\n\tcount = current->mm->map_count;\n\tsize = count * 64;\n\n\tnames_ofs = (2 + 3 * count) * sizeof(data[0]);\n alloc:\n\tif (size >= MAX_FILE_NOTE_SIZE) /* paranoia check */\n\t\treturn -EINVAL;\n\tsize = round_up(size, PAGE_SIZE);\n\tdata = vmalloc(size);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tstart_end_ofs = data + 2;\n\tname_base = name_curpos = ((char *)data) + names_ofs;\n\tremaining = size - names_ofs;\n\tcount = 0;\n\tfor (vma = current->mm->mmap; vma != NULL; vma = vma->vm_next) {\n\t\tstruct file *file;\n\t\tconst char *filename;\n\n\t\tfile = vma->vm_file;\n\t\tif (!file)\n\t\t\tcontinue;\n\t\tfilename = d_path(&file->f_path, name_curpos, remaining);\n\t\tif (IS_ERR(filename)) {\n\t\t\tif (PTR_ERR(filename) == -ENAMETOOLONG) {\n\t\t\t\tvfree(data);\n\t\t\t\tsize = size * 5 / 4;\n\t\t\t\tgoto alloc;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* d_path() fills at the end, move name down */\n\t\t/* n = strlen(filename) + 1: */\n\t\tn = (name_curpos + remaining) - filename;\n\t\tremaining = filename - name_curpos;\n\t\tmemmove(name_curpos, filename, n);\n\t\tname_curpos += n;\n\n\t\t*start_end_ofs++ = vma->vm_start;\n\t\t*start_end_ofs++ = vma->vm_end;\n\t\t*start_end_ofs++ = vma->vm_pgoff;\n\t\tcount++;\n\t}\n\n\t/* Now we know exact count of files, can store it */\n\tdata[0] = count;\n\tdata[1] = PAGE_SIZE;\n\t/*\n\t * Count usually is less than current->mm->map_count,\n\t * we need to move filenames down.\n\t */\n\tn = current->mm->map_count - count;\n\tif (n != 0) {\n\t\tunsigned shift_bytes = n * 3 * sizeof(data[0]);\n\t\tmemmove(name_base - shift_bytes, name_base,\n\t\t\tname_curpos - name_base);\n\t\tname_curpos -= shift_bytes;\n\t}\n\n\tsize = name_curpos - (char *)data;\n\tfill_note(note, \"CORE\", NT_FILE, size, data);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_auxv_note",
          "args": [
            "info->notes + 3",
            "current->mm"
          ],
          "line": 1987
        },
        "resolved": true,
        "details": {
          "function_name": "fill_auxv_note",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "1474-1482",
          "snippet": "static void fill_auxv_note(struct memelfnote *note, struct mm_struct *mm)\n{\n\telf_addr_t *auxv = (elf_addr_t *) mm->saved_auxv;\n\tint i = 0;\n\tdo\n\t\ti += 2;\n\twhile (auxv[i - 2] != AT_NULL);\n\tfill_note(note, \"CORE\", NT_AUXV, i * sizeof(elf_addr_t), auxv);\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void fill_auxv_note(struct memelfnote *note, struct mm_struct *mm)\n{\n\telf_addr_t *auxv = (elf_addr_t *) mm->saved_auxv;\n\tint i = 0;\n\tdo\n\t\ti += 2;\n\twhile (auxv[i - 2] != AT_NULL);\n\tfill_note(note, \"CORE\", NT_AUXV, i * sizeof(elf_addr_t), auxv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_siginfo_note",
          "args": [
            "info->notes + 2",
            "&info->csigdata",
            "siginfo"
          ],
          "line": 1986
        },
        "resolved": true,
        "details": {
          "function_name": "fill_siginfo_note",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "1484-1492",
          "snippet": "static void fill_siginfo_note(struct memelfnote *note, user_siginfo_t *csigdata,\n\t\tconst siginfo_t *siginfo)\n{\n\tmm_segment_t old_fs = get_fs();\n\tset_fs(KERNEL_DS);\n\tcopy_siginfo_to_user((user_siginfo_t __user *) csigdata, siginfo);\n\tset_fs(old_fs);\n\tfill_note(note, \"CORE\", NT_SIGINFO, sizeof(*csigdata), csigdata);\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define user_siginfo_t siginfo_t"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define user_siginfo_t siginfo_t\n\nstatic void fill_siginfo_note(struct memelfnote *note, user_siginfo_t *csigdata,\n\t\tconst siginfo_t *siginfo)\n{\n\tmm_segment_t old_fs = get_fs();\n\tset_fs(KERNEL_DS);\n\tcopy_siginfo_to_user((user_siginfo_t __user *) csigdata, siginfo);\n\tset_fs(old_fs);\n\tfill_note(note, \"CORE\", NT_SIGINFO, sizeof(*csigdata), csigdata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_psinfo",
          "args": [
            "info->psinfo",
            "current->group_leader",
            "current->mm"
          ],
          "line": 1982
        },
        "resolved": true,
        "details": {
          "function_name": "fill_psinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "1431-1472",
          "snippet": "static int fill_psinfo(struct elf_prpsinfo *psinfo, struct task_struct *p,\n\t\t       struct mm_struct *mm)\n{\n\tconst struct cred *cred;\n\tunsigned int i, len;\n\t\n\t/* first copy the parameters from user space */\n\tmemset(psinfo, 0, sizeof(struct elf_prpsinfo));\n\n\tlen = mm->arg_end - mm->arg_start;\n\tif (len >= ELF_PRARGSZ)\n\t\tlen = ELF_PRARGSZ-1;\n\tif (copy_from_user(&psinfo->pr_psargs,\n\t\t           (const char __user *)mm->arg_start, len))\n\t\treturn -EFAULT;\n\tfor(i = 0; i < len; i++)\n\t\tif (psinfo->pr_psargs[i] == 0)\n\t\t\tpsinfo->pr_psargs[i] = ' ';\n\tpsinfo->pr_psargs[len] = 0;\n\n\trcu_read_lock();\n\tpsinfo->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tpsinfo->pr_pid = task_pid_vnr(p);\n\tpsinfo->pr_pgrp = task_pgrp_vnr(p);\n\tpsinfo->pr_sid = task_session_vnr(p);\n\n\ti = p->state ? ffz(~p->state) + 1 : 0;\n\tpsinfo->pr_state = i;\n\tpsinfo->pr_sname = (i > 5) ? '.' : \"RSDTZW\"[i];\n\tpsinfo->pr_zomb = psinfo->pr_sname == 'Z';\n\tpsinfo->pr_nice = task_nice(p);\n\tpsinfo->pr_flag = p->flags;\n\trcu_read_lock();\n\tcred = __task_cred(p);\n\tSET_UID(psinfo->pr_uid, from_kuid_munged(cred->user_ns, cred->uid));\n\tSET_GID(psinfo->pr_gid, from_kgid_munged(cred->user_ns, cred->gid));\n\trcu_read_unlock();\n\tstrncpy(psinfo->pr_fname, p->comm, sizeof(psinfo->pr_fname));\n\t\n\treturn 0;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int fill_psinfo(struct elf_prpsinfo *psinfo, struct task_struct *p,\n\t\t       struct mm_struct *mm)\n{\n\tconst struct cred *cred;\n\tunsigned int i, len;\n\t\n\t/* first copy the parameters from user space */\n\tmemset(psinfo, 0, sizeof(struct elf_prpsinfo));\n\n\tlen = mm->arg_end - mm->arg_start;\n\tif (len >= ELF_PRARGSZ)\n\t\tlen = ELF_PRARGSZ-1;\n\tif (copy_from_user(&psinfo->pr_psargs,\n\t\t           (const char __user *)mm->arg_start, len))\n\t\treturn -EFAULT;\n\tfor(i = 0; i < len; i++)\n\t\tif (psinfo->pr_psargs[i] == 0)\n\t\t\tpsinfo->pr_psargs[i] = ' ';\n\tpsinfo->pr_psargs[len] = 0;\n\n\trcu_read_lock();\n\tpsinfo->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tpsinfo->pr_pid = task_pid_vnr(p);\n\tpsinfo->pr_pgrp = task_pgrp_vnr(p);\n\tpsinfo->pr_sid = task_session_vnr(p);\n\n\ti = p->state ? ffz(~p->state) + 1 : 0;\n\tpsinfo->pr_state = i;\n\tpsinfo->pr_sname = (i > 5) ? '.' : \"RSDTZW\"[i];\n\tpsinfo->pr_zomb = psinfo->pr_sname == 'Z';\n\tpsinfo->pr_nice = task_nice(p);\n\tpsinfo->pr_flag = p->flags;\n\trcu_read_lock();\n\tcred = __task_cred(p);\n\tSET_UID(psinfo->pr_uid, from_kuid_munged(cred->user_ns, cred->uid));\n\tSET_GID(psinfo->pr_gid, from_kgid_munged(cred->user_ns, cred->gid));\n\trcu_read_unlock();\n\tstrncpy(psinfo->pr_fname, p->comm, sizeof(psinfo->pr_fname));\n\t\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_elf_header",
          "args": [
            "elf",
            "phdrs",
            "ELF_ARCH",
            "ELF_CORE_EFLAGS"
          ],
          "line": 1973
        },
        "resolved": true,
        "details": {
          "function_name": "fill_elf_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "1348-1369",
          "snippet": "static void fill_elf_header(struct elfhdr *elf, int segs,\n\t\t\t    u16 machine, u32 flags)\n{\n\tmemset(elf, 0, sizeof(*elf));\n\n\tmemcpy(elf->e_ident, ELFMAG, SELFMAG);\n\telf->e_ident[EI_CLASS] = ELF_CLASS;\n\telf->e_ident[EI_DATA] = ELF_DATA;\n\telf->e_ident[EI_VERSION] = EV_CURRENT;\n\telf->e_ident[EI_OSABI] = ELF_OSABI;\n\n\telf->e_type = ET_CORE;\n\telf->e_machine = machine;\n\telf->e_version = EV_CURRENT;\n\telf->e_phoff = sizeof(struct elfhdr);\n\telf->e_flags = flags;\n\telf->e_ehsize = sizeof(struct elfhdr);\n\telf->e_phentsize = sizeof(struct elf_phdr);\n\telf->e_phnum = segs;\n\n\treturn;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);\n\nstatic void fill_elf_header(struct elfhdr *elf, int segs,\n\t\t\t    u16 machine, u32 flags)\n{\n\tmemset(elf, 0, sizeof(*elf));\n\n\tmemcpy(elf->e_ident, ELFMAG, SELFMAG);\n\telf->e_ident[EI_CLASS] = ELF_CLASS;\n\telf->e_ident[EI_DATA] = ELF_DATA;\n\telf->e_ident[EI_VERSION] = EV_CURRENT;\n\telf->e_ident[EI_OSABI] = ELF_OSABI;\n\n\telf->e_type = ET_CORE;\n\telf->e_machine = machine;\n\telf->e_version = EV_CURRENT;\n\telf->e_phoff = sizeof(struct elfhdr);\n\telf->e_flags = flags;\n\telf->e_ehsize = sizeof(struct elfhdr);\n\telf->e_phentsize = sizeof(struct elf_phdr);\n\telf->e_phnum = segs;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elf_core_copy_regs",
          "args": [
            "&info->prstatus->pr_reg",
            "regs"
          ],
          "line": 1970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill_prstatus",
          "args": [
            "info->prstatus",
            "current",
            "siginfo->si_signo"
          ],
          "line": 1969
        },
        "resolved": true,
        "details": {
          "function_name": "fill_prstatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "1398-1429",
          "snippet": "static void fill_prstatus(struct elf_prstatus *prstatus,\n\t\tstruct task_struct *p, long signr)\n{\n\tprstatus->pr_info.si_signo = prstatus->pr_cursig = signr;\n\tprstatus->pr_sigpend = p->pending.signal.sig[0];\n\tprstatus->pr_sighold = p->blocked.sig[0];\n\trcu_read_lock();\n\tprstatus->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tprstatus->pr_pid = task_pid_vnr(p);\n\tprstatus->pr_pgrp = task_pgrp_vnr(p);\n\tprstatus->pr_sid = task_session_vnr(p);\n\tif (thread_group_leader(p)) {\n\t\tstruct task_cputime cputime;\n\n\t\t/*\n\t\t * This is the record for the group leader.  It shows the\n\t\t * group-wide total, not its individual thread total.\n\t\t */\n\t\tthread_group_cputime(p, &cputime);\n\t\tcputime_to_timeval(cputime.utime, &prstatus->pr_utime);\n\t\tcputime_to_timeval(cputime.stime, &prstatus->pr_stime);\n\t} else {\n\t\tcputime_t utime, stime;\n\n\t\ttask_cputime(p, &utime, &stime);\n\t\tcputime_to_timeval(utime, &prstatus->pr_utime);\n\t\tcputime_to_timeval(stime, &prstatus->pr_stime);\n\t}\n\tcputime_to_timeval(p->signal->cutime, &prstatus->pr_cutime);\n\tcputime_to_timeval(p->signal->cstime, &prstatus->pr_cstime);\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void fill_prstatus(struct elf_prstatus *prstatus,\n\t\tstruct task_struct *p, long signr)\n{\n\tprstatus->pr_info.si_signo = prstatus->pr_cursig = signr;\n\tprstatus->pr_sigpend = p->pending.signal.sig[0];\n\tprstatus->pr_sighold = p->blocked.sig[0];\n\trcu_read_lock();\n\tprstatus->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tprstatus->pr_pid = task_pid_vnr(p);\n\tprstatus->pr_pgrp = task_pgrp_vnr(p);\n\tprstatus->pr_sid = task_session_vnr(p);\n\tif (thread_group_leader(p)) {\n\t\tstruct task_cputime cputime;\n\n\t\t/*\n\t\t * This is the record for the group leader.  It shows the\n\t\t * group-wide total, not its individual thread total.\n\t\t */\n\t\tthread_group_cputime(p, &cputime);\n\t\tcputime_to_timeval(cputime.utime, &prstatus->pr_utime);\n\t\tcputime_to_timeval(cputime.stime, &prstatus->pr_stime);\n\t} else {\n\t\tcputime_t utime, stime;\n\n\t\ttask_cputime(p, &utime, &stime);\n\t\tcputime_to_timeval(utime, &prstatus->pr_utime);\n\t\tcputime_to_timeval(stime, &prstatus->pr_stime);\n\t}\n\tcputime_to_timeval(p->signal->cutime, &prstatus->pr_cutime);\n\tcputime_to_timeval(p->signal->cstime, &prstatus->pr_cstime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "info->prstatus",
            "0",
            "sizeof(*info->prstatus)"
          ],
          "line": 1968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elf_dump_thread_status",
          "args": [
            "siginfo->si_signo",
            "ets"
          ],
          "line": 1964
        },
        "resolved": true,
        "details": {
          "function_name": "elf_dump_thread_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "1865-1896",
          "snippet": "static int elf_dump_thread_status(long signr, struct elf_thread_status *t)\n{\n\tint sz = 0;\n\tstruct task_struct *p = t->thread;\n\tt->num_notes = 0;\n\n\tfill_prstatus(&t->prstatus, p, signr);\n\telf_core_copy_task_regs(p, &t->prstatus.pr_reg);\t\n\t\n\tfill_note(&t->notes[0], \"CORE\", NT_PRSTATUS, sizeof(t->prstatus),\n\t\t  &(t->prstatus));\n\tt->num_notes++;\n\tsz += notesize(&t->notes[0]);\n\n\tif ((t->prstatus.pr_fpvalid = elf_core_copy_task_fpregs(p, NULL,\n\t\t\t\t\t\t\t\t&t->fpu))) {\n\t\tfill_note(&t->notes[1], \"CORE\", NT_PRFPREG, sizeof(t->fpu),\n\t\t\t  &(t->fpu));\n\t\tt->num_notes++;\n\t\tsz += notesize(&t->notes[1]);\n\t}\n\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(p, &t->xfpu)) {\n\t\tfill_note(&t->notes[2], \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(t->xfpu), &t->xfpu);\n\t\tt->num_notes++;\n\t\tsz += notesize(&t->notes[2]);\n\t}\n#endif\t\n\treturn sz;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int elf_dump_thread_status(long signr, struct elf_thread_status *t)\n{\n\tint sz = 0;\n\tstruct task_struct *p = t->thread;\n\tt->num_notes = 0;\n\n\tfill_prstatus(&t->prstatus, p, signr);\n\telf_core_copy_task_regs(p, &t->prstatus.pr_reg);\t\n\t\n\tfill_note(&t->notes[0], \"CORE\", NT_PRSTATUS, sizeof(t->prstatus),\n\t\t  &(t->prstatus));\n\tt->num_notes++;\n\tsz += notesize(&t->notes[0]);\n\n\tif ((t->prstatus.pr_fpvalid = elf_core_copy_task_fpregs(p, NULL,\n\t\t\t\t\t\t\t\t&t->fpu))) {\n\t\tfill_note(&t->notes[1], \"CORE\", NT_PRFPREG, sizeof(t->fpu),\n\t\t\t  &(t->fpu));\n\t\tt->num_notes++;\n\t\tsz += notesize(&t->notes[1]);\n\t}\n\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(p, &t->xfpu)) {\n\t\tfill_note(&t->notes[2], \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(t->xfpu), &t->xfpu);\n\t\tt->num_notes++;\n\t\tsz += notesize(&t->notes[2]);\n\t}\n#endif\t\n\treturn sz;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "t",
            "structelf_thread_status",
            "list"
          ],
          "line": 1963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "t",
            "&info->thread_list"
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&ets->list",
            "&info->thread_list"
          ],
          "line": 1957
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*ets)",
            "GFP_KERNEL"
          ],
          "line": 1952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elf_note_info_init",
          "args": [
            "info"
          ],
          "line": 1947
        },
        "resolved": true,
        "details": {
          "function_name": "elf_note_info_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "1913-1937",
          "snippet": "static int elf_note_info_init(struct elf_note_info *info)\n{\n\tmemset(info, 0, sizeof(*info));\n\tINIT_LIST_HEAD(&info->thread_list);\n\n\t/* Allocate space for ELF notes */\n\tinfo->notes = kmalloc(8 * sizeof(struct memelfnote), GFP_KERNEL);\n\tif (!info->notes)\n\t\treturn 0;\n\tinfo->psinfo = kmalloc(sizeof(*info->psinfo), GFP_KERNEL);\n\tif (!info->psinfo)\n\t\treturn 0;\n\tinfo->prstatus = kmalloc(sizeof(*info->prstatus), GFP_KERNEL);\n\tif (!info->prstatus)\n\t\treturn 0;\n\tinfo->fpu = kmalloc(sizeof(*info->fpu), GFP_KERNEL);\n\tif (!info->fpu)\n\t\treturn 0;\n#ifdef ELF_CORE_COPY_XFPREGS\n\tinfo->xfpu = kmalloc(sizeof(*info->xfpu), GFP_KERNEL);\n\tif (!info->xfpu)\n\t\treturn 0;\n#endif\n\treturn 1;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int elf_note_info_init(struct elf_note_info *info)\n{\n\tmemset(info, 0, sizeof(*info));\n\tINIT_LIST_HEAD(&info->thread_list);\n\n\t/* Allocate space for ELF notes */\n\tinfo->notes = kmalloc(8 * sizeof(struct memelfnote), GFP_KERNEL);\n\tif (!info->notes)\n\t\treturn 0;\n\tinfo->psinfo = kmalloc(sizeof(*info->psinfo), GFP_KERNEL);\n\tif (!info->psinfo)\n\t\treturn 0;\n\tinfo->prstatus = kmalloc(sizeof(*info->prstatus), GFP_KERNEL);\n\tif (!info->prstatus)\n\t\treturn 0;\n\tinfo->fpu = kmalloc(sizeof(*info->fpu), GFP_KERNEL);\n\tif (!info->fpu)\n\t\treturn 0;\n#ifdef ELF_CORE_COPY_XFPREGS\n\tinfo->xfpu = kmalloc(sizeof(*info->xfpu), GFP_KERNEL);\n\tif (!info->xfpu)\n\t\treturn 0;\n#endif\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define ELF_CORE_EFLAGS\t0\n\nstatic int fill_note_info(struct elfhdr *elf, int phdrs,\n\t\t\t  struct elf_note_info *info,\n\t\t\t  const siginfo_t *siginfo, struct pt_regs *regs)\n{\n\tstruct list_head *t;\n\tstruct core_thread *ct;\n\tstruct elf_thread_status *ets;\n\n\tif (!elf_note_info_init(info))\n\t\treturn 0;\n\n\tfor (ct = current->mm->core_state->dumper.next;\n\t\t\t\t\tct; ct = ct->next) {\n\t\tets = kzalloc(sizeof(*ets), GFP_KERNEL);\n\t\tif (!ets)\n\t\t\treturn 0;\n\n\t\tets->thread = ct->task;\n\t\tlist_add(&ets->list, &info->thread_list);\n\t}\n\n\tlist_for_each(t, &info->thread_list) {\n\t\tint sz;\n\n\t\tets = list_entry(t, struct elf_thread_status, list);\n\t\tsz = elf_dump_thread_status(siginfo->si_signo, ets);\n\t\tinfo->thread_status_size += sz;\n\t}\n\t/* now collect the dump for the current */\n\tmemset(info->prstatus, 0, sizeof(*info->prstatus));\n\tfill_prstatus(info->prstatus, current, siginfo->si_signo);\n\telf_core_copy_regs(&info->prstatus->pr_reg, regs);\n\n\t/* Set up header */\n\tfill_elf_header(elf, phdrs, ELF_ARCH, ELF_CORE_EFLAGS);\n\n\t/*\n\t * Set up the notes in similar form to SVR4 core dumps made\n\t * with info from their /proc.\n\t */\n\n\tfill_note(info->notes + 0, \"CORE\", NT_PRSTATUS,\n\t\t  sizeof(*info->prstatus), info->prstatus);\n\tfill_psinfo(info->psinfo, current->group_leader, current->mm);\n\tfill_note(info->notes + 1, \"CORE\", NT_PRPSINFO,\n\t\t  sizeof(*info->psinfo), info->psinfo);\n\n\tfill_siginfo_note(info->notes + 2, &info->csigdata, siginfo);\n\tfill_auxv_note(info->notes + 3, current->mm);\n\tinfo->numnote = 4;\n\n\tif (fill_files_note(info->notes + info->numnote) == 0) {\n\t\tinfo->notes_files = info->notes + info->numnote;\n\t\tinfo->numnote++;\n\t}\n\n\t/* Try to dump the FPU. */\n\tinfo->prstatus->pr_fpvalid = elf_core_copy_task_fpregs(current, regs,\n\t\t\t\t\t\t\t       info->fpu);\n\tif (info->prstatus->pr_fpvalid)\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"CORE\", NT_PRFPREG, sizeof(*info->fpu), info->fpu);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(current, info->xfpu))\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(*info->xfpu), info->xfpu);\n#endif\n\n\treturn 1;\n}"
  },
  {
    "function_name": "elf_note_info_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
    "lines": "1913-1937",
    "snippet": "static int elf_note_info_init(struct elf_note_info *info)\n{\n\tmemset(info, 0, sizeof(*info));\n\tINIT_LIST_HEAD(&info->thread_list);\n\n\t/* Allocate space for ELF notes */\n\tinfo->notes = kmalloc(8 * sizeof(struct memelfnote), GFP_KERNEL);\n\tif (!info->notes)\n\t\treturn 0;\n\tinfo->psinfo = kmalloc(sizeof(*info->psinfo), GFP_KERNEL);\n\tif (!info->psinfo)\n\t\treturn 0;\n\tinfo->prstatus = kmalloc(sizeof(*info->prstatus), GFP_KERNEL);\n\tif (!info->prstatus)\n\t\treturn 0;\n\tinfo->fpu = kmalloc(sizeof(*info->fpu), GFP_KERNEL);\n\tif (!info->fpu)\n\t\treturn 0;\n#ifdef ELF_CORE_COPY_XFPREGS\n\tinfo->xfpu = kmalloc(sizeof(*info->xfpu), GFP_KERNEL);\n\tif (!info->xfpu)\n\t\treturn 0;\n#endif\n\treturn 1;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*info->xfpu)",
            "GFP_KERNEL"
          ],
          "line": 1932
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&info->thread_list"
          ],
          "line": 1916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "info",
            "0",
            "sizeof(*info)"
          ],
          "line": 1915
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int elf_note_info_init(struct elf_note_info *info)\n{\n\tmemset(info, 0, sizeof(*info));\n\tINIT_LIST_HEAD(&info->thread_list);\n\n\t/* Allocate space for ELF notes */\n\tinfo->notes = kmalloc(8 * sizeof(struct memelfnote), GFP_KERNEL);\n\tif (!info->notes)\n\t\treturn 0;\n\tinfo->psinfo = kmalloc(sizeof(*info->psinfo), GFP_KERNEL);\n\tif (!info->psinfo)\n\t\treturn 0;\n\tinfo->prstatus = kmalloc(sizeof(*info->prstatus), GFP_KERNEL);\n\tif (!info->prstatus)\n\t\treturn 0;\n\tinfo->fpu = kmalloc(sizeof(*info->fpu), GFP_KERNEL);\n\tif (!info->fpu)\n\t\treturn 0;\n#ifdef ELF_CORE_COPY_XFPREGS\n\tinfo->xfpu = kmalloc(sizeof(*info->xfpu), GFP_KERNEL);\n\tif (!info->xfpu)\n\t\treturn 0;\n#endif\n\treturn 1;\n}"
  },
  {
    "function_name": "elf_dump_thread_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
    "lines": "1865-1896",
    "snippet": "static int elf_dump_thread_status(long signr, struct elf_thread_status *t)\n{\n\tint sz = 0;\n\tstruct task_struct *p = t->thread;\n\tt->num_notes = 0;\n\n\tfill_prstatus(&t->prstatus, p, signr);\n\telf_core_copy_task_regs(p, &t->prstatus.pr_reg);\t\n\t\n\tfill_note(&t->notes[0], \"CORE\", NT_PRSTATUS, sizeof(t->prstatus),\n\t\t  &(t->prstatus));\n\tt->num_notes++;\n\tsz += notesize(&t->notes[0]);\n\n\tif ((t->prstatus.pr_fpvalid = elf_core_copy_task_fpregs(p, NULL,\n\t\t\t\t\t\t\t\t&t->fpu))) {\n\t\tfill_note(&t->notes[1], \"CORE\", NT_PRFPREG, sizeof(t->fpu),\n\t\t\t  &(t->fpu));\n\t\tt->num_notes++;\n\t\tsz += notesize(&t->notes[1]);\n\t}\n\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(p, &t->xfpu)) {\n\t\tfill_note(&t->notes[2], \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(t->xfpu), &t->xfpu);\n\t\tt->num_notes++;\n\t\tsz += notesize(&t->notes[2]);\n\t}\n#endif\t\n\treturn sz;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "notesize",
          "args": [
            "&t->notes[2]"
          ],
          "line": 1892
        },
        "resolved": true,
        "details": {
          "function_name": "notesize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "1325-1334",
          "snippet": "static int notesize(struct memelfnote *en)\n{\n\tint sz;\n\n\tsz = sizeof(struct elf_note);\n\tsz += roundup(strlen(en->name) + 1, 4);\n\tsz += roundup(en->datasz, 4);\n\n\treturn sz;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int notesize(struct memelfnote *en)\n{\n\tint sz;\n\n\tsz = sizeof(struct elf_note);\n\tsz += roundup(strlen(en->name) + 1, 4);\n\tsz += roundup(en->datasz, 4);\n\n\treturn sz;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_note",
          "args": [
            "&t->notes[2]",
            "\"LINUX\"",
            "ELF_CORE_XFPREG_TYPE",
            "sizeof(t->xfpu)",
            "&t->xfpu"
          ],
          "line": 1889
        },
        "resolved": true,
        "details": {
          "function_name": "fill_note_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "1939-2009",
          "snippet": "static int fill_note_info(struct elfhdr *elf, int phdrs,\n\t\t\t  struct elf_note_info *info,\n\t\t\t  const siginfo_t *siginfo, struct pt_regs *regs)\n{\n\tstruct list_head *t;\n\tstruct core_thread *ct;\n\tstruct elf_thread_status *ets;\n\n\tif (!elf_note_info_init(info))\n\t\treturn 0;\n\n\tfor (ct = current->mm->core_state->dumper.next;\n\t\t\t\t\tct; ct = ct->next) {\n\t\tets = kzalloc(sizeof(*ets), GFP_KERNEL);\n\t\tif (!ets)\n\t\t\treturn 0;\n\n\t\tets->thread = ct->task;\n\t\tlist_add(&ets->list, &info->thread_list);\n\t}\n\n\tlist_for_each(t, &info->thread_list) {\n\t\tint sz;\n\n\t\tets = list_entry(t, struct elf_thread_status, list);\n\t\tsz = elf_dump_thread_status(siginfo->si_signo, ets);\n\t\tinfo->thread_status_size += sz;\n\t}\n\t/* now collect the dump for the current */\n\tmemset(info->prstatus, 0, sizeof(*info->prstatus));\n\tfill_prstatus(info->prstatus, current, siginfo->si_signo);\n\telf_core_copy_regs(&info->prstatus->pr_reg, regs);\n\n\t/* Set up header */\n\tfill_elf_header(elf, phdrs, ELF_ARCH, ELF_CORE_EFLAGS);\n\n\t/*\n\t * Set up the notes in similar form to SVR4 core dumps made\n\t * with info from their /proc.\n\t */\n\n\tfill_note(info->notes + 0, \"CORE\", NT_PRSTATUS,\n\t\t  sizeof(*info->prstatus), info->prstatus);\n\tfill_psinfo(info->psinfo, current->group_leader, current->mm);\n\tfill_note(info->notes + 1, \"CORE\", NT_PRPSINFO,\n\t\t  sizeof(*info->psinfo), info->psinfo);\n\n\tfill_siginfo_note(info->notes + 2, &info->csigdata, siginfo);\n\tfill_auxv_note(info->notes + 3, current->mm);\n\tinfo->numnote = 4;\n\n\tif (fill_files_note(info->notes + info->numnote) == 0) {\n\t\tinfo->notes_files = info->notes + info->numnote;\n\t\tinfo->numnote++;\n\t}\n\n\t/* Try to dump the FPU. */\n\tinfo->prstatus->pr_fpvalid = elf_core_copy_task_fpregs(current, regs,\n\t\t\t\t\t\t\t       info->fpu);\n\tif (info->prstatus->pr_fpvalid)\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"CORE\", NT_PRFPREG, sizeof(*info->fpu), info->fpu);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(current, info->xfpu))\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(*info->xfpu), info->xfpu);\n#endif\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define ELF_CORE_EFLAGS\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define ELF_CORE_EFLAGS\t0\n\nstatic int fill_note_info(struct elfhdr *elf, int phdrs,\n\t\t\t  struct elf_note_info *info,\n\t\t\t  const siginfo_t *siginfo, struct pt_regs *regs)\n{\n\tstruct list_head *t;\n\tstruct core_thread *ct;\n\tstruct elf_thread_status *ets;\n\n\tif (!elf_note_info_init(info))\n\t\treturn 0;\n\n\tfor (ct = current->mm->core_state->dumper.next;\n\t\t\t\t\tct; ct = ct->next) {\n\t\tets = kzalloc(sizeof(*ets), GFP_KERNEL);\n\t\tif (!ets)\n\t\t\treturn 0;\n\n\t\tets->thread = ct->task;\n\t\tlist_add(&ets->list, &info->thread_list);\n\t}\n\n\tlist_for_each(t, &info->thread_list) {\n\t\tint sz;\n\n\t\tets = list_entry(t, struct elf_thread_status, list);\n\t\tsz = elf_dump_thread_status(siginfo->si_signo, ets);\n\t\tinfo->thread_status_size += sz;\n\t}\n\t/* now collect the dump for the current */\n\tmemset(info->prstatus, 0, sizeof(*info->prstatus));\n\tfill_prstatus(info->prstatus, current, siginfo->si_signo);\n\telf_core_copy_regs(&info->prstatus->pr_reg, regs);\n\n\t/* Set up header */\n\tfill_elf_header(elf, phdrs, ELF_ARCH, ELF_CORE_EFLAGS);\n\n\t/*\n\t * Set up the notes in similar form to SVR4 core dumps made\n\t * with info from their /proc.\n\t */\n\n\tfill_note(info->notes + 0, \"CORE\", NT_PRSTATUS,\n\t\t  sizeof(*info->prstatus), info->prstatus);\n\tfill_psinfo(info->psinfo, current->group_leader, current->mm);\n\tfill_note(info->notes + 1, \"CORE\", NT_PRPSINFO,\n\t\t  sizeof(*info->psinfo), info->psinfo);\n\n\tfill_siginfo_note(info->notes + 2, &info->csigdata, siginfo);\n\tfill_auxv_note(info->notes + 3, current->mm);\n\tinfo->numnote = 4;\n\n\tif (fill_files_note(info->notes + info->numnote) == 0) {\n\t\tinfo->notes_files = info->notes + info->numnote;\n\t\tinfo->numnote++;\n\t}\n\n\t/* Try to dump the FPU. */\n\tinfo->prstatus->pr_fpvalid = elf_core_copy_task_fpregs(current, regs,\n\t\t\t\t\t\t\t       info->fpu);\n\tif (info->prstatus->pr_fpvalid)\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"CORE\", NT_PRFPREG, sizeof(*info->fpu), info->fpu);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(current, info->xfpu))\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(*info->xfpu), info->xfpu);\n#endif\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elf_core_copy_task_xfpregs",
          "args": [
            "p",
            "&t->xfpu"
          ],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elf_core_copy_task_fpregs",
          "args": [
            "p",
            "NULL",
            "&t->fpu"
          ],
          "line": 1879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elf_core_copy_task_regs",
          "args": [
            "p",
            "&t->prstatus.pr_reg"
          ],
          "line": 1872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill_prstatus",
          "args": [
            "&t->prstatus",
            "p",
            "signr"
          ],
          "line": 1871
        },
        "resolved": true,
        "details": {
          "function_name": "fill_prstatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "1398-1429",
          "snippet": "static void fill_prstatus(struct elf_prstatus *prstatus,\n\t\tstruct task_struct *p, long signr)\n{\n\tprstatus->pr_info.si_signo = prstatus->pr_cursig = signr;\n\tprstatus->pr_sigpend = p->pending.signal.sig[0];\n\tprstatus->pr_sighold = p->blocked.sig[0];\n\trcu_read_lock();\n\tprstatus->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tprstatus->pr_pid = task_pid_vnr(p);\n\tprstatus->pr_pgrp = task_pgrp_vnr(p);\n\tprstatus->pr_sid = task_session_vnr(p);\n\tif (thread_group_leader(p)) {\n\t\tstruct task_cputime cputime;\n\n\t\t/*\n\t\t * This is the record for the group leader.  It shows the\n\t\t * group-wide total, not its individual thread total.\n\t\t */\n\t\tthread_group_cputime(p, &cputime);\n\t\tcputime_to_timeval(cputime.utime, &prstatus->pr_utime);\n\t\tcputime_to_timeval(cputime.stime, &prstatus->pr_stime);\n\t} else {\n\t\tcputime_t utime, stime;\n\n\t\ttask_cputime(p, &utime, &stime);\n\t\tcputime_to_timeval(utime, &prstatus->pr_utime);\n\t\tcputime_to_timeval(stime, &prstatus->pr_stime);\n\t}\n\tcputime_to_timeval(p->signal->cutime, &prstatus->pr_cutime);\n\tcputime_to_timeval(p->signal->cstime, &prstatus->pr_cstime);\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void fill_prstatus(struct elf_prstatus *prstatus,\n\t\tstruct task_struct *p, long signr)\n{\n\tprstatus->pr_info.si_signo = prstatus->pr_cursig = signr;\n\tprstatus->pr_sigpend = p->pending.signal.sig[0];\n\tprstatus->pr_sighold = p->blocked.sig[0];\n\trcu_read_lock();\n\tprstatus->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tprstatus->pr_pid = task_pid_vnr(p);\n\tprstatus->pr_pgrp = task_pgrp_vnr(p);\n\tprstatus->pr_sid = task_session_vnr(p);\n\tif (thread_group_leader(p)) {\n\t\tstruct task_cputime cputime;\n\n\t\t/*\n\t\t * This is the record for the group leader.  It shows the\n\t\t * group-wide total, not its individual thread total.\n\t\t */\n\t\tthread_group_cputime(p, &cputime);\n\t\tcputime_to_timeval(cputime.utime, &prstatus->pr_utime);\n\t\tcputime_to_timeval(cputime.stime, &prstatus->pr_stime);\n\t} else {\n\t\tcputime_t utime, stime;\n\n\t\ttask_cputime(p, &utime, &stime);\n\t\tcputime_to_timeval(utime, &prstatus->pr_utime);\n\t\tcputime_to_timeval(stime, &prstatus->pr_stime);\n\t}\n\tcputime_to_timeval(p->signal->cutime, &prstatus->pr_cutime);\n\tcputime_to_timeval(p->signal->cstime, &prstatus->pr_cstime);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int elf_dump_thread_status(long signr, struct elf_thread_status *t)\n{\n\tint sz = 0;\n\tstruct task_struct *p = t->thread;\n\tt->num_notes = 0;\n\n\tfill_prstatus(&t->prstatus, p, signr);\n\telf_core_copy_task_regs(p, &t->prstatus.pr_reg);\t\n\t\n\tfill_note(&t->notes[0], \"CORE\", NT_PRSTATUS, sizeof(t->prstatus),\n\t\t  &(t->prstatus));\n\tt->num_notes++;\n\tsz += notesize(&t->notes[0]);\n\n\tif ((t->prstatus.pr_fpvalid = elf_core_copy_task_fpregs(p, NULL,\n\t\t\t\t\t\t\t\t&t->fpu))) {\n\t\tfill_note(&t->notes[1], \"CORE\", NT_PRFPREG, sizeof(t->fpu),\n\t\t\t  &(t->fpu));\n\t\tt->num_notes++;\n\t\tsz += notesize(&t->notes[1]);\n\t}\n\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(p, &t->xfpu)) {\n\t\tfill_note(&t->notes[2], \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(t->xfpu), &t->xfpu);\n\t\tt->num_notes++;\n\t\tsz += notesize(&t->notes[2]);\n\t}\n#endif\t\n\treturn sz;\n}"
  },
  {
    "function_name": "free_note_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
    "lines": "1828-1842",
    "snippet": "static void free_note_info(struct elf_note_info *info)\n{\n\tstruct elf_thread_core_info *threads = info->thread;\n\twhile (threads) {\n\t\tunsigned int i;\n\t\tstruct elf_thread_core_info *t = threads;\n\t\tthreads = t->next;\n\t\tWARN_ON(t->notes[0].data && t->notes[0].data != &t->prstatus);\n\t\tfor (i = 1; i < info->thread_notes; ++i)\n\t\t\tkfree(t->notes[i].data);\n\t\tkfree(t);\n\t}\n\tkfree(info->psinfo.data);\n\tvfree(info->files.data);\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "info->files.data"
          ],
          "line": 1841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "info->psinfo.data"
          ],
          "line": 1840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "t"
          ],
          "line": 1838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "t->notes[i].data"
          ],
          "line": 1837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "t->notes[0].data && t->notes[0].data != &t->prstatus"
          ],
          "line": 1835
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void free_note_info(struct elf_note_info *info)\n{\n\tstruct elf_thread_core_info *threads = info->thread;\n\twhile (threads) {\n\t\tunsigned int i;\n\t\tstruct elf_thread_core_info *t = threads;\n\t\tthreads = t->next;\n\t\tWARN_ON(t->notes[0].data && t->notes[0].data != &t->prstatus);\n\t\tfor (i = 1; i < info->thread_notes; ++i)\n\t\t\tkfree(t->notes[i].data);\n\t\tkfree(t);\n\t}\n\tkfree(info->psinfo.data);\n\tvfree(info->files.data);\n}"
  },
  {
    "function_name": "write_note_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
    "lines": "1794-1826",
    "snippet": "static int write_note_info(struct elf_note_info *info,\n\t\t\t   struct coredump_params *cprm)\n{\n\tbool first = true;\n\tstruct elf_thread_core_info *t = info->thread;\n\n\tdo {\n\t\tint i;\n\n\t\tif (!writenote(&t->notes[0], cprm))\n\t\t\treturn 0;\n\n\t\tif (first && !writenote(&info->psinfo, cprm))\n\t\t\treturn 0;\n\t\tif (first && !writenote(&info->signote, cprm))\n\t\t\treturn 0;\n\t\tif (first && !writenote(&info->auxv, cprm))\n\t\t\treturn 0;\n\t\tif (first && info->files.data &&\n\t\t\t\t!writenote(&info->files, cprm))\n\t\t\treturn 0;\n\n\t\tfor (i = 1; i < info->thread_notes; ++i)\n\t\t\tif (t->notes[i].data &&\n\t\t\t    !writenote(&t->notes[i], cprm))\n\t\t\t\treturn 0;\n\n\t\tfirst = false;\n\t\tt = t->next;\n\t} while (t);\n\n\treturn 1;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writenote",
          "args": [
            "&t->notes[i]",
            "cprm"
          ],
          "line": 1818
        },
        "resolved": true,
        "details": {
          "function_name": "writenote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "1336-1346",
          "snippet": "static int writenote(struct memelfnote *men, struct coredump_params *cprm)\n{\n\tstruct elf_note en;\n\ten.n_namesz = strlen(men->name) + 1;\n\ten.n_descsz = men->datasz;\n\ten.n_type = men->type;\n\n\treturn dump_emit(cprm, &en, sizeof(en)) &&\n\t    dump_emit(cprm, men->name, en.n_namesz) && dump_align(cprm, 4) &&\n\t    dump_emit(cprm, men->data, men->datasz) && dump_align(cprm, 4);\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int writenote(struct memelfnote *men, struct coredump_params *cprm)\n{\n\tstruct elf_note en;\n\ten.n_namesz = strlen(men->name) + 1;\n\ten.n_descsz = men->datasz;\n\ten.n_type = men->type;\n\n\treturn dump_emit(cprm, &en, sizeof(en)) &&\n\t    dump_emit(cprm, men->name, en.n_namesz) && dump_align(cprm, 4) &&\n\t    dump_emit(cprm, men->data, men->datasz) && dump_align(cprm, 4);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int write_note_info(struct elf_note_info *info,\n\t\t\t   struct coredump_params *cprm)\n{\n\tbool first = true;\n\tstruct elf_thread_core_info *t = info->thread;\n\n\tdo {\n\t\tint i;\n\n\t\tif (!writenote(&t->notes[0], cprm))\n\t\t\treturn 0;\n\n\t\tif (first && !writenote(&info->psinfo, cprm))\n\t\t\treturn 0;\n\t\tif (first && !writenote(&info->signote, cprm))\n\t\t\treturn 0;\n\t\tif (first && !writenote(&info->auxv, cprm))\n\t\t\treturn 0;\n\t\tif (first && info->files.data &&\n\t\t\t\t!writenote(&info->files, cprm))\n\t\t\treturn 0;\n\n\t\tfor (i = 1; i < info->thread_notes; ++i)\n\t\t\tif (t->notes[i].data &&\n\t\t\t    !writenote(&t->notes[i], cprm))\n\t\t\t\treturn 0;\n\n\t\tfirst = false;\n\t\tt = t->next;\n\t} while (t);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "get_note_info_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
    "lines": "1785-1788",
    "snippet": "static size_t get_note_info_size(struct elf_note_info *info)\n{\n\treturn info->size;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic size_t get_note_info_size(struct elf_note_info *info)\n{\n\treturn info->size;\n}"
  },
  {
    "function_name": "fill_note_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
    "lines": "1690-1783",
    "snippet": "static int fill_note_info(struct elfhdr *elf, int phdrs,\n\t\t\t  struct elf_note_info *info,\n\t\t\t  const siginfo_t *siginfo, struct pt_regs *regs)\n{\n\tstruct task_struct *dump_task = current;\n\tconst struct user_regset_view *view = task_user_regset_view(dump_task);\n\tstruct elf_thread_core_info *t;\n\tstruct elf_prpsinfo *psinfo;\n\tstruct core_thread *ct;\n\tunsigned int i;\n\n\tinfo->size = 0;\n\tinfo->thread = NULL;\n\n\tpsinfo = kmalloc(sizeof(*psinfo), GFP_KERNEL);\n\tif (psinfo == NULL) {\n\t\tinfo->psinfo.data = NULL; /* So we don't free this wrongly */\n\t\treturn 0;\n\t}\n\n\tfill_note(&info->psinfo, \"CORE\", NT_PRPSINFO, sizeof(*psinfo), psinfo);\n\n\t/*\n\t * Figure out how many notes we're going to need for each thread.\n\t */\n\tinfo->thread_notes = 0;\n\tfor (i = 0; i < view->n; ++i)\n\t\tif (view->regsets[i].core_note_type != 0)\n\t\t\t++info->thread_notes;\n\n\t/*\n\t * Sanity check.  We rely on regset 0 being in NT_PRSTATUS,\n\t * since it is our one special case.\n\t */\n\tif (unlikely(info->thread_notes == 0) ||\n\t    unlikely(view->regsets[0].core_note_type != NT_PRSTATUS)) {\n\t\tWARN_ON(1);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Initialize the ELF file header.\n\t */\n\tfill_elf_header(elf, phdrs,\n\t\t\tview->e_machine, view->e_flags);\n\n\t/*\n\t * Allocate a structure for each thread.\n\t */\n\tfor (ct = &dump_task->mm->core_state->dumper; ct; ct = ct->next) {\n\t\tt = kzalloc(offsetof(struct elf_thread_core_info,\n\t\t\t\t     notes[info->thread_notes]),\n\t\t\t    GFP_KERNEL);\n\t\tif (unlikely(!t))\n\t\t\treturn 0;\n\n\t\tt->task = ct->task;\n\t\tif (ct->task == dump_task || !info->thread) {\n\t\t\tt->next = info->thread;\n\t\t\tinfo->thread = t;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Make sure to keep the original task at\n\t\t\t * the head of the list.\n\t\t\t */\n\t\t\tt->next = info->thread->next;\n\t\t\tinfo->thread->next = t;\n\t\t}\n\t}\n\n\t/*\n\t * Now fill in each thread's information.\n\t */\n\tfor (t = info->thread; t != NULL; t = t->next)\n\t\tif (!fill_thread_core_info(t, view, siginfo->si_signo, &info->size))\n\t\t\treturn 0;\n\n\t/*\n\t * Fill in the two process-wide notes.\n\t */\n\tfill_psinfo(psinfo, dump_task->group_leader, dump_task->mm);\n\tinfo->size += notesize(&info->psinfo);\n\n\tfill_siginfo_note(&info->signote, &info->csigdata, siginfo);\n\tinfo->size += notesize(&info->signote);\n\n\tfill_auxv_note(&info->auxv, current->mm);\n\tinfo->size += notesize(&info->auxv);\n\n\tif (fill_files_note(&info->files) == 0)\n\t\tinfo->size += notesize(&info->files);\n\n\treturn 1;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "notesize",
          "args": [
            "&info->files"
          ],
          "line": 1780
        },
        "resolved": true,
        "details": {
          "function_name": "notesize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "1325-1334",
          "snippet": "static int notesize(struct memelfnote *en)\n{\n\tint sz;\n\n\tsz = sizeof(struct elf_note);\n\tsz += roundup(strlen(en->name) + 1, 4);\n\tsz += roundup(en->datasz, 4);\n\n\treturn sz;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int notesize(struct memelfnote *en)\n{\n\tint sz;\n\n\tsz = sizeof(struct elf_note);\n\tsz += roundup(strlen(en->name) + 1, 4);\n\tsz += roundup(en->datasz, 4);\n\n\treturn sz;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_files_note",
          "args": [
            "&info->files"
          ],
          "line": 1779
        },
        "resolved": true,
        "details": {
          "function_name": "fill_files_note",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "1506-1579",
          "snippet": "static int fill_files_note(struct memelfnote *note)\n{\n\tstruct vm_area_struct *vma;\n\tunsigned count, size, names_ofs, remaining, n;\n\tuser_long_t *data;\n\tuser_long_t *start_end_ofs;\n\tchar *name_base, *name_curpos;\n\n\t/* *Estimated* file count and total data size needed */\n\tcount = current->mm->map_count;\n\tsize = count * 64;\n\n\tnames_ofs = (2 + 3 * count) * sizeof(data[0]);\n alloc:\n\tif (size >= MAX_FILE_NOTE_SIZE) /* paranoia check */\n\t\treturn -EINVAL;\n\tsize = round_up(size, PAGE_SIZE);\n\tdata = vmalloc(size);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tstart_end_ofs = data + 2;\n\tname_base = name_curpos = ((char *)data) + names_ofs;\n\tremaining = size - names_ofs;\n\tcount = 0;\n\tfor (vma = current->mm->mmap; vma != NULL; vma = vma->vm_next) {\n\t\tstruct file *file;\n\t\tconst char *filename;\n\n\t\tfile = vma->vm_file;\n\t\tif (!file)\n\t\t\tcontinue;\n\t\tfilename = d_path(&file->f_path, name_curpos, remaining);\n\t\tif (IS_ERR(filename)) {\n\t\t\tif (PTR_ERR(filename) == -ENAMETOOLONG) {\n\t\t\t\tvfree(data);\n\t\t\t\tsize = size * 5 / 4;\n\t\t\t\tgoto alloc;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* d_path() fills at the end, move name down */\n\t\t/* n = strlen(filename) + 1: */\n\t\tn = (name_curpos + remaining) - filename;\n\t\tremaining = filename - name_curpos;\n\t\tmemmove(name_curpos, filename, n);\n\t\tname_curpos += n;\n\n\t\t*start_end_ofs++ = vma->vm_start;\n\t\t*start_end_ofs++ = vma->vm_end;\n\t\t*start_end_ofs++ = vma->vm_pgoff;\n\t\tcount++;\n\t}\n\n\t/* Now we know exact count of files, can store it */\n\tdata[0] = count;\n\tdata[1] = PAGE_SIZE;\n\t/*\n\t * Count usually is less than current->mm->map_count,\n\t * we need to move filenames down.\n\t */\n\tn = current->mm->map_count - count;\n\tif (n != 0) {\n\t\tunsigned shift_bytes = n * 3 * sizeof(data[0]);\n\t\tmemmove(name_base - shift_bytes, name_base,\n\t\t\tname_curpos - name_base);\n\t\tname_curpos -= shift_bytes;\n\t}\n\n\tsize = name_curpos - (char *)data;\n\tfill_note(note, \"CORE\", NT_FILE, size, data);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define MAX_FILE_NOTE_SIZE (4*1024*1024)",
            "#define user_long_t long"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define MAX_FILE_NOTE_SIZE (4*1024*1024)\n#define user_long_t long\n\nstatic int fill_files_note(struct memelfnote *note)\n{\n\tstruct vm_area_struct *vma;\n\tunsigned count, size, names_ofs, remaining, n;\n\tuser_long_t *data;\n\tuser_long_t *start_end_ofs;\n\tchar *name_base, *name_curpos;\n\n\t/* *Estimated* file count and total data size needed */\n\tcount = current->mm->map_count;\n\tsize = count * 64;\n\n\tnames_ofs = (2 + 3 * count) * sizeof(data[0]);\n alloc:\n\tif (size >= MAX_FILE_NOTE_SIZE) /* paranoia check */\n\t\treturn -EINVAL;\n\tsize = round_up(size, PAGE_SIZE);\n\tdata = vmalloc(size);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tstart_end_ofs = data + 2;\n\tname_base = name_curpos = ((char *)data) + names_ofs;\n\tremaining = size - names_ofs;\n\tcount = 0;\n\tfor (vma = current->mm->mmap; vma != NULL; vma = vma->vm_next) {\n\t\tstruct file *file;\n\t\tconst char *filename;\n\n\t\tfile = vma->vm_file;\n\t\tif (!file)\n\t\t\tcontinue;\n\t\tfilename = d_path(&file->f_path, name_curpos, remaining);\n\t\tif (IS_ERR(filename)) {\n\t\t\tif (PTR_ERR(filename) == -ENAMETOOLONG) {\n\t\t\t\tvfree(data);\n\t\t\t\tsize = size * 5 / 4;\n\t\t\t\tgoto alloc;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* d_path() fills at the end, move name down */\n\t\t/* n = strlen(filename) + 1: */\n\t\tn = (name_curpos + remaining) - filename;\n\t\tremaining = filename - name_curpos;\n\t\tmemmove(name_curpos, filename, n);\n\t\tname_curpos += n;\n\n\t\t*start_end_ofs++ = vma->vm_start;\n\t\t*start_end_ofs++ = vma->vm_end;\n\t\t*start_end_ofs++ = vma->vm_pgoff;\n\t\tcount++;\n\t}\n\n\t/* Now we know exact count of files, can store it */\n\tdata[0] = count;\n\tdata[1] = PAGE_SIZE;\n\t/*\n\t * Count usually is less than current->mm->map_count,\n\t * we need to move filenames down.\n\t */\n\tn = current->mm->map_count - count;\n\tif (n != 0) {\n\t\tunsigned shift_bytes = n * 3 * sizeof(data[0]);\n\t\tmemmove(name_base - shift_bytes, name_base,\n\t\t\tname_curpos - name_base);\n\t\tname_curpos -= shift_bytes;\n\t}\n\n\tsize = name_curpos - (char *)data;\n\tfill_note(note, \"CORE\", NT_FILE, size, data);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_auxv_note",
          "args": [
            "&info->auxv",
            "current->mm"
          ],
          "line": 1776
        },
        "resolved": true,
        "details": {
          "function_name": "fill_auxv_note",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "1474-1482",
          "snippet": "static void fill_auxv_note(struct memelfnote *note, struct mm_struct *mm)\n{\n\telf_addr_t *auxv = (elf_addr_t *) mm->saved_auxv;\n\tint i = 0;\n\tdo\n\t\ti += 2;\n\twhile (auxv[i - 2] != AT_NULL);\n\tfill_note(note, \"CORE\", NT_AUXV, i * sizeof(elf_addr_t), auxv);\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void fill_auxv_note(struct memelfnote *note, struct mm_struct *mm)\n{\n\telf_addr_t *auxv = (elf_addr_t *) mm->saved_auxv;\n\tint i = 0;\n\tdo\n\t\ti += 2;\n\twhile (auxv[i - 2] != AT_NULL);\n\tfill_note(note, \"CORE\", NT_AUXV, i * sizeof(elf_addr_t), auxv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_siginfo_note",
          "args": [
            "&info->signote",
            "&info->csigdata",
            "siginfo"
          ],
          "line": 1773
        },
        "resolved": true,
        "details": {
          "function_name": "fill_siginfo_note",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "1484-1492",
          "snippet": "static void fill_siginfo_note(struct memelfnote *note, user_siginfo_t *csigdata,\n\t\tconst siginfo_t *siginfo)\n{\n\tmm_segment_t old_fs = get_fs();\n\tset_fs(KERNEL_DS);\n\tcopy_siginfo_to_user((user_siginfo_t __user *) csigdata, siginfo);\n\tset_fs(old_fs);\n\tfill_note(note, \"CORE\", NT_SIGINFO, sizeof(*csigdata), csigdata);\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define user_siginfo_t siginfo_t"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define user_siginfo_t siginfo_t\n\nstatic void fill_siginfo_note(struct memelfnote *note, user_siginfo_t *csigdata,\n\t\tconst siginfo_t *siginfo)\n{\n\tmm_segment_t old_fs = get_fs();\n\tset_fs(KERNEL_DS);\n\tcopy_siginfo_to_user((user_siginfo_t __user *) csigdata, siginfo);\n\tset_fs(old_fs);\n\tfill_note(note, \"CORE\", NT_SIGINFO, sizeof(*csigdata), csigdata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_psinfo",
          "args": [
            "psinfo",
            "dump_task->group_leader",
            "dump_task->mm"
          ],
          "line": 1770
        },
        "resolved": true,
        "details": {
          "function_name": "fill_psinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "1431-1472",
          "snippet": "static int fill_psinfo(struct elf_prpsinfo *psinfo, struct task_struct *p,\n\t\t       struct mm_struct *mm)\n{\n\tconst struct cred *cred;\n\tunsigned int i, len;\n\t\n\t/* first copy the parameters from user space */\n\tmemset(psinfo, 0, sizeof(struct elf_prpsinfo));\n\n\tlen = mm->arg_end - mm->arg_start;\n\tif (len >= ELF_PRARGSZ)\n\t\tlen = ELF_PRARGSZ-1;\n\tif (copy_from_user(&psinfo->pr_psargs,\n\t\t           (const char __user *)mm->arg_start, len))\n\t\treturn -EFAULT;\n\tfor(i = 0; i < len; i++)\n\t\tif (psinfo->pr_psargs[i] == 0)\n\t\t\tpsinfo->pr_psargs[i] = ' ';\n\tpsinfo->pr_psargs[len] = 0;\n\n\trcu_read_lock();\n\tpsinfo->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tpsinfo->pr_pid = task_pid_vnr(p);\n\tpsinfo->pr_pgrp = task_pgrp_vnr(p);\n\tpsinfo->pr_sid = task_session_vnr(p);\n\n\ti = p->state ? ffz(~p->state) + 1 : 0;\n\tpsinfo->pr_state = i;\n\tpsinfo->pr_sname = (i > 5) ? '.' : \"RSDTZW\"[i];\n\tpsinfo->pr_zomb = psinfo->pr_sname == 'Z';\n\tpsinfo->pr_nice = task_nice(p);\n\tpsinfo->pr_flag = p->flags;\n\trcu_read_lock();\n\tcred = __task_cred(p);\n\tSET_UID(psinfo->pr_uid, from_kuid_munged(cred->user_ns, cred->uid));\n\tSET_GID(psinfo->pr_gid, from_kgid_munged(cred->user_ns, cred->gid));\n\trcu_read_unlock();\n\tstrncpy(psinfo->pr_fname, p->comm, sizeof(psinfo->pr_fname));\n\t\n\treturn 0;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int fill_psinfo(struct elf_prpsinfo *psinfo, struct task_struct *p,\n\t\t       struct mm_struct *mm)\n{\n\tconst struct cred *cred;\n\tunsigned int i, len;\n\t\n\t/* first copy the parameters from user space */\n\tmemset(psinfo, 0, sizeof(struct elf_prpsinfo));\n\n\tlen = mm->arg_end - mm->arg_start;\n\tif (len >= ELF_PRARGSZ)\n\t\tlen = ELF_PRARGSZ-1;\n\tif (copy_from_user(&psinfo->pr_psargs,\n\t\t           (const char __user *)mm->arg_start, len))\n\t\treturn -EFAULT;\n\tfor(i = 0; i < len; i++)\n\t\tif (psinfo->pr_psargs[i] == 0)\n\t\t\tpsinfo->pr_psargs[i] = ' ';\n\tpsinfo->pr_psargs[len] = 0;\n\n\trcu_read_lock();\n\tpsinfo->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tpsinfo->pr_pid = task_pid_vnr(p);\n\tpsinfo->pr_pgrp = task_pgrp_vnr(p);\n\tpsinfo->pr_sid = task_session_vnr(p);\n\n\ti = p->state ? ffz(~p->state) + 1 : 0;\n\tpsinfo->pr_state = i;\n\tpsinfo->pr_sname = (i > 5) ? '.' : \"RSDTZW\"[i];\n\tpsinfo->pr_zomb = psinfo->pr_sname == 'Z';\n\tpsinfo->pr_nice = task_nice(p);\n\tpsinfo->pr_flag = p->flags;\n\trcu_read_lock();\n\tcred = __task_cred(p);\n\tSET_UID(psinfo->pr_uid, from_kuid_munged(cred->user_ns, cred->uid));\n\tSET_GID(psinfo->pr_gid, from_kgid_munged(cred->user_ns, cred->gid));\n\trcu_read_unlock();\n\tstrncpy(psinfo->pr_fname, p->comm, sizeof(psinfo->pr_fname));\n\t\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_thread_core_info",
          "args": [
            "t",
            "view",
            "siginfo->si_signo",
            "&info->size"
          ],
          "line": 1764
        },
        "resolved": true,
        "details": {
          "function_name": "fill_thread_core_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "1630-1688",
          "snippet": "static int fill_thread_core_info(struct elf_thread_core_info *t,\n\t\t\t\t const struct user_regset_view *view,\n\t\t\t\t long signr, size_t *total)\n{\n\tunsigned int i;\n\n\t/*\n\t * NT_PRSTATUS is the one special case, because the regset data\n\t * goes into the pr_reg field inside the note contents, rather\n\t * than being the whole note contents.  We fill the reset in here.\n\t * We assume that regset 0 is NT_PRSTATUS.\n\t */\n\tfill_prstatus(&t->prstatus, t->task, signr);\n\t(void) view->regsets[0].get(t->task, &view->regsets[0],\n\t\t\t\t    0, PR_REG_SIZE(t->prstatus.pr_reg),\n\t\t\t\t    PR_REG_PTR(&t->prstatus), NULL);\n\n\tfill_note(&t->notes[0], \"CORE\", NT_PRSTATUS,\n\t\t  PRSTATUS_SIZE(t->prstatus), &t->prstatus);\n\t*total += notesize(&t->notes[0]);\n\n\tdo_thread_regset_writeback(t->task, &view->regsets[0]);\n\n\t/*\n\t * Each other regset might generate a note too.  For each regset\n\t * that has no core_note_type or is inactive, we leave t->notes[i]\n\t * all zero and we'll know to skip writing it later.\n\t */\n\tfor (i = 1; i < view->n; ++i) {\n\t\tconst struct user_regset *regset = &view->regsets[i];\n\t\tdo_thread_regset_writeback(t->task, regset);\n\t\tif (regset->core_note_type && regset->get &&\n\t\t    (!regset->active || regset->active(t->task, regset))) {\n\t\t\tint ret;\n\t\t\tsize_t size = regset->n * regset->size;\n\t\t\tvoid *data = kmalloc(size, GFP_KERNEL);\n\t\t\tif (unlikely(!data))\n\t\t\t\treturn 0;\n\t\t\tret = regset->get(t->task, regset,\n\t\t\t\t\t  0, size, data, NULL);\n\t\t\tif (unlikely(ret))\n\t\t\t\tkfree(data);\n\t\t\telse {\n\t\t\t\tif (regset->core_note_type != NT_PRFPREG)\n\t\t\t\t\tfill_note(&t->notes[i], \"LINUX\",\n\t\t\t\t\t\t  regset->core_note_type,\n\t\t\t\t\t\t  size, data);\n\t\t\t\telse {\n\t\t\t\t\tSET_PR_FPVALID(&t->prstatus, 1);\n\t\t\t\t\tfill_note(&t->notes[i], \"CORE\",\n\t\t\t\t\t\t  NT_PRFPREG, size, data);\n\t\t\t\t}\n\t\t\t\t*total += notesize(&t->notes[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int fill_thread_core_info(struct elf_thread_core_info *t,\n\t\t\t\t const struct user_regset_view *view,\n\t\t\t\t long signr, size_t *total)\n{\n\tunsigned int i;\n\n\t/*\n\t * NT_PRSTATUS is the one special case, because the regset data\n\t * goes into the pr_reg field inside the note contents, rather\n\t * than being the whole note contents.  We fill the reset in here.\n\t * We assume that regset 0 is NT_PRSTATUS.\n\t */\n\tfill_prstatus(&t->prstatus, t->task, signr);\n\t(void) view->regsets[0].get(t->task, &view->regsets[0],\n\t\t\t\t    0, PR_REG_SIZE(t->prstatus.pr_reg),\n\t\t\t\t    PR_REG_PTR(&t->prstatus), NULL);\n\n\tfill_note(&t->notes[0], \"CORE\", NT_PRSTATUS,\n\t\t  PRSTATUS_SIZE(t->prstatus), &t->prstatus);\n\t*total += notesize(&t->notes[0]);\n\n\tdo_thread_regset_writeback(t->task, &view->regsets[0]);\n\n\t/*\n\t * Each other regset might generate a note too.  For each regset\n\t * that has no core_note_type or is inactive, we leave t->notes[i]\n\t * all zero and we'll know to skip writing it later.\n\t */\n\tfor (i = 1; i < view->n; ++i) {\n\t\tconst struct user_regset *regset = &view->regsets[i];\n\t\tdo_thread_regset_writeback(t->task, regset);\n\t\tif (regset->core_note_type && regset->get &&\n\t\t    (!regset->active || regset->active(t->task, regset))) {\n\t\t\tint ret;\n\t\t\tsize_t size = regset->n * regset->size;\n\t\t\tvoid *data = kmalloc(size, GFP_KERNEL);\n\t\t\tif (unlikely(!data))\n\t\t\t\treturn 0;\n\t\t\tret = regset->get(t->task, regset,\n\t\t\t\t\t  0, size, data, NULL);\n\t\t\tif (unlikely(ret))\n\t\t\t\tkfree(data);\n\t\t\telse {\n\t\t\t\tif (regset->core_note_type != NT_PRFPREG)\n\t\t\t\t\tfill_note(&t->notes[i], \"LINUX\",\n\t\t\t\t\t\t  regset->core_note_type,\n\t\t\t\t\t\t  size, data);\n\t\t\t\telse {\n\t\t\t\t\tSET_PR_FPVALID(&t->prstatus, 1);\n\t\t\t\t\tfill_note(&t->notes[i], \"CORE\",\n\t\t\t\t\t\t  NT_PRFPREG, size, data);\n\t\t\t\t}\n\t\t\t\t*total += notesize(&t->notes[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!t"
          ],
          "line": 1743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "offsetof(struct elf_thread_core_info,\n\t\t\t\t     notes[info->thread_notes]"
          ],
          "line": 1740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill_elf_header",
          "args": [
            "elf",
            "phdrs",
            "view->e_machine",
            "view->e_flags"
          ],
          "line": 1733
        },
        "resolved": true,
        "details": {
          "function_name": "fill_elf_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "1348-1369",
          "snippet": "static void fill_elf_header(struct elfhdr *elf, int segs,\n\t\t\t    u16 machine, u32 flags)\n{\n\tmemset(elf, 0, sizeof(*elf));\n\n\tmemcpy(elf->e_ident, ELFMAG, SELFMAG);\n\telf->e_ident[EI_CLASS] = ELF_CLASS;\n\telf->e_ident[EI_DATA] = ELF_DATA;\n\telf->e_ident[EI_VERSION] = EV_CURRENT;\n\telf->e_ident[EI_OSABI] = ELF_OSABI;\n\n\telf->e_type = ET_CORE;\n\telf->e_machine = machine;\n\telf->e_version = EV_CURRENT;\n\telf->e_phoff = sizeof(struct elfhdr);\n\telf->e_flags = flags;\n\telf->e_ehsize = sizeof(struct elfhdr);\n\telf->e_phentsize = sizeof(struct elf_phdr);\n\telf->e_phnum = segs;\n\n\treturn;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);\n\nstatic void fill_elf_header(struct elfhdr *elf, int segs,\n\t\t\t    u16 machine, u32 flags)\n{\n\tmemset(elf, 0, sizeof(*elf));\n\n\tmemcpy(elf->e_ident, ELFMAG, SELFMAG);\n\telf->e_ident[EI_CLASS] = ELF_CLASS;\n\telf->e_ident[EI_DATA] = ELF_DATA;\n\telf->e_ident[EI_VERSION] = EV_CURRENT;\n\telf->e_ident[EI_OSABI] = ELF_OSABI;\n\n\telf->e_type = ET_CORE;\n\telf->e_machine = machine;\n\telf->e_version = EV_CURRENT;\n\telf->e_phoff = sizeof(struct elfhdr);\n\telf->e_flags = flags;\n\telf->e_ehsize = sizeof(struct elfhdr);\n\telf->e_phentsize = sizeof(struct elf_phdr);\n\telf->e_phnum = segs;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "view->regsets[0].core_note_type != NT_PRSTATUS"
          ],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "info->thread_notes == 0"
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill_note",
          "args": [
            "&info->psinfo",
            "\"CORE\"",
            "NT_PRPSINFO",
            "sizeof(*psinfo)",
            "psinfo"
          ],
          "line": 1710
        },
        "resolved": true,
        "details": {
          "function_name": "fill_note_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "1939-2009",
          "snippet": "static int fill_note_info(struct elfhdr *elf, int phdrs,\n\t\t\t  struct elf_note_info *info,\n\t\t\t  const siginfo_t *siginfo, struct pt_regs *regs)\n{\n\tstruct list_head *t;\n\tstruct core_thread *ct;\n\tstruct elf_thread_status *ets;\n\n\tif (!elf_note_info_init(info))\n\t\treturn 0;\n\n\tfor (ct = current->mm->core_state->dumper.next;\n\t\t\t\t\tct; ct = ct->next) {\n\t\tets = kzalloc(sizeof(*ets), GFP_KERNEL);\n\t\tif (!ets)\n\t\t\treturn 0;\n\n\t\tets->thread = ct->task;\n\t\tlist_add(&ets->list, &info->thread_list);\n\t}\n\n\tlist_for_each(t, &info->thread_list) {\n\t\tint sz;\n\n\t\tets = list_entry(t, struct elf_thread_status, list);\n\t\tsz = elf_dump_thread_status(siginfo->si_signo, ets);\n\t\tinfo->thread_status_size += sz;\n\t}\n\t/* now collect the dump for the current */\n\tmemset(info->prstatus, 0, sizeof(*info->prstatus));\n\tfill_prstatus(info->prstatus, current, siginfo->si_signo);\n\telf_core_copy_regs(&info->prstatus->pr_reg, regs);\n\n\t/* Set up header */\n\tfill_elf_header(elf, phdrs, ELF_ARCH, ELF_CORE_EFLAGS);\n\n\t/*\n\t * Set up the notes in similar form to SVR4 core dumps made\n\t * with info from their /proc.\n\t */\n\n\tfill_note(info->notes + 0, \"CORE\", NT_PRSTATUS,\n\t\t  sizeof(*info->prstatus), info->prstatus);\n\tfill_psinfo(info->psinfo, current->group_leader, current->mm);\n\tfill_note(info->notes + 1, \"CORE\", NT_PRPSINFO,\n\t\t  sizeof(*info->psinfo), info->psinfo);\n\n\tfill_siginfo_note(info->notes + 2, &info->csigdata, siginfo);\n\tfill_auxv_note(info->notes + 3, current->mm);\n\tinfo->numnote = 4;\n\n\tif (fill_files_note(info->notes + info->numnote) == 0) {\n\t\tinfo->notes_files = info->notes + info->numnote;\n\t\tinfo->numnote++;\n\t}\n\n\t/* Try to dump the FPU. */\n\tinfo->prstatus->pr_fpvalid = elf_core_copy_task_fpregs(current, regs,\n\t\t\t\t\t\t\t       info->fpu);\n\tif (info->prstatus->pr_fpvalid)\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"CORE\", NT_PRFPREG, sizeof(*info->fpu), info->fpu);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(current, info->xfpu))\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(*info->xfpu), info->xfpu);\n#endif\n\n\treturn 1;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*psinfo)",
            "GFP_KERNEL"
          ],
          "line": 1704
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_user_regset_view",
          "args": [
            "dump_task"
          ],
          "line": 1695
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int fill_note_info(struct elfhdr *elf, int phdrs,\n\t\t\t  struct elf_note_info *info,\n\t\t\t  const siginfo_t *siginfo, struct pt_regs *regs)\n{\n\tstruct task_struct *dump_task = current;\n\tconst struct user_regset_view *view = task_user_regset_view(dump_task);\n\tstruct elf_thread_core_info *t;\n\tstruct elf_prpsinfo *psinfo;\n\tstruct core_thread *ct;\n\tunsigned int i;\n\n\tinfo->size = 0;\n\tinfo->thread = NULL;\n\n\tpsinfo = kmalloc(sizeof(*psinfo), GFP_KERNEL);\n\tif (psinfo == NULL) {\n\t\tinfo->psinfo.data = NULL; /* So we don't free this wrongly */\n\t\treturn 0;\n\t}\n\n\tfill_note(&info->psinfo, \"CORE\", NT_PRPSINFO, sizeof(*psinfo), psinfo);\n\n\t/*\n\t * Figure out how many notes we're going to need for each thread.\n\t */\n\tinfo->thread_notes = 0;\n\tfor (i = 0; i < view->n; ++i)\n\t\tif (view->regsets[i].core_note_type != 0)\n\t\t\t++info->thread_notes;\n\n\t/*\n\t * Sanity check.  We rely on regset 0 being in NT_PRSTATUS,\n\t * since it is our one special case.\n\t */\n\tif (unlikely(info->thread_notes == 0) ||\n\t    unlikely(view->regsets[0].core_note_type != NT_PRSTATUS)) {\n\t\tWARN_ON(1);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Initialize the ELF file header.\n\t */\n\tfill_elf_header(elf, phdrs,\n\t\t\tview->e_machine, view->e_flags);\n\n\t/*\n\t * Allocate a structure for each thread.\n\t */\n\tfor (ct = &dump_task->mm->core_state->dumper; ct; ct = ct->next) {\n\t\tt = kzalloc(offsetof(struct elf_thread_core_info,\n\t\t\t\t     notes[info->thread_notes]),\n\t\t\t    GFP_KERNEL);\n\t\tif (unlikely(!t))\n\t\t\treturn 0;\n\n\t\tt->task = ct->task;\n\t\tif (ct->task == dump_task || !info->thread) {\n\t\t\tt->next = info->thread;\n\t\t\tinfo->thread = t;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Make sure to keep the original task at\n\t\t\t * the head of the list.\n\t\t\t */\n\t\t\tt->next = info->thread->next;\n\t\t\tinfo->thread->next = t;\n\t\t}\n\t}\n\n\t/*\n\t * Now fill in each thread's information.\n\t */\n\tfor (t = info->thread; t != NULL; t = t->next)\n\t\tif (!fill_thread_core_info(t, view, siginfo->si_signo, &info->size))\n\t\t\treturn 0;\n\n\t/*\n\t * Fill in the two process-wide notes.\n\t */\n\tfill_psinfo(psinfo, dump_task->group_leader, dump_task->mm);\n\tinfo->size += notesize(&info->psinfo);\n\n\tfill_siginfo_note(&info->signote, &info->csigdata, siginfo);\n\tinfo->size += notesize(&info->signote);\n\n\tfill_auxv_note(&info->auxv, current->mm);\n\tinfo->size += notesize(&info->auxv);\n\n\tif (fill_files_note(&info->files) == 0)\n\t\tinfo->size += notesize(&info->files);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "fill_thread_core_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
    "lines": "1630-1688",
    "snippet": "static int fill_thread_core_info(struct elf_thread_core_info *t,\n\t\t\t\t const struct user_regset_view *view,\n\t\t\t\t long signr, size_t *total)\n{\n\tunsigned int i;\n\n\t/*\n\t * NT_PRSTATUS is the one special case, because the regset data\n\t * goes into the pr_reg field inside the note contents, rather\n\t * than being the whole note contents.  We fill the reset in here.\n\t * We assume that regset 0 is NT_PRSTATUS.\n\t */\n\tfill_prstatus(&t->prstatus, t->task, signr);\n\t(void) view->regsets[0].get(t->task, &view->regsets[0],\n\t\t\t\t    0, PR_REG_SIZE(t->prstatus.pr_reg),\n\t\t\t\t    PR_REG_PTR(&t->prstatus), NULL);\n\n\tfill_note(&t->notes[0], \"CORE\", NT_PRSTATUS,\n\t\t  PRSTATUS_SIZE(t->prstatus), &t->prstatus);\n\t*total += notesize(&t->notes[0]);\n\n\tdo_thread_regset_writeback(t->task, &view->regsets[0]);\n\n\t/*\n\t * Each other regset might generate a note too.  For each regset\n\t * that has no core_note_type or is inactive, we leave t->notes[i]\n\t * all zero and we'll know to skip writing it later.\n\t */\n\tfor (i = 1; i < view->n; ++i) {\n\t\tconst struct user_regset *regset = &view->regsets[i];\n\t\tdo_thread_regset_writeback(t->task, regset);\n\t\tif (regset->core_note_type && regset->get &&\n\t\t    (!regset->active || regset->active(t->task, regset))) {\n\t\t\tint ret;\n\t\t\tsize_t size = regset->n * regset->size;\n\t\t\tvoid *data = kmalloc(size, GFP_KERNEL);\n\t\t\tif (unlikely(!data))\n\t\t\t\treturn 0;\n\t\t\tret = regset->get(t->task, regset,\n\t\t\t\t\t  0, size, data, NULL);\n\t\t\tif (unlikely(ret))\n\t\t\t\tkfree(data);\n\t\t\telse {\n\t\t\t\tif (regset->core_note_type != NT_PRFPREG)\n\t\t\t\t\tfill_note(&t->notes[i], \"LINUX\",\n\t\t\t\t\t\t  regset->core_note_type,\n\t\t\t\t\t\t  size, data);\n\t\t\t\telse {\n\t\t\t\t\tSET_PR_FPVALID(&t->prstatus, 1);\n\t\t\t\t\tfill_note(&t->notes[i], \"CORE\",\n\t\t\t\t\t\t  NT_PRFPREG, size, data);\n\t\t\t\t}\n\t\t\t\t*total += notesize(&t->notes[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "notesize",
          "args": [
            "&t->notes[i]"
          ],
          "line": 1682
        },
        "resolved": true,
        "details": {
          "function_name": "notesize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "1325-1334",
          "snippet": "static int notesize(struct memelfnote *en)\n{\n\tint sz;\n\n\tsz = sizeof(struct elf_note);\n\tsz += roundup(strlen(en->name) + 1, 4);\n\tsz += roundup(en->datasz, 4);\n\n\treturn sz;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int notesize(struct memelfnote *en)\n{\n\tint sz;\n\n\tsz = sizeof(struct elf_note);\n\tsz += roundup(strlen(en->name) + 1, 4);\n\tsz += roundup(en->datasz, 4);\n\n\treturn sz;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_note",
          "args": [
            "&t->notes[i]",
            "\"CORE\"",
            "NT_PRFPREG",
            "size",
            "data"
          ],
          "line": 1679
        },
        "resolved": true,
        "details": {
          "function_name": "fill_note_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "1939-2009",
          "snippet": "static int fill_note_info(struct elfhdr *elf, int phdrs,\n\t\t\t  struct elf_note_info *info,\n\t\t\t  const siginfo_t *siginfo, struct pt_regs *regs)\n{\n\tstruct list_head *t;\n\tstruct core_thread *ct;\n\tstruct elf_thread_status *ets;\n\n\tif (!elf_note_info_init(info))\n\t\treturn 0;\n\n\tfor (ct = current->mm->core_state->dumper.next;\n\t\t\t\t\tct; ct = ct->next) {\n\t\tets = kzalloc(sizeof(*ets), GFP_KERNEL);\n\t\tif (!ets)\n\t\t\treturn 0;\n\n\t\tets->thread = ct->task;\n\t\tlist_add(&ets->list, &info->thread_list);\n\t}\n\n\tlist_for_each(t, &info->thread_list) {\n\t\tint sz;\n\n\t\tets = list_entry(t, struct elf_thread_status, list);\n\t\tsz = elf_dump_thread_status(siginfo->si_signo, ets);\n\t\tinfo->thread_status_size += sz;\n\t}\n\t/* now collect the dump for the current */\n\tmemset(info->prstatus, 0, sizeof(*info->prstatus));\n\tfill_prstatus(info->prstatus, current, siginfo->si_signo);\n\telf_core_copy_regs(&info->prstatus->pr_reg, regs);\n\n\t/* Set up header */\n\tfill_elf_header(elf, phdrs, ELF_ARCH, ELF_CORE_EFLAGS);\n\n\t/*\n\t * Set up the notes in similar form to SVR4 core dumps made\n\t * with info from their /proc.\n\t */\n\n\tfill_note(info->notes + 0, \"CORE\", NT_PRSTATUS,\n\t\t  sizeof(*info->prstatus), info->prstatus);\n\tfill_psinfo(info->psinfo, current->group_leader, current->mm);\n\tfill_note(info->notes + 1, \"CORE\", NT_PRPSINFO,\n\t\t  sizeof(*info->psinfo), info->psinfo);\n\n\tfill_siginfo_note(info->notes + 2, &info->csigdata, siginfo);\n\tfill_auxv_note(info->notes + 3, current->mm);\n\tinfo->numnote = 4;\n\n\tif (fill_files_note(info->notes + info->numnote) == 0) {\n\t\tinfo->notes_files = info->notes + info->numnote;\n\t\tinfo->numnote++;\n\t}\n\n\t/* Try to dump the FPU. */\n\tinfo->prstatus->pr_fpvalid = elf_core_copy_task_fpregs(current, regs,\n\t\t\t\t\t\t\t       info->fpu);\n\tif (info->prstatus->pr_fpvalid)\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"CORE\", NT_PRFPREG, sizeof(*info->fpu), info->fpu);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(current, info->xfpu))\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(*info->xfpu), info->xfpu);\n#endif\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define ELF_CORE_EFLAGS\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define ELF_CORE_EFLAGS\t0\n\nstatic int fill_note_info(struct elfhdr *elf, int phdrs,\n\t\t\t  struct elf_note_info *info,\n\t\t\t  const siginfo_t *siginfo, struct pt_regs *regs)\n{\n\tstruct list_head *t;\n\tstruct core_thread *ct;\n\tstruct elf_thread_status *ets;\n\n\tif (!elf_note_info_init(info))\n\t\treturn 0;\n\n\tfor (ct = current->mm->core_state->dumper.next;\n\t\t\t\t\tct; ct = ct->next) {\n\t\tets = kzalloc(sizeof(*ets), GFP_KERNEL);\n\t\tif (!ets)\n\t\t\treturn 0;\n\n\t\tets->thread = ct->task;\n\t\tlist_add(&ets->list, &info->thread_list);\n\t}\n\n\tlist_for_each(t, &info->thread_list) {\n\t\tint sz;\n\n\t\tets = list_entry(t, struct elf_thread_status, list);\n\t\tsz = elf_dump_thread_status(siginfo->si_signo, ets);\n\t\tinfo->thread_status_size += sz;\n\t}\n\t/* now collect the dump for the current */\n\tmemset(info->prstatus, 0, sizeof(*info->prstatus));\n\tfill_prstatus(info->prstatus, current, siginfo->si_signo);\n\telf_core_copy_regs(&info->prstatus->pr_reg, regs);\n\n\t/* Set up header */\n\tfill_elf_header(elf, phdrs, ELF_ARCH, ELF_CORE_EFLAGS);\n\n\t/*\n\t * Set up the notes in similar form to SVR4 core dumps made\n\t * with info from their /proc.\n\t */\n\n\tfill_note(info->notes + 0, \"CORE\", NT_PRSTATUS,\n\t\t  sizeof(*info->prstatus), info->prstatus);\n\tfill_psinfo(info->psinfo, current->group_leader, current->mm);\n\tfill_note(info->notes + 1, \"CORE\", NT_PRPSINFO,\n\t\t  sizeof(*info->psinfo), info->psinfo);\n\n\tfill_siginfo_note(info->notes + 2, &info->csigdata, siginfo);\n\tfill_auxv_note(info->notes + 3, current->mm);\n\tinfo->numnote = 4;\n\n\tif (fill_files_note(info->notes + info->numnote) == 0) {\n\t\tinfo->notes_files = info->notes + info->numnote;\n\t\tinfo->numnote++;\n\t}\n\n\t/* Try to dump the FPU. */\n\tinfo->prstatus->pr_fpvalid = elf_core_copy_task_fpregs(current, regs,\n\t\t\t\t\t\t\t       info->fpu);\n\tif (info->prstatus->pr_fpvalid)\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"CORE\", NT_PRFPREG, sizeof(*info->fpu), info->fpu);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(current, info->xfpu))\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(*info->xfpu), info->xfpu);\n#endif\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SET_PR_FPVALID",
          "args": [
            "&t->prstatus",
            "1"
          ],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 1671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "regset->get",
          "args": [
            "t->task",
            "regset",
            "0",
            "size",
            "data",
            "NULL"
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!data"
          ],
          "line": 1666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 1665
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "regset->active",
          "args": [
            "t->task",
            "regset"
          ],
          "line": 1662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_thread_regset_writeback",
          "args": [
            "t->task",
            "regset"
          ],
          "line": 1660
        },
        "resolved": true,
        "details": {
          "function_name": "do_thread_regset_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "1607-1612",
          "snippet": "static void do_thread_regset_writeback(struct task_struct *task,\n\t\t\t\t       const struct user_regset *regset)\n{\n\tif (regset->writeback)\n\t\tregset->writeback(task, regset, 1);\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void do_thread_regset_writeback(struct task_struct *task,\n\t\t\t\t       const struct user_regset *regset)\n{\n\tif (regset->writeback)\n\t\tregset->writeback(task, regset, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PRSTATUS_SIZE",
          "args": [
            "t->prstatus"
          ],
          "line": 1648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "view->regsets[0].get",
          "args": [
            "t->task",
            "&view->regsets[0]",
            "0",
            "PR_REG_SIZE(t->prstatus.pr_reg)",
            "PR_REG_PTR(&t->prstatus)",
            "NULL"
          ],
          "line": 1643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PR_REG_PTR",
          "args": [
            "&t->prstatus"
          ],
          "line": 1645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PR_REG_SIZE",
          "args": [
            "t->prstatus.pr_reg"
          ],
          "line": 1644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill_prstatus",
          "args": [
            "&t->prstatus",
            "t->task",
            "signr"
          ],
          "line": 1642
        },
        "resolved": true,
        "details": {
          "function_name": "fill_prstatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "1398-1429",
          "snippet": "static void fill_prstatus(struct elf_prstatus *prstatus,\n\t\tstruct task_struct *p, long signr)\n{\n\tprstatus->pr_info.si_signo = prstatus->pr_cursig = signr;\n\tprstatus->pr_sigpend = p->pending.signal.sig[0];\n\tprstatus->pr_sighold = p->blocked.sig[0];\n\trcu_read_lock();\n\tprstatus->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tprstatus->pr_pid = task_pid_vnr(p);\n\tprstatus->pr_pgrp = task_pgrp_vnr(p);\n\tprstatus->pr_sid = task_session_vnr(p);\n\tif (thread_group_leader(p)) {\n\t\tstruct task_cputime cputime;\n\n\t\t/*\n\t\t * This is the record for the group leader.  It shows the\n\t\t * group-wide total, not its individual thread total.\n\t\t */\n\t\tthread_group_cputime(p, &cputime);\n\t\tcputime_to_timeval(cputime.utime, &prstatus->pr_utime);\n\t\tcputime_to_timeval(cputime.stime, &prstatus->pr_stime);\n\t} else {\n\t\tcputime_t utime, stime;\n\n\t\ttask_cputime(p, &utime, &stime);\n\t\tcputime_to_timeval(utime, &prstatus->pr_utime);\n\t\tcputime_to_timeval(stime, &prstatus->pr_stime);\n\t}\n\tcputime_to_timeval(p->signal->cutime, &prstatus->pr_cutime);\n\tcputime_to_timeval(p->signal->cstime, &prstatus->pr_cstime);\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void fill_prstatus(struct elf_prstatus *prstatus,\n\t\tstruct task_struct *p, long signr)\n{\n\tprstatus->pr_info.si_signo = prstatus->pr_cursig = signr;\n\tprstatus->pr_sigpend = p->pending.signal.sig[0];\n\tprstatus->pr_sighold = p->blocked.sig[0];\n\trcu_read_lock();\n\tprstatus->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tprstatus->pr_pid = task_pid_vnr(p);\n\tprstatus->pr_pgrp = task_pgrp_vnr(p);\n\tprstatus->pr_sid = task_session_vnr(p);\n\tif (thread_group_leader(p)) {\n\t\tstruct task_cputime cputime;\n\n\t\t/*\n\t\t * This is the record for the group leader.  It shows the\n\t\t * group-wide total, not its individual thread total.\n\t\t */\n\t\tthread_group_cputime(p, &cputime);\n\t\tcputime_to_timeval(cputime.utime, &prstatus->pr_utime);\n\t\tcputime_to_timeval(cputime.stime, &prstatus->pr_stime);\n\t} else {\n\t\tcputime_t utime, stime;\n\n\t\ttask_cputime(p, &utime, &stime);\n\t\tcputime_to_timeval(utime, &prstatus->pr_utime);\n\t\tcputime_to_timeval(stime, &prstatus->pr_stime);\n\t}\n\tcputime_to_timeval(p->signal->cutime, &prstatus->pr_cutime);\n\tcputime_to_timeval(p->signal->cstime, &prstatus->pr_cstime);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int fill_thread_core_info(struct elf_thread_core_info *t,\n\t\t\t\t const struct user_regset_view *view,\n\t\t\t\t long signr, size_t *total)\n{\n\tunsigned int i;\n\n\t/*\n\t * NT_PRSTATUS is the one special case, because the regset data\n\t * goes into the pr_reg field inside the note contents, rather\n\t * than being the whole note contents.  We fill the reset in here.\n\t * We assume that regset 0 is NT_PRSTATUS.\n\t */\n\tfill_prstatus(&t->prstatus, t->task, signr);\n\t(void) view->regsets[0].get(t->task, &view->regsets[0],\n\t\t\t\t    0, PR_REG_SIZE(t->prstatus.pr_reg),\n\t\t\t\t    PR_REG_PTR(&t->prstatus), NULL);\n\n\tfill_note(&t->notes[0], \"CORE\", NT_PRSTATUS,\n\t\t  PRSTATUS_SIZE(t->prstatus), &t->prstatus);\n\t*total += notesize(&t->notes[0]);\n\n\tdo_thread_regset_writeback(t->task, &view->regsets[0]);\n\n\t/*\n\t * Each other regset might generate a note too.  For each regset\n\t * that has no core_note_type or is inactive, we leave t->notes[i]\n\t * all zero and we'll know to skip writing it later.\n\t */\n\tfor (i = 1; i < view->n; ++i) {\n\t\tconst struct user_regset *regset = &view->regsets[i];\n\t\tdo_thread_regset_writeback(t->task, regset);\n\t\tif (regset->core_note_type && regset->get &&\n\t\t    (!regset->active || regset->active(t->task, regset))) {\n\t\t\tint ret;\n\t\t\tsize_t size = regset->n * regset->size;\n\t\t\tvoid *data = kmalloc(size, GFP_KERNEL);\n\t\t\tif (unlikely(!data))\n\t\t\t\treturn 0;\n\t\t\tret = regset->get(t->task, regset,\n\t\t\t\t\t  0, size, data, NULL);\n\t\t\tif (unlikely(ret))\n\t\t\t\tkfree(data);\n\t\t\telse {\n\t\t\t\tif (regset->core_note_type != NT_PRFPREG)\n\t\t\t\t\tfill_note(&t->notes[i], \"LINUX\",\n\t\t\t\t\t\t  regset->core_note_type,\n\t\t\t\t\t\t  size, data);\n\t\t\t\telse {\n\t\t\t\t\tSET_PR_FPVALID(&t->prstatus, 1);\n\t\t\t\t\tfill_note(&t->notes[i], \"CORE\",\n\t\t\t\t\t\t  NT_PRFPREG, size, data);\n\t\t\t\t}\n\t\t\t\t*total += notesize(&t->notes[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "do_thread_regset_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
    "lines": "1607-1612",
    "snippet": "static void do_thread_regset_writeback(struct task_struct *task,\n\t\t\t\t       const struct user_regset *regset)\n{\n\tif (regset->writeback)\n\t\tregset->writeback(task, regset, 1);\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "regset->writeback",
          "args": [
            "task",
            "regset",
            "1"
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void do_thread_regset_writeback(struct task_struct *task,\n\t\t\t\t       const struct user_regset *regset)\n{\n\tif (regset->writeback)\n\t\tregset->writeback(task, regset, 1);\n}"
  },
  {
    "function_name": "fill_files_note",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
    "lines": "1506-1579",
    "snippet": "static int fill_files_note(struct memelfnote *note)\n{\n\tstruct vm_area_struct *vma;\n\tunsigned count, size, names_ofs, remaining, n;\n\tuser_long_t *data;\n\tuser_long_t *start_end_ofs;\n\tchar *name_base, *name_curpos;\n\n\t/* *Estimated* file count and total data size needed */\n\tcount = current->mm->map_count;\n\tsize = count * 64;\n\n\tnames_ofs = (2 + 3 * count) * sizeof(data[0]);\n alloc:\n\tif (size >= MAX_FILE_NOTE_SIZE) /* paranoia check */\n\t\treturn -EINVAL;\n\tsize = round_up(size, PAGE_SIZE);\n\tdata = vmalloc(size);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tstart_end_ofs = data + 2;\n\tname_base = name_curpos = ((char *)data) + names_ofs;\n\tremaining = size - names_ofs;\n\tcount = 0;\n\tfor (vma = current->mm->mmap; vma != NULL; vma = vma->vm_next) {\n\t\tstruct file *file;\n\t\tconst char *filename;\n\n\t\tfile = vma->vm_file;\n\t\tif (!file)\n\t\t\tcontinue;\n\t\tfilename = d_path(&file->f_path, name_curpos, remaining);\n\t\tif (IS_ERR(filename)) {\n\t\t\tif (PTR_ERR(filename) == -ENAMETOOLONG) {\n\t\t\t\tvfree(data);\n\t\t\t\tsize = size * 5 / 4;\n\t\t\t\tgoto alloc;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* d_path() fills at the end, move name down */\n\t\t/* n = strlen(filename) + 1: */\n\t\tn = (name_curpos + remaining) - filename;\n\t\tremaining = filename - name_curpos;\n\t\tmemmove(name_curpos, filename, n);\n\t\tname_curpos += n;\n\n\t\t*start_end_ofs++ = vma->vm_start;\n\t\t*start_end_ofs++ = vma->vm_end;\n\t\t*start_end_ofs++ = vma->vm_pgoff;\n\t\tcount++;\n\t}\n\n\t/* Now we know exact count of files, can store it */\n\tdata[0] = count;\n\tdata[1] = PAGE_SIZE;\n\t/*\n\t * Count usually is less than current->mm->map_count,\n\t * we need to move filenames down.\n\t */\n\tn = current->mm->map_count - count;\n\tif (n != 0) {\n\t\tunsigned shift_bytes = n * 3 * sizeof(data[0]);\n\t\tmemmove(name_base - shift_bytes, name_base,\n\t\t\tname_curpos - name_base);\n\t\tname_curpos -= shift_bytes;\n\t}\n\n\tsize = name_curpos - (char *)data;\n\tfill_note(note, \"CORE\", NT_FILE, size, data);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define MAX_FILE_NOTE_SIZE (4*1024*1024)",
      "#define user_long_t long"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fill_note",
          "args": [
            "note",
            "\"CORE\"",
            "NT_FILE",
            "size",
            "data"
          ],
          "line": 1577
        },
        "resolved": true,
        "details": {
          "function_name": "fill_note_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "1939-2009",
          "snippet": "static int fill_note_info(struct elfhdr *elf, int phdrs,\n\t\t\t  struct elf_note_info *info,\n\t\t\t  const siginfo_t *siginfo, struct pt_regs *regs)\n{\n\tstruct list_head *t;\n\tstruct core_thread *ct;\n\tstruct elf_thread_status *ets;\n\n\tif (!elf_note_info_init(info))\n\t\treturn 0;\n\n\tfor (ct = current->mm->core_state->dumper.next;\n\t\t\t\t\tct; ct = ct->next) {\n\t\tets = kzalloc(sizeof(*ets), GFP_KERNEL);\n\t\tif (!ets)\n\t\t\treturn 0;\n\n\t\tets->thread = ct->task;\n\t\tlist_add(&ets->list, &info->thread_list);\n\t}\n\n\tlist_for_each(t, &info->thread_list) {\n\t\tint sz;\n\n\t\tets = list_entry(t, struct elf_thread_status, list);\n\t\tsz = elf_dump_thread_status(siginfo->si_signo, ets);\n\t\tinfo->thread_status_size += sz;\n\t}\n\t/* now collect the dump for the current */\n\tmemset(info->prstatus, 0, sizeof(*info->prstatus));\n\tfill_prstatus(info->prstatus, current, siginfo->si_signo);\n\telf_core_copy_regs(&info->prstatus->pr_reg, regs);\n\n\t/* Set up header */\n\tfill_elf_header(elf, phdrs, ELF_ARCH, ELF_CORE_EFLAGS);\n\n\t/*\n\t * Set up the notes in similar form to SVR4 core dumps made\n\t * with info from their /proc.\n\t */\n\n\tfill_note(info->notes + 0, \"CORE\", NT_PRSTATUS,\n\t\t  sizeof(*info->prstatus), info->prstatus);\n\tfill_psinfo(info->psinfo, current->group_leader, current->mm);\n\tfill_note(info->notes + 1, \"CORE\", NT_PRPSINFO,\n\t\t  sizeof(*info->psinfo), info->psinfo);\n\n\tfill_siginfo_note(info->notes + 2, &info->csigdata, siginfo);\n\tfill_auxv_note(info->notes + 3, current->mm);\n\tinfo->numnote = 4;\n\n\tif (fill_files_note(info->notes + info->numnote) == 0) {\n\t\tinfo->notes_files = info->notes + info->numnote;\n\t\tinfo->numnote++;\n\t}\n\n\t/* Try to dump the FPU. */\n\tinfo->prstatus->pr_fpvalid = elf_core_copy_task_fpregs(current, regs,\n\t\t\t\t\t\t\t       info->fpu);\n\tif (info->prstatus->pr_fpvalid)\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"CORE\", NT_PRFPREG, sizeof(*info->fpu), info->fpu);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(current, info->xfpu))\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(*info->xfpu), info->xfpu);\n#endif\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define ELF_CORE_EFLAGS\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define ELF_CORE_EFLAGS\t0\n\nstatic int fill_note_info(struct elfhdr *elf, int phdrs,\n\t\t\t  struct elf_note_info *info,\n\t\t\t  const siginfo_t *siginfo, struct pt_regs *regs)\n{\n\tstruct list_head *t;\n\tstruct core_thread *ct;\n\tstruct elf_thread_status *ets;\n\n\tif (!elf_note_info_init(info))\n\t\treturn 0;\n\n\tfor (ct = current->mm->core_state->dumper.next;\n\t\t\t\t\tct; ct = ct->next) {\n\t\tets = kzalloc(sizeof(*ets), GFP_KERNEL);\n\t\tif (!ets)\n\t\t\treturn 0;\n\n\t\tets->thread = ct->task;\n\t\tlist_add(&ets->list, &info->thread_list);\n\t}\n\n\tlist_for_each(t, &info->thread_list) {\n\t\tint sz;\n\n\t\tets = list_entry(t, struct elf_thread_status, list);\n\t\tsz = elf_dump_thread_status(siginfo->si_signo, ets);\n\t\tinfo->thread_status_size += sz;\n\t}\n\t/* now collect the dump for the current */\n\tmemset(info->prstatus, 0, sizeof(*info->prstatus));\n\tfill_prstatus(info->prstatus, current, siginfo->si_signo);\n\telf_core_copy_regs(&info->prstatus->pr_reg, regs);\n\n\t/* Set up header */\n\tfill_elf_header(elf, phdrs, ELF_ARCH, ELF_CORE_EFLAGS);\n\n\t/*\n\t * Set up the notes in similar form to SVR4 core dumps made\n\t * with info from their /proc.\n\t */\n\n\tfill_note(info->notes + 0, \"CORE\", NT_PRSTATUS,\n\t\t  sizeof(*info->prstatus), info->prstatus);\n\tfill_psinfo(info->psinfo, current->group_leader, current->mm);\n\tfill_note(info->notes + 1, \"CORE\", NT_PRPSINFO,\n\t\t  sizeof(*info->psinfo), info->psinfo);\n\n\tfill_siginfo_note(info->notes + 2, &info->csigdata, siginfo);\n\tfill_auxv_note(info->notes + 3, current->mm);\n\tinfo->numnote = 4;\n\n\tif (fill_files_note(info->notes + info->numnote) == 0) {\n\t\tinfo->notes_files = info->notes + info->numnote;\n\t\tinfo->numnote++;\n\t}\n\n\t/* Try to dump the FPU. */\n\tinfo->prstatus->pr_fpvalid = elf_core_copy_task_fpregs(current, regs,\n\t\t\t\t\t\t\t       info->fpu);\n\tif (info->prstatus->pr_fpvalid)\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"CORE\", NT_PRFPREG, sizeof(*info->fpu), info->fpu);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(current, info->xfpu))\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(*info->xfpu), info->xfpu);\n#endif\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "name_base - shift_bytes",
            "name_base",
            "name_curpos - name_base"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "name_curpos",
            "filename",
            "n"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "data"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "filename"
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "filename"
          ],
          "line": 1539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_path",
          "args": [
            "&file->f_path",
            "name_curpos",
            "remaining"
          ],
          "line": 1538
        },
        "resolved": true,
        "details": {
          "function_name": "d_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "3047-3076",
          "snippet": "char *d_path(const struct path *path, char *buf, int buflen)\n{\n\tchar *res = buf + buflen;\n\tstruct path root;\n\tint error;\n\n\t/*\n\t * We have various synthetic filesystems that never get mounted.  On\n\t * these filesystems dentries are never used for lookup purposes, and\n\t * thus don't need to be hashed.  They also don't need a name until a\n\t * user wants to identify the object in /proc/pid/fd/.  The little hack\n\t * below allows us to generate a name for these objects on demand:\n\t *\n\t * Some pseudo inodes are mountable.  When they are mounted\n\t * path->dentry == path->mnt->mnt_root.  In that case don't call d_dname\n\t * and instead have d_path return the mounted path.\n\t */\n\tif (path->dentry->d_op && path->dentry->d_op->d_dname &&\n\t    (!IS_ROOT(path->dentry) || path->dentry != path->mnt->mnt_root))\n\t\treturn path->dentry->d_op->d_dname(path->dentry, buf, buflen);\n\n\trcu_read_lock();\n\tget_fs_root_rcu(current->fs, &root);\n\terror = path_with_deleted(path, &root, &res, &buflen);\n\trcu_read_unlock();\n\n\tif (error < 0)\n\t\tres = ERR_PTR(error);\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nchar *d_path(const struct path *path, char *buf, int buflen)\n{\n\tchar *res = buf + buflen;\n\tstruct path root;\n\tint error;\n\n\t/*\n\t * We have various synthetic filesystems that never get mounted.  On\n\t * these filesystems dentries are never used for lookup purposes, and\n\t * thus don't need to be hashed.  They also don't need a name until a\n\t * user wants to identify the object in /proc/pid/fd/.  The little hack\n\t * below allows us to generate a name for these objects on demand:\n\t *\n\t * Some pseudo inodes are mountable.  When they are mounted\n\t * path->dentry == path->mnt->mnt_root.  In that case don't call d_dname\n\t * and instead have d_path return the mounted path.\n\t */\n\tif (path->dentry->d_op && path->dentry->d_op->d_dname &&\n\t    (!IS_ROOT(path->dentry) || path->dentry != path->mnt->mnt_root))\n\t\treturn path->dentry->d_op->d_dname(path->dentry, buf, buflen);\n\n\trcu_read_lock();\n\tget_fs_root_rcu(current->fs, &root);\n\terror = path_with_deleted(path, &root, &res, &buflen);\n\trcu_read_unlock();\n\n\tif (error < 0)\n\t\tres = ERR_PTR(error);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmalloc",
          "args": [
            "size"
          ],
          "line": 1523
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_blocks_use_vmalloc(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.h",
          "lines": "292-295",
          "snippet": "tatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"os-linux.h\"\n#",
            "include \"os-ecos.h\"\n#",
            "include \"summary.h\"",
            "include \"acl.h\"\n#",
            "include \"xattr.h\"\n#",
            "include \"jffs2_fs_i.h\"\n#",
            "include \"jffs2_fs_sb.h\"\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/types.h>\n#",
            "include <linux/fs.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"os-linux.h\"\n#\ninclude \"os-ecos.h\"\n#\ninclude \"summary.h\"\ninclude \"acl.h\"\n#\ninclude \"xattr.h\"\n#\ninclude \"jffs2_fs_i.h\"\n#\ninclude \"jffs2_fs_sb.h\"\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/types.h>\n#\ninclude <linux/fs.h>\n#\n\ntatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}"
        }
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "size",
            "PAGE_SIZE"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define MAX_FILE_NOTE_SIZE (4*1024*1024)\n#define user_long_t long\n\nstatic int fill_files_note(struct memelfnote *note)\n{\n\tstruct vm_area_struct *vma;\n\tunsigned count, size, names_ofs, remaining, n;\n\tuser_long_t *data;\n\tuser_long_t *start_end_ofs;\n\tchar *name_base, *name_curpos;\n\n\t/* *Estimated* file count and total data size needed */\n\tcount = current->mm->map_count;\n\tsize = count * 64;\n\n\tnames_ofs = (2 + 3 * count) * sizeof(data[0]);\n alloc:\n\tif (size >= MAX_FILE_NOTE_SIZE) /* paranoia check */\n\t\treturn -EINVAL;\n\tsize = round_up(size, PAGE_SIZE);\n\tdata = vmalloc(size);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tstart_end_ofs = data + 2;\n\tname_base = name_curpos = ((char *)data) + names_ofs;\n\tremaining = size - names_ofs;\n\tcount = 0;\n\tfor (vma = current->mm->mmap; vma != NULL; vma = vma->vm_next) {\n\t\tstruct file *file;\n\t\tconst char *filename;\n\n\t\tfile = vma->vm_file;\n\t\tif (!file)\n\t\t\tcontinue;\n\t\tfilename = d_path(&file->f_path, name_curpos, remaining);\n\t\tif (IS_ERR(filename)) {\n\t\t\tif (PTR_ERR(filename) == -ENAMETOOLONG) {\n\t\t\t\tvfree(data);\n\t\t\t\tsize = size * 5 / 4;\n\t\t\t\tgoto alloc;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* d_path() fills at the end, move name down */\n\t\t/* n = strlen(filename) + 1: */\n\t\tn = (name_curpos + remaining) - filename;\n\t\tremaining = filename - name_curpos;\n\t\tmemmove(name_curpos, filename, n);\n\t\tname_curpos += n;\n\n\t\t*start_end_ofs++ = vma->vm_start;\n\t\t*start_end_ofs++ = vma->vm_end;\n\t\t*start_end_ofs++ = vma->vm_pgoff;\n\t\tcount++;\n\t}\n\n\t/* Now we know exact count of files, can store it */\n\tdata[0] = count;\n\tdata[1] = PAGE_SIZE;\n\t/*\n\t * Count usually is less than current->mm->map_count,\n\t * we need to move filenames down.\n\t */\n\tn = current->mm->map_count - count;\n\tif (n != 0) {\n\t\tunsigned shift_bytes = n * 3 * sizeof(data[0]);\n\t\tmemmove(name_base - shift_bytes, name_base,\n\t\t\tname_curpos - name_base);\n\t\tname_curpos -= shift_bytes;\n\t}\n\n\tsize = name_curpos - (char *)data;\n\tfill_note(note, \"CORE\", NT_FILE, size, data);\n\treturn 0;\n}"
  },
  {
    "function_name": "fill_siginfo_note",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
    "lines": "1484-1492",
    "snippet": "static void fill_siginfo_note(struct memelfnote *note, user_siginfo_t *csigdata,\n\t\tconst siginfo_t *siginfo)\n{\n\tmm_segment_t old_fs = get_fs();\n\tset_fs(KERNEL_DS);\n\tcopy_siginfo_to_user((user_siginfo_t __user *) csigdata, siginfo);\n\tset_fs(old_fs);\n\tfill_note(note, \"CORE\", NT_SIGINFO, sizeof(*csigdata), csigdata);\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define user_siginfo_t siginfo_t"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fill_note",
          "args": [
            "note",
            "\"CORE\"",
            "NT_SIGINFO",
            "sizeof(*csigdata)",
            "csigdata"
          ],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "fill_note_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "1939-2009",
          "snippet": "static int fill_note_info(struct elfhdr *elf, int phdrs,\n\t\t\t  struct elf_note_info *info,\n\t\t\t  const siginfo_t *siginfo, struct pt_regs *regs)\n{\n\tstruct list_head *t;\n\tstruct core_thread *ct;\n\tstruct elf_thread_status *ets;\n\n\tif (!elf_note_info_init(info))\n\t\treturn 0;\n\n\tfor (ct = current->mm->core_state->dumper.next;\n\t\t\t\t\tct; ct = ct->next) {\n\t\tets = kzalloc(sizeof(*ets), GFP_KERNEL);\n\t\tif (!ets)\n\t\t\treturn 0;\n\n\t\tets->thread = ct->task;\n\t\tlist_add(&ets->list, &info->thread_list);\n\t}\n\n\tlist_for_each(t, &info->thread_list) {\n\t\tint sz;\n\n\t\tets = list_entry(t, struct elf_thread_status, list);\n\t\tsz = elf_dump_thread_status(siginfo->si_signo, ets);\n\t\tinfo->thread_status_size += sz;\n\t}\n\t/* now collect the dump for the current */\n\tmemset(info->prstatus, 0, sizeof(*info->prstatus));\n\tfill_prstatus(info->prstatus, current, siginfo->si_signo);\n\telf_core_copy_regs(&info->prstatus->pr_reg, regs);\n\n\t/* Set up header */\n\tfill_elf_header(elf, phdrs, ELF_ARCH, ELF_CORE_EFLAGS);\n\n\t/*\n\t * Set up the notes in similar form to SVR4 core dumps made\n\t * with info from their /proc.\n\t */\n\n\tfill_note(info->notes + 0, \"CORE\", NT_PRSTATUS,\n\t\t  sizeof(*info->prstatus), info->prstatus);\n\tfill_psinfo(info->psinfo, current->group_leader, current->mm);\n\tfill_note(info->notes + 1, \"CORE\", NT_PRPSINFO,\n\t\t  sizeof(*info->psinfo), info->psinfo);\n\n\tfill_siginfo_note(info->notes + 2, &info->csigdata, siginfo);\n\tfill_auxv_note(info->notes + 3, current->mm);\n\tinfo->numnote = 4;\n\n\tif (fill_files_note(info->notes + info->numnote) == 0) {\n\t\tinfo->notes_files = info->notes + info->numnote;\n\t\tinfo->numnote++;\n\t}\n\n\t/* Try to dump the FPU. */\n\tinfo->prstatus->pr_fpvalid = elf_core_copy_task_fpregs(current, regs,\n\t\t\t\t\t\t\t       info->fpu);\n\tif (info->prstatus->pr_fpvalid)\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"CORE\", NT_PRFPREG, sizeof(*info->fpu), info->fpu);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(current, info->xfpu))\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(*info->xfpu), info->xfpu);\n#endif\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define ELF_CORE_EFLAGS\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define ELF_CORE_EFLAGS\t0\n\nstatic int fill_note_info(struct elfhdr *elf, int phdrs,\n\t\t\t  struct elf_note_info *info,\n\t\t\t  const siginfo_t *siginfo, struct pt_regs *regs)\n{\n\tstruct list_head *t;\n\tstruct core_thread *ct;\n\tstruct elf_thread_status *ets;\n\n\tif (!elf_note_info_init(info))\n\t\treturn 0;\n\n\tfor (ct = current->mm->core_state->dumper.next;\n\t\t\t\t\tct; ct = ct->next) {\n\t\tets = kzalloc(sizeof(*ets), GFP_KERNEL);\n\t\tif (!ets)\n\t\t\treturn 0;\n\n\t\tets->thread = ct->task;\n\t\tlist_add(&ets->list, &info->thread_list);\n\t}\n\n\tlist_for_each(t, &info->thread_list) {\n\t\tint sz;\n\n\t\tets = list_entry(t, struct elf_thread_status, list);\n\t\tsz = elf_dump_thread_status(siginfo->si_signo, ets);\n\t\tinfo->thread_status_size += sz;\n\t}\n\t/* now collect the dump for the current */\n\tmemset(info->prstatus, 0, sizeof(*info->prstatus));\n\tfill_prstatus(info->prstatus, current, siginfo->si_signo);\n\telf_core_copy_regs(&info->prstatus->pr_reg, regs);\n\n\t/* Set up header */\n\tfill_elf_header(elf, phdrs, ELF_ARCH, ELF_CORE_EFLAGS);\n\n\t/*\n\t * Set up the notes in similar form to SVR4 core dumps made\n\t * with info from their /proc.\n\t */\n\n\tfill_note(info->notes + 0, \"CORE\", NT_PRSTATUS,\n\t\t  sizeof(*info->prstatus), info->prstatus);\n\tfill_psinfo(info->psinfo, current->group_leader, current->mm);\n\tfill_note(info->notes + 1, \"CORE\", NT_PRPSINFO,\n\t\t  sizeof(*info->psinfo), info->psinfo);\n\n\tfill_siginfo_note(info->notes + 2, &info->csigdata, siginfo);\n\tfill_auxv_note(info->notes + 3, current->mm);\n\tinfo->numnote = 4;\n\n\tif (fill_files_note(info->notes + info->numnote) == 0) {\n\t\tinfo->notes_files = info->notes + info->numnote;\n\t\tinfo->numnote++;\n\t}\n\n\t/* Try to dump the FPU. */\n\tinfo->prstatus->pr_fpvalid = elf_core_copy_task_fpregs(current, regs,\n\t\t\t\t\t\t\t       info->fpu);\n\tif (info->prstatus->pr_fpvalid)\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"CORE\", NT_PRFPREG, sizeof(*info->fpu), info->fpu);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(current, info->xfpu))\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(*info->xfpu), info->xfpu);\n#endif\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "old_fs"
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "KERNEL_DS"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fs",
          "args": [],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define user_siginfo_t siginfo_t\n\nstatic void fill_siginfo_note(struct memelfnote *note, user_siginfo_t *csigdata,\n\t\tconst siginfo_t *siginfo)\n{\n\tmm_segment_t old_fs = get_fs();\n\tset_fs(KERNEL_DS);\n\tcopy_siginfo_to_user((user_siginfo_t __user *) csigdata, siginfo);\n\tset_fs(old_fs);\n\tfill_note(note, \"CORE\", NT_SIGINFO, sizeof(*csigdata), csigdata);\n}"
  },
  {
    "function_name": "fill_auxv_note",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
    "lines": "1474-1482",
    "snippet": "static void fill_auxv_note(struct memelfnote *note, struct mm_struct *mm)\n{\n\telf_addr_t *auxv = (elf_addr_t *) mm->saved_auxv;\n\tint i = 0;\n\tdo\n\t\ti += 2;\n\twhile (auxv[i - 2] != AT_NULL);\n\tfill_note(note, \"CORE\", NT_AUXV, i * sizeof(elf_addr_t), auxv);\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fill_note",
          "args": [
            "note",
            "\"CORE\"",
            "NT_AUXV",
            "i * sizeof(elf_addr_t)",
            "auxv"
          ],
          "line": 1481
        },
        "resolved": true,
        "details": {
          "function_name": "fill_note_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "1939-2009",
          "snippet": "static int fill_note_info(struct elfhdr *elf, int phdrs,\n\t\t\t  struct elf_note_info *info,\n\t\t\t  const siginfo_t *siginfo, struct pt_regs *regs)\n{\n\tstruct list_head *t;\n\tstruct core_thread *ct;\n\tstruct elf_thread_status *ets;\n\n\tif (!elf_note_info_init(info))\n\t\treturn 0;\n\n\tfor (ct = current->mm->core_state->dumper.next;\n\t\t\t\t\tct; ct = ct->next) {\n\t\tets = kzalloc(sizeof(*ets), GFP_KERNEL);\n\t\tif (!ets)\n\t\t\treturn 0;\n\n\t\tets->thread = ct->task;\n\t\tlist_add(&ets->list, &info->thread_list);\n\t}\n\n\tlist_for_each(t, &info->thread_list) {\n\t\tint sz;\n\n\t\tets = list_entry(t, struct elf_thread_status, list);\n\t\tsz = elf_dump_thread_status(siginfo->si_signo, ets);\n\t\tinfo->thread_status_size += sz;\n\t}\n\t/* now collect the dump for the current */\n\tmemset(info->prstatus, 0, sizeof(*info->prstatus));\n\tfill_prstatus(info->prstatus, current, siginfo->si_signo);\n\telf_core_copy_regs(&info->prstatus->pr_reg, regs);\n\n\t/* Set up header */\n\tfill_elf_header(elf, phdrs, ELF_ARCH, ELF_CORE_EFLAGS);\n\n\t/*\n\t * Set up the notes in similar form to SVR4 core dumps made\n\t * with info from their /proc.\n\t */\n\n\tfill_note(info->notes + 0, \"CORE\", NT_PRSTATUS,\n\t\t  sizeof(*info->prstatus), info->prstatus);\n\tfill_psinfo(info->psinfo, current->group_leader, current->mm);\n\tfill_note(info->notes + 1, \"CORE\", NT_PRPSINFO,\n\t\t  sizeof(*info->psinfo), info->psinfo);\n\n\tfill_siginfo_note(info->notes + 2, &info->csigdata, siginfo);\n\tfill_auxv_note(info->notes + 3, current->mm);\n\tinfo->numnote = 4;\n\n\tif (fill_files_note(info->notes + info->numnote) == 0) {\n\t\tinfo->notes_files = info->notes + info->numnote;\n\t\tinfo->numnote++;\n\t}\n\n\t/* Try to dump the FPU. */\n\tinfo->prstatus->pr_fpvalid = elf_core_copy_task_fpregs(current, regs,\n\t\t\t\t\t\t\t       info->fpu);\n\tif (info->prstatus->pr_fpvalid)\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"CORE\", NT_PRFPREG, sizeof(*info->fpu), info->fpu);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(current, info->xfpu))\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(*info->xfpu), info->xfpu);\n#endif\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define ELF_CORE_EFLAGS\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define ELF_CORE_EFLAGS\t0\n\nstatic int fill_note_info(struct elfhdr *elf, int phdrs,\n\t\t\t  struct elf_note_info *info,\n\t\t\t  const siginfo_t *siginfo, struct pt_regs *regs)\n{\n\tstruct list_head *t;\n\tstruct core_thread *ct;\n\tstruct elf_thread_status *ets;\n\n\tif (!elf_note_info_init(info))\n\t\treturn 0;\n\n\tfor (ct = current->mm->core_state->dumper.next;\n\t\t\t\t\tct; ct = ct->next) {\n\t\tets = kzalloc(sizeof(*ets), GFP_KERNEL);\n\t\tif (!ets)\n\t\t\treturn 0;\n\n\t\tets->thread = ct->task;\n\t\tlist_add(&ets->list, &info->thread_list);\n\t}\n\n\tlist_for_each(t, &info->thread_list) {\n\t\tint sz;\n\n\t\tets = list_entry(t, struct elf_thread_status, list);\n\t\tsz = elf_dump_thread_status(siginfo->si_signo, ets);\n\t\tinfo->thread_status_size += sz;\n\t}\n\t/* now collect the dump for the current */\n\tmemset(info->prstatus, 0, sizeof(*info->prstatus));\n\tfill_prstatus(info->prstatus, current, siginfo->si_signo);\n\telf_core_copy_regs(&info->prstatus->pr_reg, regs);\n\n\t/* Set up header */\n\tfill_elf_header(elf, phdrs, ELF_ARCH, ELF_CORE_EFLAGS);\n\n\t/*\n\t * Set up the notes in similar form to SVR4 core dumps made\n\t * with info from their /proc.\n\t */\n\n\tfill_note(info->notes + 0, \"CORE\", NT_PRSTATUS,\n\t\t  sizeof(*info->prstatus), info->prstatus);\n\tfill_psinfo(info->psinfo, current->group_leader, current->mm);\n\tfill_note(info->notes + 1, \"CORE\", NT_PRPSINFO,\n\t\t  sizeof(*info->psinfo), info->psinfo);\n\n\tfill_siginfo_note(info->notes + 2, &info->csigdata, siginfo);\n\tfill_auxv_note(info->notes + 3, current->mm);\n\tinfo->numnote = 4;\n\n\tif (fill_files_note(info->notes + info->numnote) == 0) {\n\t\tinfo->notes_files = info->notes + info->numnote;\n\t\tinfo->numnote++;\n\t}\n\n\t/* Try to dump the FPU. */\n\tinfo->prstatus->pr_fpvalid = elf_core_copy_task_fpregs(current, regs,\n\t\t\t\t\t\t\t       info->fpu);\n\tif (info->prstatus->pr_fpvalid)\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"CORE\", NT_PRFPREG, sizeof(*info->fpu), info->fpu);\n#ifdef ELF_CORE_COPY_XFPREGS\n\tif (elf_core_copy_task_xfpregs(current, info->xfpu))\n\t\tfill_note(info->notes + info->numnote++,\n\t\t\t  \"LINUX\", ELF_CORE_XFPREG_TYPE,\n\t\t\t  sizeof(*info->xfpu), info->xfpu);\n#endif\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void fill_auxv_note(struct memelfnote *note, struct mm_struct *mm)\n{\n\telf_addr_t *auxv = (elf_addr_t *) mm->saved_auxv;\n\tint i = 0;\n\tdo\n\t\ti += 2;\n\twhile (auxv[i - 2] != AT_NULL);\n\tfill_note(note, \"CORE\", NT_AUXV, i * sizeof(elf_addr_t), auxv);\n}"
  },
  {
    "function_name": "fill_psinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
    "lines": "1431-1472",
    "snippet": "static int fill_psinfo(struct elf_prpsinfo *psinfo, struct task_struct *p,\n\t\t       struct mm_struct *mm)\n{\n\tconst struct cred *cred;\n\tunsigned int i, len;\n\t\n\t/* first copy the parameters from user space */\n\tmemset(psinfo, 0, sizeof(struct elf_prpsinfo));\n\n\tlen = mm->arg_end - mm->arg_start;\n\tif (len >= ELF_PRARGSZ)\n\t\tlen = ELF_PRARGSZ-1;\n\tif (copy_from_user(&psinfo->pr_psargs,\n\t\t           (const char __user *)mm->arg_start, len))\n\t\treturn -EFAULT;\n\tfor(i = 0; i < len; i++)\n\t\tif (psinfo->pr_psargs[i] == 0)\n\t\t\tpsinfo->pr_psargs[i] = ' ';\n\tpsinfo->pr_psargs[len] = 0;\n\n\trcu_read_lock();\n\tpsinfo->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tpsinfo->pr_pid = task_pid_vnr(p);\n\tpsinfo->pr_pgrp = task_pgrp_vnr(p);\n\tpsinfo->pr_sid = task_session_vnr(p);\n\n\ti = p->state ? ffz(~p->state) + 1 : 0;\n\tpsinfo->pr_state = i;\n\tpsinfo->pr_sname = (i > 5) ? '.' : \"RSDTZW\"[i];\n\tpsinfo->pr_zomb = psinfo->pr_sname == 'Z';\n\tpsinfo->pr_nice = task_nice(p);\n\tpsinfo->pr_flag = p->flags;\n\trcu_read_lock();\n\tcred = __task_cred(p);\n\tSET_UID(psinfo->pr_uid, from_kuid_munged(cred->user_ns, cred->uid));\n\tSET_GID(psinfo->pr_gid, from_kgid_munged(cred->user_ns, cred->gid));\n\trcu_read_unlock();\n\tstrncpy(psinfo->pr_fname, p->comm, sizeof(psinfo->pr_fname));\n\t\n\treturn 0;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "psinfo->pr_fname",
            "p->comm",
            "sizeof(psinfo->pr_fname)"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_GID",
          "args": [
            "psinfo->pr_gid",
            "from_kgid_munged(cred->user_ns, cred->gid)"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid_munged",
          "args": [
            "cred->user_ns",
            "cred->gid"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_UID",
          "args": [
            "psinfo->pr_uid",
            "from_kuid_munged(cred->user_ns, cred->uid)"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "cred->user_ns",
            "cred->uid"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__task_cred",
          "args": [
            "p"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_nice",
          "args": [
            "p"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffz",
          "args": [
            "~p->state"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_session_vnr",
          "args": [
            "p"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pgrp_vnr",
          "args": [
            "p"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_vnr",
          "args": [
            "p"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_vnr",
          "args": [
            "rcu_dereference(p->real_parent)"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "p->real_parent"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&psinfo->pr_psargs",
            "(const char __user *)mm->arg_start",
            "len"
          ],
          "line": 1443
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "psinfo",
            "0",
            "sizeof(struct elf_prpsinfo)"
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int fill_psinfo(struct elf_prpsinfo *psinfo, struct task_struct *p,\n\t\t       struct mm_struct *mm)\n{\n\tconst struct cred *cred;\n\tunsigned int i, len;\n\t\n\t/* first copy the parameters from user space */\n\tmemset(psinfo, 0, sizeof(struct elf_prpsinfo));\n\n\tlen = mm->arg_end - mm->arg_start;\n\tif (len >= ELF_PRARGSZ)\n\t\tlen = ELF_PRARGSZ-1;\n\tif (copy_from_user(&psinfo->pr_psargs,\n\t\t           (const char __user *)mm->arg_start, len))\n\t\treturn -EFAULT;\n\tfor(i = 0; i < len; i++)\n\t\tif (psinfo->pr_psargs[i] == 0)\n\t\t\tpsinfo->pr_psargs[i] = ' ';\n\tpsinfo->pr_psargs[len] = 0;\n\n\trcu_read_lock();\n\tpsinfo->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tpsinfo->pr_pid = task_pid_vnr(p);\n\tpsinfo->pr_pgrp = task_pgrp_vnr(p);\n\tpsinfo->pr_sid = task_session_vnr(p);\n\n\ti = p->state ? ffz(~p->state) + 1 : 0;\n\tpsinfo->pr_state = i;\n\tpsinfo->pr_sname = (i > 5) ? '.' : \"RSDTZW\"[i];\n\tpsinfo->pr_zomb = psinfo->pr_sname == 'Z';\n\tpsinfo->pr_nice = task_nice(p);\n\tpsinfo->pr_flag = p->flags;\n\trcu_read_lock();\n\tcred = __task_cred(p);\n\tSET_UID(psinfo->pr_uid, from_kuid_munged(cred->user_ns, cred->uid));\n\tSET_GID(psinfo->pr_gid, from_kgid_munged(cred->user_ns, cred->gid));\n\trcu_read_unlock();\n\tstrncpy(psinfo->pr_fname, p->comm, sizeof(psinfo->pr_fname));\n\t\n\treturn 0;\n}"
  },
  {
    "function_name": "fill_prstatus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
    "lines": "1398-1429",
    "snippet": "static void fill_prstatus(struct elf_prstatus *prstatus,\n\t\tstruct task_struct *p, long signr)\n{\n\tprstatus->pr_info.si_signo = prstatus->pr_cursig = signr;\n\tprstatus->pr_sigpend = p->pending.signal.sig[0];\n\tprstatus->pr_sighold = p->blocked.sig[0];\n\trcu_read_lock();\n\tprstatus->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tprstatus->pr_pid = task_pid_vnr(p);\n\tprstatus->pr_pgrp = task_pgrp_vnr(p);\n\tprstatus->pr_sid = task_session_vnr(p);\n\tif (thread_group_leader(p)) {\n\t\tstruct task_cputime cputime;\n\n\t\t/*\n\t\t * This is the record for the group leader.  It shows the\n\t\t * group-wide total, not its individual thread total.\n\t\t */\n\t\tthread_group_cputime(p, &cputime);\n\t\tcputime_to_timeval(cputime.utime, &prstatus->pr_utime);\n\t\tcputime_to_timeval(cputime.stime, &prstatus->pr_stime);\n\t} else {\n\t\tcputime_t utime, stime;\n\n\t\ttask_cputime(p, &utime, &stime);\n\t\tcputime_to_timeval(utime, &prstatus->pr_utime);\n\t\tcputime_to_timeval(stime, &prstatus->pr_stime);\n\t}\n\tcputime_to_timeval(p->signal->cutime, &prstatus->pr_cutime);\n\tcputime_to_timeval(p->signal->cstime, &prstatus->pr_cstime);\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cputime_to_timeval",
          "args": [
            "p->signal->cstime",
            "&prstatus->pr_cstime"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cputime_to_timeval",
          "args": [
            "p->signal->cutime",
            "&prstatus->pr_cutime"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cputime_to_timeval",
          "args": [
            "stime",
            "&prstatus->pr_stime"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cputime_to_timeval",
          "args": [
            "utime",
            "&prstatus->pr_utime"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_cputime",
          "args": [
            "p",
            "&utime",
            "&stime"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cputime_to_timeval",
          "args": [
            "cputime.stime",
            "&prstatus->pr_stime"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cputime_to_timeval",
          "args": [
            "cputime.utime",
            "&prstatus->pr_utime"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_group_cputime",
          "args": [
            "p",
            "&cputime"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_group_leader",
          "args": [
            "p"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_session_vnr",
          "args": [
            "p"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pgrp_vnr",
          "args": [
            "p"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_vnr",
          "args": [
            "p"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_vnr",
          "args": [
            "rcu_dereference(p->real_parent)"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "p->real_parent"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void fill_prstatus(struct elf_prstatus *prstatus,\n\t\tstruct task_struct *p, long signr)\n{\n\tprstatus->pr_info.si_signo = prstatus->pr_cursig = signr;\n\tprstatus->pr_sigpend = p->pending.signal.sig[0];\n\tprstatus->pr_sighold = p->blocked.sig[0];\n\trcu_read_lock();\n\tprstatus->pr_ppid = task_pid_vnr(rcu_dereference(p->real_parent));\n\trcu_read_unlock();\n\tprstatus->pr_pid = task_pid_vnr(p);\n\tprstatus->pr_pgrp = task_pgrp_vnr(p);\n\tprstatus->pr_sid = task_session_vnr(p);\n\tif (thread_group_leader(p)) {\n\t\tstruct task_cputime cputime;\n\n\t\t/*\n\t\t * This is the record for the group leader.  It shows the\n\t\t * group-wide total, not its individual thread total.\n\t\t */\n\t\tthread_group_cputime(p, &cputime);\n\t\tcputime_to_timeval(cputime.utime, &prstatus->pr_utime);\n\t\tcputime_to_timeval(cputime.stime, &prstatus->pr_stime);\n\t} else {\n\t\tcputime_t utime, stime;\n\n\t\ttask_cputime(p, &utime, &stime);\n\t\tcputime_to_timeval(utime, &prstatus->pr_utime);\n\t\tcputime_to_timeval(stime, &prstatus->pr_stime);\n\t}\n\tcputime_to_timeval(p->signal->cutime, &prstatus->pr_cutime);\n\tcputime_to_timeval(p->signal->cstime, &prstatus->pr_cstime);\n}"
  },
  {
    "function_name": "fill_note",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
    "lines": "1384-1392",
    "snippet": "static void fill_note(struct memelfnote *note, const char *name, int type, \n\t\tunsigned int sz, void *data)\n{\n\tnote->name = name;\n\tnote->type = type;\n\tnote->datasz = sz;\n\tnote->data = data;\n\treturn;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic void fill_note(struct memelfnote *note, const char *name, int type, \n\t\tunsigned int sz, void *data)\n{\n\tnote->name = name;\n\tnote->type = type;\n\tnote->datasz = sz;\n\tnote->data = data;\n\treturn;\n}"
  },
  {
    "function_name": "fill_elf_note_phdr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
    "lines": "1371-1382",
    "snippet": "static void fill_elf_note_phdr(struct elf_phdr *phdr, int sz, loff_t offset)\n{\n\tphdr->p_type = PT_NOTE;\n\tphdr->p_offset = offset;\n\tphdr->p_vaddr = 0;\n\tphdr->p_paddr = 0;\n\tphdr->p_filesz = sz;\n\tphdr->p_memsz = 0;\n\tphdr->p_flags = 0;\n\tphdr->p_align = 0;\n\treturn;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);\n\nstatic void fill_elf_note_phdr(struct elf_phdr *phdr, int sz, loff_t offset)\n{\n\tphdr->p_type = PT_NOTE;\n\tphdr->p_offset = offset;\n\tphdr->p_vaddr = 0;\n\tphdr->p_paddr = 0;\n\tphdr->p_filesz = sz;\n\tphdr->p_memsz = 0;\n\tphdr->p_flags = 0;\n\tphdr->p_align = 0;\n\treturn;\n}"
  },
  {
    "function_name": "fill_elf_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
    "lines": "1348-1369",
    "snippet": "static void fill_elf_header(struct elfhdr *elf, int segs,\n\t\t\t    u16 machine, u32 flags)\n{\n\tmemset(elf, 0, sizeof(*elf));\n\n\tmemcpy(elf->e_ident, ELFMAG, SELFMAG);\n\telf->e_ident[EI_CLASS] = ELF_CLASS;\n\telf->e_ident[EI_DATA] = ELF_DATA;\n\telf->e_ident[EI_VERSION] = EV_CURRENT;\n\telf->e_ident[EI_OSABI] = ELF_OSABI;\n\n\telf->e_type = ET_CORE;\n\telf->e_machine = machine;\n\telf->e_version = EV_CURRENT;\n\telf->e_phoff = sizeof(struct elfhdr);\n\telf->e_flags = flags;\n\telf->e_ehsize = sizeof(struct elfhdr);\n\telf->e_phentsize = sizeof(struct elf_phdr);\n\telf->e_phnum = segs;\n\n\treturn;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "elf->e_ident",
            "ELFMAG",
            "SELFMAG"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "elf",
            "0",
            "sizeof(*elf)"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);\n\nstatic void fill_elf_header(struct elfhdr *elf, int segs,\n\t\t\t    u16 machine, u32 flags)\n{\n\tmemset(elf, 0, sizeof(*elf));\n\n\tmemcpy(elf->e_ident, ELFMAG, SELFMAG);\n\telf->e_ident[EI_CLASS] = ELF_CLASS;\n\telf->e_ident[EI_DATA] = ELF_DATA;\n\telf->e_ident[EI_VERSION] = EV_CURRENT;\n\telf->e_ident[EI_OSABI] = ELF_OSABI;\n\n\telf->e_type = ET_CORE;\n\telf->e_machine = machine;\n\telf->e_version = EV_CURRENT;\n\telf->e_phoff = sizeof(struct elfhdr);\n\telf->e_flags = flags;\n\telf->e_ehsize = sizeof(struct elfhdr);\n\telf->e_phentsize = sizeof(struct elf_phdr);\n\telf->e_phnum = segs;\n\n\treturn;\n}"
  },
  {
    "function_name": "writenote",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
    "lines": "1336-1346",
    "snippet": "static int writenote(struct memelfnote *men, struct coredump_params *cprm)\n{\n\tstruct elf_note en;\n\ten.n_namesz = strlen(men->name) + 1;\n\ten.n_descsz = men->datasz;\n\ten.n_type = men->type;\n\n\treturn dump_emit(cprm, &en, sizeof(en)) &&\n\t    dump_emit(cprm, men->name, en.n_namesz) && dump_align(cprm, 4) &&\n\t    dump_emit(cprm, men->data, men->datasz) && dump_align(cprm, 4);\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_align",
          "args": [
            "cprm",
            "4"
          ],
          "line": 1345
        },
        "resolved": true,
        "details": {
          "function_name": "dump_align",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coredump.c",
          "lines": "744-750",
          "snippet": "int dump_align(struct coredump_params *cprm, int align)\n{\n\tunsigned mod = cprm->written & (align - 1);\n\tif (align & (align - 1))\n\t\treturn 0;\n\treturn mod ? dump_skip(cprm, align - mod) : 1;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/exec.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/exec.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint dump_align(struct coredump_params *cprm, int align)\n{\n\tunsigned mod = cprm->written & (align - 1);\n\tif (align & (align - 1))\n\t\treturn 0;\n\treturn mod ? dump_skip(cprm, align - mod) : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_emit",
          "args": [
            "cprm",
            "men->data",
            "men->datasz"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_emit",
          "args": [
            "cprm",
            "men->name",
            "en.n_namesz"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_emit",
          "args": [
            "cprm",
            "&en",
            "sizeof(en)"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "men->name"
          ],
          "line": 1339
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int writenote(struct memelfnote *men, struct coredump_params *cprm)\n{\n\tstruct elf_note en;\n\ten.n_namesz = strlen(men->name) + 1;\n\ten.n_descsz = men->datasz;\n\ten.n_type = men->type;\n\n\treturn dump_emit(cprm, &en, sizeof(en)) &&\n\t    dump_emit(cprm, men->name, en.n_namesz) && dump_align(cprm, 4) &&\n\t    dump_emit(cprm, men->data, men->datasz) && dump_align(cprm, 4);\n}"
  },
  {
    "function_name": "notesize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
    "lines": "1325-1334",
    "snippet": "static int notesize(struct memelfnote *en)\n{\n\tint sz;\n\n\tsz = sizeof(struct elf_note);\n\tsz += roundup(strlen(en->name) + 1, 4);\n\tsz += roundup(en->datasz, 4);\n\n\treturn sz;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "en->datasz",
            "4"
          ],
          "line": 1331
        },
        "resolved": true,
        "details": {
          "function_name": "roundup_64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "333-338",
          "snippet": "static inline __uint64_t roundup_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline __uint64_t roundup_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "en->name"
          ],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int notesize(struct memelfnote *en)\n{\n\tint sz;\n\n\tsz = sizeof(struct elf_note);\n\tsz += roundup(strlen(en->name) + 1, 4);\n\tsz += roundup(en->datasz, 4);\n\n\treturn sz;\n}"
  },
  {
    "function_name": "vma_dump_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
    "lines": "1232-1314",
    "snippet": "static unsigned long vma_dump_size(struct vm_area_struct *vma,\n\t\t\t\t   unsigned long mm_flags)\n{\n#define FILTER(type)\t(mm_flags & (1UL << MMF_DUMP_##type))\n\n\t/* always dump the vdso and vsyscall sections */\n\tif (always_dump_vma(vma))\n\t\tgoto whole;\n\n\tif (vma->vm_flags & VM_DONTDUMP)\n\t\treturn 0;\n\n\t/* Hugetlb memory check */\n\tif (vma->vm_flags & VM_HUGETLB) {\n\t\tif ((vma->vm_flags & VM_SHARED) && FILTER(HUGETLB_SHARED))\n\t\t\tgoto whole;\n\t\tif (!(vma->vm_flags & VM_SHARED) && FILTER(HUGETLB_PRIVATE))\n\t\t\tgoto whole;\n\t\treturn 0;\n\t}\n\n\t/* Do not dump I/O mapped devices or special mappings */\n\tif (vma->vm_flags & VM_IO)\n\t\treturn 0;\n\n\t/* By default, dump shared memory if mapped from an anonymous file. */\n\tif (vma->vm_flags & VM_SHARED) {\n\t\tif (file_inode(vma->vm_file)->i_nlink == 0 ?\n\t\t    FILTER(ANON_SHARED) : FILTER(MAPPED_SHARED))\n\t\t\tgoto whole;\n\t\treturn 0;\n\t}\n\n\t/* Dump segments that have been written to.  */\n\tif (vma->anon_vma && FILTER(ANON_PRIVATE))\n\t\tgoto whole;\n\tif (vma->vm_file == NULL)\n\t\treturn 0;\n\n\tif (FILTER(MAPPED_PRIVATE))\n\t\tgoto whole;\n\n\t/*\n\t * If this looks like the beginning of a DSO or executable mapping,\n\t * check for an ELF header.  If we find one, dump the first page to\n\t * aid in determining what was mapped here.\n\t */\n\tif (FILTER(ELF_HEADERS) &&\n\t    vma->vm_pgoff == 0 && (vma->vm_flags & VM_READ)) {\n\t\tu32 __user *header = (u32 __user *) vma->vm_start;\n\t\tu32 word;\n\t\tmm_segment_t fs = get_fs();\n\t\t/*\n\t\t * Doing it this way gets the constant folded by GCC.\n\t\t */\n\t\tunion {\n\t\t\tu32 cmp;\n\t\t\tchar elfmag[SELFMAG];\n\t\t} magic;\n\t\tBUILD_BUG_ON(SELFMAG != sizeof word);\n\t\tmagic.elfmag[EI_MAG0] = ELFMAG0;\n\t\tmagic.elfmag[EI_MAG1] = ELFMAG1;\n\t\tmagic.elfmag[EI_MAG2] = ELFMAG2;\n\t\tmagic.elfmag[EI_MAG3] = ELFMAG3;\n\t\t/*\n\t\t * Switch to the user \"segment\" for get_user(),\n\t\t * then put back what elf_core_dump() had in place.\n\t\t */\n\t\tset_fs(USER_DS);\n\t\tif (unlikely(get_user(word, header)))\n\t\t\tword = 0;\n\t\tset_fs(fs);\n\t\tif (word == magic.cmp)\n\t\t\treturn PAGE_SIZE;\n\t}\n\n#undef\tFILTER\n\n\treturn 0;\n\nwhole:\n\treturn vma->vm_end - vma->vm_start;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define elf_core_dump\tNULL"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "fs"
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "get_user(word, header)"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "word",
            "header"
          ],
          "line": 1301
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_arg_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "399-418",
          "snippet": "static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "USER_DS"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "SELFMAG != sizeof word"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fs",
          "args": [],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FILTER",
          "args": [
            "ELF_HEADERS"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FILTER",
          "args": [
            "MAPPED_PRIVATE"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FILTER",
          "args": [
            "ANON_PRIVATE"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FILTER",
          "args": [
            "MAPPED_SHARED"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FILTER",
          "args": [
            "ANON_SHARED"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "vma->vm_file"
          ],
          "line": 1259
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FILTER",
          "args": [
            "HUGETLB_PRIVATE"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FILTER",
          "args": [
            "HUGETLB_SHARED"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "always_dump_vma",
          "args": [
            "vma"
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "always_dump_vma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "1206-1227",
          "snippet": "static bool always_dump_vma(struct vm_area_struct *vma)\n{\n\t/* Any vsyscall mappings? */\n\tif (vma == get_gate_vma(vma->vm_mm))\n\t\treturn true;\n\n\t/*\n\t * Assume that all vmas with a .name op should always be dumped.\n\t * If this changes, a new vm_ops field can easily be added.\n\t */\n\tif (vma->vm_ops && vma->vm_ops->name && vma->vm_ops->name(vma))\n\t\treturn true;\n\n\t/*\n\t * arch_vma_name() returns non-NULL for special architecture mappings,\n\t * such as vDSO sections.\n\t */\n\tif (arch_vma_name(vma))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic bool always_dump_vma(struct vm_area_struct *vma)\n{\n\t/* Any vsyscall mappings? */\n\tif (vma == get_gate_vma(vma->vm_mm))\n\t\treturn true;\n\n\t/*\n\t * Assume that all vmas with a .name op should always be dumped.\n\t * If this changes, a new vm_ops field can easily be added.\n\t */\n\tif (vma->vm_ops && vma->vm_ops->name && vma->vm_ops->name(vma))\n\t\treturn true;\n\n\t/*\n\t * arch_vma_name() returns non-NULL for special architecture mappings,\n\t * such as vDSO sections.\n\t */\n\tif (arch_vma_name(vma))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define elf_core_dump\tNULL\n\nstatic unsigned long vma_dump_size(struct vm_area_struct *vma,\n\t\t\t\t   unsigned long mm_flags)\n{\n#define FILTER(type)\t(mm_flags & (1UL << MMF_DUMP_##type))\n\n\t/* always dump the vdso and vsyscall sections */\n\tif (always_dump_vma(vma))\n\t\tgoto whole;\n\n\tif (vma->vm_flags & VM_DONTDUMP)\n\t\treturn 0;\n\n\t/* Hugetlb memory check */\n\tif (vma->vm_flags & VM_HUGETLB) {\n\t\tif ((vma->vm_flags & VM_SHARED) && FILTER(HUGETLB_SHARED))\n\t\t\tgoto whole;\n\t\tif (!(vma->vm_flags & VM_SHARED) && FILTER(HUGETLB_PRIVATE))\n\t\t\tgoto whole;\n\t\treturn 0;\n\t}\n\n\t/* Do not dump I/O mapped devices or special mappings */\n\tif (vma->vm_flags & VM_IO)\n\t\treturn 0;\n\n\t/* By default, dump shared memory if mapped from an anonymous file. */\n\tif (vma->vm_flags & VM_SHARED) {\n\t\tif (file_inode(vma->vm_file)->i_nlink == 0 ?\n\t\t    FILTER(ANON_SHARED) : FILTER(MAPPED_SHARED))\n\t\t\tgoto whole;\n\t\treturn 0;\n\t}\n\n\t/* Dump segments that have been written to.  */\n\tif (vma->anon_vma && FILTER(ANON_PRIVATE))\n\t\tgoto whole;\n\tif (vma->vm_file == NULL)\n\t\treturn 0;\n\n\tif (FILTER(MAPPED_PRIVATE))\n\t\tgoto whole;\n\n\t/*\n\t * If this looks like the beginning of a DSO or executable mapping,\n\t * check for an ELF header.  If we find one, dump the first page to\n\t * aid in determining what was mapped here.\n\t */\n\tif (FILTER(ELF_HEADERS) &&\n\t    vma->vm_pgoff == 0 && (vma->vm_flags & VM_READ)) {\n\t\tu32 __user *header = (u32 __user *) vma->vm_start;\n\t\tu32 word;\n\t\tmm_segment_t fs = get_fs();\n\t\t/*\n\t\t * Doing it this way gets the constant folded by GCC.\n\t\t */\n\t\tunion {\n\t\t\tu32 cmp;\n\t\t\tchar elfmag[SELFMAG];\n\t\t} magic;\n\t\tBUILD_BUG_ON(SELFMAG != sizeof word);\n\t\tmagic.elfmag[EI_MAG0] = ELFMAG0;\n\t\tmagic.elfmag[EI_MAG1] = ELFMAG1;\n\t\tmagic.elfmag[EI_MAG2] = ELFMAG2;\n\t\tmagic.elfmag[EI_MAG3] = ELFMAG3;\n\t\t/*\n\t\t * Switch to the user \"segment\" for get_user(),\n\t\t * then put back what elf_core_dump() had in place.\n\t\t */\n\t\tset_fs(USER_DS);\n\t\tif (unlikely(get_user(word, header)))\n\t\t\tword = 0;\n\t\tset_fs(fs);\n\t\tif (word == magic.cmp)\n\t\t\treturn PAGE_SIZE;\n\t}\n\n#undef\tFILTER\n\n\treturn 0;\n\nwhole:\n\treturn vma->vm_end - vma->vm_start;\n}"
  },
  {
    "function_name": "always_dump_vma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
    "lines": "1206-1227",
    "snippet": "static bool always_dump_vma(struct vm_area_struct *vma)\n{\n\t/* Any vsyscall mappings? */\n\tif (vma == get_gate_vma(vma->vm_mm))\n\t\treturn true;\n\n\t/*\n\t * Assume that all vmas with a .name op should always be dumped.\n\t * If this changes, a new vm_ops field can easily be added.\n\t */\n\tif (vma->vm_ops && vma->vm_ops->name && vma->vm_ops->name(vma))\n\t\treturn true;\n\n\t/*\n\t * arch_vma_name() returns non-NULL for special architecture mappings,\n\t * such as vDSO sections.\n\t */\n\tif (arch_vma_name(vma))\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_vma_name",
          "args": [
            "vma"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma->vm_ops->name",
          "args": [
            "vma"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_gate_vma",
          "args": [
            "vma->vm_mm"
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic bool always_dump_vma(struct vm_area_struct *vma)\n{\n\t/* Any vsyscall mappings? */\n\tif (vma == get_gate_vma(vma->vm_mm))\n\t\treturn true;\n\n\t/*\n\t * Assume that all vmas with a .name op should always be dumped.\n\t * If this changes, a new vm_ops field can easily be added.\n\t */\n\tif (vma->vm_ops && vma->vm_ops->name && vma->vm_ops->name(vma))\n\t\treturn true;\n\n\t/*\n\t * arch_vma_name() returns non-NULL for special architecture mappings,\n\t * such as vDSO sections.\n\t */\n\tif (arch_vma_name(vma))\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "load_elf_library",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
    "lines": "1112-1187",
    "snippet": "static int load_elf_library(struct file *file)\n{\n\tstruct elf_phdr *elf_phdata;\n\tstruct elf_phdr *eppnt;\n\tunsigned long elf_bss, bss, len;\n\tint retval, error, i, j;\n\tstruct elfhdr elf_ex;\n\n\terror = -ENOEXEC;\n\tretval = kernel_read(file, 0, (char *)&elf_ex, sizeof(elf_ex));\n\tif (retval != sizeof(elf_ex))\n\t\tgoto out;\n\n\tif (memcmp(elf_ex.e_ident, ELFMAG, SELFMAG) != 0)\n\t\tgoto out;\n\n\t/* First of all, some simple consistency checks */\n\tif (elf_ex.e_type != ET_EXEC || elf_ex.e_phnum > 2 ||\n\t    !elf_check_arch(&elf_ex) || !file->f_op->mmap)\n\t\tgoto out;\n\n\t/* Now read in all of the header information */\n\n\tj = sizeof(struct elf_phdr) * elf_ex.e_phnum;\n\t/* j < ELF_MIN_ALIGN because elf_ex.e_phnum <= 2 */\n\n\terror = -ENOMEM;\n\telf_phdata = kmalloc(j, GFP_KERNEL);\n\tif (!elf_phdata)\n\t\tgoto out;\n\n\teppnt = elf_phdata;\n\terror = -ENOEXEC;\n\tretval = kernel_read(file, elf_ex.e_phoff, (char *)eppnt, j);\n\tif (retval != j)\n\t\tgoto out_free_ph;\n\n\tfor (j = 0, i = 0; i<elf_ex.e_phnum; i++)\n\t\tif ((eppnt + i)->p_type == PT_LOAD)\n\t\t\tj++;\n\tif (j != 1)\n\t\tgoto out_free_ph;\n\n\twhile (eppnt->p_type != PT_LOAD)\n\t\teppnt++;\n\n\t/* Now use mmap to map the library into memory. */\n\terror = vm_mmap(file,\n\t\t\tELF_PAGESTART(eppnt->p_vaddr),\n\t\t\t(eppnt->p_filesz +\n\t\t\t ELF_PAGEOFFSET(eppnt->p_vaddr)),\n\t\t\tPROT_READ | PROT_WRITE | PROT_EXEC,\n\t\t\tMAP_FIXED | MAP_PRIVATE | MAP_DENYWRITE,\n\t\t\t(eppnt->p_offset -\n\t\t\t ELF_PAGEOFFSET(eppnt->p_vaddr)));\n\tif (error != ELF_PAGESTART(eppnt->p_vaddr))\n\t\tgoto out_free_ph;\n\n\telf_bss = eppnt->p_vaddr + eppnt->p_filesz;\n\tif (padzero(elf_bss)) {\n\t\terror = -EFAULT;\n\t\tgoto out_free_ph;\n\t}\n\n\tlen = ELF_PAGESTART(eppnt->p_filesz + eppnt->p_vaddr +\n\t\t\t    ELF_MIN_ALIGN - 1);\n\tbss = eppnt->p_memsz + eppnt->p_vaddr;\n\tif (bss > len)\n\t\tvm_brk(len, bss - len);\n\terror = 0;\n\nout_free_ph:\n\tkfree(elf_phdata);\nout:\n\treturn error;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define ELF_MIN_ALIGN\tPAGE_SIZE",
      "#define ELF_MIN_ALIGN\tELF_EXEC_PAGESIZE",
      "#define load_elf_library NULL"
    ],
    "globals_used": [
      "static unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "elf_phdata"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_brk",
          "args": [
            "len",
            "bss - len"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF_PAGESTART",
          "args": [
            "eppnt->p_filesz + eppnt->p_vaddr +\n\t\t\t    ELF_MIN_ALIGN - 1"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "padzero",
          "args": [
            "elf_bss"
          ],
          "line": 1171
        },
        "resolved": true,
        "details": {
          "function_name": "padzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "111-122",
          "snippet": "static int padzero(unsigned long elf_bss)\n{\n\tunsigned long nbyte;\n\n\tnbyte = ELF_PAGEOFFSET(elf_bss);\n\tif (nbyte) {\n\t\tnbyte = ELF_MIN_ALIGN - nbyte;\n\t\tif (clear_user((void __user *) elf_bss, nbyte))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define ELF_MIN_ALIGN\tPAGE_SIZE",
            "#define ELF_MIN_ALIGN\tELF_EXEC_PAGESIZE"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define ELF_MIN_ALIGN\tPAGE_SIZE\n#define ELF_MIN_ALIGN\tELF_EXEC_PAGESIZE\n\nstatic int padzero(unsigned long elf_bss)\n{\n\tunsigned long nbyte;\n\n\tnbyte = ELF_PAGEOFFSET(elf_bss);\n\tif (nbyte) {\n\t\tnbyte = ELF_MIN_ALIGN - nbyte;\n\t\tif (clear_user((void __user *) elf_bss, nbyte))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ELF_PAGESTART",
          "args": [
            "eppnt->p_vaddr"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_mmap",
          "args": [
            "file",
            "ELF_PAGESTART(eppnt->p_vaddr)",
            "(eppnt->p_filesz +\n\t\t\t ELF_PAGEOFFSET(eppnt->p_vaddr))",
            "PROT_READ | PROT_WRITE | PROT_EXEC",
            "MAP_FIXED | MAP_PRIVATE | MAP_DENYWRITE",
            "(eppnt->p_offset -\n\t\t\t ELF_PAGEOFFSET(eppnt->p_vaddr))"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF_PAGEOFFSET",
          "args": [
            "eppnt->p_vaddr"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF_PAGEOFFSET",
          "args": [
            "eppnt->p_vaddr"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF_PAGESTART",
          "args": [
            "eppnt->p_vaddr"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_read",
          "args": [
            "file",
            "elf_ex.e_phoff",
            "(char *)eppnt",
            "j"
          ],
          "line": 1145
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_readv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "569-583",
          "snippet": "static ssize_t kernel_readv(struct file *file, const struct iovec *vec,\n\t\t\t    unsigned long vlen, loff_t offset)\n{\n\tmm_segment_t old_fs;\n\tloff_t pos = offset;\n\tssize_t res;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tres = vfs_readv(file, (const struct iovec __user *)vec, vlen, &pos);\n\tset_fs(old_fs);\n\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic ssize_t kernel_readv(struct file *file, const struct iovec *vec,\n\t\t\t    unsigned long vlen, loff_t offset)\n{\n\tmm_segment_t old_fs;\n\tloff_t pos = offset;\n\tssize_t res;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tres = vfs_readv(file, (const struct iovec __user *)vec, vlen, &pos);\n\tset_fs(old_fs);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "j",
            "GFP_KERNEL"
          ],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elf_check_arch",
          "args": [
            "&elf_ex"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "elf_ex.e_ident",
            "ELFMAG",
            "SELFMAG"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define ELF_MIN_ALIGN\tPAGE_SIZE\n#define ELF_MIN_ALIGN\tELF_EXEC_PAGESIZE\n#define load_elf_library NULL\n\nstatic unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);\n\nstatic int load_elf_library(struct file *file)\n{\n\tstruct elf_phdr *elf_phdata;\n\tstruct elf_phdr *eppnt;\n\tunsigned long elf_bss, bss, len;\n\tint retval, error, i, j;\n\tstruct elfhdr elf_ex;\n\n\terror = -ENOEXEC;\n\tretval = kernel_read(file, 0, (char *)&elf_ex, sizeof(elf_ex));\n\tif (retval != sizeof(elf_ex))\n\t\tgoto out;\n\n\tif (memcmp(elf_ex.e_ident, ELFMAG, SELFMAG) != 0)\n\t\tgoto out;\n\n\t/* First of all, some simple consistency checks */\n\tif (elf_ex.e_type != ET_EXEC || elf_ex.e_phnum > 2 ||\n\t    !elf_check_arch(&elf_ex) || !file->f_op->mmap)\n\t\tgoto out;\n\n\t/* Now read in all of the header information */\n\n\tj = sizeof(struct elf_phdr) * elf_ex.e_phnum;\n\t/* j < ELF_MIN_ALIGN because elf_ex.e_phnum <= 2 */\n\n\terror = -ENOMEM;\n\telf_phdata = kmalloc(j, GFP_KERNEL);\n\tif (!elf_phdata)\n\t\tgoto out;\n\n\teppnt = elf_phdata;\n\terror = -ENOEXEC;\n\tretval = kernel_read(file, elf_ex.e_phoff, (char *)eppnt, j);\n\tif (retval != j)\n\t\tgoto out_free_ph;\n\n\tfor (j = 0, i = 0; i<elf_ex.e_phnum; i++)\n\t\tif ((eppnt + i)->p_type == PT_LOAD)\n\t\t\tj++;\n\tif (j != 1)\n\t\tgoto out_free_ph;\n\n\twhile (eppnt->p_type != PT_LOAD)\n\t\teppnt++;\n\n\t/* Now use mmap to map the library into memory. */\n\terror = vm_mmap(file,\n\t\t\tELF_PAGESTART(eppnt->p_vaddr),\n\t\t\t(eppnt->p_filesz +\n\t\t\t ELF_PAGEOFFSET(eppnt->p_vaddr)),\n\t\t\tPROT_READ | PROT_WRITE | PROT_EXEC,\n\t\t\tMAP_FIXED | MAP_PRIVATE | MAP_DENYWRITE,\n\t\t\t(eppnt->p_offset -\n\t\t\t ELF_PAGEOFFSET(eppnt->p_vaddr)));\n\tif (error != ELF_PAGESTART(eppnt->p_vaddr))\n\t\tgoto out_free_ph;\n\n\telf_bss = eppnt->p_vaddr + eppnt->p_filesz;\n\tif (padzero(elf_bss)) {\n\t\terror = -EFAULT;\n\t\tgoto out_free_ph;\n\t}\n\n\tlen = ELF_PAGESTART(eppnt->p_filesz + eppnt->p_vaddr +\n\t\t\t    ELF_MIN_ALIGN - 1);\n\tbss = eppnt->p_memsz + eppnt->p_vaddr;\n\tif (bss > len)\n\t\tvm_brk(len, bss - len);\n\terror = 0;\n\nout_free_ph:\n\tkfree(elf_phdata);\nout:\n\treturn error;\n}"
  },
  {
    "function_name": "load_elf_binary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
    "lines": "663-1107",
    "snippet": "static int load_elf_binary(struct linux_binprm *bprm)\n{\n\tstruct file *interpreter = NULL; /* to shut gcc up */\n \tunsigned long load_addr = 0, load_bias = 0;\n\tint load_addr_set = 0;\n\tchar * elf_interpreter = NULL;\n\tunsigned long error;\n\tstruct elf_phdr *elf_ppnt, *elf_phdata, *interp_elf_phdata = NULL;\n\tunsigned long elf_bss, elf_brk;\n\tint retval, i;\n\tunsigned long elf_entry;\n\tunsigned long interp_load_addr = 0;\n\tunsigned long start_code, end_code, start_data, end_data;\n\tunsigned long reloc_func_desc __maybe_unused = 0;\n\tint executable_stack = EXSTACK_DEFAULT;\n\tstruct pt_regs *regs = current_pt_regs();\n\tstruct {\n\t\tstruct elfhdr elf_ex;\n\t\tstruct elfhdr interp_elf_ex;\n\t} *loc;\n\tstruct arch_elf_state arch_state = INIT_ARCH_ELF_STATE;\n\n\tloc = kmalloc(sizeof(*loc), GFP_KERNEL);\n\tif (!loc) {\n\t\tretval = -ENOMEM;\n\t\tgoto out_ret;\n\t}\n\t\n\t/* Get the exec-header */\n\tloc->elf_ex = *((struct elfhdr *)bprm->buf);\n\n\tretval = -ENOEXEC;\n\t/* First of all, some simple consistency checks */\n\tif (memcmp(loc->elf_ex.e_ident, ELFMAG, SELFMAG) != 0)\n\t\tgoto out;\n\n\tif (loc->elf_ex.e_type != ET_EXEC && loc->elf_ex.e_type != ET_DYN)\n\t\tgoto out;\n\tif (!elf_check_arch(&loc->elf_ex))\n\t\tgoto out;\n\tif (!bprm->file->f_op->mmap)\n\t\tgoto out;\n\n\telf_phdata = load_elf_phdrs(&loc->elf_ex, bprm->file);\n\tif (!elf_phdata)\n\t\tgoto out;\n\n\telf_ppnt = elf_phdata;\n\telf_bss = 0;\n\telf_brk = 0;\n\n\tstart_code = ~0UL;\n\tend_code = 0;\n\tstart_data = 0;\n\tend_data = 0;\n\n\tfor (i = 0; i < loc->elf_ex.e_phnum; i++) {\n\t\tif (elf_ppnt->p_type == PT_INTERP) {\n\t\t\t/* This is the program interpreter used for\n\t\t\t * shared libraries - for now assume that this\n\t\t\t * is an a.out format binary\n\t\t\t */\n\t\t\tretval = -ENOEXEC;\n\t\t\tif (elf_ppnt->p_filesz > PATH_MAX || \n\t\t\t    elf_ppnt->p_filesz < 2)\n\t\t\t\tgoto out_free_ph;\n\n\t\t\tretval = -ENOMEM;\n\t\t\telf_interpreter = kmalloc(elf_ppnt->p_filesz,\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!elf_interpreter)\n\t\t\t\tgoto out_free_ph;\n\n\t\t\tretval = kernel_read(bprm->file, elf_ppnt->p_offset,\n\t\t\t\t\t     elf_interpreter,\n\t\t\t\t\t     elf_ppnt->p_filesz);\n\t\t\tif (retval != elf_ppnt->p_filesz) {\n\t\t\t\tif (retval >= 0)\n\t\t\t\t\tretval = -EIO;\n\t\t\t\tgoto out_free_interp;\n\t\t\t}\n\t\t\t/* make sure path is NULL terminated */\n\t\t\tretval = -ENOEXEC;\n\t\t\tif (elf_interpreter[elf_ppnt->p_filesz - 1] != '\\0')\n\t\t\t\tgoto out_free_interp;\n\n\t\t\tinterpreter = open_exec(elf_interpreter);\n\t\t\tretval = PTR_ERR(interpreter);\n\t\t\tif (IS_ERR(interpreter))\n\t\t\t\tgoto out_free_interp;\n\n\t\t\t/*\n\t\t\t * If the binary is not readable then enforce\n\t\t\t * mm->dumpable = 0 regardless of the interpreter's\n\t\t\t * permissions.\n\t\t\t */\n\t\t\twould_dump(bprm, interpreter);\n\n\t\t\tretval = kernel_read(interpreter, 0, bprm->buf,\n\t\t\t\t\t     BINPRM_BUF_SIZE);\n\t\t\tif (retval != BINPRM_BUF_SIZE) {\n\t\t\t\tif (retval >= 0)\n\t\t\t\t\tretval = -EIO;\n\t\t\t\tgoto out_free_dentry;\n\t\t\t}\n\n\t\t\t/* Get the exec headers */\n\t\t\tloc->interp_elf_ex = *((struct elfhdr *)bprm->buf);\n\t\t\tbreak;\n\t\t}\n\t\telf_ppnt++;\n\t}\n\n\telf_ppnt = elf_phdata;\n\tfor (i = 0; i < loc->elf_ex.e_phnum; i++, elf_ppnt++)\n\t\tswitch (elf_ppnt->p_type) {\n\t\tcase PT_GNU_STACK:\n\t\t\tif (elf_ppnt->p_flags & PF_X)\n\t\t\t\texecutable_stack = EXSTACK_ENABLE_X;\n\t\t\telse\n\t\t\t\texecutable_stack = EXSTACK_DISABLE_X;\n\t\t\tbreak;\n\n\t\tcase PT_LOPROC ... PT_HIPROC:\n\t\t\tretval = arch_elf_pt_proc(&loc->elf_ex, elf_ppnt,\n\t\t\t\t\t\t  bprm->file, false,\n\t\t\t\t\t\t  &arch_state);\n\t\t\tif (retval)\n\t\t\t\tgoto out_free_dentry;\n\t\t\tbreak;\n\t\t}\n\n\t/* Some simple consistency checks for the interpreter */\n\tif (elf_interpreter) {\n\t\tretval = -ELIBBAD;\n\t\t/* Not an ELF interpreter */\n\t\tif (memcmp(loc->interp_elf_ex.e_ident, ELFMAG, SELFMAG) != 0)\n\t\t\tgoto out_free_dentry;\n\t\t/* Verify the interpreter has a valid arch */\n\t\tif (!elf_check_arch(&loc->interp_elf_ex))\n\t\t\tgoto out_free_dentry;\n\n\t\t/* Load the interpreter program headers */\n\t\tinterp_elf_phdata = load_elf_phdrs(&loc->interp_elf_ex,\n\t\t\t\t\t\t   interpreter);\n\t\tif (!interp_elf_phdata)\n\t\t\tgoto out_free_dentry;\n\n\t\t/* Pass PT_LOPROC..PT_HIPROC headers to arch code */\n\t\telf_ppnt = interp_elf_phdata;\n\t\tfor (i = 0; i < loc->interp_elf_ex.e_phnum; i++, elf_ppnt++)\n\t\t\tswitch (elf_ppnt->p_type) {\n\t\t\tcase PT_LOPROC ... PT_HIPROC:\n\t\t\t\tretval = arch_elf_pt_proc(&loc->interp_elf_ex,\n\t\t\t\t\t\t\t  elf_ppnt, interpreter,\n\t\t\t\t\t\t\t  true, &arch_state);\n\t\t\t\tif (retval)\n\t\t\t\t\tgoto out_free_dentry;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\t/*\n\t * Allow arch code to reject the ELF at this point, whilst it's\n\t * still possible to return an error to the code that invoked\n\t * the exec syscall.\n\t */\n\tretval = arch_check_elf(&loc->elf_ex, !!interpreter, &arch_state);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\n\t/* Flush all traces of the currently running executable */\n\tretval = flush_old_exec(bprm);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\n\t/* Do this immediately, since STACK_TOP as used in setup_arg_pages\n\t   may depend on the personality.  */\n\tSET_PERSONALITY2(loc->elf_ex, &arch_state);\n\tif (elf_read_implies_exec(loc->elf_ex, executable_stack))\n\t\tcurrent->personality |= READ_IMPLIES_EXEC;\n\n\tif (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)\n\t\tcurrent->flags |= PF_RANDOMIZE;\n\n\tsetup_new_exec(bprm);\n\n\t/* Do this so that we can load the interpreter, if need be.  We will\n\t   change some of these later */\n\tretval = setup_arg_pages(bprm, randomize_stack_top(STACK_TOP),\n\t\t\t\t executable_stack);\n\tif (retval < 0)\n\t\tgoto out_free_dentry;\n\t\n\tcurrent->mm->start_stack = bprm->p;\n\n\t/* Now we do a little grungy work by mmapping the ELF image into\n\t   the correct location in memory. */\n\tfor(i = 0, elf_ppnt = elf_phdata;\n\t    i < loc->elf_ex.e_phnum; i++, elf_ppnt++) {\n\t\tint elf_prot = 0, elf_flags;\n\t\tunsigned long k, vaddr;\n\n\t\tif (elf_ppnt->p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tif (unlikely (elf_brk > elf_bss)) {\n\t\t\tunsigned long nbyte;\n\t            \n\t\t\t/* There was a PT_LOAD segment with p_memsz > p_filesz\n\t\t\t   before this one. Map anonymous pages, if needed,\n\t\t\t   and clear the area.  */\n\t\t\tretval = set_brk(elf_bss + load_bias,\n\t\t\t\t\t elf_brk + load_bias);\n\t\t\tif (retval)\n\t\t\t\tgoto out_free_dentry;\n\t\t\tnbyte = ELF_PAGEOFFSET(elf_bss);\n\t\t\tif (nbyte) {\n\t\t\t\tnbyte = ELF_MIN_ALIGN - nbyte;\n\t\t\t\tif (nbyte > elf_brk - elf_bss)\n\t\t\t\t\tnbyte = elf_brk - elf_bss;\n\t\t\t\tif (clear_user((void __user *)elf_bss +\n\t\t\t\t\t\t\tload_bias, nbyte)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * This bss-zeroing can fail if the ELF\n\t\t\t\t\t * file specifies odd protections. So\n\t\t\t\t\t * we don't check the return value\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (elf_ppnt->p_flags & PF_R)\n\t\t\telf_prot |= PROT_READ;\n\t\tif (elf_ppnt->p_flags & PF_W)\n\t\t\telf_prot |= PROT_WRITE;\n\t\tif (elf_ppnt->p_flags & PF_X)\n\t\t\telf_prot |= PROT_EXEC;\n\n\t\telf_flags = MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE;\n\n\t\tvaddr = elf_ppnt->p_vaddr;\n\t\tif (loc->elf_ex.e_type == ET_EXEC || load_addr_set) {\n\t\t\telf_flags |= MAP_FIXED;\n\t\t} else if (loc->elf_ex.e_type == ET_DYN) {\n\t\t\t/* Try and get dynamic programs out of the way of the\n\t\t\t * default mmap base, as well as whatever program they\n\t\t\t * might try to exec.  This is because the brk will\n\t\t\t * follow the loader, and is not movable.  */\n#ifdef CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE\n\t\t\t/* Memory randomization might have been switched off\n\t\t\t * in runtime via sysctl or explicit setting of\n\t\t\t * personality flags.\n\t\t\t * If that is the case, retain the original non-zero\n\t\t\t * load_bias value in order to establish proper\n\t\t\t * non-randomized mappings.\n\t\t\t */\n\t\t\tif (current->flags & PF_RANDOMIZE)\n\t\t\t\tload_bias = 0;\n\t\t\telse\n\t\t\t\tload_bias = ELF_PAGESTART(ELF_ET_DYN_BASE - vaddr);\n#else\n\t\t\tload_bias = ELF_PAGESTART(ELF_ET_DYN_BASE - vaddr);\n#endif\n\t\t}\n\n\t\terror = elf_map(bprm->file, load_bias + vaddr, elf_ppnt,\n\t\t\t\telf_prot, elf_flags, 0);\n\t\tif (BAD_ADDR(error)) {\n\t\t\tretval = IS_ERR((void *)error) ?\n\t\t\t\tPTR_ERR((void*)error) : -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\n\t\tif (!load_addr_set) {\n\t\t\tload_addr_set = 1;\n\t\t\tload_addr = (elf_ppnt->p_vaddr - elf_ppnt->p_offset);\n\t\t\tif (loc->elf_ex.e_type == ET_DYN) {\n\t\t\t\tload_bias += error -\n\t\t\t\t             ELF_PAGESTART(load_bias + vaddr);\n\t\t\t\tload_addr += load_bias;\n\t\t\t\treloc_func_desc = load_bias;\n\t\t\t}\n\t\t}\n\t\tk = elf_ppnt->p_vaddr;\n\t\tif (k < start_code)\n\t\t\tstart_code = k;\n\t\tif (start_data < k)\n\t\t\tstart_data = k;\n\n\t\t/*\n\t\t * Check to see if the section's size will overflow the\n\t\t * allowed task size. Note that p_filesz must always be\n\t\t * <= p_memsz so it is only necessary to check p_memsz.\n\t\t */\n\t\tif (BAD_ADDR(k) || elf_ppnt->p_filesz > elf_ppnt->p_memsz ||\n\t\t    elf_ppnt->p_memsz > TASK_SIZE ||\n\t\t    TASK_SIZE - elf_ppnt->p_memsz < k) {\n\t\t\t/* set_brk can never work. Avoid overflows. */\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\n\t\tk = elf_ppnt->p_vaddr + elf_ppnt->p_filesz;\n\n\t\tif (k > elf_bss)\n\t\t\telf_bss = k;\n\t\tif ((elf_ppnt->p_flags & PF_X) && end_code < k)\n\t\t\tend_code = k;\n\t\tif (end_data < k)\n\t\t\tend_data = k;\n\t\tk = elf_ppnt->p_vaddr + elf_ppnt->p_memsz;\n\t\tif (k > elf_brk)\n\t\t\telf_brk = k;\n\t}\n\n\tloc->elf_ex.e_entry += load_bias;\n\telf_bss += load_bias;\n\telf_brk += load_bias;\n\tstart_code += load_bias;\n\tend_code += load_bias;\n\tstart_data += load_bias;\n\tend_data += load_bias;\n\n\t/* Calling set_brk effectively mmaps the pages that we need\n\t * for the bss and break sections.  We must do this before\n\t * mapping in the interpreter, to make sure it doesn't wind\n\t * up getting placed where the bss needs to go.\n\t */\n\tretval = set_brk(elf_bss, elf_brk);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\tif (likely(elf_bss != elf_brk) && unlikely(padzero(elf_bss))) {\n\t\tretval = -EFAULT; /* Nobody gets to see this, but.. */\n\t\tgoto out_free_dentry;\n\t}\n\n\tif (elf_interpreter) {\n\t\tunsigned long interp_map_addr = 0;\n\n\t\telf_entry = load_elf_interp(&loc->interp_elf_ex,\n\t\t\t\t\t    interpreter,\n\t\t\t\t\t    &interp_map_addr,\n\t\t\t\t\t    load_bias, interp_elf_phdata);\n\t\tif (!IS_ERR((void *)elf_entry)) {\n\t\t\t/*\n\t\t\t * load_elf_interp() returns relocation\n\t\t\t * adjustment\n\t\t\t */\n\t\t\tinterp_load_addr = elf_entry;\n\t\t\telf_entry += loc->interp_elf_ex.e_entry;\n\t\t}\n\t\tif (BAD_ADDR(elf_entry)) {\n\t\t\tretval = IS_ERR((void *)elf_entry) ?\n\t\t\t\t\t(int)elf_entry : -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\t\treloc_func_desc = interp_load_addr;\n\n\t\tallow_write_access(interpreter);\n\t\tfput(interpreter);\n\t\tkfree(elf_interpreter);\n\t} else {\n\t\telf_entry = loc->elf_ex.e_entry;\n\t\tif (BAD_ADDR(elf_entry)) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\t}\n\n\tkfree(interp_elf_phdata);\n\tkfree(elf_phdata);\n\n\tset_binfmt(&elf_format);\n\n#ifdef ARCH_HAS_SETUP_ADDITIONAL_PAGES\n\tretval = arch_setup_additional_pages(bprm, !!elf_interpreter);\n\tif (retval < 0)\n\t\tgoto out;\n#endif /* ARCH_HAS_SETUP_ADDITIONAL_PAGES */\n\n\tinstall_exec_creds(bprm);\n\tretval = create_elf_tables(bprm, &loc->elf_ex,\n\t\t\t  load_addr, interp_load_addr);\n\tif (retval < 0)\n\t\tgoto out;\n\t/* N.B. passed_fileno might not be initialized? */\n\tcurrent->mm->end_code = end_code;\n\tcurrent->mm->start_code = start_code;\n\tcurrent->mm->start_data = start_data;\n\tcurrent->mm->end_data = end_data;\n\tcurrent->mm->start_stack = bprm->p;\n\n#ifdef arch_randomize_brk\n\tif ((current->flags & PF_RANDOMIZE) && (randomize_va_space > 1)) {\n\t\tcurrent->mm->brk = current->mm->start_brk =\n\t\t\tarch_randomize_brk(current->mm);\n#ifdef CONFIG_COMPAT_BRK\n\t\tcurrent->brk_randomized = 1;\n#endif\n\t}\n#endif\n\n\tif (current->personality & MMAP_PAGE_ZERO) {\n\t\t/* Why this, you ask???  Well SVr4 maps page 0 as read-only,\n\t\t   and some applications \"depend\" upon this behavior.\n\t\t   Since we do not have the power to recompile these, we\n\t\t   emulate the SVr4 behavior. Sigh. */\n\t\terror = vm_mmap(NULL, 0, PAGE_SIZE, PROT_READ | PROT_EXEC,\n\t\t\t\tMAP_FIXED | MAP_PRIVATE, 0);\n\t}\n\n#ifdef ELF_PLAT_INIT\n\t/*\n\t * The ABI may specify that certain registers be set up in special\n\t * ways (on i386 %edx is the address of a DT_FINI function, for\n\t * example.  In addition, it may also specify (eg, PowerPC64 ELF)\n\t * that the e_entry field is the address of the function descriptor\n\t * for the startup routine, rather than the address of the startup\n\t * routine itself.  This macro performs whatever initialization to\n\t * the regs structure is required as well as any relocations to the\n\t * function descriptor entries when executing dynamically links apps.\n\t */\n\tELF_PLAT_INIT(regs, reloc_func_desc);\n#endif\n\n\tstart_thread(regs, elf_entry, bprm->p);\n\tretval = 0;\nout:\n\tkfree(loc);\nout_ret:\n\treturn retval;\n\n\t/* error cleanup */\nout_free_dentry:\n\tkfree(interp_elf_phdata);\n\tallow_write_access(interpreter);\n\tif (interpreter)\n\t\tfput(interpreter);\nout_free_interp:\n\tkfree(elf_interpreter);\nout_free_ph:\n\tkfree(elf_phdata);\n\tgoto out;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define INIT_ARCH_ELF_STATE {}",
      "#define ELF_MIN_ALIGN\tPAGE_SIZE",
      "#define ELF_MIN_ALIGN\tELF_EXEC_PAGESIZE"
    ],
    "globals_used": [
      "static int load_elf_binary(struct linux_binprm *bprm);",
      "static unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);",
      "static struct linux_binfmt elf_format = {\n\t.module\t\t= THIS_MODULE,\n\t.load_binary\t= load_elf_binary,\n\t.load_shlib\t= load_elf_library,\n\t.core_dump\t= elf_core_dump,\n\t.min_coredump\t= ELF_EXEC_PAGESIZE,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "elf_phdata"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "elf_interpreter"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "interpreter"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "293-300",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "allow_write_access",
          "args": [
            "interpreter"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "interp_elf_phdata"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "loc"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "start_thread",
          "args": [
            "regs",
            "elf_entry",
            "bprm->p"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF_PLAT_INIT",
          "args": [
            "regs",
            "reloc_func_desc"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_mmap",
          "args": [
            "NULL",
            "0",
            "PAGE_SIZE",
            "PROT_READ | PROT_EXEC",
            "MAP_FIXED | MAP_PRIVATE",
            "0"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_randomize_brk",
          "args": [
            "current->mm"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_elf_tables",
          "args": [
            "bprm",
            "&loc->elf_ex",
            "load_addr",
            "interp_load_addr"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "create_elf_tables",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "148-331",
          "snippet": "static int\ncreate_elf_tables(struct linux_binprm *bprm, struct elfhdr *exec,\n\t\tunsigned long load_addr, unsigned long interp_load_addr)\n{\n\tunsigned long p = bprm->p;\n\tint argc = bprm->argc;\n\tint envc = bprm->envc;\n\telf_addr_t __user *argv;\n\telf_addr_t __user *envp;\n\telf_addr_t __user *sp;\n\telf_addr_t __user *u_platform;\n\telf_addr_t __user *u_base_platform;\n\telf_addr_t __user *u_rand_bytes;\n\tconst char *k_platform = ELF_PLATFORM;\n\tconst char *k_base_platform = ELF_BASE_PLATFORM;\n\tunsigned char k_rand_bytes[16];\n\tint items;\n\telf_addr_t *elf_info;\n\tint ei_index = 0;\n\tconst struct cred *cred = current_cred();\n\tstruct vm_area_struct *vma;\n\n\t/*\n\t * In some cases (e.g. Hyper-Threading), we want to avoid L1\n\t * evictions by the processes running on the same package. One\n\t * thing we can do is to shuffle the initial stack for them.\n\t */\n\n\tp = arch_align_stack(p);\n\n\t/*\n\t * If this architecture has a platform capability string, copy it\n\t * to userspace.  In some cases (Sparc), this info is impossible\n\t * for userspace to get any other way, in others (i386) it is\n\t * merely difficult.\n\t */\n\tu_platform = NULL;\n\tif (k_platform) {\n\t\tsize_t len = strlen(k_platform) + 1;\n\n\t\tu_platform = (elf_addr_t __user *)STACK_ALLOC(p, len);\n\t\tif (__copy_to_user(u_platform, k_platform, len))\n\t\t\treturn -EFAULT;\n\t}\n\n\t/*\n\t * If this architecture has a \"base\" platform capability\n\t * string, copy it to userspace.\n\t */\n\tu_base_platform = NULL;\n\tif (k_base_platform) {\n\t\tsize_t len = strlen(k_base_platform) + 1;\n\n\t\tu_base_platform = (elf_addr_t __user *)STACK_ALLOC(p, len);\n\t\tif (__copy_to_user(u_base_platform, k_base_platform, len))\n\t\t\treturn -EFAULT;\n\t}\n\n\t/*\n\t * Generate 16 random bytes for userspace PRNG seeding.\n\t */\n\tget_random_bytes(k_rand_bytes, sizeof(k_rand_bytes));\n\tu_rand_bytes = (elf_addr_t __user *)\n\t\t       STACK_ALLOC(p, sizeof(k_rand_bytes));\n\tif (__copy_to_user(u_rand_bytes, k_rand_bytes, sizeof(k_rand_bytes)))\n\t\treturn -EFAULT;\n\n\t/* Create the ELF interpreter info */\n\telf_info = (elf_addr_t *)current->mm->saved_auxv;\n\t/* update AT_VECTOR_SIZE_BASE if the number of NEW_AUX_ENT() changes */\n#define NEW_AUX_ENT(id, val) \\\n\tdo { \\\n\t\telf_info[ei_index++] = id; \\\n\t\telf_info[ei_index++] = val; \\\n\t} while (0)\n\n#ifdef ARCH_DLINFO\n\t/* \n\t * ARCH_DLINFO must come first so PPC can do its special alignment of\n\t * AUXV.\n\t * update AT_VECTOR_SIZE_ARCH if the number of NEW_AUX_ENT() in\n\t * ARCH_DLINFO changes\n\t */\n\tARCH_DLINFO;\n#endif\n\tNEW_AUX_ENT(AT_HWCAP, ELF_HWCAP);\n\tNEW_AUX_ENT(AT_PAGESZ, ELF_EXEC_PAGESIZE);\n\tNEW_AUX_ENT(AT_CLKTCK, CLOCKS_PER_SEC);\n\tNEW_AUX_ENT(AT_PHDR, load_addr + exec->e_phoff);\n\tNEW_AUX_ENT(AT_PHENT, sizeof(struct elf_phdr));\n\tNEW_AUX_ENT(AT_PHNUM, exec->e_phnum);\n\tNEW_AUX_ENT(AT_BASE, interp_load_addr);\n\tNEW_AUX_ENT(AT_FLAGS, 0);\n\tNEW_AUX_ENT(AT_ENTRY, exec->e_entry);\n\tNEW_AUX_ENT(AT_UID, from_kuid_munged(cred->user_ns, cred->uid));\n\tNEW_AUX_ENT(AT_EUID, from_kuid_munged(cred->user_ns, cred->euid));\n\tNEW_AUX_ENT(AT_GID, from_kgid_munged(cred->user_ns, cred->gid));\n\tNEW_AUX_ENT(AT_EGID, from_kgid_munged(cred->user_ns, cred->egid));\n \tNEW_AUX_ENT(AT_SECURE, security_bprm_secureexec(bprm));\n\tNEW_AUX_ENT(AT_RANDOM, (elf_addr_t)(unsigned long)u_rand_bytes);\n#ifdef ELF_HWCAP2\n\tNEW_AUX_ENT(AT_HWCAP2, ELF_HWCAP2);\n#endif\n\tNEW_AUX_ENT(AT_EXECFN, bprm->exec);\n\tif (k_platform) {\n\t\tNEW_AUX_ENT(AT_PLATFORM,\n\t\t\t    (elf_addr_t)(unsigned long)u_platform);\n\t}\n\tif (k_base_platform) {\n\t\tNEW_AUX_ENT(AT_BASE_PLATFORM,\n\t\t\t    (elf_addr_t)(unsigned long)u_base_platform);\n\t}\n\tif (bprm->interp_flags & BINPRM_FLAGS_EXECFD) {\n\t\tNEW_AUX_ENT(AT_EXECFD, bprm->interp_data);\n\t}\n#undef NEW_AUX_ENT\n\t/* AT_NULL is zero; clear the rest too */\n\tmemset(&elf_info[ei_index], 0,\n\t       sizeof current->mm->saved_auxv - ei_index * sizeof elf_info[0]);\n\n\t/* And advance past the AT_NULL entry.  */\n\tei_index += 2;\n\n\tsp = STACK_ADD(p, ei_index);\n\n\titems = (argc + 1) + (envc + 1) + 1;\n\tbprm->p = STACK_ROUND(sp, items);\n\n\t/* Point sp at the lowest address on the stack */\n#ifdef CONFIG_STACK_GROWSUP\n\tsp = (elf_addr_t __user *)bprm->p - items - ei_index;\n\tbprm->exec = (unsigned long)sp; /* XXX: PARISC HACK */\n#else\n\tsp = (elf_addr_t __user *)bprm->p;\n#endif\n\n\n\t/*\n\t * Grow the stack manually; some architectures have a limit on how\n\t * far ahead a user-space access may be in order to grow the stack.\n\t */\n\tvma = find_extend_vma(current->mm, bprm->p);\n\tif (!vma)\n\t\treturn -EFAULT;\n\n\t/* Now, let's put argc (and argv, envp if appropriate) on the stack */\n\tif (__put_user(argc, sp++))\n\t\treturn -EFAULT;\n\targv = sp;\n\tenvp = argv + argc + 1;\n\n\t/* Populate argv and envp */\n\tp = current->mm->arg_end = current->mm->arg_start;\n\twhile (argc-- > 0) {\n\t\tsize_t len;\n\t\tif (__put_user((elf_addr_t)p, argv++))\n\t\t\treturn -EFAULT;\n\t\tlen = strnlen_user((void __user *)p, MAX_ARG_STRLEN);\n\t\tif (!len || len > MAX_ARG_STRLEN)\n\t\t\treturn -EINVAL;\n\t\tp += len;\n\t}\n\tif (__put_user(0, argv))\n\t\treturn -EFAULT;\n\tcurrent->mm->arg_end = current->mm->env_start = p;\n\twhile (envc-- > 0) {\n\t\tsize_t len;\n\t\tif (__put_user((elf_addr_t)p, envp++))\n\t\t\treturn -EFAULT;\n\t\tlen = strnlen_user((void __user *)p, MAX_ARG_STRLEN);\n\t\tif (!len || len > MAX_ARG_STRLEN)\n\t\t\treturn -EINVAL;\n\t\tp += len;\n\t}\n\tif (__put_user(0, envp))\n\t\treturn -EFAULT;\n\tcurrent->mm->env_end = p;\n\n\t/* Put the elf_info on the stack in the right place.  */\n\tsp = (elf_addr_t __user *)envp + 1;\n\tif (copy_to_user(sp, elf_info, ei_index * sizeof(elf_addr_t)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define ELF_BASE_PLATFORM NULL"
          ],
          "globals_used": [
            "static int load_elf_binary(struct linux_binprm *bprm);",
            "static unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define ELF_BASE_PLATFORM NULL\n\nstatic int load_elf_binary(struct linux_binprm *bprm);\nstatic unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);\n\nstatic int\ncreate_elf_tables(struct linux_binprm *bprm, struct elfhdr *exec,\n\t\tunsigned long load_addr, unsigned long interp_load_addr)\n{\n\tunsigned long p = bprm->p;\n\tint argc = bprm->argc;\n\tint envc = bprm->envc;\n\telf_addr_t __user *argv;\n\telf_addr_t __user *envp;\n\telf_addr_t __user *sp;\n\telf_addr_t __user *u_platform;\n\telf_addr_t __user *u_base_platform;\n\telf_addr_t __user *u_rand_bytes;\n\tconst char *k_platform = ELF_PLATFORM;\n\tconst char *k_base_platform = ELF_BASE_PLATFORM;\n\tunsigned char k_rand_bytes[16];\n\tint items;\n\telf_addr_t *elf_info;\n\tint ei_index = 0;\n\tconst struct cred *cred = current_cred();\n\tstruct vm_area_struct *vma;\n\n\t/*\n\t * In some cases (e.g. Hyper-Threading), we want to avoid L1\n\t * evictions by the processes running on the same package. One\n\t * thing we can do is to shuffle the initial stack for them.\n\t */\n\n\tp = arch_align_stack(p);\n\n\t/*\n\t * If this architecture has a platform capability string, copy it\n\t * to userspace.  In some cases (Sparc), this info is impossible\n\t * for userspace to get any other way, in others (i386) it is\n\t * merely difficult.\n\t */\n\tu_platform = NULL;\n\tif (k_platform) {\n\t\tsize_t len = strlen(k_platform) + 1;\n\n\t\tu_platform = (elf_addr_t __user *)STACK_ALLOC(p, len);\n\t\tif (__copy_to_user(u_platform, k_platform, len))\n\t\t\treturn -EFAULT;\n\t}\n\n\t/*\n\t * If this architecture has a \"base\" platform capability\n\t * string, copy it to userspace.\n\t */\n\tu_base_platform = NULL;\n\tif (k_base_platform) {\n\t\tsize_t len = strlen(k_base_platform) + 1;\n\n\t\tu_base_platform = (elf_addr_t __user *)STACK_ALLOC(p, len);\n\t\tif (__copy_to_user(u_base_platform, k_base_platform, len))\n\t\t\treturn -EFAULT;\n\t}\n\n\t/*\n\t * Generate 16 random bytes for userspace PRNG seeding.\n\t */\n\tget_random_bytes(k_rand_bytes, sizeof(k_rand_bytes));\n\tu_rand_bytes = (elf_addr_t __user *)\n\t\t       STACK_ALLOC(p, sizeof(k_rand_bytes));\n\tif (__copy_to_user(u_rand_bytes, k_rand_bytes, sizeof(k_rand_bytes)))\n\t\treturn -EFAULT;\n\n\t/* Create the ELF interpreter info */\n\telf_info = (elf_addr_t *)current->mm->saved_auxv;\n\t/* update AT_VECTOR_SIZE_BASE if the number of NEW_AUX_ENT() changes */\n#define NEW_AUX_ENT(id, val) \\\n\tdo { \\\n\t\telf_info[ei_index++] = id; \\\n\t\telf_info[ei_index++] = val; \\\n\t} while (0)\n\n#ifdef ARCH_DLINFO\n\t/* \n\t * ARCH_DLINFO must come first so PPC can do its special alignment of\n\t * AUXV.\n\t * update AT_VECTOR_SIZE_ARCH if the number of NEW_AUX_ENT() in\n\t * ARCH_DLINFO changes\n\t */\n\tARCH_DLINFO;\n#endif\n\tNEW_AUX_ENT(AT_HWCAP, ELF_HWCAP);\n\tNEW_AUX_ENT(AT_PAGESZ, ELF_EXEC_PAGESIZE);\n\tNEW_AUX_ENT(AT_CLKTCK, CLOCKS_PER_SEC);\n\tNEW_AUX_ENT(AT_PHDR, load_addr + exec->e_phoff);\n\tNEW_AUX_ENT(AT_PHENT, sizeof(struct elf_phdr));\n\tNEW_AUX_ENT(AT_PHNUM, exec->e_phnum);\n\tNEW_AUX_ENT(AT_BASE, interp_load_addr);\n\tNEW_AUX_ENT(AT_FLAGS, 0);\n\tNEW_AUX_ENT(AT_ENTRY, exec->e_entry);\n\tNEW_AUX_ENT(AT_UID, from_kuid_munged(cred->user_ns, cred->uid));\n\tNEW_AUX_ENT(AT_EUID, from_kuid_munged(cred->user_ns, cred->euid));\n\tNEW_AUX_ENT(AT_GID, from_kgid_munged(cred->user_ns, cred->gid));\n\tNEW_AUX_ENT(AT_EGID, from_kgid_munged(cred->user_ns, cred->egid));\n \tNEW_AUX_ENT(AT_SECURE, security_bprm_secureexec(bprm));\n\tNEW_AUX_ENT(AT_RANDOM, (elf_addr_t)(unsigned long)u_rand_bytes);\n#ifdef ELF_HWCAP2\n\tNEW_AUX_ENT(AT_HWCAP2, ELF_HWCAP2);\n#endif\n\tNEW_AUX_ENT(AT_EXECFN, bprm->exec);\n\tif (k_platform) {\n\t\tNEW_AUX_ENT(AT_PLATFORM,\n\t\t\t    (elf_addr_t)(unsigned long)u_platform);\n\t}\n\tif (k_base_platform) {\n\t\tNEW_AUX_ENT(AT_BASE_PLATFORM,\n\t\t\t    (elf_addr_t)(unsigned long)u_base_platform);\n\t}\n\tif (bprm->interp_flags & BINPRM_FLAGS_EXECFD) {\n\t\tNEW_AUX_ENT(AT_EXECFD, bprm->interp_data);\n\t}\n#undef NEW_AUX_ENT\n\t/* AT_NULL is zero; clear the rest too */\n\tmemset(&elf_info[ei_index], 0,\n\t       sizeof current->mm->saved_auxv - ei_index * sizeof elf_info[0]);\n\n\t/* And advance past the AT_NULL entry.  */\n\tei_index += 2;\n\n\tsp = STACK_ADD(p, ei_index);\n\n\titems = (argc + 1) + (envc + 1) + 1;\n\tbprm->p = STACK_ROUND(sp, items);\n\n\t/* Point sp at the lowest address on the stack */\n#ifdef CONFIG_STACK_GROWSUP\n\tsp = (elf_addr_t __user *)bprm->p - items - ei_index;\n\tbprm->exec = (unsigned long)sp; /* XXX: PARISC HACK */\n#else\n\tsp = (elf_addr_t __user *)bprm->p;\n#endif\n\n\n\t/*\n\t * Grow the stack manually; some architectures have a limit on how\n\t * far ahead a user-space access may be in order to grow the stack.\n\t */\n\tvma = find_extend_vma(current->mm, bprm->p);\n\tif (!vma)\n\t\treturn -EFAULT;\n\n\t/* Now, let's put argc (and argv, envp if appropriate) on the stack */\n\tif (__put_user(argc, sp++))\n\t\treturn -EFAULT;\n\targv = sp;\n\tenvp = argv + argc + 1;\n\n\t/* Populate argv and envp */\n\tp = current->mm->arg_end = current->mm->arg_start;\n\twhile (argc-- > 0) {\n\t\tsize_t len;\n\t\tif (__put_user((elf_addr_t)p, argv++))\n\t\t\treturn -EFAULT;\n\t\tlen = strnlen_user((void __user *)p, MAX_ARG_STRLEN);\n\t\tif (!len || len > MAX_ARG_STRLEN)\n\t\t\treturn -EINVAL;\n\t\tp += len;\n\t}\n\tif (__put_user(0, argv))\n\t\treturn -EFAULT;\n\tcurrent->mm->arg_end = current->mm->env_start = p;\n\twhile (envc-- > 0) {\n\t\tsize_t len;\n\t\tif (__put_user((elf_addr_t)p, envp++))\n\t\t\treturn -EFAULT;\n\t\tlen = strnlen_user((void __user *)p, MAX_ARG_STRLEN);\n\t\tif (!len || len > MAX_ARG_STRLEN)\n\t\t\treturn -EINVAL;\n\t\tp += len;\n\t}\n\tif (__put_user(0, envp))\n\t\treturn -EFAULT;\n\tcurrent->mm->env_end = p;\n\n\t/* Put the elf_info on the stack in the right place.  */\n\tsp = (elf_addr_t __user *)envp + 1;\n\tif (copy_to_user(sp, elf_info, ei_index * sizeof(elf_addr_t)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "install_exec_creds",
          "args": [
            "bprm"
          ],
          "line": 1044
        },
        "resolved": true,
        "details": {
          "function_name": "install_exec_creds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "1202-1224",
          "snippet": "void install_exec_creds(struct linux_binprm *bprm)\n{\n\tsecurity_bprm_committing_creds(bprm);\n\n\tcommit_creds(bprm->cred);\n\tbprm->cred = NULL;\n\n\t/*\n\t * Disable monitoring for regular users\n\t * when executing setuid binaries. Must\n\t * wait until new credentials are committed\n\t * by commit_creds() above\n\t */\n\tif (get_dumpable(current->mm) != SUID_DUMP_USER)\n\t\tperf_event_exit_task(current);\n\t/*\n\t * cred_guard_mutex must be held at least to this point to prevent\n\t * ptrace_attach() from altering our determination of the task's\n\t * credentials; any time after this it may be unlocked.\n\t */\n\tsecurity_bprm_committed_creds(bprm);\n\tmutex_unlock(&current->signal->cred_guard_mutex);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid install_exec_creds(struct linux_binprm *bprm)\n{\n\tsecurity_bprm_committing_creds(bprm);\n\n\tcommit_creds(bprm->cred);\n\tbprm->cred = NULL;\n\n\t/*\n\t * Disable monitoring for regular users\n\t * when executing setuid binaries. Must\n\t * wait until new credentials are committed\n\t * by commit_creds() above\n\t */\n\tif (get_dumpable(current->mm) != SUID_DUMP_USER)\n\t\tperf_event_exit_task(current);\n\t/*\n\t * cred_guard_mutex must be held at least to this point to prevent\n\t * ptrace_attach() from altering our determination of the task's\n\t * credentials; any time after this it may be unlocked.\n\t */\n\tsecurity_bprm_committed_creds(bprm);\n\tmutex_unlock(&current->signal->cred_guard_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_setup_additional_pages",
          "args": [
            "bprm",
            "!!elf_interpreter"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_binfmt",
          "args": [
            "&elf_format"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "set_binfmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "1642-1652",
          "snippet": "void set_binfmt(struct linux_binfmt *new)\n{\n\tstruct mm_struct *mm = current->mm;\n\n\tif (mm->binfmt)\n\t\tmodule_put(mm->binfmt->module);\n\n\tmm->binfmt = new;\n\tif (new)\n\t\t__module_get(new->module);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid set_binfmt(struct linux_binfmt *new)\n{\n\tstruct mm_struct *mm = current->mm;\n\n\tif (mm->binfmt)\n\t\tmodule_put(mm->binfmt->module);\n\n\tmm->binfmt = new;\n\tif (new)\n\t\t__module_get(new->module);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "elf_phdata"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "interp_elf_phdata"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BAD_ADDR",
          "args": [
            "elf_entry"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "elf_interpreter"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allow_write_access",
          "args": [
            "interpreter"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "(void *)elf_entry"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BAD_ADDR",
          "args": [
            "elf_entry"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "(void *)elf_entry"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_elf_interp",
          "args": [
            "&loc->interp_elf_ex",
            "interpreter",
            "&interp_map_addr",
            "load_bias",
            "interp_elf_phdata"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "load_elf_interp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "516-635",
          "snippet": "static unsigned long load_elf_interp(struct elfhdr *interp_elf_ex,\n\t\tstruct file *interpreter, unsigned long *interp_map_addr,\n\t\tunsigned long no_base, struct elf_phdr *interp_elf_phdata)\n{\n\tstruct elf_phdr *eppnt;\n\tunsigned long load_addr = 0;\n\tint load_addr_set = 0;\n\tunsigned long last_bss = 0, elf_bss = 0;\n\tunsigned long error = ~0UL;\n\tunsigned long total_size;\n\tint i;\n\n\t/* First of all, some simple consistency checks */\n\tif (interp_elf_ex->e_type != ET_EXEC &&\n\t    interp_elf_ex->e_type != ET_DYN)\n\t\tgoto out;\n\tif (!elf_check_arch(interp_elf_ex))\n\t\tgoto out;\n\tif (!interpreter->f_op->mmap)\n\t\tgoto out;\n\n\ttotal_size = total_mapping_size(interp_elf_phdata,\n\t\t\t\t\tinterp_elf_ex->e_phnum);\n\tif (!total_size) {\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\teppnt = interp_elf_phdata;\n\tfor (i = 0; i < interp_elf_ex->e_phnum; i++, eppnt++) {\n\t\tif (eppnt->p_type == PT_LOAD) {\n\t\t\tint elf_type = MAP_PRIVATE | MAP_DENYWRITE;\n\t\t\tint elf_prot = 0;\n\t\t\tunsigned long vaddr = 0;\n\t\t\tunsigned long k, map_addr;\n\n\t\t\tif (eppnt->p_flags & PF_R)\n\t\t    \t\telf_prot = PROT_READ;\n\t\t\tif (eppnt->p_flags & PF_W)\n\t\t\t\telf_prot |= PROT_WRITE;\n\t\t\tif (eppnt->p_flags & PF_X)\n\t\t\t\telf_prot |= PROT_EXEC;\n\t\t\tvaddr = eppnt->p_vaddr;\n\t\t\tif (interp_elf_ex->e_type == ET_EXEC || load_addr_set)\n\t\t\t\telf_type |= MAP_FIXED;\n\t\t\telse if (no_base && interp_elf_ex->e_type == ET_DYN)\n\t\t\t\tload_addr = -vaddr;\n\n\t\t\tmap_addr = elf_map(interpreter, load_addr + vaddr,\n\t\t\t\t\teppnt, elf_prot, elf_type, total_size);\n\t\t\ttotal_size = 0;\n\t\t\tif (!*interp_map_addr)\n\t\t\t\t*interp_map_addr = map_addr;\n\t\t\terror = map_addr;\n\t\t\tif (BAD_ADDR(map_addr))\n\t\t\t\tgoto out;\n\n\t\t\tif (!load_addr_set &&\n\t\t\t    interp_elf_ex->e_type == ET_DYN) {\n\t\t\t\tload_addr = map_addr - ELF_PAGESTART(vaddr);\n\t\t\t\tload_addr_set = 1;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check to see if the section's size will overflow the\n\t\t\t * allowed task size. Note that p_filesz must always be\n\t\t\t * <= p_memsize so it's only necessary to check p_memsz.\n\t\t\t */\n\t\t\tk = load_addr + eppnt->p_vaddr;\n\t\t\tif (BAD_ADDR(k) ||\n\t\t\t    eppnt->p_filesz > eppnt->p_memsz ||\n\t\t\t    eppnt->p_memsz > TASK_SIZE ||\n\t\t\t    TASK_SIZE - eppnt->p_memsz < k) {\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Find the end of the file mapping for this phdr, and\n\t\t\t * keep track of the largest address we see for this.\n\t\t\t */\n\t\t\tk = load_addr + eppnt->p_vaddr + eppnt->p_filesz;\n\t\t\tif (k > elf_bss)\n\t\t\t\telf_bss = k;\n\n\t\t\t/*\n\t\t\t * Do the same thing for the memory mapping - between\n\t\t\t * elf_bss and last_bss is the bss section.\n\t\t\t */\n\t\t\tk = load_addr + eppnt->p_memsz + eppnt->p_vaddr;\n\t\t\tif (k > last_bss)\n\t\t\t\tlast_bss = k;\n\t\t}\n\t}\n\n\tif (last_bss > elf_bss) {\n\t\t/*\n\t\t * Now fill out the bss section.  First pad the last page up\n\t\t * to the page boundary, and then perform a mmap to make sure\n\t\t * that there are zero-mapped pages up to and including the\n\t\t * last bss page.\n\t\t */\n\t\tif (padzero(elf_bss)) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* What we have mapped so far */\n\t\telf_bss = ELF_PAGESTART(elf_bss + ELF_MIN_ALIGN - 1);\n\n\t\t/* Map the last of the bss segment */\n\t\terror = vm_brk(elf_bss, last_bss - elf_bss);\n\t\tif (BAD_ADDR(error))\n\t\t\tgoto out;\n\t}\n\n\terror = load_addr;\nout:\n\treturn error;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define ELF_MIN_ALIGN\tPAGE_SIZE",
            "#define ELF_MIN_ALIGN\tELF_EXEC_PAGESIZE"
          ],
          "globals_used": [
            "static unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define ELF_MIN_ALIGN\tPAGE_SIZE\n#define ELF_MIN_ALIGN\tELF_EXEC_PAGESIZE\n\nstatic unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);\n\nstatic unsigned long load_elf_interp(struct elfhdr *interp_elf_ex,\n\t\tstruct file *interpreter, unsigned long *interp_map_addr,\n\t\tunsigned long no_base, struct elf_phdr *interp_elf_phdata)\n{\n\tstruct elf_phdr *eppnt;\n\tunsigned long load_addr = 0;\n\tint load_addr_set = 0;\n\tunsigned long last_bss = 0, elf_bss = 0;\n\tunsigned long error = ~0UL;\n\tunsigned long total_size;\n\tint i;\n\n\t/* First of all, some simple consistency checks */\n\tif (interp_elf_ex->e_type != ET_EXEC &&\n\t    interp_elf_ex->e_type != ET_DYN)\n\t\tgoto out;\n\tif (!elf_check_arch(interp_elf_ex))\n\t\tgoto out;\n\tif (!interpreter->f_op->mmap)\n\t\tgoto out;\n\n\ttotal_size = total_mapping_size(interp_elf_phdata,\n\t\t\t\t\tinterp_elf_ex->e_phnum);\n\tif (!total_size) {\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\teppnt = interp_elf_phdata;\n\tfor (i = 0; i < interp_elf_ex->e_phnum; i++, eppnt++) {\n\t\tif (eppnt->p_type == PT_LOAD) {\n\t\t\tint elf_type = MAP_PRIVATE | MAP_DENYWRITE;\n\t\t\tint elf_prot = 0;\n\t\t\tunsigned long vaddr = 0;\n\t\t\tunsigned long k, map_addr;\n\n\t\t\tif (eppnt->p_flags & PF_R)\n\t\t    \t\telf_prot = PROT_READ;\n\t\t\tif (eppnt->p_flags & PF_W)\n\t\t\t\telf_prot |= PROT_WRITE;\n\t\t\tif (eppnt->p_flags & PF_X)\n\t\t\t\telf_prot |= PROT_EXEC;\n\t\t\tvaddr = eppnt->p_vaddr;\n\t\t\tif (interp_elf_ex->e_type == ET_EXEC || load_addr_set)\n\t\t\t\telf_type |= MAP_FIXED;\n\t\t\telse if (no_base && interp_elf_ex->e_type == ET_DYN)\n\t\t\t\tload_addr = -vaddr;\n\n\t\t\tmap_addr = elf_map(interpreter, load_addr + vaddr,\n\t\t\t\t\teppnt, elf_prot, elf_type, total_size);\n\t\t\ttotal_size = 0;\n\t\t\tif (!*interp_map_addr)\n\t\t\t\t*interp_map_addr = map_addr;\n\t\t\terror = map_addr;\n\t\t\tif (BAD_ADDR(map_addr))\n\t\t\t\tgoto out;\n\n\t\t\tif (!load_addr_set &&\n\t\t\t    interp_elf_ex->e_type == ET_DYN) {\n\t\t\t\tload_addr = map_addr - ELF_PAGESTART(vaddr);\n\t\t\t\tload_addr_set = 1;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check to see if the section's size will overflow the\n\t\t\t * allowed task size. Note that p_filesz must always be\n\t\t\t * <= p_memsize so it's only necessary to check p_memsz.\n\t\t\t */\n\t\t\tk = load_addr + eppnt->p_vaddr;\n\t\t\tif (BAD_ADDR(k) ||\n\t\t\t    eppnt->p_filesz > eppnt->p_memsz ||\n\t\t\t    eppnt->p_memsz > TASK_SIZE ||\n\t\t\t    TASK_SIZE - eppnt->p_memsz < k) {\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Find the end of the file mapping for this phdr, and\n\t\t\t * keep track of the largest address we see for this.\n\t\t\t */\n\t\t\tk = load_addr + eppnt->p_vaddr + eppnt->p_filesz;\n\t\t\tif (k > elf_bss)\n\t\t\t\telf_bss = k;\n\n\t\t\t/*\n\t\t\t * Do the same thing for the memory mapping - between\n\t\t\t * elf_bss and last_bss is the bss section.\n\t\t\t */\n\t\t\tk = load_addr + eppnt->p_memsz + eppnt->p_vaddr;\n\t\t\tif (k > last_bss)\n\t\t\t\tlast_bss = k;\n\t\t}\n\t}\n\n\tif (last_bss > elf_bss) {\n\t\t/*\n\t\t * Now fill out the bss section.  First pad the last page up\n\t\t * to the page boundary, and then perform a mmap to make sure\n\t\t * that there are zero-mapped pages up to and including the\n\t\t * last bss page.\n\t\t */\n\t\tif (padzero(elf_bss)) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* What we have mapped so far */\n\t\telf_bss = ELF_PAGESTART(elf_bss + ELF_MIN_ALIGN - 1);\n\n\t\t/* Map the last of the bss segment */\n\t\terror = vm_brk(elf_bss, last_bss - elf_bss);\n\t\tif (BAD_ADDR(error))\n\t\t\tgoto out;\n\t}\n\n\terror = load_addr;\nout:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "padzero(elf_bss)"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "padzero",
          "args": [
            "elf_bss"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "padzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "111-122",
          "snippet": "static int padzero(unsigned long elf_bss)\n{\n\tunsigned long nbyte;\n\n\tnbyte = ELF_PAGEOFFSET(elf_bss);\n\tif (nbyte) {\n\t\tnbyte = ELF_MIN_ALIGN - nbyte;\n\t\tif (clear_user((void __user *) elf_bss, nbyte))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define ELF_MIN_ALIGN\tPAGE_SIZE",
            "#define ELF_MIN_ALIGN\tELF_EXEC_PAGESIZE"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define ELF_MIN_ALIGN\tPAGE_SIZE\n#define ELF_MIN_ALIGN\tELF_EXEC_PAGESIZE\n\nstatic int padzero(unsigned long elf_bss)\n{\n\tunsigned long nbyte;\n\n\tnbyte = ELF_PAGEOFFSET(elf_bss);\n\tif (nbyte) {\n\t\tnbyte = ELF_MIN_ALIGN - nbyte;\n\t\tif (clear_user((void __user *) elf_bss, nbyte))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "elf_bss != elf_brk"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_brk",
          "args": [
            "elf_bss",
            "elf_brk"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "set_brk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "92-104",
          "snippet": "static int set_brk(unsigned long start, unsigned long end)\n{\n\tstart = ELF_PAGEALIGN(start);\n\tend = ELF_PAGEALIGN(end);\n\tif (end > start) {\n\t\tunsigned long addr;\n\t\taddr = vm_brk(start, end - start);\n\t\tif (BAD_ADDR(addr))\n\t\t\treturn addr;\n\t}\n\tcurrent->mm->start_brk = current->mm->brk = end;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int set_brk(unsigned long start, unsigned long end)\n{\n\tstart = ELF_PAGEALIGN(start);\n\tend = ELF_PAGEALIGN(end);\n\tif (end > start) {\n\t\tunsigned long addr;\n\t\taddr = vm_brk(start, end - start);\n\t\tif (BAD_ADDR(addr))\n\t\t\treturn addr;\n\t}\n\tcurrent->mm->start_brk = current->mm->brk = end;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BAD_ADDR",
          "args": [
            "k"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF_PAGESTART",
          "args": [
            "load_bias + vaddr"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "(void*)error"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "(void *)error"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BAD_ADDR",
          "args": [
            "error"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elf_map",
          "args": [
            "bprm->file",
            "load_bias + vaddr",
            "elf_ppnt",
            "elf_prot",
            "elf_flags",
            "0"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "elf_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "335-367",
          "snippet": "static unsigned long elf_map(struct file *filep, unsigned long addr,\n\t\tstruct elf_phdr *eppnt, int prot, int type,\n\t\tunsigned long total_size)\n{\n\tunsigned long map_addr;\n\tunsigned long size = eppnt->p_filesz + ELF_PAGEOFFSET(eppnt->p_vaddr);\n\tunsigned long off = eppnt->p_offset - ELF_PAGEOFFSET(eppnt->p_vaddr);\n\taddr = ELF_PAGESTART(addr);\n\tsize = ELF_PAGEALIGN(size);\n\n\t/* mmap() will return -EINVAL if given a zero size, but a\n\t * segment with zero filesize is perfectly valid */\n\tif (!size)\n\t\treturn addr;\n\n\t/*\n\t* total_size is the size of the ELF (interpreter) image.\n\t* The _first_ mmap needs to know the full size, otherwise\n\t* randomization might put this image into an overlapping\n\t* position with the ELF binary image. (since size < total_size)\n\t* So we first map the 'big' image - and unmap the remainder at\n\t* the end. (which unmap is needed for ELF images with holes.)\n\t*/\n\tif (total_size) {\n\t\ttotal_size = ELF_PAGEALIGN(total_size);\n\t\tmap_addr = vm_mmap(filep, addr, total_size, prot, type, off);\n\t\tif (!BAD_ADDR(map_addr))\n\t\t\tvm_munmap(map_addr+size, total_size-size);\n\t} else\n\t\tmap_addr = vm_mmap(filep, addr, size, prot, type, off);\n\n\treturn(map_addr);\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);\n\nstatic unsigned long elf_map(struct file *filep, unsigned long addr,\n\t\tstruct elf_phdr *eppnt, int prot, int type,\n\t\tunsigned long total_size)\n{\n\tunsigned long map_addr;\n\tunsigned long size = eppnt->p_filesz + ELF_PAGEOFFSET(eppnt->p_vaddr);\n\tunsigned long off = eppnt->p_offset - ELF_PAGEOFFSET(eppnt->p_vaddr);\n\taddr = ELF_PAGESTART(addr);\n\tsize = ELF_PAGEALIGN(size);\n\n\t/* mmap() will return -EINVAL if given a zero size, but a\n\t * segment with zero filesize is perfectly valid */\n\tif (!size)\n\t\treturn addr;\n\n\t/*\n\t* total_size is the size of the ELF (interpreter) image.\n\t* The _first_ mmap needs to know the full size, otherwise\n\t* randomization might put this image into an overlapping\n\t* position with the ELF binary image. (since size < total_size)\n\t* So we first map the 'big' image - and unmap the remainder at\n\t* the end. (which unmap is needed for ELF images with holes.)\n\t*/\n\tif (total_size) {\n\t\ttotal_size = ELF_PAGEALIGN(total_size);\n\t\tmap_addr = vm_mmap(filep, addr, total_size, prot, type, off);\n\t\tif (!BAD_ADDR(map_addr))\n\t\t\tvm_munmap(map_addr+size, total_size-size);\n\t} else\n\t\tmap_addr = vm_mmap(filep, addr, size, prot, type, off);\n\n\treturn(map_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ELF_PAGESTART",
          "args": [
            "ELF_ET_DYN_BASE - vaddr"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF_PAGESTART",
          "args": [
            "ELF_ET_DYN_BASE - vaddr"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_user",
          "args": [
            "(void __user *)elf_bss +\n\t\t\t\t\t\t\tload_bias",
            "nbyte"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF_PAGEOFFSET",
          "args": [
            "elf_bss"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "elf_brk > elf_bss"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_arg_pages",
          "args": [
            "bprm",
            "randomize_stack_top(STACK_TOP)",
            "executable_stack"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "setup_arg_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "641-746",
          "snippet": "int setup_arg_pages(struct linux_binprm *bprm,\n\t\t    unsigned long stack_top,\n\t\t    int executable_stack)\n{\n\tunsigned long ret;\n\tunsigned long stack_shift;\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma = bprm->vma;\n\tstruct vm_area_struct *prev = NULL;\n\tunsigned long vm_flags;\n\tunsigned long stack_base;\n\tunsigned long stack_size;\n\tunsigned long stack_expand;\n\tunsigned long rlim_stack;\n\n#ifdef CONFIG_STACK_GROWSUP\n\t/* Limit stack size */\n\tstack_base = rlimit_max(RLIMIT_STACK);\n\tif (stack_base > STACK_SIZE_MAX)\n\t\tstack_base = STACK_SIZE_MAX;\n\n\t/* Make sure we didn't let the argument array grow too large. */\n\tif (vma->vm_end - vma->vm_start > stack_base)\n\t\treturn -ENOMEM;\n\n\tstack_base = PAGE_ALIGN(stack_top - stack_base);\n\n\tstack_shift = vma->vm_start - stack_base;\n\tmm->arg_start = bprm->p - stack_shift;\n\tbprm->p = vma->vm_end - stack_shift;\n#else\n\tstack_top = arch_align_stack(stack_top);\n\tstack_top = PAGE_ALIGN(stack_top);\n\n\tif (unlikely(stack_top < mmap_min_addr) ||\n\t    unlikely(vma->vm_end - vma->vm_start >= stack_top - mmap_min_addr))\n\t\treturn -ENOMEM;\n\n\tstack_shift = vma->vm_end - stack_top;\n\n\tbprm->p -= stack_shift;\n\tmm->arg_start = bprm->p;\n#endif\n\n\tif (bprm->loader)\n\t\tbprm->loader -= stack_shift;\n\tbprm->exec -= stack_shift;\n\n\tdown_write(&mm->mmap_sem);\n\tvm_flags = VM_STACK_FLAGS;\n\n\t/*\n\t * Adjust stack execute permissions; explicitly enable for\n\t * EXSTACK_ENABLE_X, disable for EXSTACK_DISABLE_X and leave alone\n\t * (arch default) otherwise.\n\t */\n\tif (unlikely(executable_stack == EXSTACK_ENABLE_X))\n\t\tvm_flags |= VM_EXEC;\n\telse if (executable_stack == EXSTACK_DISABLE_X)\n\t\tvm_flags &= ~VM_EXEC;\n\tvm_flags |= mm->def_flags;\n\tvm_flags |= VM_STACK_INCOMPLETE_SETUP;\n\n\tret = mprotect_fixup(vma, &prev, vma->vm_start, vma->vm_end,\n\t\t\tvm_flags);\n\tif (ret)\n\t\tgoto out_unlock;\n\tBUG_ON(prev != vma);\n\n\t/* Move stack pages down in memory. */\n\tif (stack_shift) {\n\t\tret = shift_arg_pages(vma, stack_shift);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t}\n\n\t/* mprotect_fixup is overkill to remove the temporary stack flags */\n\tvma->vm_flags &= ~VM_STACK_INCOMPLETE_SETUP;\n\n\tstack_expand = 131072UL; /* randomly 32*4k (or 2*64k) pages */\n\tstack_size = vma->vm_end - vma->vm_start;\n\t/*\n\t * Align this down to a page boundary as expand_stack\n\t * will align it up.\n\t */\n\trlim_stack = rlimit(RLIMIT_STACK) & PAGE_MASK;\n#ifdef CONFIG_STACK_GROWSUP\n\tif (stack_size + stack_expand > rlim_stack)\n\t\tstack_base = vma->vm_start + rlim_stack;\n\telse\n\t\tstack_base = vma->vm_end + stack_expand;\n#else\n\tif (stack_size + stack_expand > rlim_stack)\n\t\tstack_base = vma->vm_end - rlim_stack;\n\telse\n\t\tstack_base = vma->vm_start - stack_expand;\n#endif\n\tcurrent->mm->start_stack = bprm->p;\n\tret = expand_stack(vma, stack_base);\n\tif (ret)\n\t\tret = -EFAULT;\n\nout_unlock:\n\tup_write(&mm->mmap_sem);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint setup_arg_pages(struct linux_binprm *bprm,\n\t\t    unsigned long stack_top,\n\t\t    int executable_stack)\n{\n\tunsigned long ret;\n\tunsigned long stack_shift;\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma = bprm->vma;\n\tstruct vm_area_struct *prev = NULL;\n\tunsigned long vm_flags;\n\tunsigned long stack_base;\n\tunsigned long stack_size;\n\tunsigned long stack_expand;\n\tunsigned long rlim_stack;\n\n#ifdef CONFIG_STACK_GROWSUP\n\t/* Limit stack size */\n\tstack_base = rlimit_max(RLIMIT_STACK);\n\tif (stack_base > STACK_SIZE_MAX)\n\t\tstack_base = STACK_SIZE_MAX;\n\n\t/* Make sure we didn't let the argument array grow too large. */\n\tif (vma->vm_end - vma->vm_start > stack_base)\n\t\treturn -ENOMEM;\n\n\tstack_base = PAGE_ALIGN(stack_top - stack_base);\n\n\tstack_shift = vma->vm_start - stack_base;\n\tmm->arg_start = bprm->p - stack_shift;\n\tbprm->p = vma->vm_end - stack_shift;\n#else\n\tstack_top = arch_align_stack(stack_top);\n\tstack_top = PAGE_ALIGN(stack_top);\n\n\tif (unlikely(stack_top < mmap_min_addr) ||\n\t    unlikely(vma->vm_end - vma->vm_start >= stack_top - mmap_min_addr))\n\t\treturn -ENOMEM;\n\n\tstack_shift = vma->vm_end - stack_top;\n\n\tbprm->p -= stack_shift;\n\tmm->arg_start = bprm->p;\n#endif\n\n\tif (bprm->loader)\n\t\tbprm->loader -= stack_shift;\n\tbprm->exec -= stack_shift;\n\n\tdown_write(&mm->mmap_sem);\n\tvm_flags = VM_STACK_FLAGS;\n\n\t/*\n\t * Adjust stack execute permissions; explicitly enable for\n\t * EXSTACK_ENABLE_X, disable for EXSTACK_DISABLE_X and leave alone\n\t * (arch default) otherwise.\n\t */\n\tif (unlikely(executable_stack == EXSTACK_ENABLE_X))\n\t\tvm_flags |= VM_EXEC;\n\telse if (executable_stack == EXSTACK_DISABLE_X)\n\t\tvm_flags &= ~VM_EXEC;\n\tvm_flags |= mm->def_flags;\n\tvm_flags |= VM_STACK_INCOMPLETE_SETUP;\n\n\tret = mprotect_fixup(vma, &prev, vma->vm_start, vma->vm_end,\n\t\t\tvm_flags);\n\tif (ret)\n\t\tgoto out_unlock;\n\tBUG_ON(prev != vma);\n\n\t/* Move stack pages down in memory. */\n\tif (stack_shift) {\n\t\tret = shift_arg_pages(vma, stack_shift);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t}\n\n\t/* mprotect_fixup is overkill to remove the temporary stack flags */\n\tvma->vm_flags &= ~VM_STACK_INCOMPLETE_SETUP;\n\n\tstack_expand = 131072UL; /* randomly 32*4k (or 2*64k) pages */\n\tstack_size = vma->vm_end - vma->vm_start;\n\t/*\n\t * Align this down to a page boundary as expand_stack\n\t * will align it up.\n\t */\n\trlim_stack = rlimit(RLIMIT_STACK) & PAGE_MASK;\n#ifdef CONFIG_STACK_GROWSUP\n\tif (stack_size + stack_expand > rlim_stack)\n\t\tstack_base = vma->vm_start + rlim_stack;\n\telse\n\t\tstack_base = vma->vm_end + stack_expand;\n#else\n\tif (stack_size + stack_expand > rlim_stack)\n\t\tstack_base = vma->vm_end - rlim_stack;\n\telse\n\t\tstack_base = vma->vm_start - stack_expand;\n#endif\n\tcurrent->mm->start_stack = bprm->p;\n\tret = expand_stack(vma, stack_base);\n\tif (ret)\n\t\tret = -EFAULT;\n\nout_unlock:\n\tup_write(&mm->mmap_sem);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "randomize_stack_top",
          "args": [
            "STACK_TOP"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "randomize_stack_top",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "646-661",
          "snippet": "static unsigned long randomize_stack_top(unsigned long stack_top)\n{\n\tunsigned long random_variable = 0;\n\n\tif ((current->flags & PF_RANDOMIZE) &&\n\t\t!(current->personality & ADDR_NO_RANDOMIZE)) {\n\t\trandom_variable = (unsigned long) get_random_int();\n\t\trandom_variable &= STACK_RND_MASK;\n\t\trandom_variable <<= PAGE_SHIFT;\n\t}\n#ifdef CONFIG_STACK_GROWSUP\n\treturn PAGE_ALIGN(stack_top) + random_variable;\n#else\n\treturn PAGE_ALIGN(stack_top) - random_variable;\n#endif\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define STACK_RND_MASK (0x7ff >> (PAGE_SHIFT - 12))\t/* 8MB of VA */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define STACK_RND_MASK (0x7ff >> (PAGE_SHIFT - 12))\t/* 8MB of VA */\n\nstatic unsigned long randomize_stack_top(unsigned long stack_top)\n{\n\tunsigned long random_variable = 0;\n\n\tif ((current->flags & PF_RANDOMIZE) &&\n\t\t!(current->personality & ADDR_NO_RANDOMIZE)) {\n\t\trandom_variable = (unsigned long) get_random_int();\n\t\trandom_variable &= STACK_RND_MASK;\n\t\trandom_variable <<= PAGE_SHIFT;\n\t}\n#ifdef CONFIG_STACK_GROWSUP\n\treturn PAGE_ALIGN(stack_top) + random_variable;\n#else\n\treturn PAGE_ALIGN(stack_top) - random_variable;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_new_exec",
          "args": [
            "bprm"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "setup_new_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "1112-1148",
          "snippet": "void setup_new_exec(struct linux_binprm * bprm)\n{\n\tarch_pick_mmap_layout(current->mm);\n\n\t/* This is the point of no return */\n\tcurrent->sas_ss_sp = current->sas_ss_size = 0;\n\n\tif (uid_eq(current_euid(), current_uid()) && gid_eq(current_egid(), current_gid()))\n\t\tset_dumpable(current->mm, SUID_DUMP_USER);\n\telse\n\t\tset_dumpable(current->mm, suid_dumpable);\n\n\tperf_event_exec();\n\t__set_task_comm(current, kbasename(bprm->filename), true);\n\n\t/* Set the new mm task size. We have to do that late because it may\n\t * depend on TIF_32BIT which is only updated in flush_thread() on\n\t * some architectures like powerpc\n\t */\n\tcurrent->mm->task_size = TASK_SIZE;\n\n\t/* install the new credentials */\n\tif (!uid_eq(bprm->cred->uid, current_euid()) ||\n\t    !gid_eq(bprm->cred->gid, current_egid())) {\n\t\tcurrent->pdeath_signal = 0;\n\t} else {\n\t\twould_dump(bprm, bprm->file);\n\t\tif (bprm->interp_flags & BINPRM_FLAGS_ENFORCE_NONDUMP)\n\t\t\tset_dumpable(current->mm, suid_dumpable);\n\t}\n\n\t/* An exec changes our domain. We are no longer part of the thread\n\t   group */\n\tcurrent->self_exec_id++;\n\tflush_signal_handlers(current, 0);\n\tdo_close_on_exec(current->files);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int suid_dumpable = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint suid_dumpable = 0;\n\nvoid setup_new_exec(struct linux_binprm * bprm)\n{\n\tarch_pick_mmap_layout(current->mm);\n\n\t/* This is the point of no return */\n\tcurrent->sas_ss_sp = current->sas_ss_size = 0;\n\n\tif (uid_eq(current_euid(), current_uid()) && gid_eq(current_egid(), current_gid()))\n\t\tset_dumpable(current->mm, SUID_DUMP_USER);\n\telse\n\t\tset_dumpable(current->mm, suid_dumpable);\n\n\tperf_event_exec();\n\t__set_task_comm(current, kbasename(bprm->filename), true);\n\n\t/* Set the new mm task size. We have to do that late because it may\n\t * depend on TIF_32BIT which is only updated in flush_thread() on\n\t * some architectures like powerpc\n\t */\n\tcurrent->mm->task_size = TASK_SIZE;\n\n\t/* install the new credentials */\n\tif (!uid_eq(bprm->cred->uid, current_euid()) ||\n\t    !gid_eq(bprm->cred->gid, current_egid())) {\n\t\tcurrent->pdeath_signal = 0;\n\t} else {\n\t\twould_dump(bprm, bprm->file);\n\t\tif (bprm->interp_flags & BINPRM_FLAGS_ENFORCE_NONDUMP)\n\t\t\tset_dumpable(current->mm, suid_dumpable);\n\t}\n\n\t/* An exec changes our domain. We are no longer part of the thread\n\t   group */\n\tcurrent->self_exec_id++;\n\tflush_signal_handlers(current, 0);\n\tdo_close_on_exec(current->files);\n}"
        }
      },
      {
        "call_info": {
          "callee": "elf_read_implies_exec",
          "args": [
            "loc->elf_ex",
            "executable_stack"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_PERSONALITY2",
          "args": [
            "loc->elf_ex",
            "&arch_state"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_old_exec",
          "args": [
            "bprm"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "flush_old_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "1069-1102",
          "snippet": "int flush_old_exec(struct linux_binprm * bprm)\n{\n\tint retval;\n\n\t/*\n\t * Make sure we have a private signal table and that\n\t * we are unassociated from the previous thread group.\n\t */\n\tretval = de_thread(current);\n\tif (retval)\n\t\tgoto out;\n\n\tset_mm_exe_file(bprm->mm, bprm->file);\n\t/*\n\t * Release all of the old mmap stuff\n\t */\n\tacct_arg_size(bprm, 0);\n\tretval = exec_mmap(bprm->mm);\n\tif (retval)\n\t\tgoto out;\n\n\tbprm->mm = NULL;\t\t/* We're using it now */\n\n\tset_fs(USER_DS);\n\tcurrent->flags &= ~(PF_RANDOMIZE | PF_FORKNOEXEC | PF_KTHREAD |\n\t\t\t\t\tPF_NOFREEZE | PF_NO_SETAFFINITY);\n\tflush_thread();\n\tcurrent->personality &= ~bprm->per_clear;\n\n\treturn 0;\n\nout:\n\treturn retval;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint flush_old_exec(struct linux_binprm * bprm)\n{\n\tint retval;\n\n\t/*\n\t * Make sure we have a private signal table and that\n\t * we are unassociated from the previous thread group.\n\t */\n\tretval = de_thread(current);\n\tif (retval)\n\t\tgoto out;\n\n\tset_mm_exe_file(bprm->mm, bprm->file);\n\t/*\n\t * Release all of the old mmap stuff\n\t */\n\tacct_arg_size(bprm, 0);\n\tretval = exec_mmap(bprm->mm);\n\tif (retval)\n\t\tgoto out;\n\n\tbprm->mm = NULL;\t\t/* We're using it now */\n\n\tset_fs(USER_DS);\n\tcurrent->flags &= ~(PF_RANDOMIZE | PF_FORKNOEXEC | PF_KTHREAD |\n\t\t\t\t\tPF_NOFREEZE | PF_NO_SETAFFINITY);\n\tflush_thread();\n\tcurrent->personality &= ~bprm->per_clear;\n\n\treturn 0;\n\nout:\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_check_elf",
          "args": [
            "&loc->elf_ex",
            "!!interpreter",
            "&arch_state"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "arch_check_elf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "502-507",
          "snippet": "static inline int arch_check_elf(struct elfhdr *ehdr, bool has_interp,\n\t\t\t\t struct arch_elf_state *state)\n{\n\t/* Dummy implementation, always proceed */\n\treturn 0;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic inline int arch_check_elf(struct elfhdr *ehdr, bool has_interp,\n\t\t\t\t struct arch_elf_state *state)\n{\n\t/* Dummy implementation, always proceed */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_elf_pt_proc",
          "args": [
            "&loc->interp_elf_ex",
            "elf_ppnt",
            "interpreter",
            "true",
            "&arch_state"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "arch_elf_pt_proc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "479-486",
          "snippet": "static inline int arch_elf_pt_proc(struct elfhdr *ehdr,\n\t\t\t\t   struct elf_phdr *phdr,\n\t\t\t\t   struct file *elf, bool is_interp,\n\t\t\t\t   struct arch_elf_state *state)\n{\n\t/* Dummy implementation, always proceed */\n\treturn 0;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);\n\nstatic inline int arch_elf_pt_proc(struct elfhdr *ehdr,\n\t\t\t\t   struct elf_phdr *phdr,\n\t\t\t\t   struct file *elf, bool is_interp,\n\t\t\t\t   struct arch_elf_state *state)\n{\n\t/* Dummy implementation, always proceed */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_elf_phdrs",
          "args": [
            "&loc->interp_elf_ex",
            "interpreter"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "load_elf_phdrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "398-441",
          "snippet": "static struct elf_phdr *load_elf_phdrs(struct elfhdr *elf_ex,\n\t\t\t\t       struct file *elf_file)\n{\n\tstruct elf_phdr *elf_phdata = NULL;\n\tint retval, size, err = -1;\n\n\t/*\n\t * If the size of this structure has changed, then punt, since\n\t * we will be doing the wrong thing.\n\t */\n\tif (elf_ex->e_phentsize != sizeof(struct elf_phdr))\n\t\tgoto out;\n\n\t/* Sanity check the number of program headers... */\n\tif (elf_ex->e_phnum < 1 ||\n\t\telf_ex->e_phnum > 65536U / sizeof(struct elf_phdr))\n\t\tgoto out;\n\n\t/* ...and their total size. */\n\tsize = sizeof(struct elf_phdr) * elf_ex->e_phnum;\n\tif (size > ELF_MIN_ALIGN)\n\t\tgoto out;\n\n\telf_phdata = kmalloc(size, GFP_KERNEL);\n\tif (!elf_phdata)\n\t\tgoto out;\n\n\t/* Read in the program headers */\n\tretval = kernel_read(elf_file, elf_ex->e_phoff,\n\t\t\t     (char *)elf_phdata, size);\n\tif (retval != size) {\n\t\terr = (retval < 0) ? retval : -EIO;\n\t\tgoto out;\n\t}\n\n\t/* Success! */\n\terr = 0;\nout:\n\tif (err) {\n\t\tkfree(elf_phdata);\n\t\telf_phdata = NULL;\n\t}\n\treturn elf_phdata;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define ELF_MIN_ALIGN\tPAGE_SIZE",
            "#define ELF_MIN_ALIGN\tELF_EXEC_PAGESIZE"
          ],
          "globals_used": [
            "static unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define ELF_MIN_ALIGN\tPAGE_SIZE\n#define ELF_MIN_ALIGN\tELF_EXEC_PAGESIZE\n\nstatic unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);\n\nstatic struct elf_phdr *load_elf_phdrs(struct elfhdr *elf_ex,\n\t\t\t\t       struct file *elf_file)\n{\n\tstruct elf_phdr *elf_phdata = NULL;\n\tint retval, size, err = -1;\n\n\t/*\n\t * If the size of this structure has changed, then punt, since\n\t * we will be doing the wrong thing.\n\t */\n\tif (elf_ex->e_phentsize != sizeof(struct elf_phdr))\n\t\tgoto out;\n\n\t/* Sanity check the number of program headers... */\n\tif (elf_ex->e_phnum < 1 ||\n\t\telf_ex->e_phnum > 65536U / sizeof(struct elf_phdr))\n\t\tgoto out;\n\n\t/* ...and their total size. */\n\tsize = sizeof(struct elf_phdr) * elf_ex->e_phnum;\n\tif (size > ELF_MIN_ALIGN)\n\t\tgoto out;\n\n\telf_phdata = kmalloc(size, GFP_KERNEL);\n\tif (!elf_phdata)\n\t\tgoto out;\n\n\t/* Read in the program headers */\n\tretval = kernel_read(elf_file, elf_ex->e_phoff,\n\t\t\t     (char *)elf_phdata, size);\n\tif (retval != size) {\n\t\terr = (retval < 0) ? retval : -EIO;\n\t\tgoto out;\n\t}\n\n\t/* Success! */\n\terr = 0;\nout:\n\tif (err) {\n\t\tkfree(elf_phdata);\n\t\telf_phdata = NULL;\n\t}\n\treturn elf_phdata;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elf_check_arch",
          "args": [
            "&loc->interp_elf_ex"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "loc->interp_elf_ex.e_ident",
            "ELFMAG",
            "SELFMAG"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_read",
          "args": [
            "interpreter",
            "0",
            "bprm->buf",
            "BINPRM_BUF_SIZE"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_readv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "569-583",
          "snippet": "static ssize_t kernel_readv(struct file *file, const struct iovec *vec,\n\t\t\t    unsigned long vlen, loff_t offset)\n{\n\tmm_segment_t old_fs;\n\tloff_t pos = offset;\n\tssize_t res;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tres = vfs_readv(file, (const struct iovec __user *)vec, vlen, &pos);\n\tset_fs(old_fs);\n\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic ssize_t kernel_readv(struct file *file, const struct iovec *vec,\n\t\t\t    unsigned long vlen, loff_t offset)\n{\n\tmm_segment_t old_fs;\n\tloff_t pos = offset;\n\tssize_t res;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tres = vfs_readv(file, (const struct iovec __user *)vec, vlen, &pos);\n\tset_fs(old_fs);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "would_dump",
          "args": [
            "bprm",
            "interpreter"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "would_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "1105-1109",
          "snippet": "void would_dump(struct linux_binprm *bprm, struct file *file)\n{\n\tif (inode_permission(file_inode(file), MAY_READ) < 0)\n\t\tbprm->interp_flags |= BINPRM_FLAGS_ENFORCE_NONDUMP;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid would_dump(struct linux_binprm *bprm, struct file *file)\n{\n\tif (inode_permission(file_inode(file), MAY_READ) < 0)\n\t\tbprm->interp_flags |= BINPRM_FLAGS_ENFORCE_NONDUMP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "interpreter"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "interpreter"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open_exec",
          "args": [
            "elf_interpreter"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "open_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "795-805",
          "snippet": "struct file *open_exec(const char *name)\n{\n\tstruct filename *filename = getname_kernel(name);\n\tstruct file *f = ERR_CAST(filename);\n\n\tif (!IS_ERR(filename)) {\n\t\tf = do_open_execat(AT_FDCWD, filename, 0);\n\t\tputname(filename);\n\t}\n\treturn f;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstruct file *open_exec(const char *name)\n{\n\tstruct filename *filename = getname_kernel(name);\n\tstruct file *f = ERR_CAST(filename);\n\n\tif (!IS_ERR(filename)) {\n\t\tf = do_open_execat(AT_FDCWD, filename, 0);\n\t\tputname(filename);\n\t}\n\treturn f;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "elf_ppnt->p_filesz",
            "GFP_KERNEL"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elf_check_arch",
          "args": [
            "&loc->elf_ex"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "loc->elf_ex.e_ident",
            "ELFMAG",
            "SELFMAG"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_pt_regs",
          "args": [],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define INIT_ARCH_ELF_STATE {}\n#define ELF_MIN_ALIGN\tPAGE_SIZE\n#define ELF_MIN_ALIGN\tELF_EXEC_PAGESIZE\n\nstatic int load_elf_binary(struct linux_binprm *bprm);\nstatic unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);\nstatic struct linux_binfmt elf_format = {\n\t.module\t\t= THIS_MODULE,\n\t.load_binary\t= load_elf_binary,\n\t.load_shlib\t= load_elf_library,\n\t.core_dump\t= elf_core_dump,\n\t.min_coredump\t= ELF_EXEC_PAGESIZE,\n};\n\nstatic int load_elf_binary(struct linux_binprm *bprm)\n{\n\tstruct file *interpreter = NULL; /* to shut gcc up */\n \tunsigned long load_addr = 0, load_bias = 0;\n\tint load_addr_set = 0;\n\tchar * elf_interpreter = NULL;\n\tunsigned long error;\n\tstruct elf_phdr *elf_ppnt, *elf_phdata, *interp_elf_phdata = NULL;\n\tunsigned long elf_bss, elf_brk;\n\tint retval, i;\n\tunsigned long elf_entry;\n\tunsigned long interp_load_addr = 0;\n\tunsigned long start_code, end_code, start_data, end_data;\n\tunsigned long reloc_func_desc __maybe_unused = 0;\n\tint executable_stack = EXSTACK_DEFAULT;\n\tstruct pt_regs *regs = current_pt_regs();\n\tstruct {\n\t\tstruct elfhdr elf_ex;\n\t\tstruct elfhdr interp_elf_ex;\n\t} *loc;\n\tstruct arch_elf_state arch_state = INIT_ARCH_ELF_STATE;\n\n\tloc = kmalloc(sizeof(*loc), GFP_KERNEL);\n\tif (!loc) {\n\t\tretval = -ENOMEM;\n\t\tgoto out_ret;\n\t}\n\t\n\t/* Get the exec-header */\n\tloc->elf_ex = *((struct elfhdr *)bprm->buf);\n\n\tretval = -ENOEXEC;\n\t/* First of all, some simple consistency checks */\n\tif (memcmp(loc->elf_ex.e_ident, ELFMAG, SELFMAG) != 0)\n\t\tgoto out;\n\n\tif (loc->elf_ex.e_type != ET_EXEC && loc->elf_ex.e_type != ET_DYN)\n\t\tgoto out;\n\tif (!elf_check_arch(&loc->elf_ex))\n\t\tgoto out;\n\tif (!bprm->file->f_op->mmap)\n\t\tgoto out;\n\n\telf_phdata = load_elf_phdrs(&loc->elf_ex, bprm->file);\n\tif (!elf_phdata)\n\t\tgoto out;\n\n\telf_ppnt = elf_phdata;\n\telf_bss = 0;\n\telf_brk = 0;\n\n\tstart_code = ~0UL;\n\tend_code = 0;\n\tstart_data = 0;\n\tend_data = 0;\n\n\tfor (i = 0; i < loc->elf_ex.e_phnum; i++) {\n\t\tif (elf_ppnt->p_type == PT_INTERP) {\n\t\t\t/* This is the program interpreter used for\n\t\t\t * shared libraries - for now assume that this\n\t\t\t * is an a.out format binary\n\t\t\t */\n\t\t\tretval = -ENOEXEC;\n\t\t\tif (elf_ppnt->p_filesz > PATH_MAX || \n\t\t\t    elf_ppnt->p_filesz < 2)\n\t\t\t\tgoto out_free_ph;\n\n\t\t\tretval = -ENOMEM;\n\t\t\telf_interpreter = kmalloc(elf_ppnt->p_filesz,\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!elf_interpreter)\n\t\t\t\tgoto out_free_ph;\n\n\t\t\tretval = kernel_read(bprm->file, elf_ppnt->p_offset,\n\t\t\t\t\t     elf_interpreter,\n\t\t\t\t\t     elf_ppnt->p_filesz);\n\t\t\tif (retval != elf_ppnt->p_filesz) {\n\t\t\t\tif (retval >= 0)\n\t\t\t\t\tretval = -EIO;\n\t\t\t\tgoto out_free_interp;\n\t\t\t}\n\t\t\t/* make sure path is NULL terminated */\n\t\t\tretval = -ENOEXEC;\n\t\t\tif (elf_interpreter[elf_ppnt->p_filesz - 1] != '\\0')\n\t\t\t\tgoto out_free_interp;\n\n\t\t\tinterpreter = open_exec(elf_interpreter);\n\t\t\tretval = PTR_ERR(interpreter);\n\t\t\tif (IS_ERR(interpreter))\n\t\t\t\tgoto out_free_interp;\n\n\t\t\t/*\n\t\t\t * If the binary is not readable then enforce\n\t\t\t * mm->dumpable = 0 regardless of the interpreter's\n\t\t\t * permissions.\n\t\t\t */\n\t\t\twould_dump(bprm, interpreter);\n\n\t\t\tretval = kernel_read(interpreter, 0, bprm->buf,\n\t\t\t\t\t     BINPRM_BUF_SIZE);\n\t\t\tif (retval != BINPRM_BUF_SIZE) {\n\t\t\t\tif (retval >= 0)\n\t\t\t\t\tretval = -EIO;\n\t\t\t\tgoto out_free_dentry;\n\t\t\t}\n\n\t\t\t/* Get the exec headers */\n\t\t\tloc->interp_elf_ex = *((struct elfhdr *)bprm->buf);\n\t\t\tbreak;\n\t\t}\n\t\telf_ppnt++;\n\t}\n\n\telf_ppnt = elf_phdata;\n\tfor (i = 0; i < loc->elf_ex.e_phnum; i++, elf_ppnt++)\n\t\tswitch (elf_ppnt->p_type) {\n\t\tcase PT_GNU_STACK:\n\t\t\tif (elf_ppnt->p_flags & PF_X)\n\t\t\t\texecutable_stack = EXSTACK_ENABLE_X;\n\t\t\telse\n\t\t\t\texecutable_stack = EXSTACK_DISABLE_X;\n\t\t\tbreak;\n\n\t\tcase PT_LOPROC ... PT_HIPROC:\n\t\t\tretval = arch_elf_pt_proc(&loc->elf_ex, elf_ppnt,\n\t\t\t\t\t\t  bprm->file, false,\n\t\t\t\t\t\t  &arch_state);\n\t\t\tif (retval)\n\t\t\t\tgoto out_free_dentry;\n\t\t\tbreak;\n\t\t}\n\n\t/* Some simple consistency checks for the interpreter */\n\tif (elf_interpreter) {\n\t\tretval = -ELIBBAD;\n\t\t/* Not an ELF interpreter */\n\t\tif (memcmp(loc->interp_elf_ex.e_ident, ELFMAG, SELFMAG) != 0)\n\t\t\tgoto out_free_dentry;\n\t\t/* Verify the interpreter has a valid arch */\n\t\tif (!elf_check_arch(&loc->interp_elf_ex))\n\t\t\tgoto out_free_dentry;\n\n\t\t/* Load the interpreter program headers */\n\t\tinterp_elf_phdata = load_elf_phdrs(&loc->interp_elf_ex,\n\t\t\t\t\t\t   interpreter);\n\t\tif (!interp_elf_phdata)\n\t\t\tgoto out_free_dentry;\n\n\t\t/* Pass PT_LOPROC..PT_HIPROC headers to arch code */\n\t\telf_ppnt = interp_elf_phdata;\n\t\tfor (i = 0; i < loc->interp_elf_ex.e_phnum; i++, elf_ppnt++)\n\t\t\tswitch (elf_ppnt->p_type) {\n\t\t\tcase PT_LOPROC ... PT_HIPROC:\n\t\t\t\tretval = arch_elf_pt_proc(&loc->interp_elf_ex,\n\t\t\t\t\t\t\t  elf_ppnt, interpreter,\n\t\t\t\t\t\t\t  true, &arch_state);\n\t\t\t\tif (retval)\n\t\t\t\t\tgoto out_free_dentry;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\t/*\n\t * Allow arch code to reject the ELF at this point, whilst it's\n\t * still possible to return an error to the code that invoked\n\t * the exec syscall.\n\t */\n\tretval = arch_check_elf(&loc->elf_ex, !!interpreter, &arch_state);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\n\t/* Flush all traces of the currently running executable */\n\tretval = flush_old_exec(bprm);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\n\t/* Do this immediately, since STACK_TOP as used in setup_arg_pages\n\t   may depend on the personality.  */\n\tSET_PERSONALITY2(loc->elf_ex, &arch_state);\n\tif (elf_read_implies_exec(loc->elf_ex, executable_stack))\n\t\tcurrent->personality |= READ_IMPLIES_EXEC;\n\n\tif (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)\n\t\tcurrent->flags |= PF_RANDOMIZE;\n\n\tsetup_new_exec(bprm);\n\n\t/* Do this so that we can load the interpreter, if need be.  We will\n\t   change some of these later */\n\tretval = setup_arg_pages(bprm, randomize_stack_top(STACK_TOP),\n\t\t\t\t executable_stack);\n\tif (retval < 0)\n\t\tgoto out_free_dentry;\n\t\n\tcurrent->mm->start_stack = bprm->p;\n\n\t/* Now we do a little grungy work by mmapping the ELF image into\n\t   the correct location in memory. */\n\tfor(i = 0, elf_ppnt = elf_phdata;\n\t    i < loc->elf_ex.e_phnum; i++, elf_ppnt++) {\n\t\tint elf_prot = 0, elf_flags;\n\t\tunsigned long k, vaddr;\n\n\t\tif (elf_ppnt->p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tif (unlikely (elf_brk > elf_bss)) {\n\t\t\tunsigned long nbyte;\n\t            \n\t\t\t/* There was a PT_LOAD segment with p_memsz > p_filesz\n\t\t\t   before this one. Map anonymous pages, if needed,\n\t\t\t   and clear the area.  */\n\t\t\tretval = set_brk(elf_bss + load_bias,\n\t\t\t\t\t elf_brk + load_bias);\n\t\t\tif (retval)\n\t\t\t\tgoto out_free_dentry;\n\t\t\tnbyte = ELF_PAGEOFFSET(elf_bss);\n\t\t\tif (nbyte) {\n\t\t\t\tnbyte = ELF_MIN_ALIGN - nbyte;\n\t\t\t\tif (nbyte > elf_brk - elf_bss)\n\t\t\t\t\tnbyte = elf_brk - elf_bss;\n\t\t\t\tif (clear_user((void __user *)elf_bss +\n\t\t\t\t\t\t\tload_bias, nbyte)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * This bss-zeroing can fail if the ELF\n\t\t\t\t\t * file specifies odd protections. So\n\t\t\t\t\t * we don't check the return value\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (elf_ppnt->p_flags & PF_R)\n\t\t\telf_prot |= PROT_READ;\n\t\tif (elf_ppnt->p_flags & PF_W)\n\t\t\telf_prot |= PROT_WRITE;\n\t\tif (elf_ppnt->p_flags & PF_X)\n\t\t\telf_prot |= PROT_EXEC;\n\n\t\telf_flags = MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE;\n\n\t\tvaddr = elf_ppnt->p_vaddr;\n\t\tif (loc->elf_ex.e_type == ET_EXEC || load_addr_set) {\n\t\t\telf_flags |= MAP_FIXED;\n\t\t} else if (loc->elf_ex.e_type == ET_DYN) {\n\t\t\t/* Try and get dynamic programs out of the way of the\n\t\t\t * default mmap base, as well as whatever program they\n\t\t\t * might try to exec.  This is because the brk will\n\t\t\t * follow the loader, and is not movable.  */\n#ifdef CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE\n\t\t\t/* Memory randomization might have been switched off\n\t\t\t * in runtime via sysctl or explicit setting of\n\t\t\t * personality flags.\n\t\t\t * If that is the case, retain the original non-zero\n\t\t\t * load_bias value in order to establish proper\n\t\t\t * non-randomized mappings.\n\t\t\t */\n\t\t\tif (current->flags & PF_RANDOMIZE)\n\t\t\t\tload_bias = 0;\n\t\t\telse\n\t\t\t\tload_bias = ELF_PAGESTART(ELF_ET_DYN_BASE - vaddr);\n#else\n\t\t\tload_bias = ELF_PAGESTART(ELF_ET_DYN_BASE - vaddr);\n#endif\n\t\t}\n\n\t\terror = elf_map(bprm->file, load_bias + vaddr, elf_ppnt,\n\t\t\t\telf_prot, elf_flags, 0);\n\t\tif (BAD_ADDR(error)) {\n\t\t\tretval = IS_ERR((void *)error) ?\n\t\t\t\tPTR_ERR((void*)error) : -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\n\t\tif (!load_addr_set) {\n\t\t\tload_addr_set = 1;\n\t\t\tload_addr = (elf_ppnt->p_vaddr - elf_ppnt->p_offset);\n\t\t\tif (loc->elf_ex.e_type == ET_DYN) {\n\t\t\t\tload_bias += error -\n\t\t\t\t             ELF_PAGESTART(load_bias + vaddr);\n\t\t\t\tload_addr += load_bias;\n\t\t\t\treloc_func_desc = load_bias;\n\t\t\t}\n\t\t}\n\t\tk = elf_ppnt->p_vaddr;\n\t\tif (k < start_code)\n\t\t\tstart_code = k;\n\t\tif (start_data < k)\n\t\t\tstart_data = k;\n\n\t\t/*\n\t\t * Check to see if the section's size will overflow the\n\t\t * allowed task size. Note that p_filesz must always be\n\t\t * <= p_memsz so it is only necessary to check p_memsz.\n\t\t */\n\t\tif (BAD_ADDR(k) || elf_ppnt->p_filesz > elf_ppnt->p_memsz ||\n\t\t    elf_ppnt->p_memsz > TASK_SIZE ||\n\t\t    TASK_SIZE - elf_ppnt->p_memsz < k) {\n\t\t\t/* set_brk can never work. Avoid overflows. */\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\n\t\tk = elf_ppnt->p_vaddr + elf_ppnt->p_filesz;\n\n\t\tif (k > elf_bss)\n\t\t\telf_bss = k;\n\t\tif ((elf_ppnt->p_flags & PF_X) && end_code < k)\n\t\t\tend_code = k;\n\t\tif (end_data < k)\n\t\t\tend_data = k;\n\t\tk = elf_ppnt->p_vaddr + elf_ppnt->p_memsz;\n\t\tif (k > elf_brk)\n\t\t\telf_brk = k;\n\t}\n\n\tloc->elf_ex.e_entry += load_bias;\n\telf_bss += load_bias;\n\telf_brk += load_bias;\n\tstart_code += load_bias;\n\tend_code += load_bias;\n\tstart_data += load_bias;\n\tend_data += load_bias;\n\n\t/* Calling set_brk effectively mmaps the pages that we need\n\t * for the bss and break sections.  We must do this before\n\t * mapping in the interpreter, to make sure it doesn't wind\n\t * up getting placed where the bss needs to go.\n\t */\n\tretval = set_brk(elf_bss, elf_brk);\n\tif (retval)\n\t\tgoto out_free_dentry;\n\tif (likely(elf_bss != elf_brk) && unlikely(padzero(elf_bss))) {\n\t\tretval = -EFAULT; /* Nobody gets to see this, but.. */\n\t\tgoto out_free_dentry;\n\t}\n\n\tif (elf_interpreter) {\n\t\tunsigned long interp_map_addr = 0;\n\n\t\telf_entry = load_elf_interp(&loc->interp_elf_ex,\n\t\t\t\t\t    interpreter,\n\t\t\t\t\t    &interp_map_addr,\n\t\t\t\t\t    load_bias, interp_elf_phdata);\n\t\tif (!IS_ERR((void *)elf_entry)) {\n\t\t\t/*\n\t\t\t * load_elf_interp() returns relocation\n\t\t\t * adjustment\n\t\t\t */\n\t\t\tinterp_load_addr = elf_entry;\n\t\t\telf_entry += loc->interp_elf_ex.e_entry;\n\t\t}\n\t\tif (BAD_ADDR(elf_entry)) {\n\t\t\tretval = IS_ERR((void *)elf_entry) ?\n\t\t\t\t\t(int)elf_entry : -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\t\treloc_func_desc = interp_load_addr;\n\n\t\tallow_write_access(interpreter);\n\t\tfput(interpreter);\n\t\tkfree(elf_interpreter);\n\t} else {\n\t\telf_entry = loc->elf_ex.e_entry;\n\t\tif (BAD_ADDR(elf_entry)) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out_free_dentry;\n\t\t}\n\t}\n\n\tkfree(interp_elf_phdata);\n\tkfree(elf_phdata);\n\n\tset_binfmt(&elf_format);\n\n#ifdef ARCH_HAS_SETUP_ADDITIONAL_PAGES\n\tretval = arch_setup_additional_pages(bprm, !!elf_interpreter);\n\tif (retval < 0)\n\t\tgoto out;\n#endif /* ARCH_HAS_SETUP_ADDITIONAL_PAGES */\n\n\tinstall_exec_creds(bprm);\n\tretval = create_elf_tables(bprm, &loc->elf_ex,\n\t\t\t  load_addr, interp_load_addr);\n\tif (retval < 0)\n\t\tgoto out;\n\t/* N.B. passed_fileno might not be initialized? */\n\tcurrent->mm->end_code = end_code;\n\tcurrent->mm->start_code = start_code;\n\tcurrent->mm->start_data = start_data;\n\tcurrent->mm->end_data = end_data;\n\tcurrent->mm->start_stack = bprm->p;\n\n#ifdef arch_randomize_brk\n\tif ((current->flags & PF_RANDOMIZE) && (randomize_va_space > 1)) {\n\t\tcurrent->mm->brk = current->mm->start_brk =\n\t\t\tarch_randomize_brk(current->mm);\n#ifdef CONFIG_COMPAT_BRK\n\t\tcurrent->brk_randomized = 1;\n#endif\n\t}\n#endif\n\n\tif (current->personality & MMAP_PAGE_ZERO) {\n\t\t/* Why this, you ask???  Well SVr4 maps page 0 as read-only,\n\t\t   and some applications \"depend\" upon this behavior.\n\t\t   Since we do not have the power to recompile these, we\n\t\t   emulate the SVr4 behavior. Sigh. */\n\t\terror = vm_mmap(NULL, 0, PAGE_SIZE, PROT_READ | PROT_EXEC,\n\t\t\t\tMAP_FIXED | MAP_PRIVATE, 0);\n\t}\n\n#ifdef ELF_PLAT_INIT\n\t/*\n\t * The ABI may specify that certain registers be set up in special\n\t * ways (on i386 %edx is the address of a DT_FINI function, for\n\t * example.  In addition, it may also specify (eg, PowerPC64 ELF)\n\t * that the e_entry field is the address of the function descriptor\n\t * for the startup routine, rather than the address of the startup\n\t * routine itself.  This macro performs whatever initialization to\n\t * the regs structure is required as well as any relocations to the\n\t * function descriptor entries when executing dynamically links apps.\n\t */\n\tELF_PLAT_INIT(regs, reloc_func_desc);\n#endif\n\n\tstart_thread(regs, elf_entry, bprm->p);\n\tretval = 0;\nout:\n\tkfree(loc);\nout_ret:\n\treturn retval;\n\n\t/* error cleanup */\nout_free_dentry:\n\tkfree(interp_elf_phdata);\n\tallow_write_access(interpreter);\n\tif (interpreter)\n\t\tfput(interpreter);\nout_free_interp:\n\tkfree(elf_interpreter);\nout_free_ph:\n\tkfree(elf_phdata);\n\tgoto out;\n}"
  },
  {
    "function_name": "randomize_stack_top",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
    "lines": "646-661",
    "snippet": "static unsigned long randomize_stack_top(unsigned long stack_top)\n{\n\tunsigned long random_variable = 0;\n\n\tif ((current->flags & PF_RANDOMIZE) &&\n\t\t!(current->personality & ADDR_NO_RANDOMIZE)) {\n\t\trandom_variable = (unsigned long) get_random_int();\n\t\trandom_variable &= STACK_RND_MASK;\n\t\trandom_variable <<= PAGE_SHIFT;\n\t}\n#ifdef CONFIG_STACK_GROWSUP\n\treturn PAGE_ALIGN(stack_top) + random_variable;\n#else\n\treturn PAGE_ALIGN(stack_top) - random_variable;\n#endif\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define STACK_RND_MASK (0x7ff >> (PAGE_SHIFT - 12))\t/* 8MB of VA */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "stack_top"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "stack_top"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_random_int",
          "args": [],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define STACK_RND_MASK (0x7ff >> (PAGE_SHIFT - 12))\t/* 8MB of VA */\n\nstatic unsigned long randomize_stack_top(unsigned long stack_top)\n{\n\tunsigned long random_variable = 0;\n\n\tif ((current->flags & PF_RANDOMIZE) &&\n\t\t!(current->personality & ADDR_NO_RANDOMIZE)) {\n\t\trandom_variable = (unsigned long) get_random_int();\n\t\trandom_variable &= STACK_RND_MASK;\n\t\trandom_variable <<= PAGE_SHIFT;\n\t}\n#ifdef CONFIG_STACK_GROWSUP\n\treturn PAGE_ALIGN(stack_top) + random_variable;\n#else\n\treturn PAGE_ALIGN(stack_top) - random_variable;\n#endif\n}"
  },
  {
    "function_name": "load_elf_interp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
    "lines": "516-635",
    "snippet": "static unsigned long load_elf_interp(struct elfhdr *interp_elf_ex,\n\t\tstruct file *interpreter, unsigned long *interp_map_addr,\n\t\tunsigned long no_base, struct elf_phdr *interp_elf_phdata)\n{\n\tstruct elf_phdr *eppnt;\n\tunsigned long load_addr = 0;\n\tint load_addr_set = 0;\n\tunsigned long last_bss = 0, elf_bss = 0;\n\tunsigned long error = ~0UL;\n\tunsigned long total_size;\n\tint i;\n\n\t/* First of all, some simple consistency checks */\n\tif (interp_elf_ex->e_type != ET_EXEC &&\n\t    interp_elf_ex->e_type != ET_DYN)\n\t\tgoto out;\n\tif (!elf_check_arch(interp_elf_ex))\n\t\tgoto out;\n\tif (!interpreter->f_op->mmap)\n\t\tgoto out;\n\n\ttotal_size = total_mapping_size(interp_elf_phdata,\n\t\t\t\t\tinterp_elf_ex->e_phnum);\n\tif (!total_size) {\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\teppnt = interp_elf_phdata;\n\tfor (i = 0; i < interp_elf_ex->e_phnum; i++, eppnt++) {\n\t\tif (eppnt->p_type == PT_LOAD) {\n\t\t\tint elf_type = MAP_PRIVATE | MAP_DENYWRITE;\n\t\t\tint elf_prot = 0;\n\t\t\tunsigned long vaddr = 0;\n\t\t\tunsigned long k, map_addr;\n\n\t\t\tif (eppnt->p_flags & PF_R)\n\t\t    \t\telf_prot = PROT_READ;\n\t\t\tif (eppnt->p_flags & PF_W)\n\t\t\t\telf_prot |= PROT_WRITE;\n\t\t\tif (eppnt->p_flags & PF_X)\n\t\t\t\telf_prot |= PROT_EXEC;\n\t\t\tvaddr = eppnt->p_vaddr;\n\t\t\tif (interp_elf_ex->e_type == ET_EXEC || load_addr_set)\n\t\t\t\telf_type |= MAP_FIXED;\n\t\t\telse if (no_base && interp_elf_ex->e_type == ET_DYN)\n\t\t\t\tload_addr = -vaddr;\n\n\t\t\tmap_addr = elf_map(interpreter, load_addr + vaddr,\n\t\t\t\t\teppnt, elf_prot, elf_type, total_size);\n\t\t\ttotal_size = 0;\n\t\t\tif (!*interp_map_addr)\n\t\t\t\t*interp_map_addr = map_addr;\n\t\t\terror = map_addr;\n\t\t\tif (BAD_ADDR(map_addr))\n\t\t\t\tgoto out;\n\n\t\t\tif (!load_addr_set &&\n\t\t\t    interp_elf_ex->e_type == ET_DYN) {\n\t\t\t\tload_addr = map_addr - ELF_PAGESTART(vaddr);\n\t\t\t\tload_addr_set = 1;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check to see if the section's size will overflow the\n\t\t\t * allowed task size. Note that p_filesz must always be\n\t\t\t * <= p_memsize so it's only necessary to check p_memsz.\n\t\t\t */\n\t\t\tk = load_addr + eppnt->p_vaddr;\n\t\t\tif (BAD_ADDR(k) ||\n\t\t\t    eppnt->p_filesz > eppnt->p_memsz ||\n\t\t\t    eppnt->p_memsz > TASK_SIZE ||\n\t\t\t    TASK_SIZE - eppnt->p_memsz < k) {\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Find the end of the file mapping for this phdr, and\n\t\t\t * keep track of the largest address we see for this.\n\t\t\t */\n\t\t\tk = load_addr + eppnt->p_vaddr + eppnt->p_filesz;\n\t\t\tif (k > elf_bss)\n\t\t\t\telf_bss = k;\n\n\t\t\t/*\n\t\t\t * Do the same thing for the memory mapping - between\n\t\t\t * elf_bss and last_bss is the bss section.\n\t\t\t */\n\t\t\tk = load_addr + eppnt->p_memsz + eppnt->p_vaddr;\n\t\t\tif (k > last_bss)\n\t\t\t\tlast_bss = k;\n\t\t}\n\t}\n\n\tif (last_bss > elf_bss) {\n\t\t/*\n\t\t * Now fill out the bss section.  First pad the last page up\n\t\t * to the page boundary, and then perform a mmap to make sure\n\t\t * that there are zero-mapped pages up to and including the\n\t\t * last bss page.\n\t\t */\n\t\tif (padzero(elf_bss)) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* What we have mapped so far */\n\t\telf_bss = ELF_PAGESTART(elf_bss + ELF_MIN_ALIGN - 1);\n\n\t\t/* Map the last of the bss segment */\n\t\terror = vm_brk(elf_bss, last_bss - elf_bss);\n\t\tif (BAD_ADDR(error))\n\t\t\tgoto out;\n\t}\n\n\terror = load_addr;\nout:\n\treturn error;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define ELF_MIN_ALIGN\tPAGE_SIZE",
      "#define ELF_MIN_ALIGN\tELF_EXEC_PAGESIZE"
    ],
    "globals_used": [
      "static unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BAD_ADDR",
          "args": [
            "error"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_brk",
          "args": [
            "elf_bss",
            "last_bss - elf_bss"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF_PAGESTART",
          "args": [
            "elf_bss + ELF_MIN_ALIGN - 1"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "padzero",
          "args": [
            "elf_bss"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "padzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "111-122",
          "snippet": "static int padzero(unsigned long elf_bss)\n{\n\tunsigned long nbyte;\n\n\tnbyte = ELF_PAGEOFFSET(elf_bss);\n\tif (nbyte) {\n\t\tnbyte = ELF_MIN_ALIGN - nbyte;\n\t\tif (clear_user((void __user *) elf_bss, nbyte))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define ELF_MIN_ALIGN\tPAGE_SIZE",
            "#define ELF_MIN_ALIGN\tELF_EXEC_PAGESIZE"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define ELF_MIN_ALIGN\tPAGE_SIZE\n#define ELF_MIN_ALIGN\tELF_EXEC_PAGESIZE\n\nstatic int padzero(unsigned long elf_bss)\n{\n\tunsigned long nbyte;\n\n\tnbyte = ELF_PAGEOFFSET(elf_bss);\n\tif (nbyte) {\n\t\tnbyte = ELF_MIN_ALIGN - nbyte;\n\t\tif (clear_user((void __user *) elf_bss, nbyte))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BAD_ADDR",
          "args": [
            "k"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF_PAGESTART",
          "args": [
            "vaddr"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BAD_ADDR",
          "args": [
            "map_addr"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elf_map",
          "args": [
            "interpreter",
            "load_addr + vaddr",
            "eppnt",
            "elf_prot",
            "elf_type",
            "total_size"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "elf_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "335-367",
          "snippet": "static unsigned long elf_map(struct file *filep, unsigned long addr,\n\t\tstruct elf_phdr *eppnt, int prot, int type,\n\t\tunsigned long total_size)\n{\n\tunsigned long map_addr;\n\tunsigned long size = eppnt->p_filesz + ELF_PAGEOFFSET(eppnt->p_vaddr);\n\tunsigned long off = eppnt->p_offset - ELF_PAGEOFFSET(eppnt->p_vaddr);\n\taddr = ELF_PAGESTART(addr);\n\tsize = ELF_PAGEALIGN(size);\n\n\t/* mmap() will return -EINVAL if given a zero size, but a\n\t * segment with zero filesize is perfectly valid */\n\tif (!size)\n\t\treturn addr;\n\n\t/*\n\t* total_size is the size of the ELF (interpreter) image.\n\t* The _first_ mmap needs to know the full size, otherwise\n\t* randomization might put this image into an overlapping\n\t* position with the ELF binary image. (since size < total_size)\n\t* So we first map the 'big' image - and unmap the remainder at\n\t* the end. (which unmap is needed for ELF images with holes.)\n\t*/\n\tif (total_size) {\n\t\ttotal_size = ELF_PAGEALIGN(total_size);\n\t\tmap_addr = vm_mmap(filep, addr, total_size, prot, type, off);\n\t\tif (!BAD_ADDR(map_addr))\n\t\t\tvm_munmap(map_addr+size, total_size-size);\n\t} else\n\t\tmap_addr = vm_mmap(filep, addr, size, prot, type, off);\n\n\treturn(map_addr);\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);\n\nstatic unsigned long elf_map(struct file *filep, unsigned long addr,\n\t\tstruct elf_phdr *eppnt, int prot, int type,\n\t\tunsigned long total_size)\n{\n\tunsigned long map_addr;\n\tunsigned long size = eppnt->p_filesz + ELF_PAGEOFFSET(eppnt->p_vaddr);\n\tunsigned long off = eppnt->p_offset - ELF_PAGEOFFSET(eppnt->p_vaddr);\n\taddr = ELF_PAGESTART(addr);\n\tsize = ELF_PAGEALIGN(size);\n\n\t/* mmap() will return -EINVAL if given a zero size, but a\n\t * segment with zero filesize is perfectly valid */\n\tif (!size)\n\t\treturn addr;\n\n\t/*\n\t* total_size is the size of the ELF (interpreter) image.\n\t* The _first_ mmap needs to know the full size, otherwise\n\t* randomization might put this image into an overlapping\n\t* position with the ELF binary image. (since size < total_size)\n\t* So we first map the 'big' image - and unmap the remainder at\n\t* the end. (which unmap is needed for ELF images with holes.)\n\t*/\n\tif (total_size) {\n\t\ttotal_size = ELF_PAGEALIGN(total_size);\n\t\tmap_addr = vm_mmap(filep, addr, total_size, prot, type, off);\n\t\tif (!BAD_ADDR(map_addr))\n\t\t\tvm_munmap(map_addr+size, total_size-size);\n\t} else\n\t\tmap_addr = vm_mmap(filep, addr, size, prot, type, off);\n\n\treturn(map_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "total_mapping_size",
          "args": [
            "interp_elf_phdata",
            "interp_elf_ex->e_phnum"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "total_mapping_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
          "lines": "371-387",
          "snippet": "static unsigned long total_mapping_size(struct elf_phdr *cmds, int nr)\n{\n\tint i, first_idx = -1, last_idx = -1;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tif (cmds[i].p_type == PT_LOAD) {\n\t\t\tlast_idx = i;\n\t\t\tif (first_idx == -1)\n\t\t\t\tfirst_idx = i;\n\t\t}\n\t}\n\tif (first_idx == -1)\n\t\treturn 0;\n\n\treturn cmds[last_idx].p_vaddr + cmds[last_idx].p_memsz -\n\t\t\t\tELF_PAGESTART(cmds[first_idx].p_vaddr);\n}",
          "includes": [
            "#include <linux/regset.h>",
            "#include <asm/page.h>",
            "#include <asm/param.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/coredump.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elf.h>",
            "#include <linux/random.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/compiler.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/personality.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/string.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);\n\nstatic unsigned long total_mapping_size(struct elf_phdr *cmds, int nr)\n{\n\tint i, first_idx = -1, last_idx = -1;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tif (cmds[i].p_type == PT_LOAD) {\n\t\t\tlast_idx = i;\n\t\t\tif (first_idx == -1)\n\t\t\t\tfirst_idx = i;\n\t\t}\n\t}\n\tif (first_idx == -1)\n\t\treturn 0;\n\n\treturn cmds[last_idx].p_vaddr + cmds[last_idx].p_memsz -\n\t\t\t\tELF_PAGESTART(cmds[first_idx].p_vaddr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "elf_check_arch",
          "args": [
            "interp_elf_ex"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define ELF_MIN_ALIGN\tPAGE_SIZE\n#define ELF_MIN_ALIGN\tELF_EXEC_PAGESIZE\n\nstatic unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);\n\nstatic unsigned long load_elf_interp(struct elfhdr *interp_elf_ex,\n\t\tstruct file *interpreter, unsigned long *interp_map_addr,\n\t\tunsigned long no_base, struct elf_phdr *interp_elf_phdata)\n{\n\tstruct elf_phdr *eppnt;\n\tunsigned long load_addr = 0;\n\tint load_addr_set = 0;\n\tunsigned long last_bss = 0, elf_bss = 0;\n\tunsigned long error = ~0UL;\n\tunsigned long total_size;\n\tint i;\n\n\t/* First of all, some simple consistency checks */\n\tif (interp_elf_ex->e_type != ET_EXEC &&\n\t    interp_elf_ex->e_type != ET_DYN)\n\t\tgoto out;\n\tif (!elf_check_arch(interp_elf_ex))\n\t\tgoto out;\n\tif (!interpreter->f_op->mmap)\n\t\tgoto out;\n\n\ttotal_size = total_mapping_size(interp_elf_phdata,\n\t\t\t\t\tinterp_elf_ex->e_phnum);\n\tif (!total_size) {\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\teppnt = interp_elf_phdata;\n\tfor (i = 0; i < interp_elf_ex->e_phnum; i++, eppnt++) {\n\t\tif (eppnt->p_type == PT_LOAD) {\n\t\t\tint elf_type = MAP_PRIVATE | MAP_DENYWRITE;\n\t\t\tint elf_prot = 0;\n\t\t\tunsigned long vaddr = 0;\n\t\t\tunsigned long k, map_addr;\n\n\t\t\tif (eppnt->p_flags & PF_R)\n\t\t    \t\telf_prot = PROT_READ;\n\t\t\tif (eppnt->p_flags & PF_W)\n\t\t\t\telf_prot |= PROT_WRITE;\n\t\t\tif (eppnt->p_flags & PF_X)\n\t\t\t\telf_prot |= PROT_EXEC;\n\t\t\tvaddr = eppnt->p_vaddr;\n\t\t\tif (interp_elf_ex->e_type == ET_EXEC || load_addr_set)\n\t\t\t\telf_type |= MAP_FIXED;\n\t\t\telse if (no_base && interp_elf_ex->e_type == ET_DYN)\n\t\t\t\tload_addr = -vaddr;\n\n\t\t\tmap_addr = elf_map(interpreter, load_addr + vaddr,\n\t\t\t\t\teppnt, elf_prot, elf_type, total_size);\n\t\t\ttotal_size = 0;\n\t\t\tif (!*interp_map_addr)\n\t\t\t\t*interp_map_addr = map_addr;\n\t\t\terror = map_addr;\n\t\t\tif (BAD_ADDR(map_addr))\n\t\t\t\tgoto out;\n\n\t\t\tif (!load_addr_set &&\n\t\t\t    interp_elf_ex->e_type == ET_DYN) {\n\t\t\t\tload_addr = map_addr - ELF_PAGESTART(vaddr);\n\t\t\t\tload_addr_set = 1;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Check to see if the section's size will overflow the\n\t\t\t * allowed task size. Note that p_filesz must always be\n\t\t\t * <= p_memsize so it's only necessary to check p_memsz.\n\t\t\t */\n\t\t\tk = load_addr + eppnt->p_vaddr;\n\t\t\tif (BAD_ADDR(k) ||\n\t\t\t    eppnt->p_filesz > eppnt->p_memsz ||\n\t\t\t    eppnt->p_memsz > TASK_SIZE ||\n\t\t\t    TASK_SIZE - eppnt->p_memsz < k) {\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Find the end of the file mapping for this phdr, and\n\t\t\t * keep track of the largest address we see for this.\n\t\t\t */\n\t\t\tk = load_addr + eppnt->p_vaddr + eppnt->p_filesz;\n\t\t\tif (k > elf_bss)\n\t\t\t\telf_bss = k;\n\n\t\t\t/*\n\t\t\t * Do the same thing for the memory mapping - between\n\t\t\t * elf_bss and last_bss is the bss section.\n\t\t\t */\n\t\t\tk = load_addr + eppnt->p_memsz + eppnt->p_vaddr;\n\t\t\tif (k > last_bss)\n\t\t\t\tlast_bss = k;\n\t\t}\n\t}\n\n\tif (last_bss > elf_bss) {\n\t\t/*\n\t\t * Now fill out the bss section.  First pad the last page up\n\t\t * to the page boundary, and then perform a mmap to make sure\n\t\t * that there are zero-mapped pages up to and including the\n\t\t * last bss page.\n\t\t */\n\t\tif (padzero(elf_bss)) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* What we have mapped so far */\n\t\telf_bss = ELF_PAGESTART(elf_bss + ELF_MIN_ALIGN - 1);\n\n\t\t/* Map the last of the bss segment */\n\t\terror = vm_brk(elf_bss, last_bss - elf_bss);\n\t\tif (BAD_ADDR(error))\n\t\t\tgoto out;\n\t}\n\n\terror = load_addr;\nout:\n\treturn error;\n}"
  },
  {
    "function_name": "arch_check_elf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
    "lines": "502-507",
    "snippet": "static inline int arch_check_elf(struct elfhdr *ehdr, bool has_interp,\n\t\t\t\t struct arch_elf_state *state)\n{\n\t/* Dummy implementation, always proceed */\n\treturn 0;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic inline int arch_check_elf(struct elfhdr *ehdr, bool has_interp,\n\t\t\t\t struct arch_elf_state *state)\n{\n\t/* Dummy implementation, always proceed */\n\treturn 0;\n}"
  },
  {
    "function_name": "arch_elf_pt_proc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
    "lines": "479-486",
    "snippet": "static inline int arch_elf_pt_proc(struct elfhdr *ehdr,\n\t\t\t\t   struct elf_phdr *phdr,\n\t\t\t\t   struct file *elf, bool is_interp,\n\t\t\t\t   struct arch_elf_state *state)\n{\n\t/* Dummy implementation, always proceed */\n\treturn 0;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);\n\nstatic inline int arch_elf_pt_proc(struct elfhdr *ehdr,\n\t\t\t\t   struct elf_phdr *phdr,\n\t\t\t\t   struct file *elf, bool is_interp,\n\t\t\t\t   struct arch_elf_state *state)\n{\n\t/* Dummy implementation, always proceed */\n\treturn 0;\n}"
  },
  {
    "function_name": "load_elf_phdrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
    "lines": "398-441",
    "snippet": "static struct elf_phdr *load_elf_phdrs(struct elfhdr *elf_ex,\n\t\t\t\t       struct file *elf_file)\n{\n\tstruct elf_phdr *elf_phdata = NULL;\n\tint retval, size, err = -1;\n\n\t/*\n\t * If the size of this structure has changed, then punt, since\n\t * we will be doing the wrong thing.\n\t */\n\tif (elf_ex->e_phentsize != sizeof(struct elf_phdr))\n\t\tgoto out;\n\n\t/* Sanity check the number of program headers... */\n\tif (elf_ex->e_phnum < 1 ||\n\t\telf_ex->e_phnum > 65536U / sizeof(struct elf_phdr))\n\t\tgoto out;\n\n\t/* ...and their total size. */\n\tsize = sizeof(struct elf_phdr) * elf_ex->e_phnum;\n\tif (size > ELF_MIN_ALIGN)\n\t\tgoto out;\n\n\telf_phdata = kmalloc(size, GFP_KERNEL);\n\tif (!elf_phdata)\n\t\tgoto out;\n\n\t/* Read in the program headers */\n\tretval = kernel_read(elf_file, elf_ex->e_phoff,\n\t\t\t     (char *)elf_phdata, size);\n\tif (retval != size) {\n\t\terr = (retval < 0) ? retval : -EIO;\n\t\tgoto out;\n\t}\n\n\t/* Success! */\n\terr = 0;\nout:\n\tif (err) {\n\t\tkfree(elf_phdata);\n\t\telf_phdata = NULL;\n\t}\n\treturn elf_phdata;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define ELF_MIN_ALIGN\tPAGE_SIZE",
      "#define ELF_MIN_ALIGN\tELF_EXEC_PAGESIZE"
    ],
    "globals_used": [
      "static unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "elf_phdata"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_read",
          "args": [
            "elf_file",
            "elf_ex->e_phoff",
            "(char *)elf_phdata",
            "size"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_readv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "569-583",
          "snippet": "static ssize_t kernel_readv(struct file *file, const struct iovec *vec,\n\t\t\t    unsigned long vlen, loff_t offset)\n{\n\tmm_segment_t old_fs;\n\tloff_t pos = offset;\n\tssize_t res;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tres = vfs_readv(file, (const struct iovec __user *)vec, vlen, &pos);\n\tset_fs(old_fs);\n\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic ssize_t kernel_readv(struct file *file, const struct iovec *vec,\n\t\t\t    unsigned long vlen, loff_t offset)\n{\n\tmm_segment_t old_fs;\n\tloff_t pos = offset;\n\tssize_t res;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tres = vfs_readv(file, (const struct iovec __user *)vec, vlen, &pos);\n\tset_fs(old_fs);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define ELF_MIN_ALIGN\tPAGE_SIZE\n#define ELF_MIN_ALIGN\tELF_EXEC_PAGESIZE\n\nstatic unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);\n\nstatic struct elf_phdr *load_elf_phdrs(struct elfhdr *elf_ex,\n\t\t\t\t       struct file *elf_file)\n{\n\tstruct elf_phdr *elf_phdata = NULL;\n\tint retval, size, err = -1;\n\n\t/*\n\t * If the size of this structure has changed, then punt, since\n\t * we will be doing the wrong thing.\n\t */\n\tif (elf_ex->e_phentsize != sizeof(struct elf_phdr))\n\t\tgoto out;\n\n\t/* Sanity check the number of program headers... */\n\tif (elf_ex->e_phnum < 1 ||\n\t\telf_ex->e_phnum > 65536U / sizeof(struct elf_phdr))\n\t\tgoto out;\n\n\t/* ...and their total size. */\n\tsize = sizeof(struct elf_phdr) * elf_ex->e_phnum;\n\tif (size > ELF_MIN_ALIGN)\n\t\tgoto out;\n\n\telf_phdata = kmalloc(size, GFP_KERNEL);\n\tif (!elf_phdata)\n\t\tgoto out;\n\n\t/* Read in the program headers */\n\tretval = kernel_read(elf_file, elf_ex->e_phoff,\n\t\t\t     (char *)elf_phdata, size);\n\tif (retval != size) {\n\t\terr = (retval < 0) ? retval : -EIO;\n\t\tgoto out;\n\t}\n\n\t/* Success! */\n\terr = 0;\nout:\n\tif (err) {\n\t\tkfree(elf_phdata);\n\t\telf_phdata = NULL;\n\t}\n\treturn elf_phdata;\n}"
  },
  {
    "function_name": "total_mapping_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
    "lines": "371-387",
    "snippet": "static unsigned long total_mapping_size(struct elf_phdr *cmds, int nr)\n{\n\tint i, first_idx = -1, last_idx = -1;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tif (cmds[i].p_type == PT_LOAD) {\n\t\t\tlast_idx = i;\n\t\t\tif (first_idx == -1)\n\t\t\t\tfirst_idx = i;\n\t\t}\n\t}\n\tif (first_idx == -1)\n\t\treturn 0;\n\n\treturn cmds[last_idx].p_vaddr + cmds[last_idx].p_memsz -\n\t\t\t\tELF_PAGESTART(cmds[first_idx].p_vaddr);\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ELF_PAGESTART",
          "args": [
            "cmds[first_idx].p_vaddr"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);\n\nstatic unsigned long total_mapping_size(struct elf_phdr *cmds, int nr)\n{\n\tint i, first_idx = -1, last_idx = -1;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tif (cmds[i].p_type == PT_LOAD) {\n\t\t\tlast_idx = i;\n\t\t\tif (first_idx == -1)\n\t\t\t\tfirst_idx = i;\n\t\t}\n\t}\n\tif (first_idx == -1)\n\t\treturn 0;\n\n\treturn cmds[last_idx].p_vaddr + cmds[last_idx].p_memsz -\n\t\t\t\tELF_PAGESTART(cmds[first_idx].p_vaddr);\n}"
  },
  {
    "function_name": "elf_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
    "lines": "335-367",
    "snippet": "static unsigned long elf_map(struct file *filep, unsigned long addr,\n\t\tstruct elf_phdr *eppnt, int prot, int type,\n\t\tunsigned long total_size)\n{\n\tunsigned long map_addr;\n\tunsigned long size = eppnt->p_filesz + ELF_PAGEOFFSET(eppnt->p_vaddr);\n\tunsigned long off = eppnt->p_offset - ELF_PAGEOFFSET(eppnt->p_vaddr);\n\taddr = ELF_PAGESTART(addr);\n\tsize = ELF_PAGEALIGN(size);\n\n\t/* mmap() will return -EINVAL if given a zero size, but a\n\t * segment with zero filesize is perfectly valid */\n\tif (!size)\n\t\treturn addr;\n\n\t/*\n\t* total_size is the size of the ELF (interpreter) image.\n\t* The _first_ mmap needs to know the full size, otherwise\n\t* randomization might put this image into an overlapping\n\t* position with the ELF binary image. (since size < total_size)\n\t* So we first map the 'big' image - and unmap the remainder at\n\t* the end. (which unmap is needed for ELF images with holes.)\n\t*/\n\tif (total_size) {\n\t\ttotal_size = ELF_PAGEALIGN(total_size);\n\t\tmap_addr = vm_mmap(filep, addr, total_size, prot, type, off);\n\t\tif (!BAD_ADDR(map_addr))\n\t\t\tvm_munmap(map_addr+size, total_size-size);\n\t} else\n\t\tmap_addr = vm_mmap(filep, addr, size, prot, type, off);\n\n\treturn(map_addr);\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vm_mmap",
          "args": [
            "filep",
            "addr",
            "size",
            "prot",
            "type",
            "off"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_munmap",
          "args": [
            "map_addr+size",
            "total_size-size"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BAD_ADDR",
          "args": [
            "map_addr"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_mmap",
          "args": [
            "filep",
            "addr",
            "total_size",
            "prot",
            "type",
            "off"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF_PAGEALIGN",
          "args": [
            "total_size"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF_PAGEALIGN",
          "args": [
            "size"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF_PAGESTART",
          "args": [
            "addr"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF_PAGEOFFSET",
          "args": [
            "eppnt->p_vaddr"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF_PAGEOFFSET",
          "args": [
            "eppnt->p_vaddr"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);\n\nstatic unsigned long elf_map(struct file *filep, unsigned long addr,\n\t\tstruct elf_phdr *eppnt, int prot, int type,\n\t\tunsigned long total_size)\n{\n\tunsigned long map_addr;\n\tunsigned long size = eppnt->p_filesz + ELF_PAGEOFFSET(eppnt->p_vaddr);\n\tunsigned long off = eppnt->p_offset - ELF_PAGEOFFSET(eppnt->p_vaddr);\n\taddr = ELF_PAGESTART(addr);\n\tsize = ELF_PAGEALIGN(size);\n\n\t/* mmap() will return -EINVAL if given a zero size, but a\n\t * segment with zero filesize is perfectly valid */\n\tif (!size)\n\t\treturn addr;\n\n\t/*\n\t* total_size is the size of the ELF (interpreter) image.\n\t* The _first_ mmap needs to know the full size, otherwise\n\t* randomization might put this image into an overlapping\n\t* position with the ELF binary image. (since size < total_size)\n\t* So we first map the 'big' image - and unmap the remainder at\n\t* the end. (which unmap is needed for ELF images with holes.)\n\t*/\n\tif (total_size) {\n\t\ttotal_size = ELF_PAGEALIGN(total_size);\n\t\tmap_addr = vm_mmap(filep, addr, total_size, prot, type, off);\n\t\tif (!BAD_ADDR(map_addr))\n\t\t\tvm_munmap(map_addr+size, total_size-size);\n\t} else\n\t\tmap_addr = vm_mmap(filep, addr, size, prot, type, off);\n\n\treturn(map_addr);\n}"
  },
  {
    "function_name": "create_elf_tables",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
    "lines": "148-331",
    "snippet": "static int\ncreate_elf_tables(struct linux_binprm *bprm, struct elfhdr *exec,\n\t\tunsigned long load_addr, unsigned long interp_load_addr)\n{\n\tunsigned long p = bprm->p;\n\tint argc = bprm->argc;\n\tint envc = bprm->envc;\n\telf_addr_t __user *argv;\n\telf_addr_t __user *envp;\n\telf_addr_t __user *sp;\n\telf_addr_t __user *u_platform;\n\telf_addr_t __user *u_base_platform;\n\telf_addr_t __user *u_rand_bytes;\n\tconst char *k_platform = ELF_PLATFORM;\n\tconst char *k_base_platform = ELF_BASE_PLATFORM;\n\tunsigned char k_rand_bytes[16];\n\tint items;\n\telf_addr_t *elf_info;\n\tint ei_index = 0;\n\tconst struct cred *cred = current_cred();\n\tstruct vm_area_struct *vma;\n\n\t/*\n\t * In some cases (e.g. Hyper-Threading), we want to avoid L1\n\t * evictions by the processes running on the same package. One\n\t * thing we can do is to shuffle the initial stack for them.\n\t */\n\n\tp = arch_align_stack(p);\n\n\t/*\n\t * If this architecture has a platform capability string, copy it\n\t * to userspace.  In some cases (Sparc), this info is impossible\n\t * for userspace to get any other way, in others (i386) it is\n\t * merely difficult.\n\t */\n\tu_platform = NULL;\n\tif (k_platform) {\n\t\tsize_t len = strlen(k_platform) + 1;\n\n\t\tu_platform = (elf_addr_t __user *)STACK_ALLOC(p, len);\n\t\tif (__copy_to_user(u_platform, k_platform, len))\n\t\t\treturn -EFAULT;\n\t}\n\n\t/*\n\t * If this architecture has a \"base\" platform capability\n\t * string, copy it to userspace.\n\t */\n\tu_base_platform = NULL;\n\tif (k_base_platform) {\n\t\tsize_t len = strlen(k_base_platform) + 1;\n\n\t\tu_base_platform = (elf_addr_t __user *)STACK_ALLOC(p, len);\n\t\tif (__copy_to_user(u_base_platform, k_base_platform, len))\n\t\t\treturn -EFAULT;\n\t}\n\n\t/*\n\t * Generate 16 random bytes for userspace PRNG seeding.\n\t */\n\tget_random_bytes(k_rand_bytes, sizeof(k_rand_bytes));\n\tu_rand_bytes = (elf_addr_t __user *)\n\t\t       STACK_ALLOC(p, sizeof(k_rand_bytes));\n\tif (__copy_to_user(u_rand_bytes, k_rand_bytes, sizeof(k_rand_bytes)))\n\t\treturn -EFAULT;\n\n\t/* Create the ELF interpreter info */\n\telf_info = (elf_addr_t *)current->mm->saved_auxv;\n\t/* update AT_VECTOR_SIZE_BASE if the number of NEW_AUX_ENT() changes */\n#define NEW_AUX_ENT(id, val) \\\n\tdo { \\\n\t\telf_info[ei_index++] = id; \\\n\t\telf_info[ei_index++] = val; \\\n\t} while (0)\n\n#ifdef ARCH_DLINFO\n\t/* \n\t * ARCH_DLINFO must come first so PPC can do its special alignment of\n\t * AUXV.\n\t * update AT_VECTOR_SIZE_ARCH if the number of NEW_AUX_ENT() in\n\t * ARCH_DLINFO changes\n\t */\n\tARCH_DLINFO;\n#endif\n\tNEW_AUX_ENT(AT_HWCAP, ELF_HWCAP);\n\tNEW_AUX_ENT(AT_PAGESZ, ELF_EXEC_PAGESIZE);\n\tNEW_AUX_ENT(AT_CLKTCK, CLOCKS_PER_SEC);\n\tNEW_AUX_ENT(AT_PHDR, load_addr + exec->e_phoff);\n\tNEW_AUX_ENT(AT_PHENT, sizeof(struct elf_phdr));\n\tNEW_AUX_ENT(AT_PHNUM, exec->e_phnum);\n\tNEW_AUX_ENT(AT_BASE, interp_load_addr);\n\tNEW_AUX_ENT(AT_FLAGS, 0);\n\tNEW_AUX_ENT(AT_ENTRY, exec->e_entry);\n\tNEW_AUX_ENT(AT_UID, from_kuid_munged(cred->user_ns, cred->uid));\n\tNEW_AUX_ENT(AT_EUID, from_kuid_munged(cred->user_ns, cred->euid));\n\tNEW_AUX_ENT(AT_GID, from_kgid_munged(cred->user_ns, cred->gid));\n\tNEW_AUX_ENT(AT_EGID, from_kgid_munged(cred->user_ns, cred->egid));\n \tNEW_AUX_ENT(AT_SECURE, security_bprm_secureexec(bprm));\n\tNEW_AUX_ENT(AT_RANDOM, (elf_addr_t)(unsigned long)u_rand_bytes);\n#ifdef ELF_HWCAP2\n\tNEW_AUX_ENT(AT_HWCAP2, ELF_HWCAP2);\n#endif\n\tNEW_AUX_ENT(AT_EXECFN, bprm->exec);\n\tif (k_platform) {\n\t\tNEW_AUX_ENT(AT_PLATFORM,\n\t\t\t    (elf_addr_t)(unsigned long)u_platform);\n\t}\n\tif (k_base_platform) {\n\t\tNEW_AUX_ENT(AT_BASE_PLATFORM,\n\t\t\t    (elf_addr_t)(unsigned long)u_base_platform);\n\t}\n\tif (bprm->interp_flags & BINPRM_FLAGS_EXECFD) {\n\t\tNEW_AUX_ENT(AT_EXECFD, bprm->interp_data);\n\t}\n#undef NEW_AUX_ENT\n\t/* AT_NULL is zero; clear the rest too */\n\tmemset(&elf_info[ei_index], 0,\n\t       sizeof current->mm->saved_auxv - ei_index * sizeof elf_info[0]);\n\n\t/* And advance past the AT_NULL entry.  */\n\tei_index += 2;\n\n\tsp = STACK_ADD(p, ei_index);\n\n\titems = (argc + 1) + (envc + 1) + 1;\n\tbprm->p = STACK_ROUND(sp, items);\n\n\t/* Point sp at the lowest address on the stack */\n#ifdef CONFIG_STACK_GROWSUP\n\tsp = (elf_addr_t __user *)bprm->p - items - ei_index;\n\tbprm->exec = (unsigned long)sp; /* XXX: PARISC HACK */\n#else\n\tsp = (elf_addr_t __user *)bprm->p;\n#endif\n\n\n\t/*\n\t * Grow the stack manually; some architectures have a limit on how\n\t * far ahead a user-space access may be in order to grow the stack.\n\t */\n\tvma = find_extend_vma(current->mm, bprm->p);\n\tif (!vma)\n\t\treturn -EFAULT;\n\n\t/* Now, let's put argc (and argv, envp if appropriate) on the stack */\n\tif (__put_user(argc, sp++))\n\t\treturn -EFAULT;\n\targv = sp;\n\tenvp = argv + argc + 1;\n\n\t/* Populate argv and envp */\n\tp = current->mm->arg_end = current->mm->arg_start;\n\twhile (argc-- > 0) {\n\t\tsize_t len;\n\t\tif (__put_user((elf_addr_t)p, argv++))\n\t\t\treturn -EFAULT;\n\t\tlen = strnlen_user((void __user *)p, MAX_ARG_STRLEN);\n\t\tif (!len || len > MAX_ARG_STRLEN)\n\t\t\treturn -EINVAL;\n\t\tp += len;\n\t}\n\tif (__put_user(0, argv))\n\t\treturn -EFAULT;\n\tcurrent->mm->arg_end = current->mm->env_start = p;\n\twhile (envc-- > 0) {\n\t\tsize_t len;\n\t\tif (__put_user((elf_addr_t)p, envp++))\n\t\t\treturn -EFAULT;\n\t\tlen = strnlen_user((void __user *)p, MAX_ARG_STRLEN);\n\t\tif (!len || len > MAX_ARG_STRLEN)\n\t\t\treturn -EINVAL;\n\t\tp += len;\n\t}\n\tif (__put_user(0, envp))\n\t\treturn -EFAULT;\n\tcurrent->mm->env_end = p;\n\n\t/* Put the elf_info on the stack in the right place.  */\n\tsp = (elf_addr_t __user *)envp + 1;\n\tif (copy_to_user(sp, elf_info, ei_index * sizeof(elf_addr_t)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define ELF_BASE_PLATFORM NULL"
    ],
    "globals_used": [
      "static int load_elf_binary(struct linux_binprm *bprm);",
      "static unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "sp",
            "elf_info",
            "ei_index * sizeof(elf_addr_t)"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "0",
            "envp"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen_user",
          "args": [
            "(void __user *)p",
            "MAX_ARG_STRLEN"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "(elf_addr_t)p",
            "envp++"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "0",
            "argv"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen_user",
          "args": [
            "(void __user *)p",
            "MAX_ARG_STRLEN"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "(elf_addr_t)p",
            "argv++"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "argc",
            "sp++"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_extend_vma",
          "args": [
            "current->mm",
            "bprm->p"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STACK_ROUND",
          "args": [
            "sp",
            "items"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STACK_ADD",
          "args": [
            "p",
            "ei_index"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&elf_info[ei_index]",
            "0",
            "sizeof current->mm->saved_auxv - ei_index * sizeof elf_info[0]"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_EXECFD",
            "bprm->interp_data"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_BASE_PLATFORM",
            "(elf_addr_t)(unsigned long)u_base_platform"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_PLATFORM",
            "(elf_addr_t)(unsigned long)u_platform"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_EXECFN",
            "bprm->exec"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_HWCAP2",
            "ELF_HWCAP2"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_RANDOM",
            "(elf_addr_t)(unsigned long)u_rand_bytes"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_SECURE",
            "security_bprm_secureexec(bprm)"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_bprm_secureexec",
          "args": [
            "bprm"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_EGID",
            "from_kgid_munged(cred->user_ns, cred->egid)"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid_munged",
          "args": [
            "cred->user_ns",
            "cred->egid"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_GID",
            "from_kgid_munged(cred->user_ns, cred->gid)"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid_munged",
          "args": [
            "cred->user_ns",
            "cred->gid"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_EUID",
            "from_kuid_munged(cred->user_ns, cred->euid)"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "cred->user_ns",
            "cred->euid"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_UID",
            "from_kuid_munged(cred->user_ns, cred->uid)"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "cred->user_ns",
            "cred->uid"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_ENTRY",
            "exec->e_entry"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_FLAGS",
            "0"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_BASE",
            "interp_load_addr"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_PHNUM",
            "exec->e_phnum"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_PHENT",
            "sizeof(struct elf_phdr)"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_PHDR",
            "load_addr + exec->e_phoff"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_CLKTCK",
            "CLOCKS_PER_SEC"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_PAGESZ",
            "ELF_EXEC_PAGESIZE"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEW_AUX_ENT",
          "args": [
            "AT_HWCAP",
            "ELF_HWCAP"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "u_rand_bytes",
            "k_rand_bytes",
            "sizeof(k_rand_bytes)"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STACK_ALLOC",
          "args": [
            "p",
            "sizeof(k_rand_bytes)"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_random_bytes",
          "args": [
            "k_rand_bytes",
            "sizeof(k_rand_bytes)"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "u_base_platform",
            "k_base_platform",
            "len"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STACK_ALLOC",
          "args": [
            "p",
            "len"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "k_base_platform"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "u_platform",
            "k_platform",
            "len"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STACK_ALLOC",
          "args": [
            "p",
            "len"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_align_stack",
          "args": [
            "p"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define ELF_BASE_PLATFORM NULL\n\nstatic int load_elf_binary(struct linux_binprm *bprm);\nstatic unsigned long elf_map(struct file *, unsigned long, struct elf_phdr *,\n\t\t\t\tint, int, unsigned long);\n\nstatic int\ncreate_elf_tables(struct linux_binprm *bprm, struct elfhdr *exec,\n\t\tunsigned long load_addr, unsigned long interp_load_addr)\n{\n\tunsigned long p = bprm->p;\n\tint argc = bprm->argc;\n\tint envc = bprm->envc;\n\telf_addr_t __user *argv;\n\telf_addr_t __user *envp;\n\telf_addr_t __user *sp;\n\telf_addr_t __user *u_platform;\n\telf_addr_t __user *u_base_platform;\n\telf_addr_t __user *u_rand_bytes;\n\tconst char *k_platform = ELF_PLATFORM;\n\tconst char *k_base_platform = ELF_BASE_PLATFORM;\n\tunsigned char k_rand_bytes[16];\n\tint items;\n\telf_addr_t *elf_info;\n\tint ei_index = 0;\n\tconst struct cred *cred = current_cred();\n\tstruct vm_area_struct *vma;\n\n\t/*\n\t * In some cases (e.g. Hyper-Threading), we want to avoid L1\n\t * evictions by the processes running on the same package. One\n\t * thing we can do is to shuffle the initial stack for them.\n\t */\n\n\tp = arch_align_stack(p);\n\n\t/*\n\t * If this architecture has a platform capability string, copy it\n\t * to userspace.  In some cases (Sparc), this info is impossible\n\t * for userspace to get any other way, in others (i386) it is\n\t * merely difficult.\n\t */\n\tu_platform = NULL;\n\tif (k_platform) {\n\t\tsize_t len = strlen(k_platform) + 1;\n\n\t\tu_platform = (elf_addr_t __user *)STACK_ALLOC(p, len);\n\t\tif (__copy_to_user(u_platform, k_platform, len))\n\t\t\treturn -EFAULT;\n\t}\n\n\t/*\n\t * If this architecture has a \"base\" platform capability\n\t * string, copy it to userspace.\n\t */\n\tu_base_platform = NULL;\n\tif (k_base_platform) {\n\t\tsize_t len = strlen(k_base_platform) + 1;\n\n\t\tu_base_platform = (elf_addr_t __user *)STACK_ALLOC(p, len);\n\t\tif (__copy_to_user(u_base_platform, k_base_platform, len))\n\t\t\treturn -EFAULT;\n\t}\n\n\t/*\n\t * Generate 16 random bytes for userspace PRNG seeding.\n\t */\n\tget_random_bytes(k_rand_bytes, sizeof(k_rand_bytes));\n\tu_rand_bytes = (elf_addr_t __user *)\n\t\t       STACK_ALLOC(p, sizeof(k_rand_bytes));\n\tif (__copy_to_user(u_rand_bytes, k_rand_bytes, sizeof(k_rand_bytes)))\n\t\treturn -EFAULT;\n\n\t/* Create the ELF interpreter info */\n\telf_info = (elf_addr_t *)current->mm->saved_auxv;\n\t/* update AT_VECTOR_SIZE_BASE if the number of NEW_AUX_ENT() changes */\n#define NEW_AUX_ENT(id, val) \\\n\tdo { \\\n\t\telf_info[ei_index++] = id; \\\n\t\telf_info[ei_index++] = val; \\\n\t} while (0)\n\n#ifdef ARCH_DLINFO\n\t/* \n\t * ARCH_DLINFO must come first so PPC can do its special alignment of\n\t * AUXV.\n\t * update AT_VECTOR_SIZE_ARCH if the number of NEW_AUX_ENT() in\n\t * ARCH_DLINFO changes\n\t */\n\tARCH_DLINFO;\n#endif\n\tNEW_AUX_ENT(AT_HWCAP, ELF_HWCAP);\n\tNEW_AUX_ENT(AT_PAGESZ, ELF_EXEC_PAGESIZE);\n\tNEW_AUX_ENT(AT_CLKTCK, CLOCKS_PER_SEC);\n\tNEW_AUX_ENT(AT_PHDR, load_addr + exec->e_phoff);\n\tNEW_AUX_ENT(AT_PHENT, sizeof(struct elf_phdr));\n\tNEW_AUX_ENT(AT_PHNUM, exec->e_phnum);\n\tNEW_AUX_ENT(AT_BASE, interp_load_addr);\n\tNEW_AUX_ENT(AT_FLAGS, 0);\n\tNEW_AUX_ENT(AT_ENTRY, exec->e_entry);\n\tNEW_AUX_ENT(AT_UID, from_kuid_munged(cred->user_ns, cred->uid));\n\tNEW_AUX_ENT(AT_EUID, from_kuid_munged(cred->user_ns, cred->euid));\n\tNEW_AUX_ENT(AT_GID, from_kgid_munged(cred->user_ns, cred->gid));\n\tNEW_AUX_ENT(AT_EGID, from_kgid_munged(cred->user_ns, cred->egid));\n \tNEW_AUX_ENT(AT_SECURE, security_bprm_secureexec(bprm));\n\tNEW_AUX_ENT(AT_RANDOM, (elf_addr_t)(unsigned long)u_rand_bytes);\n#ifdef ELF_HWCAP2\n\tNEW_AUX_ENT(AT_HWCAP2, ELF_HWCAP2);\n#endif\n\tNEW_AUX_ENT(AT_EXECFN, bprm->exec);\n\tif (k_platform) {\n\t\tNEW_AUX_ENT(AT_PLATFORM,\n\t\t\t    (elf_addr_t)(unsigned long)u_platform);\n\t}\n\tif (k_base_platform) {\n\t\tNEW_AUX_ENT(AT_BASE_PLATFORM,\n\t\t\t    (elf_addr_t)(unsigned long)u_base_platform);\n\t}\n\tif (bprm->interp_flags & BINPRM_FLAGS_EXECFD) {\n\t\tNEW_AUX_ENT(AT_EXECFD, bprm->interp_data);\n\t}\n#undef NEW_AUX_ENT\n\t/* AT_NULL is zero; clear the rest too */\n\tmemset(&elf_info[ei_index], 0,\n\t       sizeof current->mm->saved_auxv - ei_index * sizeof elf_info[0]);\n\n\t/* And advance past the AT_NULL entry.  */\n\tei_index += 2;\n\n\tsp = STACK_ADD(p, ei_index);\n\n\titems = (argc + 1) + (envc + 1) + 1;\n\tbprm->p = STACK_ROUND(sp, items);\n\n\t/* Point sp at the lowest address on the stack */\n#ifdef CONFIG_STACK_GROWSUP\n\tsp = (elf_addr_t __user *)bprm->p - items - ei_index;\n\tbprm->exec = (unsigned long)sp; /* XXX: PARISC HACK */\n#else\n\tsp = (elf_addr_t __user *)bprm->p;\n#endif\n\n\n\t/*\n\t * Grow the stack manually; some architectures have a limit on how\n\t * far ahead a user-space access may be in order to grow the stack.\n\t */\n\tvma = find_extend_vma(current->mm, bprm->p);\n\tif (!vma)\n\t\treturn -EFAULT;\n\n\t/* Now, let's put argc (and argv, envp if appropriate) on the stack */\n\tif (__put_user(argc, sp++))\n\t\treturn -EFAULT;\n\targv = sp;\n\tenvp = argv + argc + 1;\n\n\t/* Populate argv and envp */\n\tp = current->mm->arg_end = current->mm->arg_start;\n\twhile (argc-- > 0) {\n\t\tsize_t len;\n\t\tif (__put_user((elf_addr_t)p, argv++))\n\t\t\treturn -EFAULT;\n\t\tlen = strnlen_user((void __user *)p, MAX_ARG_STRLEN);\n\t\tif (!len || len > MAX_ARG_STRLEN)\n\t\t\treturn -EINVAL;\n\t\tp += len;\n\t}\n\tif (__put_user(0, argv))\n\t\treturn -EFAULT;\n\tcurrent->mm->arg_end = current->mm->env_start = p;\n\twhile (envc-- > 0) {\n\t\tsize_t len;\n\t\tif (__put_user((elf_addr_t)p, envp++))\n\t\t\treturn -EFAULT;\n\t\tlen = strnlen_user((void __user *)p, MAX_ARG_STRLEN);\n\t\tif (!len || len > MAX_ARG_STRLEN)\n\t\t\treturn -EINVAL;\n\t\tp += len;\n\t}\n\tif (__put_user(0, envp))\n\t\treturn -EFAULT;\n\tcurrent->mm->env_end = p;\n\n\t/* Put the elf_info on the stack in the right place.  */\n\tsp = (elf_addr_t __user *)envp + 1;\n\tif (copy_to_user(sp, elf_info, ei_index * sizeof(elf_addr_t)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
  },
  {
    "function_name": "padzero",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
    "lines": "111-122",
    "snippet": "static int padzero(unsigned long elf_bss)\n{\n\tunsigned long nbyte;\n\n\tnbyte = ELF_PAGEOFFSET(elf_bss);\n\tif (nbyte) {\n\t\tnbyte = ELF_MIN_ALIGN - nbyte;\n\t\tif (clear_user((void __user *) elf_bss, nbyte))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define ELF_MIN_ALIGN\tPAGE_SIZE",
      "#define ELF_MIN_ALIGN\tELF_EXEC_PAGESIZE"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_user",
          "args": [
            "(void __user *) elf_bss",
            "nbyte"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF_PAGEOFFSET",
          "args": [
            "elf_bss"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#define ELF_MIN_ALIGN\tPAGE_SIZE\n#define ELF_MIN_ALIGN\tELF_EXEC_PAGESIZE\n\nstatic int padzero(unsigned long elf_bss)\n{\n\tunsigned long nbyte;\n\n\tnbyte = ELF_PAGEOFFSET(elf_bss);\n\tif (nbyte) {\n\t\tnbyte = ELF_MIN_ALIGN - nbyte;\n\t\tif (clear_user((void __user *) elf_bss, nbyte))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "set_brk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_elf.c",
    "lines": "92-104",
    "snippet": "static int set_brk(unsigned long start, unsigned long end)\n{\n\tstart = ELF_PAGEALIGN(start);\n\tend = ELF_PAGEALIGN(end);\n\tif (end > start) {\n\t\tunsigned long addr;\n\t\taddr = vm_brk(start, end - start);\n\t\tif (BAD_ADDR(addr))\n\t\t\treturn addr;\n\t}\n\tcurrent->mm->start_brk = current->mm->brk = end;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/regset.h>",
      "#include <asm/page.h>",
      "#include <asm/param.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/sched.h>",
      "#include <linux/coredump.h>",
      "#include <linux/utsname.h>",
      "#include <linux/elf.h>",
      "#include <linux/random.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/compiler.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/elfcore.h>",
      "#include <linux/personality.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <linux/string.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/kernel.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BAD_ADDR",
          "args": [
            "addr"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_brk",
          "args": [
            "start",
            "end - start"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF_PAGEALIGN",
          "args": [
            "end"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF_PAGEALIGN",
          "args": [
            "start"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/regset.h>\n#include <asm/page.h>\n#include <asm/param.h>\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/coredump.h>\n#include <linux/utsname.h>\n#include <linux/elf.h>\n#include <linux/random.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/compiler.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/elfcore.h>\n#include <linux/personality.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/string.h>\n#include <linux/binfmts.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int set_brk(unsigned long start, unsigned long end)\n{\n\tstart = ELF_PAGEALIGN(start);\n\tend = ELF_PAGEALIGN(end);\n\tif (end > start) {\n\t\tunsigned long addr;\n\t\taddr = vm_brk(start, end - start);\n\t\tif (BAD_ADDR(addr))\n\t\t\treturn addr;\n\t}\n\tcurrent->mm->start_brk = current->mm->brk = end;\n\treturn 0;\n}"
  }
]