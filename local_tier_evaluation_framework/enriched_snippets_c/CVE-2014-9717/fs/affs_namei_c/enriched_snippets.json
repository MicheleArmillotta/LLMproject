[
  {
    "function_name": "affs_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/namei.c",
    "lines": "412-460",
    "snippet": "int\naffs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t    struct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct super_block *sb = old_dir->i_sb;\n\tstruct buffer_head *bh = NULL;\n\tint retval;\n\n\tpr_debug(\"%s(old=%lu,\\\"%pd\\\" to new=%lu,\\\"%pd\\\")\\n\", __func__,\n\t\t old_dir->i_ino, old_dentry, new_dir->i_ino, new_dentry);\n\n\tretval = affs_check_name(new_dentry->d_name.name,\n\t\t\t\t new_dentry->d_name.len,\n\t\t\t\t affs_nofilenametruncate(old_dentry));\n\n\tif (retval)\n\t\treturn retval;\n\n\t/* Unlink destination if it already exists */\n\tif (new_dentry->d_inode) {\n\t\tretval = affs_remove_header(new_dentry);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\tbh = affs_bread(sb, old_dentry->d_inode->i_ino);\n\tif (!bh)\n\t\treturn -EIO;\n\n\t/* Remove header from its parent directory. */\n\taffs_lock_dir(old_dir);\n\tretval = affs_remove_hash(old_dir, bh);\n\taffs_unlock_dir(old_dir);\n\tif (retval)\n\t\tgoto done;\n\n\t/* And insert it into the new directory with the new name. */\n\taffs_copy_name(AFFS_TAIL(sb, bh)->name, new_dentry);\n\taffs_fix_checksum(sb, bh);\n\taffs_lock_dir(new_dir);\n\tretval = affs_insert_hash(new_dir, bh);\n\taffs_unlock_dir(new_dir);\n\t/* TODO: move it back to old_dir, if error? */\n\ndone:\n\tmark_buffer_dirty_inode(bh, retval ? old_dir : new_dir);\n\taffs_brelse(bh);\n\treturn retval;\n}",
    "includes": [
      "#include \"affs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int       affs_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);",
      "static int       affs_intl_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "affs_brelse",
          "args": [
            "bh"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "affs_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "260-266",
          "snippet": "static inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);",
            "extern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);",
            "extern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);",
            "extern u32\taffs_count_free_blocks(struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);\nextern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);\nextern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);\nextern u32\taffs_count_free_blocks(struct super_block *s);\n\nstatic inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty_inode",
          "args": [
            "bh",
            "retval ? old_dir : new_dir"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "599-617",
          "snippet": "void mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_unlock_dir",
          "args": [
            "new_dir"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "affs_unlock_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "296-300",
          "snippet": "static inline void\naffs_unlock_dir(struct inode *inode)\n{\n\tup(&AFFS_I(inode)->i_hash_lock);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define i_hash_lock i_ext_lock"
          ],
          "globals_used": [
            "extern void\tmode_to_prot(struct inode *inode);",
            "extern void\t\t\t affs_evict_inode(struct inode *inode);",
            "void\t\taffs_free_prealloc(struct inode *inode);",
            "extern void\taffs_truncate(struct inode *);",
            "extern void   affs_dir_truncate(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\n#define i_hash_lock i_ext_lock\n\nextern void\tmode_to_prot(struct inode *inode);\nextern void\t\t\t affs_evict_inode(struct inode *inode);\nvoid\t\taffs_free_prealloc(struct inode *inode);\nextern void\taffs_truncate(struct inode *);\nextern void   affs_dir_truncate(struct inode *);\n\nstatic inline void\naffs_unlock_dir(struct inode *inode)\n{\n\tup(&AFFS_I(inode)->i_hash_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_insert_hash",
          "args": [
            "new_dir",
            "bh"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "affs_insert_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "22-65",
          "snippet": "int\naffs_insert_hash(struct inode *dir, struct buffer_head *bh)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct buffer_head *dir_bh;\n\tu32 ino, hash_ino;\n\tint offset;\n\n\tino = bh->b_blocknr;\n\toffset = affs_hash_name(sb, AFFS_TAIL(sb, bh)->name + 1, AFFS_TAIL(sb, bh)->name[0]);\n\n\tpr_debug(\"%s(dir=%lu, ino=%d)\\n\", __func__, dir->i_ino, ino);\n\n\tdir_bh = affs_bread(sb, dir->i_ino);\n\tif (!dir_bh)\n\t\treturn -EIO;\n\n\thash_ino = be32_to_cpu(AFFS_HEAD(dir_bh)->table[offset]);\n\twhile (hash_ino) {\n\t\taffs_brelse(dir_bh);\n\t\tdir_bh = affs_bread(sb, hash_ino);\n\t\tif (!dir_bh)\n\t\t\treturn -EIO;\n\t\thash_ino = be32_to_cpu(AFFS_TAIL(sb, dir_bh)->hash_chain);\n\t}\n\tAFFS_TAIL(sb, bh)->parent = cpu_to_be32(dir->i_ino);\n\tAFFS_TAIL(sb, bh)->hash_chain = 0;\n\taffs_fix_checksum(sb, bh);\n\n\tif (dir->i_ino == dir_bh->b_blocknr)\n\t\tAFFS_HEAD(dir_bh)->table[offset] = cpu_to_be32(ino);\n\telse\n\t\tAFFS_TAIL(sb, dir_bh)->hash_chain = cpu_to_be32(ino);\n\n\taffs_adjust_checksum(dir_bh, ino);\n\tmark_buffer_dirty_inode(dir_bh, dir);\n\taffs_brelse(dir_bh);\n\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tdir->i_version++;\n\tmark_inode_dirty(dir);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nint\naffs_insert_hash(struct inode *dir, struct buffer_head *bh)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct buffer_head *dir_bh;\n\tu32 ino, hash_ino;\n\tint offset;\n\n\tino = bh->b_blocknr;\n\toffset = affs_hash_name(sb, AFFS_TAIL(sb, bh)->name + 1, AFFS_TAIL(sb, bh)->name[0]);\n\n\tpr_debug(\"%s(dir=%lu, ino=%d)\\n\", __func__, dir->i_ino, ino);\n\n\tdir_bh = affs_bread(sb, dir->i_ino);\n\tif (!dir_bh)\n\t\treturn -EIO;\n\n\thash_ino = be32_to_cpu(AFFS_HEAD(dir_bh)->table[offset]);\n\twhile (hash_ino) {\n\t\taffs_brelse(dir_bh);\n\t\tdir_bh = affs_bread(sb, hash_ino);\n\t\tif (!dir_bh)\n\t\t\treturn -EIO;\n\t\thash_ino = be32_to_cpu(AFFS_TAIL(sb, dir_bh)->hash_chain);\n\t}\n\tAFFS_TAIL(sb, bh)->parent = cpu_to_be32(dir->i_ino);\n\tAFFS_TAIL(sb, bh)->hash_chain = 0;\n\taffs_fix_checksum(sb, bh);\n\n\tif (dir->i_ino == dir_bh->b_blocknr)\n\t\tAFFS_HEAD(dir_bh)->table[offset] = cpu_to_be32(ino);\n\telse\n\t\tAFFS_TAIL(sb, dir_bh)->hash_chain = cpu_to_be32(ino);\n\n\taffs_adjust_checksum(dir_bh, ino);\n\tmark_buffer_dirty_inode(dir_bh, dir);\n\taffs_brelse(dir_bh);\n\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tdir->i_version++;\n\tmark_inode_dirty(dir);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_lock_dir",
          "args": [
            "new_dir"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "affs_lock_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "291-295",
          "snippet": "static inline void\naffs_lock_dir(struct inode *inode)\n{\n\tdown(&AFFS_I(inode)->i_hash_lock);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define i_hash_lock i_ext_lock"
          ],
          "globals_used": [
            "extern void\tmode_to_prot(struct inode *inode);",
            "extern void\t\t\t affs_evict_inode(struct inode *inode);",
            "void\t\taffs_free_prealloc(struct inode *inode);",
            "extern void\taffs_truncate(struct inode *);",
            "extern void   affs_dir_truncate(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\n#define i_hash_lock i_ext_lock\n\nextern void\tmode_to_prot(struct inode *inode);\nextern void\t\t\t affs_evict_inode(struct inode *inode);\nvoid\t\taffs_free_prealloc(struct inode *inode);\nextern void\taffs_truncate(struct inode *);\nextern void   affs_dir_truncate(struct inode *);\n\nstatic inline void\naffs_lock_dir(struct inode *inode)\n{\n\tdown(&AFFS_I(inode)->i_hash_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_fix_checksum",
          "args": [
            "sb",
            "bh"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "affs_fix_checksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "353-366",
          "snippet": "void\naffs_fix_checksum(struct super_block *sb, struct buffer_head *bh)\n{\n\tint cnt = sb->s_blocksize / sizeof(__be32);\n\t__be32 *ptr = (__be32 *)bh->b_data;\n\tu32 checksum;\n\t__be32 *checksumptr;\n\n\tchecksumptr = ptr + 5;\n\t*checksumptr = 0;\n\tfor (checksum = 0; cnt > 0; ptr++, cnt--)\n\t\tchecksum += be32_to_cpu(*ptr);\n\t*checksumptr = cpu_to_be32(-checksum);\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nvoid\naffs_fix_checksum(struct super_block *sb, struct buffer_head *bh)\n{\n\tint cnt = sb->s_blocksize / sizeof(__be32);\n\t__be32 *ptr = (__be32 *)bh->b_data;\n\tu32 checksum;\n\t__be32 *checksumptr;\n\n\tchecksumptr = ptr + 5;\n\t*checksumptr = 0;\n\tfor (checksum = 0; cnt > 0; ptr++, cnt--)\n\t\tchecksum += be32_to_cpu(*ptr);\n\t*checksumptr = cpu_to_be32(-checksum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_copy_name",
          "args": [
            "AFFS_TAIL(sb, bh)->name",
            "new_dentry"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "affs_copy_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "507-515",
          "snippet": "int\naffs_copy_name(unsigned char *bstr, struct dentry *dentry)\n{\n\tu32 len = min(dentry->d_name.len, AFFSNAMEMAX);\n\n\t*bstr++ = len;\n\tmemcpy(bstr, dentry->d_name.name, len);\n\treturn len;\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nint\naffs_copy_name(unsigned char *bstr, struct dentry *dentry)\n{\n\tu32 len = min(dentry->d_name.len, AFFSNAMEMAX);\n\n\t*bstr++ = len;\n\tmemcpy(bstr, dentry->d_name.name, len);\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFFS_TAIL",
          "args": [
            "sb",
            "bh"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_remove_hash",
          "args": [
            "old_dir",
            "bh"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "affs_remove_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "71-119",
          "snippet": "int\naffs_remove_hash(struct inode *dir, struct buffer_head *rem_bh)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bh;\n\tu32 rem_ino, hash_ino;\n\t__be32 ino;\n\tint offset, retval;\n\n\tsb = dir->i_sb;\n\trem_ino = rem_bh->b_blocknr;\n\toffset = affs_hash_name(sb, AFFS_TAIL(sb, rem_bh)->name+1, AFFS_TAIL(sb, rem_bh)->name[0]);\n\tpr_debug(\"%s(dir=%lu, ino=%d, hashval=%d)\\n\", __func__, dir->i_ino,\n\t\t rem_ino, offset);\n\n\tbh = affs_bread(sb, dir->i_ino);\n\tif (!bh)\n\t\treturn -EIO;\n\n\tretval = -ENOENT;\n\thash_ino = be32_to_cpu(AFFS_HEAD(bh)->table[offset]);\n\twhile (hash_ino) {\n\t\tif (hash_ino == rem_ino) {\n\t\t\tino = AFFS_TAIL(sb, rem_bh)->hash_chain;\n\t\t\tif (dir->i_ino == bh->b_blocknr)\n\t\t\t\tAFFS_HEAD(bh)->table[offset] = ino;\n\t\t\telse\n\t\t\t\tAFFS_TAIL(sb, bh)->hash_chain = ino;\n\t\t\taffs_adjust_checksum(bh, be32_to_cpu(ino) - hash_ino);\n\t\t\tmark_buffer_dirty_inode(bh, dir);\n\t\t\tAFFS_TAIL(sb, rem_bh)->parent = 0;\n\t\t\tretval = 0;\n\t\t\tbreak;\n\t\t}\n\t\taffs_brelse(bh);\n\t\tbh = affs_bread(sb, hash_ino);\n\t\tif (!bh)\n\t\t\treturn -EIO;\n\t\thash_ino = be32_to_cpu(AFFS_TAIL(sb, bh)->hash_chain);\n\t}\n\n\taffs_brelse(bh);\n\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tdir->i_version++;\n\tmark_inode_dirty(dir);\n\n\treturn retval;\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nint\naffs_remove_hash(struct inode *dir, struct buffer_head *rem_bh)\n{\n\tstruct super_block *sb;\n\tstruct buffer_head *bh;\n\tu32 rem_ino, hash_ino;\n\t__be32 ino;\n\tint offset, retval;\n\n\tsb = dir->i_sb;\n\trem_ino = rem_bh->b_blocknr;\n\toffset = affs_hash_name(sb, AFFS_TAIL(sb, rem_bh)->name+1, AFFS_TAIL(sb, rem_bh)->name[0]);\n\tpr_debug(\"%s(dir=%lu, ino=%d, hashval=%d)\\n\", __func__, dir->i_ino,\n\t\t rem_ino, offset);\n\n\tbh = affs_bread(sb, dir->i_ino);\n\tif (!bh)\n\t\treturn -EIO;\n\n\tretval = -ENOENT;\n\thash_ino = be32_to_cpu(AFFS_HEAD(bh)->table[offset]);\n\twhile (hash_ino) {\n\t\tif (hash_ino == rem_ino) {\n\t\t\tino = AFFS_TAIL(sb, rem_bh)->hash_chain;\n\t\t\tif (dir->i_ino == bh->b_blocknr)\n\t\t\t\tAFFS_HEAD(bh)->table[offset] = ino;\n\t\t\telse\n\t\t\t\tAFFS_TAIL(sb, bh)->hash_chain = ino;\n\t\t\taffs_adjust_checksum(bh, be32_to_cpu(ino) - hash_ino);\n\t\t\tmark_buffer_dirty_inode(bh, dir);\n\t\t\tAFFS_TAIL(sb, rem_bh)->parent = 0;\n\t\t\tretval = 0;\n\t\t\tbreak;\n\t\t}\n\t\taffs_brelse(bh);\n\t\tbh = affs_bread(sb, hash_ino);\n\t\tif (!bh)\n\t\t\treturn -EIO;\n\t\thash_ino = be32_to_cpu(AFFS_TAIL(sb, bh)->hash_chain);\n\t}\n\n\taffs_brelse(bh);\n\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME_SEC;\n\tdir->i_version++;\n\tmark_inode_dirty(dir);\n\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_bread",
          "args": [
            "sb",
            "old_dentry->d_inode->i_ino"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "affs_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "216-223",
          "snippet": "static inline struct buffer_head *\naffs_bread(struct super_block *sb, int block)\n{\n\tpr_debug(\"%s: %d\\n\", __func__, block);\n\tif (block >= AFFS_SB(sb)->s_reserved && block < AFFS_SB(sb)->s_partition_size)\n\t\treturn sb_bread(sb, block);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void affs_mark_sb_dirty(struct super_block *sb);",
            "extern u32\taffs_count_free_blocks(struct super_block *s);",
            "extern void\taffs_free_block(struct super_block *sb, u32 block);",
            "extern void\taffs_free_bitmap(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb);\nextern u32\taffs_count_free_blocks(struct super_block *s);\nextern void\taffs_free_block(struct super_block *sb, u32 block);\nextern void\taffs_free_bitmap(struct super_block *sb);\n\nstatic inline struct buffer_head *\naffs_bread(struct super_block *sb, int block)\n{\n\tpr_debug(\"%s: %d\\n\", __func__, block);\n\tif (block >= AFFS_SB(sb)->s_reserved && block < AFFS_SB(sb)->s_partition_size)\n\t\treturn sb_bread(sb, block);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_remove_header",
          "args": [
            "new_dentry"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "affs_remove_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "263-326",
          "snippet": "int\naffs_remove_header(struct dentry *dentry)\n{\n\tstruct super_block *sb;\n\tstruct inode *inode, *dir;\n\tstruct buffer_head *bh = NULL;\n\tint retval;\n\n\tdir = dentry->d_parent->d_inode;\n\tsb = dir->i_sb;\n\n\tretval = -ENOENT;\n\tinode = dentry->d_inode;\n\tif (!inode)\n\t\tgoto done;\n\n\tpr_debug(\"%s(key=%ld)\\n\", __func__, inode->i_ino);\n\tretval = -EIO;\n\tbh = affs_bread(sb, (u32)(long)dentry->d_fsdata);\n\tif (!bh)\n\t\tgoto done;\n\n\taffs_lock_link(inode);\n\taffs_lock_dir(dir);\n\tswitch (be32_to_cpu(AFFS_TAIL(sb, bh)->stype)) {\n\tcase ST_USERDIR:\n\t\t/* if we ever want to support links to dirs\n\t\t * i_hash_lock of the inode must only be\n\t\t * taken after some checks\n\t\t */\n\t\taffs_lock_dir(inode);\n\t\tretval = affs_empty_dir(inode);\n\t\taffs_unlock_dir(inode);\n\t\tif (retval)\n\t\t\tgoto done_unlock;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tretval = affs_remove_hash(dir, bh);\n\tif (retval)\n\t\tgoto done_unlock;\n\tmark_buffer_dirty_inode(bh, inode);\n\n\taffs_unlock_dir(dir);\n\n\tif (inode->i_nlink > 1)\n\t\tretval = affs_remove_link(dentry);\n\telse\n\t\tclear_nlink(inode);\n\taffs_unlock_link(inode);\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\n\ndone:\n\taffs_brelse(bh);\n\treturn retval;\n\ndone_unlock:\n\taffs_unlock_dir(dir);\n\taffs_unlock_link(inode);\n\tgoto done;\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nint\naffs_remove_header(struct dentry *dentry)\n{\n\tstruct super_block *sb;\n\tstruct inode *inode, *dir;\n\tstruct buffer_head *bh = NULL;\n\tint retval;\n\n\tdir = dentry->d_parent->d_inode;\n\tsb = dir->i_sb;\n\n\tretval = -ENOENT;\n\tinode = dentry->d_inode;\n\tif (!inode)\n\t\tgoto done;\n\n\tpr_debug(\"%s(key=%ld)\\n\", __func__, inode->i_ino);\n\tretval = -EIO;\n\tbh = affs_bread(sb, (u32)(long)dentry->d_fsdata);\n\tif (!bh)\n\t\tgoto done;\n\n\taffs_lock_link(inode);\n\taffs_lock_dir(dir);\n\tswitch (be32_to_cpu(AFFS_TAIL(sb, bh)->stype)) {\n\tcase ST_USERDIR:\n\t\t/* if we ever want to support links to dirs\n\t\t * i_hash_lock of the inode must only be\n\t\t * taken after some checks\n\t\t */\n\t\taffs_lock_dir(inode);\n\t\tretval = affs_empty_dir(inode);\n\t\taffs_unlock_dir(inode);\n\t\tif (retval)\n\t\t\tgoto done_unlock;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tretval = affs_remove_hash(dir, bh);\n\tif (retval)\n\t\tgoto done_unlock;\n\tmark_buffer_dirty_inode(bh, inode);\n\n\taffs_unlock_dir(dir);\n\n\tif (inode->i_nlink > 1)\n\t\tretval = affs_remove_link(dentry);\n\telse\n\t\tclear_nlink(inode);\n\taffs_unlock_link(inode);\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\n\ndone:\n\taffs_brelse(bh);\n\treturn retval;\n\ndone_unlock:\n\taffs_unlock_dir(dir);\n\taffs_unlock_link(inode);\n\tgoto done;\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_check_name",
          "args": [
            "new_dentry->d_name.name",
            "new_dentry->d_name.len",
            "affs_nofilenametruncate(old_dentry)"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "affs_check_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "481-498",
          "snippet": "int\naffs_check_name(const unsigned char *name, int len, bool notruncate)\n{\n\tint\t i;\n\n\tif (len > AFFSNAMEMAX) {\n\t\tif (notruncate)\n\t\t\treturn -ENAMETOOLONG;\n\t\tlen = AFFSNAMEMAX;\n\t}\n\tfor (i = 0; i < len; i++) {\n\t\tif (name[i] < ' ' || name[i] == ':'\n\t\t    || (name[i] > 0x7e && name[i] < 0xa0))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nint\naffs_check_name(const unsigned char *name, int len, bool notruncate)\n{\n\tint\t i;\n\n\tif (len > AFFSNAMEMAX) {\n\t\tif (notruncate)\n\t\t\treturn -ENAMETOOLONG;\n\t\tlen = AFFSNAMEMAX;\n\t}\n\tfor (i = 0; i < len; i++) {\n\t\tif (name[i] < ' ' || name[i] == ':'\n\t\t    || (name[i] > 0x7e && name[i] < 0xa0))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_nofilenametruncate",
          "args": [
            "old_dentry"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "affs_nofilenametruncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "471-477",
          "snippet": "bool\naffs_nofilenametruncate(const struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\treturn AFFS_SB(inode->i_sb)->s_flags & SF_NO_TRUNCATE;\n\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nbool\naffs_nofilenametruncate(const struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\treturn AFFS_SB(inode->i_sb)->s_flags & SF_NO_TRUNCATE;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s(old=%lu,\\\"%pd\\\" to new=%lu,\\\"%pd\\\")\\n\"",
            "__func__",
            "old_dir->i_ino",
            "old_dentry",
            "new_dir->i_ino",
            "new_dentry"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n\nstatic int       affs_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\nstatic int       affs_intl_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\n\nint\naffs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t    struct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct super_block *sb = old_dir->i_sb;\n\tstruct buffer_head *bh = NULL;\n\tint retval;\n\n\tpr_debug(\"%s(old=%lu,\\\"%pd\\\" to new=%lu,\\\"%pd\\\")\\n\", __func__,\n\t\t old_dir->i_ino, old_dentry, new_dir->i_ino, new_dentry);\n\n\tretval = affs_check_name(new_dentry->d_name.name,\n\t\t\t\t new_dentry->d_name.len,\n\t\t\t\t affs_nofilenametruncate(old_dentry));\n\n\tif (retval)\n\t\treturn retval;\n\n\t/* Unlink destination if it already exists */\n\tif (new_dentry->d_inode) {\n\t\tretval = affs_remove_header(new_dentry);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\tbh = affs_bread(sb, old_dentry->d_inode->i_ino);\n\tif (!bh)\n\t\treturn -EIO;\n\n\t/* Remove header from its parent directory. */\n\taffs_lock_dir(old_dir);\n\tretval = affs_remove_hash(old_dir, bh);\n\taffs_unlock_dir(old_dir);\n\tif (retval)\n\t\tgoto done;\n\n\t/* And insert it into the new directory with the new name. */\n\taffs_copy_name(AFFS_TAIL(sb, bh)->name, new_dentry);\n\taffs_fix_checksum(sb, bh);\n\taffs_lock_dir(new_dir);\n\tretval = affs_insert_hash(new_dir, bh);\n\taffs_unlock_dir(new_dir);\n\t/* TODO: move it back to old_dir, if error? */\n\ndone:\n\tmark_buffer_dirty_inode(bh, retval ? old_dir : new_dir);\n\taffs_brelse(bh);\n\treturn retval;\n}"
  },
  {
    "function_name": "affs_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/namei.c",
    "lines": "401-410",
    "snippet": "int\naffs_link(struct dentry *old_dentry, struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = old_dentry->d_inode;\n\n\tpr_debug(\"%s(%lu, %lu, \\\"%pd\\\")\\n\", __func__, inode->i_ino, dir->i_ino,\n\t\t dentry);\n\n\treturn affs_add_entry(dir, inode, dentry, ST_LINKFILE);\n}",
    "includes": [
      "#include \"affs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "affs_add_entry",
          "args": [
            "dir",
            "inode",
            "dentry",
            "ST_LINKFILE"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "affs_add_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/inode.c",
          "lines": "340-412",
          "snippet": "int\naffs_add_entry(struct inode *dir, struct inode *inode, struct dentry *dentry, s32 type)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct buffer_head *inode_bh = NULL;\n\tstruct buffer_head *bh = NULL;\n\tu32 block = 0;\n\tint retval;\n\n\tpr_debug(\"%s(dir=%lu, inode=%lu, \\\"%pd\\\", type=%d)\\n\", __func__,\n\t\t dir->i_ino, inode->i_ino, dentry, type);\n\n\tretval = -EIO;\n\tbh = affs_bread(sb, inode->i_ino);\n\tif (!bh)\n\t\tgoto done;\n\n\taffs_lock_link(inode);\n\tswitch (type) {\n\tcase ST_LINKFILE:\n\tcase ST_LINKDIR:\n\t\tretval = -ENOSPC;\n\t\tblock = affs_alloc_block(dir, dir->i_ino);\n\t\tif (!block)\n\t\t\tgoto err;\n\t\tretval = -EIO;\n\t\tinode_bh = bh;\n\t\tbh = affs_getzeroblk(sb, block);\n\t\tif (!bh)\n\t\t\tgoto err;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tAFFS_HEAD(bh)->ptype = cpu_to_be32(T_SHORT);\n\tAFFS_HEAD(bh)->key = cpu_to_be32(bh->b_blocknr);\n\taffs_copy_name(AFFS_TAIL(sb, bh)->name, dentry);\n\tAFFS_TAIL(sb, bh)->stype = cpu_to_be32(type);\n\tAFFS_TAIL(sb, bh)->parent = cpu_to_be32(dir->i_ino);\n\n\tif (inode_bh) {\n\t\t__be32 chain;\n\t       \tchain = AFFS_TAIL(sb, inode_bh)->link_chain;\n\t\tAFFS_TAIL(sb, bh)->original = cpu_to_be32(inode->i_ino);\n\t\tAFFS_TAIL(sb, bh)->link_chain = chain;\n\t\tAFFS_TAIL(sb, inode_bh)->link_chain = cpu_to_be32(block);\n\t\taffs_adjust_checksum(inode_bh, block - be32_to_cpu(chain));\n\t\tmark_buffer_dirty_inode(inode_bh, inode);\n\t\tset_nlink(inode, 2);\n\t\tihold(inode);\n\t}\n\taffs_fix_checksum(sb, bh);\n\tmark_buffer_dirty_inode(bh, inode);\n\tdentry->d_fsdata = (void *)(long)bh->b_blocknr;\n\n\taffs_lock_dir(dir);\n\tretval = affs_insert_hash(dir, bh);\n\tmark_buffer_dirty_inode(bh, inode);\n\taffs_unlock_dir(dir);\n\taffs_unlock_link(inode);\n\n\td_instantiate(dentry, inode);\ndone:\n\taffs_brelse(inode_bh);\n\taffs_brelse(bh);\n\treturn retval;\nerr:\n\tif (block)\n\t\taffs_free_block(sb, block);\n\taffs_unlock_link(inode);\n\tgoto done;\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/gfp.h>\n#include <linux/sched.h>\n\nint\naffs_add_entry(struct inode *dir, struct inode *inode, struct dentry *dentry, s32 type)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct buffer_head *inode_bh = NULL;\n\tstruct buffer_head *bh = NULL;\n\tu32 block = 0;\n\tint retval;\n\n\tpr_debug(\"%s(dir=%lu, inode=%lu, \\\"%pd\\\", type=%d)\\n\", __func__,\n\t\t dir->i_ino, inode->i_ino, dentry, type);\n\n\tretval = -EIO;\n\tbh = affs_bread(sb, inode->i_ino);\n\tif (!bh)\n\t\tgoto done;\n\n\taffs_lock_link(inode);\n\tswitch (type) {\n\tcase ST_LINKFILE:\n\tcase ST_LINKDIR:\n\t\tretval = -ENOSPC;\n\t\tblock = affs_alloc_block(dir, dir->i_ino);\n\t\tif (!block)\n\t\t\tgoto err;\n\t\tretval = -EIO;\n\t\tinode_bh = bh;\n\t\tbh = affs_getzeroblk(sb, block);\n\t\tif (!bh)\n\t\t\tgoto err;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tAFFS_HEAD(bh)->ptype = cpu_to_be32(T_SHORT);\n\tAFFS_HEAD(bh)->key = cpu_to_be32(bh->b_blocknr);\n\taffs_copy_name(AFFS_TAIL(sb, bh)->name, dentry);\n\tAFFS_TAIL(sb, bh)->stype = cpu_to_be32(type);\n\tAFFS_TAIL(sb, bh)->parent = cpu_to_be32(dir->i_ino);\n\n\tif (inode_bh) {\n\t\t__be32 chain;\n\t       \tchain = AFFS_TAIL(sb, inode_bh)->link_chain;\n\t\tAFFS_TAIL(sb, bh)->original = cpu_to_be32(inode->i_ino);\n\t\tAFFS_TAIL(sb, bh)->link_chain = chain;\n\t\tAFFS_TAIL(sb, inode_bh)->link_chain = cpu_to_be32(block);\n\t\taffs_adjust_checksum(inode_bh, block - be32_to_cpu(chain));\n\t\tmark_buffer_dirty_inode(inode_bh, inode);\n\t\tset_nlink(inode, 2);\n\t\tihold(inode);\n\t}\n\taffs_fix_checksum(sb, bh);\n\tmark_buffer_dirty_inode(bh, inode);\n\tdentry->d_fsdata = (void *)(long)bh->b_blocknr;\n\n\taffs_lock_dir(dir);\n\tretval = affs_insert_hash(dir, bh);\n\tmark_buffer_dirty_inode(bh, inode);\n\taffs_unlock_dir(dir);\n\taffs_unlock_link(inode);\n\n\td_instantiate(dentry, inode);\ndone:\n\taffs_brelse(inode_bh);\n\taffs_brelse(bh);\n\treturn retval;\nerr:\n\tif (block)\n\t\taffs_free_block(sb, block);\n\taffs_unlock_link(inode);\n\tgoto done;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s(%lu, %lu, \\\"%pd\\\")\\n\"",
            "__func__",
            "inode->i_ino",
            "dir->i_ino",
            "dentry"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n\nint\naffs_link(struct dentry *old_dentry, struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = old_dentry->d_inode;\n\n\tpr_debug(\"%s(%lu, %lu, \\\"%pd\\\")\\n\", __func__, inode->i_ino, dir->i_ino,\n\t\t dentry);\n\n\treturn affs_add_entry(dir, inode, dentry, ST_LINKFILE);\n}"
  },
  {
    "function_name": "affs_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/namei.c",
    "lines": "326-399",
    "snippet": "int\naffs_symlink(struct inode *dir, struct dentry *dentry, const char *symname)\n{\n\tstruct super_block\t*sb = dir->i_sb;\n\tstruct buffer_head\t*bh;\n\tstruct inode\t\t*inode;\n\tchar\t\t\t*p;\n\tint\t\t\t i, maxlen, error;\n\tchar\t\t\t c, lc;\n\n\tpr_debug(\"%s(%lu,\\\"%pd\\\" -> \\\"%s\\\")\\n\",\n\t\t __func__, dir->i_ino, dentry, symname);\n\n\tmaxlen = AFFS_SB(sb)->s_hashsize * sizeof(u32) - 1;\n\tinode  = affs_new_inode(dir);\n\tif (!inode)\n\t\treturn -ENOSPC;\n\n\tinode->i_op = &affs_symlink_inode_operations;\n\tinode->i_data.a_ops = &affs_symlink_aops;\n\tinode->i_mode = S_IFLNK | 0777;\n\tmode_to_prot(inode);\n\n\terror = -EIO;\n\tbh = affs_bread(sb, inode->i_ino);\n\tif (!bh)\n\t\tgoto err;\n\ti  = 0;\n\tp  = (char *)AFFS_HEAD(bh)->table;\n\tlc = '/';\n\tif (*symname == '/') {\n\t\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\t\twhile (*symname == '/')\n\t\t\tsymname++;\n\t\tspin_lock(&sbi->symlink_lock);\n\t\twhile (sbi->s_volume[i])\t/* Cannot overflow */\n\t\t\t*p++ = sbi->s_volume[i++];\n\t\tspin_unlock(&sbi->symlink_lock);\n\t}\n\twhile (i < maxlen && (c = *symname++)) {\n\t\tif (c == '.' && lc == '/' && *symname == '.' && symname[1] == '/') {\n\t\t\t*p++ = '/';\n\t\t\ti++;\n\t\t\tsymname += 2;\n\t\t\tlc = '/';\n\t\t} else if (c == '.' && lc == '/' && *symname == '/') {\n\t\t\tsymname++;\n\t\t\tlc = '/';\n\t\t} else {\n\t\t\t*p++ = c;\n\t\t\tlc   = c;\n\t\t\ti++;\n\t\t}\n\t\tif (lc == '/')\n\t\t\twhile (*symname == '/')\n\t\t\t\tsymname++;\n\t}\n\t*p = 0;\n\tmark_buffer_dirty_inode(bh, inode);\n\taffs_brelse(bh);\n\tmark_inode_dirty(inode);\n\n\terror = affs_add_entry(dir, inode, dentry, ST_SOFTLINK);\n\tif (error)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tclear_nlink(inode);\n\tmark_inode_dirty(inode);\n\tiput(inode);\n\treturn error;\n}",
    "includes": [
      "#include \"affs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "inode"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_add_entry",
          "args": [
            "dir",
            "inode",
            "dentry",
            "ST_SOFTLINK"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "affs_add_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/inode.c",
          "lines": "340-412",
          "snippet": "int\naffs_add_entry(struct inode *dir, struct inode *inode, struct dentry *dentry, s32 type)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct buffer_head *inode_bh = NULL;\n\tstruct buffer_head *bh = NULL;\n\tu32 block = 0;\n\tint retval;\n\n\tpr_debug(\"%s(dir=%lu, inode=%lu, \\\"%pd\\\", type=%d)\\n\", __func__,\n\t\t dir->i_ino, inode->i_ino, dentry, type);\n\n\tretval = -EIO;\n\tbh = affs_bread(sb, inode->i_ino);\n\tif (!bh)\n\t\tgoto done;\n\n\taffs_lock_link(inode);\n\tswitch (type) {\n\tcase ST_LINKFILE:\n\tcase ST_LINKDIR:\n\t\tretval = -ENOSPC;\n\t\tblock = affs_alloc_block(dir, dir->i_ino);\n\t\tif (!block)\n\t\t\tgoto err;\n\t\tretval = -EIO;\n\t\tinode_bh = bh;\n\t\tbh = affs_getzeroblk(sb, block);\n\t\tif (!bh)\n\t\t\tgoto err;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tAFFS_HEAD(bh)->ptype = cpu_to_be32(T_SHORT);\n\tAFFS_HEAD(bh)->key = cpu_to_be32(bh->b_blocknr);\n\taffs_copy_name(AFFS_TAIL(sb, bh)->name, dentry);\n\tAFFS_TAIL(sb, bh)->stype = cpu_to_be32(type);\n\tAFFS_TAIL(sb, bh)->parent = cpu_to_be32(dir->i_ino);\n\n\tif (inode_bh) {\n\t\t__be32 chain;\n\t       \tchain = AFFS_TAIL(sb, inode_bh)->link_chain;\n\t\tAFFS_TAIL(sb, bh)->original = cpu_to_be32(inode->i_ino);\n\t\tAFFS_TAIL(sb, bh)->link_chain = chain;\n\t\tAFFS_TAIL(sb, inode_bh)->link_chain = cpu_to_be32(block);\n\t\taffs_adjust_checksum(inode_bh, block - be32_to_cpu(chain));\n\t\tmark_buffer_dirty_inode(inode_bh, inode);\n\t\tset_nlink(inode, 2);\n\t\tihold(inode);\n\t}\n\taffs_fix_checksum(sb, bh);\n\tmark_buffer_dirty_inode(bh, inode);\n\tdentry->d_fsdata = (void *)(long)bh->b_blocknr;\n\n\taffs_lock_dir(dir);\n\tretval = affs_insert_hash(dir, bh);\n\tmark_buffer_dirty_inode(bh, inode);\n\taffs_unlock_dir(dir);\n\taffs_unlock_link(inode);\n\n\td_instantiate(dentry, inode);\ndone:\n\taffs_brelse(inode_bh);\n\taffs_brelse(bh);\n\treturn retval;\nerr:\n\tif (block)\n\t\taffs_free_block(sb, block);\n\taffs_unlock_link(inode);\n\tgoto done;\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/gfp.h>\n#include <linux/sched.h>\n\nint\naffs_add_entry(struct inode *dir, struct inode *inode, struct dentry *dentry, s32 type)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct buffer_head *inode_bh = NULL;\n\tstruct buffer_head *bh = NULL;\n\tu32 block = 0;\n\tint retval;\n\n\tpr_debug(\"%s(dir=%lu, inode=%lu, \\\"%pd\\\", type=%d)\\n\", __func__,\n\t\t dir->i_ino, inode->i_ino, dentry, type);\n\n\tretval = -EIO;\n\tbh = affs_bread(sb, inode->i_ino);\n\tif (!bh)\n\t\tgoto done;\n\n\taffs_lock_link(inode);\n\tswitch (type) {\n\tcase ST_LINKFILE:\n\tcase ST_LINKDIR:\n\t\tretval = -ENOSPC;\n\t\tblock = affs_alloc_block(dir, dir->i_ino);\n\t\tif (!block)\n\t\t\tgoto err;\n\t\tretval = -EIO;\n\t\tinode_bh = bh;\n\t\tbh = affs_getzeroblk(sb, block);\n\t\tif (!bh)\n\t\t\tgoto err;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tAFFS_HEAD(bh)->ptype = cpu_to_be32(T_SHORT);\n\tAFFS_HEAD(bh)->key = cpu_to_be32(bh->b_blocknr);\n\taffs_copy_name(AFFS_TAIL(sb, bh)->name, dentry);\n\tAFFS_TAIL(sb, bh)->stype = cpu_to_be32(type);\n\tAFFS_TAIL(sb, bh)->parent = cpu_to_be32(dir->i_ino);\n\n\tif (inode_bh) {\n\t\t__be32 chain;\n\t       \tchain = AFFS_TAIL(sb, inode_bh)->link_chain;\n\t\tAFFS_TAIL(sb, bh)->original = cpu_to_be32(inode->i_ino);\n\t\tAFFS_TAIL(sb, bh)->link_chain = chain;\n\t\tAFFS_TAIL(sb, inode_bh)->link_chain = cpu_to_be32(block);\n\t\taffs_adjust_checksum(inode_bh, block - be32_to_cpu(chain));\n\t\tmark_buffer_dirty_inode(inode_bh, inode);\n\t\tset_nlink(inode, 2);\n\t\tihold(inode);\n\t}\n\taffs_fix_checksum(sb, bh);\n\tmark_buffer_dirty_inode(bh, inode);\n\tdentry->d_fsdata = (void *)(long)bh->b_blocknr;\n\n\taffs_lock_dir(dir);\n\tretval = affs_insert_hash(dir, bh);\n\tmark_buffer_dirty_inode(bh, inode);\n\taffs_unlock_dir(dir);\n\taffs_unlock_link(inode);\n\n\td_instantiate(dentry, inode);\ndone:\n\taffs_brelse(inode_bh);\n\taffs_brelse(bh);\n\treturn retval;\nerr:\n\tif (block)\n\t\taffs_free_block(sb, block);\n\taffs_unlock_link(inode);\n\tgoto done;\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_brelse",
          "args": [
            "bh"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "affs_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "260-266",
          "snippet": "static inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);",
            "extern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);",
            "extern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);",
            "extern u32\taffs_count_free_blocks(struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);\nextern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);\nextern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);\nextern u32\taffs_count_free_blocks(struct super_block *s);\n\nstatic inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty_inode",
          "args": [
            "bh",
            "inode"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "599-617",
          "snippet": "void mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->symlink_lock"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->symlink_lock"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFFS_SB",
          "args": [
            "sb"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "AFFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "123-126",
          "snippet": "static inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void affs_mark_sb_dirty(struct super_block *sb);",
            "extern void\taffs_free_bitmap(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb);\nextern void\taffs_free_bitmap(struct super_block *sb);\n\nstatic inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFFS_HEAD",
          "args": [
            "bh"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_bread",
          "args": [
            "sb",
            "inode->i_ino"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "affs_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "216-223",
          "snippet": "static inline struct buffer_head *\naffs_bread(struct super_block *sb, int block)\n{\n\tpr_debug(\"%s: %d\\n\", __func__, block);\n\tif (block >= AFFS_SB(sb)->s_reserved && block < AFFS_SB(sb)->s_partition_size)\n\t\treturn sb_bread(sb, block);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void affs_mark_sb_dirty(struct super_block *sb);",
            "extern u32\taffs_count_free_blocks(struct super_block *s);",
            "extern void\taffs_free_block(struct super_block *sb, u32 block);",
            "extern void\taffs_free_bitmap(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb);\nextern u32\taffs_count_free_blocks(struct super_block *s);\nextern void\taffs_free_block(struct super_block *sb, u32 block);\nextern void\taffs_free_bitmap(struct super_block *sb);\n\nstatic inline struct buffer_head *\naffs_bread(struct super_block *sb, int block)\n{\n\tpr_debug(\"%s: %d\\n\", __func__, block);\n\tif (block >= AFFS_SB(sb)->s_reserved && block < AFFS_SB(sb)->s_partition_size)\n\t\treturn sb_bread(sb, block);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mode_to_prot",
          "args": [
            "inode"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "mode_to_prot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "414-440",
          "snippet": "void\nmode_to_prot(struct inode *inode)\n{\n\tu32 prot = AFFS_I(inode)->i_protect;\n\tumode_t mode = inode->i_mode;\n\n\tif (!(mode & S_IXUSR))\n\t\tprot |= FIBF_NOEXECUTE;\n\tif (!(mode & S_IRUSR))\n\t\tprot |= FIBF_NOREAD;\n\tif (!(mode & S_IWUSR))\n\t\tprot |= FIBF_NOWRITE;\n\tif (mode & S_IXGRP)\n\t\tprot |= FIBF_GRP_EXECUTE;\n\tif (mode & S_IRGRP)\n\t\tprot |= FIBF_GRP_READ;\n\tif (mode & S_IWGRP)\n\t\tprot |= FIBF_GRP_WRITE;\n\tif (mode & S_IXOTH)\n\t\tprot |= FIBF_OTR_EXECUTE;\n\tif (mode & S_IROTH)\n\t\tprot |= FIBF_OTR_READ;\n\tif (mode & S_IWOTH)\n\t\tprot |= FIBF_OTR_WRITE;\n\n\tAFFS_I(inode)->i_protect = prot;\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nvoid\nmode_to_prot(struct inode *inode)\n{\n\tu32 prot = AFFS_I(inode)->i_protect;\n\tumode_t mode = inode->i_mode;\n\n\tif (!(mode & S_IXUSR))\n\t\tprot |= FIBF_NOEXECUTE;\n\tif (!(mode & S_IRUSR))\n\t\tprot |= FIBF_NOREAD;\n\tif (!(mode & S_IWUSR))\n\t\tprot |= FIBF_NOWRITE;\n\tif (mode & S_IXGRP)\n\t\tprot |= FIBF_GRP_EXECUTE;\n\tif (mode & S_IRGRP)\n\t\tprot |= FIBF_GRP_READ;\n\tif (mode & S_IWGRP)\n\t\tprot |= FIBF_GRP_WRITE;\n\tif (mode & S_IXOTH)\n\t\tprot |= FIBF_OTR_EXECUTE;\n\tif (mode & S_IROTH)\n\t\tprot |= FIBF_OTR_READ;\n\tif (mode & S_IWOTH)\n\t\tprot |= FIBF_OTR_WRITE;\n\n\tAFFS_I(inode)->i_protect = prot;\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_new_inode",
          "args": [
            "dir"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "affs_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/inode.c",
          "lines": "283-333",
          "snippet": "struct inode *\naffs_new_inode(struct inode *dir)\n{\n\tstruct super_block\t*sb = dir->i_sb;\n\tstruct inode\t\t*inode;\n\tu32\t\t\t block;\n\tstruct buffer_head\t*bh;\n\n\tif (!(inode = new_inode(sb)))\n\t\tgoto err_inode;\n\n\tif (!(block = affs_alloc_block(dir, dir->i_ino)))\n\t\tgoto err_block;\n\n\tbh = affs_getzeroblk(sb, block);\n\tif (!bh)\n\t\tgoto err_bh;\n\tmark_buffer_dirty_inode(bh, inode);\n\taffs_brelse(bh);\n\n\tinode->i_uid     = current_fsuid();\n\tinode->i_gid     = current_fsgid();\n\tinode->i_ino     = block;\n\tset_nlink(inode, 1);\n\tinode->i_mtime   = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tatomic_set(&AFFS_I(inode)->i_opencnt, 0);\n\tAFFS_I(inode)->i_blkcnt = 0;\n\tAFFS_I(inode)->i_lc = NULL;\n\tAFFS_I(inode)->i_lc_size = 0;\n\tAFFS_I(inode)->i_lc_shift = 0;\n\tAFFS_I(inode)->i_lc_mask = 0;\n\tAFFS_I(inode)->i_ac = NULL;\n\tAFFS_I(inode)->i_ext_bh = NULL;\n\tAFFS_I(inode)->mmu_private = 0;\n\tAFFS_I(inode)->i_protect = 0;\n\tAFFS_I(inode)->i_lastalloc = 0;\n\tAFFS_I(inode)->i_pa_cnt = 0;\n\tAFFS_I(inode)->i_extcnt = 1;\n\tAFFS_I(inode)->i_ext_last = ~1;\n\n\tinsert_inode_hash(inode);\n\n\treturn inode;\n\nerr_bh:\n\taffs_free_block(sb, block);\nerr_block:\n\tiput(inode);\nerr_inode:\n\treturn NULL;\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/gfp.h>\n#include <linux/sched.h>\n\nstruct inode *\naffs_new_inode(struct inode *dir)\n{\n\tstruct super_block\t*sb = dir->i_sb;\n\tstruct inode\t\t*inode;\n\tu32\t\t\t block;\n\tstruct buffer_head\t*bh;\n\n\tif (!(inode = new_inode(sb)))\n\t\tgoto err_inode;\n\n\tif (!(block = affs_alloc_block(dir, dir->i_ino)))\n\t\tgoto err_block;\n\n\tbh = affs_getzeroblk(sb, block);\n\tif (!bh)\n\t\tgoto err_bh;\n\tmark_buffer_dirty_inode(bh, inode);\n\taffs_brelse(bh);\n\n\tinode->i_uid     = current_fsuid();\n\tinode->i_gid     = current_fsgid();\n\tinode->i_ino     = block;\n\tset_nlink(inode, 1);\n\tinode->i_mtime   = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tatomic_set(&AFFS_I(inode)->i_opencnt, 0);\n\tAFFS_I(inode)->i_blkcnt = 0;\n\tAFFS_I(inode)->i_lc = NULL;\n\tAFFS_I(inode)->i_lc_size = 0;\n\tAFFS_I(inode)->i_lc_shift = 0;\n\tAFFS_I(inode)->i_lc_mask = 0;\n\tAFFS_I(inode)->i_ac = NULL;\n\tAFFS_I(inode)->i_ext_bh = NULL;\n\tAFFS_I(inode)->mmu_private = 0;\n\tAFFS_I(inode)->i_protect = 0;\n\tAFFS_I(inode)->i_lastalloc = 0;\n\tAFFS_I(inode)->i_pa_cnt = 0;\n\tAFFS_I(inode)->i_extcnt = 1;\n\tAFFS_I(inode)->i_ext_last = ~1;\n\n\tinsert_inode_hash(inode);\n\n\treturn inode;\n\nerr_bh:\n\taffs_free_block(sb, block);\nerr_block:\n\tiput(inode);\nerr_inode:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s(%lu,\\\"%pd\\\" -> \\\"%s\\\")\\n\"",
            "__func__",
            "dir->i_ino",
            "dentry",
            "symname"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n\nint\naffs_symlink(struct inode *dir, struct dentry *dentry, const char *symname)\n{\n\tstruct super_block\t*sb = dir->i_sb;\n\tstruct buffer_head\t*bh;\n\tstruct inode\t\t*inode;\n\tchar\t\t\t*p;\n\tint\t\t\t i, maxlen, error;\n\tchar\t\t\t c, lc;\n\n\tpr_debug(\"%s(%lu,\\\"%pd\\\" -> \\\"%s\\\")\\n\",\n\t\t __func__, dir->i_ino, dentry, symname);\n\n\tmaxlen = AFFS_SB(sb)->s_hashsize * sizeof(u32) - 1;\n\tinode  = affs_new_inode(dir);\n\tif (!inode)\n\t\treturn -ENOSPC;\n\n\tinode->i_op = &affs_symlink_inode_operations;\n\tinode->i_data.a_ops = &affs_symlink_aops;\n\tinode->i_mode = S_IFLNK | 0777;\n\tmode_to_prot(inode);\n\n\terror = -EIO;\n\tbh = affs_bread(sb, inode->i_ino);\n\tif (!bh)\n\t\tgoto err;\n\ti  = 0;\n\tp  = (char *)AFFS_HEAD(bh)->table;\n\tlc = '/';\n\tif (*symname == '/') {\n\t\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\t\twhile (*symname == '/')\n\t\t\tsymname++;\n\t\tspin_lock(&sbi->symlink_lock);\n\t\twhile (sbi->s_volume[i])\t/* Cannot overflow */\n\t\t\t*p++ = sbi->s_volume[i++];\n\t\tspin_unlock(&sbi->symlink_lock);\n\t}\n\twhile (i < maxlen && (c = *symname++)) {\n\t\tif (c == '.' && lc == '/' && *symname == '.' && symname[1] == '/') {\n\t\t\t*p++ = '/';\n\t\t\ti++;\n\t\t\tsymname += 2;\n\t\t\tlc = '/';\n\t\t} else if (c == '.' && lc == '/' && *symname == '/') {\n\t\t\tsymname++;\n\t\t\tlc = '/';\n\t\t} else {\n\t\t\t*p++ = c;\n\t\t\tlc   = c;\n\t\t\ti++;\n\t\t}\n\t\tif (lc == '/')\n\t\t\twhile (*symname == '/')\n\t\t\t\tsymname++;\n\t}\n\t*p = 0;\n\tmark_buffer_dirty_inode(bh, inode);\n\taffs_brelse(bh);\n\tmark_inode_dirty(inode);\n\n\terror = affs_add_entry(dir, inode, dentry, ST_SOFTLINK);\n\tif (error)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tclear_nlink(inode);\n\tmark_inode_dirty(inode);\n\tiput(inode);\n\treturn error;\n}"
  },
  {
    "function_name": "affs_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/namei.c",
    "lines": "317-324",
    "snippet": "int\naffs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tpr_debug(\"%s(dir=%lu, %lu \\\"%pd\\\")\\n\", __func__, dir->i_ino,\n\t\t dentry->d_inode->i_ino, dentry);\n\n\treturn affs_remove_header(dentry);\n}",
    "includes": [
      "#include \"affs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "affs_remove_header",
          "args": [
            "dentry"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "affs_remove_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "263-326",
          "snippet": "int\naffs_remove_header(struct dentry *dentry)\n{\n\tstruct super_block *sb;\n\tstruct inode *inode, *dir;\n\tstruct buffer_head *bh = NULL;\n\tint retval;\n\n\tdir = dentry->d_parent->d_inode;\n\tsb = dir->i_sb;\n\n\tretval = -ENOENT;\n\tinode = dentry->d_inode;\n\tif (!inode)\n\t\tgoto done;\n\n\tpr_debug(\"%s(key=%ld)\\n\", __func__, inode->i_ino);\n\tretval = -EIO;\n\tbh = affs_bread(sb, (u32)(long)dentry->d_fsdata);\n\tif (!bh)\n\t\tgoto done;\n\n\taffs_lock_link(inode);\n\taffs_lock_dir(dir);\n\tswitch (be32_to_cpu(AFFS_TAIL(sb, bh)->stype)) {\n\tcase ST_USERDIR:\n\t\t/* if we ever want to support links to dirs\n\t\t * i_hash_lock of the inode must only be\n\t\t * taken after some checks\n\t\t */\n\t\taffs_lock_dir(inode);\n\t\tretval = affs_empty_dir(inode);\n\t\taffs_unlock_dir(inode);\n\t\tif (retval)\n\t\t\tgoto done_unlock;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tretval = affs_remove_hash(dir, bh);\n\tif (retval)\n\t\tgoto done_unlock;\n\tmark_buffer_dirty_inode(bh, inode);\n\n\taffs_unlock_dir(dir);\n\n\tif (inode->i_nlink > 1)\n\t\tretval = affs_remove_link(dentry);\n\telse\n\t\tclear_nlink(inode);\n\taffs_unlock_link(inode);\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\n\ndone:\n\taffs_brelse(bh);\n\treturn retval;\n\ndone_unlock:\n\taffs_unlock_dir(dir);\n\taffs_unlock_link(inode);\n\tgoto done;\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nint\naffs_remove_header(struct dentry *dentry)\n{\n\tstruct super_block *sb;\n\tstruct inode *inode, *dir;\n\tstruct buffer_head *bh = NULL;\n\tint retval;\n\n\tdir = dentry->d_parent->d_inode;\n\tsb = dir->i_sb;\n\n\tretval = -ENOENT;\n\tinode = dentry->d_inode;\n\tif (!inode)\n\t\tgoto done;\n\n\tpr_debug(\"%s(key=%ld)\\n\", __func__, inode->i_ino);\n\tretval = -EIO;\n\tbh = affs_bread(sb, (u32)(long)dentry->d_fsdata);\n\tif (!bh)\n\t\tgoto done;\n\n\taffs_lock_link(inode);\n\taffs_lock_dir(dir);\n\tswitch (be32_to_cpu(AFFS_TAIL(sb, bh)->stype)) {\n\tcase ST_USERDIR:\n\t\t/* if we ever want to support links to dirs\n\t\t * i_hash_lock of the inode must only be\n\t\t * taken after some checks\n\t\t */\n\t\taffs_lock_dir(inode);\n\t\tretval = affs_empty_dir(inode);\n\t\taffs_unlock_dir(inode);\n\t\tif (retval)\n\t\t\tgoto done_unlock;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tretval = affs_remove_hash(dir, bh);\n\tif (retval)\n\t\tgoto done_unlock;\n\tmark_buffer_dirty_inode(bh, inode);\n\n\taffs_unlock_dir(dir);\n\n\tif (inode->i_nlink > 1)\n\t\tretval = affs_remove_link(dentry);\n\telse\n\t\tclear_nlink(inode);\n\taffs_unlock_link(inode);\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\n\ndone:\n\taffs_brelse(bh);\n\treturn retval;\n\ndone_unlock:\n\taffs_unlock_dir(dir);\n\taffs_unlock_link(inode);\n\tgoto done;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s(dir=%lu, %lu \\\"%pd\\\")\\n\"",
            "__func__",
            "dir->i_ino",
            "dentry->d_inode->i_ino",
            "dentry"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n\nint\naffs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tpr_debug(\"%s(dir=%lu, %lu \\\"%pd\\\")\\n\", __func__, dir->i_ino,\n\t\t dentry->d_inode->i_ino, dentry);\n\n\treturn affs_remove_header(dentry);\n}"
  },
  {
    "function_name": "affs_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/namei.c",
    "lines": "288-315",
    "snippet": "int\naffs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tstruct inode\t\t*inode;\n\tint\t\t\t error;\n\n\tpr_debug(\"%s(%lu,\\\"%pd\\\",0%ho)\\n\",\n\t\t __func__, dir->i_ino, dentry, mode);\n\n\tinode = affs_new_inode(dir);\n\tif (!inode)\n\t\treturn -ENOSPC;\n\n\tinode->i_mode = S_IFDIR | mode;\n\tmode_to_prot(inode);\n\n\tinode->i_op = &affs_dir_inode_operations;\n\tinode->i_fop = &affs_dir_operations;\n\n\terror = affs_add_entry(dir, inode, dentry, ST_USERDIR);\n\tif (error) {\n\t\tclear_nlink(inode);\n\t\tmark_inode_dirty(inode);\n\t\tiput(inode);\n\t\treturn error;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"affs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "inode"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_add_entry",
          "args": [
            "dir",
            "inode",
            "dentry",
            "ST_USERDIR"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "affs_add_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/inode.c",
          "lines": "340-412",
          "snippet": "int\naffs_add_entry(struct inode *dir, struct inode *inode, struct dentry *dentry, s32 type)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct buffer_head *inode_bh = NULL;\n\tstruct buffer_head *bh = NULL;\n\tu32 block = 0;\n\tint retval;\n\n\tpr_debug(\"%s(dir=%lu, inode=%lu, \\\"%pd\\\", type=%d)\\n\", __func__,\n\t\t dir->i_ino, inode->i_ino, dentry, type);\n\n\tretval = -EIO;\n\tbh = affs_bread(sb, inode->i_ino);\n\tif (!bh)\n\t\tgoto done;\n\n\taffs_lock_link(inode);\n\tswitch (type) {\n\tcase ST_LINKFILE:\n\tcase ST_LINKDIR:\n\t\tretval = -ENOSPC;\n\t\tblock = affs_alloc_block(dir, dir->i_ino);\n\t\tif (!block)\n\t\t\tgoto err;\n\t\tretval = -EIO;\n\t\tinode_bh = bh;\n\t\tbh = affs_getzeroblk(sb, block);\n\t\tif (!bh)\n\t\t\tgoto err;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tAFFS_HEAD(bh)->ptype = cpu_to_be32(T_SHORT);\n\tAFFS_HEAD(bh)->key = cpu_to_be32(bh->b_blocknr);\n\taffs_copy_name(AFFS_TAIL(sb, bh)->name, dentry);\n\tAFFS_TAIL(sb, bh)->stype = cpu_to_be32(type);\n\tAFFS_TAIL(sb, bh)->parent = cpu_to_be32(dir->i_ino);\n\n\tif (inode_bh) {\n\t\t__be32 chain;\n\t       \tchain = AFFS_TAIL(sb, inode_bh)->link_chain;\n\t\tAFFS_TAIL(sb, bh)->original = cpu_to_be32(inode->i_ino);\n\t\tAFFS_TAIL(sb, bh)->link_chain = chain;\n\t\tAFFS_TAIL(sb, inode_bh)->link_chain = cpu_to_be32(block);\n\t\taffs_adjust_checksum(inode_bh, block - be32_to_cpu(chain));\n\t\tmark_buffer_dirty_inode(inode_bh, inode);\n\t\tset_nlink(inode, 2);\n\t\tihold(inode);\n\t}\n\taffs_fix_checksum(sb, bh);\n\tmark_buffer_dirty_inode(bh, inode);\n\tdentry->d_fsdata = (void *)(long)bh->b_blocknr;\n\n\taffs_lock_dir(dir);\n\tretval = affs_insert_hash(dir, bh);\n\tmark_buffer_dirty_inode(bh, inode);\n\taffs_unlock_dir(dir);\n\taffs_unlock_link(inode);\n\n\td_instantiate(dentry, inode);\ndone:\n\taffs_brelse(inode_bh);\n\taffs_brelse(bh);\n\treturn retval;\nerr:\n\tif (block)\n\t\taffs_free_block(sb, block);\n\taffs_unlock_link(inode);\n\tgoto done;\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/gfp.h>\n#include <linux/sched.h>\n\nint\naffs_add_entry(struct inode *dir, struct inode *inode, struct dentry *dentry, s32 type)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct buffer_head *inode_bh = NULL;\n\tstruct buffer_head *bh = NULL;\n\tu32 block = 0;\n\tint retval;\n\n\tpr_debug(\"%s(dir=%lu, inode=%lu, \\\"%pd\\\", type=%d)\\n\", __func__,\n\t\t dir->i_ino, inode->i_ino, dentry, type);\n\n\tretval = -EIO;\n\tbh = affs_bread(sb, inode->i_ino);\n\tif (!bh)\n\t\tgoto done;\n\n\taffs_lock_link(inode);\n\tswitch (type) {\n\tcase ST_LINKFILE:\n\tcase ST_LINKDIR:\n\t\tretval = -ENOSPC;\n\t\tblock = affs_alloc_block(dir, dir->i_ino);\n\t\tif (!block)\n\t\t\tgoto err;\n\t\tretval = -EIO;\n\t\tinode_bh = bh;\n\t\tbh = affs_getzeroblk(sb, block);\n\t\tif (!bh)\n\t\t\tgoto err;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tAFFS_HEAD(bh)->ptype = cpu_to_be32(T_SHORT);\n\tAFFS_HEAD(bh)->key = cpu_to_be32(bh->b_blocknr);\n\taffs_copy_name(AFFS_TAIL(sb, bh)->name, dentry);\n\tAFFS_TAIL(sb, bh)->stype = cpu_to_be32(type);\n\tAFFS_TAIL(sb, bh)->parent = cpu_to_be32(dir->i_ino);\n\n\tif (inode_bh) {\n\t\t__be32 chain;\n\t       \tchain = AFFS_TAIL(sb, inode_bh)->link_chain;\n\t\tAFFS_TAIL(sb, bh)->original = cpu_to_be32(inode->i_ino);\n\t\tAFFS_TAIL(sb, bh)->link_chain = chain;\n\t\tAFFS_TAIL(sb, inode_bh)->link_chain = cpu_to_be32(block);\n\t\taffs_adjust_checksum(inode_bh, block - be32_to_cpu(chain));\n\t\tmark_buffer_dirty_inode(inode_bh, inode);\n\t\tset_nlink(inode, 2);\n\t\tihold(inode);\n\t}\n\taffs_fix_checksum(sb, bh);\n\tmark_buffer_dirty_inode(bh, inode);\n\tdentry->d_fsdata = (void *)(long)bh->b_blocknr;\n\n\taffs_lock_dir(dir);\n\tretval = affs_insert_hash(dir, bh);\n\tmark_buffer_dirty_inode(bh, inode);\n\taffs_unlock_dir(dir);\n\taffs_unlock_link(inode);\n\n\td_instantiate(dentry, inode);\ndone:\n\taffs_brelse(inode_bh);\n\taffs_brelse(bh);\n\treturn retval;\nerr:\n\tif (block)\n\t\taffs_free_block(sb, block);\n\taffs_unlock_link(inode);\n\tgoto done;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mode_to_prot",
          "args": [
            "inode"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "mode_to_prot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "414-440",
          "snippet": "void\nmode_to_prot(struct inode *inode)\n{\n\tu32 prot = AFFS_I(inode)->i_protect;\n\tumode_t mode = inode->i_mode;\n\n\tif (!(mode & S_IXUSR))\n\t\tprot |= FIBF_NOEXECUTE;\n\tif (!(mode & S_IRUSR))\n\t\tprot |= FIBF_NOREAD;\n\tif (!(mode & S_IWUSR))\n\t\tprot |= FIBF_NOWRITE;\n\tif (mode & S_IXGRP)\n\t\tprot |= FIBF_GRP_EXECUTE;\n\tif (mode & S_IRGRP)\n\t\tprot |= FIBF_GRP_READ;\n\tif (mode & S_IWGRP)\n\t\tprot |= FIBF_GRP_WRITE;\n\tif (mode & S_IXOTH)\n\t\tprot |= FIBF_OTR_EXECUTE;\n\tif (mode & S_IROTH)\n\t\tprot |= FIBF_OTR_READ;\n\tif (mode & S_IWOTH)\n\t\tprot |= FIBF_OTR_WRITE;\n\n\tAFFS_I(inode)->i_protect = prot;\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nvoid\nmode_to_prot(struct inode *inode)\n{\n\tu32 prot = AFFS_I(inode)->i_protect;\n\tumode_t mode = inode->i_mode;\n\n\tif (!(mode & S_IXUSR))\n\t\tprot |= FIBF_NOEXECUTE;\n\tif (!(mode & S_IRUSR))\n\t\tprot |= FIBF_NOREAD;\n\tif (!(mode & S_IWUSR))\n\t\tprot |= FIBF_NOWRITE;\n\tif (mode & S_IXGRP)\n\t\tprot |= FIBF_GRP_EXECUTE;\n\tif (mode & S_IRGRP)\n\t\tprot |= FIBF_GRP_READ;\n\tif (mode & S_IWGRP)\n\t\tprot |= FIBF_GRP_WRITE;\n\tif (mode & S_IXOTH)\n\t\tprot |= FIBF_OTR_EXECUTE;\n\tif (mode & S_IROTH)\n\t\tprot |= FIBF_OTR_READ;\n\tif (mode & S_IWOTH)\n\t\tprot |= FIBF_OTR_WRITE;\n\n\tAFFS_I(inode)->i_protect = prot;\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_new_inode",
          "args": [
            "dir"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "affs_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/inode.c",
          "lines": "283-333",
          "snippet": "struct inode *\naffs_new_inode(struct inode *dir)\n{\n\tstruct super_block\t*sb = dir->i_sb;\n\tstruct inode\t\t*inode;\n\tu32\t\t\t block;\n\tstruct buffer_head\t*bh;\n\n\tif (!(inode = new_inode(sb)))\n\t\tgoto err_inode;\n\n\tif (!(block = affs_alloc_block(dir, dir->i_ino)))\n\t\tgoto err_block;\n\n\tbh = affs_getzeroblk(sb, block);\n\tif (!bh)\n\t\tgoto err_bh;\n\tmark_buffer_dirty_inode(bh, inode);\n\taffs_brelse(bh);\n\n\tinode->i_uid     = current_fsuid();\n\tinode->i_gid     = current_fsgid();\n\tinode->i_ino     = block;\n\tset_nlink(inode, 1);\n\tinode->i_mtime   = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tatomic_set(&AFFS_I(inode)->i_opencnt, 0);\n\tAFFS_I(inode)->i_blkcnt = 0;\n\tAFFS_I(inode)->i_lc = NULL;\n\tAFFS_I(inode)->i_lc_size = 0;\n\tAFFS_I(inode)->i_lc_shift = 0;\n\tAFFS_I(inode)->i_lc_mask = 0;\n\tAFFS_I(inode)->i_ac = NULL;\n\tAFFS_I(inode)->i_ext_bh = NULL;\n\tAFFS_I(inode)->mmu_private = 0;\n\tAFFS_I(inode)->i_protect = 0;\n\tAFFS_I(inode)->i_lastalloc = 0;\n\tAFFS_I(inode)->i_pa_cnt = 0;\n\tAFFS_I(inode)->i_extcnt = 1;\n\tAFFS_I(inode)->i_ext_last = ~1;\n\n\tinsert_inode_hash(inode);\n\n\treturn inode;\n\nerr_bh:\n\taffs_free_block(sb, block);\nerr_block:\n\tiput(inode);\nerr_inode:\n\treturn NULL;\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/gfp.h>\n#include <linux/sched.h>\n\nstruct inode *\naffs_new_inode(struct inode *dir)\n{\n\tstruct super_block\t*sb = dir->i_sb;\n\tstruct inode\t\t*inode;\n\tu32\t\t\t block;\n\tstruct buffer_head\t*bh;\n\n\tif (!(inode = new_inode(sb)))\n\t\tgoto err_inode;\n\n\tif (!(block = affs_alloc_block(dir, dir->i_ino)))\n\t\tgoto err_block;\n\n\tbh = affs_getzeroblk(sb, block);\n\tif (!bh)\n\t\tgoto err_bh;\n\tmark_buffer_dirty_inode(bh, inode);\n\taffs_brelse(bh);\n\n\tinode->i_uid     = current_fsuid();\n\tinode->i_gid     = current_fsgid();\n\tinode->i_ino     = block;\n\tset_nlink(inode, 1);\n\tinode->i_mtime   = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tatomic_set(&AFFS_I(inode)->i_opencnt, 0);\n\tAFFS_I(inode)->i_blkcnt = 0;\n\tAFFS_I(inode)->i_lc = NULL;\n\tAFFS_I(inode)->i_lc_size = 0;\n\tAFFS_I(inode)->i_lc_shift = 0;\n\tAFFS_I(inode)->i_lc_mask = 0;\n\tAFFS_I(inode)->i_ac = NULL;\n\tAFFS_I(inode)->i_ext_bh = NULL;\n\tAFFS_I(inode)->mmu_private = 0;\n\tAFFS_I(inode)->i_protect = 0;\n\tAFFS_I(inode)->i_lastalloc = 0;\n\tAFFS_I(inode)->i_pa_cnt = 0;\n\tAFFS_I(inode)->i_extcnt = 1;\n\tAFFS_I(inode)->i_ext_last = ~1;\n\n\tinsert_inode_hash(inode);\n\n\treturn inode;\n\nerr_bh:\n\taffs_free_block(sb, block);\nerr_block:\n\tiput(inode);\nerr_inode:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s(%lu,\\\"%pd\\\",0%ho)\\n\"",
            "__func__",
            "dir->i_ino",
            "dentry",
            "mode"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n\nint\naffs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tstruct inode\t\t*inode;\n\tint\t\t\t error;\n\n\tpr_debug(\"%s(%lu,\\\"%pd\\\",0%ho)\\n\",\n\t\t __func__, dir->i_ino, dentry, mode);\n\n\tinode = affs_new_inode(dir);\n\tif (!inode)\n\t\treturn -ENOSPC;\n\n\tinode->i_mode = S_IFDIR | mode;\n\tmode_to_prot(inode);\n\n\tinode->i_op = &affs_dir_inode_operations;\n\tinode->i_fop = &affs_dir_operations;\n\n\terror = affs_add_entry(dir, inode, dentry, ST_USERDIR);\n\tif (error) {\n\t\tclear_nlink(inode);\n\t\tmark_inode_dirty(inode);\n\t\tiput(inode);\n\t\treturn error;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "affs_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/namei.c",
    "lines": "258-286",
    "snippet": "int\naffs_create(struct inode *dir, struct dentry *dentry, umode_t mode, bool excl)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct inode\t*inode;\n\tint\t\t error;\n\n\tpr_debug(\"%s(%lu,\\\"%pd\\\",0%ho)\\n\",\n\t\t __func__, dir->i_ino, dentry, mode);\n\n\tinode = affs_new_inode(dir);\n\tif (!inode)\n\t\treturn -ENOSPC;\n\n\tinode->i_mode = mode;\n\tmode_to_prot(inode);\n\tmark_inode_dirty(inode);\n\n\tinode->i_op = &affs_file_inode_operations;\n\tinode->i_fop = &affs_file_operations;\n\tinode->i_mapping->a_ops = (AFFS_SB(sb)->s_flags & SF_OFS) ? &affs_aops_ofs : &affs_aops;\n\terror = affs_add_entry(dir, inode, dentry, ST_FILE);\n\tif (error) {\n\t\tclear_nlink(inode);\n\t\tiput(inode);\n\t\treturn error;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"affs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "inode"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_add_entry",
          "args": [
            "dir",
            "inode",
            "dentry",
            "ST_FILE"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "affs_add_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/inode.c",
          "lines": "340-412",
          "snippet": "int\naffs_add_entry(struct inode *dir, struct inode *inode, struct dentry *dentry, s32 type)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct buffer_head *inode_bh = NULL;\n\tstruct buffer_head *bh = NULL;\n\tu32 block = 0;\n\tint retval;\n\n\tpr_debug(\"%s(dir=%lu, inode=%lu, \\\"%pd\\\", type=%d)\\n\", __func__,\n\t\t dir->i_ino, inode->i_ino, dentry, type);\n\n\tretval = -EIO;\n\tbh = affs_bread(sb, inode->i_ino);\n\tif (!bh)\n\t\tgoto done;\n\n\taffs_lock_link(inode);\n\tswitch (type) {\n\tcase ST_LINKFILE:\n\tcase ST_LINKDIR:\n\t\tretval = -ENOSPC;\n\t\tblock = affs_alloc_block(dir, dir->i_ino);\n\t\tif (!block)\n\t\t\tgoto err;\n\t\tretval = -EIO;\n\t\tinode_bh = bh;\n\t\tbh = affs_getzeroblk(sb, block);\n\t\tif (!bh)\n\t\t\tgoto err;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tAFFS_HEAD(bh)->ptype = cpu_to_be32(T_SHORT);\n\tAFFS_HEAD(bh)->key = cpu_to_be32(bh->b_blocknr);\n\taffs_copy_name(AFFS_TAIL(sb, bh)->name, dentry);\n\tAFFS_TAIL(sb, bh)->stype = cpu_to_be32(type);\n\tAFFS_TAIL(sb, bh)->parent = cpu_to_be32(dir->i_ino);\n\n\tif (inode_bh) {\n\t\t__be32 chain;\n\t       \tchain = AFFS_TAIL(sb, inode_bh)->link_chain;\n\t\tAFFS_TAIL(sb, bh)->original = cpu_to_be32(inode->i_ino);\n\t\tAFFS_TAIL(sb, bh)->link_chain = chain;\n\t\tAFFS_TAIL(sb, inode_bh)->link_chain = cpu_to_be32(block);\n\t\taffs_adjust_checksum(inode_bh, block - be32_to_cpu(chain));\n\t\tmark_buffer_dirty_inode(inode_bh, inode);\n\t\tset_nlink(inode, 2);\n\t\tihold(inode);\n\t}\n\taffs_fix_checksum(sb, bh);\n\tmark_buffer_dirty_inode(bh, inode);\n\tdentry->d_fsdata = (void *)(long)bh->b_blocknr;\n\n\taffs_lock_dir(dir);\n\tretval = affs_insert_hash(dir, bh);\n\tmark_buffer_dirty_inode(bh, inode);\n\taffs_unlock_dir(dir);\n\taffs_unlock_link(inode);\n\n\td_instantiate(dentry, inode);\ndone:\n\taffs_brelse(inode_bh);\n\taffs_brelse(bh);\n\treturn retval;\nerr:\n\tif (block)\n\t\taffs_free_block(sb, block);\n\taffs_unlock_link(inode);\n\tgoto done;\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/gfp.h>\n#include <linux/sched.h>\n\nint\naffs_add_entry(struct inode *dir, struct inode *inode, struct dentry *dentry, s32 type)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct buffer_head *inode_bh = NULL;\n\tstruct buffer_head *bh = NULL;\n\tu32 block = 0;\n\tint retval;\n\n\tpr_debug(\"%s(dir=%lu, inode=%lu, \\\"%pd\\\", type=%d)\\n\", __func__,\n\t\t dir->i_ino, inode->i_ino, dentry, type);\n\n\tretval = -EIO;\n\tbh = affs_bread(sb, inode->i_ino);\n\tif (!bh)\n\t\tgoto done;\n\n\taffs_lock_link(inode);\n\tswitch (type) {\n\tcase ST_LINKFILE:\n\tcase ST_LINKDIR:\n\t\tretval = -ENOSPC;\n\t\tblock = affs_alloc_block(dir, dir->i_ino);\n\t\tif (!block)\n\t\t\tgoto err;\n\t\tretval = -EIO;\n\t\tinode_bh = bh;\n\t\tbh = affs_getzeroblk(sb, block);\n\t\tif (!bh)\n\t\t\tgoto err;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tAFFS_HEAD(bh)->ptype = cpu_to_be32(T_SHORT);\n\tAFFS_HEAD(bh)->key = cpu_to_be32(bh->b_blocknr);\n\taffs_copy_name(AFFS_TAIL(sb, bh)->name, dentry);\n\tAFFS_TAIL(sb, bh)->stype = cpu_to_be32(type);\n\tAFFS_TAIL(sb, bh)->parent = cpu_to_be32(dir->i_ino);\n\n\tif (inode_bh) {\n\t\t__be32 chain;\n\t       \tchain = AFFS_TAIL(sb, inode_bh)->link_chain;\n\t\tAFFS_TAIL(sb, bh)->original = cpu_to_be32(inode->i_ino);\n\t\tAFFS_TAIL(sb, bh)->link_chain = chain;\n\t\tAFFS_TAIL(sb, inode_bh)->link_chain = cpu_to_be32(block);\n\t\taffs_adjust_checksum(inode_bh, block - be32_to_cpu(chain));\n\t\tmark_buffer_dirty_inode(inode_bh, inode);\n\t\tset_nlink(inode, 2);\n\t\tihold(inode);\n\t}\n\taffs_fix_checksum(sb, bh);\n\tmark_buffer_dirty_inode(bh, inode);\n\tdentry->d_fsdata = (void *)(long)bh->b_blocknr;\n\n\taffs_lock_dir(dir);\n\tretval = affs_insert_hash(dir, bh);\n\tmark_buffer_dirty_inode(bh, inode);\n\taffs_unlock_dir(dir);\n\taffs_unlock_link(inode);\n\n\td_instantiate(dentry, inode);\ndone:\n\taffs_brelse(inode_bh);\n\taffs_brelse(bh);\n\treturn retval;\nerr:\n\tif (block)\n\t\taffs_free_block(sb, block);\n\taffs_unlock_link(inode);\n\tgoto done;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFFS_SB",
          "args": [
            "sb"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "AFFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "123-126",
          "snippet": "static inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void affs_mark_sb_dirty(struct super_block *sb);",
            "extern void\taffs_free_bitmap(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb);\nextern void\taffs_free_bitmap(struct super_block *sb);\n\nstatic inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mode_to_prot",
          "args": [
            "inode"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "mode_to_prot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "414-440",
          "snippet": "void\nmode_to_prot(struct inode *inode)\n{\n\tu32 prot = AFFS_I(inode)->i_protect;\n\tumode_t mode = inode->i_mode;\n\n\tif (!(mode & S_IXUSR))\n\t\tprot |= FIBF_NOEXECUTE;\n\tif (!(mode & S_IRUSR))\n\t\tprot |= FIBF_NOREAD;\n\tif (!(mode & S_IWUSR))\n\t\tprot |= FIBF_NOWRITE;\n\tif (mode & S_IXGRP)\n\t\tprot |= FIBF_GRP_EXECUTE;\n\tif (mode & S_IRGRP)\n\t\tprot |= FIBF_GRP_READ;\n\tif (mode & S_IWGRP)\n\t\tprot |= FIBF_GRP_WRITE;\n\tif (mode & S_IXOTH)\n\t\tprot |= FIBF_OTR_EXECUTE;\n\tif (mode & S_IROTH)\n\t\tprot |= FIBF_OTR_READ;\n\tif (mode & S_IWOTH)\n\t\tprot |= FIBF_OTR_WRITE;\n\n\tAFFS_I(inode)->i_protect = prot;\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nvoid\nmode_to_prot(struct inode *inode)\n{\n\tu32 prot = AFFS_I(inode)->i_protect;\n\tumode_t mode = inode->i_mode;\n\n\tif (!(mode & S_IXUSR))\n\t\tprot |= FIBF_NOEXECUTE;\n\tif (!(mode & S_IRUSR))\n\t\tprot |= FIBF_NOREAD;\n\tif (!(mode & S_IWUSR))\n\t\tprot |= FIBF_NOWRITE;\n\tif (mode & S_IXGRP)\n\t\tprot |= FIBF_GRP_EXECUTE;\n\tif (mode & S_IRGRP)\n\t\tprot |= FIBF_GRP_READ;\n\tif (mode & S_IWGRP)\n\t\tprot |= FIBF_GRP_WRITE;\n\tif (mode & S_IXOTH)\n\t\tprot |= FIBF_OTR_EXECUTE;\n\tif (mode & S_IROTH)\n\t\tprot |= FIBF_OTR_READ;\n\tif (mode & S_IWOTH)\n\t\tprot |= FIBF_OTR_WRITE;\n\n\tAFFS_I(inode)->i_protect = prot;\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_new_inode",
          "args": [
            "dir"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "affs_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/inode.c",
          "lines": "283-333",
          "snippet": "struct inode *\naffs_new_inode(struct inode *dir)\n{\n\tstruct super_block\t*sb = dir->i_sb;\n\tstruct inode\t\t*inode;\n\tu32\t\t\t block;\n\tstruct buffer_head\t*bh;\n\n\tif (!(inode = new_inode(sb)))\n\t\tgoto err_inode;\n\n\tif (!(block = affs_alloc_block(dir, dir->i_ino)))\n\t\tgoto err_block;\n\n\tbh = affs_getzeroblk(sb, block);\n\tif (!bh)\n\t\tgoto err_bh;\n\tmark_buffer_dirty_inode(bh, inode);\n\taffs_brelse(bh);\n\n\tinode->i_uid     = current_fsuid();\n\tinode->i_gid     = current_fsgid();\n\tinode->i_ino     = block;\n\tset_nlink(inode, 1);\n\tinode->i_mtime   = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tatomic_set(&AFFS_I(inode)->i_opencnt, 0);\n\tAFFS_I(inode)->i_blkcnt = 0;\n\tAFFS_I(inode)->i_lc = NULL;\n\tAFFS_I(inode)->i_lc_size = 0;\n\tAFFS_I(inode)->i_lc_shift = 0;\n\tAFFS_I(inode)->i_lc_mask = 0;\n\tAFFS_I(inode)->i_ac = NULL;\n\tAFFS_I(inode)->i_ext_bh = NULL;\n\tAFFS_I(inode)->mmu_private = 0;\n\tAFFS_I(inode)->i_protect = 0;\n\tAFFS_I(inode)->i_lastalloc = 0;\n\tAFFS_I(inode)->i_pa_cnt = 0;\n\tAFFS_I(inode)->i_extcnt = 1;\n\tAFFS_I(inode)->i_ext_last = ~1;\n\n\tinsert_inode_hash(inode);\n\n\treturn inode;\n\nerr_bh:\n\taffs_free_block(sb, block);\nerr_block:\n\tiput(inode);\nerr_inode:\n\treturn NULL;\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/gfp.h>\n#include <linux/sched.h>\n\nstruct inode *\naffs_new_inode(struct inode *dir)\n{\n\tstruct super_block\t*sb = dir->i_sb;\n\tstruct inode\t\t*inode;\n\tu32\t\t\t block;\n\tstruct buffer_head\t*bh;\n\n\tif (!(inode = new_inode(sb)))\n\t\tgoto err_inode;\n\n\tif (!(block = affs_alloc_block(dir, dir->i_ino)))\n\t\tgoto err_block;\n\n\tbh = affs_getzeroblk(sb, block);\n\tif (!bh)\n\t\tgoto err_bh;\n\tmark_buffer_dirty_inode(bh, inode);\n\taffs_brelse(bh);\n\n\tinode->i_uid     = current_fsuid();\n\tinode->i_gid     = current_fsgid();\n\tinode->i_ino     = block;\n\tset_nlink(inode, 1);\n\tinode->i_mtime   = inode->i_atime = inode->i_ctime = CURRENT_TIME_SEC;\n\tatomic_set(&AFFS_I(inode)->i_opencnt, 0);\n\tAFFS_I(inode)->i_blkcnt = 0;\n\tAFFS_I(inode)->i_lc = NULL;\n\tAFFS_I(inode)->i_lc_size = 0;\n\tAFFS_I(inode)->i_lc_shift = 0;\n\tAFFS_I(inode)->i_lc_mask = 0;\n\tAFFS_I(inode)->i_ac = NULL;\n\tAFFS_I(inode)->i_ext_bh = NULL;\n\tAFFS_I(inode)->mmu_private = 0;\n\tAFFS_I(inode)->i_protect = 0;\n\tAFFS_I(inode)->i_lastalloc = 0;\n\tAFFS_I(inode)->i_pa_cnt = 0;\n\tAFFS_I(inode)->i_extcnt = 1;\n\tAFFS_I(inode)->i_ext_last = ~1;\n\n\tinsert_inode_hash(inode);\n\n\treturn inode;\n\nerr_bh:\n\taffs_free_block(sb, block);\nerr_block:\n\tiput(inode);\nerr_inode:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s(%lu,\\\"%pd\\\",0%ho)\\n\"",
            "__func__",
            "dir->i_ino",
            "dentry",
            "mode"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n\nint\naffs_create(struct inode *dir, struct dentry *dentry, umode_t mode, bool excl)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct inode\t*inode;\n\tint\t\t error;\n\n\tpr_debug(\"%s(%lu,\\\"%pd\\\",0%ho)\\n\",\n\t\t __func__, dir->i_ino, dentry, mode);\n\n\tinode = affs_new_inode(dir);\n\tif (!inode)\n\t\treturn -ENOSPC;\n\n\tinode->i_mode = mode;\n\tmode_to_prot(inode);\n\tmark_inode_dirty(inode);\n\n\tinode->i_op = &affs_file_inode_operations;\n\tinode->i_fop = &affs_file_operations;\n\tinode->i_mapping->a_ops = (AFFS_SB(sb)->s_flags & SF_OFS) ? &affs_aops_ofs : &affs_aops;\n\terror = affs_add_entry(dir, inode, dentry, ST_FILE);\n\tif (error) {\n\t\tclear_nlink(inode);\n\t\tiput(inode);\n\t\treturn error;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "affs_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/namei.c",
    "lines": "249-256",
    "snippet": "int\naffs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tpr_debug(\"%s(dir=%lu, %lu \\\"%pd\\\")\\n\", __func__, dir->i_ino,\n\t\t dentry->d_inode->i_ino, dentry);\n\n\treturn affs_remove_header(dentry);\n}",
    "includes": [
      "#include \"affs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "affs_remove_header",
          "args": [
            "dentry"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "affs_remove_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "263-326",
          "snippet": "int\naffs_remove_header(struct dentry *dentry)\n{\n\tstruct super_block *sb;\n\tstruct inode *inode, *dir;\n\tstruct buffer_head *bh = NULL;\n\tint retval;\n\n\tdir = dentry->d_parent->d_inode;\n\tsb = dir->i_sb;\n\n\tretval = -ENOENT;\n\tinode = dentry->d_inode;\n\tif (!inode)\n\t\tgoto done;\n\n\tpr_debug(\"%s(key=%ld)\\n\", __func__, inode->i_ino);\n\tretval = -EIO;\n\tbh = affs_bread(sb, (u32)(long)dentry->d_fsdata);\n\tif (!bh)\n\t\tgoto done;\n\n\taffs_lock_link(inode);\n\taffs_lock_dir(dir);\n\tswitch (be32_to_cpu(AFFS_TAIL(sb, bh)->stype)) {\n\tcase ST_USERDIR:\n\t\t/* if we ever want to support links to dirs\n\t\t * i_hash_lock of the inode must only be\n\t\t * taken after some checks\n\t\t */\n\t\taffs_lock_dir(inode);\n\t\tretval = affs_empty_dir(inode);\n\t\taffs_unlock_dir(inode);\n\t\tif (retval)\n\t\t\tgoto done_unlock;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tretval = affs_remove_hash(dir, bh);\n\tif (retval)\n\t\tgoto done_unlock;\n\tmark_buffer_dirty_inode(bh, inode);\n\n\taffs_unlock_dir(dir);\n\n\tif (inode->i_nlink > 1)\n\t\tretval = affs_remove_link(dentry);\n\telse\n\t\tclear_nlink(inode);\n\taffs_unlock_link(inode);\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\n\ndone:\n\taffs_brelse(bh);\n\treturn retval;\n\ndone_unlock:\n\taffs_unlock_dir(dir);\n\taffs_unlock_link(inode);\n\tgoto done;\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nint\naffs_remove_header(struct dentry *dentry)\n{\n\tstruct super_block *sb;\n\tstruct inode *inode, *dir;\n\tstruct buffer_head *bh = NULL;\n\tint retval;\n\n\tdir = dentry->d_parent->d_inode;\n\tsb = dir->i_sb;\n\n\tretval = -ENOENT;\n\tinode = dentry->d_inode;\n\tif (!inode)\n\t\tgoto done;\n\n\tpr_debug(\"%s(key=%ld)\\n\", __func__, inode->i_ino);\n\tretval = -EIO;\n\tbh = affs_bread(sb, (u32)(long)dentry->d_fsdata);\n\tif (!bh)\n\t\tgoto done;\n\n\taffs_lock_link(inode);\n\taffs_lock_dir(dir);\n\tswitch (be32_to_cpu(AFFS_TAIL(sb, bh)->stype)) {\n\tcase ST_USERDIR:\n\t\t/* if we ever want to support links to dirs\n\t\t * i_hash_lock of the inode must only be\n\t\t * taken after some checks\n\t\t */\n\t\taffs_lock_dir(inode);\n\t\tretval = affs_empty_dir(inode);\n\t\taffs_unlock_dir(inode);\n\t\tif (retval)\n\t\t\tgoto done_unlock;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tretval = affs_remove_hash(dir, bh);\n\tif (retval)\n\t\tgoto done_unlock;\n\tmark_buffer_dirty_inode(bh, inode);\n\n\taffs_unlock_dir(dir);\n\n\tif (inode->i_nlink > 1)\n\t\tretval = affs_remove_link(dentry);\n\telse\n\t\tclear_nlink(inode);\n\taffs_unlock_link(inode);\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tmark_inode_dirty(inode);\n\ndone:\n\taffs_brelse(bh);\n\treturn retval;\n\ndone_unlock:\n\taffs_unlock_dir(dir);\n\taffs_unlock_link(inode);\n\tgoto done;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s(dir=%lu, %lu \\\"%pd\\\")\\n\"",
            "__func__",
            "dir->i_ino",
            "dentry->d_inode->i_ino",
            "dentry"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n\nint\naffs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tpr_debug(\"%s(dir=%lu, %lu \\\"%pd\\\")\\n\", __func__, dir->i_ino,\n\t\t dentry->d_inode->i_ino, dentry);\n\n\treturn affs_remove_header(dentry);\n}"
  },
  {
    "function_name": "affs_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/namei.c",
    "lines": "215-247",
    "snippet": "struct dentry *\naffs_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct buffer_head *bh;\n\tstruct inode *inode = NULL;\n\n\tpr_debug(\"%s(\\\"%pd\\\")\\n\", __func__, dentry);\n\n\taffs_lock_dir(dir);\n\tbh = affs_find_entry(dir, dentry);\n\taffs_unlock_dir(dir);\n\tif (IS_ERR(bh))\n\t\treturn ERR_CAST(bh);\n\tif (bh) {\n\t\tu32 ino = bh->b_blocknr;\n\n\t\t/* store the real header ino in d_fsdata for faster lookups */\n\t\tdentry->d_fsdata = (void *)(long)ino;\n\t\tswitch (be32_to_cpu(AFFS_TAIL(sb, bh)->stype)) {\n\t\t//link to dirs disabled\n\t\t//case ST_LINKDIR:\n\t\tcase ST_LINKFILE:\n\t\t\tino = be32_to_cpu(AFFS_TAIL(sb, bh)->original);\n\t\t}\n\t\taffs_brelse(bh);\n\t\tinode = affs_iget(sb, ino);\n\t\tif (IS_ERR(inode))\n\t\t\treturn ERR_CAST(inode);\n\t}\n\td_add(dentry, inode);\n\treturn NULL;\n}",
    "includes": [
      "#include \"affs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "inode"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_iget",
          "args": [
            "sb",
            "ino"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "affs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/inode.c",
          "lines": "16-162",
          "snippet": "struct inode *affs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct affs_sb_info\t*sbi = AFFS_SB(sb);\n\tstruct buffer_head\t*bh;\n\tstruct affs_tail\t*tail;\n\tstruct inode\t\t*inode;\n\tu32\t\t\t block;\n\tu32\t\t\t size;\n\tu32\t\t\t prot;\n\tu16\t\t\t id;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tpr_debug(\"affs_iget(%lu)\\n\", inode->i_ino);\n\n\tblock = inode->i_ino;\n\tbh = affs_bread(sb, block);\n\tif (!bh) {\n\t\taffs_warning(sb, \"read_inode\", \"Cannot read block %d\", block);\n\t\tgoto bad_inode;\n\t}\n\tif (affs_checksum_block(sb, bh) || be32_to_cpu(AFFS_HEAD(bh)->ptype) != T_SHORT) {\n\t\taffs_warning(sb,\"read_inode\",\n\t\t\t   \"Checksum or type (ptype=%d) error on inode %d\",\n\t\t\t   AFFS_HEAD(bh)->ptype, block);\n\t\tgoto bad_inode;\n\t}\n\n\ttail = AFFS_TAIL(sb, bh);\n\tprot = be32_to_cpu(tail->protect);\n\n\tinode->i_size = 0;\n\tset_nlink(inode, 1);\n\tinode->i_mode = 0;\n\tAFFS_I(inode)->i_extcnt = 1;\n\tAFFS_I(inode)->i_ext_last = ~1;\n\tAFFS_I(inode)->i_protect = prot;\n\tatomic_set(&AFFS_I(inode)->i_opencnt, 0);\n\tAFFS_I(inode)->i_blkcnt = 0;\n\tAFFS_I(inode)->i_lc = NULL;\n\tAFFS_I(inode)->i_lc_size = 0;\n\tAFFS_I(inode)->i_lc_shift = 0;\n\tAFFS_I(inode)->i_lc_mask = 0;\n\tAFFS_I(inode)->i_ac = NULL;\n\tAFFS_I(inode)->i_ext_bh = NULL;\n\tAFFS_I(inode)->mmu_private = 0;\n\tAFFS_I(inode)->i_lastalloc = 0;\n\tAFFS_I(inode)->i_pa_cnt = 0;\n\n\tif (sbi->s_flags & SF_SETMODE)\n\t\tinode->i_mode = sbi->s_mode;\n\telse\n\t\tinode->i_mode = prot_to_mode(prot);\n\n\tid = be16_to_cpu(tail->uid);\n\tif (id == 0 || sbi->s_flags & SF_SETUID)\n\t\tinode->i_uid = sbi->s_uid;\n\telse if (id == 0xFFFF && sbi->s_flags & SF_MUFS)\n\t\ti_uid_write(inode, 0);\n\telse\n\t\ti_uid_write(inode, id);\n\n\tid = be16_to_cpu(tail->gid);\n\tif (id == 0 || sbi->s_flags & SF_SETGID)\n\t\tinode->i_gid = sbi->s_gid;\n\telse if (id == 0xFFFF && sbi->s_flags & SF_MUFS)\n\t\ti_gid_write(inode, 0);\n\telse\n\t\ti_gid_write(inode, id);\n\n\tswitch (be32_to_cpu(tail->stype)) {\n\tcase ST_ROOT:\n\t\tinode->i_uid = sbi->s_uid;\n\t\tinode->i_gid = sbi->s_gid;\n\t\t/* fall through */\n\tcase ST_USERDIR:\n\t\tif (be32_to_cpu(tail->stype) == ST_USERDIR ||\n\t\t    sbi->s_flags & SF_SETMODE) {\n\t\t\tif (inode->i_mode & S_IRUSR)\n\t\t\t\tinode->i_mode |= S_IXUSR;\n\t\t\tif (inode->i_mode & S_IRGRP)\n\t\t\t\tinode->i_mode |= S_IXGRP;\n\t\t\tif (inode->i_mode & S_IROTH)\n\t\t\t\tinode->i_mode |= S_IXOTH;\n\t\t\tinode->i_mode |= S_IFDIR;\n\t\t} else\n\t\t\tinode->i_mode = S_IRUGO | S_IXUGO | S_IWUSR | S_IFDIR;\n\t\t/* Maybe it should be controlled by mount parameter? */\n\t\t//inode->i_mode |= S_ISVTX;\n\t\tinode->i_op = &affs_dir_inode_operations;\n\t\tinode->i_fop = &affs_dir_operations;\n\t\tbreak;\n\tcase ST_LINKDIR:\n#if 0\n\t\taffs_warning(sb, \"read_inode\", \"inode is LINKDIR\");\n\t\tgoto bad_inode;\n#else\n\t\tinode->i_mode |= S_IFDIR;\n\t\t/* ... and leave ->i_op and ->i_fop pointing to empty */\n\t\tbreak;\n#endif\n\tcase ST_LINKFILE:\n\t\taffs_warning(sb, \"read_inode\", \"inode is LINKFILE\");\n\t\tgoto bad_inode;\n\tcase ST_FILE:\n\t\tsize = be32_to_cpu(tail->size);\n\t\tinode->i_mode |= S_IFREG;\n\t\tAFFS_I(inode)->mmu_private = inode->i_size = size;\n\t\tif (inode->i_size) {\n\t\t\tAFFS_I(inode)->i_blkcnt = (size - 1) /\n\t\t\t\t\t       sbi->s_data_blksize + 1;\n\t\t\tAFFS_I(inode)->i_extcnt = (AFFS_I(inode)->i_blkcnt - 1) /\n\t\t\t\t\t       sbi->s_hashsize + 1;\n\t\t}\n\t\tif (tail->link_chain)\n\t\t\tset_nlink(inode, 2);\n\t\tinode->i_mapping->a_ops = (sbi->s_flags & SF_OFS) ? &affs_aops_ofs : &affs_aops;\n\t\tinode->i_op = &affs_file_inode_operations;\n\t\tinode->i_fop = &affs_file_operations;\n\t\tbreak;\n\tcase ST_SOFTLINK:\n\t\tinode->i_mode |= S_IFLNK;\n\t\tinode->i_op = &affs_symlink_inode_operations;\n\t\tinode->i_data.a_ops = &affs_symlink_aops;\n\t\tbreak;\n\t}\n\n\tinode->i_mtime.tv_sec = inode->i_atime.tv_sec = inode->i_ctime.tv_sec\n\t\t       = (be32_to_cpu(tail->change.days) * (24 * 60 * 60) +\n\t\t         be32_to_cpu(tail->change.mins) * 60 +\n\t\t\t be32_to_cpu(tail->change.ticks) / 50 +\n\t\t\t ((8 * 365 + 2) * 24 * 60 * 60)) +\n\t\t\t sys_tz.tz_minuteswest * 60;\n\tinode->i_mtime.tv_nsec = inode->i_ctime.tv_nsec = inode->i_atime.tv_nsec = 0;\n\taffs_brelse(bh);\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\taffs_brelse(bh);\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/gfp.h>\n#include <linux/sched.h>\n\nstruct inode *affs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct affs_sb_info\t*sbi = AFFS_SB(sb);\n\tstruct buffer_head\t*bh;\n\tstruct affs_tail\t*tail;\n\tstruct inode\t\t*inode;\n\tu32\t\t\t block;\n\tu32\t\t\t size;\n\tu32\t\t\t prot;\n\tu16\t\t\t id;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tpr_debug(\"affs_iget(%lu)\\n\", inode->i_ino);\n\n\tblock = inode->i_ino;\n\tbh = affs_bread(sb, block);\n\tif (!bh) {\n\t\taffs_warning(sb, \"read_inode\", \"Cannot read block %d\", block);\n\t\tgoto bad_inode;\n\t}\n\tif (affs_checksum_block(sb, bh) || be32_to_cpu(AFFS_HEAD(bh)->ptype) != T_SHORT) {\n\t\taffs_warning(sb,\"read_inode\",\n\t\t\t   \"Checksum or type (ptype=%d) error on inode %d\",\n\t\t\t   AFFS_HEAD(bh)->ptype, block);\n\t\tgoto bad_inode;\n\t}\n\n\ttail = AFFS_TAIL(sb, bh);\n\tprot = be32_to_cpu(tail->protect);\n\n\tinode->i_size = 0;\n\tset_nlink(inode, 1);\n\tinode->i_mode = 0;\n\tAFFS_I(inode)->i_extcnt = 1;\n\tAFFS_I(inode)->i_ext_last = ~1;\n\tAFFS_I(inode)->i_protect = prot;\n\tatomic_set(&AFFS_I(inode)->i_opencnt, 0);\n\tAFFS_I(inode)->i_blkcnt = 0;\n\tAFFS_I(inode)->i_lc = NULL;\n\tAFFS_I(inode)->i_lc_size = 0;\n\tAFFS_I(inode)->i_lc_shift = 0;\n\tAFFS_I(inode)->i_lc_mask = 0;\n\tAFFS_I(inode)->i_ac = NULL;\n\tAFFS_I(inode)->i_ext_bh = NULL;\n\tAFFS_I(inode)->mmu_private = 0;\n\tAFFS_I(inode)->i_lastalloc = 0;\n\tAFFS_I(inode)->i_pa_cnt = 0;\n\n\tif (sbi->s_flags & SF_SETMODE)\n\t\tinode->i_mode = sbi->s_mode;\n\telse\n\t\tinode->i_mode = prot_to_mode(prot);\n\n\tid = be16_to_cpu(tail->uid);\n\tif (id == 0 || sbi->s_flags & SF_SETUID)\n\t\tinode->i_uid = sbi->s_uid;\n\telse if (id == 0xFFFF && sbi->s_flags & SF_MUFS)\n\t\ti_uid_write(inode, 0);\n\telse\n\t\ti_uid_write(inode, id);\n\n\tid = be16_to_cpu(tail->gid);\n\tif (id == 0 || sbi->s_flags & SF_SETGID)\n\t\tinode->i_gid = sbi->s_gid;\n\telse if (id == 0xFFFF && sbi->s_flags & SF_MUFS)\n\t\ti_gid_write(inode, 0);\n\telse\n\t\ti_gid_write(inode, id);\n\n\tswitch (be32_to_cpu(tail->stype)) {\n\tcase ST_ROOT:\n\t\tinode->i_uid = sbi->s_uid;\n\t\tinode->i_gid = sbi->s_gid;\n\t\t/* fall through */\n\tcase ST_USERDIR:\n\t\tif (be32_to_cpu(tail->stype) == ST_USERDIR ||\n\t\t    sbi->s_flags & SF_SETMODE) {\n\t\t\tif (inode->i_mode & S_IRUSR)\n\t\t\t\tinode->i_mode |= S_IXUSR;\n\t\t\tif (inode->i_mode & S_IRGRP)\n\t\t\t\tinode->i_mode |= S_IXGRP;\n\t\t\tif (inode->i_mode & S_IROTH)\n\t\t\t\tinode->i_mode |= S_IXOTH;\n\t\t\tinode->i_mode |= S_IFDIR;\n\t\t} else\n\t\t\tinode->i_mode = S_IRUGO | S_IXUGO | S_IWUSR | S_IFDIR;\n\t\t/* Maybe it should be controlled by mount parameter? */\n\t\t//inode->i_mode |= S_ISVTX;\n\t\tinode->i_op = &affs_dir_inode_operations;\n\t\tinode->i_fop = &affs_dir_operations;\n\t\tbreak;\n\tcase ST_LINKDIR:\n#if 0\n\t\taffs_warning(sb, \"read_inode\", \"inode is LINKDIR\");\n\t\tgoto bad_inode;\n#else\n\t\tinode->i_mode |= S_IFDIR;\n\t\t/* ... and leave ->i_op and ->i_fop pointing to empty */\n\t\tbreak;\n#endif\n\tcase ST_LINKFILE:\n\t\taffs_warning(sb, \"read_inode\", \"inode is LINKFILE\");\n\t\tgoto bad_inode;\n\tcase ST_FILE:\n\t\tsize = be32_to_cpu(tail->size);\n\t\tinode->i_mode |= S_IFREG;\n\t\tAFFS_I(inode)->mmu_private = inode->i_size = size;\n\t\tif (inode->i_size) {\n\t\t\tAFFS_I(inode)->i_blkcnt = (size - 1) /\n\t\t\t\t\t       sbi->s_data_blksize + 1;\n\t\t\tAFFS_I(inode)->i_extcnt = (AFFS_I(inode)->i_blkcnt - 1) /\n\t\t\t\t\t       sbi->s_hashsize + 1;\n\t\t}\n\t\tif (tail->link_chain)\n\t\t\tset_nlink(inode, 2);\n\t\tinode->i_mapping->a_ops = (sbi->s_flags & SF_OFS) ? &affs_aops_ofs : &affs_aops;\n\t\tinode->i_op = &affs_file_inode_operations;\n\t\tinode->i_fop = &affs_file_operations;\n\t\tbreak;\n\tcase ST_SOFTLINK:\n\t\tinode->i_mode |= S_IFLNK;\n\t\tinode->i_op = &affs_symlink_inode_operations;\n\t\tinode->i_data.a_ops = &affs_symlink_aops;\n\t\tbreak;\n\t}\n\n\tinode->i_mtime.tv_sec = inode->i_atime.tv_sec = inode->i_ctime.tv_sec\n\t\t       = (be32_to_cpu(tail->change.days) * (24 * 60 * 60) +\n\t\t         be32_to_cpu(tail->change.mins) * 60 +\n\t\t\t be32_to_cpu(tail->change.ticks) / 50 +\n\t\t\t ((8 * 365 + 2) * 24 * 60 * 60)) +\n\t\t\t sys_tz.tz_minuteswest * 60;\n\tinode->i_mtime.tv_nsec = inode->i_ctime.tv_nsec = inode->i_atime.tv_nsec = 0;\n\taffs_brelse(bh);\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\taffs_brelse(bh);\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_brelse",
          "args": [
            "bh"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "affs_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "260-266",
          "snippet": "static inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);",
            "extern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);",
            "extern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);",
            "extern u32\taffs_count_free_blocks(struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);\nextern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);\nextern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);\nextern u32\taffs_count_free_blocks(struct super_block *s);\n\nstatic inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "AFFS_TAIL(sb, bh)->original"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_TAIL",
          "args": [
            "sb",
            "bh"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "AFFS_TAIL(sb, bh)->stype"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_TAIL",
          "args": [
            "sb",
            "bh"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "bh"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bh"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_unlock_dir",
          "args": [
            "dir"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "affs_unlock_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "296-300",
          "snippet": "static inline void\naffs_unlock_dir(struct inode *inode)\n{\n\tup(&AFFS_I(inode)->i_hash_lock);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define i_hash_lock i_ext_lock"
          ],
          "globals_used": [
            "extern void\tmode_to_prot(struct inode *inode);",
            "extern void\t\t\t affs_evict_inode(struct inode *inode);",
            "void\t\taffs_free_prealloc(struct inode *inode);",
            "extern void\taffs_truncate(struct inode *);",
            "extern void   affs_dir_truncate(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\n#define i_hash_lock i_ext_lock\n\nextern void\tmode_to_prot(struct inode *inode);\nextern void\t\t\t affs_evict_inode(struct inode *inode);\nvoid\t\taffs_free_prealloc(struct inode *inode);\nextern void\taffs_truncate(struct inode *);\nextern void   affs_dir_truncate(struct inode *);\n\nstatic inline void\naffs_unlock_dir(struct inode *inode)\n{\n\tup(&AFFS_I(inode)->i_hash_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_find_entry",
          "args": [
            "dir",
            "dentry"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "affs_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/namei.c",
          "lines": "186-213",
          "snippet": "static struct buffer_head *\naffs_find_entry(struct inode *dir, struct dentry *dentry)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct buffer_head *bh;\n\ttoupper_t toupper = affs_get_toupper(sb);\n\tu32 key;\n\n\tpr_debug(\"%s(\\\"%pd\\\")\\n\", __func__, dentry);\n\n\tbh = affs_bread(sb, dir->i_ino);\n\tif (!bh)\n\t\treturn ERR_PTR(-EIO);\n\n\tkey = be32_to_cpu(AFFS_HEAD(bh)->table[affs_hash_name(sb, dentry->d_name.name, dentry->d_name.len)]);\n\n\tfor (;;) {\n\t\taffs_brelse(bh);\n\t\tif (key == 0)\n\t\t\treturn NULL;\n\t\tbh = affs_bread(sb, key);\n\t\tif (!bh)\n\t\t\treturn ERR_PTR(-EIO);\n\t\tif (affs_match(dentry, AFFS_TAIL(sb, bh)->name, toupper))\n\t\t\treturn bh;\n\t\tkey = be32_to_cpu(AFFS_TAIL(sb, bh)->hash_chain);\n\t}\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int       affs_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);",
            "static int       affs_intl_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nstatic int       affs_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\nstatic int       affs_intl_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\n\nstatic struct buffer_head *\naffs_find_entry(struct inode *dir, struct dentry *dentry)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct buffer_head *bh;\n\ttoupper_t toupper = affs_get_toupper(sb);\n\tu32 key;\n\n\tpr_debug(\"%s(\\\"%pd\\\")\\n\", __func__, dentry);\n\n\tbh = affs_bread(sb, dir->i_ino);\n\tif (!bh)\n\t\treturn ERR_PTR(-EIO);\n\n\tkey = be32_to_cpu(AFFS_HEAD(bh)->table[affs_hash_name(sb, dentry->d_name.name, dentry->d_name.len)]);\n\n\tfor (;;) {\n\t\taffs_brelse(bh);\n\t\tif (key == 0)\n\t\t\treturn NULL;\n\t\tbh = affs_bread(sb, key);\n\t\tif (!bh)\n\t\t\treturn ERR_PTR(-EIO);\n\t\tif (affs_match(dentry, AFFS_TAIL(sb, bh)->name, toupper))\n\t\t\treturn bh;\n\t\tkey = be32_to_cpu(AFFS_TAIL(sb, bh)->hash_chain);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_lock_dir",
          "args": [
            "dir"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "affs_lock_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "291-295",
          "snippet": "static inline void\naffs_lock_dir(struct inode *inode)\n{\n\tdown(&AFFS_I(inode)->i_hash_lock);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define i_hash_lock i_ext_lock"
          ],
          "globals_used": [
            "extern void\tmode_to_prot(struct inode *inode);",
            "extern void\t\t\t affs_evict_inode(struct inode *inode);",
            "void\t\taffs_free_prealloc(struct inode *inode);",
            "extern void\taffs_truncate(struct inode *);",
            "extern void   affs_dir_truncate(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\n#define i_hash_lock i_ext_lock\n\nextern void\tmode_to_prot(struct inode *inode);\nextern void\t\t\t affs_evict_inode(struct inode *inode);\nvoid\t\taffs_free_prealloc(struct inode *inode);\nextern void\taffs_truncate(struct inode *);\nextern void   affs_dir_truncate(struct inode *);\n\nstatic inline void\naffs_lock_dir(struct inode *inode)\n{\n\tdown(&AFFS_I(inode)->i_hash_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s(\\\"%pd\\\")\\n\"",
            "__func__",
            "dentry"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n\nstruct dentry *\naffs_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct buffer_head *bh;\n\tstruct inode *inode = NULL;\n\n\tpr_debug(\"%s(\\\"%pd\\\")\\n\", __func__, dentry);\n\n\taffs_lock_dir(dir);\n\tbh = affs_find_entry(dir, dentry);\n\taffs_unlock_dir(dir);\n\tif (IS_ERR(bh))\n\t\treturn ERR_CAST(bh);\n\tif (bh) {\n\t\tu32 ino = bh->b_blocknr;\n\n\t\t/* store the real header ino in d_fsdata for faster lookups */\n\t\tdentry->d_fsdata = (void *)(long)ino;\n\t\tswitch (be32_to_cpu(AFFS_TAIL(sb, bh)->stype)) {\n\t\t//link to dirs disabled\n\t\t//case ST_LINKDIR:\n\t\tcase ST_LINKFILE:\n\t\t\tino = be32_to_cpu(AFFS_TAIL(sb, bh)->original);\n\t\t}\n\t\taffs_brelse(bh);\n\t\tinode = affs_iget(sb, ino);\n\t\tif (IS_ERR(inode))\n\t\t\treturn ERR_CAST(inode);\n\t}\n\td_add(dentry, inode);\n\treturn NULL;\n}"
  },
  {
    "function_name": "affs_find_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/namei.c",
    "lines": "186-213",
    "snippet": "static struct buffer_head *\naffs_find_entry(struct inode *dir, struct dentry *dentry)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct buffer_head *bh;\n\ttoupper_t toupper = affs_get_toupper(sb);\n\tu32 key;\n\n\tpr_debug(\"%s(\\\"%pd\\\")\\n\", __func__, dentry);\n\n\tbh = affs_bread(sb, dir->i_ino);\n\tif (!bh)\n\t\treturn ERR_PTR(-EIO);\n\n\tkey = be32_to_cpu(AFFS_HEAD(bh)->table[affs_hash_name(sb, dentry->d_name.name, dentry->d_name.len)]);\n\n\tfor (;;) {\n\t\taffs_brelse(bh);\n\t\tif (key == 0)\n\t\t\treturn NULL;\n\t\tbh = affs_bread(sb, key);\n\t\tif (!bh)\n\t\t\treturn ERR_PTR(-EIO);\n\t\tif (affs_match(dentry, AFFS_TAIL(sb, bh)->name, toupper))\n\t\t\treturn bh;\n\t\tkey = be32_to_cpu(AFFS_TAIL(sb, bh)->hash_chain);\n\t}\n}",
    "includes": [
      "#include \"affs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int       affs_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);",
      "static int       affs_intl_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "AFFS_TAIL(sb, bh)->hash_chain"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_TAIL",
          "args": [
            "sb",
            "bh"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_match",
          "args": [
            "dentry",
            "AFFS_TAIL(sb, bh)->name",
            "toupper"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "affs_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/namei.c",
          "lines": "154-171",
          "snippet": "static inline int\naffs_match(struct dentry *dentry, const u8 *name2, toupper_t toupper)\n{\n\tconst u8 *name = dentry->d_name.name;\n\tint len = dentry->d_name.len;\n\n\tif (len >= AFFSNAMEMAX) {\n\t\tif (*name2 < AFFSNAMEMAX)\n\t\t\treturn 0;\n\t\tlen = AFFSNAMEMAX;\n\t} else if (len != *name2)\n\t\treturn 0;\n\n\tfor (name2++; len > 0; len--)\n\t\tif (toupper(*name++) != toupper(*name2++))\n\t\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int       affs_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);",
            "static int       affs_intl_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nstatic int       affs_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\nstatic int       affs_intl_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\n\nstatic inline int\naffs_match(struct dentry *dentry, const u8 *name2, toupper_t toupper)\n{\n\tconst u8 *name = dentry->d_name.name;\n\tint len = dentry->d_name.len;\n\n\tif (len >= AFFSNAMEMAX) {\n\t\tif (*name2 < AFFSNAMEMAX)\n\t\t\treturn 0;\n\t\tlen = AFFSNAMEMAX;\n\t} else if (len != *name2)\n\t\treturn 0;\n\n\tfor (name2++; len > 0; len--)\n\t\tif (toupper(*name++) != toupper(*name2++))\n\t\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFFS_TAIL",
          "args": [
            "sb",
            "bh"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_bread",
          "args": [
            "sb",
            "key"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "affs_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "216-223",
          "snippet": "static inline struct buffer_head *\naffs_bread(struct super_block *sb, int block)\n{\n\tpr_debug(\"%s: %d\\n\", __func__, block);\n\tif (block >= AFFS_SB(sb)->s_reserved && block < AFFS_SB(sb)->s_partition_size)\n\t\treturn sb_bread(sb, block);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void affs_mark_sb_dirty(struct super_block *sb);",
            "extern u32\taffs_count_free_blocks(struct super_block *s);",
            "extern void\taffs_free_block(struct super_block *sb, u32 block);",
            "extern void\taffs_free_bitmap(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb);\nextern u32\taffs_count_free_blocks(struct super_block *s);\nextern void\taffs_free_block(struct super_block *sb, u32 block);\nextern void\taffs_free_bitmap(struct super_block *sb);\n\nstatic inline struct buffer_head *\naffs_bread(struct super_block *sb, int block)\n{\n\tpr_debug(\"%s: %d\\n\", __func__, block);\n\tif (block >= AFFS_SB(sb)->s_reserved && block < AFFS_SB(sb)->s_partition_size)\n\t\treturn sb_bread(sb, block);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_brelse",
          "args": [
            "bh"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "affs_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "260-266",
          "snippet": "static inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);",
            "extern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);",
            "extern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);",
            "extern u32\taffs_count_free_blocks(struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);\nextern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);\nextern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);\nextern u32\taffs_count_free_blocks(struct super_block *s);\n\nstatic inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "AFFS_HEAD(bh)->table[affs_hash_name(sb, dentry->d_name.name, dentry->d_name.len)]"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_hash_name",
          "args": [
            "sb",
            "dentry->d_name.name",
            "dentry->d_name.len"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "affs_hash_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/namei.c",
          "lines": "173-184",
          "snippet": "int\naffs_hash_name(struct super_block *sb, const u8 *name, unsigned int len)\n{\n\ttoupper_t toupper = affs_get_toupper(sb);\n\tu32 hash;\n\n\thash = len = min(len, AFFSNAMEMAX);\n\tfor (; len > 0; len--)\n\t\thash = (hash * 13 + toupper(*name++)) & 0x7ff;\n\n\treturn hash % AFFS_SB(sb)->s_hashsize;\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int       affs_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);",
            "static int       affs_intl_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nstatic int       affs_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\nstatic int       affs_intl_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\n\nint\naffs_hash_name(struct super_block *sb, const u8 *name, unsigned int len)\n{\n\ttoupper_t toupper = affs_get_toupper(sb);\n\tu32 hash;\n\n\thash = len = min(len, AFFSNAMEMAX);\n\tfor (; len > 0; len--)\n\t\thash = (hash * 13 + toupper(*name++)) & 0x7ff;\n\n\treturn hash % AFFS_SB(sb)->s_hashsize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFFS_HEAD",
          "args": [
            "bh"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s(\\\"%pd\\\")\\n\"",
            "__func__",
            "dentry"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_get_toupper",
          "args": [
            "sb"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "affs_get_toupper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/namei.c",
          "lines": "53-57",
          "snippet": "static inline toupper_t\naffs_get_toupper(struct super_block *sb)\n{\n\treturn AFFS_SB(sb)->s_flags & SF_INTL ? affs_intl_toupper : affs_toupper;\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nstatic inline toupper_t\naffs_get_toupper(struct super_block *sb)\n{\n\treturn AFFS_SB(sb)->s_flags & SF_INTL ? affs_intl_toupper : affs_toupper;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n\nstatic int       affs_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\nstatic int       affs_intl_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\n\nstatic struct buffer_head *\naffs_find_entry(struct inode *dir, struct dentry *dentry)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct buffer_head *bh;\n\ttoupper_t toupper = affs_get_toupper(sb);\n\tu32 key;\n\n\tpr_debug(\"%s(\\\"%pd\\\")\\n\", __func__, dentry);\n\n\tbh = affs_bread(sb, dir->i_ino);\n\tif (!bh)\n\t\treturn ERR_PTR(-EIO);\n\n\tkey = be32_to_cpu(AFFS_HEAD(bh)->table[affs_hash_name(sb, dentry->d_name.name, dentry->d_name.len)]);\n\n\tfor (;;) {\n\t\taffs_brelse(bh);\n\t\tif (key == 0)\n\t\t\treturn NULL;\n\t\tbh = affs_bread(sb, key);\n\t\tif (!bh)\n\t\t\treturn ERR_PTR(-EIO);\n\t\tif (affs_match(dentry, AFFS_TAIL(sb, bh)->name, toupper))\n\t\t\treturn bh;\n\t\tkey = be32_to_cpu(AFFS_TAIL(sb, bh)->hash_chain);\n\t}\n}"
  },
  {
    "function_name": "affs_hash_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/namei.c",
    "lines": "173-184",
    "snippet": "int\naffs_hash_name(struct super_block *sb, const u8 *name, unsigned int len)\n{\n\ttoupper_t toupper = affs_get_toupper(sb);\n\tu32 hash;\n\n\thash = len = min(len, AFFSNAMEMAX);\n\tfor (; len > 0; len--)\n\t\thash = (hash * 13 + toupper(*name++)) & 0x7ff;\n\n\treturn hash % AFFS_SB(sb)->s_hashsize;\n}",
    "includes": [
      "#include \"affs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int       affs_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);",
      "static int       affs_intl_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AFFS_SB",
          "args": [
            "sb"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "AFFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "123-126",
          "snippet": "static inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void affs_mark_sb_dirty(struct super_block *sb);",
            "extern void\taffs_free_bitmap(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb);\nextern void\taffs_free_bitmap(struct super_block *sb);\n\nstatic inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "toupper",
          "args": [
            "*name++"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "affs_get_toupper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/namei.c",
          "lines": "53-57",
          "snippet": "static inline toupper_t\naffs_get_toupper(struct super_block *sb)\n{\n\treturn AFFS_SB(sb)->s_flags & SF_INTL ? affs_intl_toupper : affs_toupper;\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nstatic inline toupper_t\naffs_get_toupper(struct super_block *sb)\n{\n\treturn AFFS_SB(sb)->s_flags & SF_INTL ? affs_intl_toupper : affs_toupper;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "len",
            "AFFSNAMEMAX"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "minix_rmdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/namei.c",
          "lines": "172-185",
          "snippet": "static int minix_rmdir(struct inode * dir, struct dentry *dentry)\n{\n\tstruct inode * inode = dentry->d_inode;\n\tint err = -ENOTEMPTY;\n\n\tif (minix_empty_dir(inode)) {\n\t\terr = minix_unlink(dir, dentry);\n\t\tif (!err) {\n\t\t\tinode_dec_link_count(dir);\n\t\t\tinode_dec_link_count(inode);\n\t\t}\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"minix.h\"\n\nstatic int minix_rmdir(struct inode * dir, struct dentry *dentry)\n{\n\tstruct inode * inode = dentry->d_inode;\n\tint err = -ENOTEMPTY;\n\n\tif (minix_empty_dir(inode)) {\n\t\terr = minix_unlink(dir, dentry);\n\t\tif (!err) {\n\t\t\tinode_dec_link_count(dir);\n\t\t\tinode_dec_link_count(inode);\n\t\t}\n\t}\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n\nstatic int       affs_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\nstatic int       affs_intl_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\n\nint\naffs_hash_name(struct super_block *sb, const u8 *name, unsigned int len)\n{\n\ttoupper_t toupper = affs_get_toupper(sb);\n\tu32 hash;\n\n\thash = len = min(len, AFFSNAMEMAX);\n\tfor (; len > 0; len--)\n\t\thash = (hash * 13 + toupper(*name++)) & 0x7ff;\n\n\treturn hash % AFFS_SB(sb)->s_hashsize;\n}"
  },
  {
    "function_name": "affs_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/namei.c",
    "lines": "154-171",
    "snippet": "static inline int\naffs_match(struct dentry *dentry, const u8 *name2, toupper_t toupper)\n{\n\tconst u8 *name = dentry->d_name.name;\n\tint len = dentry->d_name.len;\n\n\tif (len >= AFFSNAMEMAX) {\n\t\tif (*name2 < AFFSNAMEMAX)\n\t\t\treturn 0;\n\t\tlen = AFFSNAMEMAX;\n\t} else if (len != *name2)\n\t\treturn 0;\n\n\tfor (name2++; len > 0; len--)\n\t\tif (toupper(*name++) != toupper(*name2++))\n\t\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"affs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int       affs_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);",
      "static int       affs_intl_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "toupper",
          "args": [
            "*name2++"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "affs_get_toupper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/namei.c",
          "lines": "53-57",
          "snippet": "static inline toupper_t\naffs_get_toupper(struct super_block *sb)\n{\n\treturn AFFS_SB(sb)->s_flags & SF_INTL ? affs_intl_toupper : affs_toupper;\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nstatic inline toupper_t\naffs_get_toupper(struct super_block *sb)\n{\n\treturn AFFS_SB(sb)->s_flags & SF_INTL ? affs_intl_toupper : affs_toupper;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n\nstatic int       affs_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\nstatic int       affs_intl_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\n\nstatic inline int\naffs_match(struct dentry *dentry, const u8 *name2, toupper_t toupper)\n{\n\tconst u8 *name = dentry->d_name.name;\n\tint len = dentry->d_name.len;\n\n\tif (len >= AFFSNAMEMAX) {\n\t\tif (*name2 < AFFSNAMEMAX)\n\t\t\treturn 0;\n\t\tlen = AFFSNAMEMAX;\n\t} else if (len != *name2)\n\t\treturn 0;\n\n\tfor (name2++; len > 0; len--)\n\t\tif (toupper(*name++) != toupper(*name2++))\n\t\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "affs_intl_compare_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/namei.c",
    "lines": "141-148",
    "snippet": "static int\naffs_intl_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\treturn __affs_compare_dentry(len, str, name, affs_intl_toupper,\n\t\t\t\t     affs_nofilenametruncate(parent));\n\n}",
    "includes": [
      "#include \"affs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t affs_hash_dentry(const struct dentry *, struct qstr *);",
      "static int       affs_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);",
      "static int\t affs_intl_hash_dentry(const struct dentry *, struct qstr *);",
      "static int       affs_intl_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__affs_compare_dentry",
          "args": [
            "len",
            "str",
            "name",
            "affs_intl_toupper",
            "affs_nofilenametruncate(parent)"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "__affs_compare_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/namei.c",
          "lines": "99-130",
          "snippet": "static inline int __affs_compare_dentry(unsigned int len,\n\t\tconst char *str, const struct qstr *name, toupper_t toupper,\n\t\tbool notruncate)\n{\n\tconst u8 *aname = str;\n\tconst u8 *bname = name->name;\n\n\t/*\n\t * 'str' is the name of an already existing dentry, so the name\n\t * must be valid. 'name' must be validated first.\n\t */\n\n\tif (affs_check_name(name->name, name->len, notruncate))\n\t\treturn 1;\n\n\t/*\n\t * If the names are longer than the allowed 30 chars,\n\t * the excess is ignored, so their length may differ.\n\t */\n\tif (len >= AFFSNAMEMAX) {\n\t\tif (name->len < AFFSNAMEMAX)\n\t\t\treturn 1;\n\t\tlen = AFFSNAMEMAX;\n\t} else if (len != name->len)\n\t\treturn 1;\n\n\tfor (; len > 0; len--)\n\t\tif (toupper(*aname++) != toupper(*bname++))\n\t\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t affs_hash_dentry(const struct dentry *, struct qstr *);",
            "static int       affs_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);",
            "static int\t affs_intl_hash_dentry(const struct dentry *, struct qstr *);",
            "static int       affs_intl_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nstatic int\t affs_hash_dentry(const struct dentry *, struct qstr *);\nstatic int       affs_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\nstatic int\t affs_intl_hash_dentry(const struct dentry *, struct qstr *);\nstatic int       affs_intl_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\n\nstatic inline int __affs_compare_dentry(unsigned int len,\n\t\tconst char *str, const struct qstr *name, toupper_t toupper,\n\t\tbool notruncate)\n{\n\tconst u8 *aname = str;\n\tconst u8 *bname = name->name;\n\n\t/*\n\t * 'str' is the name of an already existing dentry, so the name\n\t * must be valid. 'name' must be validated first.\n\t */\n\n\tif (affs_check_name(name->name, name->len, notruncate))\n\t\treturn 1;\n\n\t/*\n\t * If the names are longer than the allowed 30 chars,\n\t * the excess is ignored, so their length may differ.\n\t */\n\tif (len >= AFFSNAMEMAX) {\n\t\tif (name->len < AFFSNAMEMAX)\n\t\t\treturn 1;\n\t\tlen = AFFSNAMEMAX;\n\t} else if (len != name->len)\n\t\treturn 1;\n\n\tfor (; len > 0; len--)\n\t\tif (toupper(*aname++) != toupper(*bname++))\n\t\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_nofilenametruncate",
          "args": [
            "parent"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "affs_nofilenametruncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "471-477",
          "snippet": "bool\naffs_nofilenametruncate(const struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\treturn AFFS_SB(inode->i_sb)->s_flags & SF_NO_TRUNCATE;\n\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nbool\naffs_nofilenametruncate(const struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\treturn AFFS_SB(inode->i_sb)->s_flags & SF_NO_TRUNCATE;\n\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n\nstatic int\t affs_hash_dentry(const struct dentry *, struct qstr *);\nstatic int       affs_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\nstatic int\t affs_intl_hash_dentry(const struct dentry *, struct qstr *);\nstatic int       affs_intl_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\n\nstatic int\naffs_intl_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\treturn __affs_compare_dentry(len, str, name, affs_intl_toupper,\n\t\t\t\t     affs_nofilenametruncate(parent));\n\n}"
  },
  {
    "function_name": "affs_compare_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/namei.c",
    "lines": "132-139",
    "snippet": "static int\naffs_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\n\treturn __affs_compare_dentry(len, str, name, affs_toupper,\n\t\t\t\t     affs_nofilenametruncate(parent));\n}",
    "includes": [
      "#include \"affs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t affs_hash_dentry(const struct dentry *, struct qstr *);",
      "static int       affs_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);",
      "static int\t affs_intl_hash_dentry(const struct dentry *, struct qstr *);",
      "static int       affs_intl_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__affs_compare_dentry",
          "args": [
            "len",
            "str",
            "name",
            "affs_toupper",
            "affs_nofilenametruncate(parent)"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "__affs_compare_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/namei.c",
          "lines": "99-130",
          "snippet": "static inline int __affs_compare_dentry(unsigned int len,\n\t\tconst char *str, const struct qstr *name, toupper_t toupper,\n\t\tbool notruncate)\n{\n\tconst u8 *aname = str;\n\tconst u8 *bname = name->name;\n\n\t/*\n\t * 'str' is the name of an already existing dentry, so the name\n\t * must be valid. 'name' must be validated first.\n\t */\n\n\tif (affs_check_name(name->name, name->len, notruncate))\n\t\treturn 1;\n\n\t/*\n\t * If the names are longer than the allowed 30 chars,\n\t * the excess is ignored, so their length may differ.\n\t */\n\tif (len >= AFFSNAMEMAX) {\n\t\tif (name->len < AFFSNAMEMAX)\n\t\t\treturn 1;\n\t\tlen = AFFSNAMEMAX;\n\t} else if (len != name->len)\n\t\treturn 1;\n\n\tfor (; len > 0; len--)\n\t\tif (toupper(*aname++) != toupper(*bname++))\n\t\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t affs_hash_dentry(const struct dentry *, struct qstr *);",
            "static int       affs_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);",
            "static int\t affs_intl_hash_dentry(const struct dentry *, struct qstr *);",
            "static int       affs_intl_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nstatic int\t affs_hash_dentry(const struct dentry *, struct qstr *);\nstatic int       affs_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\nstatic int\t affs_intl_hash_dentry(const struct dentry *, struct qstr *);\nstatic int       affs_intl_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\n\nstatic inline int __affs_compare_dentry(unsigned int len,\n\t\tconst char *str, const struct qstr *name, toupper_t toupper,\n\t\tbool notruncate)\n{\n\tconst u8 *aname = str;\n\tconst u8 *bname = name->name;\n\n\t/*\n\t * 'str' is the name of an already existing dentry, so the name\n\t * must be valid. 'name' must be validated first.\n\t */\n\n\tif (affs_check_name(name->name, name->len, notruncate))\n\t\treturn 1;\n\n\t/*\n\t * If the names are longer than the allowed 30 chars,\n\t * the excess is ignored, so their length may differ.\n\t */\n\tif (len >= AFFSNAMEMAX) {\n\t\tif (name->len < AFFSNAMEMAX)\n\t\t\treturn 1;\n\t\tlen = AFFSNAMEMAX;\n\t} else if (len != name->len)\n\t\treturn 1;\n\n\tfor (; len > 0; len--)\n\t\tif (toupper(*aname++) != toupper(*bname++))\n\t\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_nofilenametruncate",
          "args": [
            "parent"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "affs_nofilenametruncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "471-477",
          "snippet": "bool\naffs_nofilenametruncate(const struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\treturn AFFS_SB(inode->i_sb)->s_flags & SF_NO_TRUNCATE;\n\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nbool\naffs_nofilenametruncate(const struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\treturn AFFS_SB(inode->i_sb)->s_flags & SF_NO_TRUNCATE;\n\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n\nstatic int\t affs_hash_dentry(const struct dentry *, struct qstr *);\nstatic int       affs_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\nstatic int\t affs_intl_hash_dentry(const struct dentry *, struct qstr *);\nstatic int       affs_intl_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\n\nstatic int\naffs_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\n\treturn __affs_compare_dentry(len, str, name, affs_toupper,\n\t\t\t\t     affs_nofilenametruncate(parent));\n}"
  },
  {
    "function_name": "__affs_compare_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/namei.c",
    "lines": "99-130",
    "snippet": "static inline int __affs_compare_dentry(unsigned int len,\n\t\tconst char *str, const struct qstr *name, toupper_t toupper,\n\t\tbool notruncate)\n{\n\tconst u8 *aname = str;\n\tconst u8 *bname = name->name;\n\n\t/*\n\t * 'str' is the name of an already existing dentry, so the name\n\t * must be valid. 'name' must be validated first.\n\t */\n\n\tif (affs_check_name(name->name, name->len, notruncate))\n\t\treturn 1;\n\n\t/*\n\t * If the names are longer than the allowed 30 chars,\n\t * the excess is ignored, so their length may differ.\n\t */\n\tif (len >= AFFSNAMEMAX) {\n\t\tif (name->len < AFFSNAMEMAX)\n\t\t\treturn 1;\n\t\tlen = AFFSNAMEMAX;\n\t} else if (len != name->len)\n\t\treturn 1;\n\n\tfor (; len > 0; len--)\n\t\tif (toupper(*aname++) != toupper(*bname++))\n\t\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"affs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t affs_hash_dentry(const struct dentry *, struct qstr *);",
      "static int       affs_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);",
      "static int\t affs_intl_hash_dentry(const struct dentry *, struct qstr *);",
      "static int       affs_intl_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "toupper",
          "args": [
            "*bname++"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "affs_get_toupper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/namei.c",
          "lines": "53-57",
          "snippet": "static inline toupper_t\naffs_get_toupper(struct super_block *sb)\n{\n\treturn AFFS_SB(sb)->s_flags & SF_INTL ? affs_intl_toupper : affs_toupper;\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nstatic inline toupper_t\naffs_get_toupper(struct super_block *sb)\n{\n\treturn AFFS_SB(sb)->s_flags & SF_INTL ? affs_intl_toupper : affs_toupper;\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_check_name",
          "args": [
            "name->name",
            "name->len",
            "notruncate"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "affs_check_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "481-498",
          "snippet": "int\naffs_check_name(const unsigned char *name, int len, bool notruncate)\n{\n\tint\t i;\n\n\tif (len > AFFSNAMEMAX) {\n\t\tif (notruncate)\n\t\t\treturn -ENAMETOOLONG;\n\t\tlen = AFFSNAMEMAX;\n\t}\n\tfor (i = 0; i < len; i++) {\n\t\tif (name[i] < ' ' || name[i] == ':'\n\t\t    || (name[i] > 0x7e && name[i] < 0xa0))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nint\naffs_check_name(const unsigned char *name, int len, bool notruncate)\n{\n\tint\t i;\n\n\tif (len > AFFSNAMEMAX) {\n\t\tif (notruncate)\n\t\t\treturn -ENAMETOOLONG;\n\t\tlen = AFFSNAMEMAX;\n\t}\n\tfor (i = 0; i < len; i++) {\n\t\tif (name[i] < ' ' || name[i] == ':'\n\t\t    || (name[i] > 0x7e && name[i] < 0xa0))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n\nstatic int\t affs_hash_dentry(const struct dentry *, struct qstr *);\nstatic int       affs_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\nstatic int\t affs_intl_hash_dentry(const struct dentry *, struct qstr *);\nstatic int       affs_intl_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\n\nstatic inline int __affs_compare_dentry(unsigned int len,\n\t\tconst char *str, const struct qstr *name, toupper_t toupper,\n\t\tbool notruncate)\n{\n\tconst u8 *aname = str;\n\tconst u8 *bname = name->name;\n\n\t/*\n\t * 'str' is the name of an already existing dentry, so the name\n\t * must be valid. 'name' must be validated first.\n\t */\n\n\tif (affs_check_name(name->name, name->len, notruncate))\n\t\treturn 1;\n\n\t/*\n\t * If the names are longer than the allowed 30 chars,\n\t * the excess is ignored, so their length may differ.\n\t */\n\tif (len >= AFFSNAMEMAX) {\n\t\tif (name->len < AFFSNAMEMAX)\n\t\t\treturn 1;\n\t\tlen = AFFSNAMEMAX;\n\t} else if (len != name->len)\n\t\treturn 1;\n\n\tfor (; len > 0; len--)\n\t\tif (toupper(*aname++) != toupper(*bname++))\n\t\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "affs_intl_hash_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/namei.c",
    "lines": "91-97",
    "snippet": "static int\naffs_intl_hash_dentry(const struct dentry *dentry, struct qstr *qstr)\n{\n\treturn __affs_hash_dentry(qstr, affs_intl_toupper,\n\t\t\t\t  affs_nofilenametruncate(dentry));\n\n}",
    "includes": [
      "#include \"affs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t affs_hash_dentry(const struct dentry *, struct qstr *);",
      "static int\t affs_intl_hash_dentry(const struct dentry *, struct qstr *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__affs_hash_dentry",
          "args": [
            "qstr",
            "affs_intl_toupper",
            "affs_nofilenametruncate(dentry)"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "__affs_hash_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/namei.c",
          "lines": "62-81",
          "snippet": "static inline int\n__affs_hash_dentry(struct qstr *qstr, toupper_t toupper, bool notruncate)\n{\n\tconst u8 *name = qstr->name;\n\tunsigned long hash;\n\tint retval;\n\tu32 len;\n\n\tretval = affs_check_name(qstr->name, qstr->len, notruncate);\n\tif (retval)\n\t\treturn retval;\n\n\thash = init_name_hash();\n\tlen = min(qstr->len, AFFSNAMEMAX);\n\tfor (; len > 0; name++, len--)\n\t\thash = partial_name_hash(toupper(*name), hash);\n\tqstr->hash = end_name_hash(hash);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t affs_hash_dentry(const struct dentry *, struct qstr *);",
            "static int       affs_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);",
            "static int\t affs_intl_hash_dentry(const struct dentry *, struct qstr *);",
            "static int       affs_intl_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nstatic int\t affs_hash_dentry(const struct dentry *, struct qstr *);\nstatic int       affs_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\nstatic int\t affs_intl_hash_dentry(const struct dentry *, struct qstr *);\nstatic int       affs_intl_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\n\nstatic inline int\n__affs_hash_dentry(struct qstr *qstr, toupper_t toupper, bool notruncate)\n{\n\tconst u8 *name = qstr->name;\n\tunsigned long hash;\n\tint retval;\n\tu32 len;\n\n\tretval = affs_check_name(qstr->name, qstr->len, notruncate);\n\tif (retval)\n\t\treturn retval;\n\n\thash = init_name_hash();\n\tlen = min(qstr->len, AFFSNAMEMAX);\n\tfor (; len > 0; name++, len--)\n\t\thash = partial_name_hash(toupper(*name), hash);\n\tqstr->hash = end_name_hash(hash);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_nofilenametruncate",
          "args": [
            "dentry"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "affs_nofilenametruncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "471-477",
          "snippet": "bool\naffs_nofilenametruncate(const struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\treturn AFFS_SB(inode->i_sb)->s_flags & SF_NO_TRUNCATE;\n\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nbool\naffs_nofilenametruncate(const struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\treturn AFFS_SB(inode->i_sb)->s_flags & SF_NO_TRUNCATE;\n\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n\nstatic int\t affs_hash_dentry(const struct dentry *, struct qstr *);\nstatic int\t affs_intl_hash_dentry(const struct dentry *, struct qstr *);\n\nstatic int\naffs_intl_hash_dentry(const struct dentry *dentry, struct qstr *qstr)\n{\n\treturn __affs_hash_dentry(qstr, affs_intl_toupper,\n\t\t\t\t  affs_nofilenametruncate(dentry));\n\n}"
  },
  {
    "function_name": "affs_hash_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/namei.c",
    "lines": "83-89",
    "snippet": "static int\naffs_hash_dentry(const struct dentry *dentry, struct qstr *qstr)\n{\n\treturn __affs_hash_dentry(qstr, affs_toupper,\n\t\t\t\t  affs_nofilenametruncate(dentry));\n\n}",
    "includes": [
      "#include \"affs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t affs_hash_dentry(const struct dentry *, struct qstr *);",
      "static int\t affs_intl_hash_dentry(const struct dentry *, struct qstr *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__affs_hash_dentry",
          "args": [
            "qstr",
            "affs_toupper",
            "affs_nofilenametruncate(dentry)"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "__affs_hash_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/namei.c",
          "lines": "62-81",
          "snippet": "static inline int\n__affs_hash_dentry(struct qstr *qstr, toupper_t toupper, bool notruncate)\n{\n\tconst u8 *name = qstr->name;\n\tunsigned long hash;\n\tint retval;\n\tu32 len;\n\n\tretval = affs_check_name(qstr->name, qstr->len, notruncate);\n\tif (retval)\n\t\treturn retval;\n\n\thash = init_name_hash();\n\tlen = min(qstr->len, AFFSNAMEMAX);\n\tfor (; len > 0; name++, len--)\n\t\thash = partial_name_hash(toupper(*name), hash);\n\tqstr->hash = end_name_hash(hash);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t affs_hash_dentry(const struct dentry *, struct qstr *);",
            "static int       affs_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);",
            "static int\t affs_intl_hash_dentry(const struct dentry *, struct qstr *);",
            "static int       affs_intl_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nstatic int\t affs_hash_dentry(const struct dentry *, struct qstr *);\nstatic int       affs_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\nstatic int\t affs_intl_hash_dentry(const struct dentry *, struct qstr *);\nstatic int       affs_intl_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\n\nstatic inline int\n__affs_hash_dentry(struct qstr *qstr, toupper_t toupper, bool notruncate)\n{\n\tconst u8 *name = qstr->name;\n\tunsigned long hash;\n\tint retval;\n\tu32 len;\n\n\tretval = affs_check_name(qstr->name, qstr->len, notruncate);\n\tif (retval)\n\t\treturn retval;\n\n\thash = init_name_hash();\n\tlen = min(qstr->len, AFFSNAMEMAX);\n\tfor (; len > 0; name++, len--)\n\t\thash = partial_name_hash(toupper(*name), hash);\n\tqstr->hash = end_name_hash(hash);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_nofilenametruncate",
          "args": [
            "dentry"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "affs_nofilenametruncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "471-477",
          "snippet": "bool\naffs_nofilenametruncate(const struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\treturn AFFS_SB(inode->i_sb)->s_flags & SF_NO_TRUNCATE;\n\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nbool\naffs_nofilenametruncate(const struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\treturn AFFS_SB(inode->i_sb)->s_flags & SF_NO_TRUNCATE;\n\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n\nstatic int\t affs_hash_dentry(const struct dentry *, struct qstr *);\nstatic int\t affs_intl_hash_dentry(const struct dentry *, struct qstr *);\n\nstatic int\naffs_hash_dentry(const struct dentry *dentry, struct qstr *qstr)\n{\n\treturn __affs_hash_dentry(qstr, affs_toupper,\n\t\t\t\t  affs_nofilenametruncate(dentry));\n\n}"
  },
  {
    "function_name": "__affs_hash_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/namei.c",
    "lines": "62-81",
    "snippet": "static inline int\n__affs_hash_dentry(struct qstr *qstr, toupper_t toupper, bool notruncate)\n{\n\tconst u8 *name = qstr->name;\n\tunsigned long hash;\n\tint retval;\n\tu32 len;\n\n\tretval = affs_check_name(qstr->name, qstr->len, notruncate);\n\tif (retval)\n\t\treturn retval;\n\n\thash = init_name_hash();\n\tlen = min(qstr->len, AFFSNAMEMAX);\n\tfor (; len > 0; name++, len--)\n\t\thash = partial_name_hash(toupper(*name), hash);\n\tqstr->hash = end_name_hash(hash);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"affs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t affs_hash_dentry(const struct dentry *, struct qstr *);",
      "static int       affs_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);",
      "static int\t affs_intl_hash_dentry(const struct dentry *, struct qstr *);",
      "static int       affs_intl_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "end_name_hash",
          "args": [
            "hash"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "partial_name_hash",
          "args": [
            "toupper(*name)",
            "hash"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "toupper",
          "args": [
            "*name"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "affs_get_toupper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/namei.c",
          "lines": "53-57",
          "snippet": "static inline toupper_t\naffs_get_toupper(struct super_block *sb)\n{\n\treturn AFFS_SB(sb)->s_flags & SF_INTL ? affs_intl_toupper : affs_toupper;\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nstatic inline toupper_t\naffs_get_toupper(struct super_block *sb)\n{\n\treturn AFFS_SB(sb)->s_flags & SF_INTL ? affs_intl_toupper : affs_toupper;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "qstr->len",
            "AFFSNAMEMAX"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "minix_rmdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/namei.c",
          "lines": "172-185",
          "snippet": "static int minix_rmdir(struct inode * dir, struct dentry *dentry)\n{\n\tstruct inode * inode = dentry->d_inode;\n\tint err = -ENOTEMPTY;\n\n\tif (minix_empty_dir(inode)) {\n\t\terr = minix_unlink(dir, dentry);\n\t\tif (!err) {\n\t\t\tinode_dec_link_count(dir);\n\t\t\tinode_dec_link_count(inode);\n\t\t}\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"minix.h\"\n\nstatic int minix_rmdir(struct inode * dir, struct dentry *dentry)\n{\n\tstruct inode * inode = dentry->d_inode;\n\tint err = -ENOTEMPTY;\n\n\tif (minix_empty_dir(inode)) {\n\t\terr = minix_unlink(dir, dentry);\n\t\tif (!err) {\n\t\t\tinode_dec_link_count(dir);\n\t\t\tinode_dec_link_count(inode);\n\t\t}\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_name_hash",
          "args": [],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_check_name",
          "args": [
            "qstr->name",
            "qstr->len",
            "notruncate"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "affs_check_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "481-498",
          "snippet": "int\naffs_check_name(const unsigned char *name, int len, bool notruncate)\n{\n\tint\t i;\n\n\tif (len > AFFSNAMEMAX) {\n\t\tif (notruncate)\n\t\t\treturn -ENAMETOOLONG;\n\t\tlen = AFFSNAMEMAX;\n\t}\n\tfor (i = 0; i < len; i++) {\n\t\tif (name[i] < ' ' || name[i] == ':'\n\t\t    || (name[i] > 0x7e && name[i] < 0xa0))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nint\naffs_check_name(const unsigned char *name, int len, bool notruncate)\n{\n\tint\t i;\n\n\tif (len > AFFSNAMEMAX) {\n\t\tif (notruncate)\n\t\t\treturn -ENAMETOOLONG;\n\t\tlen = AFFSNAMEMAX;\n\t}\n\tfor (i = 0; i < len; i++) {\n\t\tif (name[i] < ' ' || name[i] == ':'\n\t\t    || (name[i] > 0x7e && name[i] < 0xa0))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n\nstatic int\t affs_hash_dentry(const struct dentry *, struct qstr *);\nstatic int       affs_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\nstatic int\t affs_intl_hash_dentry(const struct dentry *, struct qstr *);\nstatic int       affs_intl_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name);\n\nstatic inline int\n__affs_hash_dentry(struct qstr *qstr, toupper_t toupper, bool notruncate)\n{\n\tconst u8 *name = qstr->name;\n\tunsigned long hash;\n\tint retval;\n\tu32 len;\n\n\tretval = affs_check_name(qstr->name, qstr->len, notruncate);\n\tif (retval)\n\t\treturn retval;\n\n\thash = init_name_hash();\n\tlen = min(qstr->len, AFFSNAMEMAX);\n\tfor (; len > 0; name++, len--)\n\t\thash = partial_name_hash(toupper(*name), hash);\n\tqstr->hash = end_name_hash(hash);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "affs_get_toupper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/namei.c",
    "lines": "53-57",
    "snippet": "static inline toupper_t\naffs_get_toupper(struct super_block *sb)\n{\n\treturn AFFS_SB(sb)->s_flags & SF_INTL ? affs_intl_toupper : affs_toupper;\n}",
    "includes": [
      "#include \"affs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AFFS_SB",
          "args": [
            "sb"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "AFFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "123-126",
          "snippet": "static inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void affs_mark_sb_dirty(struct super_block *sb);",
            "extern void\taffs_free_bitmap(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb);\nextern void\taffs_free_bitmap(struct super_block *sb);\n\nstatic inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n\nstatic inline toupper_t\naffs_get_toupper(struct super_block *sb)\n{\n\treturn AFFS_SB(sb)->s_flags & SF_INTL ? affs_intl_toupper : affs_toupper;\n}"
  },
  {
    "function_name": "affs_intl_toupper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/namei.c",
    "lines": "45-51",
    "snippet": "static int\naffs_intl_toupper(int ch)\n{\n\treturn (ch >= 'a' && ch <= 'z') || (ch >= 0xE0\n\t\t&& ch <= 0xFE && ch != 0xF7) ?\n\t\tch - ('a' - 'A') : ch;\n}",
    "includes": [
      "#include \"affs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t affs_toupper(int ch);",
      "static int\t affs_intl_toupper(int ch);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"affs.h\"\n\nstatic int\t affs_toupper(int ch);\nstatic int\t affs_intl_toupper(int ch);\n\nstatic int\naffs_intl_toupper(int ch)\n{\n\treturn (ch >= 'a' && ch <= 'z') || (ch >= 0xE0\n\t\t&& ch <= 0xFE && ch != 0xF7) ?\n\t\tch - ('a' - 'A') : ch;\n}"
  },
  {
    "function_name": "affs_toupper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/namei.c",
    "lines": "37-41",
    "snippet": "static int\naffs_toupper(int ch)\n{\n\treturn ch >= 'a' && ch <= 'z' ? ch -= ('a' - 'A') : ch;\n}",
    "includes": [
      "#include \"affs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t affs_toupper(int ch);",
      "static int\t affs_intl_toupper(int ch);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"affs.h\"\n\nstatic int\t affs_toupper(int ch);\nstatic int\t affs_intl_toupper(int ch);\n\nstatic int\naffs_toupper(int ch)\n{\n\treturn ch >= 'a' && ch <= 'z' ? ch -= ('a' - 'A') : ch;\n}"
  }
]