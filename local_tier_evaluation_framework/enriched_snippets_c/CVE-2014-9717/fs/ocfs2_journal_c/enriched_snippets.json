[
  {
    "function_name": "ocfs2_check_journals_nolocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "2291-2323",
    "snippet": "int ocfs2_check_journals_nolocks(struct ocfs2_super *osb)\n{\n\tint ret = 0;\n\tunsigned int slot;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tint journal_dirty = 0;\n\n\tfor(slot = 0; slot < osb->max_slots; slot++) {\n\t\tret = ocfs2_read_journal_inode(osb, slot, &di_bh, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdi = (struct ocfs2_dinode *) di_bh->b_data;\n\n\t\tosb->slot_recovery_generations[slot] =\n\t\t\t\t\tocfs2_get_recovery_generation(di);\n\n\t\tif (le32_to_cpu(di->id1.journal1.ij_flags) &\n\t\t    OCFS2_JOURNAL_DIRTY_FL)\n\t\t\tjournal_dirty = 1;\n\n\t\tbrelse(di_bh);\n\t\tdi_bh = NULL;\n\t}\n\nout:\n\tif (journal_dirty)\n\t\tret = -EROFS;\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "di_bh"
          ],
          "line": 2315
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "di->id1.journal1.ij_flags"
          ],
          "line": 2311
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_get_recovery_generation",
          "args": [
            "di"
          ],
          "line": 2309
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_recovery_generation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "898-901",
          "snippet": "static u32 ocfs2_get_recovery_generation(struct ocfs2_dinode *di)\n{\n\treturn le32_to_cpu(di->id1.journal1.ij_recovery_generation);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u32 ocfs2_get_recovery_generation(struct ocfs2_dinode *di)\n{\n\treturn le32_to_cpu(di->id1.journal1.ij_recovery_generation);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_journal_inode",
          "args": [
            "osb",
            "slot",
            "&di_bh",
            "NULL"
          ],
          "line": 2300
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_journal_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "1494-1528",
          "snippet": "static int ocfs2_read_journal_inode(struct ocfs2_super *osb,\n\t\t\t\t    int slot_num,\n\t\t\t\t    struct buffer_head **bh,\n\t\t\t\t    struct inode **ret_inode)\n{\n\tint status = -EACCES;\n\tstruct inode *inode = NULL;\n\n\tBUG_ON(slot_num >= osb->max_slots);\n\n\tinode = ocfs2_get_system_file_inode(osb, JOURNAL_SYSTEM_INODE,\n\t\t\t\t\t    slot_num);\n\tif (!inode || is_bad_inode(inode)) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tSET_INODE_JOURNAL(inode);\n\n\tstatus = ocfs2_read_inode_block_full(inode, bh, OCFS2_BH_IGNORE_CACHE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\n\nbail:\n\tif (inode) {\n\t\tif (status || !ret_inode)\n\t\t\tiput(inode);\n\t\telse\n\t\t\t*ret_inode = inode;\n\t}\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_force_read_journal(struct inode *inode);",
            "static int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);",
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);",
            "static int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_force_read_journal(struct inode *inode);\nstatic int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\nstatic int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);\n\nstatic int ocfs2_read_journal_inode(struct ocfs2_super *osb,\n\t\t\t\t    int slot_num,\n\t\t\t\t    struct buffer_head **bh,\n\t\t\t\t    struct inode **ret_inode)\n{\n\tint status = -EACCES;\n\tstruct inode *inode = NULL;\n\n\tBUG_ON(slot_num >= osb->max_slots);\n\n\tinode = ocfs2_get_system_file_inode(osb, JOURNAL_SYSTEM_INODE,\n\t\t\t\t\t    slot_num);\n\tif (!inode || is_bad_inode(inode)) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tSET_INODE_JOURNAL(inode);\n\n\tstatus = ocfs2_read_inode_block_full(inode, bh, OCFS2_BH_IGNORE_CACHE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\n\nbail:\n\tif (inode) {\n\t\tif (status || !ret_inode)\n\t\t\tiput(inode);\n\t\telse\n\t\t\t*ret_inode = inode;\n\t}\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_check_journals_nolocks(struct ocfs2_super *osb)\n{\n\tint ret = 0;\n\tunsigned int slot;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tint journal_dirty = 0;\n\n\tfor(slot = 0; slot < osb->max_slots; slot++) {\n\t\tret = ocfs2_read_journal_inode(osb, slot, &di_bh, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdi = (struct ocfs2_dinode *) di_bh->b_data;\n\n\t\tosb->slot_recovery_generations[slot] =\n\t\t\t\t\tocfs2_get_recovery_generation(di);\n\n\t\tif (le32_to_cpu(di->id1.journal1.ij_flags) &\n\t\t    OCFS2_JOURNAL_DIRTY_FL)\n\t\t\tjournal_dirty = 1;\n\n\t\tbrelse(di_bh);\n\t\tdi_bh = NULL;\n\t}\n\nout:\n\tif (journal_dirty)\n\t\tret = -EROFS;\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_commit_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "2242-2284",
    "snippet": "static int ocfs2_commit_thread(void *arg)\n{\n\tint status;\n\tstruct ocfs2_super *osb = arg;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\t/* we can trust j_num_trans here because _should_stop() is only set in\n\t * shutdown and nobody other than ourselves should be able to start\n\t * transactions.  committing on shutdown might take a few iterations\n\t * as final transactions put deleted inodes on the list */\n\twhile (!(kthread_should_stop() &&\n\t\t atomic_read(&journal->j_num_trans) == 0)) {\n\n\t\twait_event_interruptible(osb->checkpoint_event,\n\t\t\t\t\t atomic_read(&journal->j_num_trans)\n\t\t\t\t\t || kthread_should_stop());\n\n\t\tstatus = ocfs2_commit_cache(osb);\n\t\tif (status < 0) {\n\t\t\tstatic unsigned long abort_warn_time;\n\n\t\t\t/* Warn about this once per minute */\n\t\t\tif (printk_timed_ratelimit(&abort_warn_time, 60*HZ))\n\t\t\t\tmlog(ML_ERROR, \"status = %d, journal is \"\n\t\t\t\t\t\t\"already aborted.\\n\", status);\n\t\t\t/*\n\t\t\t * After ocfs2_commit_cache() fails, j_num_trans has a\n\t\t\t * non-zero value.  Sleep here to avoid a busy-wait\n\t\t\t * loop.\n\t\t\t */\n\t\t\tmsleep_interruptible(1000);\n\t\t}\n\n\t\tif (kthread_should_stop() && atomic_read(&journal->j_num_trans)){\n\t\t\tmlog(ML_KTHREAD,\n\t\t\t     \"commit_thread: %u transactions pending on \"\n\t\t\t     \"shutdown\\n\",\n\t\t\t     atomic_read(&journal->j_num_trans));\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __ocfs2_recovery_thread(void *arg);",
      "static int ocfs2_commit_cache(struct ocfs2_super *osb);",
      "static int ocfs2_commit_thread(void *arg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_KTHREAD",
            "\"commit_thread: %u transactions pending on \"\n\t\t\t     \"shutdown\\n\"",
            "atomic_read(&journal->j_num_trans)"
          ],
          "line": 2276
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&journal->j_num_trans"
          ],
          "line": 2279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&journal->j_num_trans"
          ],
          "line": 2275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 2275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msleep_interruptible",
          "args": [
            "1000"
          ],
          "line": 2272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_timed_ratelimit",
          "args": [
            "&abort_warn_time",
            "60*HZ"
          ],
          "line": 2264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_cache",
          "args": [
            "osb"
          ],
          "line": 2259
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "307-346",
          "snippet": "static int ocfs2_commit_cache(struct ocfs2_super *osb)\n{\n\tint status = 0;\n\tunsigned int flushed;\n\tstruct ocfs2_journal *journal = NULL;\n\n\tjournal = osb->journal;\n\n\t/* Flush all pending commits and checkpoint the journal. */\n\tdown_write(&journal->j_trans_barrier);\n\n\tflushed = atomic_read(&journal->j_num_trans);\n\ttrace_ocfs2_commit_cache_begin(flushed);\n\tif (flushed == 0) {\n\t\tup_write(&journal->j_trans_barrier);\n\t\tgoto finally;\n\t}\n\n\tjbd2_journal_lock_updates(journal->j_journal);\n\tstatus = jbd2_journal_flush(journal->j_journal);\n\tjbd2_journal_unlock_updates(journal->j_journal);\n\tif (status < 0) {\n\t\tup_write(&journal->j_trans_barrier);\n\t\tmlog_errno(status);\n\t\tgoto finally;\n\t}\n\n\tocfs2_inc_trans_id(journal);\n\n\tflushed = atomic_read(&journal->j_num_trans);\n\tatomic_set(&journal->j_num_trans, 0);\n\tup_write(&journal->j_trans_barrier);\n\n\ttrace_ocfs2_commit_cache_end(journal->j_trans_id, flushed);\n\n\tocfs2_wake_downconvert_thread(osb);\n\twake_up(&journal->j_checkpointed);\nfinally:\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb)\n{\n\tint status = 0;\n\tunsigned int flushed;\n\tstruct ocfs2_journal *journal = NULL;\n\n\tjournal = osb->journal;\n\n\t/* Flush all pending commits and checkpoint the journal. */\n\tdown_write(&journal->j_trans_barrier);\n\n\tflushed = atomic_read(&journal->j_num_trans);\n\ttrace_ocfs2_commit_cache_begin(flushed);\n\tif (flushed == 0) {\n\t\tup_write(&journal->j_trans_barrier);\n\t\tgoto finally;\n\t}\n\n\tjbd2_journal_lock_updates(journal->j_journal);\n\tstatus = jbd2_journal_flush(journal->j_journal);\n\tjbd2_journal_unlock_updates(journal->j_journal);\n\tif (status < 0) {\n\t\tup_write(&journal->j_trans_barrier);\n\t\tmlog_errno(status);\n\t\tgoto finally;\n\t}\n\n\tocfs2_inc_trans_id(journal);\n\n\tflushed = atomic_read(&journal->j_num_trans);\n\tatomic_set(&journal->j_num_trans, 0);\n\tup_write(&journal->j_trans_barrier);\n\n\ttrace_ocfs2_commit_cache_end(journal->j_trans_id, flushed);\n\n\tocfs2_wake_downconvert_thread(osb);\n\twake_up(&journal->j_checkpointed);\nfinally:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible",
          "args": [
            "osb->checkpoint_event",
            "atomic_read(&journal->j_num_trans)\n\t\t\t\t\t || kthread_should_stop()"
          ],
          "line": 2255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 2257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&journal->j_num_trans"
          ],
          "line": 2256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&journal->j_num_trans"
          ],
          "line": 2253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 2252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int __ocfs2_recovery_thread(void *arg);\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\nstatic int ocfs2_commit_thread(void *arg);\n\nstatic int ocfs2_commit_thread(void *arg)\n{\n\tint status;\n\tstruct ocfs2_super *osb = arg;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\t/* we can trust j_num_trans here because _should_stop() is only set in\n\t * shutdown and nobody other than ourselves should be able to start\n\t * transactions.  committing on shutdown might take a few iterations\n\t * as final transactions put deleted inodes on the list */\n\twhile (!(kthread_should_stop() &&\n\t\t atomic_read(&journal->j_num_trans) == 0)) {\n\n\t\twait_event_interruptible(osb->checkpoint_event,\n\t\t\t\t\t atomic_read(&journal->j_num_trans)\n\t\t\t\t\t || kthread_should_stop());\n\n\t\tstatus = ocfs2_commit_cache(osb);\n\t\tif (status < 0) {\n\t\t\tstatic unsigned long abort_warn_time;\n\n\t\t\t/* Warn about this once per minute */\n\t\t\tif (printk_timed_ratelimit(&abort_warn_time, 60*HZ))\n\t\t\t\tmlog(ML_ERROR, \"status = %d, journal is \"\n\t\t\t\t\t\t\"already aborted.\\n\", status);\n\t\t\t/*\n\t\t\t * After ocfs2_commit_cache() fails, j_num_trans has a\n\t\t\t * non-zero value.  Sleep here to avoid a busy-wait\n\t\t\t * loop.\n\t\t\t */\n\t\t\tmsleep_interruptible(1000);\n\t\t}\n\n\t\tif (kthread_should_stop() && atomic_read(&journal->j_num_trans)){\n\t\t\tmlog(ML_KTHREAD,\n\t\t\t     \"commit_thread: %u transactions pending on \"\n\t\t\t     \"shutdown\\n\",\n\t\t\t     atomic_read(&journal->j_num_trans));\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__ocfs2_wait_on_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "2220-2240",
    "snippet": "static int __ocfs2_wait_on_mount(struct ocfs2_super *osb, int quota)\n{\n\t/* This check is good because ocfs2 will wait on our recovery\n\t * thread before changing it to something other than MOUNTED\n\t * or DISABLED. */\n\twait_event(osb->osb_mount_event,\n\t\t  (!quota && atomic_read(&osb->vol_state) == VOLUME_MOUNTED) ||\n\t\t   atomic_read(&osb->vol_state) == VOLUME_MOUNTED_QUOTAS ||\n\t\t   atomic_read(&osb->vol_state) == VOLUME_DISABLED);\n\n\t/* If there's an error on mount, then we may never get to the\n\t * MOUNTED flag, but this is set right before\n\t * dismount_volume() so we can trust it. */\n\tif (atomic_read(&osb->vol_state) == VOLUME_DISABLED) {\n\t\ttrace_ocfs2_wait_on_mount(VOLUME_DISABLED);\n\t\tmlog(0, \"mount error, exiting!\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_commit_cache(struct ocfs2_super *osb);",
      "static int __ocfs2_wait_on_mount(struct ocfs2_super *osb, int quota);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"mount error, exiting!\\n\""
          ],
          "line": 2235
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_wait_on_mount",
          "args": [
            "VOLUME_DISABLED"
          ],
          "line": 2234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&osb->vol_state"
          ],
          "line": 2233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "osb->osb_mount_event",
            "(!quota && atomic_read(&osb->vol_state) == VOLUME_MOUNTED) ||\n\t\t   atomic_read(&osb->vol_state) == VOLUME_MOUNTED_QUOTAS ||\n\t\t   atomic_read(&osb->vol_state) == VOLUME_DISABLED"
          ],
          "line": 2225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&osb->vol_state"
          ],
          "line": 2228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&osb->vol_state"
          ],
          "line": 2227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&osb->vol_state"
          ],
          "line": 2226
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\nstatic int __ocfs2_wait_on_mount(struct ocfs2_super *osb, int quota);\n\nstatic int __ocfs2_wait_on_mount(struct ocfs2_super *osb, int quota)\n{\n\t/* This check is good because ocfs2 will wait on our recovery\n\t * thread before changing it to something other than MOUNTED\n\t * or DISABLED. */\n\twait_event(osb->osb_mount_event,\n\t\t  (!quota && atomic_read(&osb->vol_state) == VOLUME_MOUNTED) ||\n\t\t   atomic_read(&osb->vol_state) == VOLUME_MOUNTED_QUOTAS ||\n\t\t   atomic_read(&osb->vol_state) == VOLUME_DISABLED);\n\n\t/* If there's an error on mount, then we may never get to the\n\t * MOUNTED flag, but this is set right before\n\t * dismount_volume() so we can trust it. */\n\tif (atomic_read(&osb->vol_state) == VOLUME_DISABLED) {\n\t\ttrace_ocfs2_wait_on_mount(VOLUME_DISABLED);\n\t\tmlog(0, \"mount error, exiting!\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_recover_orphans",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "2132-2218",
    "snippet": "static int ocfs2_recover_orphans(struct ocfs2_super *osb,\n\t\t\t\t int slot,\n\t\t\t\t enum ocfs2_orphan_reco_type orphan_reco_type)\n{\n\tint ret = 0;\n\tstruct inode *inode = NULL;\n\tstruct inode *iter;\n\tstruct ocfs2_inode_info *oi;\n\n\ttrace_ocfs2_recover_orphans(slot);\n\n\tocfs2_mark_recovering_orphan_dir(osb, slot);\n\tret = ocfs2_queue_orphans(osb, slot, &inode);\n\tocfs2_clear_recovering_orphan_dir(osb, slot);\n\n\t/* Error here should be noted, but we want to continue with as\n\t * many queued inodes as we've got. */\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\twhile (inode) {\n\t\toi = OCFS2_I(inode);\n\t\ttrace_ocfs2_recover_orphans_iput(\n\t\t\t\t\t(unsigned long long)oi->ip_blkno);\n\n\t\titer = oi->ip_next_orphan;\n\t\toi->ip_next_orphan = NULL;\n\n\t\t/*\n\t\t * We need to take and drop the inode lock to\n\t\t * force read inode from disk.\n\t\t */\n\t\tret = ocfs2_inode_lock(inode, NULL, 0);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto next;\n\t\t}\n\t\tocfs2_inode_unlock(inode, 0);\n\n\t\tif (inode->i_nlink == 0) {\n\t\t\tspin_lock(&oi->ip_lock);\n\t\t\t/* Set the proper information to get us going into\n\t\t\t * ocfs2_delete_inode. */\n\t\t\toi->ip_flags |= OCFS2_INODE_MAYBE_ORPHANED;\n\t\t\tspin_unlock(&oi->ip_lock);\n\t\t} else if (orphan_reco_type == ORPHAN_NEED_TRUNCATE) {\n\t\t\tstruct buffer_head *di_bh = NULL;\n\n\t\t\tret = ocfs2_rw_lock(inode, 1);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\t\t\tif (ret < 0) {\n\t\t\t\tocfs2_rw_unlock(inode, 1);\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tret = ocfs2_truncate_file(inode, di_bh,\n\t\t\t\t\ti_size_read(inode));\n\t\t\tocfs2_inode_unlock(inode, 1);\n\t\t\tocfs2_rw_unlock(inode, 1);\n\t\t\tbrelse(di_bh);\n\t\t\tif (ret < 0) {\n\t\t\t\tif (ret != -ENOSPC)\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tret = ocfs2_del_inode_from_orphan(osb, inode, 0, 0);\n\t\t\tif (ret)\n\t\t\t\tmlog_errno(ret);\n\n\t\t\twake_up(&OCFS2_I(inode)->append_dio_wq);\n\t\t} /* else if ORPHAN_NO_NEED_TRUNCATE, do nothing */\n\nnext:\n\t\tiput(inode);\n\n\t\tinode = iter;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_force_read_journal(struct inode *inode);",
      "static int ocfs2_commit_cache(struct ocfs2_super *osb);",
      "static int ocfs2_recover_orphans(struct ocfs2_super *osb,\n\t\t\t\t int slot,\n\t\t\t\t enum ocfs2_orphan_reco_type orphan_reco_type);",
      "static void ocfs2_queue_recovery_completion(struct ocfs2_journal *journal,\n\t\t\t\t\t    int slot_num,\n\t\t\t\t\t    struct ocfs2_dinode *la_dinode,\n\t\t\t\t\t    struct ocfs2_dinode *tl_dinode,\n\t\t\t\t\t    struct ocfs2_quota_recovery *qrec,\n\t\t\t\t\t    enum ocfs2_orphan_reco_type orphan_reco_type);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 2212
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&OCFS2_I(inode)->append_dio_wq"
          ],
          "line": 2208
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 2208
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_del_inode_from_orphan",
          "args": [
            "osb",
            "inode",
            "0",
            "0"
          ],
          "line": 2204
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_del_inode_from_orphan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
          "lines": "2672-2758",
          "snippet": "int ocfs2_del_inode_from_orphan(struct ocfs2_super *osb,\n\t\tstruct inode *inode, int update_isize,\n\t\tloff_t end)\n{\n\tstruct inode *orphan_dir_inode = NULL;\n\tstruct buffer_head *orphan_dir_bh = NULL;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di = NULL;\n\thandle_t *handle = NULL;\n\tint status = 0;\n\n\tstatus = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tdi = (struct ocfs2_dinode *) di_bh->b_data;\n\n\torphan_dir_inode = ocfs2_get_system_file_inode(osb,\n\t\t\tORPHAN_DIR_SYSTEM_INODE,\n\t\t\tle16_to_cpu(di->i_dio_orphaned_slot));\n\tif (!orphan_dir_inode) {\n\t\tstatus = -ENOENT;\n\t\tmlog_errno(status);\n\t\tgoto bail_unlock_inode;\n\t}\n\n\tmutex_lock(&orphan_dir_inode->i_mutex);\n\tstatus = ocfs2_inode_lock(orphan_dir_inode, &orphan_dir_bh, 1);\n\tif (status < 0) {\n\t\tmutex_unlock(&orphan_dir_inode->i_mutex);\n\t\tiput(orphan_dir_inode);\n\t\tmlog_errno(status);\n\t\tgoto bail_unlock_inode;\n\t}\n\n\thandle = ocfs2_start_trans(osb,\n\t\t\tOCFS2_INODE_DEL_FROM_ORPHAN_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tgoto bail_unlock_orphan;\n\t}\n\n\tBUG_ON(!(di->i_flags & cpu_to_le32(OCFS2_DIO_ORPHANED_FL)));\n\n\tstatus = ocfs2_orphan_del(osb, handle, orphan_dir_inode,\n\t\t\t\tinode, orphan_dir_bh, true);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail_commit;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\tINODE_CACHE(inode),\n\t\t\tdi_bh,\n\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail_commit;\n\t}\n\n\tdi->i_flags &= ~cpu_to_le32(OCFS2_DIO_ORPHANED_FL);\n\tdi->i_dio_orphaned_slot = 0;\n\n\tif (update_isize) {\n\t\tstatus = ocfs2_set_inode_size(handle, inode, di_bh, end);\n\t\tif (status)\n\t\t\tmlog_errno(status);\n\t} else\n\t\tocfs2_journal_dirty(handle, di_bh);\n\nbail_commit:\n\tocfs2_commit_trans(osb, handle);\n\nbail_unlock_orphan:\n\tocfs2_inode_unlock(orphan_dir_inode, 1);\n\tmutex_unlock(&orphan_dir_inode->i_mutex);\n\tbrelse(orphan_dir_bh);\n\tiput(orphan_dir_inode);\n\nbail_unlock_inode:\n\tocfs2_inode_unlock(inode, 1);\n\tbrelse(di_bh);\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_del_inode_from_orphan(struct ocfs2_super *osb,\n\t\tstruct inode *inode, int update_isize,\n\t\tloff_t end)\n{\n\tstruct inode *orphan_dir_inode = NULL;\n\tstruct buffer_head *orphan_dir_bh = NULL;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di = NULL;\n\thandle_t *handle = NULL;\n\tint status = 0;\n\n\tstatus = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tdi = (struct ocfs2_dinode *) di_bh->b_data;\n\n\torphan_dir_inode = ocfs2_get_system_file_inode(osb,\n\t\t\tORPHAN_DIR_SYSTEM_INODE,\n\t\t\tle16_to_cpu(di->i_dio_orphaned_slot));\n\tif (!orphan_dir_inode) {\n\t\tstatus = -ENOENT;\n\t\tmlog_errno(status);\n\t\tgoto bail_unlock_inode;\n\t}\n\n\tmutex_lock(&orphan_dir_inode->i_mutex);\n\tstatus = ocfs2_inode_lock(orphan_dir_inode, &orphan_dir_bh, 1);\n\tif (status < 0) {\n\t\tmutex_unlock(&orphan_dir_inode->i_mutex);\n\t\tiput(orphan_dir_inode);\n\t\tmlog_errno(status);\n\t\tgoto bail_unlock_inode;\n\t}\n\n\thandle = ocfs2_start_trans(osb,\n\t\t\tOCFS2_INODE_DEL_FROM_ORPHAN_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tgoto bail_unlock_orphan;\n\t}\n\n\tBUG_ON(!(di->i_flags & cpu_to_le32(OCFS2_DIO_ORPHANED_FL)));\n\n\tstatus = ocfs2_orphan_del(osb, handle, orphan_dir_inode,\n\t\t\t\tinode, orphan_dir_bh, true);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail_commit;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle,\n\t\t\tINODE_CACHE(inode),\n\t\t\tdi_bh,\n\t\t\tOCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail_commit;\n\t}\n\n\tdi->i_flags &= ~cpu_to_le32(OCFS2_DIO_ORPHANED_FL);\n\tdi->i_dio_orphaned_slot = 0;\n\n\tif (update_isize) {\n\t\tstatus = ocfs2_set_inode_size(handle, inode, di_bh, end);\n\t\tif (status)\n\t\t\tmlog_errno(status);\n\t} else\n\t\tocfs2_journal_dirty(handle, di_bh);\n\nbail_commit:\n\tocfs2_commit_trans(osb, handle);\n\nbail_unlock_orphan:\n\tocfs2_inode_unlock(orphan_dir_inode, 1);\n\tmutex_unlock(&orphan_dir_inode->i_mutex);\n\tbrelse(orphan_dir_bh);\n\tiput(orphan_dir_inode);\n\nbail_unlock_inode:\n\tocfs2_inode_unlock(inode, 1);\n\tbrelse(di_bh);\n\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "di_bh"
          ],
          "line": 2197
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_rw_unlock",
          "args": [
            "inode",
            "1"
          ],
          "line": 2196
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rw_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1692-1704",
          "snippet": "void ocfs2_rw_unlock(struct inode *inode, int write)\n{\n\tint level = write ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_rw_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s RW lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     write ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_rw_unlock(struct inode *inode, int write)\n{\n\tint level = write ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_rw_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s RW lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     write ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "inode",
            "1"
          ],
          "line": 2195
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_truncate_file",
          "args": [
            "inode",
            "di_bh",
            "i_size_read(inode)"
          ],
          "line": 2193
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_truncate_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "444-526",
          "snippet": "int ocfs2_truncate_file(struct inode *inode,\n\t\t\t       struct buffer_head *di_bh,\n\t\t\t       u64 new_i_size)\n{\n\tint status = 0;\n\tstruct ocfs2_dinode *fe = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\t/* We trust di_bh because it comes from ocfs2_inode_lock(), which\n\t * already validated it */\n\tfe = (struct ocfs2_dinode *) di_bh->b_data;\n\n\ttrace_ocfs2_truncate_file((unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t\t  (unsigned long long)le64_to_cpu(fe->i_size),\n\t\t\t\t  (unsigned long long)new_i_size);\n\n\tmlog_bug_on_msg(le64_to_cpu(fe->i_size) != i_size_read(inode),\n\t\t\t\"Inode %llu, inode i_size = %lld != di \"\n\t\t\t\"i_size = %llu, i_flags = 0x%x\\n\",\n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\ti_size_read(inode),\n\t\t\t(unsigned long long)le64_to_cpu(fe->i_size),\n\t\t\tle32_to_cpu(fe->i_flags));\n\n\tif (new_i_size > le64_to_cpu(fe->i_size)) {\n\t\ttrace_ocfs2_truncate_file_error(\n\t\t\t(unsigned long long)le64_to_cpu(fe->i_size),\n\t\t\t(unsigned long long)new_i_size);\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tdown_write(&OCFS2_I(inode)->ip_alloc_sem);\n\n\tocfs2_resv_discard(&osb->osb_la_resmap,\n\t\t\t   &OCFS2_I(inode)->ip_la_data_resv);\n\n\t/*\n\t * The inode lock forced other nodes to sync and drop their\n\t * pages, which (correctly) happens even if we have a truncate\n\t * without allocation change - ocfs2 cluster sizes can be much\n\t * greater than page size, so we have to truncate them\n\t * anyway.\n\t */\n\tunmap_mapping_range(inode->i_mapping, new_i_size + PAGE_SIZE - 1, 0, 1);\n\ttruncate_inode_pages(inode->i_mapping, new_i_size);\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tstatus = ocfs2_truncate_inline(inode, di_bh, new_i_size,\n\t\t\t\t\t       i_size_read(inode), 1);\n\t\tif (status)\n\t\t\tmlog_errno(status);\n\n\t\tgoto bail_unlock_sem;\n\t}\n\n\t/* alright, we're going to need to do a full blown alloc size\n\t * change. Orphan the inode so that recovery can complete the\n\t * truncate if necessary. This does the task of marking\n\t * i_size. */\n\tstatus = ocfs2_orphan_for_truncate(osb, inode, di_bh, new_i_size);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail_unlock_sem;\n\t}\n\n\tstatus = ocfs2_commit_truncate(osb, inode, di_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail_unlock_sem;\n\t}\n\n\t/* TODO: orphan dir cleanup here. */\nbail_unlock_sem:\n\tup_write(&OCFS2_I(inode)->ip_alloc_sem);\n\nbail:\n\tif (!status && OCFS2_I(inode)->ip_clusters == 0)\n\t\tstatus = ocfs2_try_remove_refcount_tree(inode, di_bh);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_truncate_file(struct inode *inode,\n\t\t\t       struct buffer_head *di_bh,\n\t\t\t       u64 new_i_size)\n{\n\tint status = 0;\n\tstruct ocfs2_dinode *fe = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\t/* We trust di_bh because it comes from ocfs2_inode_lock(), which\n\t * already validated it */\n\tfe = (struct ocfs2_dinode *) di_bh->b_data;\n\n\ttrace_ocfs2_truncate_file((unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t\t  (unsigned long long)le64_to_cpu(fe->i_size),\n\t\t\t\t  (unsigned long long)new_i_size);\n\n\tmlog_bug_on_msg(le64_to_cpu(fe->i_size) != i_size_read(inode),\n\t\t\t\"Inode %llu, inode i_size = %lld != di \"\n\t\t\t\"i_size = %llu, i_flags = 0x%x\\n\",\n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\ti_size_read(inode),\n\t\t\t(unsigned long long)le64_to_cpu(fe->i_size),\n\t\t\tle32_to_cpu(fe->i_flags));\n\n\tif (new_i_size > le64_to_cpu(fe->i_size)) {\n\t\ttrace_ocfs2_truncate_file_error(\n\t\t\t(unsigned long long)le64_to_cpu(fe->i_size),\n\t\t\t(unsigned long long)new_i_size);\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tdown_write(&OCFS2_I(inode)->ip_alloc_sem);\n\n\tocfs2_resv_discard(&osb->osb_la_resmap,\n\t\t\t   &OCFS2_I(inode)->ip_la_data_resv);\n\n\t/*\n\t * The inode lock forced other nodes to sync and drop their\n\t * pages, which (correctly) happens even if we have a truncate\n\t * without allocation change - ocfs2 cluster sizes can be much\n\t * greater than page size, so we have to truncate them\n\t * anyway.\n\t */\n\tunmap_mapping_range(inode->i_mapping, new_i_size + PAGE_SIZE - 1, 0, 1);\n\ttruncate_inode_pages(inode->i_mapping, new_i_size);\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tstatus = ocfs2_truncate_inline(inode, di_bh, new_i_size,\n\t\t\t\t\t       i_size_read(inode), 1);\n\t\tif (status)\n\t\t\tmlog_errno(status);\n\n\t\tgoto bail_unlock_sem;\n\t}\n\n\t/* alright, we're going to need to do a full blown alloc size\n\t * change. Orphan the inode so that recovery can complete the\n\t * truncate if necessary. This does the task of marking\n\t * i_size. */\n\tstatus = ocfs2_orphan_for_truncate(osb, inode, di_bh, new_i_size);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail_unlock_sem;\n\t}\n\n\tstatus = ocfs2_commit_truncate(osb, inode, di_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail_unlock_sem;\n\t}\n\n\t/* TODO: orphan dir cleanup here. */\nbail_unlock_sem:\n\tup_write(&OCFS2_I(inode)->ip_alloc_sem);\n\nbail:\n\tif (!status && OCFS2_I(inode)->ip_clusters == 0)\n\t\tstatus = ocfs2_try_remove_refcount_tree(inode, di_bh);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 2194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "inode",
            "&di_bh",
            "1"
          ],
          "line": 2186
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_rw_lock",
          "args": [
            "inode",
            "1"
          ],
          "line": 2180
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rw_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1665-1690",
          "snippet": "int ocfs2_rw_lock(struct inode *inode, int write)\n{\n\tint status, level;\n\tstruct ocfs2_lock_res *lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tBUG_ON(!inode);\n\n\tmlog(0, \"inode %llu take %s RW lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     write ? \"EXMODE\" : \"PRMODE\");\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn 0;\n\n\tlockres = &OCFS2_I(inode)->ip_rw_lockres;\n\n\tlevel = write ? DLM_LOCK_EX : DLM_LOCK_PR;\n\n\tstatus = ocfs2_cluster_lock(OCFS2_SB(inode->i_sb), lockres, level, 0,\n\t\t\t\t    0);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nint ocfs2_rw_lock(struct inode *inode, int write)\n{\n\tint status, level;\n\tstruct ocfs2_lock_res *lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tBUG_ON(!inode);\n\n\tmlog(0, \"inode %llu take %s RW lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     write ? \"EXMODE\" : \"PRMODE\");\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn 0;\n\n\tlockres = &OCFS2_I(inode)->ip_rw_lockres;\n\n\tlevel = write ? DLM_LOCK_EX : DLM_LOCK_PR;\n\n\tstatus = ocfs2_cluster_lock(OCFS2_SB(inode->i_sb), lockres, level, 0,\n\t\t\t\t    0);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&oi->ip_lock"
          ],
          "line": 2176
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&oi->ip_lock"
          ],
          "line": 2172
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_recover_orphans_iput",
          "args": [
            "(unsigned long long)oi->ip_blkno"
          ],
          "line": 2154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clear_recovering_orphan_dir",
          "args": [
            "osb",
            "slot"
          ],
          "line": 2145
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_recovering_orphan_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "2108-2112",
          "snippet": "static void ocfs2_clear_recovering_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t\t      int slot)\n{\n\tocfs2_node_map_clear_bit(osb, &osb->osb_recovering_orphan_dirs, slot);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nstatic void ocfs2_clear_recovering_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t\t      int slot)\n{\n\tocfs2_node_map_clear_bit(osb, &osb->osb_recovering_orphan_dirs, slot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_queue_orphans",
          "args": [
            "osb",
            "slot",
            "&inode"
          ],
          "line": 2144
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_queue_orphans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "2034-2076",
          "snippet": "static int ocfs2_queue_orphans(struct ocfs2_super *osb,\n\t\t\t       int slot,\n\t\t\t       struct inode **head)\n{\n\tint status;\n\tstruct inode *orphan_dir_inode = NULL;\n\tstruct ocfs2_orphan_filldir_priv priv = {\n\t\t.ctx.actor = ocfs2_orphan_filldir,\n\t\t.osb = osb,\n\t\t.head = *head\n\t};\n\n\torphan_dir_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t       ORPHAN_DIR_SYSTEM_INODE,\n\t\t\t\t\t\t       slot);\n\tif  (!orphan_dir_inode) {\n\t\tstatus = -ENOENT;\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\tmutex_lock(&orphan_dir_inode->i_mutex);\n\tstatus = ocfs2_inode_lock(orphan_dir_inode, NULL, 0);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tstatus = ocfs2_dir_foreach(orphan_dir_inode, &priv.ctx);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out_cluster;\n\t}\n\n\t*head = priv.head;\n\nout_cluster:\n\tocfs2_inode_unlock(orphan_dir_inode, 0);\nout:\n\tmutex_unlock(&orphan_dir_inode->i_mutex);\n\tiput(orphan_dir_inode);\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_force_read_journal(struct inode *inode);",
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_force_read_journal(struct inode *inode);\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nstatic int ocfs2_queue_orphans(struct ocfs2_super *osb,\n\t\t\t       int slot,\n\t\t\t       struct inode **head)\n{\n\tint status;\n\tstruct inode *orphan_dir_inode = NULL;\n\tstruct ocfs2_orphan_filldir_priv priv = {\n\t\t.ctx.actor = ocfs2_orphan_filldir,\n\t\t.osb = osb,\n\t\t.head = *head\n\t};\n\n\torphan_dir_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t       ORPHAN_DIR_SYSTEM_INODE,\n\t\t\t\t\t\t       slot);\n\tif  (!orphan_dir_inode) {\n\t\tstatus = -ENOENT;\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\tmutex_lock(&orphan_dir_inode->i_mutex);\n\tstatus = ocfs2_inode_lock(orphan_dir_inode, NULL, 0);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tstatus = ocfs2_dir_foreach(orphan_dir_inode, &priv.ctx);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out_cluster;\n\t}\n\n\t*head = priv.head;\n\nout_cluster:\n\tocfs2_inode_unlock(orphan_dir_inode, 0);\nout:\n\tmutex_unlock(&orphan_dir_inode->i_mutex);\n\tiput(orphan_dir_inode);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_mark_recovering_orphan_dir",
          "args": [
            "osb",
            "slot"
          ],
          "line": 2143
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mark_recovering_orphan_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "2089-2106",
          "snippet": "static void ocfs2_mark_recovering_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t\t     int slot)\n{\n\tspin_lock(&osb->osb_lock);\n\t/* Mark ourselves such that new processes in delete_inode()\n\t * know to quit early. */\n\tocfs2_node_map_set_bit(osb, &osb->osb_recovering_orphan_dirs, slot);\n\twhile (osb->osb_orphan_wipes[slot]) {\n\t\t/* If any processes are already in the middle of an\n\t\t * orphan wipe on this dir, then we need to wait for\n\t\t * them. */\n\t\tspin_unlock(&osb->osb_lock);\n\t\twait_event_interruptible(osb->osb_wipe_event,\n\t\t\t\t\t ocfs2_orphan_recovery_can_continue(osb, slot));\n\t\tspin_lock(&osb->osb_lock);\n\t}\n\tspin_unlock(&osb->osb_lock);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nstatic void ocfs2_mark_recovering_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t\t     int slot)\n{\n\tspin_lock(&osb->osb_lock);\n\t/* Mark ourselves such that new processes in delete_inode()\n\t * know to quit early. */\n\tocfs2_node_map_set_bit(osb, &osb->osb_recovering_orphan_dirs, slot);\n\twhile (osb->osb_orphan_wipes[slot]) {\n\t\t/* If any processes are already in the middle of an\n\t\t * orphan wipe on this dir, then we need to wait for\n\t\t * them. */\n\t\tspin_unlock(&osb->osb_lock);\n\t\twait_event_interruptible(osb->osb_wipe_event,\n\t\t\t\t\t ocfs2_orphan_recovery_can_continue(osb, slot));\n\t\tspin_lock(&osb->osb_lock);\n\t}\n\tspin_unlock(&osb->osb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_recover_orphans",
          "args": [
            "slot"
          ],
          "line": 2141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_force_read_journal(struct inode *inode);\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\nstatic int ocfs2_recover_orphans(struct ocfs2_super *osb,\n\t\t\t\t int slot,\n\t\t\t\t enum ocfs2_orphan_reco_type orphan_reco_type);\nstatic void ocfs2_queue_recovery_completion(struct ocfs2_journal *journal,\n\t\t\t\t\t    int slot_num,\n\t\t\t\t\t    struct ocfs2_dinode *la_dinode,\n\t\t\t\t\t    struct ocfs2_dinode *tl_dinode,\n\t\t\t\t\t    struct ocfs2_quota_recovery *qrec,\n\t\t\t\t\t    enum ocfs2_orphan_reco_type orphan_reco_type);\n\nstatic int ocfs2_recover_orphans(struct ocfs2_super *osb,\n\t\t\t\t int slot,\n\t\t\t\t enum ocfs2_orphan_reco_type orphan_reco_type)\n{\n\tint ret = 0;\n\tstruct inode *inode = NULL;\n\tstruct inode *iter;\n\tstruct ocfs2_inode_info *oi;\n\n\ttrace_ocfs2_recover_orphans(slot);\n\n\tocfs2_mark_recovering_orphan_dir(osb, slot);\n\tret = ocfs2_queue_orphans(osb, slot, &inode);\n\tocfs2_clear_recovering_orphan_dir(osb, slot);\n\n\t/* Error here should be noted, but we want to continue with as\n\t * many queued inodes as we've got. */\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\twhile (inode) {\n\t\toi = OCFS2_I(inode);\n\t\ttrace_ocfs2_recover_orphans_iput(\n\t\t\t\t\t(unsigned long long)oi->ip_blkno);\n\n\t\titer = oi->ip_next_orphan;\n\t\toi->ip_next_orphan = NULL;\n\n\t\t/*\n\t\t * We need to take and drop the inode lock to\n\t\t * force read inode from disk.\n\t\t */\n\t\tret = ocfs2_inode_lock(inode, NULL, 0);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto next;\n\t\t}\n\t\tocfs2_inode_unlock(inode, 0);\n\n\t\tif (inode->i_nlink == 0) {\n\t\t\tspin_lock(&oi->ip_lock);\n\t\t\t/* Set the proper information to get us going into\n\t\t\t * ocfs2_delete_inode. */\n\t\t\toi->ip_flags |= OCFS2_INODE_MAYBE_ORPHANED;\n\t\t\tspin_unlock(&oi->ip_lock);\n\t\t} else if (orphan_reco_type == ORPHAN_NEED_TRUNCATE) {\n\t\t\tstruct buffer_head *di_bh = NULL;\n\n\t\t\tret = ocfs2_rw_lock(inode, 1);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\t\t\tif (ret < 0) {\n\t\t\t\tocfs2_rw_unlock(inode, 1);\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tret = ocfs2_truncate_file(inode, di_bh,\n\t\t\t\t\ti_size_read(inode));\n\t\t\tocfs2_inode_unlock(inode, 1);\n\t\t\tocfs2_rw_unlock(inode, 1);\n\t\t\tbrelse(di_bh);\n\t\t\tif (ret < 0) {\n\t\t\t\tif (ret != -ENOSPC)\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tret = ocfs2_del_inode_from_orphan(osb, inode, 0, 0);\n\t\t\tif (ret)\n\t\t\t\tmlog_errno(ret);\n\n\t\t\twake_up(&OCFS2_I(inode)->append_dio_wq);\n\t\t} /* else if ORPHAN_NO_NEED_TRUNCATE, do nothing */\n\nnext:\n\t\tiput(inode);\n\n\t\tinode = iter;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_clear_recovering_orphan_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "2108-2112",
    "snippet": "static void ocfs2_clear_recovering_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t\t      int slot)\n{\n\tocfs2_node_map_clear_bit(osb, &osb->osb_recovering_orphan_dirs, slot);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_node_map_clear_bit",
          "args": [
            "osb",
            "&osb->osb_recovering_orphan_dirs",
            "slot"
          ],
          "line": 2111
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_node_map_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/heartbeat.c",
          "lines": "108-118",
          "snippet": "void ocfs2_node_map_clear_bit(struct ocfs2_super *osb,\n\t\t\t      struct ocfs2_node_map *map,\n\t\t\t      int bit)\n{\n\tif (bit==-1)\n\t\treturn;\n\tBUG_ON(bit >= map->num_nodes);\n\tspin_lock(&osb->node_map_lock);\n\t__ocfs2_node_map_clear_bit(map, bit);\n\tspin_unlock(&osb->node_map_lock);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void __ocfs2_node_map_set_bit(struct ocfs2_node_map *map,\n\t\t\t\t\t    int bit);",
            "static inline void __ocfs2_node_map_clear_bit(struct ocfs2_node_map *map,\n\t\t\t\t\t      int bit);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void __ocfs2_node_map_set_bit(struct ocfs2_node_map *map,\n\t\t\t\t\t    int bit);\nstatic inline void __ocfs2_node_map_clear_bit(struct ocfs2_node_map *map,\n\t\t\t\t\t      int bit);\n\nvoid ocfs2_node_map_clear_bit(struct ocfs2_super *osb,\n\t\t\t      struct ocfs2_node_map *map,\n\t\t\t      int bit)\n{\n\tif (bit==-1)\n\t\treturn;\n\tBUG_ON(bit >= map->num_nodes);\n\tspin_lock(&osb->node_map_lock);\n\t__ocfs2_node_map_clear_bit(map, bit);\n\tspin_unlock(&osb->node_map_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nstatic void ocfs2_clear_recovering_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t\t      int slot)\n{\n\tocfs2_node_map_clear_bit(osb, &osb->osb_recovering_orphan_dirs, slot);\n}"
  },
  {
    "function_name": "ocfs2_mark_recovering_orphan_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "2089-2106",
    "snippet": "static void ocfs2_mark_recovering_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t\t     int slot)\n{\n\tspin_lock(&osb->osb_lock);\n\t/* Mark ourselves such that new processes in delete_inode()\n\t * know to quit early. */\n\tocfs2_node_map_set_bit(osb, &osb->osb_recovering_orphan_dirs, slot);\n\twhile (osb->osb_orphan_wipes[slot]) {\n\t\t/* If any processes are already in the middle of an\n\t\t * orphan wipe on this dir, then we need to wait for\n\t\t * them. */\n\t\tspin_unlock(&osb->osb_lock);\n\t\twait_event_interruptible(osb->osb_wipe_event,\n\t\t\t\t\t ocfs2_orphan_recovery_can_continue(osb, slot));\n\t\tspin_lock(&osb->osb_lock);\n\t}\n\tspin_unlock(&osb->osb_lock);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 2105
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 2103
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible",
          "args": [
            "osb->osb_wipe_event",
            "ocfs2_orphan_recovery_can_continue(osb, slot)"
          ],
          "line": 2101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_orphan_recovery_can_continue",
          "args": [
            "osb",
            "slot"
          ],
          "line": 2102
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_orphan_recovery_can_continue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "2078-2087",
          "snippet": "static int ocfs2_orphan_recovery_can_continue(struct ocfs2_super *osb,\n\t\t\t\t\t      int slot)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = !osb->osb_orphan_wipes[slot];\n\tspin_unlock(&osb->osb_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nstatic int ocfs2_orphan_recovery_can_continue(struct ocfs2_super *osb,\n\t\t\t\t\t      int slot)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = !osb->osb_orphan_wipes[slot];\n\tspin_unlock(&osb->osb_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_node_map_set_bit",
          "args": [
            "osb",
            "&osb->osb_recovering_orphan_dirs",
            "slot"
          ],
          "line": 2095
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_node_map_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/heartbeat.c",
          "lines": "90-100",
          "snippet": "void ocfs2_node_map_set_bit(struct ocfs2_super *osb,\n\t\t\t    struct ocfs2_node_map *map,\n\t\t\t    int bit)\n{\n\tif (bit==-1)\n\t\treturn;\n\tBUG_ON(bit >= map->num_nodes);\n\tspin_lock(&osb->node_map_lock);\n\t__ocfs2_node_map_set_bit(map, bit);\n\tspin_unlock(&osb->node_map_lock);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void __ocfs2_node_map_set_bit(struct ocfs2_node_map *map,\n\t\t\t\t\t    int bit);",
            "static inline void __ocfs2_node_map_clear_bit(struct ocfs2_node_map *map,\n\t\t\t\t\t      int bit);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void __ocfs2_node_map_set_bit(struct ocfs2_node_map *map,\n\t\t\t\t\t    int bit);\nstatic inline void __ocfs2_node_map_clear_bit(struct ocfs2_node_map *map,\n\t\t\t\t\t      int bit);\n\nvoid ocfs2_node_map_set_bit(struct ocfs2_super *osb,\n\t\t\t    struct ocfs2_node_map *map,\n\t\t\t    int bit)\n{\n\tif (bit==-1)\n\t\treturn;\n\tBUG_ON(bit >= map->num_nodes);\n\tspin_lock(&osb->node_map_lock);\n\t__ocfs2_node_map_set_bit(map, bit);\n\tspin_unlock(&osb->node_map_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nstatic void ocfs2_mark_recovering_orphan_dir(struct ocfs2_super *osb,\n\t\t\t\t\t     int slot)\n{\n\tspin_lock(&osb->osb_lock);\n\t/* Mark ourselves such that new processes in delete_inode()\n\t * know to quit early. */\n\tocfs2_node_map_set_bit(osb, &osb->osb_recovering_orphan_dirs, slot);\n\twhile (osb->osb_orphan_wipes[slot]) {\n\t\t/* If any processes are already in the middle of an\n\t\t * orphan wipe on this dir, then we need to wait for\n\t\t * them. */\n\t\tspin_unlock(&osb->osb_lock);\n\t\twait_event_interruptible(osb->osb_wipe_event,\n\t\t\t\t\t ocfs2_orphan_recovery_can_continue(osb, slot));\n\t\tspin_lock(&osb->osb_lock);\n\t}\n\tspin_unlock(&osb->osb_lock);\n}"
  },
  {
    "function_name": "ocfs2_orphan_recovery_can_continue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "2078-2087",
    "snippet": "static int ocfs2_orphan_recovery_can_continue(struct ocfs2_super *osb,\n\t\t\t\t\t      int slot)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = !osb->osb_orphan_wipes[slot];\n\tspin_unlock(&osb->osb_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 2085
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 2083
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nstatic int ocfs2_orphan_recovery_can_continue(struct ocfs2_super *osb,\n\t\t\t\t\t      int slot)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = !osb->osb_orphan_wipes[slot];\n\tspin_unlock(&osb->osb_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_queue_orphans",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "2034-2076",
    "snippet": "static int ocfs2_queue_orphans(struct ocfs2_super *osb,\n\t\t\t       int slot,\n\t\t\t       struct inode **head)\n{\n\tint status;\n\tstruct inode *orphan_dir_inode = NULL;\n\tstruct ocfs2_orphan_filldir_priv priv = {\n\t\t.ctx.actor = ocfs2_orphan_filldir,\n\t\t.osb = osb,\n\t\t.head = *head\n\t};\n\n\torphan_dir_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t       ORPHAN_DIR_SYSTEM_INODE,\n\t\t\t\t\t\t       slot);\n\tif  (!orphan_dir_inode) {\n\t\tstatus = -ENOENT;\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\tmutex_lock(&orphan_dir_inode->i_mutex);\n\tstatus = ocfs2_inode_lock(orphan_dir_inode, NULL, 0);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tstatus = ocfs2_dir_foreach(orphan_dir_inode, &priv.ctx);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out_cluster;\n\t}\n\n\t*head = priv.head;\n\nout_cluster:\n\tocfs2_inode_unlock(orphan_dir_inode, 0);\nout:\n\tmutex_unlock(&orphan_dir_inode->i_mutex);\n\tiput(orphan_dir_inode);\n\treturn status;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_force_read_journal(struct inode *inode);",
      "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "orphan_dir_inode"
          ],
          "line": 2074
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&orphan_dir_inode->i_mutex"
          ],
          "line": 2073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "orphan_dir_inode",
            "0"
          ],
          "line": 2071
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dir_foreach",
          "args": [
            "orphan_dir_inode",
            "&priv.ctx"
          ],
          "line": 2062
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dir_foreach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "1951-1956",
          "snippet": "int ocfs2_dir_foreach(struct inode *inode, struct dir_context *ctx)\n{\n\tu64 version = inode->i_version;\n\tocfs2_dir_foreach_blk(inode, &version, ctx, true);\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint ocfs2_dir_foreach(struct inode *inode, struct dir_context *ctx)\n{\n\tu64 version = inode->i_version;\n\tocfs2_dir_foreach_blk(inode, &version, ctx, true);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "orphan_dir_inode",
            "NULL",
            "0"
          ],
          "line": 2056
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&orphan_dir_inode->i_mutex"
          ],
          "line": 2055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 2051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_system_file_inode",
          "args": [
            "osb",
            "ORPHAN_DIR_SYSTEM_INODE",
            "slot"
          ],
          "line": 2046
        },
        "resolved": true,
        "details": {
          "function_name": "_ocfs2_get_system_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/sysfile.c",
          "lines": "138-181",
          "snippet": "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_force_read_journal(struct inode *inode);\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nstatic int ocfs2_queue_orphans(struct ocfs2_super *osb,\n\t\t\t       int slot,\n\t\t\t       struct inode **head)\n{\n\tint status;\n\tstruct inode *orphan_dir_inode = NULL;\n\tstruct ocfs2_orphan_filldir_priv priv = {\n\t\t.ctx.actor = ocfs2_orphan_filldir,\n\t\t.osb = osb,\n\t\t.head = *head\n\t};\n\n\torphan_dir_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t       ORPHAN_DIR_SYSTEM_INODE,\n\t\t\t\t\t\t       slot);\n\tif  (!orphan_dir_inode) {\n\t\tstatus = -ENOENT;\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\tmutex_lock(&orphan_dir_inode->i_mutex);\n\tstatus = ocfs2_inode_lock(orphan_dir_inode, NULL, 0);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tstatus = ocfs2_dir_foreach(orphan_dir_inode, &priv.ctx);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out_cluster;\n\t}\n\n\t*head = priv.head;\n\nout_cluster:\n\tocfs2_inode_unlock(orphan_dir_inode, 0);\nout:\n\tmutex_unlock(&orphan_dir_inode->i_mutex);\n\tiput(orphan_dir_inode);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_orphan_filldir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "1999-2032",
    "snippet": "static int ocfs2_orphan_filldir(struct dir_context *ctx, const char *name,\n\t\t\t\tint name_len, loff_t pos, u64 ino,\n\t\t\t\tunsigned type)\n{\n\tstruct ocfs2_orphan_filldir_priv *p =\n\t\tcontainer_of(ctx, struct ocfs2_orphan_filldir_priv, ctx);\n\tstruct inode *iter;\n\n\tif (name_len == 1 && !strncmp(\".\", name, 1))\n\t\treturn 0;\n\tif (name_len == 2 && !strncmp(\"..\", name, 2))\n\t\treturn 0;\n\n\t/* Skip bad inodes so that recovery can continue */\n\titer = ocfs2_iget(p->osb, ino,\n\t\t\t  OCFS2_FI_FLAG_ORPHAN_RECOVERY, 0);\n\tif (IS_ERR(iter))\n\t\treturn 0;\n\n\t/* Skip inodes which are already added to recover list, since dio may\n\t * happen concurrently with unlink/rename */\n\tif (OCFS2_I(iter)->ip_next_orphan) {\n\t\tiput(iter);\n\t\treturn 0;\n\t}\n\n\ttrace_ocfs2_orphan_filldir((unsigned long long)OCFS2_I(iter)->ip_blkno);\n\t/* No locking is required for the next_orphan queue as there\n\t * is only ever a single process doing orphan recovery. */\n\tOCFS2_I(iter)->ip_next_orphan = p->head;\n\tp->head = iter;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_force_read_journal(struct inode *inode);",
      "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "iter"
          ],
          "line": 2028
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_orphan_filldir",
          "args": [
            "(unsigned long long)OCFS2_I(iter)->ip_blkno"
          ],
          "line": 2025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "iter"
          ],
          "line": 2021
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "iter"
          ],
          "line": 2015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_iget",
          "args": [
            "p->osb",
            "ino",
            "OCFS2_FI_FLAG_ORPHAN_RECOVERY",
            "0"
          ],
          "line": 2013
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "127-206",
          "snippet": "struct inode *ocfs2_iget(struct ocfs2_super *osb, u64 blkno, unsigned flags,\n\t\t\t int sysfile_type)\n{\n\tstruct inode *inode = NULL;\n\tstruct super_block *sb = osb->sb;\n\tstruct ocfs2_find_inode_args args;\n\tjournal_t *journal = OCFS2_SB(sb)->journal->j_journal;\n\n\ttrace_ocfs2_iget_begin((unsigned long long)blkno, flags,\n\t\t\t       sysfile_type);\n\n\t/* Ok. By now we've either got the offsets passed to us by the\n\t * caller, or we just pulled them off the bh. Lets do some\n\t * sanity checks to make sure they're OK. */\n\tif (blkno == 0) {\n\t\tinode = ERR_PTR(-EINVAL);\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tgoto bail;\n\t}\n\n\targs.fi_blkno = blkno;\n\targs.fi_flags = flags;\n\targs.fi_ino = ino_from_blkno(sb, blkno);\n\targs.fi_sysfile_type = sysfile_type;\n\n\tinode = iget5_locked(sb, args.fi_ino, ocfs2_find_actor,\n\t\t\t     ocfs2_init_locked_inode, &args);\n\t/* inode was *not* in the inode cache. 2.6.x requires\n\t * us to do our own read_inode call and unlock it\n\t * afterwards. */\n\tif (inode == NULL) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tgoto bail;\n\t}\n\ttrace_ocfs2_iget5_locked(inode->i_state);\n\tif (inode->i_state & I_NEW) {\n\t\tocfs2_read_locked_inode(inode, &args);\n\t\tunlock_new_inode(inode);\n\t}\n\tif (is_bad_inode(inode)) {\n\t\tiput(inode);\n\t\tinode = ERR_PTR(-ESTALE);\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * Set transaction id's of transactions that have to be committed\n\t * to finish f[data]sync. We set them to currently running transaction\n\t * as we cannot be sure that the inode or some of its metadata isn't\n\t * part of the transaction - the inode could have been reclaimed and\n\t * now it is reread from disk.\n\t */\n\tif (journal) {\n\t\ttransaction_t *transaction;\n\t\ttid_t tid;\n\t\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\t\tread_lock(&journal->j_state_lock);\n\t\tif (journal->j_running_transaction)\n\t\t\ttransaction = journal->j_running_transaction;\n\t\telse\n\t\t\ttransaction = journal->j_committing_transaction;\n\t\tif (transaction)\n\t\t\ttid = transaction->t_tid;\n\t\telse\n\t\t\ttid = journal->j_commit_sequence;\n\t\tread_unlock(&journal->j_state_lock);\n\t\toi->i_sync_tid = tid;\n\t\toi->i_datasync_tid = tid;\n\t}\n\nbail:\n\tif (!IS_ERR(inode)) {\n\t\ttrace_ocfs2_iget_end(inode, \n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t}\n\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_read_locked_inode(struct inode *inode,\n\t\t\t\t   struct ocfs2_find_inode_args *args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_read_locked_inode(struct inode *inode,\n\t\t\t\t   struct ocfs2_find_inode_args *args);\n\nstruct inode *ocfs2_iget(struct ocfs2_super *osb, u64 blkno, unsigned flags,\n\t\t\t int sysfile_type)\n{\n\tstruct inode *inode = NULL;\n\tstruct super_block *sb = osb->sb;\n\tstruct ocfs2_find_inode_args args;\n\tjournal_t *journal = OCFS2_SB(sb)->journal->j_journal;\n\n\ttrace_ocfs2_iget_begin((unsigned long long)blkno, flags,\n\t\t\t       sysfile_type);\n\n\t/* Ok. By now we've either got the offsets passed to us by the\n\t * caller, or we just pulled them off the bh. Lets do some\n\t * sanity checks to make sure they're OK. */\n\tif (blkno == 0) {\n\t\tinode = ERR_PTR(-EINVAL);\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tgoto bail;\n\t}\n\n\targs.fi_blkno = blkno;\n\targs.fi_flags = flags;\n\targs.fi_ino = ino_from_blkno(sb, blkno);\n\targs.fi_sysfile_type = sysfile_type;\n\n\tinode = iget5_locked(sb, args.fi_ino, ocfs2_find_actor,\n\t\t\t     ocfs2_init_locked_inode, &args);\n\t/* inode was *not* in the inode cache. 2.6.x requires\n\t * us to do our own read_inode call and unlock it\n\t * afterwards. */\n\tif (inode == NULL) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tgoto bail;\n\t}\n\ttrace_ocfs2_iget5_locked(inode->i_state);\n\tif (inode->i_state & I_NEW) {\n\t\tocfs2_read_locked_inode(inode, &args);\n\t\tunlock_new_inode(inode);\n\t}\n\tif (is_bad_inode(inode)) {\n\t\tiput(inode);\n\t\tinode = ERR_PTR(-ESTALE);\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * Set transaction id's of transactions that have to be committed\n\t * to finish f[data]sync. We set them to currently running transaction\n\t * as we cannot be sure that the inode or some of its metadata isn't\n\t * part of the transaction - the inode could have been reclaimed and\n\t * now it is reread from disk.\n\t */\n\tif (journal) {\n\t\ttransaction_t *transaction;\n\t\ttid_t tid;\n\t\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\t\tread_lock(&journal->j_state_lock);\n\t\tif (journal->j_running_transaction)\n\t\t\ttransaction = journal->j_running_transaction;\n\t\telse\n\t\t\ttransaction = journal->j_committing_transaction;\n\t\tif (transaction)\n\t\t\ttid = transaction->t_tid;\n\t\telse\n\t\t\ttid = journal->j_commit_sequence;\n\t\tread_unlock(&journal->j_state_lock);\n\t\toi->i_sync_tid = tid;\n\t\toi->i_datasync_tid = tid;\n\t}\n\nbail:\n\tif (!IS_ERR(inode)) {\n\t\ttrace_ocfs2_iget_end(inode, \n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\t}\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "\"..\"",
            "name",
            "2"
          ],
          "line": 2009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "\".\"",
            "name",
            "1"
          ],
          "line": 2007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ctx",
            "structocfs2_orphan_filldir_priv",
            "ctx"
          ],
          "line": 2004
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_force_read_journal(struct inode *inode);\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nstatic int ocfs2_orphan_filldir(struct dir_context *ctx, const char *name,\n\t\t\t\tint name_len, loff_t pos, u64 ino,\n\t\t\t\tunsigned type)\n{\n\tstruct ocfs2_orphan_filldir_priv *p =\n\t\tcontainer_of(ctx, struct ocfs2_orphan_filldir_priv, ctx);\n\tstruct inode *iter;\n\n\tif (name_len == 1 && !strncmp(\".\", name, 1))\n\t\treturn 0;\n\tif (name_len == 2 && !strncmp(\"..\", name, 2))\n\t\treturn 0;\n\n\t/* Skip bad inodes so that recovery can continue */\n\titer = ocfs2_iget(p->osb, ino,\n\t\t\t  OCFS2_FI_FLAG_ORPHAN_RECOVERY, 0);\n\tif (IS_ERR(iter))\n\t\treturn 0;\n\n\t/* Skip inodes which are already added to recover list, since dio may\n\t * happen concurrently with unlink/rename */\n\tif (OCFS2_I(iter)->ip_next_orphan) {\n\t\tiput(iter);\n\t\treturn 0;\n\t}\n\n\ttrace_ocfs2_orphan_filldir((unsigned long long)OCFS2_I(iter)->ip_blkno);\n\t/* No locking is required for the next_orphan queue as there\n\t * is only ever a single process doing orphan recovery. */\n\tOCFS2_I(iter)->ip_next_orphan = p->head;\n\tp->head = iter;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_orphan_scan_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "1978-1991",
    "snippet": "void ocfs2_orphan_scan_start(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_orphan_scan *os;\n\n\tos = &osb->osb_orphan_scan;\n\tos->os_scantime = CURRENT_TIME;\n\tif (ocfs2_is_hard_readonly(osb) || ocfs2_mount_local(osb))\n\t\tatomic_set(&os->os_state, ORPHAN_SCAN_INACTIVE);\n\telse {\n\t\tatomic_set(&os->os_state, ORPHAN_SCAN_ACTIVE);\n\t\tqueue_delayed_work(ocfs2_wq, &os->os_orphan_scan_work,\n\t\t\t\t   ocfs2_orphan_scan_timeout());\n\t}\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_delayed_work",
          "args": [
            "ocfs2_wq",
            "&os->os_orphan_scan_work",
            "ocfs2_orphan_scan_timeout()"
          ],
          "line": 1988
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_sc_queue_delayed_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "481-488",
          "snippet": "static void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;",
            "static void o2net_sc_connect_completed(struct work_struct *work);",
            "static void o2net_rx_until_empty(struct work_struct *work);",
            "static void o2net_shutdown_sc(struct work_struct *work);",
            "static void o2net_sc_send_keep_req(struct work_struct *work);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_orphan_scan_timeout",
          "args": [],
          "line": 1989
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_orphan_scan_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "1851-1858",
          "snippet": "static inline unsigned long ocfs2_orphan_scan_timeout(void)\n{\n\tunsigned long time;\n\n\tget_random_bytes(&time, sizeof(time));\n\ttime = ORPHAN_SCAN_SCHEDULE_TIMEOUT + (time % 5000);\n\treturn msecs_to_jiffies(time);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define ORPHAN_SCAN_SCHEDULE_TIMEOUT 300000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define ORPHAN_SCAN_SCHEDULE_TIMEOUT 300000\n\nstatic inline unsigned long ocfs2_orphan_scan_timeout(void)\n{\n\tunsigned long time;\n\n\tget_random_bytes(&time, sizeof(time));\n\ttime = ORPHAN_SCAN_SCHEDULE_TIMEOUT + (time % 5000);\n\treturn msecs_to_jiffies(time);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&os->os_state",
            "ORPHAN_SCAN_ACTIVE"
          ],
          "line": 1987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&os->os_state",
            "ORPHAN_SCAN_INACTIVE"
          ],
          "line": 1985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_mount_local",
          "args": [
            "osb"
          ],
          "line": 1984
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mount_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "668-671",
          "snippet": "static inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_is_hard_readonly",
          "args": [
            "osb"
          ],
          "line": 1984
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_hard_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "615-624",
          "snippet": "static inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define OCFS2_OSB_HARD_RO\t0x0002"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define OCFS2_OSB_HARD_RO\t0x0002\n\nstatic inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nvoid ocfs2_orphan_scan_start(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_orphan_scan *os;\n\n\tos = &osb->osb_orphan_scan;\n\tos->os_scantime = CURRENT_TIME;\n\tif (ocfs2_is_hard_readonly(osb) || ocfs2_mount_local(osb))\n\t\tatomic_set(&os->os_state, ORPHAN_SCAN_INACTIVE);\n\telse {\n\t\tatomic_set(&os->os_state, ORPHAN_SCAN_ACTIVE);\n\t\tqueue_delayed_work(ocfs2_wq, &os->os_orphan_scan_work,\n\t\t\t\t   ocfs2_orphan_scan_timeout());\n\t}\n}"
  },
  {
    "function_name": "ocfs2_orphan_scan_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "1966-1976",
    "snippet": "void ocfs2_orphan_scan_init(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_orphan_scan *os;\n\n\tos = &osb->osb_orphan_scan;\n\tos->os_osb = osb;\n\tos->os_count = 0;\n\tos->os_seqno = 0;\n\tmutex_init(&os->os_lock);\n\tINIT_DELAYED_WORK(&os->os_orphan_scan_work, ocfs2_orphan_scan_work);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_DELAYED_WORK",
          "args": [
            "&os->os_orphan_scan_work",
            "ocfs2_orphan_scan_work"
          ],
          "line": 1975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&os->os_lock"
          ],
          "line": 1974
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nvoid ocfs2_orphan_scan_init(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_orphan_scan *os;\n\n\tos = &osb->osb_orphan_scan;\n\tos->os_osb = osb;\n\tos->os_count = 0;\n\tos->os_seqno = 0;\n\tmutex_init(&os->os_lock);\n\tINIT_DELAYED_WORK(&os->os_orphan_scan_work, ocfs2_orphan_scan_work);\n}"
  },
  {
    "function_name": "ocfs2_orphan_scan_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "1953-1964",
    "snippet": "void ocfs2_orphan_scan_stop(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_orphan_scan *os;\n\n\tos = &osb->osb_orphan_scan;\n\tif (atomic_read(&os->os_state) == ORPHAN_SCAN_ACTIVE) {\n\t\tatomic_set(&os->os_state, ORPHAN_SCAN_INACTIVE);\n\t\tmutex_lock(&os->os_lock);\n\t\tcancel_delayed_work(&os->os_orphan_scan_work);\n\t\tmutex_unlock(&os->os_lock);\n\t}\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&os->os_lock"
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cancel_delayed_work",
          "args": [
            "&os->os_orphan_scan_work"
          ],
          "line": 1961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&os->os_lock"
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&os->os_state",
            "ORPHAN_SCAN_INACTIVE"
          ],
          "line": 1959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&os->os_state"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nvoid ocfs2_orphan_scan_stop(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_orphan_scan *os;\n\n\tos = &osb->osb_orphan_scan;\n\tif (atomic_read(&os->os_state) == ORPHAN_SCAN_ACTIVE) {\n\t\tatomic_set(&os->os_state, ORPHAN_SCAN_INACTIVE);\n\t\tmutex_lock(&os->os_lock);\n\t\tcancel_delayed_work(&os->os_orphan_scan_work);\n\t\tmutex_unlock(&os->os_lock);\n\t}\n}"
  },
  {
    "function_name": "ocfs2_orphan_scan_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "1936-1951",
    "snippet": "void ocfs2_orphan_scan_work(struct work_struct *work)\n{\n\tstruct ocfs2_orphan_scan *os;\n\tstruct ocfs2_super *osb;\n\n\tos = container_of(work, struct ocfs2_orphan_scan,\n\t\t\t  os_orphan_scan_work.work);\n\tosb = os->os_osb;\n\n\tmutex_lock(&os->os_lock);\n\tocfs2_queue_orphan_scan(osb);\n\tif (atomic_read(&os->os_state) == ORPHAN_SCAN_ACTIVE)\n\t\tqueue_delayed_work(ocfs2_wq, &os->os_orphan_scan_work,\n\t\t\t\t      ocfs2_orphan_scan_timeout());\n\tmutex_unlock(&os->os_lock);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&os->os_lock"
          ],
          "line": 1950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_delayed_work",
          "args": [
            "ocfs2_wq",
            "&os->os_orphan_scan_work",
            "ocfs2_orphan_scan_timeout()"
          ],
          "line": 1948
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_sc_queue_delayed_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "481-488",
          "snippet": "static void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;",
            "static void o2net_sc_connect_completed(struct work_struct *work);",
            "static void o2net_rx_until_empty(struct work_struct *work);",
            "static void o2net_shutdown_sc(struct work_struct *work);",
            "static void o2net_sc_send_keep_req(struct work_struct *work);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_orphan_scan_timeout",
          "args": [],
          "line": 1949
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_orphan_scan_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "1851-1858",
          "snippet": "static inline unsigned long ocfs2_orphan_scan_timeout(void)\n{\n\tunsigned long time;\n\n\tget_random_bytes(&time, sizeof(time));\n\ttime = ORPHAN_SCAN_SCHEDULE_TIMEOUT + (time % 5000);\n\treturn msecs_to_jiffies(time);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define ORPHAN_SCAN_SCHEDULE_TIMEOUT 300000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define ORPHAN_SCAN_SCHEDULE_TIMEOUT 300000\n\nstatic inline unsigned long ocfs2_orphan_scan_timeout(void)\n{\n\tunsigned long time;\n\n\tget_random_bytes(&time, sizeof(time));\n\ttime = ORPHAN_SCAN_SCHEDULE_TIMEOUT + (time % 5000);\n\treturn msecs_to_jiffies(time);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&os->os_state"
          ],
          "line": 1947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_queue_orphan_scan",
          "args": [
            "osb"
          ],
          "line": 1946
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_queue_orphan_scan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "1887-1933",
          "snippet": "void ocfs2_queue_orphan_scan(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_orphan_scan *os;\n\tint status, i;\n\tu32 seqno = 0;\n\n\tos = &osb->osb_orphan_scan;\n\n\tif (atomic_read(&os->os_state) == ORPHAN_SCAN_INACTIVE)\n\t\tgoto out;\n\n\ttrace_ocfs2_queue_orphan_scan_begin(os->os_count, os->os_seqno,\n\t\t\t\t\t    atomic_read(&os->os_state));\n\n\tstatus = ocfs2_orphan_scan_lock(osb, &seqno);\n\tif (status < 0) {\n\t\tif (status != -EAGAIN)\n\t\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\t/* Do no queue the tasks if the volume is being umounted */\n\tif (atomic_read(&os->os_state) == ORPHAN_SCAN_INACTIVE)\n\t\tgoto unlock;\n\n\tif (os->os_seqno != seqno) {\n\t\tos->os_seqno = seqno;\n\t\tgoto unlock;\n\t}\n\n\tfor (i = 0; i < osb->max_slots; i++)\n\t\tocfs2_queue_recovery_completion(osb->journal, i, NULL, NULL,\n\t\t\t\t\t\tNULL, ORPHAN_NO_NEED_TRUNCATE);\n\t/*\n\t * We queued a recovery on orphan slots, increment the sequence\n\t * number and update LVB so other node will skip the scan for a while\n\t */\n\tseqno++;\n\tos->os_count++;\n\tos->os_scantime = CURRENT_TIME;\nunlock:\n\tocfs2_orphan_scan_unlock(osb, seqno);\nout:\n\ttrace_ocfs2_queue_orphan_scan_end(os->os_count, os->os_seqno,\n\t\t\t\t\t  atomic_read(&os->os_state));\n\treturn;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nvoid ocfs2_queue_orphan_scan(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_orphan_scan *os;\n\tint status, i;\n\tu32 seqno = 0;\n\n\tos = &osb->osb_orphan_scan;\n\n\tif (atomic_read(&os->os_state) == ORPHAN_SCAN_INACTIVE)\n\t\tgoto out;\n\n\ttrace_ocfs2_queue_orphan_scan_begin(os->os_count, os->os_seqno,\n\t\t\t\t\t    atomic_read(&os->os_state));\n\n\tstatus = ocfs2_orphan_scan_lock(osb, &seqno);\n\tif (status < 0) {\n\t\tif (status != -EAGAIN)\n\t\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\t/* Do no queue the tasks if the volume is being umounted */\n\tif (atomic_read(&os->os_state) == ORPHAN_SCAN_INACTIVE)\n\t\tgoto unlock;\n\n\tif (os->os_seqno != seqno) {\n\t\tos->os_seqno = seqno;\n\t\tgoto unlock;\n\t}\n\n\tfor (i = 0; i < osb->max_slots; i++)\n\t\tocfs2_queue_recovery_completion(osb->journal, i, NULL, NULL,\n\t\t\t\t\t\tNULL, ORPHAN_NO_NEED_TRUNCATE);\n\t/*\n\t * We queued a recovery on orphan slots, increment the sequence\n\t * number and update LVB so other node will skip the scan for a while\n\t */\n\tseqno++;\n\tos->os_count++;\n\tos->os_scantime = CURRENT_TIME;\nunlock:\n\tocfs2_orphan_scan_unlock(osb, seqno);\nout:\n\ttrace_ocfs2_queue_orphan_scan_end(os->os_count, os->os_seqno,\n\t\t\t\t\t  atomic_read(&os->os_state));\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&os->os_lock"
          ],
          "line": 1945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structocfs2_orphan_scan",
            "os_orphan_scan_work.work"
          ],
          "line": 1941
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nvoid ocfs2_orphan_scan_work(struct work_struct *work)\n{\n\tstruct ocfs2_orphan_scan *os;\n\tstruct ocfs2_super *osb;\n\n\tos = container_of(work, struct ocfs2_orphan_scan,\n\t\t\t  os_orphan_scan_work.work);\n\tosb = os->os_osb;\n\n\tmutex_lock(&os->os_lock);\n\tocfs2_queue_orphan_scan(osb);\n\tif (atomic_read(&os->os_state) == ORPHAN_SCAN_ACTIVE)\n\t\tqueue_delayed_work(ocfs2_wq, &os->os_orphan_scan_work,\n\t\t\t\t      ocfs2_orphan_scan_timeout());\n\tmutex_unlock(&os->os_lock);\n}"
  },
  {
    "function_name": "ocfs2_queue_orphan_scan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "1887-1933",
    "snippet": "void ocfs2_queue_orphan_scan(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_orphan_scan *os;\n\tint status, i;\n\tu32 seqno = 0;\n\n\tos = &osb->osb_orphan_scan;\n\n\tif (atomic_read(&os->os_state) == ORPHAN_SCAN_INACTIVE)\n\t\tgoto out;\n\n\ttrace_ocfs2_queue_orphan_scan_begin(os->os_count, os->os_seqno,\n\t\t\t\t\t    atomic_read(&os->os_state));\n\n\tstatus = ocfs2_orphan_scan_lock(osb, &seqno);\n\tif (status < 0) {\n\t\tif (status != -EAGAIN)\n\t\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\t/* Do no queue the tasks if the volume is being umounted */\n\tif (atomic_read(&os->os_state) == ORPHAN_SCAN_INACTIVE)\n\t\tgoto unlock;\n\n\tif (os->os_seqno != seqno) {\n\t\tos->os_seqno = seqno;\n\t\tgoto unlock;\n\t}\n\n\tfor (i = 0; i < osb->max_slots; i++)\n\t\tocfs2_queue_recovery_completion(osb->journal, i, NULL, NULL,\n\t\t\t\t\t\tNULL, ORPHAN_NO_NEED_TRUNCATE);\n\t/*\n\t * We queued a recovery on orphan slots, increment the sequence\n\t * number and update LVB so other node will skip the scan for a while\n\t */\n\tseqno++;\n\tos->os_count++;\n\tos->os_scantime = CURRENT_TIME;\nunlock:\n\tocfs2_orphan_scan_unlock(osb, seqno);\nout:\n\ttrace_ocfs2_queue_orphan_scan_end(os->os_count, os->os_seqno,\n\t\t\t\t\t  atomic_read(&os->os_state));\n\treturn;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ocfs2_queue_orphan_scan_end",
          "args": [
            "os->os_count",
            "os->os_seqno",
            "atomic_read(&os->os_state)"
          ],
          "line": 1930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&os->os_state"
          ],
          "line": 1931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_orphan_scan_unlock",
          "args": [
            "osb",
            "seqno"
          ],
          "line": 1928
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_orphan_scan_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2534-2546",
          "snippet": "void ocfs2_orphan_scan_unlock(struct ocfs2_super *osb, u32 seqno)\n{\n\tstruct ocfs2_lock_res *lockres;\n\tstruct ocfs2_orphan_scan_lvb *lvb;\n\n\tif (!ocfs2_is_hard_readonly(osb) && !ocfs2_mount_local(osb)) {\n\t\tlockres = &osb->osb_orphan_scan.os_lockres;\n\t\tlvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\t\tlvb->lvb_version = OCFS2_ORPHAN_LVB_VERSION;\n\t\tlvb->lvb_os_seqno = cpu_to_be32(seqno);\n\t\tocfs2_cluster_unlock(osb, lockres, DLM_LOCK_EX);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_orphan_scan_unlock(struct ocfs2_super *osb, u32 seqno)\n{\n\tstruct ocfs2_lock_res *lockres;\n\tstruct ocfs2_orphan_scan_lvb *lvb;\n\n\tif (!ocfs2_is_hard_readonly(osb) && !ocfs2_mount_local(osb)) {\n\t\tlockres = &osb->osb_orphan_scan.os_lockres;\n\t\tlvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\t\tlvb->lvb_version = OCFS2_ORPHAN_LVB_VERSION;\n\t\tlvb->lvb_os_seqno = cpu_to_be32(seqno);\n\t\tocfs2_cluster_unlock(osb, lockres, DLM_LOCK_EX);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_queue_recovery_completion",
          "args": [
            "osb->journal",
            "i",
            "NULL",
            "NULL",
            "NULL",
            "ORPHAN_NO_NEED_TRUNCATE"
          ],
          "line": 1918
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_queue_recovery_completion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "1270-1305",
          "snippet": "static void ocfs2_queue_recovery_completion(struct ocfs2_journal *journal,\n\t\t\t\t\t    int slot_num,\n\t\t\t\t\t    struct ocfs2_dinode *la_dinode,\n\t\t\t\t\t    struct ocfs2_dinode *tl_dinode,\n\t\t\t\t\t    struct ocfs2_quota_recovery *qrec,\n\t\t\t\t\t    enum ocfs2_orphan_reco_type orphan_reco_type)\n{\n\tstruct ocfs2_la_recovery_item *item;\n\n\titem = kmalloc(sizeof(struct ocfs2_la_recovery_item), GFP_NOFS);\n\tif (!item) {\n\t\t/* Though we wish to avoid it, we are in fact safe in\n\t\t * skipping local alloc cleanup as fsck.ocfs2 is more\n\t\t * than capable of reclaiming unused space. */\n\t\tkfree(la_dinode);\n\t\tkfree(tl_dinode);\n\n\t\tif (qrec)\n\t\t\tocfs2_free_quota_recovery(qrec);\n\n\t\tmlog_errno(-ENOMEM);\n\t\treturn;\n\t}\n\n\tINIT_LIST_HEAD(&item->lri_list);\n\titem->lri_la_dinode = la_dinode;\n\titem->lri_slot = slot_num;\n\titem->lri_tl_dinode = tl_dinode;\n\titem->lri_qrec = qrec;\n\titem->lri_orphan_reco_type = orphan_reco_type;\n\n\tspin_lock(&journal->j_lock);\n\tlist_add_tail(&item->lri_list, &journal->j_la_cleanups);\n\tqueue_work(ocfs2_wq, &journal->j_recovery_work);\n\tspin_unlock(&journal->j_lock);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);",
            "static int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);",
            "static int ocfs2_recover_orphans(struct ocfs2_super *osb,\n\t\t\t\t int slot,\n\t\t\t\t enum ocfs2_orphan_reco_type orphan_reco_type);",
            "static void ocfs2_queue_recovery_completion(struct ocfs2_journal *journal,\n\t\t\t\t\t    int slot_num,\n\t\t\t\t\t    struct ocfs2_dinode *la_dinode,\n\t\t\t\t\t    struct ocfs2_dinode *tl_dinode,\n\t\t\t\t\t    struct ocfs2_quota_recovery *qrec,\n\t\t\t\t\t    enum ocfs2_orphan_reco_type orphan_reco_type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);\nstatic int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);\nstatic int ocfs2_recover_orphans(struct ocfs2_super *osb,\n\t\t\t\t int slot,\n\t\t\t\t enum ocfs2_orphan_reco_type orphan_reco_type);\nstatic void ocfs2_queue_recovery_completion(struct ocfs2_journal *journal,\n\t\t\t\t\t    int slot_num,\n\t\t\t\t\t    struct ocfs2_dinode *la_dinode,\n\t\t\t\t\t    struct ocfs2_dinode *tl_dinode,\n\t\t\t\t\t    struct ocfs2_quota_recovery *qrec,\n\t\t\t\t\t    enum ocfs2_orphan_reco_type orphan_reco_type);\n\nstatic void ocfs2_queue_recovery_completion(struct ocfs2_journal *journal,\n\t\t\t\t\t    int slot_num,\n\t\t\t\t\t    struct ocfs2_dinode *la_dinode,\n\t\t\t\t\t    struct ocfs2_dinode *tl_dinode,\n\t\t\t\t\t    struct ocfs2_quota_recovery *qrec,\n\t\t\t\t\t    enum ocfs2_orphan_reco_type orphan_reco_type)\n{\n\tstruct ocfs2_la_recovery_item *item;\n\n\titem = kmalloc(sizeof(struct ocfs2_la_recovery_item), GFP_NOFS);\n\tif (!item) {\n\t\t/* Though we wish to avoid it, we are in fact safe in\n\t\t * skipping local alloc cleanup as fsck.ocfs2 is more\n\t\t * than capable of reclaiming unused space. */\n\t\tkfree(la_dinode);\n\t\tkfree(tl_dinode);\n\n\t\tif (qrec)\n\t\t\tocfs2_free_quota_recovery(qrec);\n\n\t\tmlog_errno(-ENOMEM);\n\t\treturn;\n\t}\n\n\tINIT_LIST_HEAD(&item->lri_list);\n\titem->lri_la_dinode = la_dinode;\n\titem->lri_slot = slot_num;\n\titem->lri_tl_dinode = tl_dinode;\n\titem->lri_qrec = qrec;\n\titem->lri_orphan_reco_type = orphan_reco_type;\n\n\tspin_lock(&journal->j_lock);\n\tlist_add_tail(&item->lri_list, &journal->j_la_cleanups);\n\tqueue_work(ocfs2_wq, &journal->j_recovery_work);\n\tspin_unlock(&journal->j_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&os->os_state"
          ],
          "line": 1909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_orphan_scan_lock",
          "args": [
            "osb",
            "&seqno"
          ],
          "line": 1901
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_orphan_scan_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2507-2532",
          "snippet": "int ocfs2_orphan_scan_lock(struct ocfs2_super *osb, u32 *seqno)\n{\n\tstruct ocfs2_lock_res *lockres;\n\tstruct ocfs2_orphan_scan_lvb *lvb;\n\tint status = 0;\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn -EROFS;\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn 0;\n\n\tlockres = &osb->osb_orphan_scan.os_lockres;\n\tstatus = ocfs2_cluster_lock(osb, lockres, DLM_LOCK_EX, 0, 0);\n\tif (status < 0)\n\t\treturn status;\n\n\tlvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\tif (ocfs2_dlm_lvb_valid(&lockres->l_lksb) &&\n\t    lvb->lvb_version == OCFS2_ORPHAN_LVB_VERSION)\n\t\t*seqno = be32_to_cpu(lvb->lvb_os_seqno);\n\telse\n\t\t*seqno = osb->osb_orphan_scan.os_seqno + 1;\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nint ocfs2_orphan_scan_lock(struct ocfs2_super *osb, u32 *seqno)\n{\n\tstruct ocfs2_lock_res *lockres;\n\tstruct ocfs2_orphan_scan_lvb *lvb;\n\tint status = 0;\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn -EROFS;\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn 0;\n\n\tlockres = &osb->osb_orphan_scan.os_lockres;\n\tstatus = ocfs2_cluster_lock(osb, lockres, DLM_LOCK_EX, 0, 0);\n\tif (status < 0)\n\t\treturn status;\n\n\tlvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\tif (ocfs2_dlm_lvb_valid(&lockres->l_lksb) &&\n\t    lvb->lvb_version == OCFS2_ORPHAN_LVB_VERSION)\n\t\t*seqno = be32_to_cpu(lvb->lvb_os_seqno);\n\telse\n\t\t*seqno = osb->osb_orphan_scan.os_seqno + 1;\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_queue_orphan_scan_begin",
          "args": [
            "os->os_count",
            "os->os_seqno",
            "atomic_read(&os->os_state)"
          ],
          "line": 1898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&os->os_state"
          ],
          "line": 1899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&os->os_state"
          ],
          "line": 1895
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nvoid ocfs2_queue_orphan_scan(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_orphan_scan *os;\n\tint status, i;\n\tu32 seqno = 0;\n\n\tos = &osb->osb_orphan_scan;\n\n\tif (atomic_read(&os->os_state) == ORPHAN_SCAN_INACTIVE)\n\t\tgoto out;\n\n\ttrace_ocfs2_queue_orphan_scan_begin(os->os_count, os->os_seqno,\n\t\t\t\t\t    atomic_read(&os->os_state));\n\n\tstatus = ocfs2_orphan_scan_lock(osb, &seqno);\n\tif (status < 0) {\n\t\tif (status != -EAGAIN)\n\t\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\t/* Do no queue the tasks if the volume is being umounted */\n\tif (atomic_read(&os->os_state) == ORPHAN_SCAN_INACTIVE)\n\t\tgoto unlock;\n\n\tif (os->os_seqno != seqno) {\n\t\tos->os_seqno = seqno;\n\t\tgoto unlock;\n\t}\n\n\tfor (i = 0; i < osb->max_slots; i++)\n\t\tocfs2_queue_recovery_completion(osb->journal, i, NULL, NULL,\n\t\t\t\t\t\tNULL, ORPHAN_NO_NEED_TRUNCATE);\n\t/*\n\t * We queued a recovery on orphan slots, increment the sequence\n\t * number and update LVB so other node will skip the scan for a while\n\t */\n\tseqno++;\n\tos->os_count++;\n\tos->os_scantime = CURRENT_TIME;\nunlock:\n\tocfs2_orphan_scan_unlock(osb, seqno);\nout:\n\ttrace_ocfs2_queue_orphan_scan_end(os->os_count, os->os_seqno,\n\t\t\t\t\t  atomic_read(&os->os_state));\n\treturn;\n}"
  },
  {
    "function_name": "ocfs2_orphan_scan_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "1851-1858",
    "snippet": "static inline unsigned long ocfs2_orphan_scan_timeout(void)\n{\n\tunsigned long time;\n\n\tget_random_bytes(&time, sizeof(time));\n\ttime = ORPHAN_SCAN_SCHEDULE_TIMEOUT + (time % 5000);\n\treturn msecs_to_jiffies(time);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define ORPHAN_SCAN_SCHEDULE_TIMEOUT 300000"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "time"
          ],
          "line": 1857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_random_bytes",
          "args": [
            "&time",
            "sizeof(time)"
          ],
          "line": 1855
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define ORPHAN_SCAN_SCHEDULE_TIMEOUT 300000\n\nstatic inline unsigned long ocfs2_orphan_scan_timeout(void)\n{\n\tunsigned long time;\n\n\tget_random_bytes(&time, sizeof(time));\n\ttime = ORPHAN_SCAN_SCHEDULE_TIMEOUT + (time % 5000);\n\treturn msecs_to_jiffies(time);\n}"
  },
  {
    "function_name": "ocfs2_mark_dead_nodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "1780-1844",
    "snippet": "int ocfs2_mark_dead_nodes(struct ocfs2_super *osb)\n{\n\tunsigned int node_num;\n\tint status, i;\n\tu32 gen;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_dinode *di;\n\n\t/* This is called with the super block cluster lock, so we\n\t * know that the slot map can't change underneath us. */\n\n\tfor (i = 0; i < osb->max_slots; i++) {\n\t\t/* Read journal inode to get the recovery generation */\n\t\tstatus = ocfs2_read_journal_inode(osb, i, &bh, NULL);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tdi = (struct ocfs2_dinode *)bh->b_data;\n\t\tgen = ocfs2_get_recovery_generation(di);\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\n\t\tspin_lock(&osb->osb_lock);\n\t\tosb->slot_recovery_generations[i] = gen;\n\n\t\ttrace_ocfs2_mark_dead_nodes(i,\n\t\t\t\t\t    osb->slot_recovery_generations[i]);\n\n\t\tif (i == osb->slot_num) {\n\t\t\tspin_unlock(&osb->osb_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tstatus = ocfs2_slot_to_node_num_locked(osb, i, &node_num);\n\t\tif (status == -ENOENT) {\n\t\t\tspin_unlock(&osb->osb_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (__ocfs2_recovery_map_test(osb, node_num)) {\n\t\t\tspin_unlock(&osb->osb_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&osb->osb_lock);\n\n\t\t/* Ok, we have a slot occupied by another node which\n\t\t * is not in the recovery map. We trylock his journal\n\t\t * file here to test if he's alive. */\n\t\tstatus = ocfs2_trylock_journal(osb, i);\n\t\tif (!status) {\n\t\t\t/* Since we're called from mount, we know that\n\t\t\t * the recovery thread can't race us on\n\t\t\t * setting / checking the recovery bits. */\n\t\t\tocfs2_recovery_thread(osb, node_num);\n\t\t} else if ((status < 0) && (status != -EAGAIN)) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\nbail:\n\treturn status;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_force_read_journal(struct inode *inode);",
      "static int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);",
      "static int ocfs2_commit_cache(struct ocfs2_super *osb);",
      "static int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_recovery_thread",
          "args": [
            "osb",
            "node_num"
          ],
          "line": 1834
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_recovery_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "1467-1492",
          "snippet": "void ocfs2_recovery_thread(struct ocfs2_super *osb, int node_num)\n{\n\tmutex_lock(&osb->recovery_lock);\n\n\ttrace_ocfs2_recovery_thread(node_num, osb->node_num,\n\t\tosb->disable_recovery, osb->recovery_thread_task,\n\t\tosb->disable_recovery ?\n\t\t-1 : ocfs2_recovery_map_set(osb, node_num));\n\n\tif (osb->disable_recovery)\n\t\tgoto out;\n\n\tif (osb->recovery_thread_task)\n\t\tgoto out;\n\n\tosb->recovery_thread_task =  kthread_run(__ocfs2_recovery_thread, osb,\n\t\t\t\t\t\t \"ocfs2rec\");\n\tif (IS_ERR(osb->recovery_thread_task)) {\n\t\tmlog_errno((int)PTR_ERR(osb->recovery_thread_task));\n\t\tosb->recovery_thread_task = NULL;\n\t}\n\nout:\n\tmutex_unlock(&osb->recovery_lock);\n\twake_up(&osb->recovery_event);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nvoid ocfs2_recovery_thread(struct ocfs2_super *osb, int node_num)\n{\n\tmutex_lock(&osb->recovery_lock);\n\n\ttrace_ocfs2_recovery_thread(node_num, osb->node_num,\n\t\tosb->disable_recovery, osb->recovery_thread_task,\n\t\tosb->disable_recovery ?\n\t\t-1 : ocfs2_recovery_map_set(osb, node_num));\n\n\tif (osb->disable_recovery)\n\t\tgoto out;\n\n\tif (osb->recovery_thread_task)\n\t\tgoto out;\n\n\tosb->recovery_thread_task =  kthread_run(__ocfs2_recovery_thread, osb,\n\t\t\t\t\t\t \"ocfs2rec\");\n\tif (IS_ERR(osb->recovery_thread_task)) {\n\t\tmlog_errno((int)PTR_ERR(osb->recovery_thread_task));\n\t\tosb->recovery_thread_task = NULL;\n\t}\n\nout:\n\tmutex_unlock(&osb->recovery_lock);\n\twake_up(&osb->recovery_event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_trylock_journal",
          "args": [
            "osb",
            "i"
          ],
          "line": 1829
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_trylock_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "1740-1776",
          "snippet": "static int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num)\n{\n\tint status, flags;\n\tstruct inode *inode = NULL;\n\n\tinode = ocfs2_get_system_file_inode(osb, JOURNAL_SYSTEM_INODE,\n\t\t\t\t\t    slot_num);\n\tif (inode == NULL) {\n\t\tmlog(ML_ERROR, \"access error\\n\");\n\t\tstatus = -EACCES;\n\t\tgoto bail;\n\t}\n\tif (is_bad_inode(inode)) {\n\t\tmlog(ML_ERROR, \"access error (bad inode)\\n\");\n\t\tiput(inode);\n\t\tinode = NULL;\n\t\tstatus = -EACCES;\n\t\tgoto bail;\n\t}\n\tSET_INODE_JOURNAL(inode);\n\n\tflags = OCFS2_META_LOCK_RECOVERY | OCFS2_META_LOCK_NOQUEUE;\n\tstatus = ocfs2_inode_lock_full(inode, NULL, 1, flags);\n\tif (status < 0) {\n\t\tif (status != -EAGAIN)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_inode_unlock(inode, 1);\nbail:\n\tif (inode)\n\t\tiput(inode);\n\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_force_read_journal(struct inode *inode);",
            "static int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);",
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);",
            "static int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_force_read_journal(struct inode *inode);\nstatic int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\nstatic int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);\n\nstatic int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num)\n{\n\tint status, flags;\n\tstruct inode *inode = NULL;\n\n\tinode = ocfs2_get_system_file_inode(osb, JOURNAL_SYSTEM_INODE,\n\t\t\t\t\t    slot_num);\n\tif (inode == NULL) {\n\t\tmlog(ML_ERROR, \"access error\\n\");\n\t\tstatus = -EACCES;\n\t\tgoto bail;\n\t}\n\tif (is_bad_inode(inode)) {\n\t\tmlog(ML_ERROR, \"access error (bad inode)\\n\");\n\t\tiput(inode);\n\t\tinode = NULL;\n\t\tstatus = -EACCES;\n\t\tgoto bail;\n\t}\n\tSET_INODE_JOURNAL(inode);\n\n\tflags = OCFS2_META_LOCK_RECOVERY | OCFS2_META_LOCK_NOQUEUE;\n\tstatus = ocfs2_inode_lock_full(inode, NULL, 1, flags);\n\tif (status < 0) {\n\t\tif (status != -EAGAIN)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_inode_unlock(inode, 1);\nbail:\n\tif (inode)\n\t\tiput(inode);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 1824
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ocfs2_recovery_map_test",
          "args": [
            "osb",
            "node_num"
          ],
          "line": 1820
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_recovery_map_test",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "246-260",
          "snippet": "static int __ocfs2_recovery_map_test(struct ocfs2_super *osb,\n\t\t\t\t     unsigned int node_num)\n{\n\tint i;\n\tstruct ocfs2_recovery_map *rm = osb->recovery_map;\n\n\tassert_spin_locked(&osb->osb_lock);\n\n\tfor (i = 0; i < rm->rm_used; i++) {\n\t\tif (rm->rm_entries[i] == node_num)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nstatic int __ocfs2_recovery_map_test(struct ocfs2_super *osb,\n\t\t\t\t     unsigned int node_num)\n{\n\tint i;\n\tstruct ocfs2_recovery_map *rm = osb->recovery_map;\n\n\tassert_spin_locked(&osb->osb_lock);\n\n\tfor (i = 0; i < rm->rm_used; i++) {\n\t\tif (rm->rm_entries[i] == node_num)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_slot_to_node_num_locked",
          "args": [
            "osb",
            "i",
            "&node_num"
          ],
          "line": 1814
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_slot_to_node_num_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
          "lines": "301-316",
          "snippet": "int ocfs2_slot_to_node_num_locked(struct ocfs2_super *osb, int slot_num,\n\t\t\t\t  unsigned int *node_num)\n{\n\tstruct ocfs2_slot_info *si = osb->slot_info;\n\n\tassert_spin_locked(&osb->osb_lock);\n\n\tBUG_ON(slot_num < 0);\n\tBUG_ON(slot_num >= osb->max_slots);\n\n\tif (!si->si_slots[slot_num].sl_valid)\n\t\treturn -ENOENT;\n\n\t*node_num = si->si_slots[slot_num].sl_node_num;\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __ocfs2_node_num_to_slot(struct ocfs2_slot_info *si,\n\t\t\t\t    unsigned int node_num);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int __ocfs2_node_num_to_slot(struct ocfs2_slot_info *si,\n\t\t\t\t    unsigned int node_num);\n\nint ocfs2_slot_to_node_num_locked(struct ocfs2_super *osb, int slot_num,\n\t\t\t\t  unsigned int *node_num)\n{\n\tstruct ocfs2_slot_info *si = osb->slot_info;\n\n\tassert_spin_locked(&osb->osb_lock);\n\n\tBUG_ON(slot_num < 0);\n\tBUG_ON(slot_num >= osb->max_slots);\n\n\tif (!si->si_slots[slot_num].sl_valid)\n\t\treturn -ENOENT;\n\n\t*node_num = si->si_slots[slot_num].sl_node_num;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_mark_dead_nodes",
          "args": [
            "i",
            "osb->slot_recovery_generations[i]"
          ],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 1803
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1800
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_get_recovery_generation",
          "args": [
            "di"
          ],
          "line": 1799
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_recovery_generation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "898-901",
          "snippet": "static u32 ocfs2_get_recovery_generation(struct ocfs2_dinode *di)\n{\n\treturn le32_to_cpu(di->id1.journal1.ij_recovery_generation);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u32 ocfs2_get_recovery_generation(struct ocfs2_dinode *di)\n{\n\treturn le32_to_cpu(di->id1.journal1.ij_recovery_generation);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_journal_inode",
          "args": [
            "osb",
            "i",
            "&bh",
            "NULL"
          ],
          "line": 1793
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_journal_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "1494-1528",
          "snippet": "static int ocfs2_read_journal_inode(struct ocfs2_super *osb,\n\t\t\t\t    int slot_num,\n\t\t\t\t    struct buffer_head **bh,\n\t\t\t\t    struct inode **ret_inode)\n{\n\tint status = -EACCES;\n\tstruct inode *inode = NULL;\n\n\tBUG_ON(slot_num >= osb->max_slots);\n\n\tinode = ocfs2_get_system_file_inode(osb, JOURNAL_SYSTEM_INODE,\n\t\t\t\t\t    slot_num);\n\tif (!inode || is_bad_inode(inode)) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tSET_INODE_JOURNAL(inode);\n\n\tstatus = ocfs2_read_inode_block_full(inode, bh, OCFS2_BH_IGNORE_CACHE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\n\nbail:\n\tif (inode) {\n\t\tif (status || !ret_inode)\n\t\t\tiput(inode);\n\t\telse\n\t\t\t*ret_inode = inode;\n\t}\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_force_read_journal(struct inode *inode);",
            "static int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);",
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);",
            "static int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_force_read_journal(struct inode *inode);\nstatic int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\nstatic int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);\n\nstatic int ocfs2_read_journal_inode(struct ocfs2_super *osb,\n\t\t\t\t    int slot_num,\n\t\t\t\t    struct buffer_head **bh,\n\t\t\t\t    struct inode **ret_inode)\n{\n\tint status = -EACCES;\n\tstruct inode *inode = NULL;\n\n\tBUG_ON(slot_num >= osb->max_slots);\n\n\tinode = ocfs2_get_system_file_inode(osb, JOURNAL_SYSTEM_INODE,\n\t\t\t\t\t    slot_num);\n\tif (!inode || is_bad_inode(inode)) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tSET_INODE_JOURNAL(inode);\n\n\tstatus = ocfs2_read_inode_block_full(inode, bh, OCFS2_BH_IGNORE_CACHE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\n\nbail:\n\tif (inode) {\n\t\tif (status || !ret_inode)\n\t\t\tiput(inode);\n\t\telse\n\t\t\t*ret_inode = inode;\n\t}\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_force_read_journal(struct inode *inode);\nstatic int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\nstatic int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);\n\nint ocfs2_mark_dead_nodes(struct ocfs2_super *osb)\n{\n\tunsigned int node_num;\n\tint status, i;\n\tu32 gen;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_dinode *di;\n\n\t/* This is called with the super block cluster lock, so we\n\t * know that the slot map can't change underneath us. */\n\n\tfor (i = 0; i < osb->max_slots; i++) {\n\t\t/* Read journal inode to get the recovery generation */\n\t\tstatus = ocfs2_read_journal_inode(osb, i, &bh, NULL);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t\tdi = (struct ocfs2_dinode *)bh->b_data;\n\t\tgen = ocfs2_get_recovery_generation(di);\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\n\t\tspin_lock(&osb->osb_lock);\n\t\tosb->slot_recovery_generations[i] = gen;\n\n\t\ttrace_ocfs2_mark_dead_nodes(i,\n\t\t\t\t\t    osb->slot_recovery_generations[i]);\n\n\t\tif (i == osb->slot_num) {\n\t\t\tspin_unlock(&osb->osb_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tstatus = ocfs2_slot_to_node_num_locked(osb, i, &node_num);\n\t\tif (status == -ENOENT) {\n\t\t\tspin_unlock(&osb->osb_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (__ocfs2_recovery_map_test(osb, node_num)) {\n\t\t\tspin_unlock(&osb->osb_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&osb->osb_lock);\n\n\t\t/* Ok, we have a slot occupied by another node which\n\t\t * is not in the recovery map. We trylock his journal\n\t\t * file here to test if he's alive. */\n\t\tstatus = ocfs2_trylock_journal(osb, i);\n\t\tif (!status) {\n\t\t\t/* Since we're called from mount, we know that\n\t\t\t * the recovery thread can't race us on\n\t\t\t * setting / checking the recovery bits. */\n\t\t\tocfs2_recovery_thread(osb, node_num);\n\t\t} else if ((status < 0) && (status != -EAGAIN)) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\nbail:\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_trylock_journal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "1740-1776",
    "snippet": "static int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num)\n{\n\tint status, flags;\n\tstruct inode *inode = NULL;\n\n\tinode = ocfs2_get_system_file_inode(osb, JOURNAL_SYSTEM_INODE,\n\t\t\t\t\t    slot_num);\n\tif (inode == NULL) {\n\t\tmlog(ML_ERROR, \"access error\\n\");\n\t\tstatus = -EACCES;\n\t\tgoto bail;\n\t}\n\tif (is_bad_inode(inode)) {\n\t\tmlog(ML_ERROR, \"access error (bad inode)\\n\");\n\t\tiput(inode);\n\t\tinode = NULL;\n\t\tstatus = -EACCES;\n\t\tgoto bail;\n\t}\n\tSET_INODE_JOURNAL(inode);\n\n\tflags = OCFS2_META_LOCK_RECOVERY | OCFS2_META_LOCK_NOQUEUE;\n\tstatus = ocfs2_inode_lock_full(inode, NULL, 1, flags);\n\tif (status < 0) {\n\t\tif (status != -EAGAIN)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_inode_unlock(inode, 1);\nbail:\n\tif (inode)\n\t\tiput(inode);\n\n\treturn status;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_force_read_journal(struct inode *inode);",
      "static int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);",
      "static int ocfs2_commit_cache(struct ocfs2_super *osb);",
      "static int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 1773
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "inode",
            "1"
          ],
          "line": 1770
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock_full",
          "args": [
            "inode",
            "NULL",
            "1",
            "flags"
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_INODE_JOURNAL",
          "args": [
            "inode"
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"access error (bad inode)\\n\""
          ],
          "line": 1754
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "inode"
          ],
          "line": 1753
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_get_system_file_inode",
          "args": [
            "osb",
            "JOURNAL_SYSTEM_INODE",
            "slot_num"
          ],
          "line": 1746
        },
        "resolved": true,
        "details": {
          "function_name": "_ocfs2_get_system_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/sysfile.c",
          "lines": "138-181",
          "snippet": "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_force_read_journal(struct inode *inode);\nstatic int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\nstatic int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);\n\nstatic int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num)\n{\n\tint status, flags;\n\tstruct inode *inode = NULL;\n\n\tinode = ocfs2_get_system_file_inode(osb, JOURNAL_SYSTEM_INODE,\n\t\t\t\t\t    slot_num);\n\tif (inode == NULL) {\n\t\tmlog(ML_ERROR, \"access error\\n\");\n\t\tstatus = -EACCES;\n\t\tgoto bail;\n\t}\n\tif (is_bad_inode(inode)) {\n\t\tmlog(ML_ERROR, \"access error (bad inode)\\n\");\n\t\tiput(inode);\n\t\tinode = NULL;\n\t\tstatus = -EACCES;\n\t\tgoto bail;\n\t}\n\tSET_INODE_JOURNAL(inode);\n\n\tflags = OCFS2_META_LOCK_RECOVERY | OCFS2_META_LOCK_NOQUEUE;\n\tstatus = ocfs2_inode_lock_full(inode, NULL, 1, flags);\n\tif (status < 0) {\n\t\tif (status != -EAGAIN)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_inode_unlock(inode, 1);\nbail:\n\tif (inode)\n\t\tiput(inode);\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_recover_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "1683-1735",
    "snippet": "static int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num)\n{\n\tint status = 0;\n\tstruct ocfs2_dinode *la_copy = NULL;\n\tstruct ocfs2_dinode *tl_copy = NULL;\n\n\ttrace_ocfs2_recover_node(node_num, slot_num, osb->node_num);\n\n\t/* Should not ever be called to recover ourselves -- in that\n\t * case we should've called ocfs2_journal_load instead. */\n\tBUG_ON(osb->node_num == node_num);\n\n\tstatus = ocfs2_replay_journal(osb, node_num, slot_num);\n\tif (status < 0) {\n\t\tif (status == -EBUSY) {\n\t\t\ttrace_ocfs2_recover_node_skip(slot_num, node_num);\n\t\t\tstatus = 0;\n\t\t\tgoto done;\n\t\t}\n\t\tmlog_errno(status);\n\t\tgoto done;\n\t}\n\n\t/* Stamp a clean local alloc file AFTER recovering the journal... */\n\tstatus = ocfs2_begin_local_alloc_recovery(osb, slot_num, &la_copy);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto done;\n\t}\n\n\t/* An error from begin_truncate_log_recovery is not\n\t * serious enough to warrant halting the rest of\n\t * recovery. */\n\tstatus = ocfs2_begin_truncate_log_recovery(osb, slot_num, &tl_copy);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\t/* Likewise, this would be a strange but ultimately not so\n\t * harmful place to get an error... */\n\tstatus = ocfs2_clear_slot(osb, slot_num);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\t/* This will kfree the memory pointed to by la_copy and tl_copy */\n\tocfs2_queue_recovery_completion(osb->journal, slot_num, la_copy,\n\t\t\t\t\ttl_copy, NULL, ORPHAN_NEED_TRUNCATE);\n\n\tstatus = 0;\ndone:\n\n\treturn status;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);",
      "static int ocfs2_commit_cache(struct ocfs2_super *osb);",
      "static int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_queue_recovery_completion",
          "args": [
            "osb->journal",
            "slot_num",
            "la_copy",
            "tl_copy",
            "NULL",
            "ORPHAN_NEED_TRUNCATE"
          ],
          "line": 1728
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_queue_recovery_completion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "1270-1305",
          "snippet": "static void ocfs2_queue_recovery_completion(struct ocfs2_journal *journal,\n\t\t\t\t\t    int slot_num,\n\t\t\t\t\t    struct ocfs2_dinode *la_dinode,\n\t\t\t\t\t    struct ocfs2_dinode *tl_dinode,\n\t\t\t\t\t    struct ocfs2_quota_recovery *qrec,\n\t\t\t\t\t    enum ocfs2_orphan_reco_type orphan_reco_type)\n{\n\tstruct ocfs2_la_recovery_item *item;\n\n\titem = kmalloc(sizeof(struct ocfs2_la_recovery_item), GFP_NOFS);\n\tif (!item) {\n\t\t/* Though we wish to avoid it, we are in fact safe in\n\t\t * skipping local alloc cleanup as fsck.ocfs2 is more\n\t\t * than capable of reclaiming unused space. */\n\t\tkfree(la_dinode);\n\t\tkfree(tl_dinode);\n\n\t\tif (qrec)\n\t\t\tocfs2_free_quota_recovery(qrec);\n\n\t\tmlog_errno(-ENOMEM);\n\t\treturn;\n\t}\n\n\tINIT_LIST_HEAD(&item->lri_list);\n\titem->lri_la_dinode = la_dinode;\n\titem->lri_slot = slot_num;\n\titem->lri_tl_dinode = tl_dinode;\n\titem->lri_qrec = qrec;\n\titem->lri_orphan_reco_type = orphan_reco_type;\n\n\tspin_lock(&journal->j_lock);\n\tlist_add_tail(&item->lri_list, &journal->j_la_cleanups);\n\tqueue_work(ocfs2_wq, &journal->j_recovery_work);\n\tspin_unlock(&journal->j_lock);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);",
            "static int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);",
            "static int ocfs2_recover_orphans(struct ocfs2_super *osb,\n\t\t\t\t int slot,\n\t\t\t\t enum ocfs2_orphan_reco_type orphan_reco_type);",
            "static void ocfs2_queue_recovery_completion(struct ocfs2_journal *journal,\n\t\t\t\t\t    int slot_num,\n\t\t\t\t\t    struct ocfs2_dinode *la_dinode,\n\t\t\t\t\t    struct ocfs2_dinode *tl_dinode,\n\t\t\t\t\t    struct ocfs2_quota_recovery *qrec,\n\t\t\t\t\t    enum ocfs2_orphan_reco_type orphan_reco_type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);\nstatic int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);\nstatic int ocfs2_recover_orphans(struct ocfs2_super *osb,\n\t\t\t\t int slot,\n\t\t\t\t enum ocfs2_orphan_reco_type orphan_reco_type);\nstatic void ocfs2_queue_recovery_completion(struct ocfs2_journal *journal,\n\t\t\t\t\t    int slot_num,\n\t\t\t\t\t    struct ocfs2_dinode *la_dinode,\n\t\t\t\t\t    struct ocfs2_dinode *tl_dinode,\n\t\t\t\t\t    struct ocfs2_quota_recovery *qrec,\n\t\t\t\t\t    enum ocfs2_orphan_reco_type orphan_reco_type);\n\nstatic void ocfs2_queue_recovery_completion(struct ocfs2_journal *journal,\n\t\t\t\t\t    int slot_num,\n\t\t\t\t\t    struct ocfs2_dinode *la_dinode,\n\t\t\t\t\t    struct ocfs2_dinode *tl_dinode,\n\t\t\t\t\t    struct ocfs2_quota_recovery *qrec,\n\t\t\t\t\t    enum ocfs2_orphan_reco_type orphan_reco_type)\n{\n\tstruct ocfs2_la_recovery_item *item;\n\n\titem = kmalloc(sizeof(struct ocfs2_la_recovery_item), GFP_NOFS);\n\tif (!item) {\n\t\t/* Though we wish to avoid it, we are in fact safe in\n\t\t * skipping local alloc cleanup as fsck.ocfs2 is more\n\t\t * than capable of reclaiming unused space. */\n\t\tkfree(la_dinode);\n\t\tkfree(tl_dinode);\n\n\t\tif (qrec)\n\t\t\tocfs2_free_quota_recovery(qrec);\n\n\t\tmlog_errno(-ENOMEM);\n\t\treturn;\n\t}\n\n\tINIT_LIST_HEAD(&item->lri_list);\n\titem->lri_la_dinode = la_dinode;\n\titem->lri_slot = slot_num;\n\titem->lri_tl_dinode = tl_dinode;\n\titem->lri_qrec = qrec;\n\titem->lri_orphan_reco_type = orphan_reco_type;\n\n\tspin_lock(&journal->j_lock);\n\tlist_add_tail(&item->lri_list, &journal->j_la_cleanups);\n\tqueue_work(ocfs2_wq, &journal->j_recovery_work);\n\tspin_unlock(&journal->j_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clear_slot",
          "args": [
            "osb",
            "slot_num"
          ],
          "line": 1723
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
          "lines": "340-352",
          "snippet": "int ocfs2_clear_slot(struct ocfs2_super *osb, int slot_num)\n{\n\tstruct ocfs2_slot_info *si = osb->slot_info;\n\n\tif (si == NULL)\n\t\treturn 0;\n\n\tspin_lock(&osb->osb_lock);\n\tocfs2_invalidate_slot(si, slot_num);\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ocfs2_update_disk_slot(osb, osb->slot_info, slot_num);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nint ocfs2_clear_slot(struct ocfs2_super *osb, int slot_num)\n{\n\tstruct ocfs2_slot_info *si = osb->slot_info;\n\n\tif (si == NULL)\n\t\treturn 0;\n\n\tspin_lock(&osb->osb_lock);\n\tocfs2_invalidate_slot(si, slot_num);\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ocfs2_update_disk_slot(osb, osb->slot_info, slot_num);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_begin_truncate_log_recovery",
          "args": [
            "osb",
            "slot_num",
            "&tl_copy"
          ],
          "line": 1717
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_begin_truncate_log_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6107-6173",
          "snippet": "int ocfs2_begin_truncate_log_recovery(struct ocfs2_super *osb,\n\t\t\t\t      int slot_num,\n\t\t\t\t      struct ocfs2_dinode **tl_copy)\n{\n\tint status;\n\tstruct inode *tl_inode = NULL;\n\tstruct buffer_head *tl_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\t*tl_copy = NULL;\n\n\ttrace_ocfs2_begin_truncate_log_recovery(slot_num);\n\n\tstatus = ocfs2_get_truncate_log_info(osb, slot_num, &tl_inode, &tl_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_get_truncate_log_info().  It's\n\t * validated by the underlying call to ocfs2_read_inode_block(),\n\t * so any corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\tif (le16_to_cpu(tl->tl_used)) {\n\t\ttrace_ocfs2_truncate_log_recovery_num(le16_to_cpu(tl->tl_used));\n\n\t\t*tl_copy = kmalloc(tl_bh->b_size, GFP_KERNEL);\n\t\tif (!(*tl_copy)) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/* Assuming the write-out below goes well, this copy\n\t\t * will be passed back to recovery for processing. */\n\t\tmemcpy(*tl_copy, tl_bh->b_data, tl_bh->b_size);\n\n\t\t/* All we need to do to clear the truncate log is set\n\t\t * tl_used. */\n\t\ttl->tl_used = 0;\n\n\t\tocfs2_compute_meta_ecc(osb->sb, tl_bh->b_data, &di->i_check);\n\t\tstatus = ocfs2_write_block(osb, tl_bh, INODE_CACHE(tl_inode));\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\nbail:\n\tif (tl_inode)\n\t\tiput(tl_inode);\n\tbrelse(tl_bh);\n\n\tif (status < 0 && (*tl_copy)) {\n\t\tkfree(*tl_copy);\n\t\t*tl_copy = NULL;\n\t\tmlog_errno(status);\n\t}\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_begin_truncate_log_recovery(struct ocfs2_super *osb,\n\t\t\t\t      int slot_num,\n\t\t\t\t      struct ocfs2_dinode **tl_copy)\n{\n\tint status;\n\tstruct inode *tl_inode = NULL;\n\tstruct buffer_head *tl_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tstruct ocfs2_truncate_log *tl;\n\n\t*tl_copy = NULL;\n\n\ttrace_ocfs2_begin_truncate_log_recovery(slot_num);\n\n\tstatus = ocfs2_get_truncate_log_info(osb, slot_num, &tl_inode, &tl_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tdi = (struct ocfs2_dinode *) tl_bh->b_data;\n\n\t/* tl_bh is loaded from ocfs2_get_truncate_log_info().  It's\n\t * validated by the underlying call to ocfs2_read_inode_block(),\n\t * so any corruption is a code bug */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(di));\n\n\ttl = &di->id2.i_dealloc;\n\tif (le16_to_cpu(tl->tl_used)) {\n\t\ttrace_ocfs2_truncate_log_recovery_num(le16_to_cpu(tl->tl_used));\n\n\t\t*tl_copy = kmalloc(tl_bh->b_size, GFP_KERNEL);\n\t\tif (!(*tl_copy)) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/* Assuming the write-out below goes well, this copy\n\t\t * will be passed back to recovery for processing. */\n\t\tmemcpy(*tl_copy, tl_bh->b_data, tl_bh->b_size);\n\n\t\t/* All we need to do to clear the truncate log is set\n\t\t * tl_used. */\n\t\ttl->tl_used = 0;\n\n\t\tocfs2_compute_meta_ecc(osb->sb, tl_bh->b_data, &di->i_check);\n\t\tstatus = ocfs2_write_block(osb, tl_bh, INODE_CACHE(tl_inode));\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\nbail:\n\tif (tl_inode)\n\t\tiput(tl_inode);\n\tbrelse(tl_bh);\n\n\tif (status < 0 && (*tl_copy)) {\n\t\tkfree(*tl_copy);\n\t\t*tl_copy = NULL;\n\t\tmlog_errno(status);\n\t}\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_begin_local_alloc_recovery",
          "args": [
            "osb",
            "slot_num",
            "&la_copy"
          ],
          "line": 1708
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_begin_local_alloc_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
          "lines": "489-551",
          "snippet": "int ocfs2_begin_local_alloc_recovery(struct ocfs2_super *osb,\n\t\t\t\t     int slot_num,\n\t\t\t\t     struct ocfs2_dinode **alloc_copy)\n{\n\tint status = 0;\n\tstruct buffer_head *alloc_bh = NULL;\n\tstruct inode *inode = NULL;\n\tstruct ocfs2_dinode *alloc;\n\n\ttrace_ocfs2_begin_local_alloc_recovery(slot_num);\n\n\t*alloc_copy = NULL;\n\n\tinode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t    LOCAL_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t    slot_num);\n\tif (!inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tmutex_lock(&inode->i_mutex);\n\n\tstatus = ocfs2_read_inode_block_full(inode, &alloc_bh,\n\t\t\t\t\t     OCFS2_BH_IGNORE_CACHE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t*alloc_copy = kmalloc(alloc_bh->b_size, GFP_KERNEL);\n\tif (!(*alloc_copy)) {\n\t\tstatus = -ENOMEM;\n\t\tgoto bail;\n\t}\n\tmemcpy((*alloc_copy), alloc_bh->b_data, alloc_bh->b_size);\n\n\talloc = (struct ocfs2_dinode *) alloc_bh->b_data;\n\tocfs2_clear_local_alloc(alloc);\n\n\tocfs2_compute_meta_ecc(osb->sb, alloc_bh->b_data, &alloc->i_check);\n\tstatus = ocfs2_write_block(osb, alloc_bh, INODE_CACHE(inode));\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nbail:\n\tif (status < 0) {\n\t\tkfree(*alloc_copy);\n\t\t*alloc_copy = NULL;\n\t}\n\n\tbrelse(alloc_bh);\n\n\tif (inode) {\n\t\tmutex_unlock(&inode->i_mutex);\n\t\tiput(inode);\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);",
            "static void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);\n\nint ocfs2_begin_local_alloc_recovery(struct ocfs2_super *osb,\n\t\t\t\t     int slot_num,\n\t\t\t\t     struct ocfs2_dinode **alloc_copy)\n{\n\tint status = 0;\n\tstruct buffer_head *alloc_bh = NULL;\n\tstruct inode *inode = NULL;\n\tstruct ocfs2_dinode *alloc;\n\n\ttrace_ocfs2_begin_local_alloc_recovery(slot_num);\n\n\t*alloc_copy = NULL;\n\n\tinode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t    LOCAL_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t    slot_num);\n\tif (!inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tmutex_lock(&inode->i_mutex);\n\n\tstatus = ocfs2_read_inode_block_full(inode, &alloc_bh,\n\t\t\t\t\t     OCFS2_BH_IGNORE_CACHE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t*alloc_copy = kmalloc(alloc_bh->b_size, GFP_KERNEL);\n\tif (!(*alloc_copy)) {\n\t\tstatus = -ENOMEM;\n\t\tgoto bail;\n\t}\n\tmemcpy((*alloc_copy), alloc_bh->b_data, alloc_bh->b_size);\n\n\talloc = (struct ocfs2_dinode *) alloc_bh->b_data;\n\tocfs2_clear_local_alloc(alloc);\n\n\tocfs2_compute_meta_ecc(osb->sb, alloc_bh->b_data, &alloc->i_check);\n\tstatus = ocfs2_write_block(osb, alloc_bh, INODE_CACHE(inode));\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nbail:\n\tif (status < 0) {\n\t\tkfree(*alloc_copy);\n\t\t*alloc_copy = NULL;\n\t}\n\n\tbrelse(alloc_bh);\n\n\tif (inode) {\n\t\tmutex_unlock(&inode->i_mutex);\n\t\tiput(inode);\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_recover_node_skip",
          "args": [
            "slot_num",
            "node_num"
          ],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_replay_journal",
          "args": [
            "osb",
            "node_num",
            "slot_num"
          ],
          "line": 1696
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_replay_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "1532-1669",
          "snippet": "static int ocfs2_replay_journal(struct ocfs2_super *osb,\n\t\t\t\tint node_num,\n\t\t\t\tint slot_num)\n{\n\tint status;\n\tint got_lock = 0;\n\tunsigned int flags;\n\tstruct inode *inode = NULL;\n\tstruct ocfs2_dinode *fe;\n\tjournal_t *journal = NULL;\n\tstruct buffer_head *bh = NULL;\n\tu32 slot_reco_gen;\n\n\tstatus = ocfs2_read_journal_inode(osb, slot_num, &bh, &inode);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto done;\n\t}\n\n\tfe = (struct ocfs2_dinode *)bh->b_data;\n\tslot_reco_gen = ocfs2_get_recovery_generation(fe);\n\tbrelse(bh);\n\tbh = NULL;\n\n\t/*\n\t * As the fs recovery is asynchronous, there is a small chance that\n\t * another node mounted (and recovered) the slot before the recovery\n\t * thread could get the lock. To handle that, we dirty read the journal\n\t * inode for that slot to get the recovery generation. If it is\n\t * different than what we expected, the slot has been recovered.\n\t * If not, it needs recovery.\n\t */\n\tif (osb->slot_recovery_generations[slot_num] != slot_reco_gen) {\n\t\ttrace_ocfs2_replay_journal_recovered(slot_num,\n\t\t     osb->slot_recovery_generations[slot_num], slot_reco_gen);\n\t\tosb->slot_recovery_generations[slot_num] = slot_reco_gen;\n\t\tstatus = -EBUSY;\n\t\tgoto done;\n\t}\n\n\t/* Continue with recovery as the journal has not yet been recovered */\n\n\tstatus = ocfs2_inode_lock_full(inode, &bh, 1, OCFS2_META_LOCK_RECOVERY);\n\tif (status < 0) {\n\t\ttrace_ocfs2_replay_journal_lock_err(status);\n\t\tif (status != -ERESTARTSYS)\n\t\t\tmlog(ML_ERROR, \"Could not lock journal!\\n\");\n\t\tgoto done;\n\t}\n\tgot_lock = 1;\n\n\tfe = (struct ocfs2_dinode *) bh->b_data;\n\n\tflags = le32_to_cpu(fe->id1.journal1.ij_flags);\n\tslot_reco_gen = ocfs2_get_recovery_generation(fe);\n\n\tif (!(flags & OCFS2_JOURNAL_DIRTY_FL)) {\n\t\ttrace_ocfs2_replay_journal_skip(node_num);\n\t\t/* Refresh recovery generation for the slot */\n\t\tosb->slot_recovery_generations[slot_num] = slot_reco_gen;\n\t\tgoto done;\n\t}\n\n\t/* we need to run complete recovery for offline orphan slots */\n\tocfs2_replay_map_set_state(osb, REPLAY_NEEDED);\n\n\tprintk(KERN_NOTICE \"ocfs2: Begin replay journal (node %d, slot %d) on \"\\\n\t       \"device (%u,%u)\\n\", node_num, slot_num, MAJOR(osb->sb->s_dev),\n\t       MINOR(osb->sb->s_dev));\n\n\tOCFS2_I(inode)->ip_clusters = le32_to_cpu(fe->i_clusters);\n\n\tstatus = ocfs2_force_read_journal(inode);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto done;\n\t}\n\n\tjournal = jbd2_journal_init_inode(inode);\n\tif (journal == NULL) {\n\t\tmlog(ML_ERROR, \"Linux journal layer error\\n\");\n\t\tstatus = -EIO;\n\t\tgoto done;\n\t}\n\n\tstatus = jbd2_journal_load(journal);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tif (!igrab(inode))\n\t\t\tBUG();\n\t\tjbd2_journal_destroy(journal);\n\t\tgoto done;\n\t}\n\n\tocfs2_clear_journal_error(osb->sb, journal, slot_num);\n\n\t/* wipe the journal */\n\tjbd2_journal_lock_updates(journal);\n\tstatus = jbd2_journal_flush(journal);\n\tjbd2_journal_unlock_updates(journal);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\t/* This will mark the node clean */\n\tflags = le32_to_cpu(fe->id1.journal1.ij_flags);\n\tflags &= ~OCFS2_JOURNAL_DIRTY_FL;\n\tfe->id1.journal1.ij_flags = cpu_to_le32(flags);\n\n\t/* Increment recovery generation to indicate successful recovery */\n\tocfs2_bump_recovery_generation(fe);\n\tosb->slot_recovery_generations[slot_num] =\n\t\t\t\t\tocfs2_get_recovery_generation(fe);\n\n\tocfs2_compute_meta_ecc(osb->sb, bh->b_data, &fe->i_check);\n\tstatus = ocfs2_write_block(osb, bh, INODE_CACHE(inode));\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tif (!igrab(inode))\n\t\tBUG();\n\n\tjbd2_journal_destroy(journal);\n\n\tprintk(KERN_NOTICE \"ocfs2: End replay journal (node %d, slot %d) on \"\\\n\t       \"device (%u,%u)\\n\", node_num, slot_num, MAJOR(osb->sb->s_dev),\n\t       MINOR(osb->sb->s_dev));\ndone:\n\t/* drop the lock on this nodes journal */\n\tif (got_lock)\n\t\tocfs2_inode_unlock(inode, 1);\n\n\tif (inode)\n\t\tiput(inode);\n\n\tbrelse(bh);\n\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_force_read_journal(struct inode *inode);",
            "static int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);",
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);",
            "static int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_force_read_journal(struct inode *inode);\nstatic int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\nstatic int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);\n\nstatic int ocfs2_replay_journal(struct ocfs2_super *osb,\n\t\t\t\tint node_num,\n\t\t\t\tint slot_num)\n{\n\tint status;\n\tint got_lock = 0;\n\tunsigned int flags;\n\tstruct inode *inode = NULL;\n\tstruct ocfs2_dinode *fe;\n\tjournal_t *journal = NULL;\n\tstruct buffer_head *bh = NULL;\n\tu32 slot_reco_gen;\n\n\tstatus = ocfs2_read_journal_inode(osb, slot_num, &bh, &inode);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto done;\n\t}\n\n\tfe = (struct ocfs2_dinode *)bh->b_data;\n\tslot_reco_gen = ocfs2_get_recovery_generation(fe);\n\tbrelse(bh);\n\tbh = NULL;\n\n\t/*\n\t * As the fs recovery is asynchronous, there is a small chance that\n\t * another node mounted (and recovered) the slot before the recovery\n\t * thread could get the lock. To handle that, we dirty read the journal\n\t * inode for that slot to get the recovery generation. If it is\n\t * different than what we expected, the slot has been recovered.\n\t * If not, it needs recovery.\n\t */\n\tif (osb->slot_recovery_generations[slot_num] != slot_reco_gen) {\n\t\ttrace_ocfs2_replay_journal_recovered(slot_num,\n\t\t     osb->slot_recovery_generations[slot_num], slot_reco_gen);\n\t\tosb->slot_recovery_generations[slot_num] = slot_reco_gen;\n\t\tstatus = -EBUSY;\n\t\tgoto done;\n\t}\n\n\t/* Continue with recovery as the journal has not yet been recovered */\n\n\tstatus = ocfs2_inode_lock_full(inode, &bh, 1, OCFS2_META_LOCK_RECOVERY);\n\tif (status < 0) {\n\t\ttrace_ocfs2_replay_journal_lock_err(status);\n\t\tif (status != -ERESTARTSYS)\n\t\t\tmlog(ML_ERROR, \"Could not lock journal!\\n\");\n\t\tgoto done;\n\t}\n\tgot_lock = 1;\n\n\tfe = (struct ocfs2_dinode *) bh->b_data;\n\n\tflags = le32_to_cpu(fe->id1.journal1.ij_flags);\n\tslot_reco_gen = ocfs2_get_recovery_generation(fe);\n\n\tif (!(flags & OCFS2_JOURNAL_DIRTY_FL)) {\n\t\ttrace_ocfs2_replay_journal_skip(node_num);\n\t\t/* Refresh recovery generation for the slot */\n\t\tosb->slot_recovery_generations[slot_num] = slot_reco_gen;\n\t\tgoto done;\n\t}\n\n\t/* we need to run complete recovery for offline orphan slots */\n\tocfs2_replay_map_set_state(osb, REPLAY_NEEDED);\n\n\tprintk(KERN_NOTICE \"ocfs2: Begin replay journal (node %d, slot %d) on \"\\\n\t       \"device (%u,%u)\\n\", node_num, slot_num, MAJOR(osb->sb->s_dev),\n\t       MINOR(osb->sb->s_dev));\n\n\tOCFS2_I(inode)->ip_clusters = le32_to_cpu(fe->i_clusters);\n\n\tstatus = ocfs2_force_read_journal(inode);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto done;\n\t}\n\n\tjournal = jbd2_journal_init_inode(inode);\n\tif (journal == NULL) {\n\t\tmlog(ML_ERROR, \"Linux journal layer error\\n\");\n\t\tstatus = -EIO;\n\t\tgoto done;\n\t}\n\n\tstatus = jbd2_journal_load(journal);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tif (!igrab(inode))\n\t\t\tBUG();\n\t\tjbd2_journal_destroy(journal);\n\t\tgoto done;\n\t}\n\n\tocfs2_clear_journal_error(osb->sb, journal, slot_num);\n\n\t/* wipe the journal */\n\tjbd2_journal_lock_updates(journal);\n\tstatus = jbd2_journal_flush(journal);\n\tjbd2_journal_unlock_updates(journal);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\t/* This will mark the node clean */\n\tflags = le32_to_cpu(fe->id1.journal1.ij_flags);\n\tflags &= ~OCFS2_JOURNAL_DIRTY_FL;\n\tfe->id1.journal1.ij_flags = cpu_to_le32(flags);\n\n\t/* Increment recovery generation to indicate successful recovery */\n\tocfs2_bump_recovery_generation(fe);\n\tosb->slot_recovery_generations[slot_num] =\n\t\t\t\t\tocfs2_get_recovery_generation(fe);\n\n\tocfs2_compute_meta_ecc(osb->sb, bh->b_data, &fe->i_check);\n\tstatus = ocfs2_write_block(osb, bh, INODE_CACHE(inode));\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tif (!igrab(inode))\n\t\tBUG();\n\n\tjbd2_journal_destroy(journal);\n\n\tprintk(KERN_NOTICE \"ocfs2: End replay journal (node %d, slot %d) on \"\\\n\t       \"device (%u,%u)\\n\", node_num, slot_num, MAJOR(osb->sb->s_dev),\n\t       MINOR(osb->sb->s_dev));\ndone:\n\t/* drop the lock on this nodes journal */\n\tif (got_lock)\n\t\tocfs2_inode_unlock(inode, 1);\n\n\tif (inode)\n\t\tiput(inode);\n\n\tbrelse(bh);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "osb->node_num == node_num"
          ],
          "line": 1694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_recover_node",
          "args": [
            "node_num",
            "slot_num",
            "osb->node_num"
          ],
          "line": 1690
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\nstatic int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);\n\nstatic int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num)\n{\n\tint status = 0;\n\tstruct ocfs2_dinode *la_copy = NULL;\n\tstruct ocfs2_dinode *tl_copy = NULL;\n\n\ttrace_ocfs2_recover_node(node_num, slot_num, osb->node_num);\n\n\t/* Should not ever be called to recover ourselves -- in that\n\t * case we should've called ocfs2_journal_load instead. */\n\tBUG_ON(osb->node_num == node_num);\n\n\tstatus = ocfs2_replay_journal(osb, node_num, slot_num);\n\tif (status < 0) {\n\t\tif (status == -EBUSY) {\n\t\t\ttrace_ocfs2_recover_node_skip(slot_num, node_num);\n\t\t\tstatus = 0;\n\t\t\tgoto done;\n\t\t}\n\t\tmlog_errno(status);\n\t\tgoto done;\n\t}\n\n\t/* Stamp a clean local alloc file AFTER recovering the journal... */\n\tstatus = ocfs2_begin_local_alloc_recovery(osb, slot_num, &la_copy);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto done;\n\t}\n\n\t/* An error from begin_truncate_log_recovery is not\n\t * serious enough to warrant halting the rest of\n\t * recovery. */\n\tstatus = ocfs2_begin_truncate_log_recovery(osb, slot_num, &tl_copy);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\t/* Likewise, this would be a strange but ultimately not so\n\t * harmful place to get an error... */\n\tstatus = ocfs2_clear_slot(osb, slot_num);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\t/* This will kfree the memory pointed to by la_copy and tl_copy */\n\tocfs2_queue_recovery_completion(osb->journal, slot_num, la_copy,\n\t\t\t\t\ttl_copy, NULL, ORPHAN_NEED_TRUNCATE);\n\n\tstatus = 0;\ndone:\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_replay_journal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "1532-1669",
    "snippet": "static int ocfs2_replay_journal(struct ocfs2_super *osb,\n\t\t\t\tint node_num,\n\t\t\t\tint slot_num)\n{\n\tint status;\n\tint got_lock = 0;\n\tunsigned int flags;\n\tstruct inode *inode = NULL;\n\tstruct ocfs2_dinode *fe;\n\tjournal_t *journal = NULL;\n\tstruct buffer_head *bh = NULL;\n\tu32 slot_reco_gen;\n\n\tstatus = ocfs2_read_journal_inode(osb, slot_num, &bh, &inode);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto done;\n\t}\n\n\tfe = (struct ocfs2_dinode *)bh->b_data;\n\tslot_reco_gen = ocfs2_get_recovery_generation(fe);\n\tbrelse(bh);\n\tbh = NULL;\n\n\t/*\n\t * As the fs recovery is asynchronous, there is a small chance that\n\t * another node mounted (and recovered) the slot before the recovery\n\t * thread could get the lock. To handle that, we dirty read the journal\n\t * inode for that slot to get the recovery generation. If it is\n\t * different than what we expected, the slot has been recovered.\n\t * If not, it needs recovery.\n\t */\n\tif (osb->slot_recovery_generations[slot_num] != slot_reco_gen) {\n\t\ttrace_ocfs2_replay_journal_recovered(slot_num,\n\t\t     osb->slot_recovery_generations[slot_num], slot_reco_gen);\n\t\tosb->slot_recovery_generations[slot_num] = slot_reco_gen;\n\t\tstatus = -EBUSY;\n\t\tgoto done;\n\t}\n\n\t/* Continue with recovery as the journal has not yet been recovered */\n\n\tstatus = ocfs2_inode_lock_full(inode, &bh, 1, OCFS2_META_LOCK_RECOVERY);\n\tif (status < 0) {\n\t\ttrace_ocfs2_replay_journal_lock_err(status);\n\t\tif (status != -ERESTARTSYS)\n\t\t\tmlog(ML_ERROR, \"Could not lock journal!\\n\");\n\t\tgoto done;\n\t}\n\tgot_lock = 1;\n\n\tfe = (struct ocfs2_dinode *) bh->b_data;\n\n\tflags = le32_to_cpu(fe->id1.journal1.ij_flags);\n\tslot_reco_gen = ocfs2_get_recovery_generation(fe);\n\n\tif (!(flags & OCFS2_JOURNAL_DIRTY_FL)) {\n\t\ttrace_ocfs2_replay_journal_skip(node_num);\n\t\t/* Refresh recovery generation for the slot */\n\t\tosb->slot_recovery_generations[slot_num] = slot_reco_gen;\n\t\tgoto done;\n\t}\n\n\t/* we need to run complete recovery for offline orphan slots */\n\tocfs2_replay_map_set_state(osb, REPLAY_NEEDED);\n\n\tprintk(KERN_NOTICE \"ocfs2: Begin replay journal (node %d, slot %d) on \"\\\n\t       \"device (%u,%u)\\n\", node_num, slot_num, MAJOR(osb->sb->s_dev),\n\t       MINOR(osb->sb->s_dev));\n\n\tOCFS2_I(inode)->ip_clusters = le32_to_cpu(fe->i_clusters);\n\n\tstatus = ocfs2_force_read_journal(inode);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto done;\n\t}\n\n\tjournal = jbd2_journal_init_inode(inode);\n\tif (journal == NULL) {\n\t\tmlog(ML_ERROR, \"Linux journal layer error\\n\");\n\t\tstatus = -EIO;\n\t\tgoto done;\n\t}\n\n\tstatus = jbd2_journal_load(journal);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tif (!igrab(inode))\n\t\t\tBUG();\n\t\tjbd2_journal_destroy(journal);\n\t\tgoto done;\n\t}\n\n\tocfs2_clear_journal_error(osb->sb, journal, slot_num);\n\n\t/* wipe the journal */\n\tjbd2_journal_lock_updates(journal);\n\tstatus = jbd2_journal_flush(journal);\n\tjbd2_journal_unlock_updates(journal);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\t/* This will mark the node clean */\n\tflags = le32_to_cpu(fe->id1.journal1.ij_flags);\n\tflags &= ~OCFS2_JOURNAL_DIRTY_FL;\n\tfe->id1.journal1.ij_flags = cpu_to_le32(flags);\n\n\t/* Increment recovery generation to indicate successful recovery */\n\tocfs2_bump_recovery_generation(fe);\n\tosb->slot_recovery_generations[slot_num] =\n\t\t\t\t\tocfs2_get_recovery_generation(fe);\n\n\tocfs2_compute_meta_ecc(osb->sb, bh->b_data, &fe->i_check);\n\tstatus = ocfs2_write_block(osb, bh, INODE_CACHE(inode));\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tif (!igrab(inode))\n\t\tBUG();\n\n\tjbd2_journal_destroy(journal);\n\n\tprintk(KERN_NOTICE \"ocfs2: End replay journal (node %d, slot %d) on \"\\\n\t       \"device (%u,%u)\\n\", node_num, slot_num, MAJOR(osb->sb->s_dev),\n\t       MINOR(osb->sb->s_dev));\ndone:\n\t/* drop the lock on this nodes journal */\n\tif (got_lock)\n\t\tocfs2_inode_unlock(inode, 1);\n\n\tif (inode)\n\t\tiput(inode);\n\n\tbrelse(bh);\n\n\treturn status;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_force_read_journal(struct inode *inode);",
      "static int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);",
      "static int ocfs2_commit_cache(struct ocfs2_super *osb);",
      "static int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1666
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 1664
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "inode",
            "1"
          ],
          "line": 1661
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_NOTICE \"ocfs2: End replay journal (node %d, slot %d) on \"\\\n\t       \"device (%u,%u)\\n\"",
            "node_num",
            "slot_num",
            "MAJOR(osb->sb->s_dev)",
            "MINOR(osb->sb->s_dev)"
          ],
          "line": 1655
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "osb->sb->s_dev"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "osb->sb->s_dev"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_destroy",
          "args": [
            "journal"
          ],
          "line": 1653
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1677-1726",
          "snippet": "int jbd2_journal_destroy(journal_t *journal)\n{\n\tint err = 0;\n\n\t/* Wait for the commit thread to wake up and die. */\n\tjournal_kill_thread(journal);\n\n\t/* Force a final log commit */\n\tif (journal->j_running_transaction)\n\t\tjbd2_journal_commit_transaction(journal);\n\n\t/* Force any old transactions to disk */\n\n\t/* Totally anal locking here... */\n\tspin_lock(&journal->j_list_lock);\n\twhile (journal->j_checkpoint_transactions != NULL) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\tjbd2_log_do_checkpoint(journal);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\tspin_lock(&journal->j_list_lock);\n\t}\n\n\tJ_ASSERT(journal->j_running_transaction == NULL);\n\tJ_ASSERT(journal->j_committing_transaction == NULL);\n\tJ_ASSERT(journal->j_checkpoint_transactions == NULL);\n\tspin_unlock(&journal->j_list_lock);\n\n\tif (journal->j_sb_buffer) {\n\t\tif (!is_journal_aborted(journal)) {\n\t\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\t\tjbd2_mark_journal_empty(journal);\n\t\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\t} else\n\t\t\terr = -EIO;\n\t\tbrelse(journal->j_sb_buffer);\n\t}\n\n\tif (journal->j_proc_entry)\n\t\tjbd2_stats_proc_exit(journal);\n\tiput(journal->j_inode);\n\tif (journal->j_revoke)\n\t\tjbd2_journal_destroy_revoke(journal);\n\tif (journal->j_chksum_driver)\n\t\tcrypto_free_shash(journal->j_chksum_driver);\n\tkfree(journal->j_wbuf);\n\tkfree(journal);\n\n\treturn err;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_destroy(journal_t *journal)\n{\n\tint err = 0;\n\n\t/* Wait for the commit thread to wake up and die. */\n\tjournal_kill_thread(journal);\n\n\t/* Force a final log commit */\n\tif (journal->j_running_transaction)\n\t\tjbd2_journal_commit_transaction(journal);\n\n\t/* Force any old transactions to disk */\n\n\t/* Totally anal locking here... */\n\tspin_lock(&journal->j_list_lock);\n\twhile (journal->j_checkpoint_transactions != NULL) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\tjbd2_log_do_checkpoint(journal);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\tspin_lock(&journal->j_list_lock);\n\t}\n\n\tJ_ASSERT(journal->j_running_transaction == NULL);\n\tJ_ASSERT(journal->j_committing_transaction == NULL);\n\tJ_ASSERT(journal->j_checkpoint_transactions == NULL);\n\tspin_unlock(&journal->j_list_lock);\n\n\tif (journal->j_sb_buffer) {\n\t\tif (!is_journal_aborted(journal)) {\n\t\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\t\tjbd2_mark_journal_empty(journal);\n\t\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\t} else\n\t\t\terr = -EIO;\n\t\tbrelse(journal->j_sb_buffer);\n\t}\n\n\tif (journal->j_proc_entry)\n\t\tjbd2_stats_proc_exit(journal);\n\tiput(journal->j_inode);\n\tif (journal->j_revoke)\n\t\tjbd2_journal_destroy_revoke(journal);\n\tif (journal->j_chksum_driver)\n\t\tcrypto_free_shash(journal->j_chksum_driver);\n\tkfree(journal->j_wbuf);\n\tkfree(journal);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "igrab",
          "args": [
            "inode"
          ],
          "line": 1650
        },
        "resolved": true,
        "details": {
          "function_name": "igrab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1173-1189",
          "snippet": "struct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_write_block",
          "args": [
            "osb",
            "bh",
            "INODE_CACHE(inode)"
          ],
          "line": 1646
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_write_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/buffer_head_io.c",
          "lines": "53-99",
          "snippet": "int ocfs2_write_block(struct ocfs2_super *osb, struct buffer_head *bh,\n\t\t      struct ocfs2_caching_info *ci)\n{\n\tint ret = 0;\n\n\ttrace_ocfs2_write_block((unsigned long long)bh->b_blocknr, ci);\n\n\tBUG_ON(bh->b_blocknr < OCFS2_SUPER_BLOCK_BLKNO);\n\tBUG_ON(buffer_jbd(bh));\n\n\t/* No need to check for a soft readonly file system here. non\n\t * journalled writes are only ever done on system files which\n\t * can get modified during recovery even if read-only. */\n\tif (ocfs2_is_hard_readonly(osb)) {\n\t\tret = -EROFS;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_metadata_cache_io_lock(ci);\n\n\tlock_buffer(bh);\n\tset_buffer_uptodate(bh);\n\n\t/* remove from dirty list before I/O. */\n\tclear_buffer_dirty(bh);\n\n\tget_bh(bh); /* for end_buffer_write_sync() */\n\tbh->b_end_io = end_buffer_write_sync;\n\tsubmit_bh(WRITE, bh);\n\n\twait_on_buffer(bh);\n\n\tif (buffer_uptodate(bh)) {\n\t\tocfs2_set_buffer_uptodate(ci, bh);\n\t} else {\n\t\t/* We don't need to remove the clustered uptodate\n\t\t * information for this bh as it's not marked locally\n\t\t * uptodate. */\n\t\tret = -EIO;\n\t\tmlog_errno(ret);\n\t}\n\n\tocfs2_metadata_cache_io_unlock(ci);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_write_block(struct ocfs2_super *osb, struct buffer_head *bh,\n\t\t      struct ocfs2_caching_info *ci)\n{\n\tint ret = 0;\n\n\ttrace_ocfs2_write_block((unsigned long long)bh->b_blocknr, ci);\n\n\tBUG_ON(bh->b_blocknr < OCFS2_SUPER_BLOCK_BLKNO);\n\tBUG_ON(buffer_jbd(bh));\n\n\t/* No need to check for a soft readonly file system here. non\n\t * journalled writes are only ever done on system files which\n\t * can get modified during recovery even if read-only. */\n\tif (ocfs2_is_hard_readonly(osb)) {\n\t\tret = -EROFS;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_metadata_cache_io_lock(ci);\n\n\tlock_buffer(bh);\n\tset_buffer_uptodate(bh);\n\n\t/* remove from dirty list before I/O. */\n\tclear_buffer_dirty(bh);\n\n\tget_bh(bh); /* for end_buffer_write_sync() */\n\tbh->b_end_io = end_buffer_write_sync;\n\tsubmit_bh(WRITE, bh);\n\n\twait_on_buffer(bh);\n\n\tif (buffer_uptodate(bh)) {\n\t\tocfs2_set_buffer_uptodate(ci, bh);\n\t} else {\n\t\t/* We don't need to remove the clustered uptodate\n\t\t * information for this bh as it's not marked locally\n\t\t * uptodate. */\n\t\tret = -EIO;\n\t\tmlog_errno(ret);\n\t}\n\n\tocfs2_metadata_cache_io_unlock(ci);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 1646
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_compute_meta_ecc",
          "args": [
            "osb->sb",
            "bh->b_data",
            "&fe->i_check"
          ],
          "line": 1645
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_compute_meta_ecc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "606-611",
          "snippet": "void ocfs2_compute_meta_ecc(struct super_block *sb, void *data,\n\t\t\t    struct ocfs2_block_check *bc)\n{\n\tif (ocfs2_meta_ecc(OCFS2_SB(sb)))\n\t\tocfs2_block_check_compute(data, sb->s_blocksize, bc);\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid ocfs2_compute_meta_ecc(struct super_block *sb, void *data,\n\t\t\t    struct ocfs2_block_check *bc)\n{\n\tif (ocfs2_meta_ecc(OCFS2_SB(sb)))\n\t\tocfs2_block_check_compute(data, sb->s_blocksize, bc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_get_recovery_generation",
          "args": [
            "fe"
          ],
          "line": 1643
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_recovery_generation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "898-901",
          "snippet": "static u32 ocfs2_get_recovery_generation(struct ocfs2_dinode *di)\n{\n\treturn le32_to_cpu(di->id1.journal1.ij_recovery_generation);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u32 ocfs2_get_recovery_generation(struct ocfs2_dinode *di)\n{\n\treturn le32_to_cpu(di->id1.journal1.ij_recovery_generation);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_bump_recovery_generation",
          "args": [
            "fe"
          ],
          "line": 1641
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_bump_recovery_generation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "893-896",
          "snippet": "static void ocfs2_bump_recovery_generation(struct ocfs2_dinode *di)\n{\n\tle32_add_cpu(&(di->id1.journal1.ij_recovery_generation), 1);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_bump_recovery_generation(struct ocfs2_dinode *di)\n{\n\tle32_add_cpu(&(di->id1.journal1.ij_recovery_generation), 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "flags"
          ],
          "line": 1638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "fe->id1.journal1.ij_flags"
          ],
          "line": 1636
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_unlock_updates",
          "args": [
            "journal"
          ],
          "line": 1631
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_unlock_updates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "744-753",
          "snippet": "void jbd2_journal_unlock_updates (journal_t *journal)\n{\n\tJ_ASSERT(journal->j_barrier_count != 0);\n\n\tmutex_unlock(&journal->j_barrier);\n\twrite_lock(&journal->j_state_lock);\n\t--journal->j_barrier_count;\n\twrite_unlock(&journal->j_state_lock);\n\twake_up(&journal->j_wait_transaction_locked);\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid jbd2_journal_unlock_updates (journal_t *journal)\n{\n\tJ_ASSERT(journal->j_barrier_count != 0);\n\n\tmutex_unlock(&journal->j_barrier);\n\twrite_lock(&journal->j_state_lock);\n\t--journal->j_barrier_count;\n\twrite_unlock(&journal->j_state_lock);\n\twake_up(&journal->j_wait_transaction_locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_flush",
          "args": [
            "journal"
          ],
          "line": 1630
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1914-1970",
          "snippet": "int jbd2_journal_flush(journal_t *journal)\n{\n\tint err = 0;\n\ttransaction_t *transaction = NULL;\n\n\twrite_lock(&journal->j_state_lock);\n\n\t/* Force everything buffered to the log... */\n\tif (journal->j_running_transaction) {\n\t\ttransaction = journal->j_running_transaction;\n\t\t__jbd2_log_start_commit(journal, transaction->t_tid);\n\t} else if (journal->j_committing_transaction)\n\t\ttransaction = journal->j_committing_transaction;\n\n\t/* Wait for the log commit to complete... */\n\tif (transaction) {\n\t\ttid_t tid = transaction->t_tid;\n\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tjbd2_log_wait_commit(journal, tid);\n\t} else {\n\t\twrite_unlock(&journal->j_state_lock);\n\t}\n\n\t/* ...and flush everything in the log out to disk. */\n\tspin_lock(&journal->j_list_lock);\n\twhile (!err && journal->j_checkpoint_transactions != NULL) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\terr = jbd2_log_do_checkpoint(journal);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\tspin_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\tif (is_journal_aborted(journal))\n\t\treturn -EIO;\n\n\tmutex_lock(&journal->j_checkpoint_mutex);\n\tjbd2_cleanup_journal_tail(journal);\n\n\t/* Finally, mark the journal as really needing no recovery.\n\t * This sets s_start==0 in the underlying superblock, which is\n\t * the magic code for a fully-recovered superblock.  Any future\n\t * commits of data to the journal will restore the current\n\t * s_start value. */\n\tjbd2_mark_journal_empty(journal);\n\tmutex_unlock(&journal->j_checkpoint_mutex);\n\twrite_lock(&journal->j_state_lock);\n\tJ_ASSERT(!journal->j_running_transaction);\n\tJ_ASSERT(!journal->j_committing_transaction);\n\tJ_ASSERT(!journal->j_checkpoint_transactions);\n\tJ_ASSERT(journal->j_head == journal->j_tail);\n\tJ_ASSERT(journal->j_tail_sequence == journal->j_transaction_sequence);\n\twrite_unlock(&journal->j_state_lock);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_flush(journal_t *journal)\n{\n\tint err = 0;\n\ttransaction_t *transaction = NULL;\n\n\twrite_lock(&journal->j_state_lock);\n\n\t/* Force everything buffered to the log... */\n\tif (journal->j_running_transaction) {\n\t\ttransaction = journal->j_running_transaction;\n\t\t__jbd2_log_start_commit(journal, transaction->t_tid);\n\t} else if (journal->j_committing_transaction)\n\t\ttransaction = journal->j_committing_transaction;\n\n\t/* Wait for the log commit to complete... */\n\tif (transaction) {\n\t\ttid_t tid = transaction->t_tid;\n\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tjbd2_log_wait_commit(journal, tid);\n\t} else {\n\t\twrite_unlock(&journal->j_state_lock);\n\t}\n\n\t/* ...and flush everything in the log out to disk. */\n\tspin_lock(&journal->j_list_lock);\n\twhile (!err && journal->j_checkpoint_transactions != NULL) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\terr = jbd2_log_do_checkpoint(journal);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\tspin_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\tif (is_journal_aborted(journal))\n\t\treturn -EIO;\n\n\tmutex_lock(&journal->j_checkpoint_mutex);\n\tjbd2_cleanup_journal_tail(journal);\n\n\t/* Finally, mark the journal as really needing no recovery.\n\t * This sets s_start==0 in the underlying superblock, which is\n\t * the magic code for a fully-recovered superblock.  Any future\n\t * commits of data to the journal will restore the current\n\t * s_start value. */\n\tjbd2_mark_journal_empty(journal);\n\tmutex_unlock(&journal->j_checkpoint_mutex);\n\twrite_lock(&journal->j_state_lock);\n\tJ_ASSERT(!journal->j_running_transaction);\n\tJ_ASSERT(!journal->j_committing_transaction);\n\tJ_ASSERT(!journal->j_checkpoint_transactions);\n\tJ_ASSERT(journal->j_head == journal->j_tail);\n\tJ_ASSERT(journal->j_tail_sequence == journal->j_transaction_sequence);\n\twrite_unlock(&journal->j_state_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_lock_updates",
          "args": [
            "journal"
          ],
          "line": 1629
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_lock_updates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "689-734",
          "snippet": "void jbd2_journal_lock_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\n\twrite_lock(&journal->j_state_lock);\n\t++journal->j_barrier_count;\n\n\t/* Wait until there are no reserved handles */\n\tif (atomic_read(&journal->j_reserved_credits)) {\n\t\twrite_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_reserved,\n\t\t\t   atomic_read(&journal->j_reserved_credits) == 0);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\n\t/* Wait until there are no running updates */\n\twhile (1) {\n\t\ttransaction_t *transaction = journal->j_running_transaction;\n\n\t\tif (!transaction)\n\t\t\tbreak;\n\n\t\tspin_lock(&transaction->t_handle_lock);\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!atomic_read(&transaction->t_updates)) {\n\t\t\tspin_unlock(&transaction->t_handle_lock);\n\t\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\twrite_unlock(&journal->j_state_lock);\n\n\t/*\n\t * We have now established a barrier against other normal updates, but\n\t * we also need to barrier against other jbd2_journal_lock_updates() calls\n\t * to make sure that we serialise special journal-locked operations\n\t * too.\n\t */\n\tmutex_lock(&journal->j_barrier);\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid jbd2_journal_lock_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\n\twrite_lock(&journal->j_state_lock);\n\t++journal->j_barrier_count;\n\n\t/* Wait until there are no reserved handles */\n\tif (atomic_read(&journal->j_reserved_credits)) {\n\t\twrite_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_reserved,\n\t\t\t   atomic_read(&journal->j_reserved_credits) == 0);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\n\t/* Wait until there are no running updates */\n\twhile (1) {\n\t\ttransaction_t *transaction = journal->j_running_transaction;\n\n\t\tif (!transaction)\n\t\t\tbreak;\n\n\t\tspin_lock(&transaction->t_handle_lock);\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!atomic_read(&transaction->t_updates)) {\n\t\t\tspin_unlock(&transaction->t_handle_lock);\n\t\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\twrite_unlock(&journal->j_state_lock);\n\n\t/*\n\t * We have now established a barrier against other normal updates, but\n\t * we also need to barrier against other jbd2_journal_lock_updates() calls\n\t * to make sure that we serialise special journal-locked operations\n\t * too.\n\t */\n\tmutex_lock(&journal->j_barrier);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clear_journal_error",
          "args": [
            "osb->sb",
            "journal",
            "slot_num"
          ],
          "line": 1626
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_journal_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "1022-1038",
          "snippet": "static void ocfs2_clear_journal_error(struct super_block *sb,\n\t\t\t\t      journal_t *journal,\n\t\t\t\t      int slot)\n{\n\tint olderr;\n\n\tolderr = jbd2_journal_errno(journal);\n\tif (olderr) {\n\t\tmlog(ML_ERROR, \"File system error %d recorded in \"\n\t\t     \"journal %u.\\n\", olderr, slot);\n\t\tmlog(ML_ERROR, \"File system on device %s needs checking.\\n\",\n\t\t     sb->s_id);\n\n\t\tjbd2_journal_ack_err(journal);\n\t\tjbd2_journal_clear_err(journal);\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_clear_journal_error(struct super_block *sb,\n\t\t\t\t      journal_t *journal,\n\t\t\t\t      int slot)\n{\n\tint olderr;\n\n\tolderr = jbd2_journal_errno(journal);\n\tif (olderr) {\n\t\tmlog(ML_ERROR, \"File system error %d recorded in \"\n\t\t     \"journal %u.\\n\", olderr, slot);\n\t\tmlog(ML_ERROR, \"File system on device %s needs checking.\\n\",\n\t\t     sb->s_id);\n\n\t\tjbd2_journal_ack_err(journal);\n\t\tjbd2_journal_clear_err(journal);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_load",
          "args": [
            "journal"
          ],
          "line": 1617
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_load",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1611-1667",
          "snippet": "int jbd2_journal_load(journal_t *journal)\n{\n\tint err;\n\tjournal_superblock_t *sb;\n\n\terr = load_superblock(journal);\n\tif (err)\n\t\treturn err;\n\n\tsb = journal->j_superblock;\n\t/* If this is a V2 superblock, then we have to check the\n\t * features flags on it. */\n\n\tif (journal->j_format_version >= 2) {\n\t\tif ((sb->s_feature_ro_compat &\n\t\t     ~cpu_to_be32(JBD2_KNOWN_ROCOMPAT_FEATURES)) ||\n\t\t    (sb->s_feature_incompat &\n\t\t     ~cpu_to_be32(JBD2_KNOWN_INCOMPAT_FEATURES))) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t\t\"JBD2: Unrecognised features on journal\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/*\n\t * Create a slab for this blocksize\n\t */\n\terr = jbd2_journal_create_slab(be32_to_cpu(sb->s_blocksize));\n\tif (err)\n\t\treturn err;\n\n\t/* Let the recovery code check whether it needs to recover any\n\t * data from the journal. */\n\tif (jbd2_journal_recover(journal))\n\t\tgoto recovery_error;\n\n\tif (journal->j_failed_commit) {\n\t\tprintk(KERN_ERR \"JBD2: journal transaction %u on %s \"\n\t\t       \"is corrupt.\\n\", journal->j_failed_commit,\n\t\t       journal->j_devname);\n\t\treturn -EIO;\n\t}\n\n\t/* OK, we've finished with the dynamic journal bits:\n\t * reinitialise the dynamic contents of the superblock in memory\n\t * and reset them on disk. */\n\tif (journal_reset(journal))\n\t\tgoto recovery_error;\n\n\tjournal->j_flags &= ~JBD2_ABORT;\n\tjournal->j_flags |= JBD2_LOADED;\n\treturn 0;\n\nrecovery_error:\n\tprintk(KERN_WARNING \"JBD2: recovery failed\\n\");\n\treturn -EIO;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_load(journal_t *journal)\n{\n\tint err;\n\tjournal_superblock_t *sb;\n\n\terr = load_superblock(journal);\n\tif (err)\n\t\treturn err;\n\n\tsb = journal->j_superblock;\n\t/* If this is a V2 superblock, then we have to check the\n\t * features flags on it. */\n\n\tif (journal->j_format_version >= 2) {\n\t\tif ((sb->s_feature_ro_compat &\n\t\t     ~cpu_to_be32(JBD2_KNOWN_ROCOMPAT_FEATURES)) ||\n\t\t    (sb->s_feature_incompat &\n\t\t     ~cpu_to_be32(JBD2_KNOWN_INCOMPAT_FEATURES))) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t\t\"JBD2: Unrecognised features on journal\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/*\n\t * Create a slab for this blocksize\n\t */\n\terr = jbd2_journal_create_slab(be32_to_cpu(sb->s_blocksize));\n\tif (err)\n\t\treturn err;\n\n\t/* Let the recovery code check whether it needs to recover any\n\t * data from the journal. */\n\tif (jbd2_journal_recover(journal))\n\t\tgoto recovery_error;\n\n\tif (journal->j_failed_commit) {\n\t\tprintk(KERN_ERR \"JBD2: journal transaction %u on %s \"\n\t\t       \"is corrupt.\\n\", journal->j_failed_commit,\n\t\t       journal->j_devname);\n\t\treturn -EIO;\n\t}\n\n\t/* OK, we've finished with the dynamic journal bits:\n\t * reinitialise the dynamic contents of the superblock in memory\n\t * and reset them on disk. */\n\tif (journal_reset(journal))\n\t\tgoto recovery_error;\n\n\tjournal->j_flags &= ~JBD2_ABORT;\n\tjournal->j_flags |= JBD2_LOADED;\n\treturn 0;\n\nrecovery_error:\n\tprintk(KERN_WARNING \"JBD2: recovery failed\\n\");\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Linux journal layer error\\n\""
          ],
          "line": 1612
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_init_inode",
          "args": [
            "inode"
          ],
          "line": 1610
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_init_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1192-1256",
          "snippet": "journal_t * jbd2_journal_init_inode (struct inode *inode)\n{\n\tstruct buffer_head *bh;\n\tjournal_t *journal = journal_init_common();\n\tchar *p;\n\tint err;\n\tint n;\n\tunsigned long long blocknr;\n\n\tif (!journal)\n\t\treturn NULL;\n\n\tjournal->j_dev = journal->j_fs_dev = inode->i_sb->s_bdev;\n\tjournal->j_inode = inode;\n\tbdevname(journal->j_dev, journal->j_devname);\n\tp = journal->j_devname;\n\twhile ((p = strchr(p, '/')))\n\t\t*p = '!';\n\tp = journal->j_devname + strlen(journal->j_devname);\n\tsprintf(p, \"-%lu\", journal->j_inode->i_ino);\n\tjbd_debug(1,\n\t\t  \"journal %p: inode %s/%ld, size %Ld, bits %d, blksize %ld\\n\",\n\t\t  journal, inode->i_sb->s_id, inode->i_ino,\n\t\t  (long long) inode->i_size,\n\t\t  inode->i_sb->s_blocksize_bits, inode->i_sb->s_blocksize);\n\n\tjournal->j_maxlen = inode->i_size >> inode->i_sb->s_blocksize_bits;\n\tjournal->j_blocksize = inode->i_sb->s_blocksize;\n\tjbd2_stats_proc_init(journal);\n\n\t/* journal descriptor can store up to n blocks -bzzz */\n\tn = journal->j_blocksize / sizeof(journal_block_tag_t);\n\tjournal->j_wbufsize = n;\n\tjournal->j_wbuf = kmalloc(n * sizeof(struct buffer_head*), GFP_KERNEL);\n\tif (!journal->j_wbuf) {\n\t\tprintk(KERN_ERR \"%s: Can't allocate bhs for commit thread\\n\",\n\t\t\t__func__);\n\t\tgoto out_err;\n\t}\n\n\terr = jbd2_journal_bmap(journal, 0, &blocknr);\n\t/* If that failed, give up */\n\tif (err) {\n\t\tprintk(KERN_ERR \"%s: Cannot locate journal superblock\\n\",\n\t\t       __func__);\n\t\tgoto out_err;\n\t}\n\n\tbh = getblk_unmovable(journal->j_dev, blocknr, journal->j_blocksize);\n\tif (!bh) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Cannot get buffer for journal superblock\\n\",\n\t\t       __func__);\n\t\tgoto out_err;\n\t}\n\tjournal->j_sb_buffer = bh;\n\tjournal->j_superblock = (journal_superblock_t *)bh->b_data;\n\n\treturn journal;\nout_err:\n\tkfree(journal->j_wbuf);\n\tjbd2_stats_proc_exit(journal);\n\tkfree(journal);\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\njournal_t * jbd2_journal_init_inode (struct inode *inode)\n{\n\tstruct buffer_head *bh;\n\tjournal_t *journal = journal_init_common();\n\tchar *p;\n\tint err;\n\tint n;\n\tunsigned long long blocknr;\n\n\tif (!journal)\n\t\treturn NULL;\n\n\tjournal->j_dev = journal->j_fs_dev = inode->i_sb->s_bdev;\n\tjournal->j_inode = inode;\n\tbdevname(journal->j_dev, journal->j_devname);\n\tp = journal->j_devname;\n\twhile ((p = strchr(p, '/')))\n\t\t*p = '!';\n\tp = journal->j_devname + strlen(journal->j_devname);\n\tsprintf(p, \"-%lu\", journal->j_inode->i_ino);\n\tjbd_debug(1,\n\t\t  \"journal %p: inode %s/%ld, size %Ld, bits %d, blksize %ld\\n\",\n\t\t  journal, inode->i_sb->s_id, inode->i_ino,\n\t\t  (long long) inode->i_size,\n\t\t  inode->i_sb->s_blocksize_bits, inode->i_sb->s_blocksize);\n\n\tjournal->j_maxlen = inode->i_size >> inode->i_sb->s_blocksize_bits;\n\tjournal->j_blocksize = inode->i_sb->s_blocksize;\n\tjbd2_stats_proc_init(journal);\n\n\t/* journal descriptor can store up to n blocks -bzzz */\n\tn = journal->j_blocksize / sizeof(journal_block_tag_t);\n\tjournal->j_wbufsize = n;\n\tjournal->j_wbuf = kmalloc(n * sizeof(struct buffer_head*), GFP_KERNEL);\n\tif (!journal->j_wbuf) {\n\t\tprintk(KERN_ERR \"%s: Can't allocate bhs for commit thread\\n\",\n\t\t\t__func__);\n\t\tgoto out_err;\n\t}\n\n\terr = jbd2_journal_bmap(journal, 0, &blocknr);\n\t/* If that failed, give up */\n\tif (err) {\n\t\tprintk(KERN_ERR \"%s: Cannot locate journal superblock\\n\",\n\t\t       __func__);\n\t\tgoto out_err;\n\t}\n\n\tbh = getblk_unmovable(journal->j_dev, blocknr, journal->j_blocksize);\n\tif (!bh) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Cannot get buffer for journal superblock\\n\",\n\t\t       __func__);\n\t\tgoto out_err;\n\t}\n\tjournal->j_sb_buffer = bh;\n\tjournal->j_superblock = (journal_superblock_t *)bh->b_data;\n\n\treturn journal;\nout_err:\n\tkfree(journal->j_wbuf);\n\tjbd2_stats_proc_exit(journal);\n\tkfree(journal);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_force_read_journal",
          "args": [
            "inode"
          ],
          "line": 1604
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_force_read_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "1131-1175",
          "snippet": "static int ocfs2_force_read_journal(struct inode *inode)\n{\n\tint status = 0;\n\tint i;\n\tu64 v_blkno, p_blkno, p_blocks, num_blocks;\n#define CONCURRENT_JOURNAL_FILL 32ULL\n\tstruct buffer_head *bhs[CONCURRENT_JOURNAL_FILL];\n\n\tmemset(bhs, 0, sizeof(struct buffer_head *) * CONCURRENT_JOURNAL_FILL);\n\n\tnum_blocks = ocfs2_blocks_for_bytes(inode->i_sb, i_size_read(inode));\n\tv_blkno = 0;\n\twhile (v_blkno < num_blocks) {\n\t\tstatus = ocfs2_extent_map_get_blocks(inode, v_blkno,\n\t\t\t\t\t\t     &p_blkno, &p_blocks, NULL);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (p_blocks > CONCURRENT_JOURNAL_FILL)\n\t\t\tp_blocks = CONCURRENT_JOURNAL_FILL;\n\n\t\t/* We are reading journal data which should not\n\t\t * be put in the uptodate cache */\n\t\tstatus = ocfs2_read_blocks_sync(OCFS2_SB(inode->i_sb),\n\t\t\t\t\t\tp_blkno, p_blocks, bhs);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tfor(i = 0; i < p_blocks; i++) {\n\t\t\tbrelse(bhs[i]);\n\t\t\tbhs[i] = NULL;\n\t\t}\n\n\t\tv_blkno += p_blocks;\n\t}\n\nbail:\n\tfor(i = 0; i < CONCURRENT_JOURNAL_FILL; i++)\n\t\tbrelse(bhs[i]);\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define CONCURRENT_JOURNAL_FILL 32ULL"
          ],
          "globals_used": [
            "static int ocfs2_force_read_journal(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define CONCURRENT_JOURNAL_FILL 32ULL\n\nstatic int ocfs2_force_read_journal(struct inode *inode);\n\nstatic int ocfs2_force_read_journal(struct inode *inode)\n{\n\tint status = 0;\n\tint i;\n\tu64 v_blkno, p_blkno, p_blocks, num_blocks;\n#define CONCURRENT_JOURNAL_FILL 32ULL\n\tstruct buffer_head *bhs[CONCURRENT_JOURNAL_FILL];\n\n\tmemset(bhs, 0, sizeof(struct buffer_head *) * CONCURRENT_JOURNAL_FILL);\n\n\tnum_blocks = ocfs2_blocks_for_bytes(inode->i_sb, i_size_read(inode));\n\tv_blkno = 0;\n\twhile (v_blkno < num_blocks) {\n\t\tstatus = ocfs2_extent_map_get_blocks(inode, v_blkno,\n\t\t\t\t\t\t     &p_blkno, &p_blocks, NULL);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (p_blocks > CONCURRENT_JOURNAL_FILL)\n\t\t\tp_blocks = CONCURRENT_JOURNAL_FILL;\n\n\t\t/* We are reading journal data which should not\n\t\t * be put in the uptodate cache */\n\t\tstatus = ocfs2_read_blocks_sync(OCFS2_SB(inode->i_sb),\n\t\t\t\t\t\tp_blkno, p_blocks, bhs);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tfor(i = 0; i < p_blocks; i++) {\n\t\t\tbrelse(bhs[i]);\n\t\t\tbhs[i] = NULL;\n\t\t}\n\n\t\tv_blkno += p_blocks;\n\t}\n\nbail:\n\tfor(i = 0; i < CONCURRENT_JOURNAL_FILL; i++)\n\t\tbrelse(bhs[i]);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 1602
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "osb->sb->s_dev"
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "osb->sb->s_dev"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_replay_map_set_state",
          "args": [
            "osb",
            "REPLAY_NEEDED"
          ],
          "line": 1596
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_replay_map_set_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "111-121",
          "snippet": "void ocfs2_replay_map_set_state(struct ocfs2_super *osb, int state)\n{\n\tif (!osb->replay_map)\n\t\treturn;\n\n\t/* If we've already queued the replay, we don't have any more to do */\n\tif (osb->replay_map->rm_state == REPLAY_DONE)\n\t\treturn;\n\n\tosb->replay_map->rm_state = state;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nvoid ocfs2_replay_map_set_state(struct ocfs2_super *osb, int state)\n{\n\tif (!osb->replay_map)\n\t\treturn;\n\n\t/* If we've already queued the replay, we don't have any more to do */\n\tif (osb->replay_map->rm_state == REPLAY_DONE)\n\t\treturn;\n\n\tosb->replay_map->rm_state = state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_replay_journal_skip",
          "args": [
            "node_num"
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_replay_journal_lock_err",
          "args": [
            "status"
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock_full",
          "args": [
            "inode",
            "&bh",
            "1",
            "OCFS2_META_LOCK_RECOVERY"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_replay_journal_recovered",
          "args": [
            "slot_num",
            "osb->slot_recovery_generations[slot_num]",
            "slot_reco_gen"
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_journal_inode",
          "args": [
            "osb",
            "slot_num",
            "&bh",
            "&inode"
          ],
          "line": 1545
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_journal_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "1494-1528",
          "snippet": "static int ocfs2_read_journal_inode(struct ocfs2_super *osb,\n\t\t\t\t    int slot_num,\n\t\t\t\t    struct buffer_head **bh,\n\t\t\t\t    struct inode **ret_inode)\n{\n\tint status = -EACCES;\n\tstruct inode *inode = NULL;\n\n\tBUG_ON(slot_num >= osb->max_slots);\n\n\tinode = ocfs2_get_system_file_inode(osb, JOURNAL_SYSTEM_INODE,\n\t\t\t\t\t    slot_num);\n\tif (!inode || is_bad_inode(inode)) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tSET_INODE_JOURNAL(inode);\n\n\tstatus = ocfs2_read_inode_block_full(inode, bh, OCFS2_BH_IGNORE_CACHE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\n\nbail:\n\tif (inode) {\n\t\tif (status || !ret_inode)\n\t\t\tiput(inode);\n\t\telse\n\t\t\t*ret_inode = inode;\n\t}\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_force_read_journal(struct inode *inode);",
            "static int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);",
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);",
            "static int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_force_read_journal(struct inode *inode);\nstatic int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\nstatic int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);\n\nstatic int ocfs2_read_journal_inode(struct ocfs2_super *osb,\n\t\t\t\t    int slot_num,\n\t\t\t\t    struct buffer_head **bh,\n\t\t\t\t    struct inode **ret_inode)\n{\n\tint status = -EACCES;\n\tstruct inode *inode = NULL;\n\n\tBUG_ON(slot_num >= osb->max_slots);\n\n\tinode = ocfs2_get_system_file_inode(osb, JOURNAL_SYSTEM_INODE,\n\t\t\t\t\t    slot_num);\n\tif (!inode || is_bad_inode(inode)) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tSET_INODE_JOURNAL(inode);\n\n\tstatus = ocfs2_read_inode_block_full(inode, bh, OCFS2_BH_IGNORE_CACHE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\n\nbail:\n\tif (inode) {\n\t\tif (status || !ret_inode)\n\t\t\tiput(inode);\n\t\telse\n\t\t\t*ret_inode = inode;\n\t}\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_force_read_journal(struct inode *inode);\nstatic int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\nstatic int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);\n\nstatic int ocfs2_replay_journal(struct ocfs2_super *osb,\n\t\t\t\tint node_num,\n\t\t\t\tint slot_num)\n{\n\tint status;\n\tint got_lock = 0;\n\tunsigned int flags;\n\tstruct inode *inode = NULL;\n\tstruct ocfs2_dinode *fe;\n\tjournal_t *journal = NULL;\n\tstruct buffer_head *bh = NULL;\n\tu32 slot_reco_gen;\n\n\tstatus = ocfs2_read_journal_inode(osb, slot_num, &bh, &inode);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto done;\n\t}\n\n\tfe = (struct ocfs2_dinode *)bh->b_data;\n\tslot_reco_gen = ocfs2_get_recovery_generation(fe);\n\tbrelse(bh);\n\tbh = NULL;\n\n\t/*\n\t * As the fs recovery is asynchronous, there is a small chance that\n\t * another node mounted (and recovered) the slot before the recovery\n\t * thread could get the lock. To handle that, we dirty read the journal\n\t * inode for that slot to get the recovery generation. If it is\n\t * different than what we expected, the slot has been recovered.\n\t * If not, it needs recovery.\n\t */\n\tif (osb->slot_recovery_generations[slot_num] != slot_reco_gen) {\n\t\ttrace_ocfs2_replay_journal_recovered(slot_num,\n\t\t     osb->slot_recovery_generations[slot_num], slot_reco_gen);\n\t\tosb->slot_recovery_generations[slot_num] = slot_reco_gen;\n\t\tstatus = -EBUSY;\n\t\tgoto done;\n\t}\n\n\t/* Continue with recovery as the journal has not yet been recovered */\n\n\tstatus = ocfs2_inode_lock_full(inode, &bh, 1, OCFS2_META_LOCK_RECOVERY);\n\tif (status < 0) {\n\t\ttrace_ocfs2_replay_journal_lock_err(status);\n\t\tif (status != -ERESTARTSYS)\n\t\t\tmlog(ML_ERROR, \"Could not lock journal!\\n\");\n\t\tgoto done;\n\t}\n\tgot_lock = 1;\n\n\tfe = (struct ocfs2_dinode *) bh->b_data;\n\n\tflags = le32_to_cpu(fe->id1.journal1.ij_flags);\n\tslot_reco_gen = ocfs2_get_recovery_generation(fe);\n\n\tif (!(flags & OCFS2_JOURNAL_DIRTY_FL)) {\n\t\ttrace_ocfs2_replay_journal_skip(node_num);\n\t\t/* Refresh recovery generation for the slot */\n\t\tosb->slot_recovery_generations[slot_num] = slot_reco_gen;\n\t\tgoto done;\n\t}\n\n\t/* we need to run complete recovery for offline orphan slots */\n\tocfs2_replay_map_set_state(osb, REPLAY_NEEDED);\n\n\tprintk(KERN_NOTICE \"ocfs2: Begin replay journal (node %d, slot %d) on \"\\\n\t       \"device (%u,%u)\\n\", node_num, slot_num, MAJOR(osb->sb->s_dev),\n\t       MINOR(osb->sb->s_dev));\n\n\tOCFS2_I(inode)->ip_clusters = le32_to_cpu(fe->i_clusters);\n\n\tstatus = ocfs2_force_read_journal(inode);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto done;\n\t}\n\n\tjournal = jbd2_journal_init_inode(inode);\n\tif (journal == NULL) {\n\t\tmlog(ML_ERROR, \"Linux journal layer error\\n\");\n\t\tstatus = -EIO;\n\t\tgoto done;\n\t}\n\n\tstatus = jbd2_journal_load(journal);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tif (!igrab(inode))\n\t\t\tBUG();\n\t\tjbd2_journal_destroy(journal);\n\t\tgoto done;\n\t}\n\n\tocfs2_clear_journal_error(osb->sb, journal, slot_num);\n\n\t/* wipe the journal */\n\tjbd2_journal_lock_updates(journal);\n\tstatus = jbd2_journal_flush(journal);\n\tjbd2_journal_unlock_updates(journal);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\t/* This will mark the node clean */\n\tflags = le32_to_cpu(fe->id1.journal1.ij_flags);\n\tflags &= ~OCFS2_JOURNAL_DIRTY_FL;\n\tfe->id1.journal1.ij_flags = cpu_to_le32(flags);\n\n\t/* Increment recovery generation to indicate successful recovery */\n\tocfs2_bump_recovery_generation(fe);\n\tosb->slot_recovery_generations[slot_num] =\n\t\t\t\t\tocfs2_get_recovery_generation(fe);\n\n\tocfs2_compute_meta_ecc(osb->sb, bh->b_data, &fe->i_check);\n\tstatus = ocfs2_write_block(osb, bh, INODE_CACHE(inode));\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tif (!igrab(inode))\n\t\tBUG();\n\n\tjbd2_journal_destroy(journal);\n\n\tprintk(KERN_NOTICE \"ocfs2: End replay journal (node %d, slot %d) on \"\\\n\t       \"device (%u,%u)\\n\", node_num, slot_num, MAJOR(osb->sb->s_dev),\n\t       MINOR(osb->sb->s_dev));\ndone:\n\t/* drop the lock on this nodes journal */\n\tif (got_lock)\n\t\tocfs2_inode_unlock(inode, 1);\n\n\tif (inode)\n\t\tiput(inode);\n\n\tbrelse(bh);\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_read_journal_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "1494-1528",
    "snippet": "static int ocfs2_read_journal_inode(struct ocfs2_super *osb,\n\t\t\t\t    int slot_num,\n\t\t\t\t    struct buffer_head **bh,\n\t\t\t\t    struct inode **ret_inode)\n{\n\tint status = -EACCES;\n\tstruct inode *inode = NULL;\n\n\tBUG_ON(slot_num >= osb->max_slots);\n\n\tinode = ocfs2_get_system_file_inode(osb, JOURNAL_SYSTEM_INODE,\n\t\t\t\t\t    slot_num);\n\tif (!inode || is_bad_inode(inode)) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tSET_INODE_JOURNAL(inode);\n\n\tstatus = ocfs2_read_inode_block_full(inode, bh, OCFS2_BH_IGNORE_CACHE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\n\nbail:\n\tif (inode) {\n\t\tif (status || !ret_inode)\n\t\t\tiput(inode);\n\t\telse\n\t\t\t*ret_inode = inode;\n\t}\n\treturn status;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_force_read_journal(struct inode *inode);",
      "static int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);",
      "static int ocfs2_commit_cache(struct ocfs2_super *osb);",
      "static int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 1523
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_inode_block_full",
          "args": [
            "inode",
            "bh",
            "OCFS2_BH_IGNORE_CACHE"
          ],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_inode_block_full",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "1388-1402",
          "snippet": "int ocfs2_read_inode_block_full(struct inode *inode, struct buffer_head **bh,\n\t\t\t\tint flags)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_blocks(INODE_CACHE(inode), OCFS2_I(inode)->ip_blkno,\n\t\t\t       1, &tmp, flags, ocfs2_validate_inode_block);\n\n\t/* If ocfs2_read_blocks() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_inode_block_full(struct inode *inode, struct buffer_head **bh,\n\t\t\t\tint flags)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_blocks(INODE_CACHE(inode), OCFS2_I(inode)->ip_blkno,\n\t\t\t       1, &tmp, flags, ocfs2_validate_inode_block);\n\n\t/* If ocfs2_read_blocks() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SET_INODE_JOURNAL",
          "args": [
            "inode"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "inode"
          ],
          "line": 1506
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_get_system_file_inode",
          "args": [
            "osb",
            "JOURNAL_SYSTEM_INODE",
            "slot_num"
          ],
          "line": 1504
        },
        "resolved": true,
        "details": {
          "function_name": "_ocfs2_get_system_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/sysfile.c",
          "lines": "138-181",
          "snippet": "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "slot_num >= osb->max_slots"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_force_read_journal(struct inode *inode);\nstatic int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\nstatic int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);\n\nstatic int ocfs2_read_journal_inode(struct ocfs2_super *osb,\n\t\t\t\t    int slot_num,\n\t\t\t\t    struct buffer_head **bh,\n\t\t\t\t    struct inode **ret_inode)\n{\n\tint status = -EACCES;\n\tstruct inode *inode = NULL;\n\n\tBUG_ON(slot_num >= osb->max_slots);\n\n\tinode = ocfs2_get_system_file_inode(osb, JOURNAL_SYSTEM_INODE,\n\t\t\t\t\t    slot_num);\n\tif (!inode || is_bad_inode(inode)) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tSET_INODE_JOURNAL(inode);\n\n\tstatus = ocfs2_read_inode_block_full(inode, bh, OCFS2_BH_IGNORE_CACHE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\n\nbail:\n\tif (inode) {\n\t\tif (status || !ret_inode)\n\t\t\tiput(inode);\n\t\telse\n\t\t\t*ret_inode = inode;\n\t}\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_recovery_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "1467-1492",
    "snippet": "void ocfs2_recovery_thread(struct ocfs2_super *osb, int node_num)\n{\n\tmutex_lock(&osb->recovery_lock);\n\n\ttrace_ocfs2_recovery_thread(node_num, osb->node_num,\n\t\tosb->disable_recovery, osb->recovery_thread_task,\n\t\tosb->disable_recovery ?\n\t\t-1 : ocfs2_recovery_map_set(osb, node_num));\n\n\tif (osb->disable_recovery)\n\t\tgoto out;\n\n\tif (osb->recovery_thread_task)\n\t\tgoto out;\n\n\tosb->recovery_thread_task =  kthread_run(__ocfs2_recovery_thread, osb,\n\t\t\t\t\t\t \"ocfs2rec\");\n\tif (IS_ERR(osb->recovery_thread_task)) {\n\t\tmlog_errno((int)PTR_ERR(osb->recovery_thread_task));\n\t\tosb->recovery_thread_task = NULL;\n\t}\n\nout:\n\tmutex_unlock(&osb->recovery_lock);\n\twake_up(&osb->recovery_event);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&osb->recovery_event"
          ],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&osb->recovery_lock"
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "(int)PTR_ERR(osb->recovery_thread_task)"
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "osb->recovery_thread_task"
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "osb->recovery_thread_task"
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "__ocfs2_recovery_thread",
            "osb",
            "\"ocfs2rec\""
          ],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_recovery_thread",
          "args": [
            "node_num",
            "osb->node_num",
            "osb->disable_recovery",
            "osb->recovery_thread_task",
            "osb->disable_recovery ?\n\t\t-1 : ocfs2_recovery_map_set(osb, node_num)"
          ],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_recovery_map_set",
          "args": [
            "osb",
            "node_num"
          ],
          "line": 1474
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_recovery_map_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "263-282",
          "snippet": "static int ocfs2_recovery_map_set(struct ocfs2_super *osb,\n\t\t\t\t  unsigned int node_num)\n{\n\tstruct ocfs2_recovery_map *rm = osb->recovery_map;\n\n\tspin_lock(&osb->osb_lock);\n\tif (__ocfs2_recovery_map_test(osb, node_num)) {\n\t\tspin_unlock(&osb->osb_lock);\n\t\treturn 1;\n\t}\n\n\t/* XXX: Can this be exploited? Not from o2dlm... */\n\tBUG_ON(rm->rm_used >= osb->max_slots);\n\n\trm->rm_entries[rm->rm_used] = node_num;\n\trm->rm_used++;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nstatic int ocfs2_recovery_map_set(struct ocfs2_super *osb,\n\t\t\t\t  unsigned int node_num)\n{\n\tstruct ocfs2_recovery_map *rm = osb->recovery_map;\n\n\tspin_lock(&osb->osb_lock);\n\tif (__ocfs2_recovery_map_test(osb, node_num)) {\n\t\tspin_unlock(&osb->osb_lock);\n\t\treturn 1;\n\t}\n\n\t/* XXX: Can this be exploited? Not from o2dlm... */\n\tBUG_ON(rm->rm_used >= osb->max_slots);\n\n\trm->rm_entries[rm->rm_used] = node_num;\n\trm->rm_used++;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&osb->recovery_lock"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nvoid ocfs2_recovery_thread(struct ocfs2_super *osb, int node_num)\n{\n\tmutex_lock(&osb->recovery_lock);\n\n\ttrace_ocfs2_recovery_thread(node_num, osb->node_num,\n\t\tosb->disable_recovery, osb->recovery_thread_task,\n\t\tosb->disable_recovery ?\n\t\t-1 : ocfs2_recovery_map_set(osb, node_num));\n\n\tif (osb->disable_recovery)\n\t\tgoto out;\n\n\tif (osb->recovery_thread_task)\n\t\tgoto out;\n\n\tosb->recovery_thread_task =  kthread_run(__ocfs2_recovery_thread, osb,\n\t\t\t\t\t\t \"ocfs2rec\");\n\tif (IS_ERR(osb->recovery_thread_task)) {\n\t\tmlog_errno((int)PTR_ERR(osb->recovery_thread_task));\n\t\tosb->recovery_thread_task = NULL;\n\t}\n\nout:\n\tmutex_unlock(&osb->recovery_lock);\n\twake_up(&osb->recovery_event);\n}"
  },
  {
    "function_name": "__ocfs2_recovery_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "1345-1465",
    "snippet": "static int __ocfs2_recovery_thread(void *arg)\n{\n\tint status, node_num, slot_num;\n\tstruct ocfs2_super *osb = arg;\n\tstruct ocfs2_recovery_map *rm = osb->recovery_map;\n\tint *rm_quota = NULL;\n\tint rm_quota_used = 0, i;\n\tstruct ocfs2_quota_recovery *qrec;\n\n\tstatus = ocfs2_wait_on_mount(osb);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\trm_quota = kzalloc(osb->max_slots * sizeof(int), GFP_NOFS);\n\tif (!rm_quota) {\n\t\tstatus = -ENOMEM;\n\t\tgoto bail;\n\t}\nrestart:\n\tstatus = ocfs2_super_lock(osb, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_compute_replay_slots(osb);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\t/* queue recovery for our own slot */\n\tocfs2_queue_recovery_completion(osb->journal, osb->slot_num, NULL,\n\t\t\t\t\tNULL, NULL, ORPHAN_NO_NEED_TRUNCATE);\n\n\tspin_lock(&osb->osb_lock);\n\twhile (rm->rm_used) {\n\t\t/* It's always safe to remove entry zero, as we won't\n\t\t * clear it until ocfs2_recover_node() has succeeded. */\n\t\tnode_num = rm->rm_entries[0];\n\t\tspin_unlock(&osb->osb_lock);\n\t\tslot_num = ocfs2_node_num_to_slot(osb, node_num);\n\t\ttrace_ocfs2_recovery_thread_node(node_num, slot_num);\n\t\tif (slot_num == -ENOENT) {\n\t\t\tstatus = 0;\n\t\t\tgoto skip_recovery;\n\t\t}\n\n\t\t/* It is a bit subtle with quota recovery. We cannot do it\n\t\t * immediately because we have to obtain cluster locks from\n\t\t * quota files and we also don't want to just skip it because\n\t\t * then quota usage would be out of sync until some node takes\n\t\t * the slot. So we remember which nodes need quota recovery\n\t\t * and when everything else is done, we recover quotas. */\n\t\tfor (i = 0; i < rm_quota_used && rm_quota[i] != slot_num; i++);\n\t\tif (i == rm_quota_used)\n\t\t\trm_quota[rm_quota_used++] = slot_num;\n\n\t\tstatus = ocfs2_recover_node(osb, node_num, slot_num);\nskip_recovery:\n\t\tif (!status) {\n\t\t\tocfs2_recovery_map_clear(osb, node_num);\n\t\t} else {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"Error %d recovering node %d on device (%u,%u)!\\n\",\n\t\t\t     status, node_num,\n\t\t\t     MAJOR(osb->sb->s_dev), MINOR(osb->sb->s_dev));\n\t\t\tmlog(ML_ERROR, \"Volume requires unmount.\\n\");\n\t\t}\n\n\t\tspin_lock(&osb->osb_lock);\n\t}\n\tspin_unlock(&osb->osb_lock);\n\ttrace_ocfs2_recovery_thread_end(status);\n\n\t/* Refresh all journal recovery generations from disk */\n\tstatus = ocfs2_check_journals_nolocks(osb);\n\tstatus = (status == -EROFS) ? 0 : status;\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\t/* Now it is right time to recover quotas... We have to do this under\n\t * superblock lock so that no one can start using the slot (and crash)\n\t * before we recover it */\n\tfor (i = 0; i < rm_quota_used; i++) {\n\t\tqrec = ocfs2_begin_quota_recovery(osb, rm_quota[i]);\n\t\tif (IS_ERR(qrec)) {\n\t\t\tstatus = PTR_ERR(qrec);\n\t\t\tmlog_errno(status);\n\t\t\tcontinue;\n\t\t}\n\t\tocfs2_queue_recovery_completion(osb->journal, rm_quota[i],\n\t\t\t\t\t\tNULL, NULL, qrec,\n\t\t\t\t\t\tORPHAN_NEED_TRUNCATE);\n\t}\n\n\tocfs2_super_unlock(osb, 1);\n\n\t/* queue recovery for offline slots */\n\tocfs2_queue_replay_slots(osb, ORPHAN_NEED_TRUNCATE);\n\nbail:\n\tmutex_lock(&osb->recovery_lock);\n\tif (!status && !ocfs2_recovery_completed(osb)) {\n\t\tmutex_unlock(&osb->recovery_lock);\n\t\tgoto restart;\n\t}\n\n\tocfs2_free_replay_slots(osb);\n\tosb->recovery_thread_task = NULL;\n\tmb(); /* sync with ocfs2_recovery_thread_running */\n\twake_up(&osb->recovery_event);\n\n\tmutex_unlock(&osb->recovery_lock);\n\n\tkfree(rm_quota);\n\n\t/* no one is callint kthread_stop() for us so the kthread() api\n\t * requires that we call do_exit().  And it isn't exported, but\n\t * complete_and_exit() seems to be a minimal wrapper around it. */\n\tcomplete_and_exit(NULL, status);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);",
      "static int __ocfs2_recovery_thread(void *arg);",
      "static int ocfs2_commit_cache(struct ocfs2_super *osb);",
      "static int __ocfs2_wait_on_mount(struct ocfs2_super *osb, int quota);",
      "static int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);",
      "static int ocfs2_commit_thread(void *arg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete_and_exit",
          "args": [
            "NULL",
            "status"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rm_quota"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&osb->recovery_lock"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&osb->recovery_event"
          ],
          "line": 1455
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb",
          "args": [],
          "line": 1454
        },
        "resolved": true,
        "details": {
          "function_name": "exit_mbcache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "851-854",
          "snippet": "static void __exit exit_mbcache(void)\n{\n\tunregister_shrinker(&mb_cache_shrinker);\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct shrinker mb_cache_shrinker = {\n\t.count_objects = mb_cache_shrink_count,\n\t.scan_objects = mb_cache_shrink_scan,\n\t.seeks = DEFAULT_SEEKS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct shrinker mb_cache_shrinker = {\n\t.count_objects = mb_cache_shrink_count,\n\t.scan_objects = mb_cache_shrink_scan,\n\t.seeks = DEFAULT_SEEKS,\n};\n\nstatic void __exit exit_mbcache(void)\n{\n\tunregister_shrinker(&mb_cache_shrinker);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_free_replay_slots",
          "args": [
            "osb"
          ],
          "line": 1452
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_replay_slots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "176-185",
          "snippet": "void ocfs2_free_replay_slots(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_replay_map *replay_map = osb->replay_map;\n\n\tif (!osb->replay_map)\n\t\treturn;\n\n\tkfree(replay_map);\n\tosb->replay_map = NULL;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nvoid ocfs2_free_replay_slots(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_replay_map *replay_map = osb->replay_map;\n\n\tif (!osb->replay_map)\n\t\treturn;\n\n\tkfree(replay_map);\n\tosb->replay_map = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&osb->recovery_lock"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_recovery_completed",
          "args": [
            "osb"
          ],
          "line": 1447
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_recovery_completed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "1104-1114",
          "snippet": "static int ocfs2_recovery_completed(struct ocfs2_super *osb)\n{\n\tint empty;\n\tstruct ocfs2_recovery_map *rm = osb->recovery_map;\n\n\tspin_lock(&osb->osb_lock);\n\tempty = (rm->rm_used == 0);\n\tspin_unlock(&osb->osb_lock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nstatic int ocfs2_recovery_completed(struct ocfs2_super *osb)\n{\n\tint empty;\n\tstruct ocfs2_recovery_map *rm = osb->recovery_map;\n\n\tspin_lock(&osb->osb_lock);\n\tempty = (rm->rm_used == 0);\n\tspin_unlock(&osb->osb_lock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&osb->recovery_lock"
          ],
          "line": 1446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_queue_replay_slots",
          "args": [
            "osb",
            "ORPHAN_NEED_TRUNCATE"
          ],
          "line": 1443
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_queue_replay_slots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "156-174",
          "snippet": "void ocfs2_queue_replay_slots(struct ocfs2_super *osb,\n\t\tenum ocfs2_orphan_reco_type orphan_reco_type)\n{\n\tstruct ocfs2_replay_map *replay_map = osb->replay_map;\n\tint i;\n\n\tif (!replay_map)\n\t\treturn;\n\n\tif (replay_map->rm_state != REPLAY_NEEDED)\n\t\treturn;\n\n\tfor (i = 0; i < replay_map->rm_slots; i++)\n\t\tif (replay_map->rm_replay_slots[i])\n\t\t\tocfs2_queue_recovery_completion(osb->journal, i, NULL,\n\t\t\t\t\t\t\tNULL, NULL,\n\t\t\t\t\t\t\torphan_reco_type);\n\treplay_map->rm_state = REPLAY_DONE;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);",
            "static int ocfs2_recover_orphans(struct ocfs2_super *osb,\n\t\t\t\t int slot,\n\t\t\t\t enum ocfs2_orphan_reco_type orphan_reco_type);",
            "static void ocfs2_queue_recovery_completion(struct ocfs2_journal *journal,\n\t\t\t\t\t    int slot_num,\n\t\t\t\t\t    struct ocfs2_dinode *la_dinode,\n\t\t\t\t\t    struct ocfs2_dinode *tl_dinode,\n\t\t\t\t\t    struct ocfs2_quota_recovery *qrec,\n\t\t\t\t\t    enum ocfs2_orphan_reco_type orphan_reco_type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\nstatic int ocfs2_recover_orphans(struct ocfs2_super *osb,\n\t\t\t\t int slot,\n\t\t\t\t enum ocfs2_orphan_reco_type orphan_reco_type);\nstatic void ocfs2_queue_recovery_completion(struct ocfs2_journal *journal,\n\t\t\t\t\t    int slot_num,\n\t\t\t\t\t    struct ocfs2_dinode *la_dinode,\n\t\t\t\t\t    struct ocfs2_dinode *tl_dinode,\n\t\t\t\t\t    struct ocfs2_quota_recovery *qrec,\n\t\t\t\t\t    enum ocfs2_orphan_reco_type orphan_reco_type);\n\nvoid ocfs2_queue_replay_slots(struct ocfs2_super *osb,\n\t\tenum ocfs2_orphan_reco_type orphan_reco_type)\n{\n\tstruct ocfs2_replay_map *replay_map = osb->replay_map;\n\tint i;\n\n\tif (!replay_map)\n\t\treturn;\n\n\tif (replay_map->rm_state != REPLAY_NEEDED)\n\t\treturn;\n\n\tfor (i = 0; i < replay_map->rm_slots; i++)\n\t\tif (replay_map->rm_replay_slots[i])\n\t\t\tocfs2_queue_recovery_completion(osb->journal, i, NULL,\n\t\t\t\t\t\t\tNULL, NULL,\n\t\t\t\t\t\t\torphan_reco_type);\n\treplay_map->rm_state = REPLAY_DONE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_super_unlock",
          "args": [
            "osb",
            "1"
          ],
          "line": 1440
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_super_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2587-2595",
          "snippet": "void ocfs2_super_unlock(struct ocfs2_super *osb,\n\t\t\tint ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &osb->osb_super_lockres;\n\n\tif (!ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_super_unlock(struct ocfs2_super *osb,\n\t\t\tint ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &osb->osb_super_lockres;\n\n\tif (!ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_queue_recovery_completion",
          "args": [
            "osb->journal",
            "rm_quota[i]",
            "NULL",
            "NULL",
            "qrec",
            "ORPHAN_NEED_TRUNCATE"
          ],
          "line": 1435
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_queue_recovery_completion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "1270-1305",
          "snippet": "static void ocfs2_queue_recovery_completion(struct ocfs2_journal *journal,\n\t\t\t\t\t    int slot_num,\n\t\t\t\t\t    struct ocfs2_dinode *la_dinode,\n\t\t\t\t\t    struct ocfs2_dinode *tl_dinode,\n\t\t\t\t\t    struct ocfs2_quota_recovery *qrec,\n\t\t\t\t\t    enum ocfs2_orphan_reco_type orphan_reco_type)\n{\n\tstruct ocfs2_la_recovery_item *item;\n\n\titem = kmalloc(sizeof(struct ocfs2_la_recovery_item), GFP_NOFS);\n\tif (!item) {\n\t\t/* Though we wish to avoid it, we are in fact safe in\n\t\t * skipping local alloc cleanup as fsck.ocfs2 is more\n\t\t * than capable of reclaiming unused space. */\n\t\tkfree(la_dinode);\n\t\tkfree(tl_dinode);\n\n\t\tif (qrec)\n\t\t\tocfs2_free_quota_recovery(qrec);\n\n\t\tmlog_errno(-ENOMEM);\n\t\treturn;\n\t}\n\n\tINIT_LIST_HEAD(&item->lri_list);\n\titem->lri_la_dinode = la_dinode;\n\titem->lri_slot = slot_num;\n\titem->lri_tl_dinode = tl_dinode;\n\titem->lri_qrec = qrec;\n\titem->lri_orphan_reco_type = orphan_reco_type;\n\n\tspin_lock(&journal->j_lock);\n\tlist_add_tail(&item->lri_list, &journal->j_la_cleanups);\n\tqueue_work(ocfs2_wq, &journal->j_recovery_work);\n\tspin_unlock(&journal->j_lock);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);",
            "static int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);",
            "static int ocfs2_recover_orphans(struct ocfs2_super *osb,\n\t\t\t\t int slot,\n\t\t\t\t enum ocfs2_orphan_reco_type orphan_reco_type);",
            "static void ocfs2_queue_recovery_completion(struct ocfs2_journal *journal,\n\t\t\t\t\t    int slot_num,\n\t\t\t\t\t    struct ocfs2_dinode *la_dinode,\n\t\t\t\t\t    struct ocfs2_dinode *tl_dinode,\n\t\t\t\t\t    struct ocfs2_quota_recovery *qrec,\n\t\t\t\t\t    enum ocfs2_orphan_reco_type orphan_reco_type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);\nstatic int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);\nstatic int ocfs2_recover_orphans(struct ocfs2_super *osb,\n\t\t\t\t int slot,\n\t\t\t\t enum ocfs2_orphan_reco_type orphan_reco_type);\nstatic void ocfs2_queue_recovery_completion(struct ocfs2_journal *journal,\n\t\t\t\t\t    int slot_num,\n\t\t\t\t\t    struct ocfs2_dinode *la_dinode,\n\t\t\t\t\t    struct ocfs2_dinode *tl_dinode,\n\t\t\t\t\t    struct ocfs2_quota_recovery *qrec,\n\t\t\t\t\t    enum ocfs2_orphan_reco_type orphan_reco_type);\n\nstatic void ocfs2_queue_recovery_completion(struct ocfs2_journal *journal,\n\t\t\t\t\t    int slot_num,\n\t\t\t\t\t    struct ocfs2_dinode *la_dinode,\n\t\t\t\t\t    struct ocfs2_dinode *tl_dinode,\n\t\t\t\t\t    struct ocfs2_quota_recovery *qrec,\n\t\t\t\t\t    enum ocfs2_orphan_reco_type orphan_reco_type)\n{\n\tstruct ocfs2_la_recovery_item *item;\n\n\titem = kmalloc(sizeof(struct ocfs2_la_recovery_item), GFP_NOFS);\n\tif (!item) {\n\t\t/* Though we wish to avoid it, we are in fact safe in\n\t\t * skipping local alloc cleanup as fsck.ocfs2 is more\n\t\t * than capable of reclaiming unused space. */\n\t\tkfree(la_dinode);\n\t\tkfree(tl_dinode);\n\n\t\tif (qrec)\n\t\t\tocfs2_free_quota_recovery(qrec);\n\n\t\tmlog_errno(-ENOMEM);\n\t\treturn;\n\t}\n\n\tINIT_LIST_HEAD(&item->lri_list);\n\titem->lri_la_dinode = la_dinode;\n\titem->lri_slot = slot_num;\n\titem->lri_tl_dinode = tl_dinode;\n\titem->lri_qrec = qrec;\n\titem->lri_orphan_reco_type = orphan_reco_type;\n\n\tspin_lock(&journal->j_lock);\n\tlist_add_tail(&item->lri_list, &journal->j_la_cleanups);\n\tqueue_work(ocfs2_wq, &journal->j_recovery_work);\n\tspin_unlock(&journal->j_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "qrec"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "qrec"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_begin_quota_recovery",
          "args": [
            "osb",
            "rm_quota[i]"
          ],
          "line": 1429
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_begin_quota_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "385-453",
          "snippet": "struct ocfs2_quota_recovery *ocfs2_begin_quota_recovery(\n\t\t\t\t\t\tstruct ocfs2_super *osb,\n\t\t\t\t\t\tint slot_num)\n{\n\tunsigned int feature[OCFS2_MAXQUOTAS] = {\n\t\t\t\t\tOCFS2_FEATURE_RO_COMPAT_USRQUOTA,\n\t\t\t\t\tOCFS2_FEATURE_RO_COMPAT_GRPQUOTA};\n\tunsigned int ino[OCFS2_MAXQUOTAS] = { LOCAL_USER_QUOTA_SYSTEM_INODE,\n\t\t\t\t\t      LOCAL_GROUP_QUOTA_SYSTEM_INODE };\n\tstruct super_block *sb = osb->sb;\n\tstruct ocfs2_local_disk_dqinfo *ldinfo;\n\tstruct inode *lqinode;\n\tstruct buffer_head *bh;\n\tint type;\n\tint status = 0;\n\tstruct ocfs2_quota_recovery *rec;\n\n\tprintk(KERN_NOTICE \"ocfs2: Beginning quota recovery on device (%s) for \"\n\t       \"slot %u\\n\", osb->dev_str, slot_num);\n\n\trec = ocfs2_alloc_quota_recovery();\n\tif (!rec)\n\t\treturn ERR_PTR(-ENOMEM);\n\t/* First init... */\n\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++) {\n\t\tif (!OCFS2_HAS_RO_COMPAT_FEATURE(sb, feature[type]))\n\t\t\tcontinue;\n\t\t/* At this point, journal of the slot is already replayed so\n\t\t * we can trust metadata and data of the quota file */\n\t\tlqinode = ocfs2_get_system_file_inode(osb, ino[type], slot_num);\n\t\tif (!lqinode) {\n\t\t\tstatus = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tstatus = ocfs2_inode_lock_full(lqinode, NULL, 1,\n\t\t\t\t\t       OCFS2_META_LOCK_RECOVERY);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto out_put;\n\t\t}\n\t\t/* Now read local header */\n\t\tbh = NULL;\n\t\tstatus = ocfs2_read_quota_block(lqinode, 0, &bh);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tmlog(ML_ERROR, \"failed to read quota file info header \"\n\t\t\t\t\"(slot=%d type=%d)\\n\", slot_num, type);\n\t\t\tgoto out_lock;\n\t\t}\n\t\tldinfo = (struct ocfs2_local_disk_dqinfo *)(bh->b_data +\n\t\t\t\t\t\t\tOCFS2_LOCAL_INFO_OFF);\n\t\tstatus = ocfs2_recovery_load_quota(lqinode, ldinfo, type,\n\t\t\t\t\t\t   &rec->r_list[type]);\n\t\tbrelse(bh);\nout_lock:\n\t\tocfs2_inode_unlock(lqinode, 1);\nout_put:\n\t\tiput(lqinode);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t}\nout:\n\tif (status < 0) {\n\t\tocfs2_free_quota_recovery(rec);\n\t\trec = ERR_PTR(status);\n\t}\n\treturn rec;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct ocfs2_quota_recovery *ocfs2_begin_quota_recovery(\n\t\t\t\t\t\tstruct ocfs2_super *osb,\n\t\t\t\t\t\tint slot_num)\n{\n\tunsigned int feature[OCFS2_MAXQUOTAS] = {\n\t\t\t\t\tOCFS2_FEATURE_RO_COMPAT_USRQUOTA,\n\t\t\t\t\tOCFS2_FEATURE_RO_COMPAT_GRPQUOTA};\n\tunsigned int ino[OCFS2_MAXQUOTAS] = { LOCAL_USER_QUOTA_SYSTEM_INODE,\n\t\t\t\t\t      LOCAL_GROUP_QUOTA_SYSTEM_INODE };\n\tstruct super_block *sb = osb->sb;\n\tstruct ocfs2_local_disk_dqinfo *ldinfo;\n\tstruct inode *lqinode;\n\tstruct buffer_head *bh;\n\tint type;\n\tint status = 0;\n\tstruct ocfs2_quota_recovery *rec;\n\n\tprintk(KERN_NOTICE \"ocfs2: Beginning quota recovery on device (%s) for \"\n\t       \"slot %u\\n\", osb->dev_str, slot_num);\n\n\trec = ocfs2_alloc_quota_recovery();\n\tif (!rec)\n\t\treturn ERR_PTR(-ENOMEM);\n\t/* First init... */\n\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++) {\n\t\tif (!OCFS2_HAS_RO_COMPAT_FEATURE(sb, feature[type]))\n\t\t\tcontinue;\n\t\t/* At this point, journal of the slot is already replayed so\n\t\t * we can trust metadata and data of the quota file */\n\t\tlqinode = ocfs2_get_system_file_inode(osb, ino[type], slot_num);\n\t\tif (!lqinode) {\n\t\t\tstatus = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tstatus = ocfs2_inode_lock_full(lqinode, NULL, 1,\n\t\t\t\t\t       OCFS2_META_LOCK_RECOVERY);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto out_put;\n\t\t}\n\t\t/* Now read local header */\n\t\tbh = NULL;\n\t\tstatus = ocfs2_read_quota_block(lqinode, 0, &bh);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tmlog(ML_ERROR, \"failed to read quota file info header \"\n\t\t\t\t\"(slot=%d type=%d)\\n\", slot_num, type);\n\t\t\tgoto out_lock;\n\t\t}\n\t\tldinfo = (struct ocfs2_local_disk_dqinfo *)(bh->b_data +\n\t\t\t\t\t\t\tOCFS2_LOCAL_INFO_OFF);\n\t\tstatus = ocfs2_recovery_load_quota(lqinode, ldinfo, type,\n\t\t\t\t\t\t   &rec->r_list[type]);\n\t\tbrelse(bh);\nout_lock:\n\t\tocfs2_inode_unlock(lqinode, 1);\nout_put:\n\t\tiput(lqinode);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t}\nout:\n\tif (status < 0) {\n\t\tocfs2_free_quota_recovery(rec);\n\t\trec = ERR_PTR(status);\n\t}\n\treturn rec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_check_journals_nolocks",
          "args": [
            "osb"
          ],
          "line": 1420
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_check_journals_nolocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "2291-2323",
          "snippet": "int ocfs2_check_journals_nolocks(struct ocfs2_super *osb)\n{\n\tint ret = 0;\n\tunsigned int slot;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tint journal_dirty = 0;\n\n\tfor(slot = 0; slot < osb->max_slots; slot++) {\n\t\tret = ocfs2_read_journal_inode(osb, slot, &di_bh, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdi = (struct ocfs2_dinode *) di_bh->b_data;\n\n\t\tosb->slot_recovery_generations[slot] =\n\t\t\t\t\tocfs2_get_recovery_generation(di);\n\n\t\tif (le32_to_cpu(di->id1.journal1.ij_flags) &\n\t\t    OCFS2_JOURNAL_DIRTY_FL)\n\t\t\tjournal_dirty = 1;\n\n\t\tbrelse(di_bh);\n\t\tdi_bh = NULL;\n\t}\n\nout:\n\tif (journal_dirty)\n\t\tret = -EROFS;\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_check_journals_nolocks(struct ocfs2_super *osb)\n{\n\tint ret = 0;\n\tunsigned int slot;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\tint journal_dirty = 0;\n\n\tfor(slot = 0; slot < osb->max_slots; slot++) {\n\t\tret = ocfs2_read_journal_inode(osb, slot, &di_bh, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tdi = (struct ocfs2_dinode *) di_bh->b_data;\n\n\t\tosb->slot_recovery_generations[slot] =\n\t\t\t\t\tocfs2_get_recovery_generation(di);\n\n\t\tif (le32_to_cpu(di->id1.journal1.ij_flags) &\n\t\t    OCFS2_JOURNAL_DIRTY_FL)\n\t\t\tjournal_dirty = 1;\n\n\t\tbrelse(di_bh);\n\t\tdi_bh = NULL;\n\t}\n\nout:\n\tif (journal_dirty)\n\t\tret = -EROFS;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_recovery_thread_end",
          "args": [
            "status"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 1416
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 1414
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Volume requires unmount.\\n\""
          ],
          "line": 1411
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Error %d recovering node %d on device (%u,%u)!\\n\"",
            "status",
            "node_num",
            "MAJOR(osb->sb->s_dev)",
            "MINOR(osb->sb->s_dev)"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "osb->sb->s_dev"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "osb->sb->s_dev"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_recovery_map_clear",
          "args": [
            "osb",
            "node_num"
          ],
          "line": 1405
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_recovery_map_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "284-305",
          "snippet": "static void ocfs2_recovery_map_clear(struct ocfs2_super *osb,\n\t\t\t\t     unsigned int node_num)\n{\n\tint i;\n\tstruct ocfs2_recovery_map *rm = osb->recovery_map;\n\n\tspin_lock(&osb->osb_lock);\n\n\tfor (i = 0; i < rm->rm_used; i++) {\n\t\tif (rm->rm_entries[i] == node_num)\n\t\t\tbreak;\n\t}\n\n\tif (i < rm->rm_used) {\n\t\t/* XXX: be careful with the pointer math */\n\t\tmemmove(&(rm->rm_entries[i]), &(rm->rm_entries[i + 1]),\n\t\t\t(rm->rm_used - i - 1) * sizeof(unsigned int));\n\t\trm->rm_used--;\n\t}\n\n\tspin_unlock(&osb->osb_lock);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nstatic void ocfs2_recovery_map_clear(struct ocfs2_super *osb,\n\t\t\t\t     unsigned int node_num)\n{\n\tint i;\n\tstruct ocfs2_recovery_map *rm = osb->recovery_map;\n\n\tspin_lock(&osb->osb_lock);\n\n\tfor (i = 0; i < rm->rm_used; i++) {\n\t\tif (rm->rm_entries[i] == node_num)\n\t\t\tbreak;\n\t}\n\n\tif (i < rm->rm_used) {\n\t\t/* XXX: be careful with the pointer math */\n\t\tmemmove(&(rm->rm_entries[i]), &(rm->rm_entries[i + 1]),\n\t\t\t(rm->rm_used - i - 1) * sizeof(unsigned int));\n\t\trm->rm_used--;\n\t}\n\n\tspin_unlock(&osb->osb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_recover_node",
          "args": [
            "osb",
            "node_num",
            "slot_num"
          ],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_recover_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "1683-1735",
          "snippet": "static int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num)\n{\n\tint status = 0;\n\tstruct ocfs2_dinode *la_copy = NULL;\n\tstruct ocfs2_dinode *tl_copy = NULL;\n\n\ttrace_ocfs2_recover_node(node_num, slot_num, osb->node_num);\n\n\t/* Should not ever be called to recover ourselves -- in that\n\t * case we should've called ocfs2_journal_load instead. */\n\tBUG_ON(osb->node_num == node_num);\n\n\tstatus = ocfs2_replay_journal(osb, node_num, slot_num);\n\tif (status < 0) {\n\t\tif (status == -EBUSY) {\n\t\t\ttrace_ocfs2_recover_node_skip(slot_num, node_num);\n\t\t\tstatus = 0;\n\t\t\tgoto done;\n\t\t}\n\t\tmlog_errno(status);\n\t\tgoto done;\n\t}\n\n\t/* Stamp a clean local alloc file AFTER recovering the journal... */\n\tstatus = ocfs2_begin_local_alloc_recovery(osb, slot_num, &la_copy);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto done;\n\t}\n\n\t/* An error from begin_truncate_log_recovery is not\n\t * serious enough to warrant halting the rest of\n\t * recovery. */\n\tstatus = ocfs2_begin_truncate_log_recovery(osb, slot_num, &tl_copy);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\t/* Likewise, this would be a strange but ultimately not so\n\t * harmful place to get an error... */\n\tstatus = ocfs2_clear_slot(osb, slot_num);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\t/* This will kfree the memory pointed to by la_copy and tl_copy */\n\tocfs2_queue_recovery_completion(osb->journal, slot_num, la_copy,\n\t\t\t\t\ttl_copy, NULL, ORPHAN_NEED_TRUNCATE);\n\n\tstatus = 0;\ndone:\n\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);",
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);",
            "static int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\nstatic int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);\n\nstatic int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num)\n{\n\tint status = 0;\n\tstruct ocfs2_dinode *la_copy = NULL;\n\tstruct ocfs2_dinode *tl_copy = NULL;\n\n\ttrace_ocfs2_recover_node(node_num, slot_num, osb->node_num);\n\n\t/* Should not ever be called to recover ourselves -- in that\n\t * case we should've called ocfs2_journal_load instead. */\n\tBUG_ON(osb->node_num == node_num);\n\n\tstatus = ocfs2_replay_journal(osb, node_num, slot_num);\n\tif (status < 0) {\n\t\tif (status == -EBUSY) {\n\t\t\ttrace_ocfs2_recover_node_skip(slot_num, node_num);\n\t\t\tstatus = 0;\n\t\t\tgoto done;\n\t\t}\n\t\tmlog_errno(status);\n\t\tgoto done;\n\t}\n\n\t/* Stamp a clean local alloc file AFTER recovering the journal... */\n\tstatus = ocfs2_begin_local_alloc_recovery(osb, slot_num, &la_copy);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto done;\n\t}\n\n\t/* An error from begin_truncate_log_recovery is not\n\t * serious enough to warrant halting the rest of\n\t * recovery. */\n\tstatus = ocfs2_begin_truncate_log_recovery(osb, slot_num, &tl_copy);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\t/* Likewise, this would be a strange but ultimately not so\n\t * harmful place to get an error... */\n\tstatus = ocfs2_clear_slot(osb, slot_num);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\t/* This will kfree the memory pointed to by la_copy and tl_copy */\n\tocfs2_queue_recovery_completion(osb->journal, slot_num, la_copy,\n\t\t\t\t\ttl_copy, NULL, ORPHAN_NEED_TRUNCATE);\n\n\tstatus = 0;\ndone:\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_recovery_thread_node",
          "args": [
            "node_num",
            "slot_num"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_node_num_to_slot",
          "args": [
            "osb",
            "node_num"
          ],
          "line": 1385
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_node_num_to_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
          "lines": "289-299",
          "snippet": "int ocfs2_node_num_to_slot(struct ocfs2_super *osb, unsigned int node_num)\n{\n\tint slot;\n\tstruct ocfs2_slot_info *si = osb->slot_info;\n\n\tspin_lock(&osb->osb_lock);\n\tslot = __ocfs2_node_num_to_slot(si, node_num);\n\tspin_unlock(&osb->osb_lock);\n\n\treturn slot;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __ocfs2_node_num_to_slot(struct ocfs2_slot_info *si,\n\t\t\t\t    unsigned int node_num);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int __ocfs2_node_num_to_slot(struct ocfs2_slot_info *si,\n\t\t\t\t    unsigned int node_num);\n\nint ocfs2_node_num_to_slot(struct ocfs2_super *osb, unsigned int node_num)\n{\n\tint slot;\n\tstruct ocfs2_slot_info *si = osb->slot_info;\n\n\tspin_lock(&osb->osb_lock);\n\tslot = __ocfs2_node_num_to_slot(si, node_num);\n\tspin_unlock(&osb->osb_lock);\n\n\treturn slot;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_compute_replay_slots",
          "args": [
            "osb"
          ],
          "line": 1371
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_compute_replay_slots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "123-154",
          "snippet": "int ocfs2_compute_replay_slots(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_replay_map *replay_map;\n\tint i, node_num;\n\n\t/* If replay map is already set, we don't do it again */\n\tif (osb->replay_map)\n\t\treturn 0;\n\n\treplay_map = kzalloc(sizeof(struct ocfs2_replay_map) +\n\t\t\t     (osb->max_slots * sizeof(char)), GFP_KERNEL);\n\n\tif (!replay_map) {\n\t\tmlog_errno(-ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock(&osb->osb_lock);\n\n\treplay_map->rm_slots = osb->max_slots;\n\treplay_map->rm_state = REPLAY_UNNEEDED;\n\n\t/* set rm_replay_slots for offline slot(s) */\n\tfor (i = 0; i < replay_map->rm_slots; i++) {\n\t\tif (ocfs2_slot_to_node_num_locked(osb, i, &node_num) == -ENOENT)\n\t\t\treplay_map->rm_replay_slots[i] = 1;\n\t}\n\n\tosb->replay_map = replay_map;\n\tspin_unlock(&osb->osb_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_compute_replay_slots(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_replay_map *replay_map;\n\tint i, node_num;\n\n\t/* If replay map is already set, we don't do it again */\n\tif (osb->replay_map)\n\t\treturn 0;\n\n\treplay_map = kzalloc(sizeof(struct ocfs2_replay_map) +\n\t\t\t     (osb->max_slots * sizeof(char)), GFP_KERNEL);\n\n\tif (!replay_map) {\n\t\tmlog_errno(-ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock(&osb->osb_lock);\n\n\treplay_map->rm_slots = osb->max_slots;\n\treplay_map->rm_state = REPLAY_UNNEEDED;\n\n\t/* set rm_replay_slots for offline slot(s) */\n\tfor (i = 0; i < replay_map->rm_slots; i++) {\n\t\tif (ocfs2_slot_to_node_num_locked(osb, i, &node_num) == -ENOENT)\n\t\t\treplay_map->rm_replay_slots[i] = 1;\n\t}\n\n\tosb->replay_map = replay_map;\n\tspin_unlock(&osb->osb_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_super_lock",
          "args": [
            "osb",
            "1"
          ],
          "line": 1365
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_super_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2548-2585",
          "snippet": "int ocfs2_super_lock(struct ocfs2_super *osb,\n\t\t     int ex)\n{\n\tint status = 0;\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &osb->osb_super_lockres;\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn -EROFS;\n\n\tif (ocfs2_mount_local(osb))\n\t\tgoto bail;\n\n\tstatus = ocfs2_cluster_lock(osb, lockres, level, 0, 0);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/* The super block lock path is really in the best position to\n\t * know when resources covered by the lock need to be\n\t * refreshed, so we do it here. Of course, making sense of\n\t * everything is up to the caller :) */\n\tstatus = ocfs2_should_refresh_lock_res(lockres);\n\tif (status) {\n\t\tstatus = ocfs2_refresh_slot_info(osb);\n\n\t\tocfs2_complete_lock_res_refresh(lockres, status);\n\n\t\tif (status < 0) {\n\t\t\tocfs2_cluster_unlock(osb, lockres, level);\n\t\t\tmlog_errno(status);\n\t\t}\n\t\tocfs2_track_lock_refresh(lockres);\n\t}\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nint ocfs2_super_lock(struct ocfs2_super *osb,\n\t\t     int ex)\n{\n\tint status = 0;\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &osb->osb_super_lockres;\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn -EROFS;\n\n\tif (ocfs2_mount_local(osb))\n\t\tgoto bail;\n\n\tstatus = ocfs2_cluster_lock(osb, lockres, level, 0, 0);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t/* The super block lock path is really in the best position to\n\t * know when resources covered by the lock need to be\n\t * refreshed, so we do it here. Of course, making sense of\n\t * everything is up to the caller :) */\n\tstatus = ocfs2_should_refresh_lock_res(lockres);\n\tif (status) {\n\t\tstatus = ocfs2_refresh_slot_info(osb);\n\n\t\tocfs2_complete_lock_res_refresh(lockres, status);\n\n\t\tif (status < 0) {\n\t\t\tocfs2_cluster_unlock(osb, lockres, level);\n\t\t\tmlog_errno(status);\n\t\t}\n\t\tocfs2_track_lock_refresh(lockres);\n\t}\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "osb->max_slots * sizeof(int)",
            "GFP_NOFS"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_wait_on_mount",
          "args": [
            "osb"
          ],
          "line": 1354
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_wait_on_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "84-87",
          "snippet": "static inline int ocfs2_wait_on_mount(struct ocfs2_super *osb)\n{\n\treturn __ocfs2_wait_on_mount(osb, 0);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nstatic inline int ocfs2_wait_on_mount(struct ocfs2_super *osb)\n{\n\treturn __ocfs2_wait_on_mount(osb, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);\nstatic int __ocfs2_recovery_thread(void *arg);\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\nstatic int __ocfs2_wait_on_mount(struct ocfs2_super *osb, int quota);\nstatic int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);\nstatic int ocfs2_commit_thread(void *arg);\n\nstatic int __ocfs2_recovery_thread(void *arg)\n{\n\tint status, node_num, slot_num;\n\tstruct ocfs2_super *osb = arg;\n\tstruct ocfs2_recovery_map *rm = osb->recovery_map;\n\tint *rm_quota = NULL;\n\tint rm_quota_used = 0, i;\n\tstruct ocfs2_quota_recovery *qrec;\n\n\tstatus = ocfs2_wait_on_mount(osb);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\trm_quota = kzalloc(osb->max_slots * sizeof(int), GFP_NOFS);\n\tif (!rm_quota) {\n\t\tstatus = -ENOMEM;\n\t\tgoto bail;\n\t}\nrestart:\n\tstatus = ocfs2_super_lock(osb, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_compute_replay_slots(osb);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\t/* queue recovery for our own slot */\n\tocfs2_queue_recovery_completion(osb->journal, osb->slot_num, NULL,\n\t\t\t\t\tNULL, NULL, ORPHAN_NO_NEED_TRUNCATE);\n\n\tspin_lock(&osb->osb_lock);\n\twhile (rm->rm_used) {\n\t\t/* It's always safe to remove entry zero, as we won't\n\t\t * clear it until ocfs2_recover_node() has succeeded. */\n\t\tnode_num = rm->rm_entries[0];\n\t\tspin_unlock(&osb->osb_lock);\n\t\tslot_num = ocfs2_node_num_to_slot(osb, node_num);\n\t\ttrace_ocfs2_recovery_thread_node(node_num, slot_num);\n\t\tif (slot_num == -ENOENT) {\n\t\t\tstatus = 0;\n\t\t\tgoto skip_recovery;\n\t\t}\n\n\t\t/* It is a bit subtle with quota recovery. We cannot do it\n\t\t * immediately because we have to obtain cluster locks from\n\t\t * quota files and we also don't want to just skip it because\n\t\t * then quota usage would be out of sync until some node takes\n\t\t * the slot. So we remember which nodes need quota recovery\n\t\t * and when everything else is done, we recover quotas. */\n\t\tfor (i = 0; i < rm_quota_used && rm_quota[i] != slot_num; i++);\n\t\tif (i == rm_quota_used)\n\t\t\trm_quota[rm_quota_used++] = slot_num;\n\n\t\tstatus = ocfs2_recover_node(osb, node_num, slot_num);\nskip_recovery:\n\t\tif (!status) {\n\t\t\tocfs2_recovery_map_clear(osb, node_num);\n\t\t} else {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"Error %d recovering node %d on device (%u,%u)!\\n\",\n\t\t\t     status, node_num,\n\t\t\t     MAJOR(osb->sb->s_dev), MINOR(osb->sb->s_dev));\n\t\t\tmlog(ML_ERROR, \"Volume requires unmount.\\n\");\n\t\t}\n\n\t\tspin_lock(&osb->osb_lock);\n\t}\n\tspin_unlock(&osb->osb_lock);\n\ttrace_ocfs2_recovery_thread_end(status);\n\n\t/* Refresh all journal recovery generations from disk */\n\tstatus = ocfs2_check_journals_nolocks(osb);\n\tstatus = (status == -EROFS) ? 0 : status;\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\t/* Now it is right time to recover quotas... We have to do this under\n\t * superblock lock so that no one can start using the slot (and crash)\n\t * before we recover it */\n\tfor (i = 0; i < rm_quota_used; i++) {\n\t\tqrec = ocfs2_begin_quota_recovery(osb, rm_quota[i]);\n\t\tif (IS_ERR(qrec)) {\n\t\t\tstatus = PTR_ERR(qrec);\n\t\t\tmlog_errno(status);\n\t\t\tcontinue;\n\t\t}\n\t\tocfs2_queue_recovery_completion(osb->journal, rm_quota[i],\n\t\t\t\t\t\tNULL, NULL, qrec,\n\t\t\t\t\t\tORPHAN_NEED_TRUNCATE);\n\t}\n\n\tocfs2_super_unlock(osb, 1);\n\n\t/* queue recovery for offline slots */\n\tocfs2_queue_replay_slots(osb, ORPHAN_NEED_TRUNCATE);\n\nbail:\n\tmutex_lock(&osb->recovery_lock);\n\tif (!status && !ocfs2_recovery_completed(osb)) {\n\t\tmutex_unlock(&osb->recovery_lock);\n\t\tgoto restart;\n\t}\n\n\tocfs2_free_replay_slots(osb);\n\tosb->recovery_thread_task = NULL;\n\tmb(); /* sync with ocfs2_recovery_thread_running */\n\twake_up(&osb->recovery_event);\n\n\tmutex_unlock(&osb->recovery_lock);\n\n\tkfree(rm_quota);\n\n\t/* no one is callint kthread_stop() for us so the kthread() api\n\t * requires that we call do_exit().  And it isn't exported, but\n\t * complete_and_exit() seems to be a minimal wrapper around it. */\n\tcomplete_and_exit(NULL, status);\n}"
  },
  {
    "function_name": "ocfs2_complete_quota_recovery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "1332-1343",
    "snippet": "void ocfs2_complete_quota_recovery(struct ocfs2_super *osb)\n{\n\tif (osb->quota_rec) {\n\t\tocfs2_queue_recovery_completion(osb->journal,\n\t\t\t\t\t\tosb->slot_num,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tosb->quota_rec,\n\t\t\t\t\t\tORPHAN_NEED_TRUNCATE);\n\t\tosb->quota_rec = NULL;\n\t}\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);",
      "static int ocfs2_commit_cache(struct ocfs2_super *osb);",
      "static int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_queue_recovery_completion",
          "args": [
            "osb->journal",
            "osb->slot_num",
            "NULL",
            "NULL",
            "osb->quota_rec",
            "ORPHAN_NEED_TRUNCATE"
          ],
          "line": 1335
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_queue_recovery_completion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "1270-1305",
          "snippet": "static void ocfs2_queue_recovery_completion(struct ocfs2_journal *journal,\n\t\t\t\t\t    int slot_num,\n\t\t\t\t\t    struct ocfs2_dinode *la_dinode,\n\t\t\t\t\t    struct ocfs2_dinode *tl_dinode,\n\t\t\t\t\t    struct ocfs2_quota_recovery *qrec,\n\t\t\t\t\t    enum ocfs2_orphan_reco_type orphan_reco_type)\n{\n\tstruct ocfs2_la_recovery_item *item;\n\n\titem = kmalloc(sizeof(struct ocfs2_la_recovery_item), GFP_NOFS);\n\tif (!item) {\n\t\t/* Though we wish to avoid it, we are in fact safe in\n\t\t * skipping local alloc cleanup as fsck.ocfs2 is more\n\t\t * than capable of reclaiming unused space. */\n\t\tkfree(la_dinode);\n\t\tkfree(tl_dinode);\n\n\t\tif (qrec)\n\t\t\tocfs2_free_quota_recovery(qrec);\n\n\t\tmlog_errno(-ENOMEM);\n\t\treturn;\n\t}\n\n\tINIT_LIST_HEAD(&item->lri_list);\n\titem->lri_la_dinode = la_dinode;\n\titem->lri_slot = slot_num;\n\titem->lri_tl_dinode = tl_dinode;\n\titem->lri_qrec = qrec;\n\titem->lri_orphan_reco_type = orphan_reco_type;\n\n\tspin_lock(&journal->j_lock);\n\tlist_add_tail(&item->lri_list, &journal->j_la_cleanups);\n\tqueue_work(ocfs2_wq, &journal->j_recovery_work);\n\tspin_unlock(&journal->j_lock);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);",
            "static int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);",
            "static int ocfs2_recover_orphans(struct ocfs2_super *osb,\n\t\t\t\t int slot,\n\t\t\t\t enum ocfs2_orphan_reco_type orphan_reco_type);",
            "static void ocfs2_queue_recovery_completion(struct ocfs2_journal *journal,\n\t\t\t\t\t    int slot_num,\n\t\t\t\t\t    struct ocfs2_dinode *la_dinode,\n\t\t\t\t\t    struct ocfs2_dinode *tl_dinode,\n\t\t\t\t\t    struct ocfs2_quota_recovery *qrec,\n\t\t\t\t\t    enum ocfs2_orphan_reco_type orphan_reco_type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);\nstatic int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);\nstatic int ocfs2_recover_orphans(struct ocfs2_super *osb,\n\t\t\t\t int slot,\n\t\t\t\t enum ocfs2_orphan_reco_type orphan_reco_type);\nstatic void ocfs2_queue_recovery_completion(struct ocfs2_journal *journal,\n\t\t\t\t\t    int slot_num,\n\t\t\t\t\t    struct ocfs2_dinode *la_dinode,\n\t\t\t\t\t    struct ocfs2_dinode *tl_dinode,\n\t\t\t\t\t    struct ocfs2_quota_recovery *qrec,\n\t\t\t\t\t    enum ocfs2_orphan_reco_type orphan_reco_type);\n\nstatic void ocfs2_queue_recovery_completion(struct ocfs2_journal *journal,\n\t\t\t\t\t    int slot_num,\n\t\t\t\t\t    struct ocfs2_dinode *la_dinode,\n\t\t\t\t\t    struct ocfs2_dinode *tl_dinode,\n\t\t\t\t\t    struct ocfs2_quota_recovery *qrec,\n\t\t\t\t\t    enum ocfs2_orphan_reco_type orphan_reco_type)\n{\n\tstruct ocfs2_la_recovery_item *item;\n\n\titem = kmalloc(sizeof(struct ocfs2_la_recovery_item), GFP_NOFS);\n\tif (!item) {\n\t\t/* Though we wish to avoid it, we are in fact safe in\n\t\t * skipping local alloc cleanup as fsck.ocfs2 is more\n\t\t * than capable of reclaiming unused space. */\n\t\tkfree(la_dinode);\n\t\tkfree(tl_dinode);\n\n\t\tif (qrec)\n\t\t\tocfs2_free_quota_recovery(qrec);\n\n\t\tmlog_errno(-ENOMEM);\n\t\treturn;\n\t}\n\n\tINIT_LIST_HEAD(&item->lri_list);\n\titem->lri_la_dinode = la_dinode;\n\titem->lri_slot = slot_num;\n\titem->lri_tl_dinode = tl_dinode;\n\titem->lri_qrec = qrec;\n\titem->lri_orphan_reco_type = orphan_reco_type;\n\n\tspin_lock(&journal->j_lock);\n\tlist_add_tail(&item->lri_list, &journal->j_la_cleanups);\n\tqueue_work(ocfs2_wq, &journal->j_recovery_work);\n\tspin_unlock(&journal->j_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\nstatic int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);\n\nvoid ocfs2_complete_quota_recovery(struct ocfs2_super *osb)\n{\n\tif (osb->quota_rec) {\n\t\tocfs2_queue_recovery_completion(osb->journal,\n\t\t\t\t\t\tosb->slot_num,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tosb->quota_rec,\n\t\t\t\t\t\tORPHAN_NEED_TRUNCATE);\n\t\tosb->quota_rec = NULL;\n\t}\n}"
  },
  {
    "function_name": "ocfs2_complete_mount_recovery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "1309-1330",
    "snippet": "void ocfs2_complete_mount_recovery(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn;\n\n\t/* No need to queue up our truncate_log as regular cleanup will catch\n\t * that */\n\tocfs2_queue_recovery_completion(journal, osb->slot_num,\n\t\t\t\t\tosb->local_alloc_copy, NULL, NULL,\n\t\t\t\t\tORPHAN_NEED_TRUNCATE);\n\tocfs2_schedule_truncate_log_flush(osb, 0);\n\n\tosb->local_alloc_copy = NULL;\n\tosb->dirty = 0;\n\n\t/* queue to recover orphan slots for all offline slots */\n\tocfs2_replay_map_set_state(osb, REPLAY_NEEDED);\n\tocfs2_queue_replay_slots(osb, ORPHAN_NEED_TRUNCATE);\n\tocfs2_free_replay_slots(osb);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);",
      "static int ocfs2_commit_cache(struct ocfs2_super *osb);",
      "static int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_replay_slots",
          "args": [
            "osb"
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_replay_slots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "176-185",
          "snippet": "void ocfs2_free_replay_slots(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_replay_map *replay_map = osb->replay_map;\n\n\tif (!osb->replay_map)\n\t\treturn;\n\n\tkfree(replay_map);\n\tosb->replay_map = NULL;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nvoid ocfs2_free_replay_slots(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_replay_map *replay_map = osb->replay_map;\n\n\tif (!osb->replay_map)\n\t\treturn;\n\n\tkfree(replay_map);\n\tosb->replay_map = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_queue_replay_slots",
          "args": [
            "osb",
            "ORPHAN_NEED_TRUNCATE"
          ],
          "line": 1328
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_queue_replay_slots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "156-174",
          "snippet": "void ocfs2_queue_replay_slots(struct ocfs2_super *osb,\n\t\tenum ocfs2_orphan_reco_type orphan_reco_type)\n{\n\tstruct ocfs2_replay_map *replay_map = osb->replay_map;\n\tint i;\n\n\tif (!replay_map)\n\t\treturn;\n\n\tif (replay_map->rm_state != REPLAY_NEEDED)\n\t\treturn;\n\n\tfor (i = 0; i < replay_map->rm_slots; i++)\n\t\tif (replay_map->rm_replay_slots[i])\n\t\t\tocfs2_queue_recovery_completion(osb->journal, i, NULL,\n\t\t\t\t\t\t\tNULL, NULL,\n\t\t\t\t\t\t\torphan_reco_type);\n\treplay_map->rm_state = REPLAY_DONE;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);",
            "static int ocfs2_recover_orphans(struct ocfs2_super *osb,\n\t\t\t\t int slot,\n\t\t\t\t enum ocfs2_orphan_reco_type orphan_reco_type);",
            "static void ocfs2_queue_recovery_completion(struct ocfs2_journal *journal,\n\t\t\t\t\t    int slot_num,\n\t\t\t\t\t    struct ocfs2_dinode *la_dinode,\n\t\t\t\t\t    struct ocfs2_dinode *tl_dinode,\n\t\t\t\t\t    struct ocfs2_quota_recovery *qrec,\n\t\t\t\t\t    enum ocfs2_orphan_reco_type orphan_reco_type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\nstatic int ocfs2_recover_orphans(struct ocfs2_super *osb,\n\t\t\t\t int slot,\n\t\t\t\t enum ocfs2_orphan_reco_type orphan_reco_type);\nstatic void ocfs2_queue_recovery_completion(struct ocfs2_journal *journal,\n\t\t\t\t\t    int slot_num,\n\t\t\t\t\t    struct ocfs2_dinode *la_dinode,\n\t\t\t\t\t    struct ocfs2_dinode *tl_dinode,\n\t\t\t\t\t    struct ocfs2_quota_recovery *qrec,\n\t\t\t\t\t    enum ocfs2_orphan_reco_type orphan_reco_type);\n\nvoid ocfs2_queue_replay_slots(struct ocfs2_super *osb,\n\t\tenum ocfs2_orphan_reco_type orphan_reco_type)\n{\n\tstruct ocfs2_replay_map *replay_map = osb->replay_map;\n\tint i;\n\n\tif (!replay_map)\n\t\treturn;\n\n\tif (replay_map->rm_state != REPLAY_NEEDED)\n\t\treturn;\n\n\tfor (i = 0; i < replay_map->rm_slots; i++)\n\t\tif (replay_map->rm_replay_slots[i])\n\t\t\tocfs2_queue_recovery_completion(osb->journal, i, NULL,\n\t\t\t\t\t\t\tNULL, NULL,\n\t\t\t\t\t\t\torphan_reco_type);\n\treplay_map->rm_state = REPLAY_DONE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_replay_map_set_state",
          "args": [
            "osb",
            "REPLAY_NEEDED"
          ],
          "line": 1327
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_replay_map_set_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "111-121",
          "snippet": "void ocfs2_replay_map_set_state(struct ocfs2_super *osb, int state)\n{\n\tif (!osb->replay_map)\n\t\treturn;\n\n\t/* If we've already queued the replay, we don't have any more to do */\n\tif (osb->replay_map->rm_state == REPLAY_DONE)\n\t\treturn;\n\n\tosb->replay_map->rm_state = state;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nvoid ocfs2_replay_map_set_state(struct ocfs2_super *osb, int state)\n{\n\tif (!osb->replay_map)\n\t\treturn;\n\n\t/* If we've already queued the replay, we don't have any more to do */\n\tif (osb->replay_map->rm_state == REPLAY_DONE)\n\t\treturn;\n\n\tosb->replay_map->rm_state = state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_schedule_truncate_log_flush",
          "args": [
            "osb",
            "0"
          ],
          "line": 1321
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_schedule_truncate_log_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6057-6070",
          "snippet": "void ocfs2_schedule_truncate_log_flush(struct ocfs2_super *osb,\n\t\t\t\t       int cancel)\n{\n\tif (osb->osb_tl_inode &&\n\t\t\tatomic_read(&osb->osb_tl_disable) == 0) {\n\t\t/* We want to push off log flushes while truncates are\n\t\t * still running. */\n\t\tif (cancel)\n\t\t\tcancel_delayed_work(&osb->osb_truncate_log_wq);\n\n\t\tqueue_delayed_work(ocfs2_wq, &osb->osb_truncate_log_wq,\n\t\t\t\t   OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL (2 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL (2 * HZ)\n\nvoid ocfs2_schedule_truncate_log_flush(struct ocfs2_super *osb,\n\t\t\t\t       int cancel)\n{\n\tif (osb->osb_tl_inode &&\n\t\t\tatomic_read(&osb->osb_tl_disable) == 0) {\n\t\t/* We want to push off log flushes while truncates are\n\t\t * still running. */\n\t\tif (cancel)\n\t\t\tcancel_delayed_work(&osb->osb_truncate_log_wq);\n\n\t\tqueue_delayed_work(ocfs2_wq, &osb->osb_truncate_log_wq,\n\t\t\t\t   OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_queue_recovery_completion",
          "args": [
            "journal",
            "osb->slot_num",
            "osb->local_alloc_copy",
            "NULL",
            "NULL",
            "ORPHAN_NEED_TRUNCATE"
          ],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_queue_recovery_completion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "1270-1305",
          "snippet": "static void ocfs2_queue_recovery_completion(struct ocfs2_journal *journal,\n\t\t\t\t\t    int slot_num,\n\t\t\t\t\t    struct ocfs2_dinode *la_dinode,\n\t\t\t\t\t    struct ocfs2_dinode *tl_dinode,\n\t\t\t\t\t    struct ocfs2_quota_recovery *qrec,\n\t\t\t\t\t    enum ocfs2_orphan_reco_type orphan_reco_type)\n{\n\tstruct ocfs2_la_recovery_item *item;\n\n\titem = kmalloc(sizeof(struct ocfs2_la_recovery_item), GFP_NOFS);\n\tif (!item) {\n\t\t/* Though we wish to avoid it, we are in fact safe in\n\t\t * skipping local alloc cleanup as fsck.ocfs2 is more\n\t\t * than capable of reclaiming unused space. */\n\t\tkfree(la_dinode);\n\t\tkfree(tl_dinode);\n\n\t\tif (qrec)\n\t\t\tocfs2_free_quota_recovery(qrec);\n\n\t\tmlog_errno(-ENOMEM);\n\t\treturn;\n\t}\n\n\tINIT_LIST_HEAD(&item->lri_list);\n\titem->lri_la_dinode = la_dinode;\n\titem->lri_slot = slot_num;\n\titem->lri_tl_dinode = tl_dinode;\n\titem->lri_qrec = qrec;\n\titem->lri_orphan_reco_type = orphan_reco_type;\n\n\tspin_lock(&journal->j_lock);\n\tlist_add_tail(&item->lri_list, &journal->j_la_cleanups);\n\tqueue_work(ocfs2_wq, &journal->j_recovery_work);\n\tspin_unlock(&journal->j_lock);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);",
            "static int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);",
            "static int ocfs2_recover_orphans(struct ocfs2_super *osb,\n\t\t\t\t int slot,\n\t\t\t\t enum ocfs2_orphan_reco_type orphan_reco_type);",
            "static void ocfs2_queue_recovery_completion(struct ocfs2_journal *journal,\n\t\t\t\t\t    int slot_num,\n\t\t\t\t\t    struct ocfs2_dinode *la_dinode,\n\t\t\t\t\t    struct ocfs2_dinode *tl_dinode,\n\t\t\t\t\t    struct ocfs2_quota_recovery *qrec,\n\t\t\t\t\t    enum ocfs2_orphan_reco_type orphan_reco_type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);\nstatic int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);\nstatic int ocfs2_recover_orphans(struct ocfs2_super *osb,\n\t\t\t\t int slot,\n\t\t\t\t enum ocfs2_orphan_reco_type orphan_reco_type);\nstatic void ocfs2_queue_recovery_completion(struct ocfs2_journal *journal,\n\t\t\t\t\t    int slot_num,\n\t\t\t\t\t    struct ocfs2_dinode *la_dinode,\n\t\t\t\t\t    struct ocfs2_dinode *tl_dinode,\n\t\t\t\t\t    struct ocfs2_quota_recovery *qrec,\n\t\t\t\t\t    enum ocfs2_orphan_reco_type orphan_reco_type);\n\nstatic void ocfs2_queue_recovery_completion(struct ocfs2_journal *journal,\n\t\t\t\t\t    int slot_num,\n\t\t\t\t\t    struct ocfs2_dinode *la_dinode,\n\t\t\t\t\t    struct ocfs2_dinode *tl_dinode,\n\t\t\t\t\t    struct ocfs2_quota_recovery *qrec,\n\t\t\t\t\t    enum ocfs2_orphan_reco_type orphan_reco_type)\n{\n\tstruct ocfs2_la_recovery_item *item;\n\n\titem = kmalloc(sizeof(struct ocfs2_la_recovery_item), GFP_NOFS);\n\tif (!item) {\n\t\t/* Though we wish to avoid it, we are in fact safe in\n\t\t * skipping local alloc cleanup as fsck.ocfs2 is more\n\t\t * than capable of reclaiming unused space. */\n\t\tkfree(la_dinode);\n\t\tkfree(tl_dinode);\n\n\t\tif (qrec)\n\t\t\tocfs2_free_quota_recovery(qrec);\n\n\t\tmlog_errno(-ENOMEM);\n\t\treturn;\n\t}\n\n\tINIT_LIST_HEAD(&item->lri_list);\n\titem->lri_la_dinode = la_dinode;\n\titem->lri_slot = slot_num;\n\titem->lri_tl_dinode = tl_dinode;\n\titem->lri_qrec = qrec;\n\titem->lri_orphan_reco_type = orphan_reco_type;\n\n\tspin_lock(&journal->j_lock);\n\tlist_add_tail(&item->lri_list, &journal->j_la_cleanups);\n\tqueue_work(ocfs2_wq, &journal->j_recovery_work);\n\tspin_unlock(&journal->j_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_is_hard_readonly",
          "args": [
            "osb"
          ],
          "line": 1313
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_hard_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "615-624",
          "snippet": "static inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define OCFS2_OSB_HARD_RO\t0x0002"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define OCFS2_OSB_HARD_RO\t0x0002\n\nstatic inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\nstatic int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);\n\nvoid ocfs2_complete_mount_recovery(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn;\n\n\t/* No need to queue up our truncate_log as regular cleanup will catch\n\t * that */\n\tocfs2_queue_recovery_completion(journal, osb->slot_num,\n\t\t\t\t\tosb->local_alloc_copy, NULL, NULL,\n\t\t\t\t\tORPHAN_NEED_TRUNCATE);\n\tocfs2_schedule_truncate_log_flush(osb, 0);\n\n\tosb->local_alloc_copy = NULL;\n\tosb->dirty = 0;\n\n\t/* queue to recover orphan slots for all offline slots */\n\tocfs2_replay_map_set_state(osb, REPLAY_NEEDED);\n\tocfs2_queue_replay_slots(osb, ORPHAN_NEED_TRUNCATE);\n\tocfs2_free_replay_slots(osb);\n}"
  },
  {
    "function_name": "ocfs2_queue_recovery_completion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "1270-1305",
    "snippet": "static void ocfs2_queue_recovery_completion(struct ocfs2_journal *journal,\n\t\t\t\t\t    int slot_num,\n\t\t\t\t\t    struct ocfs2_dinode *la_dinode,\n\t\t\t\t\t    struct ocfs2_dinode *tl_dinode,\n\t\t\t\t\t    struct ocfs2_quota_recovery *qrec,\n\t\t\t\t\t    enum ocfs2_orphan_reco_type orphan_reco_type)\n{\n\tstruct ocfs2_la_recovery_item *item;\n\n\titem = kmalloc(sizeof(struct ocfs2_la_recovery_item), GFP_NOFS);\n\tif (!item) {\n\t\t/* Though we wish to avoid it, we are in fact safe in\n\t\t * skipping local alloc cleanup as fsck.ocfs2 is more\n\t\t * than capable of reclaiming unused space. */\n\t\tkfree(la_dinode);\n\t\tkfree(tl_dinode);\n\n\t\tif (qrec)\n\t\t\tocfs2_free_quota_recovery(qrec);\n\n\t\tmlog_errno(-ENOMEM);\n\t\treturn;\n\t}\n\n\tINIT_LIST_HEAD(&item->lri_list);\n\titem->lri_la_dinode = la_dinode;\n\titem->lri_slot = slot_num;\n\titem->lri_tl_dinode = tl_dinode;\n\titem->lri_qrec = qrec;\n\titem->lri_orphan_reco_type = orphan_reco_type;\n\n\tspin_lock(&journal->j_lock);\n\tlist_add_tail(&item->lri_list, &journal->j_la_cleanups);\n\tqueue_work(ocfs2_wq, &journal->j_recovery_work);\n\tspin_unlock(&journal->j_lock);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);",
      "static int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);",
      "static int ocfs2_recover_orphans(struct ocfs2_super *osb,\n\t\t\t\t int slot,\n\t\t\t\t enum ocfs2_orphan_reco_type orphan_reco_type);",
      "static void ocfs2_queue_recovery_completion(struct ocfs2_journal *journal,\n\t\t\t\t\t    int slot_num,\n\t\t\t\t\t    struct ocfs2_dinode *la_dinode,\n\t\t\t\t\t    struct ocfs2_dinode *tl_dinode,\n\t\t\t\t\t    struct ocfs2_quota_recovery *qrec,\n\t\t\t\t\t    enum ocfs2_orphan_reco_type orphan_reco_type);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_lock"
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "ocfs2_wq",
            "&journal->j_recovery_work"
          ],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&item->lri_list",
            "&journal->j_la_cleanups"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_lock"
          ],
          "line": 1301
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&item->lri_list"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "-ENOMEM"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_free_quota_recovery",
          "args": [
            "qrec"
          ],
          "line": 1288
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_quota_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "329-336",
          "snippet": "void ocfs2_free_quota_recovery(struct ocfs2_quota_recovery *rec)\n{\n\tint type;\n\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++)\n\t\tfree_recovery_list(&(rec->r_list[type]));\n\tkfree(rec);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_quota_recovery(struct ocfs2_quota_recovery *rec)\n{\n\tint type;\n\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++)\n\t\tfree_recovery_list(&(rec->r_list[type]));\n\tkfree(rec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tl_dinode"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "la_dinode"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct ocfs2_la_recovery_item)",
            "GFP_NOFS"
          ],
          "line": 1279
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);\nstatic int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);\nstatic int ocfs2_recover_orphans(struct ocfs2_super *osb,\n\t\t\t\t int slot,\n\t\t\t\t enum ocfs2_orphan_reco_type orphan_reco_type);\nstatic void ocfs2_queue_recovery_completion(struct ocfs2_journal *journal,\n\t\t\t\t\t    int slot_num,\n\t\t\t\t\t    struct ocfs2_dinode *la_dinode,\n\t\t\t\t\t    struct ocfs2_dinode *tl_dinode,\n\t\t\t\t\t    struct ocfs2_quota_recovery *qrec,\n\t\t\t\t\t    enum ocfs2_orphan_reco_type orphan_reco_type);\n\nstatic void ocfs2_queue_recovery_completion(struct ocfs2_journal *journal,\n\t\t\t\t\t    int slot_num,\n\t\t\t\t\t    struct ocfs2_dinode *la_dinode,\n\t\t\t\t\t    struct ocfs2_dinode *tl_dinode,\n\t\t\t\t\t    struct ocfs2_quota_recovery *qrec,\n\t\t\t\t\t    enum ocfs2_orphan_reco_type orphan_reco_type)\n{\n\tstruct ocfs2_la_recovery_item *item;\n\n\titem = kmalloc(sizeof(struct ocfs2_la_recovery_item), GFP_NOFS);\n\tif (!item) {\n\t\t/* Though we wish to avoid it, we are in fact safe in\n\t\t * skipping local alloc cleanup as fsck.ocfs2 is more\n\t\t * than capable of reclaiming unused space. */\n\t\tkfree(la_dinode);\n\t\tkfree(tl_dinode);\n\n\t\tif (qrec)\n\t\t\tocfs2_free_quota_recovery(qrec);\n\n\t\tmlog_errno(-ENOMEM);\n\t\treturn;\n\t}\n\n\tINIT_LIST_HEAD(&item->lri_list);\n\titem->lri_la_dinode = la_dinode;\n\titem->lri_slot = slot_num;\n\titem->lri_tl_dinode = tl_dinode;\n\titem->lri_qrec = qrec;\n\titem->lri_orphan_reco_type = orphan_reco_type;\n\n\tspin_lock(&journal->j_lock);\n\tlist_add_tail(&item->lri_list, &journal->j_la_cleanups);\n\tqueue_work(ocfs2_wq, &journal->j_recovery_work);\n\tspin_unlock(&journal->j_lock);\n}"
  },
  {
    "function_name": "ocfs2_complete_recovery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "1196-1265",
    "snippet": "void ocfs2_complete_recovery(struct work_struct *work)\n{\n\tint ret = 0;\n\tstruct ocfs2_journal *journal =\n\t\tcontainer_of(work, struct ocfs2_journal, j_recovery_work);\n\tstruct ocfs2_super *osb = journal->j_osb;\n\tstruct ocfs2_dinode *la_dinode, *tl_dinode;\n\tstruct ocfs2_la_recovery_item *item, *n;\n\tstruct ocfs2_quota_recovery *qrec;\n\tenum ocfs2_orphan_reco_type orphan_reco_type;\n\tLIST_HEAD(tmp_la_list);\n\n\ttrace_ocfs2_complete_recovery(\n\t\t(unsigned long long)OCFS2_I(journal->j_inode)->ip_blkno);\n\n\tspin_lock(&journal->j_lock);\n\tlist_splice_init(&journal->j_la_cleanups, &tmp_la_list);\n\tspin_unlock(&journal->j_lock);\n\n\tlist_for_each_entry_safe(item, n, &tmp_la_list, lri_list) {\n\t\tlist_del_init(&item->lri_list);\n\n\t\tocfs2_wait_on_quotas(osb);\n\n\t\tla_dinode = item->lri_la_dinode;\n\t\ttl_dinode = item->lri_tl_dinode;\n\t\tqrec = item->lri_qrec;\n\t\torphan_reco_type = item->lri_orphan_reco_type;\n\n\t\ttrace_ocfs2_complete_recovery_slot(item->lri_slot,\n\t\t\tla_dinode ? le64_to_cpu(la_dinode->i_blkno) : 0,\n\t\t\ttl_dinode ? le64_to_cpu(tl_dinode->i_blkno) : 0,\n\t\t\tqrec);\n\n\t\tif (la_dinode) {\n\t\t\tret = ocfs2_complete_local_alloc_recovery(osb,\n\t\t\t\t\t\t\t\t  la_dinode);\n\t\t\tif (ret < 0)\n\t\t\t\tmlog_errno(ret);\n\n\t\t\tkfree(la_dinode);\n\t\t}\n\n\t\tif (tl_dinode) {\n\t\t\tret = ocfs2_complete_truncate_log_recovery(osb,\n\t\t\t\t\t\t\t\t   tl_dinode);\n\t\t\tif (ret < 0)\n\t\t\t\tmlog_errno(ret);\n\n\t\t\tkfree(tl_dinode);\n\t\t}\n\n\t\tret = ocfs2_recover_orphans(osb, item->lri_slot,\n\t\t\t\torphan_reco_type);\n\t\tif (ret < 0)\n\t\t\tmlog_errno(ret);\n\n\t\tif (qrec) {\n\t\t\tret = ocfs2_finish_quota_recovery(osb, qrec,\n\t\t\t\t\t\t\t  item->lri_slot);\n\t\t\tif (ret < 0)\n\t\t\t\tmlog_errno(ret);\n\t\t\t/* Recovery info is already freed now */\n\t\t}\n\n\t\tkfree(item);\n\t}\n\n\ttrace_ocfs2_complete_recovery_end(ret);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_commit_cache(struct ocfs2_super *osb);",
      "static int ocfs2_recover_orphans(struct ocfs2_super *osb,\n\t\t\t\t int slot,\n\t\t\t\t enum ocfs2_orphan_reco_type orphan_reco_type);",
      "static void ocfs2_queue_recovery_completion(struct ocfs2_journal *journal,\n\t\t\t\t\t    int slot_num,\n\t\t\t\t\t    struct ocfs2_dinode *la_dinode,\n\t\t\t\t\t    struct ocfs2_dinode *tl_dinode,\n\t\t\t\t\t    struct ocfs2_quota_recovery *qrec,\n\t\t\t\t\t    enum ocfs2_orphan_reco_type orphan_reco_type);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_ocfs2_complete_recovery_end",
          "args": [
            "ret"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "item"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_finish_quota_recovery",
          "args": [
            "osb",
            "qrec",
            "item->lri_slot"
          ],
          "line": 1254
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_finish_quota_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_local.c",
          "lines": "583-681",
          "snippet": "int ocfs2_finish_quota_recovery(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_quota_recovery *rec,\n\t\t\t\tint slot_num)\n{\n\tunsigned int ino[OCFS2_MAXQUOTAS] = { LOCAL_USER_QUOTA_SYSTEM_INODE,\n\t\t\t\t\t      LOCAL_GROUP_QUOTA_SYSTEM_INODE };\n\tstruct super_block *sb = osb->sb;\n\tstruct ocfs2_local_disk_dqinfo *ldinfo;\n\tstruct buffer_head *bh;\n\thandle_t *handle;\n\tint type;\n\tint status = 0;\n\tstruct inode *lqinode;\n\tunsigned int flags;\n\n\tprintk(KERN_NOTICE \"ocfs2: Finishing quota recovery on device (%s) for \"\n\t       \"slot %u\\n\", osb->dev_str, slot_num);\n\n\tmutex_lock(&sb_dqopt(sb)->dqonoff_mutex);\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++) {\n\t\tif (list_empty(&(rec->r_list[type])))\n\t\t\tcontinue;\n\t\ttrace_ocfs2_finish_quota_recovery(slot_num);\n\t\tlqinode = ocfs2_get_system_file_inode(osb, ino[type], slot_num);\n\t\tif (!lqinode) {\n\t\t\tstatus = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tstatus = ocfs2_inode_lock_full(lqinode, NULL, 1,\n\t\t\t\t\t\t       OCFS2_META_LOCK_NOQUEUE);\n\t\t/* Someone else is holding the lock? Then he must be\n\t\t * doing the recovery. Just skip the file... */\n\t\tif (status == -EAGAIN) {\n\t\t\tprintk(KERN_NOTICE \"ocfs2: Skipping quota recovery on \"\n\t\t\t       \"device (%s) for slot %d because quota file is \"\n\t\t\t       \"locked.\\n\", osb->dev_str, slot_num);\n\t\t\tstatus = 0;\n\t\t\tgoto out_put;\n\t\t} else if (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto out_put;\n\t\t}\n\t\t/* Now read local header */\n\t\tbh = NULL;\n\t\tstatus = ocfs2_read_quota_block(lqinode, 0, &bh);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tmlog(ML_ERROR, \"failed to read quota file info header \"\n\t\t\t\t\"(slot=%d type=%d)\\n\", slot_num, type);\n\t\t\tgoto out_lock;\n\t\t}\n\t\tldinfo = (struct ocfs2_local_disk_dqinfo *)(bh->b_data +\n\t\t\t\t\t\t\tOCFS2_LOCAL_INFO_OFF);\n\t\t/* Is recovery still needed? */\n\t\tflags = le32_to_cpu(ldinfo->dqi_flags);\n\t\tif (!(flags & OLQF_CLEAN))\n\t\t\tstatus = ocfs2_recover_local_quota_file(lqinode,\n\t\t\t\t\t\t\t\ttype,\n\t\t\t\t\t\t\t\trec);\n\t\t/* We don't want to mark file as clean when it is actually\n\t\t * active */\n\t\tif (slot_num == osb->slot_num)\n\t\t\tgoto out_bh;\n\t\t/* Mark quota file as clean if we are recovering quota file of\n\t\t * some other node. */\n\t\thandle = ocfs2_start_trans(osb,\n\t\t\t\t\t   OCFS2_LOCAL_QINFO_WRITE_CREDITS);\n\t\tif (IS_ERR(handle)) {\n\t\t\tstatus = PTR_ERR(handle);\n\t\t\tmlog_errno(status);\n\t\t\tgoto out_bh;\n\t\t}\n\t\tstatus = ocfs2_journal_access_dq(handle, INODE_CACHE(lqinode),\n\t\t\t\t\t\t bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto out_trans;\n\t\t}\n\t\tlock_buffer(bh);\n\t\tldinfo->dqi_flags = cpu_to_le32(flags | OLQF_CLEAN);\n\t\tunlock_buffer(bh);\n\t\tocfs2_journal_dirty(handle, bh);\nout_trans:\n\t\tocfs2_commit_trans(osb, handle);\nout_bh:\n\t\tbrelse(bh);\nout_lock:\n\t\tocfs2_inode_unlock(lqinode, 1);\nout_put:\n\t\tiput(lqinode);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t}\nout:\n\tmutex_unlock(&sb_dqopt(sb)->dqonoff_mutex);\n\tkfree(rec);\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"quota.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"file.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/module.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"quota.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"buffer_head_io.h\"\n#include \"file.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/module.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint ocfs2_finish_quota_recovery(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_quota_recovery *rec,\n\t\t\t\tint slot_num)\n{\n\tunsigned int ino[OCFS2_MAXQUOTAS] = { LOCAL_USER_QUOTA_SYSTEM_INODE,\n\t\t\t\t\t      LOCAL_GROUP_QUOTA_SYSTEM_INODE };\n\tstruct super_block *sb = osb->sb;\n\tstruct ocfs2_local_disk_dqinfo *ldinfo;\n\tstruct buffer_head *bh;\n\thandle_t *handle;\n\tint type;\n\tint status = 0;\n\tstruct inode *lqinode;\n\tunsigned int flags;\n\n\tprintk(KERN_NOTICE \"ocfs2: Finishing quota recovery on device (%s) for \"\n\t       \"slot %u\\n\", osb->dev_str, slot_num);\n\n\tmutex_lock(&sb_dqopt(sb)->dqonoff_mutex);\n\tfor (type = 0; type < OCFS2_MAXQUOTAS; type++) {\n\t\tif (list_empty(&(rec->r_list[type])))\n\t\t\tcontinue;\n\t\ttrace_ocfs2_finish_quota_recovery(slot_num);\n\t\tlqinode = ocfs2_get_system_file_inode(osb, ino[type], slot_num);\n\t\tif (!lqinode) {\n\t\t\tstatus = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tstatus = ocfs2_inode_lock_full(lqinode, NULL, 1,\n\t\t\t\t\t\t       OCFS2_META_LOCK_NOQUEUE);\n\t\t/* Someone else is holding the lock? Then he must be\n\t\t * doing the recovery. Just skip the file... */\n\t\tif (status == -EAGAIN) {\n\t\t\tprintk(KERN_NOTICE \"ocfs2: Skipping quota recovery on \"\n\t\t\t       \"device (%s) for slot %d because quota file is \"\n\t\t\t       \"locked.\\n\", osb->dev_str, slot_num);\n\t\t\tstatus = 0;\n\t\t\tgoto out_put;\n\t\t} else if (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto out_put;\n\t\t}\n\t\t/* Now read local header */\n\t\tbh = NULL;\n\t\tstatus = ocfs2_read_quota_block(lqinode, 0, &bh);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tmlog(ML_ERROR, \"failed to read quota file info header \"\n\t\t\t\t\"(slot=%d type=%d)\\n\", slot_num, type);\n\t\t\tgoto out_lock;\n\t\t}\n\t\tldinfo = (struct ocfs2_local_disk_dqinfo *)(bh->b_data +\n\t\t\t\t\t\t\tOCFS2_LOCAL_INFO_OFF);\n\t\t/* Is recovery still needed? */\n\t\tflags = le32_to_cpu(ldinfo->dqi_flags);\n\t\tif (!(flags & OLQF_CLEAN))\n\t\t\tstatus = ocfs2_recover_local_quota_file(lqinode,\n\t\t\t\t\t\t\t\ttype,\n\t\t\t\t\t\t\t\trec);\n\t\t/* We don't want to mark file as clean when it is actually\n\t\t * active */\n\t\tif (slot_num == osb->slot_num)\n\t\t\tgoto out_bh;\n\t\t/* Mark quota file as clean if we are recovering quota file of\n\t\t * some other node. */\n\t\thandle = ocfs2_start_trans(osb,\n\t\t\t\t\t   OCFS2_LOCAL_QINFO_WRITE_CREDITS);\n\t\tif (IS_ERR(handle)) {\n\t\t\tstatus = PTR_ERR(handle);\n\t\t\tmlog_errno(status);\n\t\t\tgoto out_bh;\n\t\t}\n\t\tstatus = ocfs2_journal_access_dq(handle, INODE_CACHE(lqinode),\n\t\t\t\t\t\t bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto out_trans;\n\t\t}\n\t\tlock_buffer(bh);\n\t\tldinfo->dqi_flags = cpu_to_le32(flags | OLQF_CLEAN);\n\t\tunlock_buffer(bh);\n\t\tocfs2_journal_dirty(handle, bh);\nout_trans:\n\t\tocfs2_commit_trans(osb, handle);\nout_bh:\n\t\tbrelse(bh);\nout_lock:\n\t\tocfs2_inode_unlock(lqinode, 1);\nout_put:\n\t\tiput(lqinode);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t}\nout:\n\tmutex_unlock(&sb_dqopt(sb)->dqonoff_mutex);\n\tkfree(rec);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_recover_orphans",
          "args": [
            "osb",
            "item->lri_slot",
            "orphan_reco_type"
          ],
          "line": 1248
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_recover_orphans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "2132-2218",
          "snippet": "static int ocfs2_recover_orphans(struct ocfs2_super *osb,\n\t\t\t\t int slot,\n\t\t\t\t enum ocfs2_orphan_reco_type orphan_reco_type)\n{\n\tint ret = 0;\n\tstruct inode *inode = NULL;\n\tstruct inode *iter;\n\tstruct ocfs2_inode_info *oi;\n\n\ttrace_ocfs2_recover_orphans(slot);\n\n\tocfs2_mark_recovering_orphan_dir(osb, slot);\n\tret = ocfs2_queue_orphans(osb, slot, &inode);\n\tocfs2_clear_recovering_orphan_dir(osb, slot);\n\n\t/* Error here should be noted, but we want to continue with as\n\t * many queued inodes as we've got. */\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\twhile (inode) {\n\t\toi = OCFS2_I(inode);\n\t\ttrace_ocfs2_recover_orphans_iput(\n\t\t\t\t\t(unsigned long long)oi->ip_blkno);\n\n\t\titer = oi->ip_next_orphan;\n\t\toi->ip_next_orphan = NULL;\n\n\t\t/*\n\t\t * We need to take and drop the inode lock to\n\t\t * force read inode from disk.\n\t\t */\n\t\tret = ocfs2_inode_lock(inode, NULL, 0);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto next;\n\t\t}\n\t\tocfs2_inode_unlock(inode, 0);\n\n\t\tif (inode->i_nlink == 0) {\n\t\t\tspin_lock(&oi->ip_lock);\n\t\t\t/* Set the proper information to get us going into\n\t\t\t * ocfs2_delete_inode. */\n\t\t\toi->ip_flags |= OCFS2_INODE_MAYBE_ORPHANED;\n\t\t\tspin_unlock(&oi->ip_lock);\n\t\t} else if (orphan_reco_type == ORPHAN_NEED_TRUNCATE) {\n\t\t\tstruct buffer_head *di_bh = NULL;\n\n\t\t\tret = ocfs2_rw_lock(inode, 1);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\t\t\tif (ret < 0) {\n\t\t\t\tocfs2_rw_unlock(inode, 1);\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tret = ocfs2_truncate_file(inode, di_bh,\n\t\t\t\t\ti_size_read(inode));\n\t\t\tocfs2_inode_unlock(inode, 1);\n\t\t\tocfs2_rw_unlock(inode, 1);\n\t\t\tbrelse(di_bh);\n\t\t\tif (ret < 0) {\n\t\t\t\tif (ret != -ENOSPC)\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tret = ocfs2_del_inode_from_orphan(osb, inode, 0, 0);\n\t\t\tif (ret)\n\t\t\t\tmlog_errno(ret);\n\n\t\t\twake_up(&OCFS2_I(inode)->append_dio_wq);\n\t\t} /* else if ORPHAN_NO_NEED_TRUNCATE, do nothing */\n\nnext:\n\t\tiput(inode);\n\n\t\tinode = iter;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_force_read_journal(struct inode *inode);",
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);",
            "static int ocfs2_recover_orphans(struct ocfs2_super *osb,\n\t\t\t\t int slot,\n\t\t\t\t enum ocfs2_orphan_reco_type orphan_reco_type);",
            "static void ocfs2_queue_recovery_completion(struct ocfs2_journal *journal,\n\t\t\t\t\t    int slot_num,\n\t\t\t\t\t    struct ocfs2_dinode *la_dinode,\n\t\t\t\t\t    struct ocfs2_dinode *tl_dinode,\n\t\t\t\t\t    struct ocfs2_quota_recovery *qrec,\n\t\t\t\t\t    enum ocfs2_orphan_reco_type orphan_reco_type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_force_read_journal(struct inode *inode);\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\nstatic int ocfs2_recover_orphans(struct ocfs2_super *osb,\n\t\t\t\t int slot,\n\t\t\t\t enum ocfs2_orphan_reco_type orphan_reco_type);\nstatic void ocfs2_queue_recovery_completion(struct ocfs2_journal *journal,\n\t\t\t\t\t    int slot_num,\n\t\t\t\t\t    struct ocfs2_dinode *la_dinode,\n\t\t\t\t\t    struct ocfs2_dinode *tl_dinode,\n\t\t\t\t\t    struct ocfs2_quota_recovery *qrec,\n\t\t\t\t\t    enum ocfs2_orphan_reco_type orphan_reco_type);\n\nstatic int ocfs2_recover_orphans(struct ocfs2_super *osb,\n\t\t\t\t int slot,\n\t\t\t\t enum ocfs2_orphan_reco_type orphan_reco_type)\n{\n\tint ret = 0;\n\tstruct inode *inode = NULL;\n\tstruct inode *iter;\n\tstruct ocfs2_inode_info *oi;\n\n\ttrace_ocfs2_recover_orphans(slot);\n\n\tocfs2_mark_recovering_orphan_dir(osb, slot);\n\tret = ocfs2_queue_orphans(osb, slot, &inode);\n\tocfs2_clear_recovering_orphan_dir(osb, slot);\n\n\t/* Error here should be noted, but we want to continue with as\n\t * many queued inodes as we've got. */\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\twhile (inode) {\n\t\toi = OCFS2_I(inode);\n\t\ttrace_ocfs2_recover_orphans_iput(\n\t\t\t\t\t(unsigned long long)oi->ip_blkno);\n\n\t\titer = oi->ip_next_orphan;\n\t\toi->ip_next_orphan = NULL;\n\n\t\t/*\n\t\t * We need to take and drop the inode lock to\n\t\t * force read inode from disk.\n\t\t */\n\t\tret = ocfs2_inode_lock(inode, NULL, 0);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto next;\n\t\t}\n\t\tocfs2_inode_unlock(inode, 0);\n\n\t\tif (inode->i_nlink == 0) {\n\t\t\tspin_lock(&oi->ip_lock);\n\t\t\t/* Set the proper information to get us going into\n\t\t\t * ocfs2_delete_inode. */\n\t\t\toi->ip_flags |= OCFS2_INODE_MAYBE_ORPHANED;\n\t\t\tspin_unlock(&oi->ip_lock);\n\t\t} else if (orphan_reco_type == ORPHAN_NEED_TRUNCATE) {\n\t\t\tstruct buffer_head *di_bh = NULL;\n\n\t\t\tret = ocfs2_rw_lock(inode, 1);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\t\t\tif (ret < 0) {\n\t\t\t\tocfs2_rw_unlock(inode, 1);\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tret = ocfs2_truncate_file(inode, di_bh,\n\t\t\t\t\ti_size_read(inode));\n\t\t\tocfs2_inode_unlock(inode, 1);\n\t\t\tocfs2_rw_unlock(inode, 1);\n\t\t\tbrelse(di_bh);\n\t\t\tif (ret < 0) {\n\t\t\t\tif (ret != -ENOSPC)\n\t\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tret = ocfs2_del_inode_from_orphan(osb, inode, 0, 0);\n\t\t\tif (ret)\n\t\t\t\tmlog_errno(ret);\n\n\t\t\twake_up(&OCFS2_I(inode)->append_dio_wq);\n\t\t} /* else if ORPHAN_NO_NEED_TRUNCATE, do nothing */\n\nnext:\n\t\tiput(inode);\n\n\t\tinode = iter;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tl_dinode"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_complete_truncate_log_recovery",
          "args": [
            "osb",
            "tl_dinode"
          ],
          "line": 1240
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_complete_truncate_log_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6175-6231",
          "snippet": "int ocfs2_complete_truncate_log_recovery(struct ocfs2_super *osb,\n\t\t\t\t\t struct ocfs2_dinode *tl_copy)\n{\n\tint status = 0;\n\tint i;\n\tunsigned int clusters, num_recs, start_cluster;\n\tu64 start_blk;\n\thandle_t *handle;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct ocfs2_truncate_log *tl;\n\n\tif (OCFS2_I(tl_inode)->ip_blkno == le64_to_cpu(tl_copy->i_blkno)) {\n\t\tmlog(ML_ERROR, \"Asked to recover my own truncate log!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttl = &tl_copy->id2.i_dealloc;\n\tnum_recs = le16_to_cpu(tl->tl_used);\n\ttrace_ocfs2_complete_truncate_log_recovery(\n\t\t(unsigned long long)le64_to_cpu(tl_copy->i_blkno),\n\t\tnum_recs);\n\n\tmutex_lock(&tl_inode->i_mutex);\n\tfor(i = 0; i < num_recs; i++) {\n\t\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\t\tstatus = __ocfs2_flush_truncate_log(osb);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail_up;\n\t\t\t}\n\t\t}\n\n\t\thandle = ocfs2_start_trans(osb, OCFS2_TRUNCATE_LOG_UPDATE);\n\t\tif (IS_ERR(handle)) {\n\t\t\tstatus = PTR_ERR(handle);\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail_up;\n\t\t}\n\n\t\tclusters = le32_to_cpu(tl->tl_recs[i].t_clusters);\n\t\tstart_cluster = le32_to_cpu(tl->tl_recs[i].t_start);\n\t\tstart_blk = ocfs2_clusters_to_blocks(osb->sb, start_cluster);\n\n\t\tstatus = ocfs2_truncate_log_append(osb, handle,\n\t\t\t\t\t\t   start_blk, clusters);\n\t\tocfs2_commit_trans(osb, handle);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail_up;\n\t\t}\n\t}\n\nbail_up:\n\tmutex_unlock(&tl_inode->i_mutex);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
            "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\n\nint ocfs2_complete_truncate_log_recovery(struct ocfs2_super *osb,\n\t\t\t\t\t struct ocfs2_dinode *tl_copy)\n{\n\tint status = 0;\n\tint i;\n\tunsigned int clusters, num_recs, start_cluster;\n\tu64 start_blk;\n\thandle_t *handle;\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\tstruct ocfs2_truncate_log *tl;\n\n\tif (OCFS2_I(tl_inode)->ip_blkno == le64_to_cpu(tl_copy->i_blkno)) {\n\t\tmlog(ML_ERROR, \"Asked to recover my own truncate log!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttl = &tl_copy->id2.i_dealloc;\n\tnum_recs = le16_to_cpu(tl->tl_used);\n\ttrace_ocfs2_complete_truncate_log_recovery(\n\t\t(unsigned long long)le64_to_cpu(tl_copy->i_blkno),\n\t\tnum_recs);\n\n\tmutex_lock(&tl_inode->i_mutex);\n\tfor(i = 0; i < num_recs; i++) {\n\t\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\t\tstatus = __ocfs2_flush_truncate_log(osb);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail_up;\n\t\t\t}\n\t\t}\n\n\t\thandle = ocfs2_start_trans(osb, OCFS2_TRUNCATE_LOG_UPDATE);\n\t\tif (IS_ERR(handle)) {\n\t\t\tstatus = PTR_ERR(handle);\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail_up;\n\t\t}\n\n\t\tclusters = le32_to_cpu(tl->tl_recs[i].t_clusters);\n\t\tstart_cluster = le32_to_cpu(tl->tl_recs[i].t_start);\n\t\tstart_blk = ocfs2_clusters_to_blocks(osb->sb, start_cluster);\n\n\t\tstatus = ocfs2_truncate_log_append(osb, handle,\n\t\t\t\t\t\t   start_blk, clusters);\n\t\tocfs2_commit_trans(osb, handle);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail_up;\n\t\t}\n\t}\n\nbail_up:\n\tmutex_unlock(&tl_inode->i_mutex);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "la_dinode"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_complete_local_alloc_recovery",
          "args": [
            "osb",
            "la_dinode"
          ],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_complete_local_alloc_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/localalloc.c",
          "lines": "559-618",
          "snippet": "int ocfs2_complete_local_alloc_recovery(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_dinode *alloc)\n{\n\tint status;\n\thandle_t *handle;\n\tstruct buffer_head *main_bm_bh = NULL;\n\tstruct inode *main_bm_inode;\n\n\tmain_bm_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t    GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t    OCFS2_INVALID_SLOT);\n\tif (!main_bm_inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&main_bm_inode->i_mutex);\n\n\tstatus = ocfs2_inode_lock(main_bm_inode, &main_bm_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_mutex;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_WINDOW_MOVE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto out_unlock;\n\t}\n\n\t/* we want the bitmap change to be recorded on disk asap */\n\thandle->h_sync = 1;\n\n\tstatus = ocfs2_sync_local_to_main(osb, handle, alloc,\n\t\t\t\t\t  main_bm_inode, main_bm_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tocfs2_commit_trans(osb, handle);\n\nout_unlock:\n\tocfs2_inode_unlock(main_bm_inode, 1);\n\nout_mutex:\n\tmutex_unlock(&main_bm_inode->i_mutex);\n\n\tbrelse(main_bm_bh);\n\n\tiput(main_bm_inode);\n\nout:\n\tif (!status)\n\t\tocfs2_init_steal_slots(osb);\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);",
            "static void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);",
            "static int ocfs2_sync_local_to_main(struct ocfs2_super *osb,\n\t\t\t\t    handle_t *handle,\n\t\t\t\t    struct ocfs2_dinode *alloc,\n\t\t\t\t    struct inode *main_bm_inode,\n\t\t\t\t    struct buffer_head *main_bm_bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u32 ocfs2_local_alloc_count_bits(struct ocfs2_dinode *alloc);\nstatic void ocfs2_clear_local_alloc(struct ocfs2_dinode *alloc);\nstatic int ocfs2_sync_local_to_main(struct ocfs2_super *osb,\n\t\t\t\t    handle_t *handle,\n\t\t\t\t    struct ocfs2_dinode *alloc,\n\t\t\t\t    struct inode *main_bm_inode,\n\t\t\t\t    struct buffer_head *main_bm_bh);\n\nint ocfs2_complete_local_alloc_recovery(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_dinode *alloc)\n{\n\tint status;\n\thandle_t *handle;\n\tstruct buffer_head *main_bm_bh = NULL;\n\tstruct inode *main_bm_inode;\n\n\tmain_bm_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t    GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t    OCFS2_INVALID_SLOT);\n\tif (!main_bm_inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&main_bm_inode->i_mutex);\n\n\tstatus = ocfs2_inode_lock(main_bm_inode, &main_bm_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_mutex;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_WINDOW_MOVE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto out_unlock;\n\t}\n\n\t/* we want the bitmap change to be recorded on disk asap */\n\thandle->h_sync = 1;\n\n\tstatus = ocfs2_sync_local_to_main(osb, handle, alloc,\n\t\t\t\t\t  main_bm_inode, main_bm_bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tocfs2_commit_trans(osb, handle);\n\nout_unlock:\n\tocfs2_inode_unlock(main_bm_inode, 1);\n\nout_mutex:\n\tmutex_unlock(&main_bm_inode->i_mutex);\n\n\tbrelse(main_bm_bh);\n\n\tiput(main_bm_inode);\n\nout:\n\tif (!status)\n\t\tocfs2_init_steal_slots(osb);\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_complete_recovery_slot",
          "args": [
            "item->lri_slot",
            "la_dinode ? le64_to_cpu(la_dinode->i_blkno) : 0",
            "tl_dinode ? le64_to_cpu(tl_dinode->i_blkno) : 0",
            "qrec"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "tl_dinode->i_blkno"
          ],
          "line": 1227
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_wait_on_quotas",
          "args": [
            "osb"
          ],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_wait_on_quotas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "89-92",
          "snippet": "static inline int ocfs2_wait_on_quotas(struct ocfs2_super *osb)\n{\n\treturn __ocfs2_wait_on_mount(osb, 1);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nstatic inline int ocfs2_wait_on_quotas(struct ocfs2_super *osb)\n{\n\treturn __ocfs2_wait_on_mount(osb, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&item->lri_list"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "item",
            "n",
            "&tmp_la_list",
            "lri_list"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_lock"
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_splice_init",
          "args": [
            "&journal->j_la_cleanups",
            "&tmp_la_list"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_lock"
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_complete_recovery",
          "args": [
            "(unsigned long long)OCFS2_I(journal->j_inode)->ip_blkno"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "journal->j_inode"
          ],
          "line": 1209
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "tmp_la_list"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structocfs2_journal",
            "j_recovery_work"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\nstatic int ocfs2_recover_orphans(struct ocfs2_super *osb,\n\t\t\t\t int slot,\n\t\t\t\t enum ocfs2_orphan_reco_type orphan_reco_type);\nstatic void ocfs2_queue_recovery_completion(struct ocfs2_journal *journal,\n\t\t\t\t\t    int slot_num,\n\t\t\t\t\t    struct ocfs2_dinode *la_dinode,\n\t\t\t\t\t    struct ocfs2_dinode *tl_dinode,\n\t\t\t\t\t    struct ocfs2_quota_recovery *qrec,\n\t\t\t\t\t    enum ocfs2_orphan_reco_type orphan_reco_type);\n\nvoid ocfs2_complete_recovery(struct work_struct *work)\n{\n\tint ret = 0;\n\tstruct ocfs2_journal *journal =\n\t\tcontainer_of(work, struct ocfs2_journal, j_recovery_work);\n\tstruct ocfs2_super *osb = journal->j_osb;\n\tstruct ocfs2_dinode *la_dinode, *tl_dinode;\n\tstruct ocfs2_la_recovery_item *item, *n;\n\tstruct ocfs2_quota_recovery *qrec;\n\tenum ocfs2_orphan_reco_type orphan_reco_type;\n\tLIST_HEAD(tmp_la_list);\n\n\ttrace_ocfs2_complete_recovery(\n\t\t(unsigned long long)OCFS2_I(journal->j_inode)->ip_blkno);\n\n\tspin_lock(&journal->j_lock);\n\tlist_splice_init(&journal->j_la_cleanups, &tmp_la_list);\n\tspin_unlock(&journal->j_lock);\n\n\tlist_for_each_entry_safe(item, n, &tmp_la_list, lri_list) {\n\t\tlist_del_init(&item->lri_list);\n\n\t\tocfs2_wait_on_quotas(osb);\n\n\t\tla_dinode = item->lri_la_dinode;\n\t\ttl_dinode = item->lri_tl_dinode;\n\t\tqrec = item->lri_qrec;\n\t\torphan_reco_type = item->lri_orphan_reco_type;\n\n\t\ttrace_ocfs2_complete_recovery_slot(item->lri_slot,\n\t\t\tla_dinode ? le64_to_cpu(la_dinode->i_blkno) : 0,\n\t\t\ttl_dinode ? le64_to_cpu(tl_dinode->i_blkno) : 0,\n\t\t\tqrec);\n\n\t\tif (la_dinode) {\n\t\t\tret = ocfs2_complete_local_alloc_recovery(osb,\n\t\t\t\t\t\t\t\t  la_dinode);\n\t\t\tif (ret < 0)\n\t\t\t\tmlog_errno(ret);\n\n\t\t\tkfree(la_dinode);\n\t\t}\n\n\t\tif (tl_dinode) {\n\t\t\tret = ocfs2_complete_truncate_log_recovery(osb,\n\t\t\t\t\t\t\t\t   tl_dinode);\n\t\t\tif (ret < 0)\n\t\t\t\tmlog_errno(ret);\n\n\t\t\tkfree(tl_dinode);\n\t\t}\n\n\t\tret = ocfs2_recover_orphans(osb, item->lri_slot,\n\t\t\t\torphan_reco_type);\n\t\tif (ret < 0)\n\t\t\tmlog_errno(ret);\n\n\t\tif (qrec) {\n\t\t\tret = ocfs2_finish_quota_recovery(osb, qrec,\n\t\t\t\t\t\t\t  item->lri_slot);\n\t\t\tif (ret < 0)\n\t\t\t\tmlog_errno(ret);\n\t\t\t/* Recovery info is already freed now */\n\t\t}\n\n\t\tkfree(item);\n\t}\n\n\ttrace_ocfs2_complete_recovery_end(ret);\n}"
  },
  {
    "function_name": "ocfs2_force_read_journal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "1131-1175",
    "snippet": "static int ocfs2_force_read_journal(struct inode *inode)\n{\n\tint status = 0;\n\tint i;\n\tu64 v_blkno, p_blkno, p_blocks, num_blocks;\n#define CONCURRENT_JOURNAL_FILL 32ULL\n\tstruct buffer_head *bhs[CONCURRENT_JOURNAL_FILL];\n\n\tmemset(bhs, 0, sizeof(struct buffer_head *) * CONCURRENT_JOURNAL_FILL);\n\n\tnum_blocks = ocfs2_blocks_for_bytes(inode->i_sb, i_size_read(inode));\n\tv_blkno = 0;\n\twhile (v_blkno < num_blocks) {\n\t\tstatus = ocfs2_extent_map_get_blocks(inode, v_blkno,\n\t\t\t\t\t\t     &p_blkno, &p_blocks, NULL);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (p_blocks > CONCURRENT_JOURNAL_FILL)\n\t\t\tp_blocks = CONCURRENT_JOURNAL_FILL;\n\n\t\t/* We are reading journal data which should not\n\t\t * be put in the uptodate cache */\n\t\tstatus = ocfs2_read_blocks_sync(OCFS2_SB(inode->i_sb),\n\t\t\t\t\t\tp_blkno, p_blocks, bhs);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tfor(i = 0; i < p_blocks; i++) {\n\t\t\tbrelse(bhs[i]);\n\t\t\tbhs[i] = NULL;\n\t\t}\n\n\t\tv_blkno += p_blocks;\n\t}\n\nbail:\n\tfor(i = 0; i < CONCURRENT_JOURNAL_FILL; i++)\n\t\tbrelse(bhs[i]);\n\treturn status;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define CONCURRENT_JOURNAL_FILL 32ULL"
    ],
    "globals_used": [
      "static int ocfs2_force_read_journal(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bhs[i]"
          ],
          "line": 1173
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_blocks_sync",
          "args": [
            "OCFS2_SB(inode->i_sb)",
            "p_blkno",
            "p_blocks",
            "bhs"
          ],
          "line": 1156
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_blocks_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/buffer_head_io.c",
          "lines": "101-174",
          "snippet": "int ocfs2_read_blocks_sync(struct ocfs2_super *osb, u64 block,\n\t\t\t   unsigned int nr, struct buffer_head *bhs[])\n{\n\tint status = 0;\n\tunsigned int i;\n\tstruct buffer_head *bh;\n\n\ttrace_ocfs2_read_blocks_sync((unsigned long long)block, nr);\n\n\tif (!nr)\n\t\tgoto bail;\n\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\ttrace_ocfs2_read_blocks_sync_jbd(\n\t\t\t\t\t(unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (buffer_dirty(bh)) {\n\t\t\t/* This should probably be a BUG, or\n\t\t\t * at least return an error. */\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"trying to sync read a dirty \"\n\t\t\t     \"buffer! (blocknr = %llu), skipping\\n\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlock_buffer(bh);\n\t\tif (buffer_jbd(bh)) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"block %llu had the JBD bit set \"\n\t\t\t     \"while I was in lock_buffer!\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tBUG();\n\t\t}\n\n\t\tclear_buffer_uptodate(bh);\n\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ, bh);\n\t}\n\n\tfor (i = nr; i > 0; i--) {\n\t\tbh = bhs[i - 1];\n\n\t\t/* No need to wait on the buffer if it's managed by JBD. */\n\t\tif (!buffer_jbd(bh))\n\t\t\twait_on_buffer(bh);\n\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* Status won't be cleared from here on out,\n\t\t\t * so we can safely record this and loop back\n\t\t\t * to cleanup the other buffers. */\n\t\t\tstatus = -EIO;\n\t\t\tput_bh(bh);\n\t\t\tbhs[i - 1] = NULL;\n\t\t}\n\t}\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_blocks_sync(struct ocfs2_super *osb, u64 block,\n\t\t\t   unsigned int nr, struct buffer_head *bhs[])\n{\n\tint status = 0;\n\tunsigned int i;\n\tstruct buffer_head *bh;\n\n\ttrace_ocfs2_read_blocks_sync((unsigned long long)block, nr);\n\n\tif (!nr)\n\t\tgoto bail;\n\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\ttrace_ocfs2_read_blocks_sync_jbd(\n\t\t\t\t\t(unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (buffer_dirty(bh)) {\n\t\t\t/* This should probably be a BUG, or\n\t\t\t * at least return an error. */\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"trying to sync read a dirty \"\n\t\t\t     \"buffer! (blocknr = %llu), skipping\\n\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlock_buffer(bh);\n\t\tif (buffer_jbd(bh)) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"block %llu had the JBD bit set \"\n\t\t\t     \"while I was in lock_buffer!\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tBUG();\n\t\t}\n\n\t\tclear_buffer_uptodate(bh);\n\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ, bh);\n\t}\n\n\tfor (i = nr; i > 0; i--) {\n\t\tbh = bhs[i - 1];\n\n\t\t/* No need to wait on the buffer if it's managed by JBD. */\n\t\tif (!buffer_jbd(bh))\n\t\t\twait_on_buffer(bh);\n\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* Status won't be cleared from here on out,\n\t\t\t * so we can safely record this and loop back\n\t\t\t * to cleanup the other buffers. */\n\t\t\tstatus = -EIO;\n\t\t\tput_bh(bh);\n\t\t\tbhs[i - 1] = NULL;\n\t\t}\n\t}\n\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extent_map_get_blocks",
          "args": [
            "inode",
            "v_blkno",
            "&p_blkno",
            "&p_blocks",
            "NULL"
          ],
          "line": 1144
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extent_map_get_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "671-705",
          "snippet": "int ocfs2_extent_map_get_blocks(struct inode *inode, u64 v_blkno, u64 *p_blkno,\n\t\t\t\tu64 *ret_count, unsigned int *extent_flags)\n{\n\tint ret;\n\tint bpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\tu32 cpos, num_clusters, p_cluster;\n\tu64 boff = 0;\n\n\tcpos = ocfs2_blocks_to_clusters(inode->i_sb, v_blkno);\n\n\tret = ocfs2_get_clusters(inode, cpos, &p_cluster, &num_clusters,\n\t\t\t\t extent_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * p_cluster == 0 indicates a hole.\n\t */\n\tif (p_cluster) {\n\t\tboff = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);\n\t\tboff += (v_blkno & (u64)(bpc - 1));\n\t}\n\n\t*p_blkno = boff;\n\n\tif (ret_count) {\n\t\t*ret_count = ocfs2_clusters_to_blocks(inode->i_sb, num_clusters);\n\t\t*ret_count -= v_blkno & (u64)(bpc - 1);\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint ocfs2_extent_map_get_blocks(struct inode *inode, u64 v_blkno, u64 *p_blkno,\n\t\t\t\tu64 *ret_count, unsigned int *extent_flags)\n{\n\tint ret;\n\tint bpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\tu32 cpos, num_clusters, p_cluster;\n\tu64 boff = 0;\n\n\tcpos = ocfs2_blocks_to_clusters(inode->i_sb, v_blkno);\n\n\tret = ocfs2_get_clusters(inode, cpos, &p_cluster, &num_clusters,\n\t\t\t\t extent_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * p_cluster == 0 indicates a hole.\n\t */\n\tif (p_cluster) {\n\t\tboff = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);\n\t\tboff += (v_blkno & (u64)(bpc - 1));\n\t}\n\n\t*p_blkno = boff;\n\n\tif (ret_count) {\n\t\t*ret_count = ocfs2_clusters_to_blocks(inode->i_sb, num_clusters);\n\t\t*ret_count -= v_blkno & (u64)(bpc - 1);\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_blocks_for_bytes",
          "args": [
            "inode->i_sb",
            "i_size_read(inode)"
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blocks_for_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "752-757",
          "snippet": "static inline u64 ocfs2_blocks_for_bytes(struct super_block *sb,\n\t\t\t\t\t u64 bytes)\n{\n\tbytes += sb->s_blocksize - 1;\n\treturn bytes >> sb->s_blocksize_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_blocks_for_bytes(struct super_block *sb,\n\t\t\t\t\t u64 bytes)\n{\n\tbytes += sb->s_blocksize - 1;\n\treturn bytes >> sb->s_blocksize_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bhs",
            "0",
            "sizeof(struct buffer_head *) * CONCURRENT_JOURNAL_FILL"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define CONCURRENT_JOURNAL_FILL 32ULL\n\nstatic int ocfs2_force_read_journal(struct inode *inode);\n\nstatic int ocfs2_force_read_journal(struct inode *inode)\n{\n\tint status = 0;\n\tint i;\n\tu64 v_blkno, p_blkno, p_blocks, num_blocks;\n#define CONCURRENT_JOURNAL_FILL 32ULL\n\tstruct buffer_head *bhs[CONCURRENT_JOURNAL_FILL];\n\n\tmemset(bhs, 0, sizeof(struct buffer_head *) * CONCURRENT_JOURNAL_FILL);\n\n\tnum_blocks = ocfs2_blocks_for_bytes(inode->i_sb, i_size_read(inode));\n\tv_blkno = 0;\n\twhile (v_blkno < num_blocks) {\n\t\tstatus = ocfs2_extent_map_get_blocks(inode, v_blkno,\n\t\t\t\t\t\t     &p_blkno, &p_blocks, NULL);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (p_blocks > CONCURRENT_JOURNAL_FILL)\n\t\t\tp_blocks = CONCURRENT_JOURNAL_FILL;\n\n\t\t/* We are reading journal data which should not\n\t\t * be put in the uptodate cache */\n\t\tstatus = ocfs2_read_blocks_sync(OCFS2_SB(inode->i_sb),\n\t\t\t\t\t\tp_blkno, p_blocks, bhs);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tfor(i = 0; i < p_blocks; i++) {\n\t\t\tbrelse(bhs[i]);\n\t\t\tbhs[i] = NULL;\n\t\t}\n\n\t\tv_blkno += p_blocks;\n\t}\n\nbail:\n\tfor(i = 0; i < CONCURRENT_JOURNAL_FILL; i++)\n\t\tbrelse(bhs[i]);\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_wait_for_recovery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "1116-1119",
    "snippet": "void ocfs2_wait_for_recovery(struct ocfs2_super *osb)\n{\n\twait_event(osb->recovery_event, ocfs2_recovery_completed(osb));\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "osb->recovery_event",
            "ocfs2_recovery_completed(osb)"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_recovery_completed",
          "args": [
            "osb"
          ],
          "line": 1118
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_recovery_completed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "1104-1114",
          "snippet": "static int ocfs2_recovery_completed(struct ocfs2_super *osb)\n{\n\tint empty;\n\tstruct ocfs2_recovery_map *rm = osb->recovery_map;\n\n\tspin_lock(&osb->osb_lock);\n\tempty = (rm->rm_used == 0);\n\tspin_unlock(&osb->osb_lock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nstatic int ocfs2_recovery_completed(struct ocfs2_super *osb)\n{\n\tint empty;\n\tstruct ocfs2_recovery_map *rm = osb->recovery_map;\n\n\tspin_lock(&osb->osb_lock);\n\tempty = (rm->rm_used == 0);\n\tspin_unlock(&osb->osb_lock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nvoid ocfs2_wait_for_recovery(struct ocfs2_super *osb)\n{\n\twait_event(osb->recovery_event, ocfs2_recovery_completed(osb));\n}"
  },
  {
    "function_name": "ocfs2_recovery_completed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "1104-1114",
    "snippet": "static int ocfs2_recovery_completed(struct ocfs2_super *osb)\n{\n\tint empty;\n\tstruct ocfs2_recovery_map *rm = osb->recovery_map;\n\n\tspin_lock(&osb->osb_lock);\n\tempty = (rm->rm_used == 0);\n\tspin_unlock(&osb->osb_lock);\n\n\treturn empty;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 1109
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nstatic int ocfs2_recovery_completed(struct ocfs2_super *osb)\n{\n\tint empty;\n\tstruct ocfs2_recovery_map *rm = osb->recovery_map;\n\n\tspin_lock(&osb->osb_lock);\n\tempty = (rm->rm_used == 0);\n\tspin_unlock(&osb->osb_lock);\n\n\treturn empty;\n}"
  },
  {
    "function_name": "ocfs2_journal_wipe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "1084-1102",
    "snippet": "int ocfs2_journal_wipe(struct ocfs2_journal *journal, int full)\n{\n\tint status;\n\n\tBUG_ON(!journal);\n\n\tstatus = jbd2_journal_wipe(journal->j_journal, full);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_journal_toggle_dirty(journal->j_osb, 0, 0);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nbail:\n\treturn status;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_toggle_dirty",
          "args": [
            "journal->j_osb",
            "0",
            "0"
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_toggle_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "903-935",
          "snippet": "static int ocfs2_journal_toggle_dirty(struct ocfs2_super *osb,\n\t\t\t\t      int dirty, int replayed)\n{\n\tint status;\n\tunsigned int flags;\n\tstruct ocfs2_journal *journal = osb->journal;\n\tstruct buffer_head *bh = journal->j_bh;\n\tstruct ocfs2_dinode *fe;\n\n\tfe = (struct ocfs2_dinode *)bh->b_data;\n\n\t/* The journal bh on the osb always comes from ocfs2_journal_init()\n\t * and was validated there inside ocfs2_inode_lock_full().  It's a\n\t * code bug if we mess it up. */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(fe));\n\n\tflags = le32_to_cpu(fe->id1.journal1.ij_flags);\n\tif (dirty)\n\t\tflags |= OCFS2_JOURNAL_DIRTY_FL;\n\telse\n\t\tflags &= ~OCFS2_JOURNAL_DIRTY_FL;\n\tfe->id1.journal1.ij_flags = cpu_to_le32(flags);\n\n\tif (replayed)\n\t\tocfs2_bump_recovery_generation(fe);\n\n\tocfs2_compute_meta_ecc(osb->sb, bh->b_data, &fe->i_check);\n\tstatus = ocfs2_write_block(osb, bh, INODE_CACHE(journal->j_inode));\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);",
            "static int ocfs2_journal_toggle_dirty(struct ocfs2_super *osb,\n\t\t\t\t      int dirty, int replayed);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\nstatic int ocfs2_journal_toggle_dirty(struct ocfs2_super *osb,\n\t\t\t\t      int dirty, int replayed);\n\nstatic int ocfs2_journal_toggle_dirty(struct ocfs2_super *osb,\n\t\t\t\t      int dirty, int replayed)\n{\n\tint status;\n\tunsigned int flags;\n\tstruct ocfs2_journal *journal = osb->journal;\n\tstruct buffer_head *bh = journal->j_bh;\n\tstruct ocfs2_dinode *fe;\n\n\tfe = (struct ocfs2_dinode *)bh->b_data;\n\n\t/* The journal bh on the osb always comes from ocfs2_journal_init()\n\t * and was validated there inside ocfs2_inode_lock_full().  It's a\n\t * code bug if we mess it up. */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(fe));\n\n\tflags = le32_to_cpu(fe->id1.journal1.ij_flags);\n\tif (dirty)\n\t\tflags |= OCFS2_JOURNAL_DIRTY_FL;\n\telse\n\t\tflags &= ~OCFS2_JOURNAL_DIRTY_FL;\n\tfe->id1.journal1.ij_flags = cpu_to_le32(flags);\n\n\tif (replayed)\n\t\tocfs2_bump_recovery_generation(fe);\n\n\tocfs2_compute_meta_ecc(osb->sb, bh->b_data, &fe->i_check);\n\tstatus = ocfs2_write_block(osb, bh, INODE_CACHE(journal->j_inode));\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_wipe",
          "args": [
            "journal->j_journal",
            "full"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_wipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1985-2011",
          "snippet": "int jbd2_journal_wipe(journal_t *journal, int write)\n{\n\tint err = 0;\n\n\tJ_ASSERT (!(journal->j_flags & JBD2_LOADED));\n\n\terr = load_superblock(journal);\n\tif (err)\n\t\treturn err;\n\n\tif (!journal->j_tail)\n\t\tgoto no_recovery;\n\n\tprintk(KERN_WARNING \"JBD2: %s recovery information on journal\\n\",\n\t\twrite ? \"Clearing\" : \"Ignoring\");\n\n\terr = jbd2_journal_skip_recovery(journal);\n\tif (write) {\n\t\t/* Lock to make assertions happy... */\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\tjbd2_mark_journal_empty(journal);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t}\n\n no_recovery:\n\treturn err;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_wipe(journal_t *journal, int write)\n{\n\tint err = 0;\n\n\tJ_ASSERT (!(journal->j_flags & JBD2_LOADED));\n\n\terr = load_superblock(journal);\n\tif (err)\n\t\treturn err;\n\n\tif (!journal->j_tail)\n\t\tgoto no_recovery;\n\n\tprintk(KERN_WARNING \"JBD2: %s recovery information on journal\\n\",\n\t\twrite ? \"Clearing\" : \"Ignoring\");\n\n\terr = jbd2_journal_skip_recovery(journal);\n\tif (write) {\n\t\t/* Lock to make assertions happy... */\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\tjbd2_mark_journal_empty(journal);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t}\n\n no_recovery:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!journal"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_journal_wipe(struct ocfs2_journal *journal, int full)\n{\n\tint status;\n\n\tBUG_ON(!journal);\n\n\tstatus = jbd2_journal_wipe(journal->j_journal, full);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_journal_toggle_dirty(journal->j_osb, 0, 0);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nbail:\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_journal_load",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "1040-1079",
    "snippet": "int ocfs2_journal_load(struct ocfs2_journal *journal, int local, int replayed)\n{\n\tint status = 0;\n\tstruct ocfs2_super *osb;\n\n\tBUG_ON(!journal);\n\n\tosb = journal->j_osb;\n\n\tstatus = jbd2_journal_load(journal->j_journal);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"Failed to load journal!\\n\");\n\t\tgoto done;\n\t}\n\n\tocfs2_clear_journal_error(osb->sb, journal->j_journal, osb->slot_num);\n\n\tstatus = ocfs2_journal_toggle_dirty(osb, 1, replayed);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto done;\n\t}\n\n\t/* Launch the commit thread */\n\tif (!local) {\n\t\tosb->commit_task = kthread_run(ocfs2_commit_thread, osb,\n\t\t\t\t\t       \"ocfs2cmt\");\n\t\tif (IS_ERR(osb->commit_task)) {\n\t\t\tstatus = PTR_ERR(osb->commit_task);\n\t\t\tosb->commit_task = NULL;\n\t\t\tmlog(ML_ERROR, \"unable to launch ocfs2commit thread, \"\n\t\t\t     \"error=%d\", status);\n\t\t\tgoto done;\n\t\t}\n\t} else\n\t\tosb->commit_task = NULL;\n\ndone:\n\treturn status;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);",
      "static int ocfs2_commit_cache(struct ocfs2_super *osb);",
      "static int ocfs2_journal_toggle_dirty(struct ocfs2_super *osb,\n\t\t\t\t      int dirty, int replayed);",
      "static int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"unable to launch ocfs2commit thread, \"\n\t\t\t     \"error=%d\"",
            "status"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "osb->commit_task"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "osb->commit_task"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "ocfs2_commit_thread",
            "osb",
            "\"ocfs2cmt\""
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_toggle_dirty",
          "args": [
            "osb",
            "1",
            "replayed"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_toggle_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "903-935",
          "snippet": "static int ocfs2_journal_toggle_dirty(struct ocfs2_super *osb,\n\t\t\t\t      int dirty, int replayed)\n{\n\tint status;\n\tunsigned int flags;\n\tstruct ocfs2_journal *journal = osb->journal;\n\tstruct buffer_head *bh = journal->j_bh;\n\tstruct ocfs2_dinode *fe;\n\n\tfe = (struct ocfs2_dinode *)bh->b_data;\n\n\t/* The journal bh on the osb always comes from ocfs2_journal_init()\n\t * and was validated there inside ocfs2_inode_lock_full().  It's a\n\t * code bug if we mess it up. */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(fe));\n\n\tflags = le32_to_cpu(fe->id1.journal1.ij_flags);\n\tif (dirty)\n\t\tflags |= OCFS2_JOURNAL_DIRTY_FL;\n\telse\n\t\tflags &= ~OCFS2_JOURNAL_DIRTY_FL;\n\tfe->id1.journal1.ij_flags = cpu_to_le32(flags);\n\n\tif (replayed)\n\t\tocfs2_bump_recovery_generation(fe);\n\n\tocfs2_compute_meta_ecc(osb->sb, bh->b_data, &fe->i_check);\n\tstatus = ocfs2_write_block(osb, bh, INODE_CACHE(journal->j_inode));\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);",
            "static int ocfs2_journal_toggle_dirty(struct ocfs2_super *osb,\n\t\t\t\t      int dirty, int replayed);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\nstatic int ocfs2_journal_toggle_dirty(struct ocfs2_super *osb,\n\t\t\t\t      int dirty, int replayed);\n\nstatic int ocfs2_journal_toggle_dirty(struct ocfs2_super *osb,\n\t\t\t\t      int dirty, int replayed)\n{\n\tint status;\n\tunsigned int flags;\n\tstruct ocfs2_journal *journal = osb->journal;\n\tstruct buffer_head *bh = journal->j_bh;\n\tstruct ocfs2_dinode *fe;\n\n\tfe = (struct ocfs2_dinode *)bh->b_data;\n\n\t/* The journal bh on the osb always comes from ocfs2_journal_init()\n\t * and was validated there inside ocfs2_inode_lock_full().  It's a\n\t * code bug if we mess it up. */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(fe));\n\n\tflags = le32_to_cpu(fe->id1.journal1.ij_flags);\n\tif (dirty)\n\t\tflags |= OCFS2_JOURNAL_DIRTY_FL;\n\telse\n\t\tflags &= ~OCFS2_JOURNAL_DIRTY_FL;\n\tfe->id1.journal1.ij_flags = cpu_to_le32(flags);\n\n\tif (replayed)\n\t\tocfs2_bump_recovery_generation(fe);\n\n\tocfs2_compute_meta_ecc(osb->sb, bh->b_data, &fe->i_check);\n\tstatus = ocfs2_write_block(osb, bh, INODE_CACHE(journal->j_inode));\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clear_journal_error",
          "args": [
            "osb->sb",
            "journal->j_journal",
            "osb->slot_num"
          ],
          "line": 1055
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_journal_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "1022-1038",
          "snippet": "static void ocfs2_clear_journal_error(struct super_block *sb,\n\t\t\t\t      journal_t *journal,\n\t\t\t\t      int slot)\n{\n\tint olderr;\n\n\tolderr = jbd2_journal_errno(journal);\n\tif (olderr) {\n\t\tmlog(ML_ERROR, \"File system error %d recorded in \"\n\t\t     \"journal %u.\\n\", olderr, slot);\n\t\tmlog(ML_ERROR, \"File system on device %s needs checking.\\n\",\n\t\t     sb->s_id);\n\n\t\tjbd2_journal_ack_err(journal);\n\t\tjbd2_journal_clear_err(journal);\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_clear_journal_error(struct super_block *sb,\n\t\t\t\t      journal_t *journal,\n\t\t\t\t      int slot)\n{\n\tint olderr;\n\n\tolderr = jbd2_journal_errno(journal);\n\tif (olderr) {\n\t\tmlog(ML_ERROR, \"File system error %d recorded in \"\n\t\t     \"journal %u.\\n\", olderr, slot);\n\t\tmlog(ML_ERROR, \"File system on device %s needs checking.\\n\",\n\t\t     sb->s_id);\n\n\t\tjbd2_journal_ack_err(journal);\n\t\tjbd2_journal_clear_err(journal);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Failed to load journal!\\n\""
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_load",
          "args": [
            "journal->j_journal"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_load",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1611-1667",
          "snippet": "int jbd2_journal_load(journal_t *journal)\n{\n\tint err;\n\tjournal_superblock_t *sb;\n\n\terr = load_superblock(journal);\n\tif (err)\n\t\treturn err;\n\n\tsb = journal->j_superblock;\n\t/* If this is a V2 superblock, then we have to check the\n\t * features flags on it. */\n\n\tif (journal->j_format_version >= 2) {\n\t\tif ((sb->s_feature_ro_compat &\n\t\t     ~cpu_to_be32(JBD2_KNOWN_ROCOMPAT_FEATURES)) ||\n\t\t    (sb->s_feature_incompat &\n\t\t     ~cpu_to_be32(JBD2_KNOWN_INCOMPAT_FEATURES))) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t\t\"JBD2: Unrecognised features on journal\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/*\n\t * Create a slab for this blocksize\n\t */\n\terr = jbd2_journal_create_slab(be32_to_cpu(sb->s_blocksize));\n\tif (err)\n\t\treturn err;\n\n\t/* Let the recovery code check whether it needs to recover any\n\t * data from the journal. */\n\tif (jbd2_journal_recover(journal))\n\t\tgoto recovery_error;\n\n\tif (journal->j_failed_commit) {\n\t\tprintk(KERN_ERR \"JBD2: journal transaction %u on %s \"\n\t\t       \"is corrupt.\\n\", journal->j_failed_commit,\n\t\t       journal->j_devname);\n\t\treturn -EIO;\n\t}\n\n\t/* OK, we've finished with the dynamic journal bits:\n\t * reinitialise the dynamic contents of the superblock in memory\n\t * and reset them on disk. */\n\tif (journal_reset(journal))\n\t\tgoto recovery_error;\n\n\tjournal->j_flags &= ~JBD2_ABORT;\n\tjournal->j_flags |= JBD2_LOADED;\n\treturn 0;\n\nrecovery_error:\n\tprintk(KERN_WARNING \"JBD2: recovery failed\\n\");\n\treturn -EIO;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_load(journal_t *journal)\n{\n\tint err;\n\tjournal_superblock_t *sb;\n\n\terr = load_superblock(journal);\n\tif (err)\n\t\treturn err;\n\n\tsb = journal->j_superblock;\n\t/* If this is a V2 superblock, then we have to check the\n\t * features flags on it. */\n\n\tif (journal->j_format_version >= 2) {\n\t\tif ((sb->s_feature_ro_compat &\n\t\t     ~cpu_to_be32(JBD2_KNOWN_ROCOMPAT_FEATURES)) ||\n\t\t    (sb->s_feature_incompat &\n\t\t     ~cpu_to_be32(JBD2_KNOWN_INCOMPAT_FEATURES))) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t\t\"JBD2: Unrecognised features on journal\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/*\n\t * Create a slab for this blocksize\n\t */\n\terr = jbd2_journal_create_slab(be32_to_cpu(sb->s_blocksize));\n\tif (err)\n\t\treturn err;\n\n\t/* Let the recovery code check whether it needs to recover any\n\t * data from the journal. */\n\tif (jbd2_journal_recover(journal))\n\t\tgoto recovery_error;\n\n\tif (journal->j_failed_commit) {\n\t\tprintk(KERN_ERR \"JBD2: journal transaction %u on %s \"\n\t\t       \"is corrupt.\\n\", journal->j_failed_commit,\n\t\t       journal->j_devname);\n\t\treturn -EIO;\n\t}\n\n\t/* OK, we've finished with the dynamic journal bits:\n\t * reinitialise the dynamic contents of the superblock in memory\n\t * and reset them on disk. */\n\tif (journal_reset(journal))\n\t\tgoto recovery_error;\n\n\tjournal->j_flags &= ~JBD2_ABORT;\n\tjournal->j_flags |= JBD2_LOADED;\n\treturn 0;\n\nrecovery_error:\n\tprintk(KERN_WARNING \"JBD2: recovery failed\\n\");\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!journal"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\nstatic int ocfs2_journal_toggle_dirty(struct ocfs2_super *osb,\n\t\t\t\t      int dirty, int replayed);\nstatic int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);\n\nint ocfs2_journal_load(struct ocfs2_journal *journal, int local, int replayed)\n{\n\tint status = 0;\n\tstruct ocfs2_super *osb;\n\n\tBUG_ON(!journal);\n\n\tosb = journal->j_osb;\n\n\tstatus = jbd2_journal_load(journal->j_journal);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"Failed to load journal!\\n\");\n\t\tgoto done;\n\t}\n\n\tocfs2_clear_journal_error(osb->sb, journal->j_journal, osb->slot_num);\n\n\tstatus = ocfs2_journal_toggle_dirty(osb, 1, replayed);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto done;\n\t}\n\n\t/* Launch the commit thread */\n\tif (!local) {\n\t\tosb->commit_task = kthread_run(ocfs2_commit_thread, osb,\n\t\t\t\t\t       \"ocfs2cmt\");\n\t\tif (IS_ERR(osb->commit_task)) {\n\t\t\tstatus = PTR_ERR(osb->commit_task);\n\t\t\tosb->commit_task = NULL;\n\t\t\tmlog(ML_ERROR, \"unable to launch ocfs2commit thread, \"\n\t\t\t     \"error=%d\", status);\n\t\t\tgoto done;\n\t\t}\n\t} else\n\t\tosb->commit_task = NULL;\n\ndone:\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_clear_journal_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "1022-1038",
    "snippet": "static void ocfs2_clear_journal_error(struct super_block *sb,\n\t\t\t\t      journal_t *journal,\n\t\t\t\t      int slot)\n{\n\tint olderr;\n\n\tolderr = jbd2_journal_errno(journal);\n\tif (olderr) {\n\t\tmlog(ML_ERROR, \"File system error %d recorded in \"\n\t\t     \"journal %u.\\n\", olderr, slot);\n\t\tmlog(ML_ERROR, \"File system on device %s needs checking.\\n\",\n\t\t     sb->s_id);\n\n\t\tjbd2_journal_ack_err(journal);\n\t\tjbd2_journal_clear_err(journal);\n\t}\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd2_journal_clear_err",
          "args": [
            "journal"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_clear_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "2142-2153",
          "snippet": "int jbd2_journal_clear_err(journal_t *journal)\n{\n\tint err = 0;\n\n\twrite_lock(&journal->j_state_lock);\n\tif (journal->j_flags & JBD2_ABORT)\n\t\terr = -EROFS;\n\telse\n\t\tjournal->j_errno = 0;\n\twrite_unlock(&journal->j_state_lock);\n\treturn err;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_clear_err(journal_t *journal)\n{\n\tint err = 0;\n\n\twrite_lock(&journal->j_state_lock);\n\tif (journal->j_flags & JBD2_ABORT)\n\t\terr = -EROFS;\n\telse\n\t\tjournal->j_errno = 0;\n\twrite_unlock(&journal->j_state_lock);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_ack_err",
          "args": [
            "journal"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_ack_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "2162-2168",
          "snippet": "void jbd2_journal_ack_err(journal_t *journal)\n{\n\twrite_lock(&journal->j_state_lock);\n\tif (journal->j_errno)\n\t\tjournal->j_flags |= JBD2_ACK_ERR;\n\twrite_unlock(&journal->j_state_lock);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid jbd2_journal_ack_err(journal_t *journal)\n{\n\twrite_lock(&journal->j_state_lock);\n\tif (journal->j_errno)\n\t\tjournal->j_flags |= JBD2_ACK_ERR;\n\twrite_unlock(&journal->j_state_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"File system on device %s needs checking.\\n\"",
            "sb->s_id"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"File system error %d recorded in \"\n\t\t     \"journal %u.\\n\"",
            "olderr",
            "slot"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_errno",
          "args": [
            "journal"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "2122-2133",
          "snippet": "int jbd2_journal_errno(journal_t *journal)\n{\n\tint err;\n\n\tread_lock(&journal->j_state_lock);\n\tif (journal->j_flags & JBD2_ABORT)\n\t\terr = -EROFS;\n\telse\n\t\terr = journal->j_errno;\n\tread_unlock(&journal->j_state_lock);\n\treturn err;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_errno(journal_t *journal)\n{\n\tint err;\n\n\tread_lock(&journal->j_state_lock);\n\tif (journal->j_flags & JBD2_ABORT)\n\t\terr = -EROFS;\n\telse\n\t\terr = journal->j_errno;\n\tread_unlock(&journal->j_state_lock);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_clear_journal_error(struct super_block *sb,\n\t\t\t\t      journal_t *journal,\n\t\t\t\t      int slot)\n{\n\tint olderr;\n\n\tolderr = jbd2_journal_errno(journal);\n\tif (olderr) {\n\t\tmlog(ML_ERROR, \"File system error %d recorded in \"\n\t\t     \"journal %u.\\n\", olderr, slot);\n\t\tmlog(ML_ERROR, \"File system on device %s needs checking.\\n\",\n\t\t     sb->s_id);\n\n\t\tjbd2_journal_ack_err(journal);\n\t\tjbd2_journal_clear_err(journal);\n\t}\n}"
  },
  {
    "function_name": "ocfs2_journal_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "941-1020",
    "snippet": "void ocfs2_journal_shutdown(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_journal *journal = NULL;\n\tint status = 0;\n\tstruct inode *inode = NULL;\n\tint num_running_trans = 0;\n\n\tBUG_ON(!osb);\n\n\tjournal = osb->journal;\n\tif (!journal)\n\t\tgoto done;\n\n\tinode = journal->j_inode;\n\n\tif (journal->j_state != OCFS2_JOURNAL_LOADED)\n\t\tgoto done;\n\n\t/* need to inc inode use count - jbd2_journal_destroy will iput. */\n\tif (!igrab(inode))\n\t\tBUG();\n\n\tnum_running_trans = atomic_read(&(osb->journal->j_num_trans));\n\ttrace_ocfs2_journal_shutdown(num_running_trans);\n\n\t/* Do a commit_cache here. It will flush our journal, *and*\n\t * release any locks that are still held.\n\t * set the SHUTDOWN flag and release the trans lock.\n\t * the commit thread will take the trans lock for us below. */\n\tjournal->j_state = OCFS2_JOURNAL_IN_SHUTDOWN;\n\n\t/* The OCFS2_JOURNAL_IN_SHUTDOWN will signal to commit_cache to not\n\t * drop the trans_lock (which we want to hold until we\n\t * completely destroy the journal. */\n\tif (osb->commit_task) {\n\t\t/* Wait for the commit thread */\n\t\ttrace_ocfs2_journal_shutdown_wait(osb->commit_task);\n\t\tkthread_stop(osb->commit_task);\n\t\tosb->commit_task = NULL;\n\t}\n\n\tBUG_ON(atomic_read(&(osb->journal->j_num_trans)) != 0);\n\n\tif (ocfs2_mount_local(osb)) {\n\t\tjbd2_journal_lock_updates(journal->j_journal);\n\t\tstatus = jbd2_journal_flush(journal->j_journal);\n\t\tjbd2_journal_unlock_updates(journal->j_journal);\n\t\tif (status < 0)\n\t\t\tmlog_errno(status);\n\t}\n\n\tif (status == 0) {\n\t\t/*\n\t\t * Do not toggle if flush was unsuccessful otherwise\n\t\t * will leave dirty metadata in a \"clean\" journal\n\t\t */\n\t\tstatus = ocfs2_journal_toggle_dirty(osb, 0, 0);\n\t\tif (status < 0)\n\t\t\tmlog_errno(status);\n\t}\n\n\t/* Shutdown the kernel journal system */\n\tjbd2_journal_destroy(journal->j_journal);\n\tjournal->j_journal = NULL;\n\n\tOCFS2_I(inode)->ip_open_count--;\n\n\t/* unlock our journal */\n\tocfs2_inode_unlock(inode, 1);\n\n\tbrelse(journal->j_bh);\n\tjournal->j_bh = NULL;\n\n\tjournal->j_state = OCFS2_JOURNAL_FREE;\n\n//\tup_write(&journal->j_trans_barrier);\ndone:\n\tif (inode)\n\t\tiput(inode);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_force_read_journal(struct inode *inode);",
      "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "journal->j_bh"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "inode",
            "1"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_destroy",
          "args": [
            "journal->j_journal"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1677-1726",
          "snippet": "int jbd2_journal_destroy(journal_t *journal)\n{\n\tint err = 0;\n\n\t/* Wait for the commit thread to wake up and die. */\n\tjournal_kill_thread(journal);\n\n\t/* Force a final log commit */\n\tif (journal->j_running_transaction)\n\t\tjbd2_journal_commit_transaction(journal);\n\n\t/* Force any old transactions to disk */\n\n\t/* Totally anal locking here... */\n\tspin_lock(&journal->j_list_lock);\n\twhile (journal->j_checkpoint_transactions != NULL) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\tjbd2_log_do_checkpoint(journal);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\tspin_lock(&journal->j_list_lock);\n\t}\n\n\tJ_ASSERT(journal->j_running_transaction == NULL);\n\tJ_ASSERT(journal->j_committing_transaction == NULL);\n\tJ_ASSERT(journal->j_checkpoint_transactions == NULL);\n\tspin_unlock(&journal->j_list_lock);\n\n\tif (journal->j_sb_buffer) {\n\t\tif (!is_journal_aborted(journal)) {\n\t\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\t\tjbd2_mark_journal_empty(journal);\n\t\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\t} else\n\t\t\terr = -EIO;\n\t\tbrelse(journal->j_sb_buffer);\n\t}\n\n\tif (journal->j_proc_entry)\n\t\tjbd2_stats_proc_exit(journal);\n\tiput(journal->j_inode);\n\tif (journal->j_revoke)\n\t\tjbd2_journal_destroy_revoke(journal);\n\tif (journal->j_chksum_driver)\n\t\tcrypto_free_shash(journal->j_chksum_driver);\n\tkfree(journal->j_wbuf);\n\tkfree(journal);\n\n\treturn err;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_destroy(journal_t *journal)\n{\n\tint err = 0;\n\n\t/* Wait for the commit thread to wake up and die. */\n\tjournal_kill_thread(journal);\n\n\t/* Force a final log commit */\n\tif (journal->j_running_transaction)\n\t\tjbd2_journal_commit_transaction(journal);\n\n\t/* Force any old transactions to disk */\n\n\t/* Totally anal locking here... */\n\tspin_lock(&journal->j_list_lock);\n\twhile (journal->j_checkpoint_transactions != NULL) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\tjbd2_log_do_checkpoint(journal);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\tspin_lock(&journal->j_list_lock);\n\t}\n\n\tJ_ASSERT(journal->j_running_transaction == NULL);\n\tJ_ASSERT(journal->j_committing_transaction == NULL);\n\tJ_ASSERT(journal->j_checkpoint_transactions == NULL);\n\tspin_unlock(&journal->j_list_lock);\n\n\tif (journal->j_sb_buffer) {\n\t\tif (!is_journal_aborted(journal)) {\n\t\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\t\tjbd2_mark_journal_empty(journal);\n\t\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\t} else\n\t\t\terr = -EIO;\n\t\tbrelse(journal->j_sb_buffer);\n\t}\n\n\tif (journal->j_proc_entry)\n\t\tjbd2_stats_proc_exit(journal);\n\tiput(journal->j_inode);\n\tif (journal->j_revoke)\n\t\tjbd2_journal_destroy_revoke(journal);\n\tif (journal->j_chksum_driver)\n\t\tcrypto_free_shash(journal->j_chksum_driver);\n\tkfree(journal->j_wbuf);\n\tkfree(journal);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_toggle_dirty",
          "args": [
            "osb",
            "0",
            "0"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_toggle_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "903-935",
          "snippet": "static int ocfs2_journal_toggle_dirty(struct ocfs2_super *osb,\n\t\t\t\t      int dirty, int replayed)\n{\n\tint status;\n\tunsigned int flags;\n\tstruct ocfs2_journal *journal = osb->journal;\n\tstruct buffer_head *bh = journal->j_bh;\n\tstruct ocfs2_dinode *fe;\n\n\tfe = (struct ocfs2_dinode *)bh->b_data;\n\n\t/* The journal bh on the osb always comes from ocfs2_journal_init()\n\t * and was validated there inside ocfs2_inode_lock_full().  It's a\n\t * code bug if we mess it up. */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(fe));\n\n\tflags = le32_to_cpu(fe->id1.journal1.ij_flags);\n\tif (dirty)\n\t\tflags |= OCFS2_JOURNAL_DIRTY_FL;\n\telse\n\t\tflags &= ~OCFS2_JOURNAL_DIRTY_FL;\n\tfe->id1.journal1.ij_flags = cpu_to_le32(flags);\n\n\tif (replayed)\n\t\tocfs2_bump_recovery_generation(fe);\n\n\tocfs2_compute_meta_ecc(osb->sb, bh->b_data, &fe->i_check);\n\tstatus = ocfs2_write_block(osb, bh, INODE_CACHE(journal->j_inode));\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);",
            "static int ocfs2_journal_toggle_dirty(struct ocfs2_super *osb,\n\t\t\t\t      int dirty, int replayed);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\nstatic int ocfs2_journal_toggle_dirty(struct ocfs2_super *osb,\n\t\t\t\t      int dirty, int replayed);\n\nstatic int ocfs2_journal_toggle_dirty(struct ocfs2_super *osb,\n\t\t\t\t      int dirty, int replayed)\n{\n\tint status;\n\tunsigned int flags;\n\tstruct ocfs2_journal *journal = osb->journal;\n\tstruct buffer_head *bh = journal->j_bh;\n\tstruct ocfs2_dinode *fe;\n\n\tfe = (struct ocfs2_dinode *)bh->b_data;\n\n\t/* The journal bh on the osb always comes from ocfs2_journal_init()\n\t * and was validated there inside ocfs2_inode_lock_full().  It's a\n\t * code bug if we mess it up. */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(fe));\n\n\tflags = le32_to_cpu(fe->id1.journal1.ij_flags);\n\tif (dirty)\n\t\tflags |= OCFS2_JOURNAL_DIRTY_FL;\n\telse\n\t\tflags &= ~OCFS2_JOURNAL_DIRTY_FL;\n\tfe->id1.journal1.ij_flags = cpu_to_le32(flags);\n\n\tif (replayed)\n\t\tocfs2_bump_recovery_generation(fe);\n\n\tocfs2_compute_meta_ecc(osb->sb, bh->b_data, &fe->i_check);\n\tstatus = ocfs2_write_block(osb, bh, INODE_CACHE(journal->j_inode));\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_unlock_updates",
          "args": [
            "journal->j_journal"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_unlock_updates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "744-753",
          "snippet": "void jbd2_journal_unlock_updates (journal_t *journal)\n{\n\tJ_ASSERT(journal->j_barrier_count != 0);\n\n\tmutex_unlock(&journal->j_barrier);\n\twrite_lock(&journal->j_state_lock);\n\t--journal->j_barrier_count;\n\twrite_unlock(&journal->j_state_lock);\n\twake_up(&journal->j_wait_transaction_locked);\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid jbd2_journal_unlock_updates (journal_t *journal)\n{\n\tJ_ASSERT(journal->j_barrier_count != 0);\n\n\tmutex_unlock(&journal->j_barrier);\n\twrite_lock(&journal->j_state_lock);\n\t--journal->j_barrier_count;\n\twrite_unlock(&journal->j_state_lock);\n\twake_up(&journal->j_wait_transaction_locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_flush",
          "args": [
            "journal->j_journal"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1914-1970",
          "snippet": "int jbd2_journal_flush(journal_t *journal)\n{\n\tint err = 0;\n\ttransaction_t *transaction = NULL;\n\n\twrite_lock(&journal->j_state_lock);\n\n\t/* Force everything buffered to the log... */\n\tif (journal->j_running_transaction) {\n\t\ttransaction = journal->j_running_transaction;\n\t\t__jbd2_log_start_commit(journal, transaction->t_tid);\n\t} else if (journal->j_committing_transaction)\n\t\ttransaction = journal->j_committing_transaction;\n\n\t/* Wait for the log commit to complete... */\n\tif (transaction) {\n\t\ttid_t tid = transaction->t_tid;\n\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tjbd2_log_wait_commit(journal, tid);\n\t} else {\n\t\twrite_unlock(&journal->j_state_lock);\n\t}\n\n\t/* ...and flush everything in the log out to disk. */\n\tspin_lock(&journal->j_list_lock);\n\twhile (!err && journal->j_checkpoint_transactions != NULL) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\terr = jbd2_log_do_checkpoint(journal);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\tspin_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\tif (is_journal_aborted(journal))\n\t\treturn -EIO;\n\n\tmutex_lock(&journal->j_checkpoint_mutex);\n\tjbd2_cleanup_journal_tail(journal);\n\n\t/* Finally, mark the journal as really needing no recovery.\n\t * This sets s_start==0 in the underlying superblock, which is\n\t * the magic code for a fully-recovered superblock.  Any future\n\t * commits of data to the journal will restore the current\n\t * s_start value. */\n\tjbd2_mark_journal_empty(journal);\n\tmutex_unlock(&journal->j_checkpoint_mutex);\n\twrite_lock(&journal->j_state_lock);\n\tJ_ASSERT(!journal->j_running_transaction);\n\tJ_ASSERT(!journal->j_committing_transaction);\n\tJ_ASSERT(!journal->j_checkpoint_transactions);\n\tJ_ASSERT(journal->j_head == journal->j_tail);\n\tJ_ASSERT(journal->j_tail_sequence == journal->j_transaction_sequence);\n\twrite_unlock(&journal->j_state_lock);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_flush(journal_t *journal)\n{\n\tint err = 0;\n\ttransaction_t *transaction = NULL;\n\n\twrite_lock(&journal->j_state_lock);\n\n\t/* Force everything buffered to the log... */\n\tif (journal->j_running_transaction) {\n\t\ttransaction = journal->j_running_transaction;\n\t\t__jbd2_log_start_commit(journal, transaction->t_tid);\n\t} else if (journal->j_committing_transaction)\n\t\ttransaction = journal->j_committing_transaction;\n\n\t/* Wait for the log commit to complete... */\n\tif (transaction) {\n\t\ttid_t tid = transaction->t_tid;\n\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tjbd2_log_wait_commit(journal, tid);\n\t} else {\n\t\twrite_unlock(&journal->j_state_lock);\n\t}\n\n\t/* ...and flush everything in the log out to disk. */\n\tspin_lock(&journal->j_list_lock);\n\twhile (!err && journal->j_checkpoint_transactions != NULL) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\terr = jbd2_log_do_checkpoint(journal);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\tspin_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\tif (is_journal_aborted(journal))\n\t\treturn -EIO;\n\n\tmutex_lock(&journal->j_checkpoint_mutex);\n\tjbd2_cleanup_journal_tail(journal);\n\n\t/* Finally, mark the journal as really needing no recovery.\n\t * This sets s_start==0 in the underlying superblock, which is\n\t * the magic code for a fully-recovered superblock.  Any future\n\t * commits of data to the journal will restore the current\n\t * s_start value. */\n\tjbd2_mark_journal_empty(journal);\n\tmutex_unlock(&journal->j_checkpoint_mutex);\n\twrite_lock(&journal->j_state_lock);\n\tJ_ASSERT(!journal->j_running_transaction);\n\tJ_ASSERT(!journal->j_committing_transaction);\n\tJ_ASSERT(!journal->j_checkpoint_transactions);\n\tJ_ASSERT(journal->j_head == journal->j_tail);\n\tJ_ASSERT(journal->j_tail_sequence == journal->j_transaction_sequence);\n\twrite_unlock(&journal->j_state_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_lock_updates",
          "args": [
            "journal->j_journal"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_lock_updates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "689-734",
          "snippet": "void jbd2_journal_lock_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\n\twrite_lock(&journal->j_state_lock);\n\t++journal->j_barrier_count;\n\n\t/* Wait until there are no reserved handles */\n\tif (atomic_read(&journal->j_reserved_credits)) {\n\t\twrite_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_reserved,\n\t\t\t   atomic_read(&journal->j_reserved_credits) == 0);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\n\t/* Wait until there are no running updates */\n\twhile (1) {\n\t\ttransaction_t *transaction = journal->j_running_transaction;\n\n\t\tif (!transaction)\n\t\t\tbreak;\n\n\t\tspin_lock(&transaction->t_handle_lock);\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!atomic_read(&transaction->t_updates)) {\n\t\t\tspin_unlock(&transaction->t_handle_lock);\n\t\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\twrite_unlock(&journal->j_state_lock);\n\n\t/*\n\t * We have now established a barrier against other normal updates, but\n\t * we also need to barrier against other jbd2_journal_lock_updates() calls\n\t * to make sure that we serialise special journal-locked operations\n\t * too.\n\t */\n\tmutex_lock(&journal->j_barrier);\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid jbd2_journal_lock_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\n\twrite_lock(&journal->j_state_lock);\n\t++journal->j_barrier_count;\n\n\t/* Wait until there are no reserved handles */\n\tif (atomic_read(&journal->j_reserved_credits)) {\n\t\twrite_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_reserved,\n\t\t\t   atomic_read(&journal->j_reserved_credits) == 0);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\n\t/* Wait until there are no running updates */\n\twhile (1) {\n\t\ttransaction_t *transaction = journal->j_running_transaction;\n\n\t\tif (!transaction)\n\t\t\tbreak;\n\n\t\tspin_lock(&transaction->t_handle_lock);\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!atomic_read(&transaction->t_updates)) {\n\t\t\tspin_unlock(&transaction->t_handle_lock);\n\t\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\twrite_unlock(&journal->j_state_lock);\n\n\t/*\n\t * We have now established a barrier against other normal updates, but\n\t * we also need to barrier against other jbd2_journal_lock_updates() calls\n\t * to make sure that we serialise special journal-locked operations\n\t * too.\n\t */\n\tmutex_lock(&journal->j_barrier);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_mount_local",
          "args": [
            "osb"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mount_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "668-671",
          "snippet": "static inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "atomic_read(&(osb->journal->j_num_trans)) != 0"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&(osb->journal->j_num_trans)"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "osb->commit_task"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_journal_shutdown_wait",
          "args": [
            "osb->commit_task"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_journal_shutdown",
          "args": [
            "num_running_trans"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&(osb->journal->j_num_trans)"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "igrab",
          "args": [
            "inode"
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "igrab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1173-1189",
          "snippet": "struct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!osb"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_force_read_journal(struct inode *inode);\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nvoid ocfs2_journal_shutdown(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_journal *journal = NULL;\n\tint status = 0;\n\tstruct inode *inode = NULL;\n\tint num_running_trans = 0;\n\n\tBUG_ON(!osb);\n\n\tjournal = osb->journal;\n\tif (!journal)\n\t\tgoto done;\n\n\tinode = journal->j_inode;\n\n\tif (journal->j_state != OCFS2_JOURNAL_LOADED)\n\t\tgoto done;\n\n\t/* need to inc inode use count - jbd2_journal_destroy will iput. */\n\tif (!igrab(inode))\n\t\tBUG();\n\n\tnum_running_trans = atomic_read(&(osb->journal->j_num_trans));\n\ttrace_ocfs2_journal_shutdown(num_running_trans);\n\n\t/* Do a commit_cache here. It will flush our journal, *and*\n\t * release any locks that are still held.\n\t * set the SHUTDOWN flag and release the trans lock.\n\t * the commit thread will take the trans lock for us below. */\n\tjournal->j_state = OCFS2_JOURNAL_IN_SHUTDOWN;\n\n\t/* The OCFS2_JOURNAL_IN_SHUTDOWN will signal to commit_cache to not\n\t * drop the trans_lock (which we want to hold until we\n\t * completely destroy the journal. */\n\tif (osb->commit_task) {\n\t\t/* Wait for the commit thread */\n\t\ttrace_ocfs2_journal_shutdown_wait(osb->commit_task);\n\t\tkthread_stop(osb->commit_task);\n\t\tosb->commit_task = NULL;\n\t}\n\n\tBUG_ON(atomic_read(&(osb->journal->j_num_trans)) != 0);\n\n\tif (ocfs2_mount_local(osb)) {\n\t\tjbd2_journal_lock_updates(journal->j_journal);\n\t\tstatus = jbd2_journal_flush(journal->j_journal);\n\t\tjbd2_journal_unlock_updates(journal->j_journal);\n\t\tif (status < 0)\n\t\t\tmlog_errno(status);\n\t}\n\n\tif (status == 0) {\n\t\t/*\n\t\t * Do not toggle if flush was unsuccessful otherwise\n\t\t * will leave dirty metadata in a \"clean\" journal\n\t\t */\n\t\tstatus = ocfs2_journal_toggle_dirty(osb, 0, 0);\n\t\tif (status < 0)\n\t\t\tmlog_errno(status);\n\t}\n\n\t/* Shutdown the kernel journal system */\n\tjbd2_journal_destroy(journal->j_journal);\n\tjournal->j_journal = NULL;\n\n\tOCFS2_I(inode)->ip_open_count--;\n\n\t/* unlock our journal */\n\tocfs2_inode_unlock(inode, 1);\n\n\tbrelse(journal->j_bh);\n\tjournal->j_bh = NULL;\n\n\tjournal->j_state = OCFS2_JOURNAL_FREE;\n\n//\tup_write(&journal->j_trans_barrier);\ndone:\n\tif (inode)\n\t\tiput(inode);\n}"
  },
  {
    "function_name": "ocfs2_journal_toggle_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "903-935",
    "snippet": "static int ocfs2_journal_toggle_dirty(struct ocfs2_super *osb,\n\t\t\t\t      int dirty, int replayed)\n{\n\tint status;\n\tunsigned int flags;\n\tstruct ocfs2_journal *journal = osb->journal;\n\tstruct buffer_head *bh = journal->j_bh;\n\tstruct ocfs2_dinode *fe;\n\n\tfe = (struct ocfs2_dinode *)bh->b_data;\n\n\t/* The journal bh on the osb always comes from ocfs2_journal_init()\n\t * and was validated there inside ocfs2_inode_lock_full().  It's a\n\t * code bug if we mess it up. */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(fe));\n\n\tflags = le32_to_cpu(fe->id1.journal1.ij_flags);\n\tif (dirty)\n\t\tflags |= OCFS2_JOURNAL_DIRTY_FL;\n\telse\n\t\tflags &= ~OCFS2_JOURNAL_DIRTY_FL;\n\tfe->id1.journal1.ij_flags = cpu_to_le32(flags);\n\n\tif (replayed)\n\t\tocfs2_bump_recovery_generation(fe);\n\n\tocfs2_compute_meta_ecc(osb->sb, bh->b_data, &fe->i_check);\n\tstatus = ocfs2_write_block(osb, bh, INODE_CACHE(journal->j_inode));\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\treturn status;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_commit_cache(struct ocfs2_super *osb);",
      "static int ocfs2_journal_toggle_dirty(struct ocfs2_super *osb,\n\t\t\t\t      int dirty, int replayed);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_write_block",
          "args": [
            "osb",
            "bh",
            "INODE_CACHE(journal->j_inode)"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_write_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/buffer_head_io.c",
          "lines": "53-99",
          "snippet": "int ocfs2_write_block(struct ocfs2_super *osb, struct buffer_head *bh,\n\t\t      struct ocfs2_caching_info *ci)\n{\n\tint ret = 0;\n\n\ttrace_ocfs2_write_block((unsigned long long)bh->b_blocknr, ci);\n\n\tBUG_ON(bh->b_blocknr < OCFS2_SUPER_BLOCK_BLKNO);\n\tBUG_ON(buffer_jbd(bh));\n\n\t/* No need to check for a soft readonly file system here. non\n\t * journalled writes are only ever done on system files which\n\t * can get modified during recovery even if read-only. */\n\tif (ocfs2_is_hard_readonly(osb)) {\n\t\tret = -EROFS;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_metadata_cache_io_lock(ci);\n\n\tlock_buffer(bh);\n\tset_buffer_uptodate(bh);\n\n\t/* remove from dirty list before I/O. */\n\tclear_buffer_dirty(bh);\n\n\tget_bh(bh); /* for end_buffer_write_sync() */\n\tbh->b_end_io = end_buffer_write_sync;\n\tsubmit_bh(WRITE, bh);\n\n\twait_on_buffer(bh);\n\n\tif (buffer_uptodate(bh)) {\n\t\tocfs2_set_buffer_uptodate(ci, bh);\n\t} else {\n\t\t/* We don't need to remove the clustered uptodate\n\t\t * information for this bh as it's not marked locally\n\t\t * uptodate. */\n\t\tret = -EIO;\n\t\tmlog_errno(ret);\n\t}\n\n\tocfs2_metadata_cache_io_unlock(ci);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_write_block(struct ocfs2_super *osb, struct buffer_head *bh,\n\t\t      struct ocfs2_caching_info *ci)\n{\n\tint ret = 0;\n\n\ttrace_ocfs2_write_block((unsigned long long)bh->b_blocknr, ci);\n\n\tBUG_ON(bh->b_blocknr < OCFS2_SUPER_BLOCK_BLKNO);\n\tBUG_ON(buffer_jbd(bh));\n\n\t/* No need to check for a soft readonly file system here. non\n\t * journalled writes are only ever done on system files which\n\t * can get modified during recovery even if read-only. */\n\tif (ocfs2_is_hard_readonly(osb)) {\n\t\tret = -EROFS;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_metadata_cache_io_lock(ci);\n\n\tlock_buffer(bh);\n\tset_buffer_uptodate(bh);\n\n\t/* remove from dirty list before I/O. */\n\tclear_buffer_dirty(bh);\n\n\tget_bh(bh); /* for end_buffer_write_sync() */\n\tbh->b_end_io = end_buffer_write_sync;\n\tsubmit_bh(WRITE, bh);\n\n\twait_on_buffer(bh);\n\n\tif (buffer_uptodate(bh)) {\n\t\tocfs2_set_buffer_uptodate(ci, bh);\n\t} else {\n\t\t/* We don't need to remove the clustered uptodate\n\t\t * information for this bh as it's not marked locally\n\t\t * uptodate. */\n\t\tret = -EIO;\n\t\tmlog_errno(ret);\n\t}\n\n\tocfs2_metadata_cache_io_unlock(ci);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "journal->j_inode"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_compute_meta_ecc",
          "args": [
            "osb->sb",
            "bh->b_data",
            "&fe->i_check"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_compute_meta_ecc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "606-611",
          "snippet": "void ocfs2_compute_meta_ecc(struct super_block *sb, void *data,\n\t\t\t    struct ocfs2_block_check *bc)\n{\n\tif (ocfs2_meta_ecc(OCFS2_SB(sb)))\n\t\tocfs2_block_check_compute(data, sb->s_blocksize, bc);\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid ocfs2_compute_meta_ecc(struct super_block *sb, void *data,\n\t\t\t    struct ocfs2_block_check *bc)\n{\n\tif (ocfs2_meta_ecc(OCFS2_SB(sb)))\n\t\tocfs2_block_check_compute(data, sb->s_blocksize, bc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_bump_recovery_generation",
          "args": [
            "fe"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_bump_recovery_generation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "893-896",
          "snippet": "static void ocfs2_bump_recovery_generation(struct ocfs2_dinode *di)\n{\n\tle32_add_cpu(&(di->id1.journal1.ij_recovery_generation), 1);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_bump_recovery_generation(struct ocfs2_dinode *di)\n{\n\tle32_add_cpu(&(di->id1.journal1.ij_recovery_generation), 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "flags"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "fe->id1.journal1.ij_flags"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!OCFS2_IS_VALID_DINODE(fe)"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_IS_VALID_DINODE",
          "args": [
            "fe"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\nstatic int ocfs2_journal_toggle_dirty(struct ocfs2_super *osb,\n\t\t\t\t      int dirty, int replayed);\n\nstatic int ocfs2_journal_toggle_dirty(struct ocfs2_super *osb,\n\t\t\t\t      int dirty, int replayed)\n{\n\tint status;\n\tunsigned int flags;\n\tstruct ocfs2_journal *journal = osb->journal;\n\tstruct buffer_head *bh = journal->j_bh;\n\tstruct ocfs2_dinode *fe;\n\n\tfe = (struct ocfs2_dinode *)bh->b_data;\n\n\t/* The journal bh on the osb always comes from ocfs2_journal_init()\n\t * and was validated there inside ocfs2_inode_lock_full().  It's a\n\t * code bug if we mess it up. */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(fe));\n\n\tflags = le32_to_cpu(fe->id1.journal1.ij_flags);\n\tif (dirty)\n\t\tflags |= OCFS2_JOURNAL_DIRTY_FL;\n\telse\n\t\tflags &= ~OCFS2_JOURNAL_DIRTY_FL;\n\tfe->id1.journal1.ij_flags = cpu_to_le32(flags);\n\n\tif (replayed)\n\t\tocfs2_bump_recovery_generation(fe);\n\n\tocfs2_compute_meta_ecc(osb->sb, bh->b_data, &fe->i_check);\n\tstatus = ocfs2_write_block(osb, bh, INODE_CACHE(journal->j_inode));\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_get_recovery_generation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "898-901",
    "snippet": "static u32 ocfs2_get_recovery_generation(struct ocfs2_dinode *di)\n{\n\treturn le32_to_cpu(di->id1.journal1.ij_recovery_generation);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "di->id1.journal1.ij_recovery_generation"
          ],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u32 ocfs2_get_recovery_generation(struct ocfs2_dinode *di)\n{\n\treturn le32_to_cpu(di->id1.journal1.ij_recovery_generation);\n}"
  },
  {
    "function_name": "ocfs2_bump_recovery_generation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "893-896",
    "snippet": "static void ocfs2_bump_recovery_generation(struct ocfs2_dinode *di)\n{\n\tle32_add_cpu(&(di->id1.journal1.ij_recovery_generation), 1);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&(di->id1.journal1.ij_recovery_generation)",
            "1"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_bump_recovery_generation(struct ocfs2_dinode *di)\n{\n\tle32_add_cpu(&(di->id1.journal1.ij_recovery_generation), 1);\n}"
  },
  {
    "function_name": "ocfs2_journal_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "800-891",
    "snippet": "int ocfs2_journal_init(struct ocfs2_journal *journal, int *dirty)\n{\n\tint status = -1;\n\tstruct inode *inode = NULL; /* the journal inode */\n\tjournal_t *j_journal = NULL;\n\tstruct ocfs2_dinode *di = NULL;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_super *osb;\n\tint inode_lock = 0;\n\n\tBUG_ON(!journal);\n\n\tosb = journal->j_osb;\n\n\t/* already have the inode for our journal */\n\tinode = ocfs2_get_system_file_inode(osb, JOURNAL_SYSTEM_INODE,\n\t\t\t\t\t    osb->slot_num);\n\tif (inode == NULL) {\n\t\tstatus = -EACCES;\n\t\tmlog_errno(status);\n\t\tgoto done;\n\t}\n\tif (is_bad_inode(inode)) {\n\t\tmlog(ML_ERROR, \"access error (bad inode)\\n\");\n\t\tiput(inode);\n\t\tinode = NULL;\n\t\tstatus = -EACCES;\n\t\tgoto done;\n\t}\n\n\tSET_INODE_JOURNAL(inode);\n\tOCFS2_I(inode)->ip_open_count++;\n\n\t/* Skip recovery waits here - journal inode metadata never\n\t * changes in a live cluster so it can be considered an\n\t * exception to the rule. */\n\tstatus = ocfs2_inode_lock_full(inode, &bh, 1, OCFS2_META_LOCK_RECOVERY);\n\tif (status < 0) {\n\t\tif (status != -ERESTARTSYS)\n\t\t\tmlog(ML_ERROR, \"Could not get lock on journal!\\n\");\n\t\tgoto done;\n\t}\n\n\tinode_lock = 1;\n\tdi = (struct ocfs2_dinode *)bh->b_data;\n\n\tif (i_size_read(inode) <  OCFS2_MIN_JOURNAL_SIZE) {\n\t\tmlog(ML_ERROR, \"Journal file size (%lld) is too small!\\n\",\n\t\t     i_size_read(inode));\n\t\tstatus = -EINVAL;\n\t\tgoto done;\n\t}\n\n\ttrace_ocfs2_journal_init(i_size_read(inode),\n\t\t\t\t (unsigned long long)inode->i_blocks,\n\t\t\t\t OCFS2_I(inode)->ip_clusters);\n\n\t/* call the kernels journal init function now */\n\tj_journal = jbd2_journal_init_inode(inode);\n\tif (j_journal == NULL) {\n\t\tmlog(ML_ERROR, \"Linux journal layer error\\n\");\n\t\tstatus = -EINVAL;\n\t\tgoto done;\n\t}\n\n\ttrace_ocfs2_journal_init_maxlen(j_journal->j_maxlen);\n\n\t*dirty = (le32_to_cpu(di->id1.journal1.ij_flags) &\n\t\t  OCFS2_JOURNAL_DIRTY_FL);\n\n\tjournal->j_journal = j_journal;\n\tjournal->j_inode = inode;\n\tjournal->j_bh = bh;\n\n\tocfs2_set_journal_params(osb);\n\n\tjournal->j_state = OCFS2_JOURNAL_LOADED;\n\n\tstatus = 0;\ndone:\n\tif (status < 0) {\n\t\tif (inode_lock)\n\t\t\tocfs2_inode_unlock(inode, 1);\n\t\tbrelse(bh);\n\t\tif (inode) {\n\t\t\tOCFS2_I(inode)->ip_open_count--;\n\t\t\tiput(inode);\n\t\t}\n\t}\n\n\treturn status;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_force_read_journal(struct inode *inode);",
      "static int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);",
      "static int ocfs2_commit_cache(struct ocfs2_super *osb);",
      "static int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "inode",
            "1"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_set_journal_params",
          "args": [
            "osb"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_journal_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "783-798",
          "snippet": "void ocfs2_set_journal_params(struct ocfs2_super *osb)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\tunsigned long commit_interval = OCFS2_DEFAULT_COMMIT_INTERVAL;\n\n\tif (osb->osb_commit_interval)\n\t\tcommit_interval = osb->osb_commit_interval;\n\n\twrite_lock(&journal->j_state_lock);\n\tjournal->j_commit_interval = commit_interval;\n\tif (osb->s_mount_opt & OCFS2_MOUNT_BARRIER)\n\t\tjournal->j_flags |= JBD2_BARRIER;\n\telse\n\t\tjournal->j_flags &= ~JBD2_BARRIER;\n\twrite_unlock(&journal->j_state_lock);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_DEFAULT_COMMIT_INTERVAL\t(HZ * JBD2_DEFAULT_MAX_COMMIT_AGE)"
          ],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_DEFAULT_COMMIT_INTERVAL\t(HZ * JBD2_DEFAULT_MAX_COMMIT_AGE)\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nvoid ocfs2_set_journal_params(struct ocfs2_super *osb)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\tunsigned long commit_interval = OCFS2_DEFAULT_COMMIT_INTERVAL;\n\n\tif (osb->osb_commit_interval)\n\t\tcommit_interval = osb->osb_commit_interval;\n\n\twrite_lock(&journal->j_state_lock);\n\tjournal->j_commit_interval = commit_interval;\n\tif (osb->s_mount_opt & OCFS2_MOUNT_BARRIER)\n\t\tjournal->j_flags |= JBD2_BARRIER;\n\telse\n\t\tjournal->j_flags &= ~JBD2_BARRIER;\n\twrite_unlock(&journal->j_state_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "di->id1.journal1.ij_flags"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_journal_init_maxlen",
          "args": [
            "j_journal->j_maxlen"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Linux journal layer error\\n\""
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_init_inode",
          "args": [
            "inode"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_init_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1192-1256",
          "snippet": "journal_t * jbd2_journal_init_inode (struct inode *inode)\n{\n\tstruct buffer_head *bh;\n\tjournal_t *journal = journal_init_common();\n\tchar *p;\n\tint err;\n\tint n;\n\tunsigned long long blocknr;\n\n\tif (!journal)\n\t\treturn NULL;\n\n\tjournal->j_dev = journal->j_fs_dev = inode->i_sb->s_bdev;\n\tjournal->j_inode = inode;\n\tbdevname(journal->j_dev, journal->j_devname);\n\tp = journal->j_devname;\n\twhile ((p = strchr(p, '/')))\n\t\t*p = '!';\n\tp = journal->j_devname + strlen(journal->j_devname);\n\tsprintf(p, \"-%lu\", journal->j_inode->i_ino);\n\tjbd_debug(1,\n\t\t  \"journal %p: inode %s/%ld, size %Ld, bits %d, blksize %ld\\n\",\n\t\t  journal, inode->i_sb->s_id, inode->i_ino,\n\t\t  (long long) inode->i_size,\n\t\t  inode->i_sb->s_blocksize_bits, inode->i_sb->s_blocksize);\n\n\tjournal->j_maxlen = inode->i_size >> inode->i_sb->s_blocksize_bits;\n\tjournal->j_blocksize = inode->i_sb->s_blocksize;\n\tjbd2_stats_proc_init(journal);\n\n\t/* journal descriptor can store up to n blocks -bzzz */\n\tn = journal->j_blocksize / sizeof(journal_block_tag_t);\n\tjournal->j_wbufsize = n;\n\tjournal->j_wbuf = kmalloc(n * sizeof(struct buffer_head*), GFP_KERNEL);\n\tif (!journal->j_wbuf) {\n\t\tprintk(KERN_ERR \"%s: Can't allocate bhs for commit thread\\n\",\n\t\t\t__func__);\n\t\tgoto out_err;\n\t}\n\n\terr = jbd2_journal_bmap(journal, 0, &blocknr);\n\t/* If that failed, give up */\n\tif (err) {\n\t\tprintk(KERN_ERR \"%s: Cannot locate journal superblock\\n\",\n\t\t       __func__);\n\t\tgoto out_err;\n\t}\n\n\tbh = getblk_unmovable(journal->j_dev, blocknr, journal->j_blocksize);\n\tif (!bh) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Cannot get buffer for journal superblock\\n\",\n\t\t       __func__);\n\t\tgoto out_err;\n\t}\n\tjournal->j_sb_buffer = bh;\n\tjournal->j_superblock = (journal_superblock_t *)bh->b_data;\n\n\treturn journal;\nout_err:\n\tkfree(journal->j_wbuf);\n\tjbd2_stats_proc_exit(journal);\n\tkfree(journal);\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\njournal_t * jbd2_journal_init_inode (struct inode *inode)\n{\n\tstruct buffer_head *bh;\n\tjournal_t *journal = journal_init_common();\n\tchar *p;\n\tint err;\n\tint n;\n\tunsigned long long blocknr;\n\n\tif (!journal)\n\t\treturn NULL;\n\n\tjournal->j_dev = journal->j_fs_dev = inode->i_sb->s_bdev;\n\tjournal->j_inode = inode;\n\tbdevname(journal->j_dev, journal->j_devname);\n\tp = journal->j_devname;\n\twhile ((p = strchr(p, '/')))\n\t\t*p = '!';\n\tp = journal->j_devname + strlen(journal->j_devname);\n\tsprintf(p, \"-%lu\", journal->j_inode->i_ino);\n\tjbd_debug(1,\n\t\t  \"journal %p: inode %s/%ld, size %Ld, bits %d, blksize %ld\\n\",\n\t\t  journal, inode->i_sb->s_id, inode->i_ino,\n\t\t  (long long) inode->i_size,\n\t\t  inode->i_sb->s_blocksize_bits, inode->i_sb->s_blocksize);\n\n\tjournal->j_maxlen = inode->i_size >> inode->i_sb->s_blocksize_bits;\n\tjournal->j_blocksize = inode->i_sb->s_blocksize;\n\tjbd2_stats_proc_init(journal);\n\n\t/* journal descriptor can store up to n blocks -bzzz */\n\tn = journal->j_blocksize / sizeof(journal_block_tag_t);\n\tjournal->j_wbufsize = n;\n\tjournal->j_wbuf = kmalloc(n * sizeof(struct buffer_head*), GFP_KERNEL);\n\tif (!journal->j_wbuf) {\n\t\tprintk(KERN_ERR \"%s: Can't allocate bhs for commit thread\\n\",\n\t\t\t__func__);\n\t\tgoto out_err;\n\t}\n\n\terr = jbd2_journal_bmap(journal, 0, &blocknr);\n\t/* If that failed, give up */\n\tif (err) {\n\t\tprintk(KERN_ERR \"%s: Cannot locate journal superblock\\n\",\n\t\t       __func__);\n\t\tgoto out_err;\n\t}\n\n\tbh = getblk_unmovable(journal->j_dev, blocknr, journal->j_blocksize);\n\tif (!bh) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Cannot get buffer for journal superblock\\n\",\n\t\t       __func__);\n\t\tgoto out_err;\n\t}\n\tjournal->j_sb_buffer = bh;\n\tjournal->j_superblock = (journal_superblock_t *)bh->b_data;\n\n\treturn journal;\nout_err:\n\tkfree(journal->j_wbuf);\n\tjbd2_stats_proc_exit(journal);\n\tkfree(journal);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_journal_init",
          "args": [
            "i_size_read(inode)",
            "(unsigned long long)inode->i_blocks",
            "OCFS2_I(inode)->ip_clusters"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Journal file size (%lld) is too small!\\n\"",
            "i_size_read(inode)"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock_full",
          "args": [
            "inode",
            "&bh",
            "1",
            "OCFS2_META_LOCK_RECOVERY"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_INODE_JOURNAL",
          "args": [
            "inode"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "inode"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_system_file_inode",
          "args": [
            "osb",
            "JOURNAL_SYSTEM_INODE",
            "osb->slot_num"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "_ocfs2_get_system_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/sysfile.c",
          "lines": "138-181",
          "snippet": "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!journal"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_force_read_journal(struct inode *inode);\nstatic int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\nstatic int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);\n\nint ocfs2_journal_init(struct ocfs2_journal *journal, int *dirty)\n{\n\tint status = -1;\n\tstruct inode *inode = NULL; /* the journal inode */\n\tjournal_t *j_journal = NULL;\n\tstruct ocfs2_dinode *di = NULL;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_super *osb;\n\tint inode_lock = 0;\n\n\tBUG_ON(!journal);\n\n\tosb = journal->j_osb;\n\n\t/* already have the inode for our journal */\n\tinode = ocfs2_get_system_file_inode(osb, JOURNAL_SYSTEM_INODE,\n\t\t\t\t\t    osb->slot_num);\n\tif (inode == NULL) {\n\t\tstatus = -EACCES;\n\t\tmlog_errno(status);\n\t\tgoto done;\n\t}\n\tif (is_bad_inode(inode)) {\n\t\tmlog(ML_ERROR, \"access error (bad inode)\\n\");\n\t\tiput(inode);\n\t\tinode = NULL;\n\t\tstatus = -EACCES;\n\t\tgoto done;\n\t}\n\n\tSET_INODE_JOURNAL(inode);\n\tOCFS2_I(inode)->ip_open_count++;\n\n\t/* Skip recovery waits here - journal inode metadata never\n\t * changes in a live cluster so it can be considered an\n\t * exception to the rule. */\n\tstatus = ocfs2_inode_lock_full(inode, &bh, 1, OCFS2_META_LOCK_RECOVERY);\n\tif (status < 0) {\n\t\tif (status != -ERESTARTSYS)\n\t\t\tmlog(ML_ERROR, \"Could not get lock on journal!\\n\");\n\t\tgoto done;\n\t}\n\n\tinode_lock = 1;\n\tdi = (struct ocfs2_dinode *)bh->b_data;\n\n\tif (i_size_read(inode) <  OCFS2_MIN_JOURNAL_SIZE) {\n\t\tmlog(ML_ERROR, \"Journal file size (%lld) is too small!\\n\",\n\t\t     i_size_read(inode));\n\t\tstatus = -EINVAL;\n\t\tgoto done;\n\t}\n\n\ttrace_ocfs2_journal_init(i_size_read(inode),\n\t\t\t\t (unsigned long long)inode->i_blocks,\n\t\t\t\t OCFS2_I(inode)->ip_clusters);\n\n\t/* call the kernels journal init function now */\n\tj_journal = jbd2_journal_init_inode(inode);\n\tif (j_journal == NULL) {\n\t\tmlog(ML_ERROR, \"Linux journal layer error\\n\");\n\t\tstatus = -EINVAL;\n\t\tgoto done;\n\t}\n\n\ttrace_ocfs2_journal_init_maxlen(j_journal->j_maxlen);\n\n\t*dirty = (le32_to_cpu(di->id1.journal1.ij_flags) &\n\t\t  OCFS2_JOURNAL_DIRTY_FL);\n\n\tjournal->j_journal = j_journal;\n\tjournal->j_inode = inode;\n\tjournal->j_bh = bh;\n\n\tocfs2_set_journal_params(osb);\n\n\tjournal->j_state = OCFS2_JOURNAL_LOADED;\n\n\tstatus = 0;\ndone:\n\tif (status < 0) {\n\t\tif (inode_lock)\n\t\t\tocfs2_inode_unlock(inode, 1);\n\t\tbrelse(bh);\n\t\tif (inode) {\n\t\t\tOCFS2_I(inode)->ip_open_count--;\n\t\t\tiput(inode);\n\t\t}\n\t}\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_set_journal_params",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "783-798",
    "snippet": "void ocfs2_set_journal_params(struct ocfs2_super *osb)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\tunsigned long commit_interval = OCFS2_DEFAULT_COMMIT_INTERVAL;\n\n\tif (osb->osb_commit_interval)\n\t\tcommit_interval = osb->osb_commit_interval;\n\n\twrite_lock(&journal->j_state_lock);\n\tjournal->j_commit_interval = commit_interval;\n\tif (osb->s_mount_opt & OCFS2_MOUNT_BARRIER)\n\t\tjournal->j_flags |= JBD2_BARRIER;\n\telse\n\t\tjournal->j_flags &= ~JBD2_BARRIER;\n\twrite_unlock(&journal->j_state_lock);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define OCFS2_DEFAULT_COMMIT_INTERVAL\t(HZ * JBD2_DEFAULT_MAX_COMMIT_AGE)"
    ],
    "globals_used": [
      "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_DEFAULT_COMMIT_INTERVAL\t(HZ * JBD2_DEFAULT_MAX_COMMIT_AGE)\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nvoid ocfs2_set_journal_params(struct ocfs2_super *osb)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\tunsigned long commit_interval = OCFS2_DEFAULT_COMMIT_INTERVAL;\n\n\tif (osb->osb_commit_interval)\n\t\tcommit_interval = osb->osb_commit_interval;\n\n\twrite_lock(&journal->j_state_lock);\n\tjournal->j_commit_interval = commit_interval;\n\tif (osb->s_mount_opt & OCFS2_MOUNT_BARRIER)\n\t\tjournal->j_flags |= JBD2_BARRIER;\n\telse\n\t\tjournal->j_flags &= ~JBD2_BARRIER;\n\twrite_unlock(&journal->j_state_lock);\n}"
  },
  {
    "function_name": "ocfs2_journal_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "771-779",
    "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "status"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_dirty_metadata",
          "args": [
            "handle",
            "bh"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_dirty_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "1262-1372",
          "snippet": "int jbd2_journal_dirty_metadata(handle_t *handle, struct buffer_head *bh)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal;\n\tstruct journal_head *jh;\n\tint ret = 0;\n\n\tWARN_ON(!transaction);\n\tif (is_handle_aborted(handle))\n\t\treturn -EROFS;\n\tjournal = transaction->t_journal;\n\tjh = jbd2_journal_grab_journal_head(bh);\n\tif (!jh) {\n\t\tret = -EUCLEAN;\n\t\tgoto out;\n\t}\n\tjbd_debug(5, \"journal_head %p\\n\", jh);\n\tJBUFFER_TRACE(jh, \"entry\");\n\n\tjbd_lock_bh_state(bh);\n\n\tif (jh->b_modified == 0) {\n\t\t/*\n\t\t * This buffer's got modified and becoming part\n\t\t * of the transaction. This needs to be done\n\t\t * once a transaction -bzzz\n\t\t */\n\t\tjh->b_modified = 1;\n\t\tif (handle->h_buffer_credits <= 0) {\n\t\t\tret = -ENOSPC;\n\t\t\tgoto out_unlock_bh;\n\t\t}\n\t\thandle->h_buffer_credits--;\n\t}\n\n\t/*\n\t * fastpath, to avoid expensive locking.  If this buffer is already\n\t * on the running transaction's metadata list there is nothing to do.\n\t * Nobody can take it off again because there is a handle open.\n\t * I _think_ we're OK here with SMP barriers - a mistaken decision will\n\t * result in this test being false, so we go in and take the locks.\n\t */\n\tif (jh->b_transaction == transaction && jh->b_jlist == BJ_Metadata) {\n\t\tJBUFFER_TRACE(jh, \"fastpath\");\n\t\tif (unlikely(jh->b_transaction !=\n\t\t\t     journal->j_running_transaction)) {\n\t\t\tprintk(KERN_ERR \"JBD2: %s: \"\n\t\t\t       \"jh->b_transaction (%llu, %p, %u) != \"\n\t\t\t       \"journal->j_running_transaction (%p, %u)\\n\",\n\t\t\t       journal->j_devname,\n\t\t\t       (unsigned long long) bh->b_blocknr,\n\t\t\t       jh->b_transaction,\n\t\t\t       jh->b_transaction ? jh->b_transaction->t_tid : 0,\n\t\t\t       journal->j_running_transaction,\n\t\t\t       journal->j_running_transaction ?\n\t\t\t       journal->j_running_transaction->t_tid : 0);\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tgoto out_unlock_bh;\n\t}\n\n\tset_buffer_jbddirty(bh);\n\n\t/*\n\t * Metadata already on the current transaction list doesn't\n\t * need to be filed.  Metadata on another transaction's list must\n\t * be committing, and will be refiled once the commit completes:\n\t * leave it alone for now.\n\t */\n\tif (jh->b_transaction != transaction) {\n\t\tJBUFFER_TRACE(jh, \"already on other transaction\");\n\t\tif (unlikely(((jh->b_transaction !=\n\t\t\t       journal->j_committing_transaction)) ||\n\t\t\t     (jh->b_next_transaction != transaction))) {\n\t\t\tprintk(KERN_ERR \"jbd2_journal_dirty_metadata: %s: \"\n\t\t\t       \"bad jh for block %llu: \"\n\t\t\t       \"transaction (%p, %u), \"\n\t\t\t       \"jh->b_transaction (%p, %u), \"\n\t\t\t       \"jh->b_next_transaction (%p, %u), jlist %u\\n\",\n\t\t\t       journal->j_devname,\n\t\t\t       (unsigned long long) bh->b_blocknr,\n\t\t\t       transaction, transaction->t_tid,\n\t\t\t       jh->b_transaction,\n\t\t\t       jh->b_transaction ?\n\t\t\t       jh->b_transaction->t_tid : 0,\n\t\t\t       jh->b_next_transaction,\n\t\t\t       jh->b_next_transaction ?\n\t\t\t       jh->b_next_transaction->t_tid : 0,\n\t\t\t       jh->b_jlist);\n\t\t\tWARN_ON(1);\n\t\t\tret = -EINVAL;\n\t\t}\n\t\t/* And this case is illegal: we can't reuse another\n\t\t * transaction's data buffer, ever. */\n\t\tgoto out_unlock_bh;\n\t}\n\n\t/* That test should have eliminated the following case: */\n\tJ_ASSERT_JH(jh, jh->b_frozen_data == NULL);\n\n\tJBUFFER_TRACE(jh, \"file as BJ_Metadata\");\n\tspin_lock(&journal->j_list_lock);\n\t__jbd2_journal_file_buffer(jh, transaction, BJ_Metadata);\n\tspin_unlock(&journal->j_list_lock);\nout_unlock_bh:\n\tjbd_unlock_bh_state(bh);\n\tjbd2_journal_put_journal_head(jh);\nout:\n\tJBUFFER_TRACE(jh, \"exit\");\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __jbd2_journal_temp_unlink_buffer(struct journal_head *jh);",
            "static void __jbd2_journal_unfile_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __jbd2_journal_temp_unlink_buffer(struct journal_head *jh);\nstatic void __jbd2_journal_unfile_buffer(struct journal_head *jh);\n\nint jbd2_journal_dirty_metadata(handle_t *handle, struct buffer_head *bh)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal;\n\tstruct journal_head *jh;\n\tint ret = 0;\n\n\tWARN_ON(!transaction);\n\tif (is_handle_aborted(handle))\n\t\treturn -EROFS;\n\tjournal = transaction->t_journal;\n\tjh = jbd2_journal_grab_journal_head(bh);\n\tif (!jh) {\n\t\tret = -EUCLEAN;\n\t\tgoto out;\n\t}\n\tjbd_debug(5, \"journal_head %p\\n\", jh);\n\tJBUFFER_TRACE(jh, \"entry\");\n\n\tjbd_lock_bh_state(bh);\n\n\tif (jh->b_modified == 0) {\n\t\t/*\n\t\t * This buffer's got modified and becoming part\n\t\t * of the transaction. This needs to be done\n\t\t * once a transaction -bzzz\n\t\t */\n\t\tjh->b_modified = 1;\n\t\tif (handle->h_buffer_credits <= 0) {\n\t\t\tret = -ENOSPC;\n\t\t\tgoto out_unlock_bh;\n\t\t}\n\t\thandle->h_buffer_credits--;\n\t}\n\n\t/*\n\t * fastpath, to avoid expensive locking.  If this buffer is already\n\t * on the running transaction's metadata list there is nothing to do.\n\t * Nobody can take it off again because there is a handle open.\n\t * I _think_ we're OK here with SMP barriers - a mistaken decision will\n\t * result in this test being false, so we go in and take the locks.\n\t */\n\tif (jh->b_transaction == transaction && jh->b_jlist == BJ_Metadata) {\n\t\tJBUFFER_TRACE(jh, \"fastpath\");\n\t\tif (unlikely(jh->b_transaction !=\n\t\t\t     journal->j_running_transaction)) {\n\t\t\tprintk(KERN_ERR \"JBD2: %s: \"\n\t\t\t       \"jh->b_transaction (%llu, %p, %u) != \"\n\t\t\t       \"journal->j_running_transaction (%p, %u)\\n\",\n\t\t\t       journal->j_devname,\n\t\t\t       (unsigned long long) bh->b_blocknr,\n\t\t\t       jh->b_transaction,\n\t\t\t       jh->b_transaction ? jh->b_transaction->t_tid : 0,\n\t\t\t       journal->j_running_transaction,\n\t\t\t       journal->j_running_transaction ?\n\t\t\t       journal->j_running_transaction->t_tid : 0);\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tgoto out_unlock_bh;\n\t}\n\n\tset_buffer_jbddirty(bh);\n\n\t/*\n\t * Metadata already on the current transaction list doesn't\n\t * need to be filed.  Metadata on another transaction's list must\n\t * be committing, and will be refiled once the commit completes:\n\t * leave it alone for now.\n\t */\n\tif (jh->b_transaction != transaction) {\n\t\tJBUFFER_TRACE(jh, \"already on other transaction\");\n\t\tif (unlikely(((jh->b_transaction !=\n\t\t\t       journal->j_committing_transaction)) ||\n\t\t\t     (jh->b_next_transaction != transaction))) {\n\t\t\tprintk(KERN_ERR \"jbd2_journal_dirty_metadata: %s: \"\n\t\t\t       \"bad jh for block %llu: \"\n\t\t\t       \"transaction (%p, %u), \"\n\t\t\t       \"jh->b_transaction (%p, %u), \"\n\t\t\t       \"jh->b_next_transaction (%p, %u), jlist %u\\n\",\n\t\t\t       journal->j_devname,\n\t\t\t       (unsigned long long) bh->b_blocknr,\n\t\t\t       transaction, transaction->t_tid,\n\t\t\t       jh->b_transaction,\n\t\t\t       jh->b_transaction ?\n\t\t\t       jh->b_transaction->t_tid : 0,\n\t\t\t       jh->b_next_transaction,\n\t\t\t       jh->b_next_transaction ?\n\t\t\t       jh->b_next_transaction->t_tid : 0,\n\t\t\t       jh->b_jlist);\n\t\t\tWARN_ON(1);\n\t\t\tret = -EINVAL;\n\t\t}\n\t\t/* And this case is illegal: we can't reuse another\n\t\t * transaction's data buffer, ever. */\n\t\tgoto out_unlock_bh;\n\t}\n\n\t/* That test should have eliminated the following case: */\n\tJ_ASSERT_JH(jh, jh->b_frozen_data == NULL);\n\n\tJBUFFER_TRACE(jh, \"file as BJ_Metadata\");\n\tspin_lock(&journal->j_list_lock);\n\t__jbd2_journal_file_buffer(jh, transaction, BJ_Metadata);\n\tspin_unlock(&journal->j_list_lock);\nout_unlock_bh:\n\tjbd_unlock_bh_state(bh);\n\tjbd2_journal_put_journal_head(jh);\nout:\n\tJBUFFER_TRACE(jh, \"exit\");\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_journal_dirty",
          "args": [
            "(unsigned long long)bh->b_blocknr"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
  },
  {
    "function_name": "ocfs2_journal_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "765-769",
    "snippet": "int ocfs2_journal_access(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, NULL, type);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ocfs2_journal_access",
          "args": [
            "handle",
            "ci",
            "bh",
            "NULL",
            "type"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "650-708",
          "snippet": "static int __ocfs2_journal_access(handle_t *handle,\n\t\t\t\t  struct ocfs2_caching_info *ci,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  struct ocfs2_triggers *triggers,\n\t\t\t\t  int type)\n{\n\tint status;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(ci));\n\n\tBUG_ON(!ci || !ci->ci_ops);\n\tBUG_ON(!handle);\n\tBUG_ON(!bh);\n\n\ttrace_ocfs2_journal_access(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long)bh->b_blocknr, type, bh->b_size);\n\n\t/* we can safely remove this assertion after testing. */\n\tif (!buffer_uptodate(bh)) {\n\t\tmlog(ML_ERROR, \"giving me a buffer that's not uptodate!\\n\");\n\t\tmlog(ML_ERROR, \"b_blocknr=%llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\t\tBUG();\n\t}\n\n\t/* Set the current transaction information on the ci so\n\t * that the locking code knows whether it can drop it's locks\n\t * on this ci or not. We're protected from the commit\n\t * thread updating the current transaction id until\n\t * ocfs2_commit_trans() because ocfs2_start_trans() took\n\t * j_trans_barrier for us. */\n\tocfs2_set_ci_lock_trans(osb->journal, ci);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tswitch (type) {\n\tcase OCFS2_JOURNAL_ACCESS_CREATE:\n\tcase OCFS2_JOURNAL_ACCESS_WRITE:\n\t\tstatus = jbd2_journal_get_write_access(handle, bh);\n\t\tbreak;\n\n\tcase OCFS2_JOURNAL_ACCESS_UNDO:\n\t\tstatus = jbd2_journal_get_undo_access(handle, bh);\n\t\tbreak;\n\n\tdefault:\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Unknown access type!\\n\");\n\t}\n\tif (!status && ocfs2_meta_ecc(osb) && triggers)\n\t\tjbd2_journal_set_triggers(bh, &triggers->ot_triggers);\n\tocfs2_metadata_cache_io_unlock(ci);\n\n\tif (status < 0)\n\t\tmlog(ML_ERROR, \"Error %d getting %d access to buffer!\\n\",\n\t\t     status, type);\n\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nstatic int __ocfs2_journal_access(handle_t *handle,\n\t\t\t\t  struct ocfs2_caching_info *ci,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  struct ocfs2_triggers *triggers,\n\t\t\t\t  int type)\n{\n\tint status;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(ci));\n\n\tBUG_ON(!ci || !ci->ci_ops);\n\tBUG_ON(!handle);\n\tBUG_ON(!bh);\n\n\ttrace_ocfs2_journal_access(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long)bh->b_blocknr, type, bh->b_size);\n\n\t/* we can safely remove this assertion after testing. */\n\tif (!buffer_uptodate(bh)) {\n\t\tmlog(ML_ERROR, \"giving me a buffer that's not uptodate!\\n\");\n\t\tmlog(ML_ERROR, \"b_blocknr=%llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\t\tBUG();\n\t}\n\n\t/* Set the current transaction information on the ci so\n\t * that the locking code knows whether it can drop it's locks\n\t * on this ci or not. We're protected from the commit\n\t * thread updating the current transaction id until\n\t * ocfs2_commit_trans() because ocfs2_start_trans() took\n\t * j_trans_barrier for us. */\n\tocfs2_set_ci_lock_trans(osb->journal, ci);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tswitch (type) {\n\tcase OCFS2_JOURNAL_ACCESS_CREATE:\n\tcase OCFS2_JOURNAL_ACCESS_WRITE:\n\t\tstatus = jbd2_journal_get_write_access(handle, bh);\n\t\tbreak;\n\n\tcase OCFS2_JOURNAL_ACCESS_UNDO:\n\t\tstatus = jbd2_journal_get_undo_access(handle, bh);\n\t\tbreak;\n\n\tdefault:\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Unknown access type!\\n\");\n\t}\n\tif (!status && ocfs2_meta_ecc(osb) && triggers)\n\t\tjbd2_journal_set_triggers(bh, &triggers->ot_triggers);\n\tocfs2_metadata_cache_io_unlock(ci);\n\n\tif (status < 0)\n\t\tmlog(ML_ERROR, \"Error %d getting %d access to buffer!\\n\",\n\t\t     status, type);\n\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_journal_access(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, NULL, type);\n}"
  },
  {
    "function_name": "ocfs2_journal_access_dl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "759-763",
    "snippet": "int ocfs2_journal_access_dl(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &dl_triggers, type);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_triggers dl_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dx_leaf, dl_check),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ocfs2_journal_access",
          "args": [
            "handle",
            "ci",
            "bh",
            "&dl_triggers",
            "type"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "650-708",
          "snippet": "static int __ocfs2_journal_access(handle_t *handle,\n\t\t\t\t  struct ocfs2_caching_info *ci,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  struct ocfs2_triggers *triggers,\n\t\t\t\t  int type)\n{\n\tint status;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(ci));\n\n\tBUG_ON(!ci || !ci->ci_ops);\n\tBUG_ON(!handle);\n\tBUG_ON(!bh);\n\n\ttrace_ocfs2_journal_access(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long)bh->b_blocknr, type, bh->b_size);\n\n\t/* we can safely remove this assertion after testing. */\n\tif (!buffer_uptodate(bh)) {\n\t\tmlog(ML_ERROR, \"giving me a buffer that's not uptodate!\\n\");\n\t\tmlog(ML_ERROR, \"b_blocknr=%llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\t\tBUG();\n\t}\n\n\t/* Set the current transaction information on the ci so\n\t * that the locking code knows whether it can drop it's locks\n\t * on this ci or not. We're protected from the commit\n\t * thread updating the current transaction id until\n\t * ocfs2_commit_trans() because ocfs2_start_trans() took\n\t * j_trans_barrier for us. */\n\tocfs2_set_ci_lock_trans(osb->journal, ci);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tswitch (type) {\n\tcase OCFS2_JOURNAL_ACCESS_CREATE:\n\tcase OCFS2_JOURNAL_ACCESS_WRITE:\n\t\tstatus = jbd2_journal_get_write_access(handle, bh);\n\t\tbreak;\n\n\tcase OCFS2_JOURNAL_ACCESS_UNDO:\n\t\tstatus = jbd2_journal_get_undo_access(handle, bh);\n\t\tbreak;\n\n\tdefault:\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Unknown access type!\\n\");\n\t}\n\tif (!status && ocfs2_meta_ecc(osb) && triggers)\n\t\tjbd2_journal_set_triggers(bh, &triggers->ot_triggers);\n\tocfs2_metadata_cache_io_unlock(ci);\n\n\tif (status < 0)\n\t\tmlog(ML_ERROR, \"Error %d getting %d access to buffer!\\n\",\n\t\t     status, type);\n\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nstatic int __ocfs2_journal_access(handle_t *handle,\n\t\t\t\t  struct ocfs2_caching_info *ci,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  struct ocfs2_triggers *triggers,\n\t\t\t\t  int type)\n{\n\tint status;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(ci));\n\n\tBUG_ON(!ci || !ci->ci_ops);\n\tBUG_ON(!handle);\n\tBUG_ON(!bh);\n\n\ttrace_ocfs2_journal_access(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long)bh->b_blocknr, type, bh->b_size);\n\n\t/* we can safely remove this assertion after testing. */\n\tif (!buffer_uptodate(bh)) {\n\t\tmlog(ML_ERROR, \"giving me a buffer that's not uptodate!\\n\");\n\t\tmlog(ML_ERROR, \"b_blocknr=%llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\t\tBUG();\n\t}\n\n\t/* Set the current transaction information on the ci so\n\t * that the locking code knows whether it can drop it's locks\n\t * on this ci or not. We're protected from the commit\n\t * thread updating the current transaction id until\n\t * ocfs2_commit_trans() because ocfs2_start_trans() took\n\t * j_trans_barrier for us. */\n\tocfs2_set_ci_lock_trans(osb->journal, ci);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tswitch (type) {\n\tcase OCFS2_JOURNAL_ACCESS_CREATE:\n\tcase OCFS2_JOURNAL_ACCESS_WRITE:\n\t\tstatus = jbd2_journal_get_write_access(handle, bh);\n\t\tbreak;\n\n\tcase OCFS2_JOURNAL_ACCESS_UNDO:\n\t\tstatus = jbd2_journal_get_undo_access(handle, bh);\n\t\tbreak;\n\n\tdefault:\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Unknown access type!\\n\");\n\t}\n\tif (!status && ocfs2_meta_ecc(osb) && triggers)\n\t\tjbd2_journal_set_triggers(bh, &triggers->ot_triggers);\n\tocfs2_metadata_cache_io_unlock(ci);\n\n\tif (status < 0)\n\t\tmlog(ML_ERROR, \"Error %d getting %d access to buffer!\\n\",\n\t\t     status, type);\n\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers dl_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dx_leaf, dl_check),\n};\n\nint ocfs2_journal_access_dl(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &dl_triggers, type);\n}"
  },
  {
    "function_name": "ocfs2_journal_access_dr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "753-757",
    "snippet": "int ocfs2_journal_access_dr(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &dr_triggers, type);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_triggers dr_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dx_root_block, dr_check),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ocfs2_journal_access",
          "args": [
            "handle",
            "ci",
            "bh",
            "&dr_triggers",
            "type"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "650-708",
          "snippet": "static int __ocfs2_journal_access(handle_t *handle,\n\t\t\t\t  struct ocfs2_caching_info *ci,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  struct ocfs2_triggers *triggers,\n\t\t\t\t  int type)\n{\n\tint status;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(ci));\n\n\tBUG_ON(!ci || !ci->ci_ops);\n\tBUG_ON(!handle);\n\tBUG_ON(!bh);\n\n\ttrace_ocfs2_journal_access(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long)bh->b_blocknr, type, bh->b_size);\n\n\t/* we can safely remove this assertion after testing. */\n\tif (!buffer_uptodate(bh)) {\n\t\tmlog(ML_ERROR, \"giving me a buffer that's not uptodate!\\n\");\n\t\tmlog(ML_ERROR, \"b_blocknr=%llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\t\tBUG();\n\t}\n\n\t/* Set the current transaction information on the ci so\n\t * that the locking code knows whether it can drop it's locks\n\t * on this ci or not. We're protected from the commit\n\t * thread updating the current transaction id until\n\t * ocfs2_commit_trans() because ocfs2_start_trans() took\n\t * j_trans_barrier for us. */\n\tocfs2_set_ci_lock_trans(osb->journal, ci);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tswitch (type) {\n\tcase OCFS2_JOURNAL_ACCESS_CREATE:\n\tcase OCFS2_JOURNAL_ACCESS_WRITE:\n\t\tstatus = jbd2_journal_get_write_access(handle, bh);\n\t\tbreak;\n\n\tcase OCFS2_JOURNAL_ACCESS_UNDO:\n\t\tstatus = jbd2_journal_get_undo_access(handle, bh);\n\t\tbreak;\n\n\tdefault:\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Unknown access type!\\n\");\n\t}\n\tif (!status && ocfs2_meta_ecc(osb) && triggers)\n\t\tjbd2_journal_set_triggers(bh, &triggers->ot_triggers);\n\tocfs2_metadata_cache_io_unlock(ci);\n\n\tif (status < 0)\n\t\tmlog(ML_ERROR, \"Error %d getting %d access to buffer!\\n\",\n\t\t     status, type);\n\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nstatic int __ocfs2_journal_access(handle_t *handle,\n\t\t\t\t  struct ocfs2_caching_info *ci,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  struct ocfs2_triggers *triggers,\n\t\t\t\t  int type)\n{\n\tint status;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(ci));\n\n\tBUG_ON(!ci || !ci->ci_ops);\n\tBUG_ON(!handle);\n\tBUG_ON(!bh);\n\n\ttrace_ocfs2_journal_access(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long)bh->b_blocknr, type, bh->b_size);\n\n\t/* we can safely remove this assertion after testing. */\n\tif (!buffer_uptodate(bh)) {\n\t\tmlog(ML_ERROR, \"giving me a buffer that's not uptodate!\\n\");\n\t\tmlog(ML_ERROR, \"b_blocknr=%llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\t\tBUG();\n\t}\n\n\t/* Set the current transaction information on the ci so\n\t * that the locking code knows whether it can drop it's locks\n\t * on this ci or not. We're protected from the commit\n\t * thread updating the current transaction id until\n\t * ocfs2_commit_trans() because ocfs2_start_trans() took\n\t * j_trans_barrier for us. */\n\tocfs2_set_ci_lock_trans(osb->journal, ci);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tswitch (type) {\n\tcase OCFS2_JOURNAL_ACCESS_CREATE:\n\tcase OCFS2_JOURNAL_ACCESS_WRITE:\n\t\tstatus = jbd2_journal_get_write_access(handle, bh);\n\t\tbreak;\n\n\tcase OCFS2_JOURNAL_ACCESS_UNDO:\n\t\tstatus = jbd2_journal_get_undo_access(handle, bh);\n\t\tbreak;\n\n\tdefault:\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Unknown access type!\\n\");\n\t}\n\tif (!status && ocfs2_meta_ecc(osb) && triggers)\n\t\tjbd2_journal_set_triggers(bh, &triggers->ot_triggers);\n\tocfs2_metadata_cache_io_unlock(ci);\n\n\tif (status < 0)\n\t\tmlog(ML_ERROR, \"Error %d getting %d access to buffer!\\n\",\n\t\t     status, type);\n\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers dr_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dx_root_block, dr_check),\n};\n\nint ocfs2_journal_access_dr(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &dr_triggers, type);\n}"
  },
  {
    "function_name": "ocfs2_journal_access_dq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "747-751",
    "snippet": "int ocfs2_journal_access_dq(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &dq_triggers, type);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_triggers dq_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_dq_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ocfs2_journal_access",
          "args": [
            "handle",
            "ci",
            "bh",
            "&dq_triggers",
            "type"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "650-708",
          "snippet": "static int __ocfs2_journal_access(handle_t *handle,\n\t\t\t\t  struct ocfs2_caching_info *ci,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  struct ocfs2_triggers *triggers,\n\t\t\t\t  int type)\n{\n\tint status;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(ci));\n\n\tBUG_ON(!ci || !ci->ci_ops);\n\tBUG_ON(!handle);\n\tBUG_ON(!bh);\n\n\ttrace_ocfs2_journal_access(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long)bh->b_blocknr, type, bh->b_size);\n\n\t/* we can safely remove this assertion after testing. */\n\tif (!buffer_uptodate(bh)) {\n\t\tmlog(ML_ERROR, \"giving me a buffer that's not uptodate!\\n\");\n\t\tmlog(ML_ERROR, \"b_blocknr=%llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\t\tBUG();\n\t}\n\n\t/* Set the current transaction information on the ci so\n\t * that the locking code knows whether it can drop it's locks\n\t * on this ci or not. We're protected from the commit\n\t * thread updating the current transaction id until\n\t * ocfs2_commit_trans() because ocfs2_start_trans() took\n\t * j_trans_barrier for us. */\n\tocfs2_set_ci_lock_trans(osb->journal, ci);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tswitch (type) {\n\tcase OCFS2_JOURNAL_ACCESS_CREATE:\n\tcase OCFS2_JOURNAL_ACCESS_WRITE:\n\t\tstatus = jbd2_journal_get_write_access(handle, bh);\n\t\tbreak;\n\n\tcase OCFS2_JOURNAL_ACCESS_UNDO:\n\t\tstatus = jbd2_journal_get_undo_access(handle, bh);\n\t\tbreak;\n\n\tdefault:\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Unknown access type!\\n\");\n\t}\n\tif (!status && ocfs2_meta_ecc(osb) && triggers)\n\t\tjbd2_journal_set_triggers(bh, &triggers->ot_triggers);\n\tocfs2_metadata_cache_io_unlock(ci);\n\n\tif (status < 0)\n\t\tmlog(ML_ERROR, \"Error %d getting %d access to buffer!\\n\",\n\t\t     status, type);\n\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nstatic int __ocfs2_journal_access(handle_t *handle,\n\t\t\t\t  struct ocfs2_caching_info *ci,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  struct ocfs2_triggers *triggers,\n\t\t\t\t  int type)\n{\n\tint status;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(ci));\n\n\tBUG_ON(!ci || !ci->ci_ops);\n\tBUG_ON(!handle);\n\tBUG_ON(!bh);\n\n\ttrace_ocfs2_journal_access(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long)bh->b_blocknr, type, bh->b_size);\n\n\t/* we can safely remove this assertion after testing. */\n\tif (!buffer_uptodate(bh)) {\n\t\tmlog(ML_ERROR, \"giving me a buffer that's not uptodate!\\n\");\n\t\tmlog(ML_ERROR, \"b_blocknr=%llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\t\tBUG();\n\t}\n\n\t/* Set the current transaction information on the ci so\n\t * that the locking code knows whether it can drop it's locks\n\t * on this ci or not. We're protected from the commit\n\t * thread updating the current transaction id until\n\t * ocfs2_commit_trans() because ocfs2_start_trans() took\n\t * j_trans_barrier for us. */\n\tocfs2_set_ci_lock_trans(osb->journal, ci);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tswitch (type) {\n\tcase OCFS2_JOURNAL_ACCESS_CREATE:\n\tcase OCFS2_JOURNAL_ACCESS_WRITE:\n\t\tstatus = jbd2_journal_get_write_access(handle, bh);\n\t\tbreak;\n\n\tcase OCFS2_JOURNAL_ACCESS_UNDO:\n\t\tstatus = jbd2_journal_get_undo_access(handle, bh);\n\t\tbreak;\n\n\tdefault:\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Unknown access type!\\n\");\n\t}\n\tif (!status && ocfs2_meta_ecc(osb) && triggers)\n\t\tjbd2_journal_set_triggers(bh, &triggers->ot_triggers);\n\tocfs2_metadata_cache_io_unlock(ci);\n\n\tif (status < 0)\n\t\tmlog(ML_ERROR, \"Error %d getting %d access to buffer!\\n\",\n\t\t     status, type);\n\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers dq_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_dq_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n};\n\nint ocfs2_journal_access_dq(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &dq_triggers, type);\n}"
  },
  {
    "function_name": "ocfs2_journal_access_xb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "741-745",
    "snippet": "int ocfs2_journal_access_xb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &xb_triggers, type);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_triggers xb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_xattr_block, xb_check),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ocfs2_journal_access",
          "args": [
            "handle",
            "ci",
            "bh",
            "&xb_triggers",
            "type"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "650-708",
          "snippet": "static int __ocfs2_journal_access(handle_t *handle,\n\t\t\t\t  struct ocfs2_caching_info *ci,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  struct ocfs2_triggers *triggers,\n\t\t\t\t  int type)\n{\n\tint status;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(ci));\n\n\tBUG_ON(!ci || !ci->ci_ops);\n\tBUG_ON(!handle);\n\tBUG_ON(!bh);\n\n\ttrace_ocfs2_journal_access(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long)bh->b_blocknr, type, bh->b_size);\n\n\t/* we can safely remove this assertion after testing. */\n\tif (!buffer_uptodate(bh)) {\n\t\tmlog(ML_ERROR, \"giving me a buffer that's not uptodate!\\n\");\n\t\tmlog(ML_ERROR, \"b_blocknr=%llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\t\tBUG();\n\t}\n\n\t/* Set the current transaction information on the ci so\n\t * that the locking code knows whether it can drop it's locks\n\t * on this ci or not. We're protected from the commit\n\t * thread updating the current transaction id until\n\t * ocfs2_commit_trans() because ocfs2_start_trans() took\n\t * j_trans_barrier for us. */\n\tocfs2_set_ci_lock_trans(osb->journal, ci);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tswitch (type) {\n\tcase OCFS2_JOURNAL_ACCESS_CREATE:\n\tcase OCFS2_JOURNAL_ACCESS_WRITE:\n\t\tstatus = jbd2_journal_get_write_access(handle, bh);\n\t\tbreak;\n\n\tcase OCFS2_JOURNAL_ACCESS_UNDO:\n\t\tstatus = jbd2_journal_get_undo_access(handle, bh);\n\t\tbreak;\n\n\tdefault:\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Unknown access type!\\n\");\n\t}\n\tif (!status && ocfs2_meta_ecc(osb) && triggers)\n\t\tjbd2_journal_set_triggers(bh, &triggers->ot_triggers);\n\tocfs2_metadata_cache_io_unlock(ci);\n\n\tif (status < 0)\n\t\tmlog(ML_ERROR, \"Error %d getting %d access to buffer!\\n\",\n\t\t     status, type);\n\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nstatic int __ocfs2_journal_access(handle_t *handle,\n\t\t\t\t  struct ocfs2_caching_info *ci,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  struct ocfs2_triggers *triggers,\n\t\t\t\t  int type)\n{\n\tint status;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(ci));\n\n\tBUG_ON(!ci || !ci->ci_ops);\n\tBUG_ON(!handle);\n\tBUG_ON(!bh);\n\n\ttrace_ocfs2_journal_access(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long)bh->b_blocknr, type, bh->b_size);\n\n\t/* we can safely remove this assertion after testing. */\n\tif (!buffer_uptodate(bh)) {\n\t\tmlog(ML_ERROR, \"giving me a buffer that's not uptodate!\\n\");\n\t\tmlog(ML_ERROR, \"b_blocknr=%llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\t\tBUG();\n\t}\n\n\t/* Set the current transaction information on the ci so\n\t * that the locking code knows whether it can drop it's locks\n\t * on this ci or not. We're protected from the commit\n\t * thread updating the current transaction id until\n\t * ocfs2_commit_trans() because ocfs2_start_trans() took\n\t * j_trans_barrier for us. */\n\tocfs2_set_ci_lock_trans(osb->journal, ci);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tswitch (type) {\n\tcase OCFS2_JOURNAL_ACCESS_CREATE:\n\tcase OCFS2_JOURNAL_ACCESS_WRITE:\n\t\tstatus = jbd2_journal_get_write_access(handle, bh);\n\t\tbreak;\n\n\tcase OCFS2_JOURNAL_ACCESS_UNDO:\n\t\tstatus = jbd2_journal_get_undo_access(handle, bh);\n\t\tbreak;\n\n\tdefault:\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Unknown access type!\\n\");\n\t}\n\tif (!status && ocfs2_meta_ecc(osb) && triggers)\n\t\tjbd2_journal_set_triggers(bh, &triggers->ot_triggers);\n\tocfs2_metadata_cache_io_unlock(ci);\n\n\tif (status < 0)\n\t\tmlog(ML_ERROR, \"Error %d getting %d access to buffer!\\n\",\n\t\t     status, type);\n\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers xb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_xattr_block, xb_check),\n};\n\nint ocfs2_journal_access_xb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &xb_triggers, type);\n}"
  },
  {
    "function_name": "ocfs2_journal_access_db",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "735-739",
    "snippet": "int ocfs2_journal_access_db(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &db_triggers, type);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_triggers db_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_db_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ocfs2_journal_access",
          "args": [
            "handle",
            "ci",
            "bh",
            "&db_triggers",
            "type"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "650-708",
          "snippet": "static int __ocfs2_journal_access(handle_t *handle,\n\t\t\t\t  struct ocfs2_caching_info *ci,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  struct ocfs2_triggers *triggers,\n\t\t\t\t  int type)\n{\n\tint status;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(ci));\n\n\tBUG_ON(!ci || !ci->ci_ops);\n\tBUG_ON(!handle);\n\tBUG_ON(!bh);\n\n\ttrace_ocfs2_journal_access(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long)bh->b_blocknr, type, bh->b_size);\n\n\t/* we can safely remove this assertion after testing. */\n\tif (!buffer_uptodate(bh)) {\n\t\tmlog(ML_ERROR, \"giving me a buffer that's not uptodate!\\n\");\n\t\tmlog(ML_ERROR, \"b_blocknr=%llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\t\tBUG();\n\t}\n\n\t/* Set the current transaction information on the ci so\n\t * that the locking code knows whether it can drop it's locks\n\t * on this ci or not. We're protected from the commit\n\t * thread updating the current transaction id until\n\t * ocfs2_commit_trans() because ocfs2_start_trans() took\n\t * j_trans_barrier for us. */\n\tocfs2_set_ci_lock_trans(osb->journal, ci);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tswitch (type) {\n\tcase OCFS2_JOURNAL_ACCESS_CREATE:\n\tcase OCFS2_JOURNAL_ACCESS_WRITE:\n\t\tstatus = jbd2_journal_get_write_access(handle, bh);\n\t\tbreak;\n\n\tcase OCFS2_JOURNAL_ACCESS_UNDO:\n\t\tstatus = jbd2_journal_get_undo_access(handle, bh);\n\t\tbreak;\n\n\tdefault:\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Unknown access type!\\n\");\n\t}\n\tif (!status && ocfs2_meta_ecc(osb) && triggers)\n\t\tjbd2_journal_set_triggers(bh, &triggers->ot_triggers);\n\tocfs2_metadata_cache_io_unlock(ci);\n\n\tif (status < 0)\n\t\tmlog(ML_ERROR, \"Error %d getting %d access to buffer!\\n\",\n\t\t     status, type);\n\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nstatic int __ocfs2_journal_access(handle_t *handle,\n\t\t\t\t  struct ocfs2_caching_info *ci,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  struct ocfs2_triggers *triggers,\n\t\t\t\t  int type)\n{\n\tint status;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(ci));\n\n\tBUG_ON(!ci || !ci->ci_ops);\n\tBUG_ON(!handle);\n\tBUG_ON(!bh);\n\n\ttrace_ocfs2_journal_access(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long)bh->b_blocknr, type, bh->b_size);\n\n\t/* we can safely remove this assertion after testing. */\n\tif (!buffer_uptodate(bh)) {\n\t\tmlog(ML_ERROR, \"giving me a buffer that's not uptodate!\\n\");\n\t\tmlog(ML_ERROR, \"b_blocknr=%llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\t\tBUG();\n\t}\n\n\t/* Set the current transaction information on the ci so\n\t * that the locking code knows whether it can drop it's locks\n\t * on this ci or not. We're protected from the commit\n\t * thread updating the current transaction id until\n\t * ocfs2_commit_trans() because ocfs2_start_trans() took\n\t * j_trans_barrier for us. */\n\tocfs2_set_ci_lock_trans(osb->journal, ci);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tswitch (type) {\n\tcase OCFS2_JOURNAL_ACCESS_CREATE:\n\tcase OCFS2_JOURNAL_ACCESS_WRITE:\n\t\tstatus = jbd2_journal_get_write_access(handle, bh);\n\t\tbreak;\n\n\tcase OCFS2_JOURNAL_ACCESS_UNDO:\n\t\tstatus = jbd2_journal_get_undo_access(handle, bh);\n\t\tbreak;\n\n\tdefault:\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Unknown access type!\\n\");\n\t}\n\tif (!status && ocfs2_meta_ecc(osb) && triggers)\n\t\tjbd2_journal_set_triggers(bh, &triggers->ot_triggers);\n\tocfs2_metadata_cache_io_unlock(ci);\n\n\tif (status < 0)\n\t\tmlog(ML_ERROR, \"Error %d getting %d access to buffer!\\n\",\n\t\t     status, type);\n\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers db_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_db_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n};\n\nint ocfs2_journal_access_db(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &db_triggers, type);\n}"
  },
  {
    "function_name": "ocfs2_journal_access_gd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "729-733",
    "snippet": "int ocfs2_journal_access_gd(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &gd_triggers, type);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_triggers gd_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_group_desc, bg_check),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ocfs2_journal_access",
          "args": [
            "handle",
            "ci",
            "bh",
            "&gd_triggers",
            "type"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "650-708",
          "snippet": "static int __ocfs2_journal_access(handle_t *handle,\n\t\t\t\t  struct ocfs2_caching_info *ci,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  struct ocfs2_triggers *triggers,\n\t\t\t\t  int type)\n{\n\tint status;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(ci));\n\n\tBUG_ON(!ci || !ci->ci_ops);\n\tBUG_ON(!handle);\n\tBUG_ON(!bh);\n\n\ttrace_ocfs2_journal_access(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long)bh->b_blocknr, type, bh->b_size);\n\n\t/* we can safely remove this assertion after testing. */\n\tif (!buffer_uptodate(bh)) {\n\t\tmlog(ML_ERROR, \"giving me a buffer that's not uptodate!\\n\");\n\t\tmlog(ML_ERROR, \"b_blocknr=%llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\t\tBUG();\n\t}\n\n\t/* Set the current transaction information on the ci so\n\t * that the locking code knows whether it can drop it's locks\n\t * on this ci or not. We're protected from the commit\n\t * thread updating the current transaction id until\n\t * ocfs2_commit_trans() because ocfs2_start_trans() took\n\t * j_trans_barrier for us. */\n\tocfs2_set_ci_lock_trans(osb->journal, ci);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tswitch (type) {\n\tcase OCFS2_JOURNAL_ACCESS_CREATE:\n\tcase OCFS2_JOURNAL_ACCESS_WRITE:\n\t\tstatus = jbd2_journal_get_write_access(handle, bh);\n\t\tbreak;\n\n\tcase OCFS2_JOURNAL_ACCESS_UNDO:\n\t\tstatus = jbd2_journal_get_undo_access(handle, bh);\n\t\tbreak;\n\n\tdefault:\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Unknown access type!\\n\");\n\t}\n\tif (!status && ocfs2_meta_ecc(osb) && triggers)\n\t\tjbd2_journal_set_triggers(bh, &triggers->ot_triggers);\n\tocfs2_metadata_cache_io_unlock(ci);\n\n\tif (status < 0)\n\t\tmlog(ML_ERROR, \"Error %d getting %d access to buffer!\\n\",\n\t\t     status, type);\n\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nstatic int __ocfs2_journal_access(handle_t *handle,\n\t\t\t\t  struct ocfs2_caching_info *ci,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  struct ocfs2_triggers *triggers,\n\t\t\t\t  int type)\n{\n\tint status;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(ci));\n\n\tBUG_ON(!ci || !ci->ci_ops);\n\tBUG_ON(!handle);\n\tBUG_ON(!bh);\n\n\ttrace_ocfs2_journal_access(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long)bh->b_blocknr, type, bh->b_size);\n\n\t/* we can safely remove this assertion after testing. */\n\tif (!buffer_uptodate(bh)) {\n\t\tmlog(ML_ERROR, \"giving me a buffer that's not uptodate!\\n\");\n\t\tmlog(ML_ERROR, \"b_blocknr=%llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\t\tBUG();\n\t}\n\n\t/* Set the current transaction information on the ci so\n\t * that the locking code knows whether it can drop it's locks\n\t * on this ci or not. We're protected from the commit\n\t * thread updating the current transaction id until\n\t * ocfs2_commit_trans() because ocfs2_start_trans() took\n\t * j_trans_barrier for us. */\n\tocfs2_set_ci_lock_trans(osb->journal, ci);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tswitch (type) {\n\tcase OCFS2_JOURNAL_ACCESS_CREATE:\n\tcase OCFS2_JOURNAL_ACCESS_WRITE:\n\t\tstatus = jbd2_journal_get_write_access(handle, bh);\n\t\tbreak;\n\n\tcase OCFS2_JOURNAL_ACCESS_UNDO:\n\t\tstatus = jbd2_journal_get_undo_access(handle, bh);\n\t\tbreak;\n\n\tdefault:\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Unknown access type!\\n\");\n\t}\n\tif (!status && ocfs2_meta_ecc(osb) && triggers)\n\t\tjbd2_journal_set_triggers(bh, &triggers->ot_triggers);\n\tocfs2_metadata_cache_io_unlock(ci);\n\n\tif (status < 0)\n\t\tmlog(ML_ERROR, \"Error %d getting %d access to buffer!\\n\",\n\t\t     status, type);\n\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers gd_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_group_desc, bg_check),\n};\n\nint ocfs2_journal_access_gd(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &gd_triggers, type);\n}"
  },
  {
    "function_name": "ocfs2_journal_access_rb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "722-727",
    "snippet": "int ocfs2_journal_access_rb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &rb_triggers,\n\t\t\t\t      type);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_triggers rb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_refcount_block, rf_check),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ocfs2_journal_access",
          "args": [
            "handle",
            "ci",
            "bh",
            "&rb_triggers",
            "type"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "650-708",
          "snippet": "static int __ocfs2_journal_access(handle_t *handle,\n\t\t\t\t  struct ocfs2_caching_info *ci,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  struct ocfs2_triggers *triggers,\n\t\t\t\t  int type)\n{\n\tint status;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(ci));\n\n\tBUG_ON(!ci || !ci->ci_ops);\n\tBUG_ON(!handle);\n\tBUG_ON(!bh);\n\n\ttrace_ocfs2_journal_access(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long)bh->b_blocknr, type, bh->b_size);\n\n\t/* we can safely remove this assertion after testing. */\n\tif (!buffer_uptodate(bh)) {\n\t\tmlog(ML_ERROR, \"giving me a buffer that's not uptodate!\\n\");\n\t\tmlog(ML_ERROR, \"b_blocknr=%llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\t\tBUG();\n\t}\n\n\t/* Set the current transaction information on the ci so\n\t * that the locking code knows whether it can drop it's locks\n\t * on this ci or not. We're protected from the commit\n\t * thread updating the current transaction id until\n\t * ocfs2_commit_trans() because ocfs2_start_trans() took\n\t * j_trans_barrier for us. */\n\tocfs2_set_ci_lock_trans(osb->journal, ci);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tswitch (type) {\n\tcase OCFS2_JOURNAL_ACCESS_CREATE:\n\tcase OCFS2_JOURNAL_ACCESS_WRITE:\n\t\tstatus = jbd2_journal_get_write_access(handle, bh);\n\t\tbreak;\n\n\tcase OCFS2_JOURNAL_ACCESS_UNDO:\n\t\tstatus = jbd2_journal_get_undo_access(handle, bh);\n\t\tbreak;\n\n\tdefault:\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Unknown access type!\\n\");\n\t}\n\tif (!status && ocfs2_meta_ecc(osb) && triggers)\n\t\tjbd2_journal_set_triggers(bh, &triggers->ot_triggers);\n\tocfs2_metadata_cache_io_unlock(ci);\n\n\tif (status < 0)\n\t\tmlog(ML_ERROR, \"Error %d getting %d access to buffer!\\n\",\n\t\t     status, type);\n\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nstatic int __ocfs2_journal_access(handle_t *handle,\n\t\t\t\t  struct ocfs2_caching_info *ci,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  struct ocfs2_triggers *triggers,\n\t\t\t\t  int type)\n{\n\tint status;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(ci));\n\n\tBUG_ON(!ci || !ci->ci_ops);\n\tBUG_ON(!handle);\n\tBUG_ON(!bh);\n\n\ttrace_ocfs2_journal_access(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long)bh->b_blocknr, type, bh->b_size);\n\n\t/* we can safely remove this assertion after testing. */\n\tif (!buffer_uptodate(bh)) {\n\t\tmlog(ML_ERROR, \"giving me a buffer that's not uptodate!\\n\");\n\t\tmlog(ML_ERROR, \"b_blocknr=%llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\t\tBUG();\n\t}\n\n\t/* Set the current transaction information on the ci so\n\t * that the locking code knows whether it can drop it's locks\n\t * on this ci or not. We're protected from the commit\n\t * thread updating the current transaction id until\n\t * ocfs2_commit_trans() because ocfs2_start_trans() took\n\t * j_trans_barrier for us. */\n\tocfs2_set_ci_lock_trans(osb->journal, ci);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tswitch (type) {\n\tcase OCFS2_JOURNAL_ACCESS_CREATE:\n\tcase OCFS2_JOURNAL_ACCESS_WRITE:\n\t\tstatus = jbd2_journal_get_write_access(handle, bh);\n\t\tbreak;\n\n\tcase OCFS2_JOURNAL_ACCESS_UNDO:\n\t\tstatus = jbd2_journal_get_undo_access(handle, bh);\n\t\tbreak;\n\n\tdefault:\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Unknown access type!\\n\");\n\t}\n\tif (!status && ocfs2_meta_ecc(osb) && triggers)\n\t\tjbd2_journal_set_triggers(bh, &triggers->ot_triggers);\n\tocfs2_metadata_cache_io_unlock(ci);\n\n\tif (status < 0)\n\t\tmlog(ML_ERROR, \"Error %d getting %d access to buffer!\\n\",\n\t\t     status, type);\n\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers rb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_refcount_block, rf_check),\n};\n\nint ocfs2_journal_access_rb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &rb_triggers,\n\t\t\t\t      type);\n}"
  },
  {
    "function_name": "ocfs2_journal_access_eb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "716-720",
    "snippet": "int ocfs2_journal_access_eb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &eb_triggers, type);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_triggers eb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_extent_block, h_check),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ocfs2_journal_access",
          "args": [
            "handle",
            "ci",
            "bh",
            "&eb_triggers",
            "type"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "650-708",
          "snippet": "static int __ocfs2_journal_access(handle_t *handle,\n\t\t\t\t  struct ocfs2_caching_info *ci,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  struct ocfs2_triggers *triggers,\n\t\t\t\t  int type)\n{\n\tint status;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(ci));\n\n\tBUG_ON(!ci || !ci->ci_ops);\n\tBUG_ON(!handle);\n\tBUG_ON(!bh);\n\n\ttrace_ocfs2_journal_access(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long)bh->b_blocknr, type, bh->b_size);\n\n\t/* we can safely remove this assertion after testing. */\n\tif (!buffer_uptodate(bh)) {\n\t\tmlog(ML_ERROR, \"giving me a buffer that's not uptodate!\\n\");\n\t\tmlog(ML_ERROR, \"b_blocknr=%llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\t\tBUG();\n\t}\n\n\t/* Set the current transaction information on the ci so\n\t * that the locking code knows whether it can drop it's locks\n\t * on this ci or not. We're protected from the commit\n\t * thread updating the current transaction id until\n\t * ocfs2_commit_trans() because ocfs2_start_trans() took\n\t * j_trans_barrier for us. */\n\tocfs2_set_ci_lock_trans(osb->journal, ci);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tswitch (type) {\n\tcase OCFS2_JOURNAL_ACCESS_CREATE:\n\tcase OCFS2_JOURNAL_ACCESS_WRITE:\n\t\tstatus = jbd2_journal_get_write_access(handle, bh);\n\t\tbreak;\n\n\tcase OCFS2_JOURNAL_ACCESS_UNDO:\n\t\tstatus = jbd2_journal_get_undo_access(handle, bh);\n\t\tbreak;\n\n\tdefault:\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Unknown access type!\\n\");\n\t}\n\tif (!status && ocfs2_meta_ecc(osb) && triggers)\n\t\tjbd2_journal_set_triggers(bh, &triggers->ot_triggers);\n\tocfs2_metadata_cache_io_unlock(ci);\n\n\tif (status < 0)\n\t\tmlog(ML_ERROR, \"Error %d getting %d access to buffer!\\n\",\n\t\t     status, type);\n\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nstatic int __ocfs2_journal_access(handle_t *handle,\n\t\t\t\t  struct ocfs2_caching_info *ci,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  struct ocfs2_triggers *triggers,\n\t\t\t\t  int type)\n{\n\tint status;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(ci));\n\n\tBUG_ON(!ci || !ci->ci_ops);\n\tBUG_ON(!handle);\n\tBUG_ON(!bh);\n\n\ttrace_ocfs2_journal_access(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long)bh->b_blocknr, type, bh->b_size);\n\n\t/* we can safely remove this assertion after testing. */\n\tif (!buffer_uptodate(bh)) {\n\t\tmlog(ML_ERROR, \"giving me a buffer that's not uptodate!\\n\");\n\t\tmlog(ML_ERROR, \"b_blocknr=%llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\t\tBUG();\n\t}\n\n\t/* Set the current transaction information on the ci so\n\t * that the locking code knows whether it can drop it's locks\n\t * on this ci or not. We're protected from the commit\n\t * thread updating the current transaction id until\n\t * ocfs2_commit_trans() because ocfs2_start_trans() took\n\t * j_trans_barrier for us. */\n\tocfs2_set_ci_lock_trans(osb->journal, ci);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tswitch (type) {\n\tcase OCFS2_JOURNAL_ACCESS_CREATE:\n\tcase OCFS2_JOURNAL_ACCESS_WRITE:\n\t\tstatus = jbd2_journal_get_write_access(handle, bh);\n\t\tbreak;\n\n\tcase OCFS2_JOURNAL_ACCESS_UNDO:\n\t\tstatus = jbd2_journal_get_undo_access(handle, bh);\n\t\tbreak;\n\n\tdefault:\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Unknown access type!\\n\");\n\t}\n\tif (!status && ocfs2_meta_ecc(osb) && triggers)\n\t\tjbd2_journal_set_triggers(bh, &triggers->ot_triggers);\n\tocfs2_metadata_cache_io_unlock(ci);\n\n\tif (status < 0)\n\t\tmlog(ML_ERROR, \"Error %d getting %d access to buffer!\\n\",\n\t\t     status, type);\n\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers eb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_extent_block, h_check),\n};\n\nint ocfs2_journal_access_eb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &eb_triggers, type);\n}"
  },
  {
    "function_name": "ocfs2_journal_access_di",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "710-714",
    "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ocfs2_journal_access",
          "args": [
            "handle",
            "ci",
            "bh",
            "&di_triggers",
            "type"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "650-708",
          "snippet": "static int __ocfs2_journal_access(handle_t *handle,\n\t\t\t\t  struct ocfs2_caching_info *ci,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  struct ocfs2_triggers *triggers,\n\t\t\t\t  int type)\n{\n\tint status;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(ci));\n\n\tBUG_ON(!ci || !ci->ci_ops);\n\tBUG_ON(!handle);\n\tBUG_ON(!bh);\n\n\ttrace_ocfs2_journal_access(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long)bh->b_blocknr, type, bh->b_size);\n\n\t/* we can safely remove this assertion after testing. */\n\tif (!buffer_uptodate(bh)) {\n\t\tmlog(ML_ERROR, \"giving me a buffer that's not uptodate!\\n\");\n\t\tmlog(ML_ERROR, \"b_blocknr=%llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\t\tBUG();\n\t}\n\n\t/* Set the current transaction information on the ci so\n\t * that the locking code knows whether it can drop it's locks\n\t * on this ci or not. We're protected from the commit\n\t * thread updating the current transaction id until\n\t * ocfs2_commit_trans() because ocfs2_start_trans() took\n\t * j_trans_barrier for us. */\n\tocfs2_set_ci_lock_trans(osb->journal, ci);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tswitch (type) {\n\tcase OCFS2_JOURNAL_ACCESS_CREATE:\n\tcase OCFS2_JOURNAL_ACCESS_WRITE:\n\t\tstatus = jbd2_journal_get_write_access(handle, bh);\n\t\tbreak;\n\n\tcase OCFS2_JOURNAL_ACCESS_UNDO:\n\t\tstatus = jbd2_journal_get_undo_access(handle, bh);\n\t\tbreak;\n\n\tdefault:\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Unknown access type!\\n\");\n\t}\n\tif (!status && ocfs2_meta_ecc(osb) && triggers)\n\t\tjbd2_journal_set_triggers(bh, &triggers->ot_triggers);\n\tocfs2_metadata_cache_io_unlock(ci);\n\n\tif (status < 0)\n\t\tmlog(ML_ERROR, \"Error %d getting %d access to buffer!\\n\",\n\t\t     status, type);\n\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nstatic int __ocfs2_journal_access(handle_t *handle,\n\t\t\t\t  struct ocfs2_caching_info *ci,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  struct ocfs2_triggers *triggers,\n\t\t\t\t  int type)\n{\n\tint status;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(ci));\n\n\tBUG_ON(!ci || !ci->ci_ops);\n\tBUG_ON(!handle);\n\tBUG_ON(!bh);\n\n\ttrace_ocfs2_journal_access(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long)bh->b_blocknr, type, bh->b_size);\n\n\t/* we can safely remove this assertion after testing. */\n\tif (!buffer_uptodate(bh)) {\n\t\tmlog(ML_ERROR, \"giving me a buffer that's not uptodate!\\n\");\n\t\tmlog(ML_ERROR, \"b_blocknr=%llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\t\tBUG();\n\t}\n\n\t/* Set the current transaction information on the ci so\n\t * that the locking code knows whether it can drop it's locks\n\t * on this ci or not. We're protected from the commit\n\t * thread updating the current transaction id until\n\t * ocfs2_commit_trans() because ocfs2_start_trans() took\n\t * j_trans_barrier for us. */\n\tocfs2_set_ci_lock_trans(osb->journal, ci);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tswitch (type) {\n\tcase OCFS2_JOURNAL_ACCESS_CREATE:\n\tcase OCFS2_JOURNAL_ACCESS_WRITE:\n\t\tstatus = jbd2_journal_get_write_access(handle, bh);\n\t\tbreak;\n\n\tcase OCFS2_JOURNAL_ACCESS_UNDO:\n\t\tstatus = jbd2_journal_get_undo_access(handle, bh);\n\t\tbreak;\n\n\tdefault:\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Unknown access type!\\n\");\n\t}\n\tif (!status && ocfs2_meta_ecc(osb) && triggers)\n\t\tjbd2_journal_set_triggers(bh, &triggers->ot_triggers);\n\tocfs2_metadata_cache_io_unlock(ci);\n\n\tif (status < 0)\n\t\tmlog(ML_ERROR, \"Error %d getting %d access to buffer!\\n\",\n\t\t     status, type);\n\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
  },
  {
    "function_name": "__ocfs2_journal_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "650-708",
    "snippet": "static int __ocfs2_journal_access(handle_t *handle,\n\t\t\t\t  struct ocfs2_caching_info *ci,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  struct ocfs2_triggers *triggers,\n\t\t\t\t  int type)\n{\n\tint status;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(ci));\n\n\tBUG_ON(!ci || !ci->ci_ops);\n\tBUG_ON(!handle);\n\tBUG_ON(!bh);\n\n\ttrace_ocfs2_journal_access(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long)bh->b_blocknr, type, bh->b_size);\n\n\t/* we can safely remove this assertion after testing. */\n\tif (!buffer_uptodate(bh)) {\n\t\tmlog(ML_ERROR, \"giving me a buffer that's not uptodate!\\n\");\n\t\tmlog(ML_ERROR, \"b_blocknr=%llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\t\tBUG();\n\t}\n\n\t/* Set the current transaction information on the ci so\n\t * that the locking code knows whether it can drop it's locks\n\t * on this ci or not. We're protected from the commit\n\t * thread updating the current transaction id until\n\t * ocfs2_commit_trans() because ocfs2_start_trans() took\n\t * j_trans_barrier for us. */\n\tocfs2_set_ci_lock_trans(osb->journal, ci);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tswitch (type) {\n\tcase OCFS2_JOURNAL_ACCESS_CREATE:\n\tcase OCFS2_JOURNAL_ACCESS_WRITE:\n\t\tstatus = jbd2_journal_get_write_access(handle, bh);\n\t\tbreak;\n\n\tcase OCFS2_JOURNAL_ACCESS_UNDO:\n\t\tstatus = jbd2_journal_get_undo_access(handle, bh);\n\t\tbreak;\n\n\tdefault:\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Unknown access type!\\n\");\n\t}\n\tif (!status && ocfs2_meta_ecc(osb) && triggers)\n\t\tjbd2_journal_set_triggers(bh, &triggers->ot_triggers);\n\tocfs2_metadata_cache_io_unlock(ci);\n\n\tif (status < 0)\n\t\tmlog(ML_ERROR, \"Error %d getting %d access to buffer!\\n\",\n\t\t     status, type);\n\n\treturn status;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Error %d getting %d access to buffer!\\n\"",
            "status",
            "type"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_io_unlock",
          "args": [
            "ci"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_io_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "107-112",
          "snippet": "void ocfs2_metadata_cache_io_unlock(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\tci->ci_ops->co_io_unlock(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_metadata_cache_io_unlock(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\tci->ci_ops->co_io_unlock(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_set_triggers",
          "args": [
            "bh",
            "&triggers->ot_triggers"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_set_triggers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "1206-1215",
          "snippet": "void jbd2_journal_set_triggers(struct buffer_head *bh,\n\t\t\t       struct jbd2_buffer_trigger_type *type)\n{\n\tstruct journal_head *jh = jbd2_journal_grab_journal_head(bh);\n\n\tif (WARN_ON(!jh))\n\t\treturn;\n\tjh->b_triggers = type;\n\tjbd2_journal_put_journal_head(jh);\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __jbd2_journal_temp_unlink_buffer(struct journal_head *jh);",
            "static void __jbd2_journal_unfile_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __jbd2_journal_temp_unlink_buffer(struct journal_head *jh);\nstatic void __jbd2_journal_unfile_buffer(struct journal_head *jh);\n\nvoid jbd2_journal_set_triggers(struct buffer_head *bh,\n\t\t\t       struct jbd2_buffer_trigger_type *type)\n{\n\tstruct journal_head *jh = jbd2_journal_grab_journal_head(bh);\n\n\tif (WARN_ON(!jh))\n\t\treturn;\n\tjh->b_triggers = type;\n\tjbd2_journal_put_journal_head(jh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_meta_ecc",
          "args": [
            "osb"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_meta_ecc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "525-530",
          "snippet": "static inline int ocfs2_meta_ecc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_META_ECC)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_meta_ecc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_META_ECC)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Unknown access type!\\n\""
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_get_undo_access",
          "args": [
            "handle",
            "bh"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_get_undo_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "1145-1193",
          "snippet": "int jbd2_journal_get_undo_access(handle_t *handle, struct buffer_head *bh)\n{\n\tint err;\n\tstruct journal_head *jh = jbd2_journal_add_journal_head(bh);\n\tchar *committed_data = NULL;\n\n\tJBUFFER_TRACE(jh, \"entry\");\n\n\t/*\n\t * Do this first --- it can drop the journal lock, so we want to\n\t * make sure that obtaining the committed_data is done\n\t * atomically wrt. completion of any outstanding commits.\n\t */\n\terr = do_get_write_access(handle, jh, 1);\n\tif (err)\n\t\tgoto out;\n\nrepeat:\n\tif (!jh->b_committed_data) {\n\t\tcommitted_data = jbd2_alloc(jh2bh(jh)->b_size, GFP_NOFS);\n\t\tif (!committed_data) {\n\t\t\tprintk(KERN_ERR \"%s: No memory for committed data\\n\",\n\t\t\t\t__func__);\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tjbd_lock_bh_state(bh);\n\tif (!jh->b_committed_data) {\n\t\t/* Copy out the current buffer contents into the\n\t\t * preserved, committed copy. */\n\t\tJBUFFER_TRACE(jh, \"generate b_committed data\");\n\t\tif (!committed_data) {\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tjh->b_committed_data = committed_data;\n\t\tcommitted_data = NULL;\n\t\tmemcpy(jh->b_committed_data, bh->b_data, bh->b_size);\n\t}\n\tjbd_unlock_bh_state(bh);\nout:\n\tjbd2_journal_put_journal_head(jh);\n\tif (unlikely(committed_data))\n\t\tjbd2_free(committed_data, bh->b_size);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __jbd2_journal_temp_unlink_buffer(struct journal_head *jh);",
            "static void __jbd2_journal_unfile_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __jbd2_journal_temp_unlink_buffer(struct journal_head *jh);\nstatic void __jbd2_journal_unfile_buffer(struct journal_head *jh);\n\nint jbd2_journal_get_undo_access(handle_t *handle, struct buffer_head *bh)\n{\n\tint err;\n\tstruct journal_head *jh = jbd2_journal_add_journal_head(bh);\n\tchar *committed_data = NULL;\n\n\tJBUFFER_TRACE(jh, \"entry\");\n\n\t/*\n\t * Do this first --- it can drop the journal lock, so we want to\n\t * make sure that obtaining the committed_data is done\n\t * atomically wrt. completion of any outstanding commits.\n\t */\n\terr = do_get_write_access(handle, jh, 1);\n\tif (err)\n\t\tgoto out;\n\nrepeat:\n\tif (!jh->b_committed_data) {\n\t\tcommitted_data = jbd2_alloc(jh2bh(jh)->b_size, GFP_NOFS);\n\t\tif (!committed_data) {\n\t\t\tprintk(KERN_ERR \"%s: No memory for committed data\\n\",\n\t\t\t\t__func__);\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tjbd_lock_bh_state(bh);\n\tif (!jh->b_committed_data) {\n\t\t/* Copy out the current buffer contents into the\n\t\t * preserved, committed copy. */\n\t\tJBUFFER_TRACE(jh, \"generate b_committed data\");\n\t\tif (!committed_data) {\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tjh->b_committed_data = committed_data;\n\t\tcommitted_data = NULL;\n\t\tmemcpy(jh->b_committed_data, bh->b_data, bh->b_size);\n\t}\n\tjbd_unlock_bh_state(bh);\nout:\n\tjbd2_journal_put_journal_head(jh);\n\tif (unlikely(committed_data))\n\t\tjbd2_free(committed_data, bh->b_size);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_get_write_access",
          "args": [
            "handle",
            "bh"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_get_write_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "1013-1024",
          "snippet": "int jbd2_journal_get_write_access(handle_t *handle, struct buffer_head *bh)\n{\n\tstruct journal_head *jh = jbd2_journal_add_journal_head(bh);\n\tint rc;\n\n\t/* We do not want to get caught playing with fields which the\n\t * log thread also manipulates.  Make sure that the buffer\n\t * completes any outstanding IO before proceeding. */\n\trc = do_get_write_access(handle, jh, 0);\n\tjbd2_journal_put_journal_head(jh);\n\treturn rc;\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __jbd2_journal_temp_unlink_buffer(struct journal_head *jh);",
            "static void __jbd2_journal_unfile_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __jbd2_journal_temp_unlink_buffer(struct journal_head *jh);\nstatic void __jbd2_journal_unfile_buffer(struct journal_head *jh);\n\nint jbd2_journal_get_write_access(handle_t *handle, struct buffer_head *bh)\n{\n\tstruct journal_head *jh = jbd2_journal_add_journal_head(bh);\n\tint rc;\n\n\t/* We do not want to get caught playing with fields which the\n\t * log thread also manipulates.  Make sure that the buffer\n\t * completes any outstanding IO before proceeding. */\n\trc = do_get_write_access(handle, jh, 0);\n\tjbd2_journal_put_journal_head(jh);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_io_lock",
          "args": [
            "ci"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_io_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "100-105",
          "snippet": "void ocfs2_metadata_cache_io_lock(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\tci->ci_ops->co_io_lock(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_metadata_cache_io_lock(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\tci->ci_ops->co_io_lock(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_set_ci_lock_trans",
          "args": [
            "osb->journal",
            "ci"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_ci_lock_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "94-100",
          "snippet": "static inline void ocfs2_set_ci_lock_trans(struct ocfs2_journal *journal,\n\t\t\t\t\t   struct ocfs2_caching_info *ci)\n{\n\tspin_lock(&trans_inc_lock);\n\tci->ci_last_trans = journal->j_trans_id;\n\tspin_unlock(&trans_inc_lock);\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_set_ci_lock_trans(struct ocfs2_journal *journal,\n\t\t\t\t\t   struct ocfs2_caching_info *ci)\n{\n\tspin_lock(&trans_inc_lock);\n\tci->ci_last_trans = journal->j_trans_id;\n\tspin_unlock(&trans_inc_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"b_blocknr=%llu\\n\"",
            "(unsigned long long)bh->b_blocknr"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_journal_access",
          "args": [
            "(unsigned long long)ocfs2_metadata_cache_owner(ci)",
            "(unsigned long long)bh->b_blocknr",
            "type",
            "bh->b_size"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_owner",
          "args": [
            "ci"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "72-77",
          "snippet": "u64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!bh"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!handle"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ci || !ci->ci_ops"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "ocfs2_metadata_cache_get_super(ci)"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "ci"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nstatic int __ocfs2_journal_access(handle_t *handle,\n\t\t\t\t  struct ocfs2_caching_info *ci,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  struct ocfs2_triggers *triggers,\n\t\t\t\t  int type)\n{\n\tint status;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(ci));\n\n\tBUG_ON(!ci || !ci->ci_ops);\n\tBUG_ON(!handle);\n\tBUG_ON(!bh);\n\n\ttrace_ocfs2_journal_access(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long)bh->b_blocknr, type, bh->b_size);\n\n\t/* we can safely remove this assertion after testing. */\n\tif (!buffer_uptodate(bh)) {\n\t\tmlog(ML_ERROR, \"giving me a buffer that's not uptodate!\\n\");\n\t\tmlog(ML_ERROR, \"b_blocknr=%llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\t\tBUG();\n\t}\n\n\t/* Set the current transaction information on the ci so\n\t * that the locking code knows whether it can drop it's locks\n\t * on this ci or not. We're protected from the commit\n\t * thread updating the current transaction id until\n\t * ocfs2_commit_trans() because ocfs2_start_trans() took\n\t * j_trans_barrier for us. */\n\tocfs2_set_ci_lock_trans(osb->journal, ci);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tswitch (type) {\n\tcase OCFS2_JOURNAL_ACCESS_CREATE:\n\tcase OCFS2_JOURNAL_ACCESS_WRITE:\n\t\tstatus = jbd2_journal_get_write_access(handle, bh);\n\t\tbreak;\n\n\tcase OCFS2_JOURNAL_ACCESS_UNDO:\n\t\tstatus = jbd2_journal_get_undo_access(handle, bh);\n\t\tbreak;\n\n\tdefault:\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Unknown access type!\\n\");\n\t}\n\tif (!status && ocfs2_meta_ecc(osb) && triggers)\n\t\tjbd2_journal_set_triggers(bh, &triggers->ot_triggers);\n\tocfs2_metadata_cache_io_unlock(ci);\n\n\tif (status < 0)\n\t\tmlog(ML_ERROR, \"Error %d getting %d access to buffer!\\n\",\n\t\t     status, type);\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_abort_trigger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "565-578",
    "snippet": "static void ocfs2_abort_trigger(struct jbd2_buffer_trigger_type *triggers,\n\t\t\t\tstruct buffer_head *bh)\n{\n\tmlog(ML_ERROR,\n\t     \"ocfs2_abort_trigger called by JBD2.  bh = 0x%lx, \"\n\t     \"bh->b_blocknr = %llu\\n\",\n\t     (unsigned long)bh,\n\t     (unsigned long long)bh->b_blocknr);\n\n\t/* We aren't guaranteed to have the superblock here - but if we\n\t * don't, it'll just crash. */\n\tocfs2_error(bh->b_assoc_map->host->i_sb,\n\t\t    \"JBD2 has aborted our journal, ocfs2 cannot continue\\n\");\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "bh->b_assoc_map->host->i_sb",
            "\"JBD2 has aborted our journal, ocfs2 cannot continue\\n\""
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"ocfs2_abort_trigger called by JBD2.  bh = 0x%lx, \"\n\t     \"bh->b_blocknr = %llu\\n\"",
            "(unsigned long)bh",
            "(unsigned long long)bh->b_blocknr"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_abort_trigger(struct jbd2_buffer_trigger_type *triggers,\n\t\t\t\tstruct buffer_head *bh)\n{\n\tmlog(ML_ERROR,\n\t     \"ocfs2_abort_trigger called by JBD2.  bh = 0x%lx, \"\n\t     \"bh->b_blocknr = %llu\\n\",\n\t     (unsigned long)bh,\n\t     (unsigned long long)bh->b_blocknr);\n\n\t/* We aren't guaranteed to have the superblock here - but if we\n\t * don't, it'll just crash. */\n\tocfs2_error(bh->b_assoc_map->host->i_sb,\n\t\t    \"JBD2 has aborted our journal, ocfs2 cannot continue\\n\");\n}"
  },
  {
    "function_name": "ocfs2_db_frozen_trigger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "549-563",
    "snippet": "static void ocfs2_db_frozen_trigger(struct jbd2_buffer_trigger_type *triggers,\n\t\t\t\t struct buffer_head *bh,\n\t\t\t\t void *data, size_t size)\n{\n\tstruct ocfs2_dir_block_trailer *trailer =\n\t\tocfs2_dir_trailer_from_size(size, data);\n\n\t/*\n\t * We aren't guaranteed to have the superblock here, so we\n\t * must unconditionally compute the ecc data.\n\t * __ocfs2_journal_access() will only set the triggers if\n\t * metaecc is enabled.\n\t */\n\tocfs2_block_check_compute(data, size, &trailer->db_check);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_block_check_compute",
          "args": [
            "data",
            "size",
            "&trailer->db_check"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_block_check_compute_bhs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "483-516",
          "snippet": "void ocfs2_block_check_compute_bhs(struct buffer_head **bhs, int nr,\n\t\t\t\t   struct ocfs2_block_check *bc)\n{\n\tint i;\n\tu32 crc, ecc;\n\n\tBUG_ON(nr < 0);\n\n\tif (!nr)\n\t\treturn;\n\n\tmemset(bc, 0, sizeof(struct ocfs2_block_check));\n\n\tfor (i = 0, crc = ~0, ecc = 0; i < nr; i++) {\n\t\tcrc = crc32_le(crc, bhs[i]->b_data, bhs[i]->b_size);\n\t\t/*\n\t\t * The number of bits in a buffer is obviously b_size*8.\n\t\t * The offset of this buffer is b_size*i, so the bit offset\n\t\t * of this buffer is b_size*8*i.\n\t\t */\n\t\tecc = (u16)ocfs2_hamming_encode(ecc, bhs[i]->b_data,\n\t\t\t\t\t\tbhs[i]->b_size * 8,\n\t\t\t\t\t\tbhs[i]->b_size * 8 * i);\n\t}\n\n\t/*\n\t * No ecc'd ocfs2 structure is larger than 4K, so ecc will be no\n\t * larger than 16 bits.\n\t */\n\tBUG_ON(ecc > USHRT_MAX);\n\n\tbc->bc_crc32e = cpu_to_le32(crc);\n\tbc->bc_ecc = cpu_to_le16((u16)ecc);\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid ocfs2_block_check_compute_bhs(struct buffer_head **bhs, int nr,\n\t\t\t\t   struct ocfs2_block_check *bc)\n{\n\tint i;\n\tu32 crc, ecc;\n\n\tBUG_ON(nr < 0);\n\n\tif (!nr)\n\t\treturn;\n\n\tmemset(bc, 0, sizeof(struct ocfs2_block_check));\n\n\tfor (i = 0, crc = ~0, ecc = 0; i < nr; i++) {\n\t\tcrc = crc32_le(crc, bhs[i]->b_data, bhs[i]->b_size);\n\t\t/*\n\t\t * The number of bits in a buffer is obviously b_size*8.\n\t\t * The offset of this buffer is b_size*i, so the bit offset\n\t\t * of this buffer is b_size*8*i.\n\t\t */\n\t\tecc = (u16)ocfs2_hamming_encode(ecc, bhs[i]->b_data,\n\t\t\t\t\t\tbhs[i]->b_size * 8,\n\t\t\t\t\t\tbhs[i]->b_size * 8 * i);\n\t}\n\n\t/*\n\t * No ecc'd ocfs2 structure is larger than 4K, so ecc will be no\n\t * larger than 16 bits.\n\t */\n\tBUG_ON(ecc > USHRT_MAX);\n\n\tbc->bc_crc32e = cpu_to_le32(crc);\n\tbc->bc_ecc = cpu_to_le16((u16)ecc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dir_trailer_from_size",
          "args": [
            "size",
            "data"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dir_trailer_from_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "123-130",
          "snippet": "struct ocfs2_dir_block_trailer *ocfs2_dir_trailer_from_size(int blocksize,\n\t\t\t\t\t\t\t    void *data)\n{\n\tchar *p = data;\n\n\tp += blocksize - sizeof(struct ocfs2_dir_block_trailer);\n\treturn (struct ocfs2_dir_block_trailer *)p;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct ocfs2_dir_block_trailer *ocfs2_dir_trailer_from_size(int blocksize,\n\t\t\t\t\t\t\t    void *data)\n{\n\tchar *p = data;\n\n\tp += blocksize - sizeof(struct ocfs2_dir_block_trailer);\n\treturn (struct ocfs2_dir_block_trailer *)p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_db_frozen_trigger(struct jbd2_buffer_trigger_type *triggers,\n\t\t\t\t struct buffer_head *bh,\n\t\t\t\t void *data, size_t size)\n{\n\tstruct ocfs2_dir_block_trailer *trailer =\n\t\tocfs2_dir_trailer_from_size(size, data);\n\n\t/*\n\t * We aren't guaranteed to have the superblock here, so we\n\t * must unconditionally compute the ecc data.\n\t * __ocfs2_journal_access() will only set the triggers if\n\t * metaecc is enabled.\n\t */\n\tocfs2_block_check_compute(data, size, &trailer->db_check);\n}"
  },
  {
    "function_name": "ocfs2_dq_frozen_trigger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "529-543",
    "snippet": "static void ocfs2_dq_frozen_trigger(struct jbd2_buffer_trigger_type *triggers,\n\t\t\t\t struct buffer_head *bh,\n\t\t\t\t void *data, size_t size)\n{\n\tstruct ocfs2_disk_dqtrailer *dqt =\n\t\tocfs2_block_dqtrailer(size, data);\n\n\t/*\n\t * We aren't guaranteed to have the superblock here, so we\n\t * must unconditionally compute the ecc data.\n\t * __ocfs2_journal_access() will only set the triggers if\n\t * metaecc is enabled.\n\t */\n\tocfs2_block_check_compute(data, size, &dqt->dq_check);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_block_check_compute",
          "args": [
            "data",
            "size",
            "&dqt->dq_check"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_block_check_compute_bhs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "483-516",
          "snippet": "void ocfs2_block_check_compute_bhs(struct buffer_head **bhs, int nr,\n\t\t\t\t   struct ocfs2_block_check *bc)\n{\n\tint i;\n\tu32 crc, ecc;\n\n\tBUG_ON(nr < 0);\n\n\tif (!nr)\n\t\treturn;\n\n\tmemset(bc, 0, sizeof(struct ocfs2_block_check));\n\n\tfor (i = 0, crc = ~0, ecc = 0; i < nr; i++) {\n\t\tcrc = crc32_le(crc, bhs[i]->b_data, bhs[i]->b_size);\n\t\t/*\n\t\t * The number of bits in a buffer is obviously b_size*8.\n\t\t * The offset of this buffer is b_size*i, so the bit offset\n\t\t * of this buffer is b_size*8*i.\n\t\t */\n\t\tecc = (u16)ocfs2_hamming_encode(ecc, bhs[i]->b_data,\n\t\t\t\t\t\tbhs[i]->b_size * 8,\n\t\t\t\t\t\tbhs[i]->b_size * 8 * i);\n\t}\n\n\t/*\n\t * No ecc'd ocfs2 structure is larger than 4K, so ecc will be no\n\t * larger than 16 bits.\n\t */\n\tBUG_ON(ecc > USHRT_MAX);\n\n\tbc->bc_crc32e = cpu_to_le32(crc);\n\tbc->bc_ecc = cpu_to_le16((u16)ecc);\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid ocfs2_block_check_compute_bhs(struct buffer_head **bhs, int nr,\n\t\t\t\t   struct ocfs2_block_check *bc)\n{\n\tint i;\n\tu32 crc, ecc;\n\n\tBUG_ON(nr < 0);\n\n\tif (!nr)\n\t\treturn;\n\n\tmemset(bc, 0, sizeof(struct ocfs2_block_check));\n\n\tfor (i = 0, crc = ~0, ecc = 0; i < nr; i++) {\n\t\tcrc = crc32_le(crc, bhs[i]->b_data, bhs[i]->b_size);\n\t\t/*\n\t\t * The number of bits in a buffer is obviously b_size*8.\n\t\t * The offset of this buffer is b_size*i, so the bit offset\n\t\t * of this buffer is b_size*8*i.\n\t\t */\n\t\tecc = (u16)ocfs2_hamming_encode(ecc, bhs[i]->b_data,\n\t\t\t\t\t\tbhs[i]->b_size * 8,\n\t\t\t\t\t\tbhs[i]->b_size * 8 * i);\n\t}\n\n\t/*\n\t * No ecc'd ocfs2 structure is larger than 4K, so ecc will be no\n\t * larger than 16 bits.\n\t */\n\tBUG_ON(ecc > USHRT_MAX);\n\n\tbc->bc_crc32e = cpu_to_le32(crc);\n\tbc->bc_ecc = cpu_to_le16((u16)ecc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_block_dqtrailer",
          "args": [
            "size",
            "data"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_block_dqtrailer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1271-1278",
          "snippet": "static inline struct ocfs2_disk_dqtrailer *ocfs2_block_dqtrailer(int blocksize,\n\t\t\t\t\t\t\t\t void *buf)\n{\n\tchar *ptr = buf;\n\tptr += blocksize - OCFS2_QBLK_RESERVED_SPACE;\n\n\treturn (struct ocfs2_disk_dqtrailer *)ptr;\n}",
          "includes": [],
          "macros_used": [
            "#define OCFS2_QBLK_RESERVED_SPACE 8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define OCFS2_QBLK_RESERVED_SPACE 8\n\nstatic inline struct ocfs2_disk_dqtrailer *ocfs2_block_dqtrailer(int blocksize,\n\t\t\t\t\t\t\t\t void *buf)\n{\n\tchar *ptr = buf;\n\tptr += blocksize - OCFS2_QBLK_RESERVED_SPACE;\n\n\treturn (struct ocfs2_disk_dqtrailer *)ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dq_frozen_trigger(struct jbd2_buffer_trigger_type *triggers,\n\t\t\t\t struct buffer_head *bh,\n\t\t\t\t void *data, size_t size)\n{\n\tstruct ocfs2_disk_dqtrailer *dqt =\n\t\tocfs2_block_dqtrailer(size, data);\n\n\t/*\n\t * We aren't guaranteed to have the superblock here, so we\n\t * must unconditionally compute the ecc data.\n\t * __ocfs2_journal_access() will only set the triggers if\n\t * metaecc is enabled.\n\t */\n\tocfs2_block_check_compute(data, size, &dqt->dq_check);\n}"
  },
  {
    "function_name": "ocfs2_frozen_trigger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "510-523",
    "snippet": "static void ocfs2_frozen_trigger(struct jbd2_buffer_trigger_type *triggers,\n\t\t\t\t struct buffer_head *bh,\n\t\t\t\t void *data, size_t size)\n{\n\tstruct ocfs2_triggers *ot = to_ocfs2_trigger(triggers);\n\n\t/*\n\t * We aren't guaranteed to have the superblock here, so we\n\t * must unconditionally compute the ecc data.\n\t * __ocfs2_journal_access() will only set the triggers if\n\t * metaecc is enabled.\n\t */\n\tocfs2_block_check_compute(data, size, data + ot->ot_offset);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_block_check_compute",
          "args": [
            "data",
            "size",
            "data + ot->ot_offset"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_block_check_compute_bhs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "483-516",
          "snippet": "void ocfs2_block_check_compute_bhs(struct buffer_head **bhs, int nr,\n\t\t\t\t   struct ocfs2_block_check *bc)\n{\n\tint i;\n\tu32 crc, ecc;\n\n\tBUG_ON(nr < 0);\n\n\tif (!nr)\n\t\treturn;\n\n\tmemset(bc, 0, sizeof(struct ocfs2_block_check));\n\n\tfor (i = 0, crc = ~0, ecc = 0; i < nr; i++) {\n\t\tcrc = crc32_le(crc, bhs[i]->b_data, bhs[i]->b_size);\n\t\t/*\n\t\t * The number of bits in a buffer is obviously b_size*8.\n\t\t * The offset of this buffer is b_size*i, so the bit offset\n\t\t * of this buffer is b_size*8*i.\n\t\t */\n\t\tecc = (u16)ocfs2_hamming_encode(ecc, bhs[i]->b_data,\n\t\t\t\t\t\tbhs[i]->b_size * 8,\n\t\t\t\t\t\tbhs[i]->b_size * 8 * i);\n\t}\n\n\t/*\n\t * No ecc'd ocfs2 structure is larger than 4K, so ecc will be no\n\t * larger than 16 bits.\n\t */\n\tBUG_ON(ecc > USHRT_MAX);\n\n\tbc->bc_crc32e = cpu_to_le32(crc);\n\tbc->bc_ecc = cpu_to_le16((u16)ecc);\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid ocfs2_block_check_compute_bhs(struct buffer_head **bhs, int nr,\n\t\t\t\t   struct ocfs2_block_check *bc)\n{\n\tint i;\n\tu32 crc, ecc;\n\n\tBUG_ON(nr < 0);\n\n\tif (!nr)\n\t\treturn;\n\n\tmemset(bc, 0, sizeof(struct ocfs2_block_check));\n\n\tfor (i = 0, crc = ~0, ecc = 0; i < nr; i++) {\n\t\tcrc = crc32_le(crc, bhs[i]->b_data, bhs[i]->b_size);\n\t\t/*\n\t\t * The number of bits in a buffer is obviously b_size*8.\n\t\t * The offset of this buffer is b_size*i, so the bit offset\n\t\t * of this buffer is b_size*8*i.\n\t\t */\n\t\tecc = (u16)ocfs2_hamming_encode(ecc, bhs[i]->b_data,\n\t\t\t\t\t\tbhs[i]->b_size * 8,\n\t\t\t\t\t\tbhs[i]->b_size * 8 * i);\n\t}\n\n\t/*\n\t * No ecc'd ocfs2 structure is larger than 4K, so ecc will be no\n\t * larger than 16 bits.\n\t */\n\tBUG_ON(ecc > USHRT_MAX);\n\n\tbc->bc_crc32e = cpu_to_le32(crc);\n\tbc->bc_ecc = cpu_to_le16((u16)ecc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_ocfs2_trigger",
          "args": [
            "triggers"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "to_ocfs2_trigger",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "505-508",
          "snippet": "static inline struct ocfs2_triggers *to_ocfs2_trigger(struct jbd2_buffer_trigger_type *triggers)\n{\n\treturn container_of(triggers, struct ocfs2_triggers, ot_triggers);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline struct ocfs2_triggers *to_ocfs2_trigger(struct jbd2_buffer_trigger_type *triggers)\n{\n\treturn container_of(triggers, struct ocfs2_triggers, ot_triggers);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_frozen_trigger(struct jbd2_buffer_trigger_type *triggers,\n\t\t\t\t struct buffer_head *bh,\n\t\t\t\t void *data, size_t size)\n{\n\tstruct ocfs2_triggers *ot = to_ocfs2_trigger(triggers);\n\n\t/*\n\t * We aren't guaranteed to have the superblock here, so we\n\t * must unconditionally compute the ecc data.\n\t * __ocfs2_journal_access() will only set the triggers if\n\t * metaecc is enabled.\n\t */\n\tocfs2_block_check_compute(data, size, data + ot->ot_offset);\n}"
  },
  {
    "function_name": "to_ocfs2_trigger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "505-508",
    "snippet": "static inline struct ocfs2_triggers *to_ocfs2_trigger(struct jbd2_buffer_trigger_type *triggers)\n{\n\treturn container_of(triggers, struct ocfs2_triggers, ot_triggers);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "triggers",
            "structocfs2_triggers",
            "ot_triggers"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline struct ocfs2_triggers *to_ocfs2_trigger(struct jbd2_buffer_trigger_type *triggers)\n{\n\treturn container_of(triggers, struct ocfs2_triggers, ot_triggers);\n}"
  },
  {
    "function_name": "ocfs2_allocate_extend_trans",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "471-497",
    "snippet": "int ocfs2_allocate_extend_trans(handle_t *handle, int thresh)\n{\n\tint status, old_nblks;\n\n\tBUG_ON(!handle);\n\n\told_nblks = handle->h_buffer_credits;\n\ttrace_ocfs2_allocate_extend_trans(old_nblks, thresh);\n\n\tif (old_nblks < thresh)\n\t\treturn 0;\n\n\tstatus = jbd2_journal_extend(handle, OCFS2_MAX_TRANS_DATA);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (status > 0) {\n\t\tstatus = jbd2_journal_restart(handle, OCFS2_MAX_TRANS_DATA);\n\t\tif (status < 0)\n\t\t\tmlog_errno(status);\n\t}\n\nbail:\n\treturn status;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_restart",
          "args": [
            "handle",
            "OCFS2_MAX_TRANS_DATA"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_restart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "673-676",
          "snippet": "int jbd2_journal_restart(handle_t *handle, int nblocks)\n{\n\treturn jbd2__journal_restart(handle, nblocks, GFP_NOFS);\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint jbd2_journal_restart(handle_t *handle, int nblocks)\n{\n\treturn jbd2__journal_restart(handle, nblocks, GFP_NOFS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_extend",
          "args": [
            "handle",
            "OCFS2_MAX_TRANS_DATA"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_extend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "547-605",
          "snippet": "int jbd2_journal_extend(handle_t *handle, int nblocks)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal;\n\tint result;\n\tint wanted;\n\n\tWARN_ON(!transaction);\n\tif (is_handle_aborted(handle))\n\t\treturn -EROFS;\n\tjournal = transaction->t_journal;\n\n\tresult = 1;\n\n\tread_lock(&journal->j_state_lock);\n\n\t/* Don't extend a locked-down transaction! */\n\tif (transaction->t_state != T_RUNNING) {\n\t\tjbd_debug(3, \"denied handle %p %d blocks: \"\n\t\t\t  \"transaction not running\\n\", handle, nblocks);\n\t\tgoto error_out;\n\t}\n\n\tspin_lock(&transaction->t_handle_lock);\n\twanted = atomic_add_return(nblocks,\n\t\t\t\t   &transaction->t_outstanding_credits);\n\n\tif (wanted > journal->j_max_transaction_buffers) {\n\t\tjbd_debug(3, \"denied handle %p %d blocks: \"\n\t\t\t  \"transaction too large\\n\", handle, nblocks);\n\t\tatomic_sub(nblocks, &transaction->t_outstanding_credits);\n\t\tgoto unlock;\n\t}\n\n\tif (wanted + (wanted >> JBD2_CONTROL_BLOCKS_SHIFT) >\n\t    jbd2_log_space_left(journal)) {\n\t\tjbd_debug(3, \"denied handle %p %d blocks: \"\n\t\t\t  \"insufficient log space\\n\", handle, nblocks);\n\t\tatomic_sub(nblocks, &transaction->t_outstanding_credits);\n\t\tgoto unlock;\n\t}\n\n\ttrace_jbd2_handle_extend(journal->j_fs_dev->bd_dev,\n\t\t\t\t transaction->t_tid,\n\t\t\t\t handle->h_type, handle->h_line_no,\n\t\t\t\t handle->h_buffer_credits,\n\t\t\t\t nblocks);\n\n\thandle->h_buffer_credits += nblocks;\n\thandle->h_requested_credits += nblocks;\n\tresult = 0;\n\n\tjbd_debug(3, \"extended handle %p by %d\\n\", handle, nblocks);\nunlock:\n\tspin_unlock(&transaction->t_handle_lock);\nerror_out:\n\tread_unlock(&journal->j_state_lock);\n\treturn result;\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint jbd2_journal_extend(handle_t *handle, int nblocks)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal;\n\tint result;\n\tint wanted;\n\n\tWARN_ON(!transaction);\n\tif (is_handle_aborted(handle))\n\t\treturn -EROFS;\n\tjournal = transaction->t_journal;\n\n\tresult = 1;\n\n\tread_lock(&journal->j_state_lock);\n\n\t/* Don't extend a locked-down transaction! */\n\tif (transaction->t_state != T_RUNNING) {\n\t\tjbd_debug(3, \"denied handle %p %d blocks: \"\n\t\t\t  \"transaction not running\\n\", handle, nblocks);\n\t\tgoto error_out;\n\t}\n\n\tspin_lock(&transaction->t_handle_lock);\n\twanted = atomic_add_return(nblocks,\n\t\t\t\t   &transaction->t_outstanding_credits);\n\n\tif (wanted > journal->j_max_transaction_buffers) {\n\t\tjbd_debug(3, \"denied handle %p %d blocks: \"\n\t\t\t  \"transaction too large\\n\", handle, nblocks);\n\t\tatomic_sub(nblocks, &transaction->t_outstanding_credits);\n\t\tgoto unlock;\n\t}\n\n\tif (wanted + (wanted >> JBD2_CONTROL_BLOCKS_SHIFT) >\n\t    jbd2_log_space_left(journal)) {\n\t\tjbd_debug(3, \"denied handle %p %d blocks: \"\n\t\t\t  \"insufficient log space\\n\", handle, nblocks);\n\t\tatomic_sub(nblocks, &transaction->t_outstanding_credits);\n\t\tgoto unlock;\n\t}\n\n\ttrace_jbd2_handle_extend(journal->j_fs_dev->bd_dev,\n\t\t\t\t transaction->t_tid,\n\t\t\t\t handle->h_type, handle->h_line_no,\n\t\t\t\t handle->h_buffer_credits,\n\t\t\t\t nblocks);\n\n\thandle->h_buffer_credits += nblocks;\n\thandle->h_requested_credits += nblocks;\n\tresult = 0;\n\n\tjbd_debug(3, \"extended handle %p by %d\\n\", handle, nblocks);\nunlock:\n\tspin_unlock(&transaction->t_handle_lock);\nerror_out:\n\tread_unlock(&journal->j_state_lock);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_allocate_extend_trans",
          "args": [
            "old_nblks",
            "thresh"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!handle"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_allocate_extend_trans(handle_t *handle, int thresh)\n{\n\tint status, old_nblks;\n\n\tBUG_ON(!handle);\n\n\told_nblks = handle->h_buffer_credits;\n\ttrace_ocfs2_allocate_extend_trans(old_nblks, thresh);\n\n\tif (old_nblks < thresh)\n\t\treturn 0;\n\n\tstatus = jbd2_journal_extend(handle, OCFS2_MAX_TRANS_DATA);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (status > 0) {\n\t\tstatus = jbd2_journal_restart(handle, OCFS2_MAX_TRANS_DATA);\n\t\tif (status < 0)\n\t\t\tmlog_errno(status);\n\t}\n\nbail:\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_extend_trans",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "426-463",
    "snippet": "int ocfs2_extend_trans(handle_t *handle, int nblocks)\n{\n\tint status, old_nblocks;\n\n\tBUG_ON(!handle);\n\tBUG_ON(nblocks < 0);\n\n\tif (!nblocks)\n\t\treturn 0;\n\n\told_nblocks = handle->h_buffer_credits;\n\n\ttrace_ocfs2_extend_trans(old_nblocks, nblocks);\n\n#ifdef CONFIG_OCFS2_DEBUG_FS\n\tstatus = 1;\n#else\n\tstatus = jbd2_journal_extend(handle, nblocks);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n#endif\n\n\tif (status > 0) {\n\t\ttrace_ocfs2_extend_trans_restart(old_nblocks + nblocks);\n\t\tstatus = jbd2_journal_restart(handle,\n\t\t\t\t\t      old_nblocks + nblocks);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\nbail:\n\treturn status;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_restart",
          "args": [
            "handle",
            "old_nblocks + nblocks"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_restart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "673-676",
          "snippet": "int jbd2_journal_restart(handle_t *handle, int nblocks)\n{\n\treturn jbd2__journal_restart(handle, nblocks, GFP_NOFS);\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint jbd2_journal_restart(handle_t *handle, int nblocks)\n{\n\treturn jbd2__journal_restart(handle, nblocks, GFP_NOFS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_extend_trans_restart",
          "args": [
            "old_nblocks + nblocks"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_extend",
          "args": [
            "handle",
            "nblocks"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_extend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "547-605",
          "snippet": "int jbd2_journal_extend(handle_t *handle, int nblocks)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal;\n\tint result;\n\tint wanted;\n\n\tWARN_ON(!transaction);\n\tif (is_handle_aborted(handle))\n\t\treturn -EROFS;\n\tjournal = transaction->t_journal;\n\n\tresult = 1;\n\n\tread_lock(&journal->j_state_lock);\n\n\t/* Don't extend a locked-down transaction! */\n\tif (transaction->t_state != T_RUNNING) {\n\t\tjbd_debug(3, \"denied handle %p %d blocks: \"\n\t\t\t  \"transaction not running\\n\", handle, nblocks);\n\t\tgoto error_out;\n\t}\n\n\tspin_lock(&transaction->t_handle_lock);\n\twanted = atomic_add_return(nblocks,\n\t\t\t\t   &transaction->t_outstanding_credits);\n\n\tif (wanted > journal->j_max_transaction_buffers) {\n\t\tjbd_debug(3, \"denied handle %p %d blocks: \"\n\t\t\t  \"transaction too large\\n\", handle, nblocks);\n\t\tatomic_sub(nblocks, &transaction->t_outstanding_credits);\n\t\tgoto unlock;\n\t}\n\n\tif (wanted + (wanted >> JBD2_CONTROL_BLOCKS_SHIFT) >\n\t    jbd2_log_space_left(journal)) {\n\t\tjbd_debug(3, \"denied handle %p %d blocks: \"\n\t\t\t  \"insufficient log space\\n\", handle, nblocks);\n\t\tatomic_sub(nblocks, &transaction->t_outstanding_credits);\n\t\tgoto unlock;\n\t}\n\n\ttrace_jbd2_handle_extend(journal->j_fs_dev->bd_dev,\n\t\t\t\t transaction->t_tid,\n\t\t\t\t handle->h_type, handle->h_line_no,\n\t\t\t\t handle->h_buffer_credits,\n\t\t\t\t nblocks);\n\n\thandle->h_buffer_credits += nblocks;\n\thandle->h_requested_credits += nblocks;\n\tresult = 0;\n\n\tjbd_debug(3, \"extended handle %p by %d\\n\", handle, nblocks);\nunlock:\n\tspin_unlock(&transaction->t_handle_lock);\nerror_out:\n\tread_unlock(&journal->j_state_lock);\n\treturn result;\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint jbd2_journal_extend(handle_t *handle, int nblocks)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal;\n\tint result;\n\tint wanted;\n\n\tWARN_ON(!transaction);\n\tif (is_handle_aborted(handle))\n\t\treturn -EROFS;\n\tjournal = transaction->t_journal;\n\n\tresult = 1;\n\n\tread_lock(&journal->j_state_lock);\n\n\t/* Don't extend a locked-down transaction! */\n\tif (transaction->t_state != T_RUNNING) {\n\t\tjbd_debug(3, \"denied handle %p %d blocks: \"\n\t\t\t  \"transaction not running\\n\", handle, nblocks);\n\t\tgoto error_out;\n\t}\n\n\tspin_lock(&transaction->t_handle_lock);\n\twanted = atomic_add_return(nblocks,\n\t\t\t\t   &transaction->t_outstanding_credits);\n\n\tif (wanted > journal->j_max_transaction_buffers) {\n\t\tjbd_debug(3, \"denied handle %p %d blocks: \"\n\t\t\t  \"transaction too large\\n\", handle, nblocks);\n\t\tatomic_sub(nblocks, &transaction->t_outstanding_credits);\n\t\tgoto unlock;\n\t}\n\n\tif (wanted + (wanted >> JBD2_CONTROL_BLOCKS_SHIFT) >\n\t    jbd2_log_space_left(journal)) {\n\t\tjbd_debug(3, \"denied handle %p %d blocks: \"\n\t\t\t  \"insufficient log space\\n\", handle, nblocks);\n\t\tatomic_sub(nblocks, &transaction->t_outstanding_credits);\n\t\tgoto unlock;\n\t}\n\n\ttrace_jbd2_handle_extend(journal->j_fs_dev->bd_dev,\n\t\t\t\t transaction->t_tid,\n\t\t\t\t handle->h_type, handle->h_line_no,\n\t\t\t\t handle->h_buffer_credits,\n\t\t\t\t nblocks);\n\n\thandle->h_buffer_credits += nblocks;\n\thandle->h_requested_credits += nblocks;\n\tresult = 0;\n\n\tjbd_debug(3, \"extended handle %p by %d\\n\", handle, nblocks);\nunlock:\n\tspin_unlock(&transaction->t_handle_lock);\nerror_out:\n\tread_unlock(&journal->j_state_lock);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_extend_trans",
          "args": [
            "old_nblocks",
            "nblocks"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "nblocks < 0"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!handle"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_extend_trans(handle_t *handle, int nblocks)\n{\n\tint status, old_nblocks;\n\n\tBUG_ON(!handle);\n\tBUG_ON(nblocks < 0);\n\n\tif (!nblocks)\n\t\treturn 0;\n\n\told_nblocks = handle->h_buffer_credits;\n\n\ttrace_ocfs2_extend_trans(old_nblocks, nblocks);\n\n#ifdef CONFIG_OCFS2_DEBUG_FS\n\tstatus = 1;\n#else\n\tstatus = jbd2_journal_extend(handle, nblocks);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n#endif\n\n\tif (status > 0) {\n\t\ttrace_ocfs2_extend_trans_restart(old_nblocks + nblocks);\n\t\tstatus = jbd2_journal_restart(handle,\n\t\t\t\t\t      old_nblocks + nblocks);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\nbail:\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_commit_trans",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "388-407",
    "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sb_end_intwrite",
          "args": [
            "osb->sb"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&journal->j_trans_barrier"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_stop",
          "args": [
            "handle"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "1525-1671",
          "snippet": "int jbd2_journal_stop(handle_t *handle)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal;\n\tint err = 0, wait_for_commit = 0;\n\ttid_t tid;\n\tpid_t pid;\n\n\tif (!transaction)\n\t\tgoto free_and_exit;\n\tjournal = transaction->t_journal;\n\n\tJ_ASSERT(journal_current_handle() == handle);\n\n\tif (is_handle_aborted(handle))\n\t\terr = -EIO;\n\telse\n\t\tJ_ASSERT(atomic_read(&transaction->t_updates) > 0);\n\n\tif (--handle->h_ref > 0) {\n\t\tjbd_debug(4, \"h_ref %d -> %d\\n\", handle->h_ref + 1,\n\t\t\t  handle->h_ref);\n\t\treturn err;\n\t}\n\n\tjbd_debug(4, \"Handle %p going down\\n\", handle);\n\ttrace_jbd2_handle_stats(journal->j_fs_dev->bd_dev,\n\t\t\t\ttransaction->t_tid,\n\t\t\t\thandle->h_type, handle->h_line_no,\n\t\t\t\tjiffies - handle->h_start_jiffies,\n\t\t\t\thandle->h_sync, handle->h_requested_credits,\n\t\t\t\t(handle->h_requested_credits -\n\t\t\t\t handle->h_buffer_credits));\n\n\t/*\n\t * Implement synchronous transaction batching.  If the handle\n\t * was synchronous, don't force a commit immediately.  Let's\n\t * yield and let another thread piggyback onto this\n\t * transaction.  Keep doing that while new threads continue to\n\t * arrive.  It doesn't cost much - we're about to run a commit\n\t * and sleep on IO anyway.  Speeds up many-threaded, many-dir\n\t * operations by 30x or more...\n\t *\n\t * We try and optimize the sleep time against what the\n\t * underlying disk can do, instead of having a static sleep\n\t * time.  This is useful for the case where our storage is so\n\t * fast that it is more optimal to go ahead and force a flush\n\t * and wait for the transaction to be committed than it is to\n\t * wait for an arbitrary amount of time for new writers to\n\t * join the transaction.  We achieve this by measuring how\n\t * long it takes to commit a transaction, and compare it with\n\t * how long this transaction has been running, and if run time\n\t * < commit time then we sleep for the delta and commit.  This\n\t * greatly helps super fast disks that would see slowdowns as\n\t * more threads started doing fsyncs.\n\t *\n\t * But don't do this if this process was the most recent one\n\t * to perform a synchronous write.  We do this to detect the\n\t * case where a single process is doing a stream of sync\n\t * writes.  No point in waiting for joiners in that case.\n\t *\n\t * Setting max_batch_time to 0 disables this completely.\n\t */\n\tpid = current->pid;\n\tif (handle->h_sync && journal->j_last_sync_writer != pid &&\n\t    journal->j_max_batch_time) {\n\t\tu64 commit_time, trans_time;\n\n\t\tjournal->j_last_sync_writer = pid;\n\n\t\tread_lock(&journal->j_state_lock);\n\t\tcommit_time = journal->j_average_commit_time;\n\t\tread_unlock(&journal->j_state_lock);\n\n\t\ttrans_time = ktime_to_ns(ktime_sub(ktime_get(),\n\t\t\t\t\t\t   transaction->t_start_time));\n\n\t\tcommit_time = max_t(u64, commit_time,\n\t\t\t\t    1000*journal->j_min_batch_time);\n\t\tcommit_time = min_t(u64, commit_time,\n\t\t\t\t    1000*journal->j_max_batch_time);\n\n\t\tif (trans_time < commit_time) {\n\t\t\tktime_t expires = ktime_add_ns(ktime_get(),\n\t\t\t\t\t\t       commit_time);\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tschedule_hrtimeout(&expires, HRTIMER_MODE_ABS);\n\t\t}\n\t}\n\n\tif (handle->h_sync)\n\t\ttransaction->t_synchronous_commit = 1;\n\tcurrent->journal_info = NULL;\n\tatomic_sub(handle->h_buffer_credits,\n\t\t   &transaction->t_outstanding_credits);\n\n\t/*\n\t * If the handle is marked SYNC, we need to set another commit\n\t * going!  We also want to force a commit if the current\n\t * transaction is occupying too much of the log, or if the\n\t * transaction is too old now.\n\t */\n\tif (handle->h_sync ||\n\t    (atomic_read(&transaction->t_outstanding_credits) >\n\t     journal->j_max_transaction_buffers) ||\n\t    time_after_eq(jiffies, transaction->t_expires)) {\n\t\t/* Do this even for aborted journals: an abort still\n\t\t * completes the commit thread, it just doesn't write\n\t\t * anything to disk. */\n\n\t\tjbd_debug(2, \"transaction too old, requesting commit for \"\n\t\t\t\t\t\"handle %p\\n\", handle);\n\t\t/* This is non-blocking */\n\t\tjbd2_log_start_commit(journal, transaction->t_tid);\n\n\t\t/*\n\t\t * Special case: JBD2_SYNC synchronous updates require us\n\t\t * to wait for the commit to complete.\n\t\t */\n\t\tif (handle->h_sync && !(current->flags & PF_MEMALLOC))\n\t\t\twait_for_commit = 1;\n\t}\n\n\t/*\n\t * Once we drop t_updates, if it goes to zero the transaction\n\t * could start committing on us and eventually disappear.  So\n\t * once we do this, we must not dereference transaction\n\t * pointer again.\n\t */\n\ttid = transaction->t_tid;\n\tif (atomic_dec_and_test(&transaction->t_updates)) {\n\t\twake_up(&journal->j_wait_updates);\n\t\tif (journal->j_barrier_count)\n\t\t\twake_up(&journal->j_wait_transaction_locked);\n\t}\n\n\tif (wait_for_commit)\n\t\terr = jbd2_log_wait_commit(journal, tid);\n\n\tlock_map_release(&handle->h_lockdep_map);\n\n\tif (handle->h_rsv_handle)\n\t\tjbd2_journal_free_reserved(handle->h_rsv_handle);\nfree_and_exit:\n\tjbd2_free_handle(handle);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint jbd2_journal_stop(handle_t *handle)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal;\n\tint err = 0, wait_for_commit = 0;\n\ttid_t tid;\n\tpid_t pid;\n\n\tif (!transaction)\n\t\tgoto free_and_exit;\n\tjournal = transaction->t_journal;\n\n\tJ_ASSERT(journal_current_handle() == handle);\n\n\tif (is_handle_aborted(handle))\n\t\terr = -EIO;\n\telse\n\t\tJ_ASSERT(atomic_read(&transaction->t_updates) > 0);\n\n\tif (--handle->h_ref > 0) {\n\t\tjbd_debug(4, \"h_ref %d -> %d\\n\", handle->h_ref + 1,\n\t\t\t  handle->h_ref);\n\t\treturn err;\n\t}\n\n\tjbd_debug(4, \"Handle %p going down\\n\", handle);\n\ttrace_jbd2_handle_stats(journal->j_fs_dev->bd_dev,\n\t\t\t\ttransaction->t_tid,\n\t\t\t\thandle->h_type, handle->h_line_no,\n\t\t\t\tjiffies - handle->h_start_jiffies,\n\t\t\t\thandle->h_sync, handle->h_requested_credits,\n\t\t\t\t(handle->h_requested_credits -\n\t\t\t\t handle->h_buffer_credits));\n\n\t/*\n\t * Implement synchronous transaction batching.  If the handle\n\t * was synchronous, don't force a commit immediately.  Let's\n\t * yield and let another thread piggyback onto this\n\t * transaction.  Keep doing that while new threads continue to\n\t * arrive.  It doesn't cost much - we're about to run a commit\n\t * and sleep on IO anyway.  Speeds up many-threaded, many-dir\n\t * operations by 30x or more...\n\t *\n\t * We try and optimize the sleep time against what the\n\t * underlying disk can do, instead of having a static sleep\n\t * time.  This is useful for the case where our storage is so\n\t * fast that it is more optimal to go ahead and force a flush\n\t * and wait for the transaction to be committed than it is to\n\t * wait for an arbitrary amount of time for new writers to\n\t * join the transaction.  We achieve this by measuring how\n\t * long it takes to commit a transaction, and compare it with\n\t * how long this transaction has been running, and if run time\n\t * < commit time then we sleep for the delta and commit.  This\n\t * greatly helps super fast disks that would see slowdowns as\n\t * more threads started doing fsyncs.\n\t *\n\t * But don't do this if this process was the most recent one\n\t * to perform a synchronous write.  We do this to detect the\n\t * case where a single process is doing a stream of sync\n\t * writes.  No point in waiting for joiners in that case.\n\t *\n\t * Setting max_batch_time to 0 disables this completely.\n\t */\n\tpid = current->pid;\n\tif (handle->h_sync && journal->j_last_sync_writer != pid &&\n\t    journal->j_max_batch_time) {\n\t\tu64 commit_time, trans_time;\n\n\t\tjournal->j_last_sync_writer = pid;\n\n\t\tread_lock(&journal->j_state_lock);\n\t\tcommit_time = journal->j_average_commit_time;\n\t\tread_unlock(&journal->j_state_lock);\n\n\t\ttrans_time = ktime_to_ns(ktime_sub(ktime_get(),\n\t\t\t\t\t\t   transaction->t_start_time));\n\n\t\tcommit_time = max_t(u64, commit_time,\n\t\t\t\t    1000*journal->j_min_batch_time);\n\t\tcommit_time = min_t(u64, commit_time,\n\t\t\t\t    1000*journal->j_max_batch_time);\n\n\t\tif (trans_time < commit_time) {\n\t\t\tktime_t expires = ktime_add_ns(ktime_get(),\n\t\t\t\t\t\t       commit_time);\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tschedule_hrtimeout(&expires, HRTIMER_MODE_ABS);\n\t\t}\n\t}\n\n\tif (handle->h_sync)\n\t\ttransaction->t_synchronous_commit = 1;\n\tcurrent->journal_info = NULL;\n\tatomic_sub(handle->h_buffer_credits,\n\t\t   &transaction->t_outstanding_credits);\n\n\t/*\n\t * If the handle is marked SYNC, we need to set another commit\n\t * going!  We also want to force a commit if the current\n\t * transaction is occupying too much of the log, or if the\n\t * transaction is too old now.\n\t */\n\tif (handle->h_sync ||\n\t    (atomic_read(&transaction->t_outstanding_credits) >\n\t     journal->j_max_transaction_buffers) ||\n\t    time_after_eq(jiffies, transaction->t_expires)) {\n\t\t/* Do this even for aborted journals: an abort still\n\t\t * completes the commit thread, it just doesn't write\n\t\t * anything to disk. */\n\n\t\tjbd_debug(2, \"transaction too old, requesting commit for \"\n\t\t\t\t\t\"handle %p\\n\", handle);\n\t\t/* This is non-blocking */\n\t\tjbd2_log_start_commit(journal, transaction->t_tid);\n\n\t\t/*\n\t\t * Special case: JBD2_SYNC synchronous updates require us\n\t\t * to wait for the commit to complete.\n\t\t */\n\t\tif (handle->h_sync && !(current->flags & PF_MEMALLOC))\n\t\t\twait_for_commit = 1;\n\t}\n\n\t/*\n\t * Once we drop t_updates, if it goes to zero the transaction\n\t * could start committing on us and eventually disappear.  So\n\t * once we do this, we must not dereference transaction\n\t * pointer again.\n\t */\n\ttid = transaction->t_tid;\n\tif (atomic_dec_and_test(&transaction->t_updates)) {\n\t\twake_up(&journal->j_wait_updates);\n\t\tif (journal->j_barrier_count)\n\t\t\twake_up(&journal->j_wait_transaction_locked);\n\t}\n\n\tif (wait_for_commit)\n\t\terr = jbd2_log_wait_commit(journal, tid);\n\n\tlock_map_release(&handle->h_lockdep_map);\n\n\tif (handle->h_rsv_handle)\n\t\tjbd2_journal_free_reserved(handle->h_rsv_handle);\nfree_and_exit:\n\tjbd2_free_handle(handle);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!handle"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_start_trans",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "348-386",
    "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&(osb->journal->j_num_trans)"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_mount_local",
          "args": [
            "osb"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mount_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "668-671",
          "snippet": "static inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EROFS"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_abort",
          "args": [
            "osb->sb",
            "\"Detected aborted journal\""
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_abort_trigger",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "565-578",
          "snippet": "static void ocfs2_abort_trigger(struct jbd2_buffer_trigger_type *triggers,\n\t\t\t\tstruct buffer_head *bh)\n{\n\tmlog(ML_ERROR,\n\t     \"ocfs2_abort_trigger called by JBD2.  bh = 0x%lx, \"\n\t     \"bh->b_blocknr = %llu\\n\",\n\t     (unsigned long)bh,\n\t     (unsigned long long)bh->b_blocknr);\n\n\t/* We aren't guaranteed to have the superblock here - but if we\n\t * don't, it'll just crash. */\n\tocfs2_error(bh->b_assoc_map->host->i_sb,\n\t\t    \"JBD2 has aborted our journal, ocfs2 cannot continue\\n\");\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_abort_trigger(struct jbd2_buffer_trigger_type *triggers,\n\t\t\t\tstruct buffer_head *bh)\n{\n\tmlog(ML_ERROR,\n\t     \"ocfs2_abort_trigger called by JBD2.  bh = 0x%lx, \"\n\t     \"bh->b_blocknr = %llu\\n\",\n\t     (unsigned long)bh,\n\t     (unsigned long long)bh->b_blocknr);\n\n\t/* We aren't guaranteed to have the superblock here - but if we\n\t * don't, it'll just crash. */\n\tocfs2_error(bh->b_assoc_map->host->i_sb,\n\t\t    \"JBD2 has aborted our journal, ocfs2 cannot continue\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_journal_aborted",
          "args": [
            "journal"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_is_journal_aborted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "760-764",
          "snippet": "static inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "PTR_ERR(handle)"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_end_intwrite",
          "args": [
            "osb->sb"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&osb->journal->j_trans_barrier"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_start",
          "args": [
            "journal",
            "max_buffs"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_start_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "626-651",
          "snippet": "int jbd2_journal_start_commit(journal_t *journal, tid_t *ptid)\n{\n\tint ret = 0;\n\n\twrite_lock(&journal->j_state_lock);\n\tif (journal->j_running_transaction) {\n\t\ttid_t tid = journal->j_running_transaction->t_tid;\n\n\t\t__jbd2_log_start_commit(journal, tid);\n\t\t/* There's a running transaction and we've just made sure\n\t\t * it's commit has been scheduled. */\n\t\tif (ptid)\n\t\t\t*ptid = tid;\n\t\tret = 1;\n\t} else if (journal->j_committing_transaction) {\n\t\t/*\n\t\t * If commit has been started, then we have to wait for\n\t\t * completion of that transaction.\n\t\t */\n\t\tif (ptid)\n\t\t\t*ptid = journal->j_committing_transaction->t_tid;\n\t\tret = 1;\n\t}\n\twrite_unlock(&journal->j_state_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_start_commit(journal_t *journal, tid_t *ptid)\n{\n\tint ret = 0;\n\n\twrite_lock(&journal->j_state_lock);\n\tif (journal->j_running_transaction) {\n\t\ttid_t tid = journal->j_running_transaction->t_tid;\n\n\t\t__jbd2_log_start_commit(journal, tid);\n\t\t/* There's a running transaction and we've just made sure\n\t\t * it's commit has been scheduled. */\n\t\tif (ptid)\n\t\t\t*ptid = tid;\n\t\tret = 1;\n\t} else if (journal->j_committing_transaction) {\n\t\t/*\n\t\t * If commit has been started, then we have to wait for\n\t\t * completion of that transaction.\n\t\t */\n\t\tif (ptid)\n\t\t\t*ptid = journal->j_committing_transaction->t_tid;\n\t\tret = 1;\n\t}\n\twrite_unlock(&journal->j_state_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&osb->journal->j_trans_barrier"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_start_intwrite",
          "args": [
            "osb->sb"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_current_handle",
          "args": [],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_current_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1271-1274",
          "snippet": "static inline handle_t *ext3_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nstatic inline handle_t *ext3_journal_current_handle(void)\n{\n\treturn journal_current_handle();\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "max_buffs <= 0"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "osb->journal->j_state == OCFS2_JOURNAL_FREE"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EROFS"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_is_hard_readonly",
          "args": [
            "osb"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_hard_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "615-624",
          "snippet": "static inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define OCFS2_OSB_HARD_RO\t0x0002"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define OCFS2_OSB_HARD_RO\t0x0002\n\nstatic inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!osb || !osb->journal->j_journal"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
  },
  {
    "function_name": "ocfs2_commit_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "307-346",
    "snippet": "static int ocfs2_commit_cache(struct ocfs2_super *osb)\n{\n\tint status = 0;\n\tunsigned int flushed;\n\tstruct ocfs2_journal *journal = NULL;\n\n\tjournal = osb->journal;\n\n\t/* Flush all pending commits and checkpoint the journal. */\n\tdown_write(&journal->j_trans_barrier);\n\n\tflushed = atomic_read(&journal->j_num_trans);\n\ttrace_ocfs2_commit_cache_begin(flushed);\n\tif (flushed == 0) {\n\t\tup_write(&journal->j_trans_barrier);\n\t\tgoto finally;\n\t}\n\n\tjbd2_journal_lock_updates(journal->j_journal);\n\tstatus = jbd2_journal_flush(journal->j_journal);\n\tjbd2_journal_unlock_updates(journal->j_journal);\n\tif (status < 0) {\n\t\tup_write(&journal->j_trans_barrier);\n\t\tmlog_errno(status);\n\t\tgoto finally;\n\t}\n\n\tocfs2_inc_trans_id(journal);\n\n\tflushed = atomic_read(&journal->j_num_trans);\n\tatomic_set(&journal->j_num_trans, 0);\n\tup_write(&journal->j_trans_barrier);\n\n\ttrace_ocfs2_commit_cache_end(journal->j_trans_id, flushed);\n\n\tocfs2_wake_downconvert_thread(osb);\n\twake_up(&journal->j_checkpointed);\nfinally:\n\treturn status;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&journal->j_checkpointed"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_wake_downconvert_thread",
          "args": [
            "osb"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_wake_downconvert_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "4091-4101",
          "snippet": "void ocfs2_wake_downconvert_thread(struct ocfs2_super *osb)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&osb->dc_task_lock, flags);\n\t/* make sure the voting thread gets a swipe at whatever changes\n\t * the caller may have made to the voting state */\n\tosb->dc_wake_sequence++;\n\tspin_unlock_irqrestore(&osb->dc_task_lock, flags);\n\twake_up(&osb->dc_event);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\n\nvoid ocfs2_wake_downconvert_thread(struct ocfs2_super *osb)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&osb->dc_task_lock, flags);\n\t/* make sure the voting thread gets a swipe at whatever changes\n\t * the caller may have made to the voting state */\n\tosb->dc_wake_sequence++;\n\tspin_unlock_irqrestore(&osb->dc_task_lock, flags);\n\twake_up(&osb->dc_event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_commit_cache_end",
          "args": [
            "journal->j_trans_id",
            "flushed"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&journal->j_trans_barrier"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&journal->j_num_trans",
            "0"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&journal->j_num_trans"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inc_trans_id",
          "args": [
            "journal"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inc_trans_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "83-92",
          "snippet": "static inline unsigned long ocfs2_inc_trans_id(struct ocfs2_journal *j)\n{\n\tunsigned long old_id;\n\tspin_lock(&trans_inc_lock);\n\told_id = j->j_trans_id++;\n\tif (unlikely(!j->j_trans_id))\n\t\tj->j_trans_id = 1;\n\tspin_unlock(&trans_inc_lock);\n\treturn old_id;\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline unsigned long ocfs2_inc_trans_id(struct ocfs2_journal *j)\n{\n\tunsigned long old_id;\n\tspin_lock(&trans_inc_lock);\n\told_id = j->j_trans_id++;\n\tif (unlikely(!j->j_trans_id))\n\t\tj->j_trans_id = 1;\n\tspin_unlock(&trans_inc_lock);\n\treturn old_id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&journal->j_trans_barrier"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_unlock_updates",
          "args": [
            "journal->j_journal"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_unlock_updates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "744-753",
          "snippet": "void jbd2_journal_unlock_updates (journal_t *journal)\n{\n\tJ_ASSERT(journal->j_barrier_count != 0);\n\n\tmutex_unlock(&journal->j_barrier);\n\twrite_lock(&journal->j_state_lock);\n\t--journal->j_barrier_count;\n\twrite_unlock(&journal->j_state_lock);\n\twake_up(&journal->j_wait_transaction_locked);\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid jbd2_journal_unlock_updates (journal_t *journal)\n{\n\tJ_ASSERT(journal->j_barrier_count != 0);\n\n\tmutex_unlock(&journal->j_barrier);\n\twrite_lock(&journal->j_state_lock);\n\t--journal->j_barrier_count;\n\twrite_unlock(&journal->j_state_lock);\n\twake_up(&journal->j_wait_transaction_locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_flush",
          "args": [
            "journal->j_journal"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1914-1970",
          "snippet": "int jbd2_journal_flush(journal_t *journal)\n{\n\tint err = 0;\n\ttransaction_t *transaction = NULL;\n\n\twrite_lock(&journal->j_state_lock);\n\n\t/* Force everything buffered to the log... */\n\tif (journal->j_running_transaction) {\n\t\ttransaction = journal->j_running_transaction;\n\t\t__jbd2_log_start_commit(journal, transaction->t_tid);\n\t} else if (journal->j_committing_transaction)\n\t\ttransaction = journal->j_committing_transaction;\n\n\t/* Wait for the log commit to complete... */\n\tif (transaction) {\n\t\ttid_t tid = transaction->t_tid;\n\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tjbd2_log_wait_commit(journal, tid);\n\t} else {\n\t\twrite_unlock(&journal->j_state_lock);\n\t}\n\n\t/* ...and flush everything in the log out to disk. */\n\tspin_lock(&journal->j_list_lock);\n\twhile (!err && journal->j_checkpoint_transactions != NULL) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\terr = jbd2_log_do_checkpoint(journal);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\tspin_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\tif (is_journal_aborted(journal))\n\t\treturn -EIO;\n\n\tmutex_lock(&journal->j_checkpoint_mutex);\n\tjbd2_cleanup_journal_tail(journal);\n\n\t/* Finally, mark the journal as really needing no recovery.\n\t * This sets s_start==0 in the underlying superblock, which is\n\t * the magic code for a fully-recovered superblock.  Any future\n\t * commits of data to the journal will restore the current\n\t * s_start value. */\n\tjbd2_mark_journal_empty(journal);\n\tmutex_unlock(&journal->j_checkpoint_mutex);\n\twrite_lock(&journal->j_state_lock);\n\tJ_ASSERT(!journal->j_running_transaction);\n\tJ_ASSERT(!journal->j_committing_transaction);\n\tJ_ASSERT(!journal->j_checkpoint_transactions);\n\tJ_ASSERT(journal->j_head == journal->j_tail);\n\tJ_ASSERT(journal->j_tail_sequence == journal->j_transaction_sequence);\n\twrite_unlock(&journal->j_state_lock);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_flush(journal_t *journal)\n{\n\tint err = 0;\n\ttransaction_t *transaction = NULL;\n\n\twrite_lock(&journal->j_state_lock);\n\n\t/* Force everything buffered to the log... */\n\tif (journal->j_running_transaction) {\n\t\ttransaction = journal->j_running_transaction;\n\t\t__jbd2_log_start_commit(journal, transaction->t_tid);\n\t} else if (journal->j_committing_transaction)\n\t\ttransaction = journal->j_committing_transaction;\n\n\t/* Wait for the log commit to complete... */\n\tif (transaction) {\n\t\ttid_t tid = transaction->t_tid;\n\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tjbd2_log_wait_commit(journal, tid);\n\t} else {\n\t\twrite_unlock(&journal->j_state_lock);\n\t}\n\n\t/* ...and flush everything in the log out to disk. */\n\tspin_lock(&journal->j_list_lock);\n\twhile (!err && journal->j_checkpoint_transactions != NULL) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\terr = jbd2_log_do_checkpoint(journal);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\tspin_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\tif (is_journal_aborted(journal))\n\t\treturn -EIO;\n\n\tmutex_lock(&journal->j_checkpoint_mutex);\n\tjbd2_cleanup_journal_tail(journal);\n\n\t/* Finally, mark the journal as really needing no recovery.\n\t * This sets s_start==0 in the underlying superblock, which is\n\t * the magic code for a fully-recovered superblock.  Any future\n\t * commits of data to the journal will restore the current\n\t * s_start value. */\n\tjbd2_mark_journal_empty(journal);\n\tmutex_unlock(&journal->j_checkpoint_mutex);\n\twrite_lock(&journal->j_state_lock);\n\tJ_ASSERT(!journal->j_running_transaction);\n\tJ_ASSERT(!journal->j_committing_transaction);\n\tJ_ASSERT(!journal->j_checkpoint_transactions);\n\tJ_ASSERT(journal->j_head == journal->j_tail);\n\tJ_ASSERT(journal->j_tail_sequence == journal->j_transaction_sequence);\n\twrite_unlock(&journal->j_state_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_lock_updates",
          "args": [
            "journal->j_journal"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_lock_updates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "689-734",
          "snippet": "void jbd2_journal_lock_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\n\twrite_lock(&journal->j_state_lock);\n\t++journal->j_barrier_count;\n\n\t/* Wait until there are no reserved handles */\n\tif (atomic_read(&journal->j_reserved_credits)) {\n\t\twrite_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_reserved,\n\t\t\t   atomic_read(&journal->j_reserved_credits) == 0);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\n\t/* Wait until there are no running updates */\n\twhile (1) {\n\t\ttransaction_t *transaction = journal->j_running_transaction;\n\n\t\tif (!transaction)\n\t\t\tbreak;\n\n\t\tspin_lock(&transaction->t_handle_lock);\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!atomic_read(&transaction->t_updates)) {\n\t\t\tspin_unlock(&transaction->t_handle_lock);\n\t\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\twrite_unlock(&journal->j_state_lock);\n\n\t/*\n\t * We have now established a barrier against other normal updates, but\n\t * we also need to barrier against other jbd2_journal_lock_updates() calls\n\t * to make sure that we serialise special journal-locked operations\n\t * too.\n\t */\n\tmutex_lock(&journal->j_barrier);\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid jbd2_journal_lock_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\n\twrite_lock(&journal->j_state_lock);\n\t++journal->j_barrier_count;\n\n\t/* Wait until there are no reserved handles */\n\tif (atomic_read(&journal->j_reserved_credits)) {\n\t\twrite_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_reserved,\n\t\t\t   atomic_read(&journal->j_reserved_credits) == 0);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\n\t/* Wait until there are no running updates */\n\twhile (1) {\n\t\ttransaction_t *transaction = journal->j_running_transaction;\n\n\t\tif (!transaction)\n\t\t\tbreak;\n\n\t\tspin_lock(&transaction->t_handle_lock);\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!atomic_read(&transaction->t_updates)) {\n\t\t\tspin_unlock(&transaction->t_handle_lock);\n\t\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\twrite_unlock(&journal->j_state_lock);\n\n\t/*\n\t * We have now established a barrier against other normal updates, but\n\t * we also need to barrier against other jbd2_journal_lock_updates() calls\n\t * to make sure that we serialise special journal-locked operations\n\t * too.\n\t */\n\tmutex_lock(&journal->j_barrier);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&journal->j_trans_barrier"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_commit_cache_begin",
          "args": [
            "flushed"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&journal->j_num_trans"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&journal->j_trans_barrier"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb)\n{\n\tint status = 0;\n\tunsigned int flushed;\n\tstruct ocfs2_journal *journal = NULL;\n\n\tjournal = osb->journal;\n\n\t/* Flush all pending commits and checkpoint the journal. */\n\tdown_write(&journal->j_trans_barrier);\n\n\tflushed = atomic_read(&journal->j_num_trans);\n\ttrace_ocfs2_commit_cache_begin(flushed);\n\tif (flushed == 0) {\n\t\tup_write(&journal->j_trans_barrier);\n\t\tgoto finally;\n\t}\n\n\tjbd2_journal_lock_updates(journal->j_journal);\n\tstatus = jbd2_journal_flush(journal->j_journal);\n\tjbd2_journal_unlock_updates(journal->j_journal);\n\tif (status < 0) {\n\t\tup_write(&journal->j_trans_barrier);\n\t\tmlog_errno(status);\n\t\tgoto finally;\n\t}\n\n\tocfs2_inc_trans_id(journal);\n\n\tflushed = atomic_read(&journal->j_num_trans);\n\tatomic_set(&journal->j_num_trans, 0);\n\tup_write(&journal->j_trans_barrier);\n\n\ttrace_ocfs2_commit_cache_end(journal->j_trans_id, flushed);\n\n\tocfs2_wake_downconvert_thread(osb);\n\twake_up(&journal->j_checkpointed);\nfinally:\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_recovery_map_clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "284-305",
    "snippet": "static void ocfs2_recovery_map_clear(struct ocfs2_super *osb,\n\t\t\t\t     unsigned int node_num)\n{\n\tint i;\n\tstruct ocfs2_recovery_map *rm = osb->recovery_map;\n\n\tspin_lock(&osb->osb_lock);\n\n\tfor (i = 0; i < rm->rm_used; i++) {\n\t\tif (rm->rm_entries[i] == node_num)\n\t\t\tbreak;\n\t}\n\n\tif (i < rm->rm_used) {\n\t\t/* XXX: be careful with the pointer math */\n\t\tmemmove(&(rm->rm_entries[i]), &(rm->rm_entries[i + 1]),\n\t\t\t(rm->rm_used - i - 1) * sizeof(unsigned int));\n\t\trm->rm_used--;\n\t}\n\n\tspin_unlock(&osb->osb_lock);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&(rm->rm_entries[i])",
            "&(rm->rm_entries[i + 1])",
            "(rm->rm_used - i - 1) * sizeof(unsigned int)"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nstatic void ocfs2_recovery_map_clear(struct ocfs2_super *osb,\n\t\t\t\t     unsigned int node_num)\n{\n\tint i;\n\tstruct ocfs2_recovery_map *rm = osb->recovery_map;\n\n\tspin_lock(&osb->osb_lock);\n\n\tfor (i = 0; i < rm->rm_used; i++) {\n\t\tif (rm->rm_entries[i] == node_num)\n\t\t\tbreak;\n\t}\n\n\tif (i < rm->rm_used) {\n\t\t/* XXX: be careful with the pointer math */\n\t\tmemmove(&(rm->rm_entries[i]), &(rm->rm_entries[i + 1]),\n\t\t\t(rm->rm_used - i - 1) * sizeof(unsigned int));\n\t\trm->rm_used--;\n\t}\n\n\tspin_unlock(&osb->osb_lock);\n}"
  },
  {
    "function_name": "ocfs2_recovery_map_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "263-282",
    "snippet": "static int ocfs2_recovery_map_set(struct ocfs2_super *osb,\n\t\t\t\t  unsigned int node_num)\n{\n\tstruct ocfs2_recovery_map *rm = osb->recovery_map;\n\n\tspin_lock(&osb->osb_lock);\n\tif (__ocfs2_recovery_map_test(osb, node_num)) {\n\t\tspin_unlock(&osb->osb_lock);\n\t\treturn 1;\n\t}\n\n\t/* XXX: Can this be exploited? Not from o2dlm... */\n\tBUG_ON(rm->rm_used >= osb->max_slots);\n\n\trm->rm_entries[rm->rm_used] = node_num;\n\trm->rm_used++;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "rm->rm_used >= osb->max_slots"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ocfs2_recovery_map_test",
          "args": [
            "osb",
            "node_num"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_recovery_map_test",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "246-260",
          "snippet": "static int __ocfs2_recovery_map_test(struct ocfs2_super *osb,\n\t\t\t\t     unsigned int node_num)\n{\n\tint i;\n\tstruct ocfs2_recovery_map *rm = osb->recovery_map;\n\n\tassert_spin_locked(&osb->osb_lock);\n\n\tfor (i = 0; i < rm->rm_used; i++) {\n\t\tif (rm->rm_entries[i] == node_num)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nstatic int __ocfs2_recovery_map_test(struct ocfs2_super *osb,\n\t\t\t\t     unsigned int node_num)\n{\n\tint i;\n\tstruct ocfs2_recovery_map *rm = osb->recovery_map;\n\n\tassert_spin_locked(&osb->osb_lock);\n\n\tfor (i = 0; i < rm->rm_used; i++) {\n\t\tif (rm->rm_entries[i] == node_num)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nstatic int ocfs2_recovery_map_set(struct ocfs2_super *osb,\n\t\t\t\t  unsigned int node_num)\n{\n\tstruct ocfs2_recovery_map *rm = osb->recovery_map;\n\n\tspin_lock(&osb->osb_lock);\n\tif (__ocfs2_recovery_map_test(osb, node_num)) {\n\t\tspin_unlock(&osb->osb_lock);\n\t\treturn 1;\n\t}\n\n\t/* XXX: Can this be exploited? Not from o2dlm... */\n\tBUG_ON(rm->rm_used >= osb->max_slots);\n\n\trm->rm_entries[rm->rm_used] = node_num;\n\trm->rm_used++;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__ocfs2_recovery_map_test",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "246-260",
    "snippet": "static int __ocfs2_recovery_map_test(struct ocfs2_super *osb,\n\t\t\t\t     unsigned int node_num)\n{\n\tint i;\n\tstruct ocfs2_recovery_map *rm = osb->recovery_map;\n\n\tassert_spin_locked(&osb->osb_lock);\n\n\tfor (i = 0; i < rm->rm_used; i++) {\n\t\tif (rm->rm_entries[i] == node_num)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nstatic int __ocfs2_recovery_map_test(struct ocfs2_super *osb,\n\t\t\t\t     unsigned int node_num)\n{\n\tint i;\n\tstruct ocfs2_recovery_map *rm = osb->recovery_map;\n\n\tassert_spin_locked(&osb->osb_lock);\n\n\tfor (i = 0; i < rm->rm_used; i++) {\n\t\tif (rm->rm_entries[i] == node_num)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_recovery_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "220-244",
    "snippet": "void ocfs2_recovery_exit(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_recovery_map *rm;\n\n\t/* disable any new recovery threads and wait for any currently\n\t * running ones to exit. Do this before setting the vol_state. */\n\tmutex_lock(&osb->recovery_lock);\n\tosb->disable_recovery = 1;\n\tmutex_unlock(&osb->recovery_lock);\n\twait_event(osb->recovery_event, !ocfs2_recovery_thread_running(osb));\n\n\t/* At this point, we know that no more recovery threads can be\n\t * launched, so wait for any recovery completion work to\n\t * complete. */\n\tflush_workqueue(ocfs2_wq);\n\n\t/*\n\t * Now that recovery is shut down, and the osb is about to be\n\t * freed,  the osb_lock is not taken here.\n\t */\n\trm = osb->recovery_map;\n\t/* XXX: Should we bug if there are dirty entries? */\n\n\tkfree(rm);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rm"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_workqueue",
          "args": [
            "ocfs2_wq"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "osb->recovery_event",
            "!ocfs2_recovery_thread_running(osb)"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_recovery_thread_running",
          "args": [
            "osb"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_recovery_thread_running",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "214-218",
          "snippet": "static int ocfs2_recovery_thread_running(struct ocfs2_super *osb)\n{\n\tmb();\n\treturn osb->recovery_thread_task != NULL;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nstatic int ocfs2_recovery_thread_running(struct ocfs2_super *osb)\n{\n\tmb();\n\treturn osb->recovery_thread_task != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&osb->recovery_lock"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&osb->recovery_lock"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nvoid ocfs2_recovery_exit(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_recovery_map *rm;\n\n\t/* disable any new recovery threads and wait for any currently\n\t * running ones to exit. Do this before setting the vol_state. */\n\tmutex_lock(&osb->recovery_lock);\n\tosb->disable_recovery = 1;\n\tmutex_unlock(&osb->recovery_lock);\n\twait_event(osb->recovery_event, !ocfs2_recovery_thread_running(osb));\n\n\t/* At this point, we know that no more recovery threads can be\n\t * launched, so wait for any recovery completion work to\n\t * complete. */\n\tflush_workqueue(ocfs2_wq);\n\n\t/*\n\t * Now that recovery is shut down, and the osb is about to be\n\t * freed,  the osb_lock is not taken here.\n\t */\n\trm = osb->recovery_map;\n\t/* XXX: Should we bug if there are dirty entries? */\n\n\tkfree(rm);\n}"
  },
  {
    "function_name": "ocfs2_recovery_thread_running",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "214-218",
    "snippet": "static int ocfs2_recovery_thread_running(struct ocfs2_super *osb)\n{\n\tmb();\n\treturn osb->recovery_thread_task != NULL;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mb",
          "args": [],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "exit_mbcache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "851-854",
          "snippet": "static void __exit exit_mbcache(void)\n{\n\tunregister_shrinker(&mb_cache_shrinker);\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct shrinker mb_cache_shrinker = {\n\t.count_objects = mb_cache_shrink_count,\n\t.scan_objects = mb_cache_shrink_scan,\n\t.seeks = DEFAULT_SEEKS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct shrinker mb_cache_shrinker = {\n\t.count_objects = mb_cache_shrink_count,\n\t.scan_objects = mb_cache_shrink_scan,\n\t.seeks = DEFAULT_SEEKS,\n};\n\nstatic void __exit exit_mbcache(void)\n{\n\tunregister_shrinker(&mb_cache_shrinker);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nstatic int ocfs2_recovery_thread_running(struct ocfs2_super *osb)\n{\n\tmb();\n\treturn osb->recovery_thread_task != NULL;\n}"
  },
  {
    "function_name": "ocfs2_recovery_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "187-209",
    "snippet": "int ocfs2_recovery_init(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_recovery_map *rm;\n\n\tmutex_init(&osb->recovery_lock);\n\tosb->disable_recovery = 0;\n\tosb->recovery_thread_task = NULL;\n\tinit_waitqueue_head(&osb->recovery_event);\n\n\trm = kzalloc(sizeof(struct ocfs2_recovery_map) +\n\t\t     osb->max_slots * sizeof(unsigned int),\n\t\t     GFP_KERNEL);\n\tif (!rm) {\n\t\tmlog_errno(-ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\trm->rm_entries = (unsigned int *)((char *)rm +\n\t\t\t\t\t  sizeof(struct ocfs2_recovery_map));\n\tosb->recovery_map = rm;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "-ENOMEM"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct ocfs2_recovery_map) +\n\t\t     osb->max_slots * sizeof(unsigned int)",
            "GFP_KERNEL"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&osb->recovery_event"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&osb->recovery_lock"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_recovery_init(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_recovery_map *rm;\n\n\tmutex_init(&osb->recovery_lock);\n\tosb->disable_recovery = 0;\n\tosb->recovery_thread_task = NULL;\n\tinit_waitqueue_head(&osb->recovery_event);\n\n\trm = kzalloc(sizeof(struct ocfs2_recovery_map) +\n\t\t     osb->max_slots * sizeof(unsigned int),\n\t\t     GFP_KERNEL);\n\tif (!rm) {\n\t\tmlog_errno(-ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\trm->rm_entries = (unsigned int *)((char *)rm +\n\t\t\t\t\t  sizeof(struct ocfs2_recovery_map));\n\tosb->recovery_map = rm;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_free_replay_slots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "176-185",
    "snippet": "void ocfs2_free_replay_slots(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_replay_map *replay_map = osb->replay_map;\n\n\tif (!osb->replay_map)\n\t\treturn;\n\n\tkfree(replay_map);\n\tosb->replay_map = NULL;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "replay_map"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nvoid ocfs2_free_replay_slots(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_replay_map *replay_map = osb->replay_map;\n\n\tif (!osb->replay_map)\n\t\treturn;\n\n\tkfree(replay_map);\n\tosb->replay_map = NULL;\n}"
  },
  {
    "function_name": "ocfs2_queue_replay_slots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "156-174",
    "snippet": "void ocfs2_queue_replay_slots(struct ocfs2_super *osb,\n\t\tenum ocfs2_orphan_reco_type orphan_reco_type)\n{\n\tstruct ocfs2_replay_map *replay_map = osb->replay_map;\n\tint i;\n\n\tif (!replay_map)\n\t\treturn;\n\n\tif (replay_map->rm_state != REPLAY_NEEDED)\n\t\treturn;\n\n\tfor (i = 0; i < replay_map->rm_slots; i++)\n\t\tif (replay_map->rm_replay_slots[i])\n\t\t\tocfs2_queue_recovery_completion(osb->journal, i, NULL,\n\t\t\t\t\t\t\tNULL, NULL,\n\t\t\t\t\t\t\torphan_reco_type);\n\treplay_map->rm_state = REPLAY_DONE;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_commit_cache(struct ocfs2_super *osb);",
      "static int ocfs2_recover_orphans(struct ocfs2_super *osb,\n\t\t\t\t int slot,\n\t\t\t\t enum ocfs2_orphan_reco_type orphan_reco_type);",
      "static void ocfs2_queue_recovery_completion(struct ocfs2_journal *journal,\n\t\t\t\t\t    int slot_num,\n\t\t\t\t\t    struct ocfs2_dinode *la_dinode,\n\t\t\t\t\t    struct ocfs2_dinode *tl_dinode,\n\t\t\t\t\t    struct ocfs2_quota_recovery *qrec,\n\t\t\t\t\t    enum ocfs2_orphan_reco_type orphan_reco_type);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_queue_recovery_completion",
          "args": [
            "osb->journal",
            "i",
            "NULL",
            "NULL",
            "NULL",
            "orphan_reco_type"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_queue_recovery_completion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "1270-1305",
          "snippet": "static void ocfs2_queue_recovery_completion(struct ocfs2_journal *journal,\n\t\t\t\t\t    int slot_num,\n\t\t\t\t\t    struct ocfs2_dinode *la_dinode,\n\t\t\t\t\t    struct ocfs2_dinode *tl_dinode,\n\t\t\t\t\t    struct ocfs2_quota_recovery *qrec,\n\t\t\t\t\t    enum ocfs2_orphan_reco_type orphan_reco_type)\n{\n\tstruct ocfs2_la_recovery_item *item;\n\n\titem = kmalloc(sizeof(struct ocfs2_la_recovery_item), GFP_NOFS);\n\tif (!item) {\n\t\t/* Though we wish to avoid it, we are in fact safe in\n\t\t * skipping local alloc cleanup as fsck.ocfs2 is more\n\t\t * than capable of reclaiming unused space. */\n\t\tkfree(la_dinode);\n\t\tkfree(tl_dinode);\n\n\t\tif (qrec)\n\t\t\tocfs2_free_quota_recovery(qrec);\n\n\t\tmlog_errno(-ENOMEM);\n\t\treturn;\n\t}\n\n\tINIT_LIST_HEAD(&item->lri_list);\n\titem->lri_la_dinode = la_dinode;\n\titem->lri_slot = slot_num;\n\titem->lri_tl_dinode = tl_dinode;\n\titem->lri_qrec = qrec;\n\titem->lri_orphan_reco_type = orphan_reco_type;\n\n\tspin_lock(&journal->j_lock);\n\tlist_add_tail(&item->lri_list, &journal->j_la_cleanups);\n\tqueue_work(ocfs2_wq, &journal->j_recovery_work);\n\tspin_unlock(&journal->j_lock);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);",
            "static int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);",
            "static int ocfs2_recover_orphans(struct ocfs2_super *osb,\n\t\t\t\t int slot,\n\t\t\t\t enum ocfs2_orphan_reco_type orphan_reco_type);",
            "static void ocfs2_queue_recovery_completion(struct ocfs2_journal *journal,\n\t\t\t\t\t    int slot_num,\n\t\t\t\t\t    struct ocfs2_dinode *la_dinode,\n\t\t\t\t\t    struct ocfs2_dinode *tl_dinode,\n\t\t\t\t\t    struct ocfs2_quota_recovery *qrec,\n\t\t\t\t\t    enum ocfs2_orphan_reco_type orphan_reco_type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_recover_node(struct ocfs2_super *osb,\n\t\t\t      int node_num, int slot_num);\nstatic int ocfs2_trylock_journal(struct ocfs2_super *osb,\n\t\t\t\t int slot_num);\nstatic int ocfs2_recover_orphans(struct ocfs2_super *osb,\n\t\t\t\t int slot,\n\t\t\t\t enum ocfs2_orphan_reco_type orphan_reco_type);\nstatic void ocfs2_queue_recovery_completion(struct ocfs2_journal *journal,\n\t\t\t\t\t    int slot_num,\n\t\t\t\t\t    struct ocfs2_dinode *la_dinode,\n\t\t\t\t\t    struct ocfs2_dinode *tl_dinode,\n\t\t\t\t\t    struct ocfs2_quota_recovery *qrec,\n\t\t\t\t\t    enum ocfs2_orphan_reco_type orphan_reco_type);\n\nstatic void ocfs2_queue_recovery_completion(struct ocfs2_journal *journal,\n\t\t\t\t\t    int slot_num,\n\t\t\t\t\t    struct ocfs2_dinode *la_dinode,\n\t\t\t\t\t    struct ocfs2_dinode *tl_dinode,\n\t\t\t\t\t    struct ocfs2_quota_recovery *qrec,\n\t\t\t\t\t    enum ocfs2_orphan_reco_type orphan_reco_type)\n{\n\tstruct ocfs2_la_recovery_item *item;\n\n\titem = kmalloc(sizeof(struct ocfs2_la_recovery_item), GFP_NOFS);\n\tif (!item) {\n\t\t/* Though we wish to avoid it, we are in fact safe in\n\t\t * skipping local alloc cleanup as fsck.ocfs2 is more\n\t\t * than capable of reclaiming unused space. */\n\t\tkfree(la_dinode);\n\t\tkfree(tl_dinode);\n\n\t\tif (qrec)\n\t\t\tocfs2_free_quota_recovery(qrec);\n\n\t\tmlog_errno(-ENOMEM);\n\t\treturn;\n\t}\n\n\tINIT_LIST_HEAD(&item->lri_list);\n\titem->lri_la_dinode = la_dinode;\n\titem->lri_slot = slot_num;\n\titem->lri_tl_dinode = tl_dinode;\n\titem->lri_qrec = qrec;\n\titem->lri_orphan_reco_type = orphan_reco_type;\n\n\tspin_lock(&journal->j_lock);\n\tlist_add_tail(&item->lri_list, &journal->j_la_cleanups);\n\tqueue_work(ocfs2_wq, &journal->j_recovery_work);\n\tspin_unlock(&journal->j_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\nstatic int ocfs2_recover_orphans(struct ocfs2_super *osb,\n\t\t\t\t int slot,\n\t\t\t\t enum ocfs2_orphan_reco_type orphan_reco_type);\nstatic void ocfs2_queue_recovery_completion(struct ocfs2_journal *journal,\n\t\t\t\t\t    int slot_num,\n\t\t\t\t\t    struct ocfs2_dinode *la_dinode,\n\t\t\t\t\t    struct ocfs2_dinode *tl_dinode,\n\t\t\t\t\t    struct ocfs2_quota_recovery *qrec,\n\t\t\t\t\t    enum ocfs2_orphan_reco_type orphan_reco_type);\n\nvoid ocfs2_queue_replay_slots(struct ocfs2_super *osb,\n\t\tenum ocfs2_orphan_reco_type orphan_reco_type)\n{\n\tstruct ocfs2_replay_map *replay_map = osb->replay_map;\n\tint i;\n\n\tif (!replay_map)\n\t\treturn;\n\n\tif (replay_map->rm_state != REPLAY_NEEDED)\n\t\treturn;\n\n\tfor (i = 0; i < replay_map->rm_slots; i++)\n\t\tif (replay_map->rm_replay_slots[i])\n\t\t\tocfs2_queue_recovery_completion(osb->journal, i, NULL,\n\t\t\t\t\t\t\tNULL, NULL,\n\t\t\t\t\t\t\torphan_reco_type);\n\treplay_map->rm_state = REPLAY_DONE;\n}"
  },
  {
    "function_name": "ocfs2_compute_replay_slots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "123-154",
    "snippet": "int ocfs2_compute_replay_slots(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_replay_map *replay_map;\n\tint i, node_num;\n\n\t/* If replay map is already set, we don't do it again */\n\tif (osb->replay_map)\n\t\treturn 0;\n\n\treplay_map = kzalloc(sizeof(struct ocfs2_replay_map) +\n\t\t\t     (osb->max_slots * sizeof(char)), GFP_KERNEL);\n\n\tif (!replay_map) {\n\t\tmlog_errno(-ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock(&osb->osb_lock);\n\n\treplay_map->rm_slots = osb->max_slots;\n\treplay_map->rm_state = REPLAY_UNNEEDED;\n\n\t/* set rm_replay_slots for offline slot(s) */\n\tfor (i = 0; i < replay_map->rm_slots; i++) {\n\t\tif (ocfs2_slot_to_node_num_locked(osb, i, &node_num) == -ENOENT)\n\t\t\treplay_map->rm_replay_slots[i] = 1;\n\t}\n\n\tosb->replay_map = replay_map;\n\tspin_unlock(&osb->osb_lock);\n\treturn 0;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_slot_to_node_num_locked",
          "args": [
            "osb",
            "i",
            "&node_num"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_slot_to_node_num_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
          "lines": "301-316",
          "snippet": "int ocfs2_slot_to_node_num_locked(struct ocfs2_super *osb, int slot_num,\n\t\t\t\t  unsigned int *node_num)\n{\n\tstruct ocfs2_slot_info *si = osb->slot_info;\n\n\tassert_spin_locked(&osb->osb_lock);\n\n\tBUG_ON(slot_num < 0);\n\tBUG_ON(slot_num >= osb->max_slots);\n\n\tif (!si->si_slots[slot_num].sl_valid)\n\t\treturn -ENOENT;\n\n\t*node_num = si->si_slots[slot_num].sl_node_num;\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __ocfs2_node_num_to_slot(struct ocfs2_slot_info *si,\n\t\t\t\t    unsigned int node_num);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int __ocfs2_node_num_to_slot(struct ocfs2_slot_info *si,\n\t\t\t\t    unsigned int node_num);\n\nint ocfs2_slot_to_node_num_locked(struct ocfs2_super *osb, int slot_num,\n\t\t\t\t  unsigned int *node_num)\n{\n\tstruct ocfs2_slot_info *si = osb->slot_info;\n\n\tassert_spin_locked(&osb->osb_lock);\n\n\tBUG_ON(slot_num < 0);\n\tBUG_ON(slot_num >= osb->max_slots);\n\n\tif (!si->si_slots[slot_num].sl_valid)\n\t\treturn -ENOENT;\n\n\t*node_num = si->si_slots[slot_num].sl_node_num;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "-ENOMEM"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct ocfs2_replay_map) +\n\t\t\t     (osb->max_slots * sizeof(char))",
            "GFP_KERNEL"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_compute_replay_slots(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_replay_map *replay_map;\n\tint i, node_num;\n\n\t/* If replay map is already set, we don't do it again */\n\tif (osb->replay_map)\n\t\treturn 0;\n\n\treplay_map = kzalloc(sizeof(struct ocfs2_replay_map) +\n\t\t\t     (osb->max_slots * sizeof(char)), GFP_KERNEL);\n\n\tif (!replay_map) {\n\t\tmlog_errno(-ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock(&osb->osb_lock);\n\n\treplay_map->rm_slots = osb->max_slots;\n\treplay_map->rm_state = REPLAY_UNNEEDED;\n\n\t/* set rm_replay_slots for offline slot(s) */\n\tfor (i = 0; i < replay_map->rm_slots; i++) {\n\t\tif (ocfs2_slot_to_node_num_locked(osb, i, &node_num) == -ENOENT)\n\t\t\treplay_map->rm_replay_slots[i] = 1;\n\t}\n\n\tosb->replay_map = replay_map;\n\tspin_unlock(&osb->osb_lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_replay_map_set_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "111-121",
    "snippet": "void ocfs2_replay_map_set_state(struct ocfs2_super *osb, int state)\n{\n\tif (!osb->replay_map)\n\t\treturn;\n\n\t/* If we've already queued the replay, we don't have any more to do */\n\tif (osb->replay_map->rm_state == REPLAY_DONE)\n\t\treturn;\n\n\tosb->replay_map->rm_state = state;\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nvoid ocfs2_replay_map_set_state(struct ocfs2_super *osb, int state)\n{\n\tif (!osb->replay_map)\n\t\treturn;\n\n\t/* If we've already queued the replay, we don't have any more to do */\n\tif (osb->replay_map->rm_state == REPLAY_DONE)\n\t\treturn;\n\n\tosb->replay_map->rm_state = state;\n}"
  },
  {
    "function_name": "ocfs2_wait_on_quotas",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "89-92",
    "snippet": "static inline int ocfs2_wait_on_quotas(struct ocfs2_super *osb)\n{\n\treturn __ocfs2_wait_on_mount(osb, 1);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ocfs2_wait_on_mount",
          "args": [
            "osb",
            "1"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_wait_on_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "2220-2240",
          "snippet": "static int __ocfs2_wait_on_mount(struct ocfs2_super *osb, int quota)\n{\n\t/* This check is good because ocfs2 will wait on our recovery\n\t * thread before changing it to something other than MOUNTED\n\t * or DISABLED. */\n\twait_event(osb->osb_mount_event,\n\t\t  (!quota && atomic_read(&osb->vol_state) == VOLUME_MOUNTED) ||\n\t\t   atomic_read(&osb->vol_state) == VOLUME_MOUNTED_QUOTAS ||\n\t\t   atomic_read(&osb->vol_state) == VOLUME_DISABLED);\n\n\t/* If there's an error on mount, then we may never get to the\n\t * MOUNTED flag, but this is set right before\n\t * dismount_volume() so we can trust it. */\n\tif (atomic_read(&osb->vol_state) == VOLUME_DISABLED) {\n\t\ttrace_ocfs2_wait_on_mount(VOLUME_DISABLED);\n\t\tmlog(0, \"mount error, exiting!\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);",
            "static int __ocfs2_wait_on_mount(struct ocfs2_super *osb, int quota);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\nstatic int __ocfs2_wait_on_mount(struct ocfs2_super *osb, int quota);\n\nstatic int __ocfs2_wait_on_mount(struct ocfs2_super *osb, int quota)\n{\n\t/* This check is good because ocfs2 will wait on our recovery\n\t * thread before changing it to something other than MOUNTED\n\t * or DISABLED. */\n\twait_event(osb->osb_mount_event,\n\t\t  (!quota && atomic_read(&osb->vol_state) == VOLUME_MOUNTED) ||\n\t\t   atomic_read(&osb->vol_state) == VOLUME_MOUNTED_QUOTAS ||\n\t\t   atomic_read(&osb->vol_state) == VOLUME_DISABLED);\n\n\t/* If there's an error on mount, then we may never get to the\n\t * MOUNTED flag, but this is set right before\n\t * dismount_volume() so we can trust it. */\n\tif (atomic_read(&osb->vol_state) == VOLUME_DISABLED) {\n\t\ttrace_ocfs2_wait_on_mount(VOLUME_DISABLED);\n\t\tmlog(0, \"mount error, exiting!\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nstatic inline int ocfs2_wait_on_quotas(struct ocfs2_super *osb)\n{\n\treturn __ocfs2_wait_on_mount(osb, 1);\n}"
  },
  {
    "function_name": "ocfs2_wait_on_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
    "lines": "84-87",
    "snippet": "static inline int ocfs2_wait_on_mount(struct ocfs2_super *osb)\n{\n\treturn __ocfs2_wait_on_mount(osb, 0);\n}",
    "includes": [
      "#include \"ocfs2_trace.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"namei.h\"",
      "#include \"file.h\"",
      "#include \"quota.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"localalloc.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"blockcheck.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/delay.h>",
      "#include <linux/random.h>",
      "#include <linux/time.h>",
      "#include <linux/kthread.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ocfs2_wait_on_mount",
          "args": [
            "osb",
            "0"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_wait_on_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "2220-2240",
          "snippet": "static int __ocfs2_wait_on_mount(struct ocfs2_super *osb, int quota)\n{\n\t/* This check is good because ocfs2 will wait on our recovery\n\t * thread before changing it to something other than MOUNTED\n\t * or DISABLED. */\n\twait_event(osb->osb_mount_event,\n\t\t  (!quota && atomic_read(&osb->vol_state) == VOLUME_MOUNTED) ||\n\t\t   atomic_read(&osb->vol_state) == VOLUME_MOUNTED_QUOTAS ||\n\t\t   atomic_read(&osb->vol_state) == VOLUME_DISABLED);\n\n\t/* If there's an error on mount, then we may never get to the\n\t * MOUNTED flag, but this is set right before\n\t * dismount_volume() so we can trust it. */\n\tif (atomic_read(&osb->vol_state) == VOLUME_DISABLED) {\n\t\ttrace_ocfs2_wait_on_mount(VOLUME_DISABLED);\n\t\tmlog(0, \"mount error, exiting!\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);",
            "static int __ocfs2_wait_on_mount(struct ocfs2_super *osb, int quota);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\nstatic int __ocfs2_wait_on_mount(struct ocfs2_super *osb, int quota);\n\nstatic int __ocfs2_wait_on_mount(struct ocfs2_super *osb, int quota)\n{\n\t/* This check is good because ocfs2 will wait on our recovery\n\t * thread before changing it to something other than MOUNTED\n\t * or DISABLED. */\n\twait_event(osb->osb_mount_event,\n\t\t  (!quota && atomic_read(&osb->vol_state) == VOLUME_MOUNTED) ||\n\t\t   atomic_read(&osb->vol_state) == VOLUME_MOUNTED_QUOTAS ||\n\t\t   atomic_read(&osb->vol_state) == VOLUME_DISABLED);\n\n\t/* If there's an error on mount, then we may never get to the\n\t * MOUNTED flag, but this is set right before\n\t * dismount_volume() so we can trust it. */\n\tif (atomic_read(&osb->vol_state) == VOLUME_DISABLED) {\n\t\ttrace_ocfs2_wait_on_mount(VOLUME_DISABLED);\n\t\tmlog(0, \"mount error, exiting!\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nstatic inline int ocfs2_wait_on_mount(struct ocfs2_super *osb)\n{\n\treturn __ocfs2_wait_on_mount(osb, 0);\n}"
  }
]