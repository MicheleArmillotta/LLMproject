[
  {
    "function_name": "udf_get_pblock_meta25",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/partition.c",
    "lines": "306-339",
    "snippet": "uint32_t udf_get_pblock_meta25(struct super_block *sb, uint32_t block,\n\t\t\t\tuint16_t partition, uint32_t offset)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct udf_part_map *map;\n\tstruct udf_meta_data *mdata;\n\tuint32_t retblk;\n\tstruct inode *inode;\n\n\tudf_debug(\"READING from METADATA\\n\");\n\n\tmap = &sbi->s_partmaps[partition];\n\tmdata = &map->s_type_specific.s_metadata;\n\tinode = mdata->s_metadata_fe ? : mdata->s_mirror_fe;\n\n\t/* We shouldn't mount such media... */\n\tBUG_ON(!inode);\n\tretblk = udf_try_read_meta(inode, block, partition, offset);\n\tif (retblk == 0xFFFFFFFF && mdata->s_metadata_fe) {\n\t\tudf_warn(sb, \"error reading from METADATA, trying to read from MIRROR\\n\");\n\t\tif (!(mdata->s_flags & MF_MIRROR_FE_LOADED)) {\n\t\t\tmdata->s_mirror_fe = udf_find_metadata_inode_efe(sb,\n\t\t\t\tmdata->s_mirror_file_loc, map->s_partition_num);\n\t\t\tmdata->s_flags |= MF_MIRROR_FE_LOADED;\n\t\t}\n\n\t\tinode = mdata->s_mirror_fe;\n\t\tif (!inode)\n\t\t\treturn 0xFFFFFFFF;\n\t\tretblk = udf_try_read_meta(inode, block, partition, offset);\n\t}\n\n\treturn retblk;\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "udf_try_read_meta",
          "args": [
            "inode",
            "block",
            "partition",
            "offset"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "udf_try_read_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/partition.c",
          "lines": "281-304",
          "snippet": "static uint32_t udf_try_read_meta(struct inode *inode, uint32_t block,\n\t\t\t\t\tuint16_t partition, uint32_t offset)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct udf_part_map *map;\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tsector_t ext_offset;\n\tstruct extent_position epos = {};\n\tuint32_t phyblock;\n\n\tif (inode_bmap(inode, block, &epos, &eloc, &elen, &ext_offset) !=\n\t\t\t\t\t\t(EXT_RECORDED_ALLOCATED >> 30))\n\t\tphyblock = 0xFFFFFFFF;\n\telse {\n\t\tmap = &UDF_SB(sb)->s_partmaps[partition];\n\t\t/* map to sparable/physical partition desc */\n\t\tphyblock = udf_get_pblock(sb, eloc.logicalBlockNum,\n\t\t\tmap->s_partition_num, ext_offset + offset);\n\t}\n\n\tbrelse(epos.bh);\n\treturn phyblock;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include \"udfdecl.h\"\n\nstatic uint32_t udf_try_read_meta(struct inode *inode, uint32_t block,\n\t\t\t\t\tuint16_t partition, uint32_t offset)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct udf_part_map *map;\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tsector_t ext_offset;\n\tstruct extent_position epos = {};\n\tuint32_t phyblock;\n\n\tif (inode_bmap(inode, block, &epos, &eloc, &elen, &ext_offset) !=\n\t\t\t\t\t\t(EXT_RECORDED_ALLOCATED >> 30))\n\t\tphyblock = 0xFFFFFFFF;\n\telse {\n\t\tmap = &UDF_SB(sb)->s_partmaps[partition];\n\t\t/* map to sparable/physical partition desc */\n\t\tphyblock = udf_get_pblock(sb, eloc.logicalBlockNum,\n\t\t\tmap->s_partition_num, ext_offset + offset);\n\t}\n\n\tbrelse(epos.bh);\n\treturn phyblock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_find_metadata_inode_efe",
          "args": [
            "sb",
            "mdata->s_mirror_file_loc",
            "map->s_partition_num"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "udf_find_metadata_inode_efe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/super.c",
          "lines": "953-975",
          "snippet": "struct inode *udf_find_metadata_inode_efe(struct super_block *sb,\n\t\t\t\t\tu32 meta_file_loc, u32 partition_num)\n{\n\tstruct kernel_lb_addr addr;\n\tstruct inode *metadata_fe;\n\n\taddr.logicalBlockNum = meta_file_loc;\n\taddr.partitionReferenceNum = partition_num;\n\n\tmetadata_fe = udf_iget_special(sb, &addr);\n\n\tif (IS_ERR(metadata_fe)) {\n\t\tudf_warn(sb, \"metadata inode efe not found\\n\");\n\t\treturn metadata_fe;\n\t}\n\tif (UDF_I(metadata_fe)->i_alloc_type != ICBTAG_FLAG_AD_SHORT) {\n\t\tudf_warn(sb, \"metadata inode efe does not have short allocation descriptors!\\n\");\n\t\tiput(metadata_fe);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\treturn metadata_fe;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/init.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/log2.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/errno.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/nls.h>",
            "#include <linux/cdrom.h>",
            "#include <linux/stat.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_fill_super(struct super_block *, void *, int);",
            "static void udf_put_super(struct super_block *);",
            "static int udf_sync_fs(struct super_block *, int);",
            "static int udf_remount_fs(struct super_block *, int *, char *);",
            "static int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);",
            "static void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);",
            "static void udf_open_lvid(struct super_block *);",
            "static void udf_close_lvid(struct super_block *);",
            "static unsigned int udf_count_free(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/init.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include <asm/byteorder.h>\n#include <linux/log2.h>\n#include <linux/crc-itu-t.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/errno.h>\n#include <linux/vmalloc.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/nls.h>\n#include <linux/cdrom.h>\n#include <linux/stat.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include \"udfdecl.h\"\n\nstatic int udf_fill_super(struct super_block *, void *, int);\nstatic void udf_put_super(struct super_block *);\nstatic int udf_sync_fs(struct super_block *, int);\nstatic int udf_remount_fs(struct super_block *, int *, char *);\nstatic int udf_find_fileset(struct super_block *, struct kernel_lb_addr *,\n\t\t\t    struct kernel_lb_addr *);\nstatic void udf_load_fileset(struct super_block *, struct buffer_head *,\n\t\t\t     struct kernel_lb_addr *);\nstatic void udf_open_lvid(struct super_block *);\nstatic void udf_close_lvid(struct super_block *);\nstatic unsigned int udf_count_free(struct super_block *);\n\nstruct inode *udf_find_metadata_inode_efe(struct super_block *sb,\n\t\t\t\t\tu32 meta_file_loc, u32 partition_num)\n{\n\tstruct kernel_lb_addr addr;\n\tstruct inode *metadata_fe;\n\n\taddr.logicalBlockNum = meta_file_loc;\n\taddr.partitionReferenceNum = partition_num;\n\n\tmetadata_fe = udf_iget_special(sb, &addr);\n\n\tif (IS_ERR(metadata_fe)) {\n\t\tudf_warn(sb, \"metadata inode efe not found\\n\");\n\t\treturn metadata_fe;\n\t}\n\tif (UDF_I(metadata_fe)->i_alloc_type != ICBTAG_FLAG_AD_SHORT) {\n\t\tudf_warn(sb, \"metadata inode efe does not have short allocation descriptors!\\n\");\n\t\tiput(metadata_fe);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\treturn metadata_fe;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_warn",
          "args": [
            "sb",
            "\"error reading from METADATA, trying to read from MIRROR\\n\""
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!inode"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"READING from METADATA\\n\""
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include \"udfdecl.h\"\n\nuint32_t udf_get_pblock_meta25(struct super_block *sb, uint32_t block,\n\t\t\t\tuint16_t partition, uint32_t offset)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct udf_part_map *map;\n\tstruct udf_meta_data *mdata;\n\tuint32_t retblk;\n\tstruct inode *inode;\n\n\tudf_debug(\"READING from METADATA\\n\");\n\n\tmap = &sbi->s_partmaps[partition];\n\tmdata = &map->s_type_specific.s_metadata;\n\tinode = mdata->s_metadata_fe ? : mdata->s_mirror_fe;\n\n\t/* We shouldn't mount such media... */\n\tBUG_ON(!inode);\n\tretblk = udf_try_read_meta(inode, block, partition, offset);\n\tif (retblk == 0xFFFFFFFF && mdata->s_metadata_fe) {\n\t\tudf_warn(sb, \"error reading from METADATA, trying to read from MIRROR\\n\");\n\t\tif (!(mdata->s_flags & MF_MIRROR_FE_LOADED)) {\n\t\t\tmdata->s_mirror_fe = udf_find_metadata_inode_efe(sb,\n\t\t\t\tmdata->s_mirror_file_loc, map->s_partition_num);\n\t\t\tmdata->s_flags |= MF_MIRROR_FE_LOADED;\n\t\t}\n\n\t\tinode = mdata->s_mirror_fe;\n\t\tif (!inode)\n\t\t\treturn 0xFFFFFFFF;\n\t\tretblk = udf_try_read_meta(inode, block, partition, offset);\n\t}\n\n\treturn retblk;\n}"
  },
  {
    "function_name": "udf_try_read_meta",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/partition.c",
    "lines": "281-304",
    "snippet": "static uint32_t udf_try_read_meta(struct inode *inode, uint32_t block,\n\t\t\t\t\tuint16_t partition, uint32_t offset)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct udf_part_map *map;\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tsector_t ext_offset;\n\tstruct extent_position epos = {};\n\tuint32_t phyblock;\n\n\tif (inode_bmap(inode, block, &epos, &eloc, &elen, &ext_offset) !=\n\t\t\t\t\t\t(EXT_RECORDED_ALLOCATED >> 30))\n\t\tphyblock = 0xFFFFFFFF;\n\telse {\n\t\tmap = &UDF_SB(sb)->s_partmaps[partition];\n\t\t/* map to sparable/physical partition desc */\n\t\tphyblock = udf_get_pblock(sb, eloc.logicalBlockNum,\n\t\t\tmap->s_partition_num, ext_offset + offset);\n\t}\n\n\tbrelse(epos.bh);\n\treturn phyblock;\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "epos.bh"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_get_pblock",
          "args": [
            "sb",
            "eloc.logicalBlockNum",
            "map->s_partition_num",
            "ext_offset + offset"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "udf_get_pblock_meta25",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/partition.c",
          "lines": "306-339",
          "snippet": "uint32_t udf_get_pblock_meta25(struct super_block *sb, uint32_t block,\n\t\t\t\tuint16_t partition, uint32_t offset)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct udf_part_map *map;\n\tstruct udf_meta_data *mdata;\n\tuint32_t retblk;\n\tstruct inode *inode;\n\n\tudf_debug(\"READING from METADATA\\n\");\n\n\tmap = &sbi->s_partmaps[partition];\n\tmdata = &map->s_type_specific.s_metadata;\n\tinode = mdata->s_metadata_fe ? : mdata->s_mirror_fe;\n\n\t/* We shouldn't mount such media... */\n\tBUG_ON(!inode);\n\tretblk = udf_try_read_meta(inode, block, partition, offset);\n\tif (retblk == 0xFFFFFFFF && mdata->s_metadata_fe) {\n\t\tudf_warn(sb, \"error reading from METADATA, trying to read from MIRROR\\n\");\n\t\tif (!(mdata->s_flags & MF_MIRROR_FE_LOADED)) {\n\t\t\tmdata->s_mirror_fe = udf_find_metadata_inode_efe(sb,\n\t\t\t\tmdata->s_mirror_file_loc, map->s_partition_num);\n\t\t\tmdata->s_flags |= MF_MIRROR_FE_LOADED;\n\t\t}\n\n\t\tinode = mdata->s_mirror_fe;\n\t\tif (!inode)\n\t\t\treturn 0xFFFFFFFF;\n\t\tretblk = udf_try_read_meta(inode, block, partition, offset);\n\t}\n\n\treturn retblk;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include \"udfdecl.h\"\n\nuint32_t udf_get_pblock_meta25(struct super_block *sb, uint32_t block,\n\t\t\t\tuint16_t partition, uint32_t offset)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct udf_part_map *map;\n\tstruct udf_meta_data *mdata;\n\tuint32_t retblk;\n\tstruct inode *inode;\n\n\tudf_debug(\"READING from METADATA\\n\");\n\n\tmap = &sbi->s_partmaps[partition];\n\tmdata = &map->s_type_specific.s_metadata;\n\tinode = mdata->s_metadata_fe ? : mdata->s_mirror_fe;\n\n\t/* We shouldn't mount such media... */\n\tBUG_ON(!inode);\n\tretblk = udf_try_read_meta(inode, block, partition, offset);\n\tif (retblk == 0xFFFFFFFF && mdata->s_metadata_fe) {\n\t\tudf_warn(sb, \"error reading from METADATA, trying to read from MIRROR\\n\");\n\t\tif (!(mdata->s_flags & MF_MIRROR_FE_LOADED)) {\n\t\t\tmdata->s_mirror_fe = udf_find_metadata_inode_efe(sb,\n\t\t\t\tmdata->s_mirror_file_loc, map->s_partition_num);\n\t\t\tmdata->s_flags |= MF_MIRROR_FE_LOADED;\n\t\t}\n\n\t\tinode = mdata->s_mirror_fe;\n\t\tif (!inode)\n\t\t\treturn 0xFFFFFFFF;\n\t\tretblk = udf_try_read_meta(inode, block, partition, offset);\n\t}\n\n\treturn retblk;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_bmap",
          "args": [
            "inode",
            "block",
            "&epos",
            "&eloc",
            "&elen",
            "&ext_offset"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "inode_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "2237-2268",
          "snippet": "int8_t inode_bmap(struct inode *inode, sector_t block,\n\t\t  struct extent_position *pos, struct kernel_lb_addr *eloc,\n\t\t  uint32_t *elen, sector_t *offset)\n{\n\tunsigned char blocksize_bits = inode->i_sb->s_blocksize_bits;\n\tloff_t lbcount = 0, bcount =\n\t    (loff_t) block << blocksize_bits;\n\tint8_t etype;\n\tstruct udf_inode_info *iinfo;\n\n\tiinfo = UDF_I(inode);\n\tif (!udf_read_extent_cache(inode, bcount, &lbcount, pos)) {\n\t\tpos->offset = 0;\n\t\tpos->block = iinfo->i_location;\n\t\tpos->bh = NULL;\n\t}\n\t*elen = 0;\n\tdo {\n\t\tetype = udf_next_aext(inode, pos, eloc, elen, 1);\n\t\tif (etype == -1) {\n\t\t\t*offset = (bcount - lbcount) >> blocksize_bits;\n\t\t\tiinfo->i_lenExtents = lbcount;\n\t\t\treturn -1;\n\t\t}\n\t\tlbcount += *elen;\n\t} while (lbcount <= bcount);\n\t/* update extent cache */\n\tudf_update_extent_cache(inode, lbcount - *elen, pos, 1);\n\t*offset = (bcount + *elen - lbcount) >> blocksize_bits;\n\n\treturn etype;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static sector_t inode_getblk(struct inode *, sector_t, int *, int *);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic sector_t inode_getblk(struct inode *, sector_t, int *, int *);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nint8_t inode_bmap(struct inode *inode, sector_t block,\n\t\t  struct extent_position *pos, struct kernel_lb_addr *eloc,\n\t\t  uint32_t *elen, sector_t *offset)\n{\n\tunsigned char blocksize_bits = inode->i_sb->s_blocksize_bits;\n\tloff_t lbcount = 0, bcount =\n\t    (loff_t) block << blocksize_bits;\n\tint8_t etype;\n\tstruct udf_inode_info *iinfo;\n\n\tiinfo = UDF_I(inode);\n\tif (!udf_read_extent_cache(inode, bcount, &lbcount, pos)) {\n\t\tpos->offset = 0;\n\t\tpos->block = iinfo->i_location;\n\t\tpos->bh = NULL;\n\t}\n\t*elen = 0;\n\tdo {\n\t\tetype = udf_next_aext(inode, pos, eloc, elen, 1);\n\t\tif (etype == -1) {\n\t\t\t*offset = (bcount - lbcount) >> blocksize_bits;\n\t\t\tiinfo->i_lenExtents = lbcount;\n\t\t\treturn -1;\n\t\t}\n\t\tlbcount += *elen;\n\t} while (lbcount <= bcount);\n\t/* update extent cache */\n\tudf_update_extent_cache(inode, lbcount - *elen, pos, 1);\n\t*offset = (bcount + *elen - lbcount) >> blocksize_bits;\n\n\treturn etype;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include \"udfdecl.h\"\n\nstatic uint32_t udf_try_read_meta(struct inode *inode, uint32_t block,\n\t\t\t\t\tuint16_t partition, uint32_t offset)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct udf_part_map *map;\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tsector_t ext_offset;\n\tstruct extent_position epos = {};\n\tuint32_t phyblock;\n\n\tif (inode_bmap(inode, block, &epos, &eloc, &elen, &ext_offset) !=\n\t\t\t\t\t\t(EXT_RECORDED_ALLOCATED >> 30))\n\t\tphyblock = 0xFFFFFFFF;\n\telse {\n\t\tmap = &UDF_SB(sb)->s_partmaps[partition];\n\t\t/* map to sparable/physical partition desc */\n\t\tphyblock = udf_get_pblock(sb, eloc.logicalBlockNum,\n\t\t\tmap->s_partition_num, ext_offset + offset);\n\t}\n\n\tbrelse(epos.bh);\n\treturn phyblock;\n}"
  },
  {
    "function_name": "udf_relocate_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/partition.c",
    "lines": "153-279",
    "snippet": "int udf_relocate_blocks(struct super_block *sb, long old_block, long *new_block)\n{\n\tstruct udf_sparing_data *sdata;\n\tstruct sparingTable *st = NULL;\n\tstruct sparingEntry mapEntry;\n\tuint32_t packet;\n\tint i, j, k, l;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tu16 reallocationTableLen;\n\tstruct buffer_head *bh;\n\tint ret = 0;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tfor (i = 0; i < sbi->s_partitions; i++) {\n\t\tstruct udf_part_map *map = &sbi->s_partmaps[i];\n\t\tif (old_block > map->s_partition_root &&\n\t\t    old_block < map->s_partition_root + map->s_partition_len) {\n\t\t\tsdata = &map->s_type_specific.s_sparing;\n\t\t\tpacket = (old_block - map->s_partition_root) &\n\t\t\t\t\t\t~(sdata->s_packet_len - 1);\n\n\t\t\tfor (j = 0; j < 4; j++)\n\t\t\t\tif (sdata->s_spar_map[j] != NULL) {\n\t\t\t\t\tst = (struct sparingTable *)\n\t\t\t\t\t\tsdata->s_spar_map[j]->b_data;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tif (!st) {\n\t\t\t\tret = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\treallocationTableLen =\n\t\t\t\t\tle16_to_cpu(st->reallocationTableLen);\n\t\t\tfor (k = 0; k < reallocationTableLen; k++) {\n\t\t\t\tstruct sparingEntry *entry = &st->mapEntry[k];\n\t\t\t\tu32 origLoc = le32_to_cpu(entry->origLocation);\n\n\t\t\t\tif (origLoc == 0xFFFFFFFF) {\n\t\t\t\t\tfor (; j < 4; j++) {\n\t\t\t\t\t\tint len;\n\t\t\t\t\t\tbh = sdata->s_spar_map[j];\n\t\t\t\t\t\tif (!bh)\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tst = (struct sparingTable *)\n\t\t\t\t\t\t\t\tbh->b_data;\n\t\t\t\t\t\tentry->origLocation =\n\t\t\t\t\t\t\tcpu_to_le32(packet);\n\t\t\t\t\t\tlen =\n\t\t\t\t\t\t  sizeof(struct sparingTable) +\n\t\t\t\t\t\t  reallocationTableLen *\n\t\t\t\t\t\t  sizeof(struct sparingEntry);\n\t\t\t\t\t\tudf_update_tag((char *)st, len);\n\t\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\t}\n\t\t\t\t\t*new_block = le32_to_cpu(\n\t\t\t\t\t\t\tentry->mappedLocation) +\n\t\t\t\t\t\t     ((old_block -\n\t\t\t\t\t\t\tmap->s_partition_root) &\n\t\t\t\t\t\t     (sdata->s_packet_len - 1));\n\t\t\t\t\tret = 0;\n\t\t\t\t\tgoto out;\n\t\t\t\t} else if (origLoc == packet) {\n\t\t\t\t\t*new_block = le32_to_cpu(\n\t\t\t\t\t\t\tentry->mappedLocation) +\n\t\t\t\t\t\t     ((old_block -\n\t\t\t\t\t\t\tmap->s_partition_root) &\n\t\t\t\t\t\t     (sdata->s_packet_len - 1));\n\t\t\t\t\tret = 0;\n\t\t\t\t\tgoto out;\n\t\t\t\t} else if (origLoc > packet)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (l = k; l < reallocationTableLen; l++) {\n\t\t\t\tstruct sparingEntry *entry = &st->mapEntry[l];\n\t\t\t\tu32 origLoc = le32_to_cpu(entry->origLocation);\n\n\t\t\t\tif (origLoc != 0xFFFFFFFF)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfor (; j < 4; j++) {\n\t\t\t\t\tbh = sdata->s_spar_map[j];\n\t\t\t\t\tif (!bh)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tst = (struct sparingTable *)bh->b_data;\n\t\t\t\t\tmapEntry = st->mapEntry[l];\n\t\t\t\t\tmapEntry.origLocation =\n\t\t\t\t\t\t\tcpu_to_le32(packet);\n\t\t\t\t\tmemmove(&st->mapEntry[k + 1],\n\t\t\t\t\t\t&st->mapEntry[k],\n\t\t\t\t\t\t(l - k) *\n\t\t\t\t\t\tsizeof(struct sparingEntry));\n\t\t\t\t\tst->mapEntry[k] = mapEntry;\n\t\t\t\t\tudf_update_tag((char *)st,\n\t\t\t\t\t\tsizeof(struct sparingTable) +\n\t\t\t\t\t\treallocationTableLen *\n\t\t\t\t\t\tsizeof(struct sparingEntry));\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t}\n\t\t\t\t*new_block =\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\t      st->mapEntry[k].mappedLocation) +\n\t\t\t\t\t((old_block - map->s_partition_root) &\n\t\t\t\t\t (sdata->s_packet_len - 1));\n\t\t\t\tret = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t} /* if old_block */\n\t}\n\n\tif (i == sbi->s_partitions) {\n\t\t/* outside of partitions */\n\t\t/* for now, fail =) */\n\t\tret = 1;\n\t}\n\nout:\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sbi->s_alloc_mutex"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "st->mapEntry[k].mappedLocation"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_update_tag",
          "args": [
            "(char *)st",
            "sizeof(struct sparingTable) +\n\t\t\t\t\t\treallocationTableLen *\n\t\t\t\t\t\tsizeof(struct sparingEntry)"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "udf_update_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/misc.c",
          "lines": "269-277",
          "snippet": "void udf_update_tag(char *data, int length)\n{\n\tstruct tag *tptr = (struct tag *)data;\n\tlength -= sizeof(struct tag);\n\n\ttptr->descCRCLength = cpu_to_le16(length);\n\ttptr->descCRC = cpu_to_le16(crc_itu_t(0, data + sizeof(struct tag), length));\n\ttptr->tagChecksum = udf_tag_checksum(tptr);\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udfdecl.h\"\n\nvoid udf_update_tag(char *data, int length)\n{\n\tstruct tag *tptr = (struct tag *)data;\n\tlength -= sizeof(struct tag);\n\n\ttptr->descCRCLength = cpu_to_le16(length);\n\ttptr->descCRC = cpu_to_le16(crc_itu_t(0, data + sizeof(struct tag), length));\n\ttptr->tagChecksum = udf_tag_checksum(tptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&st->mapEntry[k + 1]",
            "&st->mapEntry[k]",
            "(l - k) *\n\t\t\t\t\t\tsizeof(struct sparingEntry)"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "packet"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "packet"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "st->reallocationTableLen"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sbi->s_alloc_mutex"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include \"udfdecl.h\"\n\nint udf_relocate_blocks(struct super_block *sb, long old_block, long *new_block)\n{\n\tstruct udf_sparing_data *sdata;\n\tstruct sparingTable *st = NULL;\n\tstruct sparingEntry mapEntry;\n\tuint32_t packet;\n\tint i, j, k, l;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tu16 reallocationTableLen;\n\tstruct buffer_head *bh;\n\tint ret = 0;\n\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tfor (i = 0; i < sbi->s_partitions; i++) {\n\t\tstruct udf_part_map *map = &sbi->s_partmaps[i];\n\t\tif (old_block > map->s_partition_root &&\n\t\t    old_block < map->s_partition_root + map->s_partition_len) {\n\t\t\tsdata = &map->s_type_specific.s_sparing;\n\t\t\tpacket = (old_block - map->s_partition_root) &\n\t\t\t\t\t\t~(sdata->s_packet_len - 1);\n\n\t\t\tfor (j = 0; j < 4; j++)\n\t\t\t\tif (sdata->s_spar_map[j] != NULL) {\n\t\t\t\t\tst = (struct sparingTable *)\n\t\t\t\t\t\tsdata->s_spar_map[j]->b_data;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tif (!st) {\n\t\t\t\tret = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\treallocationTableLen =\n\t\t\t\t\tle16_to_cpu(st->reallocationTableLen);\n\t\t\tfor (k = 0; k < reallocationTableLen; k++) {\n\t\t\t\tstruct sparingEntry *entry = &st->mapEntry[k];\n\t\t\t\tu32 origLoc = le32_to_cpu(entry->origLocation);\n\n\t\t\t\tif (origLoc == 0xFFFFFFFF) {\n\t\t\t\t\tfor (; j < 4; j++) {\n\t\t\t\t\t\tint len;\n\t\t\t\t\t\tbh = sdata->s_spar_map[j];\n\t\t\t\t\t\tif (!bh)\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tst = (struct sparingTable *)\n\t\t\t\t\t\t\t\tbh->b_data;\n\t\t\t\t\t\tentry->origLocation =\n\t\t\t\t\t\t\tcpu_to_le32(packet);\n\t\t\t\t\t\tlen =\n\t\t\t\t\t\t  sizeof(struct sparingTable) +\n\t\t\t\t\t\t  reallocationTableLen *\n\t\t\t\t\t\t  sizeof(struct sparingEntry);\n\t\t\t\t\t\tudf_update_tag((char *)st, len);\n\t\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\t}\n\t\t\t\t\t*new_block = le32_to_cpu(\n\t\t\t\t\t\t\tentry->mappedLocation) +\n\t\t\t\t\t\t     ((old_block -\n\t\t\t\t\t\t\tmap->s_partition_root) &\n\t\t\t\t\t\t     (sdata->s_packet_len - 1));\n\t\t\t\t\tret = 0;\n\t\t\t\t\tgoto out;\n\t\t\t\t} else if (origLoc == packet) {\n\t\t\t\t\t*new_block = le32_to_cpu(\n\t\t\t\t\t\t\tentry->mappedLocation) +\n\t\t\t\t\t\t     ((old_block -\n\t\t\t\t\t\t\tmap->s_partition_root) &\n\t\t\t\t\t\t     (sdata->s_packet_len - 1));\n\t\t\t\t\tret = 0;\n\t\t\t\t\tgoto out;\n\t\t\t\t} else if (origLoc > packet)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (l = k; l < reallocationTableLen; l++) {\n\t\t\t\tstruct sparingEntry *entry = &st->mapEntry[l];\n\t\t\t\tu32 origLoc = le32_to_cpu(entry->origLocation);\n\n\t\t\t\tif (origLoc != 0xFFFFFFFF)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfor (; j < 4; j++) {\n\t\t\t\t\tbh = sdata->s_spar_map[j];\n\t\t\t\t\tif (!bh)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tst = (struct sparingTable *)bh->b_data;\n\t\t\t\t\tmapEntry = st->mapEntry[l];\n\t\t\t\t\tmapEntry.origLocation =\n\t\t\t\t\t\t\tcpu_to_le32(packet);\n\t\t\t\t\tmemmove(&st->mapEntry[k + 1],\n\t\t\t\t\t\t&st->mapEntry[k],\n\t\t\t\t\t\t(l - k) *\n\t\t\t\t\t\tsizeof(struct sparingEntry));\n\t\t\t\t\tst->mapEntry[k] = mapEntry;\n\t\t\t\t\tudf_update_tag((char *)st,\n\t\t\t\t\t\tsizeof(struct sparingTable) +\n\t\t\t\t\t\treallocationTableLen *\n\t\t\t\t\t\tsizeof(struct sparingEntry));\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t}\n\t\t\t\t*new_block =\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\t      st->mapEntry[k].mappedLocation) +\n\t\t\t\t\t((old_block - map->s_partition_root) &\n\t\t\t\t\t (sdata->s_packet_len - 1));\n\t\t\t\tret = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t} /* if old_block */\n\t}\n\n\tif (i == sbi->s_partitions) {\n\t\t/* outside of partitions */\n\t\t/* for now, fail =) */\n\t\tret = 1;\n\t}\n\nout:\n\tmutex_unlock(&sbi->s_alloc_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "udf_get_pblock_spar15",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/partition.c",
    "lines": "113-151",
    "snippet": "uint32_t udf_get_pblock_spar15(struct super_block *sb, uint32_t block,\n\t\t\t       uint16_t partition, uint32_t offset)\n{\n\tint i;\n\tstruct sparingTable *st = NULL;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct udf_part_map *map;\n\tuint32_t packet;\n\tstruct udf_sparing_data *sdata;\n\n\tmap = &sbi->s_partmaps[partition];\n\tsdata = &map->s_type_specific.s_sparing;\n\tpacket = (block + offset) & ~(sdata->s_packet_len - 1);\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (sdata->s_spar_map[i] != NULL) {\n\t\t\tst = (struct sparingTable *)\n\t\t\t\t\tsdata->s_spar_map[i]->b_data;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (st) {\n\t\tfor (i = 0; i < le16_to_cpu(st->reallocationTableLen); i++) {\n\t\t\tstruct sparingEntry *entry = &st->mapEntry[i];\n\t\t\tu32 origLoc = le32_to_cpu(entry->origLocation);\n\t\t\tif (origLoc >= 0xFFFFFFF0)\n\t\t\t\tbreak;\n\t\t\telse if (origLoc == packet)\n\t\t\t\treturn le32_to_cpu(entry->mappedLocation) +\n\t\t\t\t\t((block + offset) &\n\t\t\t\t\t\t(sdata->s_packet_len - 1));\n\t\t\telse if (origLoc > packet)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn map->s_partition_root + block + offset;\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "entry->mappedLocation"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "st->reallocationTableLen"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include \"udfdecl.h\"\n\nuint32_t udf_get_pblock_spar15(struct super_block *sb, uint32_t block,\n\t\t\t       uint16_t partition, uint32_t offset)\n{\n\tint i;\n\tstruct sparingTable *st = NULL;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct udf_part_map *map;\n\tuint32_t packet;\n\tstruct udf_sparing_data *sdata;\n\n\tmap = &sbi->s_partmaps[partition];\n\tsdata = &map->s_type_specific.s_sparing;\n\tpacket = (block + offset) & ~(sdata->s_packet_len - 1);\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (sdata->s_spar_map[i] != NULL) {\n\t\t\tst = (struct sparingTable *)\n\t\t\t\t\tsdata->s_spar_map[i]->b_data;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (st) {\n\t\tfor (i = 0; i < le16_to_cpu(st->reallocationTableLen); i++) {\n\t\t\tstruct sparingEntry *entry = &st->mapEntry[i];\n\t\t\tu32 origLoc = le32_to_cpu(entry->origLocation);\n\t\t\tif (origLoc >= 0xFFFFFFF0)\n\t\t\t\tbreak;\n\t\t\telse if (origLoc == packet)\n\t\t\t\treturn le32_to_cpu(entry->mappedLocation) +\n\t\t\t\t\t((block + offset) &\n\t\t\t\t\t\t(sdata->s_packet_len - 1));\n\t\t\telse if (origLoc > packet)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn map->s_partition_root + block + offset;\n}"
  },
  {
    "function_name": "udf_get_pblock_virt20",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/partition.c",
    "lines": "107-111",
    "snippet": "inline uint32_t udf_get_pblock_virt20(struct super_block *sb, uint32_t block,\n\t\t\t\t      uint16_t partition, uint32_t offset)\n{\n\treturn udf_get_pblock_virt15(sb, block, partition, offset);\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "udf_get_pblock_virt15",
          "args": [
            "sb",
            "block",
            "partition",
            "offset"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "udf_get_pblock_virt15",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/partition.c",
          "lines": "47-105",
          "snippet": "uint32_t udf_get_pblock_virt15(struct super_block *sb, uint32_t block,\n\t\t\t       uint16_t partition, uint32_t offset)\n{\n\tstruct buffer_head *bh = NULL;\n\tuint32_t newblock;\n\tuint32_t index;\n\tuint32_t loc;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct udf_part_map *map;\n\tstruct udf_virtual_data *vdata;\n\tstruct udf_inode_info *iinfo = UDF_I(sbi->s_vat_inode);\n\n\tmap = &sbi->s_partmaps[partition];\n\tvdata = &map->s_type_specific.s_virtual;\n\n\tif (block > vdata->s_num_entries) {\n\t\tudf_debug(\"Trying to access block beyond end of VAT (%d max %d)\\n\",\n\t\t\t  block, vdata->s_num_entries);\n\t\treturn 0xFFFFFFFF;\n\t}\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\tloc = le32_to_cpu(((__le32 *)(iinfo->i_ext.i_data +\n\t\t\tvdata->s_start_offset))[block]);\n\t\tgoto translate;\n\t}\n\tindex = (sb->s_blocksize - vdata->s_start_offset) / sizeof(uint32_t);\n\tif (block >= index) {\n\t\tblock -= index;\n\t\tnewblock = 1 + (block / (sb->s_blocksize / sizeof(uint32_t)));\n\t\tindex = block % (sb->s_blocksize / sizeof(uint32_t));\n\t} else {\n\t\tnewblock = 0;\n\t\tindex = vdata->s_start_offset / sizeof(uint32_t) + block;\n\t}\n\n\tloc = udf_block_map(sbi->s_vat_inode, newblock);\n\n\tbh = sb_bread(sb, loc);\n\tif (!bh) {\n\t\tudf_debug(\"get_pblock(UDF_VIRTUAL_MAP:%p,%d,%d) VAT: %d[%d]\\n\",\n\t\t\t  sb, block, partition, loc, index);\n\t\treturn 0xFFFFFFFF;\n\t}\n\n\tloc = le32_to_cpu(((__le32 *)bh->b_data)[index]);\n\n\tbrelse(bh);\n\ntranslate:\n\tif (iinfo->i_location.partitionReferenceNum == partition) {\n\t\tudf_debug(\"recursive call to udf_get_pblock!\\n\");\n\t\treturn 0xFFFFFFFF;\n\t}\n\n\treturn udf_get_pblock(sb, loc,\n\t\t\t      iinfo->i_location.partitionReferenceNum,\n\t\t\t      offset);\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include \"udfdecl.h\"\n\nuint32_t udf_get_pblock_virt15(struct super_block *sb, uint32_t block,\n\t\t\t       uint16_t partition, uint32_t offset)\n{\n\tstruct buffer_head *bh = NULL;\n\tuint32_t newblock;\n\tuint32_t index;\n\tuint32_t loc;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct udf_part_map *map;\n\tstruct udf_virtual_data *vdata;\n\tstruct udf_inode_info *iinfo = UDF_I(sbi->s_vat_inode);\n\n\tmap = &sbi->s_partmaps[partition];\n\tvdata = &map->s_type_specific.s_virtual;\n\n\tif (block > vdata->s_num_entries) {\n\t\tudf_debug(\"Trying to access block beyond end of VAT (%d max %d)\\n\",\n\t\t\t  block, vdata->s_num_entries);\n\t\treturn 0xFFFFFFFF;\n\t}\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\tloc = le32_to_cpu(((__le32 *)(iinfo->i_ext.i_data +\n\t\t\tvdata->s_start_offset))[block]);\n\t\tgoto translate;\n\t}\n\tindex = (sb->s_blocksize - vdata->s_start_offset) / sizeof(uint32_t);\n\tif (block >= index) {\n\t\tblock -= index;\n\t\tnewblock = 1 + (block / (sb->s_blocksize / sizeof(uint32_t)));\n\t\tindex = block % (sb->s_blocksize / sizeof(uint32_t));\n\t} else {\n\t\tnewblock = 0;\n\t\tindex = vdata->s_start_offset / sizeof(uint32_t) + block;\n\t}\n\n\tloc = udf_block_map(sbi->s_vat_inode, newblock);\n\n\tbh = sb_bread(sb, loc);\n\tif (!bh) {\n\t\tudf_debug(\"get_pblock(UDF_VIRTUAL_MAP:%p,%d,%d) VAT: %d[%d]\\n\",\n\t\t\t  sb, block, partition, loc, index);\n\t\treturn 0xFFFFFFFF;\n\t}\n\n\tloc = le32_to_cpu(((__le32 *)bh->b_data)[index]);\n\n\tbrelse(bh);\n\ntranslate:\n\tif (iinfo->i_location.partitionReferenceNum == partition) {\n\t\tudf_debug(\"recursive call to udf_get_pblock!\\n\");\n\t\treturn 0xFFFFFFFF;\n\t}\n\n\treturn udf_get_pblock(sb, loc,\n\t\t\t      iinfo->i_location.partitionReferenceNum,\n\t\t\t      offset);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include \"udfdecl.h\"\n\ninline uint32_t udf_get_pblock_virt20(struct super_block *sb, uint32_t block,\n\t\t\t\t      uint16_t partition, uint32_t offset)\n{\n\treturn udf_get_pblock_virt15(sb, block, partition, offset);\n}"
  },
  {
    "function_name": "udf_get_pblock_virt15",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/partition.c",
    "lines": "47-105",
    "snippet": "uint32_t udf_get_pblock_virt15(struct super_block *sb, uint32_t block,\n\t\t\t       uint16_t partition, uint32_t offset)\n{\n\tstruct buffer_head *bh = NULL;\n\tuint32_t newblock;\n\tuint32_t index;\n\tuint32_t loc;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct udf_part_map *map;\n\tstruct udf_virtual_data *vdata;\n\tstruct udf_inode_info *iinfo = UDF_I(sbi->s_vat_inode);\n\n\tmap = &sbi->s_partmaps[partition];\n\tvdata = &map->s_type_specific.s_virtual;\n\n\tif (block > vdata->s_num_entries) {\n\t\tudf_debug(\"Trying to access block beyond end of VAT (%d max %d)\\n\",\n\t\t\t  block, vdata->s_num_entries);\n\t\treturn 0xFFFFFFFF;\n\t}\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\tloc = le32_to_cpu(((__le32 *)(iinfo->i_ext.i_data +\n\t\t\tvdata->s_start_offset))[block]);\n\t\tgoto translate;\n\t}\n\tindex = (sb->s_blocksize - vdata->s_start_offset) / sizeof(uint32_t);\n\tif (block >= index) {\n\t\tblock -= index;\n\t\tnewblock = 1 + (block / (sb->s_blocksize / sizeof(uint32_t)));\n\t\tindex = block % (sb->s_blocksize / sizeof(uint32_t));\n\t} else {\n\t\tnewblock = 0;\n\t\tindex = vdata->s_start_offset / sizeof(uint32_t) + block;\n\t}\n\n\tloc = udf_block_map(sbi->s_vat_inode, newblock);\n\n\tbh = sb_bread(sb, loc);\n\tif (!bh) {\n\t\tudf_debug(\"get_pblock(UDF_VIRTUAL_MAP:%p,%d,%d) VAT: %d[%d]\\n\",\n\t\t\t  sb, block, partition, loc, index);\n\t\treturn 0xFFFFFFFF;\n\t}\n\n\tloc = le32_to_cpu(((__le32 *)bh->b_data)[index]);\n\n\tbrelse(bh);\n\ntranslate:\n\tif (iinfo->i_location.partitionReferenceNum == partition) {\n\t\tudf_debug(\"recursive call to udf_get_pblock!\\n\");\n\t\treturn 0xFFFFFFFF;\n\t}\n\n\treturn udf_get_pblock(sb, loc,\n\t\t\t      iinfo->i_location.partitionReferenceNum,\n\t\t\t      offset);\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "udf_get_pblock",
          "args": [
            "sb",
            "loc",
            "iinfo->i_location.partitionReferenceNum",
            "offset"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "udf_get_pblock_meta25",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/partition.c",
          "lines": "306-339",
          "snippet": "uint32_t udf_get_pblock_meta25(struct super_block *sb, uint32_t block,\n\t\t\t\tuint16_t partition, uint32_t offset)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct udf_part_map *map;\n\tstruct udf_meta_data *mdata;\n\tuint32_t retblk;\n\tstruct inode *inode;\n\n\tudf_debug(\"READING from METADATA\\n\");\n\n\tmap = &sbi->s_partmaps[partition];\n\tmdata = &map->s_type_specific.s_metadata;\n\tinode = mdata->s_metadata_fe ? : mdata->s_mirror_fe;\n\n\t/* We shouldn't mount such media... */\n\tBUG_ON(!inode);\n\tretblk = udf_try_read_meta(inode, block, partition, offset);\n\tif (retblk == 0xFFFFFFFF && mdata->s_metadata_fe) {\n\t\tudf_warn(sb, \"error reading from METADATA, trying to read from MIRROR\\n\");\n\t\tif (!(mdata->s_flags & MF_MIRROR_FE_LOADED)) {\n\t\t\tmdata->s_mirror_fe = udf_find_metadata_inode_efe(sb,\n\t\t\t\tmdata->s_mirror_file_loc, map->s_partition_num);\n\t\t\tmdata->s_flags |= MF_MIRROR_FE_LOADED;\n\t\t}\n\n\t\tinode = mdata->s_mirror_fe;\n\t\tif (!inode)\n\t\t\treturn 0xFFFFFFFF;\n\t\tretblk = udf_try_read_meta(inode, block, partition, offset);\n\t}\n\n\treturn retblk;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include \"udf_i.h\"",
            "#include \"udf_sb.h\"",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include \"udfdecl.h\"\n\nuint32_t udf_get_pblock_meta25(struct super_block *sb, uint32_t block,\n\t\t\t\tuint16_t partition, uint32_t offset)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct udf_part_map *map;\n\tstruct udf_meta_data *mdata;\n\tuint32_t retblk;\n\tstruct inode *inode;\n\n\tudf_debug(\"READING from METADATA\\n\");\n\n\tmap = &sbi->s_partmaps[partition];\n\tmdata = &map->s_type_specific.s_metadata;\n\tinode = mdata->s_metadata_fe ? : mdata->s_mirror_fe;\n\n\t/* We shouldn't mount such media... */\n\tBUG_ON(!inode);\n\tretblk = udf_try_read_meta(inode, block, partition, offset);\n\tif (retblk == 0xFFFFFFFF && mdata->s_metadata_fe) {\n\t\tudf_warn(sb, \"error reading from METADATA, trying to read from MIRROR\\n\");\n\t\tif (!(mdata->s_flags & MF_MIRROR_FE_LOADED)) {\n\t\t\tmdata->s_mirror_fe = udf_find_metadata_inode_efe(sb,\n\t\t\t\tmdata->s_mirror_file_loc, map->s_partition_num);\n\t\t\tmdata->s_flags |= MF_MIRROR_FE_LOADED;\n\t\t}\n\n\t\tinode = mdata->s_mirror_fe;\n\t\tif (!inode)\n\t\t\treturn 0xFFFFFFFF;\n\t\tretblk = udf_try_read_meta(inode, block, partition, offset);\n\t}\n\n\treturn retblk;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"recursive call to udf_get_pblock!\\n\""
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "((__le32 *)bh->b_data)[index]"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"get_pblock(UDF_VIRTUAL_MAP:%p,%d,%d) VAT: %d[%d]\\n\"",
            "sb",
            "block",
            "partition",
            "loc",
            "index"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "loc"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_block_map",
          "args": [
            "sbi->s_vat_inode",
            "newblock"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "udf_block_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/inode.c",
          "lines": "2270-2293",
          "snippet": "long udf_block_map(struct inode *inode, sector_t block)\n{\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tsector_t offset;\n\tstruct extent_position epos = {};\n\tint ret;\n\n\tdown_read(&UDF_I(inode)->i_data_sem);\n\n\tif (inode_bmap(inode, block, &epos, &eloc, &elen, &offset) ==\n\t\t\t\t\t\t(EXT_RECORDED_ALLOCATED >> 30))\n\t\tret = udf_get_lb_pblock(inode->i_sb, &eloc, offset);\n\telse\n\t\tret = 0;\n\n\tup_read(&UDF_I(inode)->i_data_sem);\n\tbrelse(epos.bh);\n\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_VARCONV))\n\t\treturn udf_fixed_to_variable(ret);\n\telse\n\t\treturn ret;\n}",
          "includes": [
            "#include \"udf_sb.h\"",
            "#include \"udf_i.h\"",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include \"udfdecl.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int udf_update_inode(struct inode *, int);",
            "static int udf_sync_inode(struct inode *inode);",
            "static sector_t inode_getblk(struct inode *, sector_t, int *, int *);",
            "static int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"udf_sb.h\"\n#include \"udf_i.h\"\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/crc-itu-t.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include \"udfdecl.h\"\n\nstatic int udf_update_inode(struct inode *, int);\nstatic int udf_sync_inode(struct inode *inode);\nstatic sector_t inode_getblk(struct inode *, sector_t, int *, int *);\nstatic int8_t udf_insert_aext(struct inode *, struct extent_position,\n\t\t\t      struct kernel_lb_addr, uint32_t);\n\nlong udf_block_map(struct inode *inode, sector_t block)\n{\n\tstruct kernel_lb_addr eloc;\n\tuint32_t elen;\n\tsector_t offset;\n\tstruct extent_position epos = {};\n\tint ret;\n\n\tdown_read(&UDF_I(inode)->i_data_sem);\n\n\tif (inode_bmap(inode, block, &epos, &eloc, &elen, &offset) ==\n\t\t\t\t\t\t(EXT_RECORDED_ALLOCATED >> 30))\n\t\tret = udf_get_lb_pblock(inode->i_sb, &eloc, offset);\n\telse\n\t\tret = 0;\n\n\tup_read(&UDF_I(inode)->i_data_sem);\n\tbrelse(epos.bh);\n\n\tif (UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_VARCONV))\n\t\treturn udf_fixed_to_variable(ret);\n\telse\n\t\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"Trying to access block beyond end of VAT (%d max %d)\\n\"",
            "block",
            "vdata->s_num_entries"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_I",
          "args": [
            "sbi->s_vat_inode"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_i.h",
          "lines": "57-60",
          "snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct udf_inode_info *UDF_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct udf_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include \"udfdecl.h\"\n\nuint32_t udf_get_pblock_virt15(struct super_block *sb, uint32_t block,\n\t\t\t       uint16_t partition, uint32_t offset)\n{\n\tstruct buffer_head *bh = NULL;\n\tuint32_t newblock;\n\tuint32_t index;\n\tuint32_t loc;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct udf_part_map *map;\n\tstruct udf_virtual_data *vdata;\n\tstruct udf_inode_info *iinfo = UDF_I(sbi->s_vat_inode);\n\n\tmap = &sbi->s_partmaps[partition];\n\tvdata = &map->s_type_specific.s_virtual;\n\n\tif (block > vdata->s_num_entries) {\n\t\tudf_debug(\"Trying to access block beyond end of VAT (%d max %d)\\n\",\n\t\t\t  block, vdata->s_num_entries);\n\t\treturn 0xFFFFFFFF;\n\t}\n\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\tloc = le32_to_cpu(((__le32 *)(iinfo->i_ext.i_data +\n\t\t\tvdata->s_start_offset))[block]);\n\t\tgoto translate;\n\t}\n\tindex = (sb->s_blocksize - vdata->s_start_offset) / sizeof(uint32_t);\n\tif (block >= index) {\n\t\tblock -= index;\n\t\tnewblock = 1 + (block / (sb->s_blocksize / sizeof(uint32_t)));\n\t\tindex = block % (sb->s_blocksize / sizeof(uint32_t));\n\t} else {\n\t\tnewblock = 0;\n\t\tindex = vdata->s_start_offset / sizeof(uint32_t) + block;\n\t}\n\n\tloc = udf_block_map(sbi->s_vat_inode, newblock);\n\n\tbh = sb_bread(sb, loc);\n\tif (!bh) {\n\t\tudf_debug(\"get_pblock(UDF_VIRTUAL_MAP:%p,%d,%d) VAT: %d[%d]\\n\",\n\t\t\t  sb, block, partition, loc, index);\n\t\treturn 0xFFFFFFFF;\n\t}\n\n\tloc = le32_to_cpu(((__le32 *)bh->b_data)[index]);\n\n\tbrelse(bh);\n\ntranslate:\n\tif (iinfo->i_location.partitionReferenceNum == partition) {\n\t\tudf_debug(\"recursive call to udf_get_pblock!\\n\");\n\t\treturn 0xFFFFFFFF;\n\t}\n\n\treturn udf_get_pblock(sb, loc,\n\t\t\t      iinfo->i_location.partitionReferenceNum,\n\t\t\t      offset);\n}"
  },
  {
    "function_name": "udf_get_pblock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/partition.c",
    "lines": "30-45",
    "snippet": "uint32_t udf_get_pblock(struct super_block *sb, uint32_t block,\n\t\t\tuint16_t partition, uint32_t offset)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct udf_part_map *map;\n\tif (partition >= sbi->s_partitions) {\n\t\tudf_debug(\"block=%d, partition=%d, offset=%d: invalid partition\\n\",\n\t\t\t  block, partition, offset);\n\t\treturn 0xFFFFFFFF;\n\t}\n\tmap = &sbi->s_partmaps[partition];\n\tif (map->s_partition_func)\n\t\treturn map->s_partition_func(sb, block, partition, offset);\n\telse\n\t\treturn map->s_partition_root + block + offset;\n}",
    "includes": [
      "#include <linux/mutex.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include \"udf_i.h\"",
      "#include \"udf_sb.h\"",
      "#include \"udfdecl.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "map->s_partition_func",
          "args": [
            "sb",
            "block",
            "partition",
            "offset"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udf_debug",
          "args": [
            "\"block=%d, partition=%d, offset=%d: invalid partition\\n\"",
            "block",
            "partition",
            "offset"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UDF_SB",
          "args": [
            "sb"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "UDF_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/udf/udf_sb.h",
          "lines": "160-163",
          "snippet": "static inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/mutex.h>\n\nstatic inline struct udf_sb_info *UDF_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include \"udf_i.h\"\n#include \"udf_sb.h\"\n#include \"udfdecl.h\"\n\nuint32_t udf_get_pblock(struct super_block *sb, uint32_t block,\n\t\t\tuint16_t partition, uint32_t offset)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct udf_part_map *map;\n\tif (partition >= sbi->s_partitions) {\n\t\tudf_debug(\"block=%d, partition=%d, offset=%d: invalid partition\\n\",\n\t\t\t  block, partition, offset);\n\t\treturn 0xFFFFFFFF;\n\t}\n\tmap = &sbi->s_partmaps[partition];\n\tif (map->s_partition_func)\n\t\treturn map->s_partition_func(sb, block, partition, offset);\n\telse\n\t\treturn map->s_partition_root + block + offset;\n}"
  }
]