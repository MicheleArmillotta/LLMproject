[
  {
    "function_name": "__kernfs_create_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
    "lines": "909-954",
    "snippet": "struct kernfs_node *__kernfs_create_file(struct kernfs_node *parent,\n\t\t\t\t\t const char *name,\n\t\t\t\t\t umode_t mode, loff_t size,\n\t\t\t\t\t const struct kernfs_ops *ops,\n\t\t\t\t\t void *priv, const void *ns,\n\t\t\t\t\t struct lock_class_key *key)\n{\n\tstruct kernfs_node *kn;\n\tunsigned flags;\n\tint rc;\n\n\tflags = KERNFS_FILE;\n\n\tkn = kernfs_new_node(parent, name, (mode & S_IALLUGO) | S_IFREG, flags);\n\tif (!kn)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tkn->attr.ops = ops;\n\tkn->attr.size = size;\n\tkn->ns = ns;\n\tkn->priv = priv;\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (key) {\n\t\tlockdep_init_map(&kn->dep_map, \"s_active\", key, 0);\n\t\tkn->flags |= KERNFS_LOCKDEP;\n\t}\n#endif\n\n\t/*\n\t * kn->attr.ops is accesible only while holding active ref.  We\n\t * need to know whether some ops are implemented outside active\n\t * ref.  Cache their existence in flags.\n\t */\n\tif (ops->seq_show)\n\t\tkn->flags |= KERNFS_HAS_SEQ_SHOW;\n\tif (ops->mmap)\n\t\tkn->flags |= KERNFS_HAS_MMAP;\n\n\trc = kernfs_add_one(kn);\n\tif (rc) {\n\t\tkernfs_put(kn);\n\t\treturn ERR_PTR(rc);\n\t}\n\treturn kn;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/fsnotify.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "rc"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_put",
          "args": [
            "kn"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "393-436",
          "snippet": "void kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_add_one",
          "args": [
            "kn"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_add_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "569-620",
          "snippet": "int kernfs_add_one(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent = kn->parent;\n\tstruct kernfs_iattrs *ps_iattr;\n\tbool has_ns;\n\tint ret;\n\n\tmutex_lock(&kernfs_mutex);\n\n\tret = -EINVAL;\n\thas_ns = kernfs_ns_enabled(parent);\n\tif (WARN(has_ns != (bool)kn->ns, KERN_WARNING \"kernfs: ns %s in '%s' for '%s'\\n\",\n\t\t has_ns ? \"required\" : \"invalid\", parent->name, kn->name))\n\t\tgoto out_unlock;\n\n\tif (kernfs_type(parent) != KERNFS_DIR)\n\t\tgoto out_unlock;\n\n\tret = -ENOENT;\n\tif ((parent->flags & KERNFS_ACTIVATED) && !kernfs_active(parent))\n\t\tgoto out_unlock;\n\n\tkn->hash = kernfs_name_hash(kn->name, kn->ns);\n\n\tret = kernfs_link_sibling(kn);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t/* Update timestamps on the parent */\n\tps_iattr = parent->iattr;\n\tif (ps_iattr) {\n\t\tstruct iattr *ps_iattrs = &ps_iattr->ia_iattr;\n\t\tps_iattrs->ia_ctime = ps_iattrs->ia_mtime = CURRENT_TIME;\n\t}\n\n\tmutex_unlock(&kernfs_mutex);\n\n\t/*\n\t * Activate the new node unless CREATE_DEACTIVATED is requested.\n\t * If not activated here, the kernfs user is responsible for\n\t * activating the node with kernfs_activate().  A node which hasn't\n\t * been activated is not visible to userland and its removal won't\n\t * trigger deactivation.\n\t */\n\tif (!(kernfs_root(kn)->flags & KERNFS_ROOT_CREATE_DEACTIVATED))\n\t\tkernfs_activate(kn);\n\treturn 0;\n\nout_unlock:\n\tmutex_unlock(&kernfs_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nint kernfs_add_one(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent = kn->parent;\n\tstruct kernfs_iattrs *ps_iattr;\n\tbool has_ns;\n\tint ret;\n\n\tmutex_lock(&kernfs_mutex);\n\n\tret = -EINVAL;\n\thas_ns = kernfs_ns_enabled(parent);\n\tif (WARN(has_ns != (bool)kn->ns, KERN_WARNING \"kernfs: ns %s in '%s' for '%s'\\n\",\n\t\t has_ns ? \"required\" : \"invalid\", parent->name, kn->name))\n\t\tgoto out_unlock;\n\n\tif (kernfs_type(parent) != KERNFS_DIR)\n\t\tgoto out_unlock;\n\n\tret = -ENOENT;\n\tif ((parent->flags & KERNFS_ACTIVATED) && !kernfs_active(parent))\n\t\tgoto out_unlock;\n\n\tkn->hash = kernfs_name_hash(kn->name, kn->ns);\n\n\tret = kernfs_link_sibling(kn);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t/* Update timestamps on the parent */\n\tps_iattr = parent->iattr;\n\tif (ps_iattr) {\n\t\tstruct iattr *ps_iattrs = &ps_iattr->ia_iattr;\n\t\tps_iattrs->ia_ctime = ps_iattrs->ia_mtime = CURRENT_TIME;\n\t}\n\n\tmutex_unlock(&kernfs_mutex);\n\n\t/*\n\t * Activate the new node unless CREATE_DEACTIVATED is requested.\n\t * If not activated here, the kernfs user is responsible for\n\t * activating the node with kernfs_activate().  A node which hasn't\n\t * been activated is not visible to userland and its removal won't\n\t * trigger deactivation.\n\t */\n\tif (!(kernfs_root(kn)->flags & KERNFS_ROOT_CREATE_DEACTIVATED))\n\t\tkernfs_activate(kn);\n\treturn 0;\n\nout_unlock:\n\tmutex_unlock(&kernfs_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_init_map",
          "args": [
            "&kn->dep_map",
            "\"s_active\"",
            "key",
            "0"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_new_node",
          "args": [
            "parent",
            "name",
            "(mode & S_IALLUGO) | S_IFREG",
            "flags"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_new_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "543-555",
          "snippet": "struct kernfs_node *kernfs_new_node(struct kernfs_node *parent,\n\t\t\t\t    const char *name, umode_t mode,\n\t\t\t\t    unsigned flags)\n{\n\tstruct kernfs_node *kn;\n\n\tkn = __kernfs_new_node(kernfs_root(parent), name, mode, flags);\n\tif (kn) {\n\t\tkernfs_get(parent);\n\t\tkn->parent = parent;\n\t}\n\treturn kn;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstruct kernfs_node *kernfs_new_node(struct kernfs_node *parent,\n\t\t\t\t    const char *name, umode_t mode,\n\t\t\t\t    unsigned flags)\n{\n\tstruct kernfs_node *kn;\n\n\tkn = __kernfs_new_node(kernfs_root(parent), name, mode, flags);\n\tif (kn) {\n\t\tkernfs_get(parent);\n\t\tkn->parent = parent;\n\t}\n\treturn kn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstruct kernfs_node *__kernfs_create_file(struct kernfs_node *parent,\n\t\t\t\t\t const char *name,\n\t\t\t\t\t umode_t mode, loff_t size,\n\t\t\t\t\t const struct kernfs_ops *ops,\n\t\t\t\t\t void *priv, const void *ns,\n\t\t\t\t\t struct lock_class_key *key)\n{\n\tstruct kernfs_node *kn;\n\tunsigned flags;\n\tint rc;\n\n\tflags = KERNFS_FILE;\n\n\tkn = kernfs_new_node(parent, name, (mode & S_IALLUGO) | S_IFREG, flags);\n\tif (!kn)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tkn->attr.ops = ops;\n\tkn->attr.size = size;\n\tkn->ns = ns;\n\tkn->priv = priv;\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (key) {\n\t\tlockdep_init_map(&kn->dep_map, \"s_active\", key, 0);\n\t\tkn->flags |= KERNFS_LOCKDEP;\n\t}\n#endif\n\n\t/*\n\t * kn->attr.ops is accesible only while holding active ref.  We\n\t * need to know whether some ops are implemented outside active\n\t * ref.  Cache their existence in flags.\n\t */\n\tif (ops->seq_show)\n\t\tkn->flags |= KERNFS_HAS_SEQ_SHOW;\n\tif (ops->mmap)\n\t\tkn->flags |= KERNFS_HAS_MMAP;\n\n\trc = kernfs_add_one(kn);\n\tif (rc) {\n\t\tkernfs_put(kn);\n\t\treturn ERR_PTR(rc);\n\t}\n\treturn kn;\n}"
  },
  {
    "function_name": "kernfs_notify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
    "lines": "867-883",
    "snippet": "void kernfs_notify(struct kernfs_node *kn)\n{\n\tstatic DECLARE_WORK(kernfs_notify_work, kernfs_notify_workfn);\n\tunsigned long flags;\n\n\tif (WARN_ON(kernfs_type(kn) != KERNFS_FILE))\n\t\treturn;\n\n\tspin_lock_irqsave(&kernfs_notify_lock, flags);\n\tif (!kn->attr.notify_next) {\n\t\tkernfs_get(kn);\n\t\tkn->attr.notify_next = kernfs_notify_list;\n\t\tkernfs_notify_list = kn;\n\t\tschedule_work(&kernfs_notify_work);\n\t}\n\tspin_unlock_irqrestore(&kernfs_notify_lock, flags);\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/fsnotify.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(kernfs_notify_lock);",
      "static struct kernfs_node *kernfs_notify_list = KERNFS_NOTIFY_EOL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&kernfs_notify_lock",
            "flags"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&kernfs_notify_work"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_direct_write_schedule_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/direct.c",
          "lines": "755-771",
          "snippet": "static void nfs_direct_write_schedule_work(struct work_struct *work)\n{\n\tstruct nfs_direct_req *dreq = container_of(work, struct nfs_direct_req, work);\n\tint flags = dreq->flags;\n\n\tdreq->flags = 0;\n\tswitch (flags) {\n\t\tcase NFS_ODIRECT_DO_COMMIT:\n\t\t\tnfs_direct_commit_schedule(dreq);\n\t\t\tbreak;\n\t\tcase NFS_ODIRECT_RESCHED_WRITES:\n\t\t\tnfs_direct_write_reschedule(dreq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfs_direct_complete(dreq, true);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/slab.h>",
            "#include <linux/kref.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */",
            "#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t/* an unstable reply was received */"
          ],
          "globals_used": [
            "static void nfs_direct_write_schedule_work(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/atomic.h>\n#include <asm/uaccess.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/slab.h>\n#include <linux/kref.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */\n#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t/* an unstable reply was received */\n\nstatic void nfs_direct_write_schedule_work(struct work_struct *work);\n\nstatic void nfs_direct_write_schedule_work(struct work_struct *work)\n{\n\tstruct nfs_direct_req *dreq = container_of(work, struct nfs_direct_req, work);\n\tint flags = dreq->flags;\n\n\tdreq->flags = 0;\n\tswitch (flags) {\n\t\tcase NFS_ODIRECT_DO_COMMIT:\n\t\t\tnfs_direct_commit_schedule(dreq);\n\t\t\tbreak;\n\t\tcase NFS_ODIRECT_RESCHED_WRITES:\n\t\t\tnfs_direct_write_reschedule(dreq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfs_direct_complete(dreq, true);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_get",
          "args": [
            "kn"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "378-384",
          "snippet": "void kernfs_get(struct kernfs_node *kn)\n{\n\tif (kn) {\n\t\tWARN_ON(!atomic_read(&kn->count));\n\t\tatomic_inc(&kn->count);\n\t}\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_get(struct kernfs_node *kn)\n{\n\tif (kn) {\n\t\tWARN_ON(!atomic_read(&kn->count));\n\t\tatomic_inc(&kn->count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&kernfs_notify_lock",
            "flags"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "kernfs_type(kn) != KERNFS_FILE"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_type",
          "args": [
            "kn"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic DEFINE_SPINLOCK(kernfs_notify_lock);\nstatic struct kernfs_node *kernfs_notify_list = KERNFS_NOTIFY_EOL;\n\nvoid kernfs_notify(struct kernfs_node *kn)\n{\n\tstatic DECLARE_WORK(kernfs_notify_work, kernfs_notify_workfn);\n\tunsigned long flags;\n\n\tif (WARN_ON(kernfs_type(kn) != KERNFS_FILE))\n\t\treturn;\n\n\tspin_lock_irqsave(&kernfs_notify_lock, flags);\n\tif (!kn->attr.notify_next) {\n\t\tkernfs_get(kn);\n\t\tkn->attr.notify_next = kernfs_notify_list;\n\t\tkernfs_notify_list = kn;\n\t\tschedule_work(&kernfs_notify_work);\n\t}\n\tspin_unlock_irqrestore(&kernfs_notify_lock, flags);\n}"
  },
  {
    "function_name": "kernfs_notify_workfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
    "lines": "805-858",
    "snippet": "static void kernfs_notify_workfn(struct work_struct *work)\n{\n\tstruct kernfs_node *kn;\n\tstruct kernfs_open_node *on;\n\tstruct kernfs_super_info *info;\nrepeat:\n\t/* pop one off the notify_list */\n\tspin_lock_irq(&kernfs_notify_lock);\n\tkn = kernfs_notify_list;\n\tif (kn == KERNFS_NOTIFY_EOL) {\n\t\tspin_unlock_irq(&kernfs_notify_lock);\n\t\treturn;\n\t}\n\tkernfs_notify_list = kn->attr.notify_next;\n\tkn->attr.notify_next = NULL;\n\tspin_unlock_irq(&kernfs_notify_lock);\n\n\t/* kick poll */\n\tspin_lock_irq(&kernfs_open_node_lock);\n\n\ton = kn->attr.open;\n\tif (on) {\n\t\tatomic_inc(&on->event);\n\t\twake_up_interruptible(&on->poll);\n\t}\n\n\tspin_unlock_irq(&kernfs_open_node_lock);\n\n\t/* kick fsnotify */\n\tmutex_lock(&kernfs_mutex);\n\n\tlist_for_each_entry(info, &kernfs_root(kn)->supers, node) {\n\t\tstruct inode *inode;\n\t\tstruct dentry *dentry;\n\n\t\tinode = ilookup(info->sb, kn->ino);\n\t\tif (!inode)\n\t\t\tcontinue;\n\n\t\tdentry = d_find_any_alias(inode);\n\t\tif (dentry) {\n\t\t\tfsnotify_parent(NULL, dentry, FS_MODIFY);\n\t\t\tfsnotify(inode, FS_MODIFY, inode, FSNOTIFY_EVENT_INODE,\n\t\t\t\t NULL, 0);\n\t\t\tdput(dentry);\n\t\t}\n\n\t\tiput(inode);\n\t}\n\n\tmutex_unlock(&kernfs_mutex);\n\tkernfs_put(kn);\n\tgoto repeat;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/fsnotify.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define KERNFS_NOTIFY_EOL\t\t\t((void *)&kernfs_notify_list)"
    ],
    "globals_used": [
      "static DEFINE_SPINLOCK(kernfs_open_node_lock);",
      "static DEFINE_SPINLOCK(kernfs_notify_lock);",
      "static struct kernfs_node *kernfs_notify_list = KERNFS_NOTIFY_EOL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_put",
          "args": [
            "kn"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "393-436",
          "snippet": "void kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_put(struct kernfs_node *kn)\n{\n\tstruct kernfs_node *parent;\n\tstruct kernfs_root *root;\n\n\tif (!kn || !atomic_dec_and_test(&kn->count))\n\t\treturn;\n\troot = kernfs_root(kn);\n repeat:\n\t/*\n\t * Moving/renaming is always done while holding reference.\n\t * kn->parent won't change beneath us.\n\t */\n\tparent = kn->parent;\n\n\tWARN_ONCE(atomic_read(&kn->active) != KN_DEACTIVATED_BIAS,\n\t\t  \"kernfs_put: %s/%s: released with incorrect active_ref %d\\n\",\n\t\t  parent ? parent->name : \"\", kn->name, atomic_read(&kn->active));\n\n\tif (kernfs_type(kn) == KERNFS_LINK)\n\t\tkernfs_put(kn->symlink.target_kn);\n\n\tkfree_const(kn->name);\n\n\tif (kn->iattr) {\n\t\tif (kn->iattr->ia_secdata)\n\t\t\tsecurity_release_secctx(kn->iattr->ia_secdata,\n\t\t\t\t\t\tkn->iattr->ia_secdata_len);\n\t\tsimple_xattrs_free(&kn->iattr->xattrs);\n\t}\n\tkfree(kn->iattr);\n\tida_simple_remove(&root->ino_ida, kn->ino);\n\tkmem_cache_free(kernfs_node_cache, kn);\n\n\tkn = parent;\n\tif (kn) {\n\t\tif (atomic_dec_and_test(&kn->count))\n\t\t\tgoto repeat;\n\t} else {\n\t\t/* just released the root kn, free @root too */\n\t\tida_destroy(&root->ino_ida);\n\t\tkfree(root);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify",
          "args": [
            "inode",
            "FS_MODIFY",
            "inode",
            "FSNOTIFY_EVENT_INODE",
            "NULL",
            "0"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fsnotify.c",
          "lines": "191-284",
          "snippet": "int fsnotify(struct inode *to_tell, __u32 mask, void *data, int data_is,\n\t     const unsigned char *file_name, u32 cookie)\n{\n\tstruct hlist_node *inode_node = NULL, *vfsmount_node = NULL;\n\tstruct fsnotify_mark *inode_mark = NULL, *vfsmount_mark = NULL;\n\tstruct fsnotify_group *inode_group, *vfsmount_group;\n\tstruct mount *mnt;\n\tint idx, ret = 0;\n\t/* global tests shouldn't care about events on child only the specific event */\n\t__u32 test_mask = (mask & ~FS_EVENT_ON_CHILD);\n\n\tif (data_is == FSNOTIFY_EVENT_PATH)\n\t\tmnt = real_mount(((struct path *)data)->mnt);\n\telse\n\t\tmnt = NULL;\n\n\t/*\n\t * if this is a modify event we may need to clear the ignored masks\n\t * otherwise return if neither the inode nor the vfsmount care about\n\t * this type of event.\n\t */\n\tif (!(mask & FS_MODIFY) &&\n\t    !(test_mask & to_tell->i_fsnotify_mask) &&\n\t    !(mnt && test_mask & mnt->mnt_fsnotify_mask))\n\t\treturn 0;\n\n\tidx = srcu_read_lock(&fsnotify_mark_srcu);\n\n\tif ((mask & FS_MODIFY) ||\n\t    (test_mask & to_tell->i_fsnotify_mask))\n\t\tinode_node = srcu_dereference(to_tell->i_fsnotify_marks.first,\n\t\t\t\t\t      &fsnotify_mark_srcu);\n\n\tif (mnt && ((mask & FS_MODIFY) ||\n\t\t    (test_mask & mnt->mnt_fsnotify_mask))) {\n\t\tvfsmount_node = srcu_dereference(mnt->mnt_fsnotify_marks.first,\n\t\t\t\t\t\t &fsnotify_mark_srcu);\n\t\tinode_node = srcu_dereference(to_tell->i_fsnotify_marks.first,\n\t\t\t\t\t      &fsnotify_mark_srcu);\n\t}\n\n\t/*\n\t * We need to merge inode & vfsmount mark lists so that inode mark\n\t * ignore masks are properly reflected for mount mark notifications.\n\t * That's why this traversal is so complicated...\n\t */\n\twhile (inode_node || vfsmount_node) {\n\t\tinode_group = NULL;\n\t\tinode_mark = NULL;\n\t\tvfsmount_group = NULL;\n\t\tvfsmount_mark = NULL;\n\n\t\tif (inode_node) {\n\t\t\tinode_mark = hlist_entry(srcu_dereference(inode_node, &fsnotify_mark_srcu),\n\t\t\t\t\t\t struct fsnotify_mark, obj_list);\n\t\t\tinode_group = inode_mark->group;\n\t\t}\n\n\t\tif (vfsmount_node) {\n\t\t\tvfsmount_mark = hlist_entry(srcu_dereference(vfsmount_node, &fsnotify_mark_srcu),\n\t\t\t\t\t\t    struct fsnotify_mark, obj_list);\n\t\t\tvfsmount_group = vfsmount_mark->group;\n\t\t}\n\n\t\tif (inode_group && vfsmount_group) {\n\t\t\tint cmp = fsnotify_compare_groups(inode_group,\n\t\t\t\t\t\t\t  vfsmount_group);\n\t\t\tif (cmp > 0) {\n\t\t\t\tinode_group = NULL;\n\t\t\t\tinode_mark = NULL;\n\t\t\t} else if (cmp < 0) {\n\t\t\t\tvfsmount_group = NULL;\n\t\t\t\tvfsmount_mark = NULL;\n\t\t\t}\n\t\t}\n\t\tret = send_to_group(to_tell, inode_mark, vfsmount_mark, mask,\n\t\t\t\t    data, data_is, cookie, file_name);\n\n\t\tif (ret && (mask & ALL_FSNOTIFY_PERM_EVENTS))\n\t\t\tgoto out;\n\n\t\tif (inode_group)\n\t\t\tinode_node = srcu_dereference(inode_node->next,\n\t\t\t\t\t\t      &fsnotify_mark_srcu);\n\t\tif (vfsmount_group)\n\t\t\tvfsmount_node = srcu_dereference(vfsmount_node->next,\n\t\t\t\t\t\t\t &fsnotify_mark_srcu);\n\t}\n\tret = 0;\nout:\n\tsrcu_read_unlock(&fsnotify_mark_srcu, idx);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"../mount.h\"",
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/srcu.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/gfp.h>",
            "#include <linux/fs.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../mount.h\"\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/srcu.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n#include <linux/dcache.h>\n\nint fsnotify(struct inode *to_tell, __u32 mask, void *data, int data_is,\n\t     const unsigned char *file_name, u32 cookie)\n{\n\tstruct hlist_node *inode_node = NULL, *vfsmount_node = NULL;\n\tstruct fsnotify_mark *inode_mark = NULL, *vfsmount_mark = NULL;\n\tstruct fsnotify_group *inode_group, *vfsmount_group;\n\tstruct mount *mnt;\n\tint idx, ret = 0;\n\t/* global tests shouldn't care about events on child only the specific event */\n\t__u32 test_mask = (mask & ~FS_EVENT_ON_CHILD);\n\n\tif (data_is == FSNOTIFY_EVENT_PATH)\n\t\tmnt = real_mount(((struct path *)data)->mnt);\n\telse\n\t\tmnt = NULL;\n\n\t/*\n\t * if this is a modify event we may need to clear the ignored masks\n\t * otherwise return if neither the inode nor the vfsmount care about\n\t * this type of event.\n\t */\n\tif (!(mask & FS_MODIFY) &&\n\t    !(test_mask & to_tell->i_fsnotify_mask) &&\n\t    !(mnt && test_mask & mnt->mnt_fsnotify_mask))\n\t\treturn 0;\n\n\tidx = srcu_read_lock(&fsnotify_mark_srcu);\n\n\tif ((mask & FS_MODIFY) ||\n\t    (test_mask & to_tell->i_fsnotify_mask))\n\t\tinode_node = srcu_dereference(to_tell->i_fsnotify_marks.first,\n\t\t\t\t\t      &fsnotify_mark_srcu);\n\n\tif (mnt && ((mask & FS_MODIFY) ||\n\t\t    (test_mask & mnt->mnt_fsnotify_mask))) {\n\t\tvfsmount_node = srcu_dereference(mnt->mnt_fsnotify_marks.first,\n\t\t\t\t\t\t &fsnotify_mark_srcu);\n\t\tinode_node = srcu_dereference(to_tell->i_fsnotify_marks.first,\n\t\t\t\t\t      &fsnotify_mark_srcu);\n\t}\n\n\t/*\n\t * We need to merge inode & vfsmount mark lists so that inode mark\n\t * ignore masks are properly reflected for mount mark notifications.\n\t * That's why this traversal is so complicated...\n\t */\n\twhile (inode_node || vfsmount_node) {\n\t\tinode_group = NULL;\n\t\tinode_mark = NULL;\n\t\tvfsmount_group = NULL;\n\t\tvfsmount_mark = NULL;\n\n\t\tif (inode_node) {\n\t\t\tinode_mark = hlist_entry(srcu_dereference(inode_node, &fsnotify_mark_srcu),\n\t\t\t\t\t\t struct fsnotify_mark, obj_list);\n\t\t\tinode_group = inode_mark->group;\n\t\t}\n\n\t\tif (vfsmount_node) {\n\t\t\tvfsmount_mark = hlist_entry(srcu_dereference(vfsmount_node, &fsnotify_mark_srcu),\n\t\t\t\t\t\t    struct fsnotify_mark, obj_list);\n\t\t\tvfsmount_group = vfsmount_mark->group;\n\t\t}\n\n\t\tif (inode_group && vfsmount_group) {\n\t\t\tint cmp = fsnotify_compare_groups(inode_group,\n\t\t\t\t\t\t\t  vfsmount_group);\n\t\t\tif (cmp > 0) {\n\t\t\t\tinode_group = NULL;\n\t\t\t\tinode_mark = NULL;\n\t\t\t} else if (cmp < 0) {\n\t\t\t\tvfsmount_group = NULL;\n\t\t\t\tvfsmount_mark = NULL;\n\t\t\t}\n\t\t}\n\t\tret = send_to_group(to_tell, inode_mark, vfsmount_mark, mask,\n\t\t\t\t    data, data_is, cookie, file_name);\n\n\t\tif (ret && (mask & ALL_FSNOTIFY_PERM_EVENTS))\n\t\t\tgoto out;\n\n\t\tif (inode_group)\n\t\t\tinode_node = srcu_dereference(inode_node->next,\n\t\t\t\t\t\t      &fsnotify_mark_srcu);\n\t\tif (vfsmount_group)\n\t\t\tvfsmount_node = srcu_dereference(vfsmount_node->next,\n\t\t\t\t\t\t\t &fsnotify_mark_srcu);\n\t}\n\tret = 0;\nout:\n\tsrcu_read_unlock(&fsnotify_mark_srcu, idx);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_parent",
          "args": [
            "NULL",
            "dentry",
            "FS_MODIFY"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "__fsnotify_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fsnotify.c",
          "lines": "90-123",
          "snippet": "int __fsnotify_parent(struct path *path, struct dentry *dentry, __u32 mask)\n{\n\tstruct dentry *parent;\n\tstruct inode *p_inode;\n\tint ret = 0;\n\n\tif (!dentry)\n\t\tdentry = path->dentry;\n\n\tif (!(dentry->d_flags & DCACHE_FSNOTIFY_PARENT_WATCHED))\n\t\treturn 0;\n\n\tparent = dget_parent(dentry);\n\tp_inode = parent->d_inode;\n\n\tif (unlikely(!fsnotify_inode_watches_children(p_inode)))\n\t\t__fsnotify_update_child_dentry_flags(p_inode);\n\telse if (p_inode->i_fsnotify_mask & mask) {\n\t\t/* we are notifying a parent so come up with the new mask which\n\t\t * specifies these are events which came from a child. */\n\t\tmask |= FS_EVENT_ON_CHILD;\n\n\t\tif (path)\n\t\t\tret = fsnotify(p_inode, mask, path, FSNOTIFY_EVENT_PATH,\n\t\t\t\t       dentry->d_name.name, 0);\n\t\telse\n\t\t\tret = fsnotify(p_inode, mask, dentry->d_inode, FSNOTIFY_EVENT_INODE,\n\t\t\t\t       dentry->d_name.name, 0);\n\t}\n\n\tdput(parent);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"../mount.h\"",
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/srcu.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/gfp.h>",
            "#include <linux/fs.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../mount.h\"\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/srcu.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n#include <linux/dcache.h>\n\nint __fsnotify_parent(struct path *path, struct dentry *dentry, __u32 mask)\n{\n\tstruct dentry *parent;\n\tstruct inode *p_inode;\n\tint ret = 0;\n\n\tif (!dentry)\n\t\tdentry = path->dentry;\n\n\tif (!(dentry->d_flags & DCACHE_FSNOTIFY_PARENT_WATCHED))\n\t\treturn 0;\n\n\tparent = dget_parent(dentry);\n\tp_inode = parent->d_inode;\n\n\tif (unlikely(!fsnotify_inode_watches_children(p_inode)))\n\t\t__fsnotify_update_child_dentry_flags(p_inode);\n\telse if (p_inode->i_fsnotify_mask & mask) {\n\t\t/* we are notifying a parent so come up with the new mask which\n\t\t * specifies these are events which came from a child. */\n\t\tmask |= FS_EVENT_ON_CHILD;\n\n\t\tif (path)\n\t\t\tret = fsnotify(p_inode, mask, path, FSNOTIFY_EVENT_PATH,\n\t\t\t\t       dentry->d_name.name, 0);\n\t\telse\n\t\t\tret = fsnotify(p_inode, mask, dentry->d_inode, FSNOTIFY_EVENT_INODE,\n\t\t\t\t       dentry->d_name.name, 0);\n\t}\n\n\tdput(parent);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_find_any_alias",
          "args": [
            "inode"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "d_find_any_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1892-1900",
          "snippet": "struct dentry *d_find_any_alias(struct inode *inode)\n{\n\tstruct dentry *de;\n\n\tspin_lock(&inode->i_lock);\n\tde = __d_find_any_alias(inode);\n\tspin_unlock(&inode->i_lock);\n\treturn de;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_find_any_alias(struct inode *inode)\n{\n\tstruct dentry *de;\n\n\tspin_lock(&inode->i_lock);\n\tde = __d_find_any_alias(inode);\n\tspin_unlock(&inode->i_lock);\n\treturn de;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ilookup",
          "args": [
            "info->sb",
            "kn->ino"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "ilookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1258-1270",
          "snippet": "struct inode *ilookup(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode)\n\t\twait_on_inode(inode);\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *ilookup(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode)\n\t\twait_on_inode(inode);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "info",
            "&kernfs_root(kn)->supers",
            "node"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_root",
          "args": [
            "kn"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/kernfs-internal.h",
          "lines": "40-46",
          "snippet": "static inline struct kernfs_root *kernfs_root(struct kernfs_node *kn)\n{\n\t/* if parent exists, it's always a dir; otherwise, @sd is a dir */\n\tif (kn->parent)\n\t\tkn = kn->parent;\n\treturn kn->dir.root;\n}",
          "includes": [
            "#include <linux/kernfs.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>",
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernfs.h>\n#include <linux/xattr.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/lockdep.h>\n\nstatic inline struct kernfs_root *kernfs_root(struct kernfs_node *kn)\n{\n\t/* if parent exists, it's always a dir; otherwise, @sd is a dir */\n\tif (kn->parent)\n\t\tkn = kn->parent;\n\treturn kn->dir.root;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kernfs_mutex"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&kernfs_open_node_lock"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_interruptible",
          "args": [
            "&on->poll"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&on->event"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&kernfs_open_node_lock"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&kernfs_notify_lock"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&kernfs_notify_lock"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&kernfs_notify_lock"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\n#define KERNFS_NOTIFY_EOL\t\t\t((void *)&kernfs_notify_list)\n\nstatic DEFINE_SPINLOCK(kernfs_open_node_lock);\nstatic DEFINE_SPINLOCK(kernfs_notify_lock);\nstatic struct kernfs_node *kernfs_notify_list = KERNFS_NOTIFY_EOL;\n\nstatic void kernfs_notify_workfn(struct work_struct *work)\n{\n\tstruct kernfs_node *kn;\n\tstruct kernfs_open_node *on;\n\tstruct kernfs_super_info *info;\nrepeat:\n\t/* pop one off the notify_list */\n\tspin_lock_irq(&kernfs_notify_lock);\n\tkn = kernfs_notify_list;\n\tif (kn == KERNFS_NOTIFY_EOL) {\n\t\tspin_unlock_irq(&kernfs_notify_lock);\n\t\treturn;\n\t}\n\tkernfs_notify_list = kn->attr.notify_next;\n\tkn->attr.notify_next = NULL;\n\tspin_unlock_irq(&kernfs_notify_lock);\n\n\t/* kick poll */\n\tspin_lock_irq(&kernfs_open_node_lock);\n\n\ton = kn->attr.open;\n\tif (on) {\n\t\tatomic_inc(&on->event);\n\t\twake_up_interruptible(&on->poll);\n\t}\n\n\tspin_unlock_irq(&kernfs_open_node_lock);\n\n\t/* kick fsnotify */\n\tmutex_lock(&kernfs_mutex);\n\n\tlist_for_each_entry(info, &kernfs_root(kn)->supers, node) {\n\t\tstruct inode *inode;\n\t\tstruct dentry *dentry;\n\n\t\tinode = ilookup(info->sb, kn->ino);\n\t\tif (!inode)\n\t\t\tcontinue;\n\n\t\tdentry = d_find_any_alias(inode);\n\t\tif (dentry) {\n\t\t\tfsnotify_parent(NULL, dentry, FS_MODIFY);\n\t\t\tfsnotify(inode, FS_MODIFY, inode, FSNOTIFY_EVENT_INODE,\n\t\t\t\t NULL, 0);\n\t\t\tdput(dentry);\n\t\t}\n\n\t\tiput(inode);\n\t}\n\n\tmutex_unlock(&kernfs_mutex);\n\tkernfs_put(kn);\n\tgoto repeat;\n}"
  },
  {
    "function_name": "kernfs_fop_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
    "lines": "782-803",
    "snippet": "static unsigned int kernfs_fop_poll(struct file *filp, poll_table *wait)\n{\n\tstruct kernfs_open_file *of = kernfs_of(filp);\n\tstruct kernfs_node *kn = filp->f_path.dentry->d_fsdata;\n\tstruct kernfs_open_node *on = kn->attr.open;\n\n\t/* need parent for the kobj, grab both */\n\tif (!kernfs_get_active(kn))\n\t\tgoto trigger;\n\n\tpoll_wait(filp, &on->poll, wait);\n\n\tkernfs_put_active(kn);\n\n\tif (of->event != atomic_read(&on->event))\n\t\tgoto trigger;\n\n\treturn DEFAULT_POLLMASK;\n\n trigger:\n\treturn DEFAULT_POLLMASK|POLLERR|POLLPRI;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/fsnotify.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&on->event"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_put_active",
          "args": [
            "kn"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_put_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "319-334",
          "snippet": "void kernfs_put_active(struct kernfs_node *kn)\n{\n\tstruct kernfs_root *root = kernfs_root(kn);\n\tint v;\n\n\tif (unlikely(!kn))\n\t\treturn;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_release(&kn->dep_map, 1, _RET_IP_);\n\tv = atomic_dec_return(&kn->active);\n\tif (likely(v != KN_DEACTIVATED_BIAS))\n\t\treturn;\n\n\twake_up_all(&root->deactivate_waitq);\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_put_active(struct kernfs_node *kn)\n{\n\tstruct kernfs_root *root = kernfs_root(kn);\n\tint v;\n\n\tif (unlikely(!kn))\n\t\treturn;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_release(&kn->dep_map, 1, _RET_IP_);\n\tv = atomic_dec_return(&kn->active);\n\tif (likely(v != KN_DEACTIVATED_BIAS))\n\t\treturn;\n\n\twake_up_all(&root->deactivate_waitq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "poll_wait",
          "args": [
            "filp",
            "&on->poll",
            "wait"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_get_active",
          "args": [
            "kn"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_get_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "299-310",
          "snippet": "struct kernfs_node *kernfs_get_active(struct kernfs_node *kn)\n{\n\tif (unlikely(!kn))\n\t\treturn NULL;\n\n\tif (!atomic_inc_unless_negative(&kn->active))\n\t\treturn NULL;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_acquire_read(&kn->dep_map, 0, 1, _RET_IP_);\n\treturn kn;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstruct kernfs_node *kernfs_get_active(struct kernfs_node *kn)\n{\n\tif (unlikely(!kn))\n\t\treturn NULL;\n\n\tif (!atomic_inc_unless_negative(&kn->active))\n\t\treturn NULL;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_acquire_read(&kn->dep_map, 0, 1, _RET_IP_);\n\treturn kn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_of",
          "args": [
            "filp"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_of",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
          "lines": "55-58",
          "snippet": "static struct kernfs_open_file *kernfs_of(struct file *file)\n{\n\treturn ((struct seq_file *)file->private_data)->private;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic struct kernfs_open_file *kernfs_of(struct file *file)\n{\n\treturn ((struct seq_file *)file->private_data)->private;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic unsigned int kernfs_fop_poll(struct file *filp, poll_table *wait)\n{\n\tstruct kernfs_open_file *of = kernfs_of(filp);\n\tstruct kernfs_node *kn = filp->f_path.dentry->d_fsdata;\n\tstruct kernfs_open_node *on = kn->attr.open;\n\n\t/* need parent for the kobj, grab both */\n\tif (!kernfs_get_active(kn))\n\t\tgoto trigger;\n\n\tpoll_wait(filp, &on->poll, wait);\n\n\tkernfs_put_active(kn);\n\n\tif (of->event != atomic_read(&on->event))\n\t\tgoto trigger;\n\n\treturn DEFAULT_POLLMASK;\n\n trigger:\n\treturn DEFAULT_POLLMASK|POLLERR|POLLPRI;\n}"
  },
  {
    "function_name": "kernfs_unmap_bin_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
    "lines": "742-766",
    "snippet": "void kernfs_unmap_bin_file(struct kernfs_node *kn)\n{\n\tstruct kernfs_open_node *on;\n\tstruct kernfs_open_file *of;\n\n\tif (!(kn->flags & KERNFS_HAS_MMAP))\n\t\treturn;\n\n\tspin_lock_irq(&kernfs_open_node_lock);\n\ton = kn->attr.open;\n\tif (on)\n\t\tatomic_inc(&on->refcnt);\n\tspin_unlock_irq(&kernfs_open_node_lock);\n\tif (!on)\n\t\treturn;\n\n\tmutex_lock(&kernfs_open_file_mutex);\n\tlist_for_each_entry(of, &on->files, list) {\n\t\tstruct inode *inode = file_inode(of->file);\n\t\tunmap_mapping_range(inode->i_mapping, 0, 0, 1);\n\t}\n\tmutex_unlock(&kernfs_open_file_mutex);\n\n\tkernfs_put_open_node(kn, NULL);\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/fsnotify.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(kernfs_open_node_lock);",
      "static DEFINE_MUTEX(kernfs_open_file_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_put_open_node",
          "args": [
            "kn",
            "NULL"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_put_open_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
          "lines": "589-610",
          "snippet": "static void kernfs_put_open_node(struct kernfs_node *kn,\n\t\t\t\t struct kernfs_open_file *of)\n{\n\tstruct kernfs_open_node *on = kn->attr.open;\n\tunsigned long flags;\n\n\tmutex_lock(&kernfs_open_file_mutex);\n\tspin_lock_irqsave(&kernfs_open_node_lock, flags);\n\n\tif (of)\n\t\tlist_del(&of->list);\n\n\tif (atomic_dec_and_test(&on->refcnt))\n\t\tkn->attr.open = NULL;\n\telse\n\t\ton = NULL;\n\n\tspin_unlock_irqrestore(&kernfs_open_node_lock, flags);\n\tmutex_unlock(&kernfs_open_file_mutex);\n\n\tkfree(on);\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(kernfs_open_node_lock);",
            "static DEFINE_MUTEX(kernfs_open_file_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic DEFINE_SPINLOCK(kernfs_open_node_lock);\nstatic DEFINE_MUTEX(kernfs_open_file_mutex);\n\nstatic void kernfs_put_open_node(struct kernfs_node *kn,\n\t\t\t\t struct kernfs_open_file *of)\n{\n\tstruct kernfs_open_node *on = kn->attr.open;\n\tunsigned long flags;\n\n\tmutex_lock(&kernfs_open_file_mutex);\n\tspin_lock_irqsave(&kernfs_open_node_lock, flags);\n\n\tif (of)\n\t\tlist_del(&of->list);\n\n\tif (atomic_dec_and_test(&on->refcnt))\n\t\tkn->attr.open = NULL;\n\telse\n\t\ton = NULL;\n\n\tspin_unlock_irqrestore(&kernfs_open_node_lock, flags);\n\tmutex_unlock(&kernfs_open_file_mutex);\n\n\tkfree(on);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kernfs_open_file_mutex"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_mapping_range",
          "args": [
            "inode->i_mapping",
            "0",
            "0",
            "1"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "of->file"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "of",
            "&on->files",
            "list"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kernfs_open_file_mutex"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&kernfs_open_node_lock"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&on->refcnt"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&kernfs_open_node_lock"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic DEFINE_SPINLOCK(kernfs_open_node_lock);\nstatic DEFINE_MUTEX(kernfs_open_file_mutex);\n\nvoid kernfs_unmap_bin_file(struct kernfs_node *kn)\n{\n\tstruct kernfs_open_node *on;\n\tstruct kernfs_open_file *of;\n\n\tif (!(kn->flags & KERNFS_HAS_MMAP))\n\t\treturn;\n\n\tspin_lock_irq(&kernfs_open_node_lock);\n\ton = kn->attr.open;\n\tif (on)\n\t\tatomic_inc(&on->refcnt);\n\tspin_unlock_irq(&kernfs_open_node_lock);\n\tif (!on)\n\t\treturn;\n\n\tmutex_lock(&kernfs_open_file_mutex);\n\tlist_for_each_entry(of, &on->files, list) {\n\t\tstruct inode *inode = file_inode(of->file);\n\t\tunmap_mapping_range(inode->i_mapping, 0, 0, 1);\n\t}\n\tmutex_unlock(&kernfs_open_file_mutex);\n\n\tkernfs_put_open_node(kn, NULL);\n}"
  },
  {
    "function_name": "kernfs_fop_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
    "lines": "729-740",
    "snippet": "static int kernfs_fop_release(struct inode *inode, struct file *filp)\n{\n\tstruct kernfs_node *kn = filp->f_path.dentry->d_fsdata;\n\tstruct kernfs_open_file *of = kernfs_of(filp);\n\n\tkernfs_put_open_node(kn, of);\n\tseq_release(inode, filp);\n\tkfree(of->prealloc_buf);\n\tkfree(of);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/fsnotify.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "of"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "of->prealloc_buf"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_release",
          "args": [
            "inode",
            "filp"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "seq_release_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "605-612",
          "snippet": "int seq_release_private(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\n\tkfree(seq->private);\n\tseq->private = NULL;\n\treturn seq_release(inode, file);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_release_private(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\n\tkfree(seq->private);\n\tseq->private = NULL;\n\treturn seq_release(inode, file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_put_open_node",
          "args": [
            "kn",
            "of"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_put_open_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
          "lines": "589-610",
          "snippet": "static void kernfs_put_open_node(struct kernfs_node *kn,\n\t\t\t\t struct kernfs_open_file *of)\n{\n\tstruct kernfs_open_node *on = kn->attr.open;\n\tunsigned long flags;\n\n\tmutex_lock(&kernfs_open_file_mutex);\n\tspin_lock_irqsave(&kernfs_open_node_lock, flags);\n\n\tif (of)\n\t\tlist_del(&of->list);\n\n\tif (atomic_dec_and_test(&on->refcnt))\n\t\tkn->attr.open = NULL;\n\telse\n\t\ton = NULL;\n\n\tspin_unlock_irqrestore(&kernfs_open_node_lock, flags);\n\tmutex_unlock(&kernfs_open_file_mutex);\n\n\tkfree(on);\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(kernfs_open_node_lock);",
            "static DEFINE_MUTEX(kernfs_open_file_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic DEFINE_SPINLOCK(kernfs_open_node_lock);\nstatic DEFINE_MUTEX(kernfs_open_file_mutex);\n\nstatic void kernfs_put_open_node(struct kernfs_node *kn,\n\t\t\t\t struct kernfs_open_file *of)\n{\n\tstruct kernfs_open_node *on = kn->attr.open;\n\tunsigned long flags;\n\n\tmutex_lock(&kernfs_open_file_mutex);\n\tspin_lock_irqsave(&kernfs_open_node_lock, flags);\n\n\tif (of)\n\t\tlist_del(&of->list);\n\n\tif (atomic_dec_and_test(&on->refcnt))\n\t\tkn->attr.open = NULL;\n\telse\n\t\ton = NULL;\n\n\tspin_unlock_irqrestore(&kernfs_open_node_lock, flags);\n\tmutex_unlock(&kernfs_open_file_mutex);\n\n\tkfree(on);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_of",
          "args": [
            "filp"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_of",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
          "lines": "55-58",
          "snippet": "static struct kernfs_open_file *kernfs_of(struct file *file)\n{\n\treturn ((struct seq_file *)file->private_data)->private;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic struct kernfs_open_file *kernfs_of(struct file *file)\n{\n\treturn ((struct seq_file *)file->private_data)->private;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic int kernfs_fop_release(struct inode *inode, struct file *filp)\n{\n\tstruct kernfs_node *kn = filp->f_path.dentry->d_fsdata;\n\tstruct kernfs_open_file *of = kernfs_of(filp);\n\n\tkernfs_put_open_node(kn, of);\n\tseq_release(inode, filp);\n\tkfree(of->prealloc_buf);\n\tkfree(of);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kernfs_fop_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
    "lines": "612-727",
    "snippet": "static int kernfs_fop_open(struct inode *inode, struct file *file)\n{\n\tstruct kernfs_node *kn = file->f_path.dentry->d_fsdata;\n\tstruct kernfs_root *root = kernfs_root(kn);\n\tconst struct kernfs_ops *ops;\n\tstruct kernfs_open_file *of;\n\tbool has_read, has_write, has_mmap;\n\tint error = -EACCES;\n\n\tif (!kernfs_get_active(kn))\n\t\treturn -ENODEV;\n\n\tops = kernfs_ops(kn);\n\n\thas_read = ops->seq_show || ops->read || ops->mmap;\n\thas_write = ops->write || ops->mmap;\n\thas_mmap = ops->mmap;\n\n\t/* see the flag definition for details */\n\tif (root->flags & KERNFS_ROOT_EXTRA_OPEN_PERM_CHECK) {\n\t\tif ((file->f_mode & FMODE_WRITE) &&\n\t\t    (!(inode->i_mode & S_IWUGO) || !has_write))\n\t\t\tgoto err_out;\n\n\t\tif ((file->f_mode & FMODE_READ) &&\n\t\t    (!(inode->i_mode & S_IRUGO) || !has_read))\n\t\t\tgoto err_out;\n\t}\n\n\t/* allocate a kernfs_open_file for the file */\n\terror = -ENOMEM;\n\tof = kzalloc(sizeof(struct kernfs_open_file), GFP_KERNEL);\n\tif (!of)\n\t\tgoto err_out;\n\n\t/*\n\t * The following is done to give a different lockdep key to\n\t * @of->mutex for files which implement mmap.  This is a rather\n\t * crude way to avoid false positive lockdep warning around\n\t * mm->mmap_sem - mmap nests @of->mutex under mm->mmap_sem and\n\t * reading /sys/block/sda/trace/act_mask grabs sr_mutex, under\n\t * which mm->mmap_sem nests, while holding @of->mutex.  As each\n\t * open file has a separate mutex, it's okay as long as those don't\n\t * happen on the same file.  At this point, we can't easily give\n\t * each file a separate locking class.  Let's differentiate on\n\t * whether the file has mmap or not for now.\n\t *\n\t * Both paths of the branch look the same.  They're supposed to\n\t * look that way and give @of->mutex different static lockdep keys.\n\t */\n\tif (has_mmap)\n\t\tmutex_init(&of->mutex);\n\telse\n\t\tmutex_init(&of->mutex);\n\n\tof->kn = kn;\n\tof->file = file;\n\n\t/*\n\t * Write path needs to atomic_write_len outside active reference.\n\t * Cache it in open_file.  See kernfs_fop_write() for details.\n\t */\n\tof->atomic_write_len = ops->atomic_write_len;\n\n\terror = -EINVAL;\n\t/*\n\t * ->seq_show is incompatible with ->prealloc,\n\t * as seq_read does its own allocation.\n\t * ->read must be used instead.\n\t */\n\tif (ops->prealloc && ops->seq_show)\n\t\tgoto err_free;\n\tif (ops->prealloc) {\n\t\tint len = of->atomic_write_len ?: PAGE_SIZE;\n\t\tof->prealloc_buf = kmalloc(len + 1, GFP_KERNEL);\n\t\terror = -ENOMEM;\n\t\tif (!of->prealloc_buf)\n\t\t\tgoto err_free;\n\t}\n\n\t/*\n\t * Always instantiate seq_file even if read access doesn't use\n\t * seq_file or is not requested.  This unifies private data access\n\t * and readable regular files are the vast majority anyway.\n\t */\n\tif (ops->seq_show)\n\t\terror = seq_open(file, &kernfs_seq_ops);\n\telse\n\t\terror = seq_open(file, NULL);\n\tif (error)\n\t\tgoto err_free;\n\n\t((struct seq_file *)file->private_data)->private = of;\n\n\t/* seq_file clears PWRITE unconditionally, restore it if WRITE */\n\tif (file->f_mode & FMODE_WRITE)\n\t\tfile->f_mode |= FMODE_PWRITE;\n\n\t/* make sure we have open node struct */\n\terror = kernfs_get_open_node(kn, of);\n\tif (error)\n\t\tgoto err_close;\n\n\t/* open succeeded, put active references */\n\tkernfs_put_active(kn);\n\treturn 0;\n\nerr_close:\n\tseq_release(inode, file);\nerr_free:\n\tkfree(of->prealloc_buf);\n\tkfree(of);\nerr_out:\n\tkernfs_put_active(kn);\n\treturn error;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/fsnotify.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct seq_operations kernfs_seq_ops = {\n\t.start = kernfs_seq_start,\n\t.next = kernfs_seq_next,\n\t.stop = kernfs_seq_stop,\n\t.show = kernfs_seq_show,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_put_active",
          "args": [
            "kn"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_put_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "319-334",
          "snippet": "void kernfs_put_active(struct kernfs_node *kn)\n{\n\tstruct kernfs_root *root = kernfs_root(kn);\n\tint v;\n\n\tif (unlikely(!kn))\n\t\treturn;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_release(&kn->dep_map, 1, _RET_IP_);\n\tv = atomic_dec_return(&kn->active);\n\tif (likely(v != KN_DEACTIVATED_BIAS))\n\t\treturn;\n\n\twake_up_all(&root->deactivate_waitq);\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_put_active(struct kernfs_node *kn)\n{\n\tstruct kernfs_root *root = kernfs_root(kn);\n\tint v;\n\n\tif (unlikely(!kn))\n\t\treturn;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_release(&kn->dep_map, 1, _RET_IP_);\n\tv = atomic_dec_return(&kn->active);\n\tif (likely(v != KN_DEACTIVATED_BIAS))\n\t\treturn;\n\n\twake_up_all(&root->deactivate_waitq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "of"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "of->prealloc_buf"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_release",
          "args": [
            "inode",
            "file"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "seq_release_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "605-612",
          "snippet": "int seq_release_private(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\n\tkfree(seq->private);\n\tseq->private = NULL;\n\treturn seq_release(inode, file);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_release_private(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\n\tkfree(seq->private);\n\tseq->private = NULL;\n\treturn seq_release(inode, file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_get_open_node",
          "args": [
            "kn",
            "of"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_get_open_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
          "lines": "538-576",
          "snippet": "static int kernfs_get_open_node(struct kernfs_node *kn,\n\t\t\t\tstruct kernfs_open_file *of)\n{\n\tstruct kernfs_open_node *on, *new_on = NULL;\n\n retry:\n\tmutex_lock(&kernfs_open_file_mutex);\n\tspin_lock_irq(&kernfs_open_node_lock);\n\n\tif (!kn->attr.open && new_on) {\n\t\tkn->attr.open = new_on;\n\t\tnew_on = NULL;\n\t}\n\n\ton = kn->attr.open;\n\tif (on) {\n\t\tatomic_inc(&on->refcnt);\n\t\tlist_add_tail(&of->list, &on->files);\n\t}\n\n\tspin_unlock_irq(&kernfs_open_node_lock);\n\tmutex_unlock(&kernfs_open_file_mutex);\n\n\tif (on) {\n\t\tkfree(new_on);\n\t\treturn 0;\n\t}\n\n\t/* not there, initialize a new one and retry */\n\tnew_on = kmalloc(sizeof(*new_on), GFP_KERNEL);\n\tif (!new_on)\n\t\treturn -ENOMEM;\n\n\tatomic_set(&new_on->refcnt, 0);\n\tatomic_set(&new_on->event, 1);\n\tinit_waitqueue_head(&new_on->poll);\n\tINIT_LIST_HEAD(&new_on->files);\n\tgoto retry;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(kernfs_open_node_lock);",
            "static DEFINE_MUTEX(kernfs_open_file_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic DEFINE_SPINLOCK(kernfs_open_node_lock);\nstatic DEFINE_MUTEX(kernfs_open_file_mutex);\n\nstatic int kernfs_get_open_node(struct kernfs_node *kn,\n\t\t\t\tstruct kernfs_open_file *of)\n{\n\tstruct kernfs_open_node *on, *new_on = NULL;\n\n retry:\n\tmutex_lock(&kernfs_open_file_mutex);\n\tspin_lock_irq(&kernfs_open_node_lock);\n\n\tif (!kn->attr.open && new_on) {\n\t\tkn->attr.open = new_on;\n\t\tnew_on = NULL;\n\t}\n\n\ton = kn->attr.open;\n\tif (on) {\n\t\tatomic_inc(&on->refcnt);\n\t\tlist_add_tail(&of->list, &on->files);\n\t}\n\n\tspin_unlock_irq(&kernfs_open_node_lock);\n\tmutex_unlock(&kernfs_open_file_mutex);\n\n\tif (on) {\n\t\tkfree(new_on);\n\t\treturn 0;\n\t}\n\n\t/* not there, initialize a new one and retry */\n\tnew_on = kmalloc(sizeof(*new_on), GFP_KERNEL);\n\tif (!new_on)\n\t\treturn -ENOMEM;\n\n\tatomic_set(&new_on->refcnt, 0);\n\tatomic_set(&new_on->event, 1);\n\tinit_waitqueue_head(&new_on->poll);\n\tINIT_LIST_HEAD(&new_on->files);\n\tgoto retry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "NULL"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "52-87",
          "snippet": "int seq_open(struct file *file, const struct seq_operations *op)\n{\n\tstruct seq_file *p = file->private_data;\n\n\tif (!p) {\n\t\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\tfile->private_data = p;\n\t}\n\tmemset(p, 0, sizeof(*p));\n\tmutex_init(&p->lock);\n\tp->op = op;\n#ifdef CONFIG_USER_NS\n\tp->user_ns = file->f_cred->user_ns;\n#endif\n\n\t/*\n\t * Wrappers around seq_open(e.g. swaps_open) need to be\n\t * aware of this. If they set f_version themselves, they\n\t * should call seq_open first and then set f_version.\n\t */\n\tfile->f_version = 0;\n\n\t/*\n\t * seq_files support lseek() and pread().  They do not implement\n\t * write() at all, but we clear FMODE_PWRITE here for historical\n\t * reasons.\n\t *\n\t * If a client of seq_files a) implements file.write() and b) wishes to\n\t * support pwrite() then that client will need to implement its own\n\t * file.open() which calls seq_open() and then sets FMODE_PWRITE.\n\t */\n\tfile->f_mode &= ~FMODE_PWRITE;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_open(struct file *file, const struct seq_operations *op)\n{\n\tstruct seq_file *p = file->private_data;\n\n\tif (!p) {\n\t\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\tfile->private_data = p;\n\t}\n\tmemset(p, 0, sizeof(*p));\n\tmutex_init(&p->lock);\n\tp->op = op;\n#ifdef CONFIG_USER_NS\n\tp->user_ns = file->f_cred->user_ns;\n#endif\n\n\t/*\n\t * Wrappers around seq_open(e.g. swaps_open) need to be\n\t * aware of this. If they set f_version themselves, they\n\t * should call seq_open first and then set f_version.\n\t */\n\tfile->f_version = 0;\n\n\t/*\n\t * seq_files support lseek() and pread().  They do not implement\n\t * write() at all, but we clear FMODE_PWRITE here for historical\n\t * reasons.\n\t *\n\t * If a client of seq_files a) implements file.write() and b) wishes to\n\t * support pwrite() then that client will need to implement its own\n\t * file.open() which calls seq_open() and then sets FMODE_PWRITE.\n\t */\n\tfile->f_mode &= ~FMODE_PWRITE;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "len + 1",
            "GFP_KERNEL"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&of->mutex"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&of->mutex"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct kernfs_open_file)",
            "GFP_KERNEL"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_ops",
          "args": [
            "kn"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
          "lines": "64-69",
          "snippet": "static const struct kernfs_ops *kernfs_ops(struct kernfs_node *kn)\n{\n\tif (kn->flags & KERNFS_LOCKDEP)\n\t\tlockdep_assert_held(kn);\n\treturn kn->attr.ops;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic const struct kernfs_ops *kernfs_ops(struct kernfs_node *kn)\n{\n\tif (kn->flags & KERNFS_LOCKDEP)\n\t\tlockdep_assert_held(kn);\n\treturn kn->attr.ops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_get_active",
          "args": [
            "kn"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_get_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "299-310",
          "snippet": "struct kernfs_node *kernfs_get_active(struct kernfs_node *kn)\n{\n\tif (unlikely(!kn))\n\t\treturn NULL;\n\n\tif (!atomic_inc_unless_negative(&kn->active))\n\t\treturn NULL;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_acquire_read(&kn->dep_map, 0, 1, _RET_IP_);\n\treturn kn;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstruct kernfs_node *kernfs_get_active(struct kernfs_node *kn)\n{\n\tif (unlikely(!kn))\n\t\treturn NULL;\n\n\tif (!atomic_inc_unless_negative(&kn->active))\n\t\treturn NULL;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_acquire_read(&kn->dep_map, 0, 1, _RET_IP_);\n\treturn kn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_root",
          "args": [
            "kn"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/kernfs-internal.h",
          "lines": "40-46",
          "snippet": "static inline struct kernfs_root *kernfs_root(struct kernfs_node *kn)\n{\n\t/* if parent exists, it's always a dir; otherwise, @sd is a dir */\n\tif (kn->parent)\n\t\tkn = kn->parent;\n\treturn kn->dir.root;\n}",
          "includes": [
            "#include <linux/kernfs.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>",
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernfs.h>\n#include <linux/xattr.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n#include <linux/lockdep.h>\n\nstatic inline struct kernfs_root *kernfs_root(struct kernfs_node *kn)\n{\n\t/* if parent exists, it's always a dir; otherwise, @sd is a dir */\n\tif (kn->parent)\n\t\tkn = kn->parent;\n\treturn kn->dir.root;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic const struct seq_operations kernfs_seq_ops = {\n\t.start = kernfs_seq_start,\n\t.next = kernfs_seq_next,\n\t.stop = kernfs_seq_stop,\n\t.show = kernfs_seq_show,\n};\n\nstatic int kernfs_fop_open(struct inode *inode, struct file *file)\n{\n\tstruct kernfs_node *kn = file->f_path.dentry->d_fsdata;\n\tstruct kernfs_root *root = kernfs_root(kn);\n\tconst struct kernfs_ops *ops;\n\tstruct kernfs_open_file *of;\n\tbool has_read, has_write, has_mmap;\n\tint error = -EACCES;\n\n\tif (!kernfs_get_active(kn))\n\t\treturn -ENODEV;\n\n\tops = kernfs_ops(kn);\n\n\thas_read = ops->seq_show || ops->read || ops->mmap;\n\thas_write = ops->write || ops->mmap;\n\thas_mmap = ops->mmap;\n\n\t/* see the flag definition for details */\n\tif (root->flags & KERNFS_ROOT_EXTRA_OPEN_PERM_CHECK) {\n\t\tif ((file->f_mode & FMODE_WRITE) &&\n\t\t    (!(inode->i_mode & S_IWUGO) || !has_write))\n\t\t\tgoto err_out;\n\n\t\tif ((file->f_mode & FMODE_READ) &&\n\t\t    (!(inode->i_mode & S_IRUGO) || !has_read))\n\t\t\tgoto err_out;\n\t}\n\n\t/* allocate a kernfs_open_file for the file */\n\terror = -ENOMEM;\n\tof = kzalloc(sizeof(struct kernfs_open_file), GFP_KERNEL);\n\tif (!of)\n\t\tgoto err_out;\n\n\t/*\n\t * The following is done to give a different lockdep key to\n\t * @of->mutex for files which implement mmap.  This is a rather\n\t * crude way to avoid false positive lockdep warning around\n\t * mm->mmap_sem - mmap nests @of->mutex under mm->mmap_sem and\n\t * reading /sys/block/sda/trace/act_mask grabs sr_mutex, under\n\t * which mm->mmap_sem nests, while holding @of->mutex.  As each\n\t * open file has a separate mutex, it's okay as long as those don't\n\t * happen on the same file.  At this point, we can't easily give\n\t * each file a separate locking class.  Let's differentiate on\n\t * whether the file has mmap or not for now.\n\t *\n\t * Both paths of the branch look the same.  They're supposed to\n\t * look that way and give @of->mutex different static lockdep keys.\n\t */\n\tif (has_mmap)\n\t\tmutex_init(&of->mutex);\n\telse\n\t\tmutex_init(&of->mutex);\n\n\tof->kn = kn;\n\tof->file = file;\n\n\t/*\n\t * Write path needs to atomic_write_len outside active reference.\n\t * Cache it in open_file.  See kernfs_fop_write() for details.\n\t */\n\tof->atomic_write_len = ops->atomic_write_len;\n\n\terror = -EINVAL;\n\t/*\n\t * ->seq_show is incompatible with ->prealloc,\n\t * as seq_read does its own allocation.\n\t * ->read must be used instead.\n\t */\n\tif (ops->prealloc && ops->seq_show)\n\t\tgoto err_free;\n\tif (ops->prealloc) {\n\t\tint len = of->atomic_write_len ?: PAGE_SIZE;\n\t\tof->prealloc_buf = kmalloc(len + 1, GFP_KERNEL);\n\t\terror = -ENOMEM;\n\t\tif (!of->prealloc_buf)\n\t\t\tgoto err_free;\n\t}\n\n\t/*\n\t * Always instantiate seq_file even if read access doesn't use\n\t * seq_file or is not requested.  This unifies private data access\n\t * and readable regular files are the vast majority anyway.\n\t */\n\tif (ops->seq_show)\n\t\terror = seq_open(file, &kernfs_seq_ops);\n\telse\n\t\terror = seq_open(file, NULL);\n\tif (error)\n\t\tgoto err_free;\n\n\t((struct seq_file *)file->private_data)->private = of;\n\n\t/* seq_file clears PWRITE unconditionally, restore it if WRITE */\n\tif (file->f_mode & FMODE_WRITE)\n\t\tfile->f_mode |= FMODE_PWRITE;\n\n\t/* make sure we have open node struct */\n\terror = kernfs_get_open_node(kn, of);\n\tif (error)\n\t\tgoto err_close;\n\n\t/* open succeeded, put active references */\n\tkernfs_put_active(kn);\n\treturn 0;\n\nerr_close:\n\tseq_release(inode, file);\nerr_free:\n\tkfree(of->prealloc_buf);\n\tkfree(of);\nerr_out:\n\tkernfs_put_active(kn);\n\treturn error;\n}"
  },
  {
    "function_name": "kernfs_put_open_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
    "lines": "589-610",
    "snippet": "static void kernfs_put_open_node(struct kernfs_node *kn,\n\t\t\t\t struct kernfs_open_file *of)\n{\n\tstruct kernfs_open_node *on = kn->attr.open;\n\tunsigned long flags;\n\n\tmutex_lock(&kernfs_open_file_mutex);\n\tspin_lock_irqsave(&kernfs_open_node_lock, flags);\n\n\tif (of)\n\t\tlist_del(&of->list);\n\n\tif (atomic_dec_and_test(&on->refcnt))\n\t\tkn->attr.open = NULL;\n\telse\n\t\ton = NULL;\n\n\tspin_unlock_irqrestore(&kernfs_open_node_lock, flags);\n\tmutex_unlock(&kernfs_open_file_mutex);\n\n\tkfree(on);\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/fsnotify.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(kernfs_open_node_lock);",
      "static DEFINE_MUTEX(kernfs_open_file_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "on"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kernfs_open_file_mutex"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&kernfs_open_node_lock",
            "flags"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&on->refcnt"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&of->list"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&kernfs_open_node_lock",
            "flags"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kernfs_open_file_mutex"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic DEFINE_SPINLOCK(kernfs_open_node_lock);\nstatic DEFINE_MUTEX(kernfs_open_file_mutex);\n\nstatic void kernfs_put_open_node(struct kernfs_node *kn,\n\t\t\t\t struct kernfs_open_file *of)\n{\n\tstruct kernfs_open_node *on = kn->attr.open;\n\tunsigned long flags;\n\n\tmutex_lock(&kernfs_open_file_mutex);\n\tspin_lock_irqsave(&kernfs_open_node_lock, flags);\n\n\tif (of)\n\t\tlist_del(&of->list);\n\n\tif (atomic_dec_and_test(&on->refcnt))\n\t\tkn->attr.open = NULL;\n\telse\n\t\ton = NULL;\n\n\tspin_unlock_irqrestore(&kernfs_open_node_lock, flags);\n\tmutex_unlock(&kernfs_open_file_mutex);\n\n\tkfree(on);\n}"
  },
  {
    "function_name": "kernfs_get_open_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
    "lines": "538-576",
    "snippet": "static int kernfs_get_open_node(struct kernfs_node *kn,\n\t\t\t\tstruct kernfs_open_file *of)\n{\n\tstruct kernfs_open_node *on, *new_on = NULL;\n\n retry:\n\tmutex_lock(&kernfs_open_file_mutex);\n\tspin_lock_irq(&kernfs_open_node_lock);\n\n\tif (!kn->attr.open && new_on) {\n\t\tkn->attr.open = new_on;\n\t\tnew_on = NULL;\n\t}\n\n\ton = kn->attr.open;\n\tif (on) {\n\t\tatomic_inc(&on->refcnt);\n\t\tlist_add_tail(&of->list, &on->files);\n\t}\n\n\tspin_unlock_irq(&kernfs_open_node_lock);\n\tmutex_unlock(&kernfs_open_file_mutex);\n\n\tif (on) {\n\t\tkfree(new_on);\n\t\treturn 0;\n\t}\n\n\t/* not there, initialize a new one and retry */\n\tnew_on = kmalloc(sizeof(*new_on), GFP_KERNEL);\n\tif (!new_on)\n\t\treturn -ENOMEM;\n\n\tatomic_set(&new_on->refcnt, 0);\n\tatomic_set(&new_on->event, 1);\n\tinit_waitqueue_head(&new_on->poll);\n\tINIT_LIST_HEAD(&new_on->files);\n\tgoto retry;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/fsnotify.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(kernfs_open_node_lock);",
      "static DEFINE_MUTEX(kernfs_open_file_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&new_on->files"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&new_on->poll"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&new_on->event",
            "1"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&new_on->refcnt",
            "0"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*new_on)",
            "GFP_KERNEL"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "new_on"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kernfs_open_file_mutex"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&kernfs_open_node_lock"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&of->list",
            "&on->files"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&on->refcnt"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&kernfs_open_node_lock"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kernfs_open_file_mutex"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic DEFINE_SPINLOCK(kernfs_open_node_lock);\nstatic DEFINE_MUTEX(kernfs_open_file_mutex);\n\nstatic int kernfs_get_open_node(struct kernfs_node *kn,\n\t\t\t\tstruct kernfs_open_file *of)\n{\n\tstruct kernfs_open_node *on, *new_on = NULL;\n\n retry:\n\tmutex_lock(&kernfs_open_file_mutex);\n\tspin_lock_irq(&kernfs_open_node_lock);\n\n\tif (!kn->attr.open && new_on) {\n\t\tkn->attr.open = new_on;\n\t\tnew_on = NULL;\n\t}\n\n\ton = kn->attr.open;\n\tif (on) {\n\t\tatomic_inc(&on->refcnt);\n\t\tlist_add_tail(&of->list, &on->files);\n\t}\n\n\tspin_unlock_irq(&kernfs_open_node_lock);\n\tmutex_unlock(&kernfs_open_file_mutex);\n\n\tif (on) {\n\t\tkfree(new_on);\n\t\treturn 0;\n\t}\n\n\t/* not there, initialize a new one and retry */\n\tnew_on = kmalloc(sizeof(*new_on), GFP_KERNEL);\n\tif (!new_on)\n\t\treturn -ENOMEM;\n\n\tatomic_set(&new_on->refcnt, 0);\n\tatomic_set(&new_on->event, 1);\n\tinit_waitqueue_head(&new_on->poll);\n\tINIT_LIST_HEAD(&new_on->files);\n\tgoto retry;\n}"
  },
  {
    "function_name": "kernfs_fop_mmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
    "lines": "465-522",
    "snippet": "static int kernfs_fop_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct kernfs_open_file *of = kernfs_of(file);\n\tconst struct kernfs_ops *ops;\n\tint rc;\n\n\t/*\n\t * mmap path and of->mutex are prone to triggering spurious lockdep\n\t * warnings and we don't want to add spurious locking dependency\n\t * between the two.  Check whether mmap is actually implemented\n\t * without grabbing @of->mutex by testing HAS_MMAP flag.  See the\n\t * comment in kernfs_file_open() for more details.\n\t */\n\tif (!(of->kn->flags & KERNFS_HAS_MMAP))\n\t\treturn -ENODEV;\n\n\tmutex_lock(&of->mutex);\n\n\trc = -ENODEV;\n\tif (!kernfs_get_active(of->kn))\n\t\tgoto out_unlock;\n\n\tops = kernfs_ops(of->kn);\n\trc = ops->mmap(of, vma);\n\tif (rc)\n\t\tgoto out_put;\n\n\t/*\n\t * PowerPC's pci_mmap of legacy_mem uses shmem_zero_setup()\n\t * to satisfy versions of X which crash if the mmap fails: that\n\t * substitutes a new vm_file, and we don't then want bin_vm_ops.\n\t */\n\tif (vma->vm_file != file)\n\t\tgoto out_put;\n\n\trc = -EINVAL;\n\tif (of->mmapped && of->vm_ops != vma->vm_ops)\n\t\tgoto out_put;\n\n\t/*\n\t * It is not possible to successfully wrap close.\n\t * So error if someone is trying to use close.\n\t */\n\trc = -EINVAL;\n\tif (vma->vm_ops && vma->vm_ops->close)\n\t\tgoto out_put;\n\n\trc = 0;\n\tof->mmapped = 1;\n\tof->vm_ops = vma->vm_ops;\n\tvma->vm_ops = &kernfs_vm_ops;\nout_put:\n\tkernfs_put_active(of->kn);\nout_unlock:\n\tmutex_unlock(&of->mutex);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/fsnotify.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct vm_operations_struct kernfs_vm_ops = {\n\t.open\t\t= kernfs_vma_open,\n\t.fault\t\t= kernfs_vma_fault,\n\t.page_mkwrite\t= kernfs_vma_page_mkwrite,\n\t.access\t\t= kernfs_vma_access,\n#ifdef CONFIG_NUMA\n\t.set_policy\t= kernfs_vma_set_policy,\n\t.get_policy\t= kernfs_vma_get_policy,\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&of->mutex"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_put_active",
          "args": [
            "of->kn"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_put_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "319-334",
          "snippet": "void kernfs_put_active(struct kernfs_node *kn)\n{\n\tstruct kernfs_root *root = kernfs_root(kn);\n\tint v;\n\n\tif (unlikely(!kn))\n\t\treturn;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_release(&kn->dep_map, 1, _RET_IP_);\n\tv = atomic_dec_return(&kn->active);\n\tif (likely(v != KN_DEACTIVATED_BIAS))\n\t\treturn;\n\n\twake_up_all(&root->deactivate_waitq);\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_put_active(struct kernfs_node *kn)\n{\n\tstruct kernfs_root *root = kernfs_root(kn);\n\tint v;\n\n\tif (unlikely(!kn))\n\t\treturn;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_release(&kn->dep_map, 1, _RET_IP_);\n\tv = atomic_dec_return(&kn->active);\n\tif (likely(v != KN_DEACTIVATED_BIAS))\n\t\treturn;\n\n\twake_up_all(&root->deactivate_waitq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->mmap",
          "args": [
            "of",
            "vma"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_ops",
          "args": [
            "of->kn"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
          "lines": "64-69",
          "snippet": "static const struct kernfs_ops *kernfs_ops(struct kernfs_node *kn)\n{\n\tif (kn->flags & KERNFS_LOCKDEP)\n\t\tlockdep_assert_held(kn);\n\treturn kn->attr.ops;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic const struct kernfs_ops *kernfs_ops(struct kernfs_node *kn)\n{\n\tif (kn->flags & KERNFS_LOCKDEP)\n\t\tlockdep_assert_held(kn);\n\treturn kn->attr.ops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_get_active",
          "args": [
            "of->kn"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_get_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "299-310",
          "snippet": "struct kernfs_node *kernfs_get_active(struct kernfs_node *kn)\n{\n\tif (unlikely(!kn))\n\t\treturn NULL;\n\n\tif (!atomic_inc_unless_negative(&kn->active))\n\t\treturn NULL;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_acquire_read(&kn->dep_map, 0, 1, _RET_IP_);\n\treturn kn;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstruct kernfs_node *kernfs_get_active(struct kernfs_node *kn)\n{\n\tif (unlikely(!kn))\n\t\treturn NULL;\n\n\tif (!atomic_inc_unless_negative(&kn->active))\n\t\treturn NULL;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_acquire_read(&kn->dep_map, 0, 1, _RET_IP_);\n\treturn kn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&of->mutex"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_of",
          "args": [
            "file"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_of",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
          "lines": "55-58",
          "snippet": "static struct kernfs_open_file *kernfs_of(struct file *file)\n{\n\treturn ((struct seq_file *)file->private_data)->private;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic struct kernfs_open_file *kernfs_of(struct file *file)\n{\n\treturn ((struct seq_file *)file->private_data)->private;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic const struct vm_operations_struct kernfs_vm_ops = {\n\t.open\t\t= kernfs_vma_open,\n\t.fault\t\t= kernfs_vma_fault,\n\t.page_mkwrite\t= kernfs_vma_page_mkwrite,\n\t.access\t\t= kernfs_vma_access,\n#ifdef CONFIG_NUMA\n\t.set_policy\t= kernfs_vma_set_policy,\n\t.get_policy\t= kernfs_vma_get_policy,\n#endif\n};\n\nstatic int kernfs_fop_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct kernfs_open_file *of = kernfs_of(file);\n\tconst struct kernfs_ops *ops;\n\tint rc;\n\n\t/*\n\t * mmap path and of->mutex are prone to triggering spurious lockdep\n\t * warnings and we don't want to add spurious locking dependency\n\t * between the two.  Check whether mmap is actually implemented\n\t * without grabbing @of->mutex by testing HAS_MMAP flag.  See the\n\t * comment in kernfs_file_open() for more details.\n\t */\n\tif (!(of->kn->flags & KERNFS_HAS_MMAP))\n\t\treturn -ENODEV;\n\n\tmutex_lock(&of->mutex);\n\n\trc = -ENODEV;\n\tif (!kernfs_get_active(of->kn))\n\t\tgoto out_unlock;\n\n\tops = kernfs_ops(of->kn);\n\trc = ops->mmap(of, vma);\n\tif (rc)\n\t\tgoto out_put;\n\n\t/*\n\t * PowerPC's pci_mmap of legacy_mem uses shmem_zero_setup()\n\t * to satisfy versions of X which crash if the mmap fails: that\n\t * substitutes a new vm_file, and we don't then want bin_vm_ops.\n\t */\n\tif (vma->vm_file != file)\n\t\tgoto out_put;\n\n\trc = -EINVAL;\n\tif (of->mmapped && of->vm_ops != vma->vm_ops)\n\t\tgoto out_put;\n\n\t/*\n\t * It is not possible to successfully wrap close.\n\t * So error if someone is trying to use close.\n\t */\n\trc = -EINVAL;\n\tif (vma->vm_ops && vma->vm_ops->close)\n\t\tgoto out_put;\n\n\trc = 0;\n\tof->mmapped = 1;\n\tof->vm_ops = vma->vm_ops;\n\tvma->vm_ops = &kernfs_vm_ops;\nout_put:\n\tkernfs_put_active(of->kn);\nout_unlock:\n\tmutex_unlock(&of->mutex);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "kernfs_vma_get_policy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
    "lines": "431-450",
    "snippet": "static struct mempolicy *kernfs_vma_get_policy(struct vm_area_struct *vma,\n\t\t\t\t\t       unsigned long addr)\n{\n\tstruct file *file = vma->vm_file;\n\tstruct kernfs_open_file *of = kernfs_of(file);\n\tstruct mempolicy *pol;\n\n\tif (!of->vm_ops)\n\t\treturn vma->vm_policy;\n\n\tif (!kernfs_get_active(of->kn))\n\t\treturn vma->vm_policy;\n\n\tpol = vma->vm_policy;\n\tif (of->vm_ops->get_policy)\n\t\tpol = of->vm_ops->get_policy(vma, addr);\n\n\tkernfs_put_active(of->kn);\n\treturn pol;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/fsnotify.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_put_active",
          "args": [
            "of->kn"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_put_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "319-334",
          "snippet": "void kernfs_put_active(struct kernfs_node *kn)\n{\n\tstruct kernfs_root *root = kernfs_root(kn);\n\tint v;\n\n\tif (unlikely(!kn))\n\t\treturn;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_release(&kn->dep_map, 1, _RET_IP_);\n\tv = atomic_dec_return(&kn->active);\n\tif (likely(v != KN_DEACTIVATED_BIAS))\n\t\treturn;\n\n\twake_up_all(&root->deactivate_waitq);\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_put_active(struct kernfs_node *kn)\n{\n\tstruct kernfs_root *root = kernfs_root(kn);\n\tint v;\n\n\tif (unlikely(!kn))\n\t\treturn;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_release(&kn->dep_map, 1, _RET_IP_);\n\tv = atomic_dec_return(&kn->active);\n\tif (likely(v != KN_DEACTIVATED_BIAS))\n\t\treturn;\n\n\twake_up_all(&root->deactivate_waitq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "of->vm_ops->get_policy",
          "args": [
            "vma",
            "addr"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_get_active",
          "args": [
            "of->kn"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_get_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "299-310",
          "snippet": "struct kernfs_node *kernfs_get_active(struct kernfs_node *kn)\n{\n\tif (unlikely(!kn))\n\t\treturn NULL;\n\n\tif (!atomic_inc_unless_negative(&kn->active))\n\t\treturn NULL;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_acquire_read(&kn->dep_map, 0, 1, _RET_IP_);\n\treturn kn;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstruct kernfs_node *kernfs_get_active(struct kernfs_node *kn)\n{\n\tif (unlikely(!kn))\n\t\treturn NULL;\n\n\tif (!atomic_inc_unless_negative(&kn->active))\n\t\treturn NULL;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_acquire_read(&kn->dep_map, 0, 1, _RET_IP_);\n\treturn kn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_of",
          "args": [
            "file"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_of",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
          "lines": "55-58",
          "snippet": "static struct kernfs_open_file *kernfs_of(struct file *file)\n{\n\treturn ((struct seq_file *)file->private_data)->private;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic struct kernfs_open_file *kernfs_of(struct file *file)\n{\n\treturn ((struct seq_file *)file->private_data)->private;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic struct mempolicy *kernfs_vma_get_policy(struct vm_area_struct *vma,\n\t\t\t\t\t       unsigned long addr)\n{\n\tstruct file *file = vma->vm_file;\n\tstruct kernfs_open_file *of = kernfs_of(file);\n\tstruct mempolicy *pol;\n\n\tif (!of->vm_ops)\n\t\treturn vma->vm_policy;\n\n\tif (!kernfs_get_active(of->kn))\n\t\treturn vma->vm_policy;\n\n\tpol = vma->vm_policy;\n\tif (of->vm_ops->get_policy)\n\t\tpol = of->vm_ops->get_policy(vma, addr);\n\n\tkernfs_put_active(of->kn);\n\treturn pol;\n}"
  },
  {
    "function_name": "kernfs_vma_set_policy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
    "lines": "410-429",
    "snippet": "static int kernfs_vma_set_policy(struct vm_area_struct *vma,\n\t\t\t\t struct mempolicy *new)\n{\n\tstruct file *file = vma->vm_file;\n\tstruct kernfs_open_file *of = kernfs_of(file);\n\tint ret;\n\n\tif (!of->vm_ops)\n\t\treturn 0;\n\n\tif (!kernfs_get_active(of->kn))\n\t\treturn -EINVAL;\n\n\tret = 0;\n\tif (of->vm_ops->set_policy)\n\t\tret = of->vm_ops->set_policy(vma, new);\n\n\tkernfs_put_active(of->kn);\n\treturn ret;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/fsnotify.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_put_active",
          "args": [
            "of->kn"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_put_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "319-334",
          "snippet": "void kernfs_put_active(struct kernfs_node *kn)\n{\n\tstruct kernfs_root *root = kernfs_root(kn);\n\tint v;\n\n\tif (unlikely(!kn))\n\t\treturn;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_release(&kn->dep_map, 1, _RET_IP_);\n\tv = atomic_dec_return(&kn->active);\n\tif (likely(v != KN_DEACTIVATED_BIAS))\n\t\treturn;\n\n\twake_up_all(&root->deactivate_waitq);\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_put_active(struct kernfs_node *kn)\n{\n\tstruct kernfs_root *root = kernfs_root(kn);\n\tint v;\n\n\tif (unlikely(!kn))\n\t\treturn;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_release(&kn->dep_map, 1, _RET_IP_);\n\tv = atomic_dec_return(&kn->active);\n\tif (likely(v != KN_DEACTIVATED_BIAS))\n\t\treturn;\n\n\twake_up_all(&root->deactivate_waitq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "of->vm_ops->set_policy",
          "args": [
            "vma",
            "new"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_get_active",
          "args": [
            "of->kn"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_get_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "299-310",
          "snippet": "struct kernfs_node *kernfs_get_active(struct kernfs_node *kn)\n{\n\tif (unlikely(!kn))\n\t\treturn NULL;\n\n\tif (!atomic_inc_unless_negative(&kn->active))\n\t\treturn NULL;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_acquire_read(&kn->dep_map, 0, 1, _RET_IP_);\n\treturn kn;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstruct kernfs_node *kernfs_get_active(struct kernfs_node *kn)\n{\n\tif (unlikely(!kn))\n\t\treturn NULL;\n\n\tif (!atomic_inc_unless_negative(&kn->active))\n\t\treturn NULL;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_acquire_read(&kn->dep_map, 0, 1, _RET_IP_);\n\treturn kn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_of",
          "args": [
            "file"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_of",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
          "lines": "55-58",
          "snippet": "static struct kernfs_open_file *kernfs_of(struct file *file)\n{\n\treturn ((struct seq_file *)file->private_data)->private;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic struct kernfs_open_file *kernfs_of(struct file *file)\n{\n\treturn ((struct seq_file *)file->private_data)->private;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic int kernfs_vma_set_policy(struct vm_area_struct *vma,\n\t\t\t\t struct mempolicy *new)\n{\n\tstruct file *file = vma->vm_file;\n\tstruct kernfs_open_file *of = kernfs_of(file);\n\tint ret;\n\n\tif (!of->vm_ops)\n\t\treturn 0;\n\n\tif (!kernfs_get_active(of->kn))\n\t\treturn -EINVAL;\n\n\tret = 0;\n\tif (of->vm_ops->set_policy)\n\t\tret = of->vm_ops->set_policy(vma, new);\n\n\tkernfs_put_active(of->kn);\n\treturn ret;\n}"
  },
  {
    "function_name": "kernfs_vma_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
    "lines": "388-407",
    "snippet": "static int kernfs_vma_access(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t     void *buf, int len, int write)\n{\n\tstruct file *file = vma->vm_file;\n\tstruct kernfs_open_file *of = kernfs_of(file);\n\tint ret;\n\n\tif (!of->vm_ops)\n\t\treturn -EINVAL;\n\n\tif (!kernfs_get_active(of->kn))\n\t\treturn -EINVAL;\n\n\tret = -EINVAL;\n\tif (of->vm_ops->access)\n\t\tret = of->vm_ops->access(vma, addr, buf, len, write);\n\n\tkernfs_put_active(of->kn);\n\treturn ret;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/fsnotify.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_put_active",
          "args": [
            "of->kn"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_put_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "319-334",
          "snippet": "void kernfs_put_active(struct kernfs_node *kn)\n{\n\tstruct kernfs_root *root = kernfs_root(kn);\n\tint v;\n\n\tif (unlikely(!kn))\n\t\treturn;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_release(&kn->dep_map, 1, _RET_IP_);\n\tv = atomic_dec_return(&kn->active);\n\tif (likely(v != KN_DEACTIVATED_BIAS))\n\t\treturn;\n\n\twake_up_all(&root->deactivate_waitq);\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_put_active(struct kernfs_node *kn)\n{\n\tstruct kernfs_root *root = kernfs_root(kn);\n\tint v;\n\n\tif (unlikely(!kn))\n\t\treturn;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_release(&kn->dep_map, 1, _RET_IP_);\n\tv = atomic_dec_return(&kn->active);\n\tif (likely(v != KN_DEACTIVATED_BIAS))\n\t\treturn;\n\n\twake_up_all(&root->deactivate_waitq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "of->vm_ops->access",
          "args": [
            "vma",
            "addr",
            "buf",
            "len",
            "write"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_get_active",
          "args": [
            "of->kn"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_get_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "299-310",
          "snippet": "struct kernfs_node *kernfs_get_active(struct kernfs_node *kn)\n{\n\tif (unlikely(!kn))\n\t\treturn NULL;\n\n\tif (!atomic_inc_unless_negative(&kn->active))\n\t\treturn NULL;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_acquire_read(&kn->dep_map, 0, 1, _RET_IP_);\n\treturn kn;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstruct kernfs_node *kernfs_get_active(struct kernfs_node *kn)\n{\n\tif (unlikely(!kn))\n\t\treturn NULL;\n\n\tif (!atomic_inc_unless_negative(&kn->active))\n\t\treturn NULL;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_acquire_read(&kn->dep_map, 0, 1, _RET_IP_);\n\treturn kn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_of",
          "args": [
            "file"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_of",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
          "lines": "55-58",
          "snippet": "static struct kernfs_open_file *kernfs_of(struct file *file)\n{\n\treturn ((struct seq_file *)file->private_data)->private;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic struct kernfs_open_file *kernfs_of(struct file *file)\n{\n\treturn ((struct seq_file *)file->private_data)->private;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic int kernfs_vma_access(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t     void *buf, int len, int write)\n{\n\tstruct file *file = vma->vm_file;\n\tstruct kernfs_open_file *of = kernfs_of(file);\n\tint ret;\n\n\tif (!of->vm_ops)\n\t\treturn -EINVAL;\n\n\tif (!kernfs_get_active(of->kn))\n\t\treturn -EINVAL;\n\n\tret = -EINVAL;\n\tif (of->vm_ops->access)\n\t\tret = of->vm_ops->access(vma, addr, buf, len, write);\n\n\tkernfs_put_active(of->kn);\n\treturn ret;\n}"
  },
  {
    "function_name": "kernfs_vma_page_mkwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
    "lines": "365-386",
    "snippet": "static int kernfs_vma_page_mkwrite(struct vm_area_struct *vma,\n\t\t\t\t   struct vm_fault *vmf)\n{\n\tstruct file *file = vma->vm_file;\n\tstruct kernfs_open_file *of = kernfs_of(file);\n\tint ret;\n\n\tif (!of->vm_ops)\n\t\treturn VM_FAULT_SIGBUS;\n\n\tif (!kernfs_get_active(of->kn))\n\t\treturn VM_FAULT_SIGBUS;\n\n\tret = 0;\n\tif (of->vm_ops->page_mkwrite)\n\t\tret = of->vm_ops->page_mkwrite(vma, vmf);\n\telse\n\t\tfile_update_time(file);\n\n\tkernfs_put_active(of->kn);\n\treturn ret;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/fsnotify.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_put_active",
          "args": [
            "of->kn"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_put_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "319-334",
          "snippet": "void kernfs_put_active(struct kernfs_node *kn)\n{\n\tstruct kernfs_root *root = kernfs_root(kn);\n\tint v;\n\n\tif (unlikely(!kn))\n\t\treturn;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_release(&kn->dep_map, 1, _RET_IP_);\n\tv = atomic_dec_return(&kn->active);\n\tif (likely(v != KN_DEACTIVATED_BIAS))\n\t\treturn;\n\n\twake_up_all(&root->deactivate_waitq);\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_put_active(struct kernfs_node *kn)\n{\n\tstruct kernfs_root *root = kernfs_root(kn);\n\tint v;\n\n\tif (unlikely(!kn))\n\t\treturn;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_release(&kn->dep_map, 1, _RET_IP_);\n\tv = atomic_dec_return(&kn->active);\n\tif (likely(v != KN_DEACTIVATED_BIAS))\n\t\treturn;\n\n\twake_up_all(&root->deactivate_waitq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_update_time",
          "args": [
            "file"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "file_update_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1716-1748",
          "snippet": "int file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_fs_time(inode->i_sb);\n\tif (!timespec_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_fs_time(inode->i_sb);\n\tif (!timespec_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "of->vm_ops->page_mkwrite",
          "args": [
            "vma",
            "vmf"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_get_active",
          "args": [
            "of->kn"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_get_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "299-310",
          "snippet": "struct kernfs_node *kernfs_get_active(struct kernfs_node *kn)\n{\n\tif (unlikely(!kn))\n\t\treturn NULL;\n\n\tif (!atomic_inc_unless_negative(&kn->active))\n\t\treturn NULL;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_acquire_read(&kn->dep_map, 0, 1, _RET_IP_);\n\treturn kn;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstruct kernfs_node *kernfs_get_active(struct kernfs_node *kn)\n{\n\tif (unlikely(!kn))\n\t\treturn NULL;\n\n\tif (!atomic_inc_unless_negative(&kn->active))\n\t\treturn NULL;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_acquire_read(&kn->dep_map, 0, 1, _RET_IP_);\n\treturn kn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_of",
          "args": [
            "file"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_of",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
          "lines": "55-58",
          "snippet": "static struct kernfs_open_file *kernfs_of(struct file *file)\n{\n\treturn ((struct seq_file *)file->private_data)->private;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic struct kernfs_open_file *kernfs_of(struct file *file)\n{\n\treturn ((struct seq_file *)file->private_data)->private;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic int kernfs_vma_page_mkwrite(struct vm_area_struct *vma,\n\t\t\t\t   struct vm_fault *vmf)\n{\n\tstruct file *file = vma->vm_file;\n\tstruct kernfs_open_file *of = kernfs_of(file);\n\tint ret;\n\n\tif (!of->vm_ops)\n\t\treturn VM_FAULT_SIGBUS;\n\n\tif (!kernfs_get_active(of->kn))\n\t\treturn VM_FAULT_SIGBUS;\n\n\tret = 0;\n\tif (of->vm_ops->page_mkwrite)\n\t\tret = of->vm_ops->page_mkwrite(vma, vmf);\n\telse\n\t\tfile_update_time(file);\n\n\tkernfs_put_active(of->kn);\n\treturn ret;\n}"
  },
  {
    "function_name": "kernfs_vma_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
    "lines": "345-363",
    "snippet": "static int kernfs_vma_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct file *file = vma->vm_file;\n\tstruct kernfs_open_file *of = kernfs_of(file);\n\tint ret;\n\n\tif (!of->vm_ops)\n\t\treturn VM_FAULT_SIGBUS;\n\n\tif (!kernfs_get_active(of->kn))\n\t\treturn VM_FAULT_SIGBUS;\n\n\tret = VM_FAULT_SIGBUS;\n\tif (of->vm_ops->fault)\n\t\tret = of->vm_ops->fault(vma, vmf);\n\n\tkernfs_put_active(of->kn);\n\treturn ret;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/fsnotify.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_put_active",
          "args": [
            "of->kn"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_put_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "319-334",
          "snippet": "void kernfs_put_active(struct kernfs_node *kn)\n{\n\tstruct kernfs_root *root = kernfs_root(kn);\n\tint v;\n\n\tif (unlikely(!kn))\n\t\treturn;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_release(&kn->dep_map, 1, _RET_IP_);\n\tv = atomic_dec_return(&kn->active);\n\tif (likely(v != KN_DEACTIVATED_BIAS))\n\t\treturn;\n\n\twake_up_all(&root->deactivate_waitq);\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_put_active(struct kernfs_node *kn)\n{\n\tstruct kernfs_root *root = kernfs_root(kn);\n\tint v;\n\n\tif (unlikely(!kn))\n\t\treturn;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_release(&kn->dep_map, 1, _RET_IP_);\n\tv = atomic_dec_return(&kn->active);\n\tif (likely(v != KN_DEACTIVATED_BIAS))\n\t\treturn;\n\n\twake_up_all(&root->deactivate_waitq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "of->vm_ops->fault",
          "args": [
            "vma",
            "vmf"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_get_active",
          "args": [
            "of->kn"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_get_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "299-310",
          "snippet": "struct kernfs_node *kernfs_get_active(struct kernfs_node *kn)\n{\n\tif (unlikely(!kn))\n\t\treturn NULL;\n\n\tif (!atomic_inc_unless_negative(&kn->active))\n\t\treturn NULL;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_acquire_read(&kn->dep_map, 0, 1, _RET_IP_);\n\treturn kn;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstruct kernfs_node *kernfs_get_active(struct kernfs_node *kn)\n{\n\tif (unlikely(!kn))\n\t\treturn NULL;\n\n\tif (!atomic_inc_unless_negative(&kn->active))\n\t\treturn NULL;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_acquire_read(&kn->dep_map, 0, 1, _RET_IP_);\n\treturn kn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_of",
          "args": [
            "file"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_of",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
          "lines": "55-58",
          "snippet": "static struct kernfs_open_file *kernfs_of(struct file *file)\n{\n\treturn ((struct seq_file *)file->private_data)->private;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic struct kernfs_open_file *kernfs_of(struct file *file)\n{\n\treturn ((struct seq_file *)file->private_data)->private;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic int kernfs_vma_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct file *file = vma->vm_file;\n\tstruct kernfs_open_file *of = kernfs_of(file);\n\tint ret;\n\n\tif (!of->vm_ops)\n\t\treturn VM_FAULT_SIGBUS;\n\n\tif (!kernfs_get_active(of->kn))\n\t\treturn VM_FAULT_SIGBUS;\n\n\tret = VM_FAULT_SIGBUS;\n\tif (of->vm_ops->fault)\n\t\tret = of->vm_ops->fault(vma, vmf);\n\n\tkernfs_put_active(of->kn);\n\treturn ret;\n}"
  },
  {
    "function_name": "kernfs_vma_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
    "lines": "328-343",
    "snippet": "static void kernfs_vma_open(struct vm_area_struct *vma)\n{\n\tstruct file *file = vma->vm_file;\n\tstruct kernfs_open_file *of = kernfs_of(file);\n\n\tif (!of->vm_ops)\n\t\treturn;\n\n\tif (!kernfs_get_active(of->kn))\n\t\treturn;\n\n\tif (of->vm_ops->open)\n\t\tof->vm_ops->open(vma);\n\n\tkernfs_put_active(of->kn);\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/fsnotify.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_put_active",
          "args": [
            "of->kn"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_put_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "319-334",
          "snippet": "void kernfs_put_active(struct kernfs_node *kn)\n{\n\tstruct kernfs_root *root = kernfs_root(kn);\n\tint v;\n\n\tif (unlikely(!kn))\n\t\treturn;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_release(&kn->dep_map, 1, _RET_IP_);\n\tv = atomic_dec_return(&kn->active);\n\tif (likely(v != KN_DEACTIVATED_BIAS))\n\t\treturn;\n\n\twake_up_all(&root->deactivate_waitq);\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_put_active(struct kernfs_node *kn)\n{\n\tstruct kernfs_root *root = kernfs_root(kn);\n\tint v;\n\n\tif (unlikely(!kn))\n\t\treturn;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_release(&kn->dep_map, 1, _RET_IP_);\n\tv = atomic_dec_return(&kn->active);\n\tif (likely(v != KN_DEACTIVATED_BIAS))\n\t\treturn;\n\n\twake_up_all(&root->deactivate_waitq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "of->vm_ops->open",
          "args": [
            "vma"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_get_active",
          "args": [
            "of->kn"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_get_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "299-310",
          "snippet": "struct kernfs_node *kernfs_get_active(struct kernfs_node *kn)\n{\n\tif (unlikely(!kn))\n\t\treturn NULL;\n\n\tif (!atomic_inc_unless_negative(&kn->active))\n\t\treturn NULL;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_acquire_read(&kn->dep_map, 0, 1, _RET_IP_);\n\treturn kn;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstruct kernfs_node *kernfs_get_active(struct kernfs_node *kn)\n{\n\tif (unlikely(!kn))\n\t\treturn NULL;\n\n\tif (!atomic_inc_unless_negative(&kn->active))\n\t\treturn NULL;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_acquire_read(&kn->dep_map, 0, 1, _RET_IP_);\n\treturn kn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_of",
          "args": [
            "file"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_of",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
          "lines": "55-58",
          "snippet": "static struct kernfs_open_file *kernfs_of(struct file *file)\n{\n\treturn ((struct seq_file *)file->private_data)->private;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic struct kernfs_open_file *kernfs_of(struct file *file)\n{\n\treturn ((struct seq_file *)file->private_data)->private;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic void kernfs_vma_open(struct vm_area_struct *vma)\n{\n\tstruct file *file = vma->vm_file;\n\tstruct kernfs_open_file *of = kernfs_of(file);\n\n\tif (!of->vm_ops)\n\t\treturn;\n\n\tif (!kernfs_get_active(of->kn))\n\t\treturn;\n\n\tif (of->vm_ops->open)\n\t\tof->vm_ops->open(vma);\n\n\tkernfs_put_active(of->kn);\n}"
  },
  {
    "function_name": "kernfs_fop_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
    "lines": "270-326",
    "snippet": "static ssize_t kernfs_fop_write(struct file *file, const char __user *user_buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct kernfs_open_file *of = kernfs_of(file);\n\tconst struct kernfs_ops *ops;\n\tsize_t len;\n\tchar *buf;\n\n\tif (of->atomic_write_len) {\n\t\tlen = count;\n\t\tif (len > of->atomic_write_len)\n\t\t\treturn -E2BIG;\n\t} else {\n\t\tlen = min_t(size_t, count, PAGE_SIZE);\n\t}\n\n\tbuf = of->prealloc_buf;\n\tif (!buf)\n\t\tbuf = kmalloc(len + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * @of->mutex nests outside active ref and is used both to ensure that\n\t * the ops aren't called concurrently for the same open file, and\n\t * to provide exclusive access to ->prealloc_buf (when that exists).\n\t */\n\tmutex_lock(&of->mutex);\n\tif (!kernfs_get_active(of->kn)) {\n\t\tmutex_unlock(&of->mutex);\n\t\tlen = -ENODEV;\n\t\tgoto out_free;\n\t}\n\n\tif (copy_from_user(buf, user_buf, len)) {\n\t\tlen = -EFAULT;\n\t\tgoto out_unlock;\n\t}\n\tbuf[len] = '\\0';\t/* guarantee string termination */\n\n\tops = kernfs_ops(of->kn);\n\tif (ops->write)\n\t\tlen = ops->write(of, buf, len, *ppos);\n\telse\n\t\tlen = -EINVAL;\n\n\tif (len > 0)\n\t\t*ppos += len;\n\nout_unlock:\n\tkernfs_put_active(of->kn);\n\tmutex_unlock(&of->mutex);\nout_free:\n\tif (buf != of->prealloc_buf)\n\t\tkfree(buf);\n\treturn len;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/fsnotify.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&of->mutex"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_put_active",
          "args": [
            "of->kn"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_put_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "319-334",
          "snippet": "void kernfs_put_active(struct kernfs_node *kn)\n{\n\tstruct kernfs_root *root = kernfs_root(kn);\n\tint v;\n\n\tif (unlikely(!kn))\n\t\treturn;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_release(&kn->dep_map, 1, _RET_IP_);\n\tv = atomic_dec_return(&kn->active);\n\tif (likely(v != KN_DEACTIVATED_BIAS))\n\t\treturn;\n\n\twake_up_all(&root->deactivate_waitq);\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_put_active(struct kernfs_node *kn)\n{\n\tstruct kernfs_root *root = kernfs_root(kn);\n\tint v;\n\n\tif (unlikely(!kn))\n\t\treturn;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_release(&kn->dep_map, 1, _RET_IP_);\n\tv = atomic_dec_return(&kn->active);\n\tif (likely(v != KN_DEACTIVATED_BIAS))\n\t\treturn;\n\n\twake_up_all(&root->deactivate_waitq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->write",
          "args": [
            "of",
            "buf",
            "len",
            "*ppos"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_ops",
          "args": [
            "of->kn"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
          "lines": "64-69",
          "snippet": "static const struct kernfs_ops *kernfs_ops(struct kernfs_node *kn)\n{\n\tif (kn->flags & KERNFS_LOCKDEP)\n\t\tlockdep_assert_held(kn);\n\treturn kn->attr.ops;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic const struct kernfs_ops *kernfs_ops(struct kernfs_node *kn)\n{\n\tif (kn->flags & KERNFS_LOCKDEP)\n\t\tlockdep_assert_held(kn);\n\treturn kn->attr.ops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "buf",
            "user_buf",
            "len"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&of->mutex"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_get_active",
          "args": [
            "of->kn"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_get_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "299-310",
          "snippet": "struct kernfs_node *kernfs_get_active(struct kernfs_node *kn)\n{\n\tif (unlikely(!kn))\n\t\treturn NULL;\n\n\tif (!atomic_inc_unless_negative(&kn->active))\n\t\treturn NULL;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_acquire_read(&kn->dep_map, 0, 1, _RET_IP_);\n\treturn kn;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstruct kernfs_node *kernfs_get_active(struct kernfs_node *kn)\n{\n\tif (unlikely(!kn))\n\t\treturn NULL;\n\n\tif (!atomic_inc_unless_negative(&kn->active))\n\t\treturn NULL;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_acquire_read(&kn->dep_map, 0, 1, _RET_IP_);\n\treturn kn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&of->mutex"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "len + 1",
            "GFP_KERNEL"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "count",
            "PAGE_SIZE"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_of",
          "args": [
            "file"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_of",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
          "lines": "55-58",
          "snippet": "static struct kernfs_open_file *kernfs_of(struct file *file)\n{\n\treturn ((struct seq_file *)file->private_data)->private;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic struct kernfs_open_file *kernfs_of(struct file *file)\n{\n\treturn ((struct seq_file *)file->private_data)->private;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic ssize_t kernfs_fop_write(struct file *file, const char __user *user_buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct kernfs_open_file *of = kernfs_of(file);\n\tconst struct kernfs_ops *ops;\n\tsize_t len;\n\tchar *buf;\n\n\tif (of->atomic_write_len) {\n\t\tlen = count;\n\t\tif (len > of->atomic_write_len)\n\t\t\treturn -E2BIG;\n\t} else {\n\t\tlen = min_t(size_t, count, PAGE_SIZE);\n\t}\n\n\tbuf = of->prealloc_buf;\n\tif (!buf)\n\t\tbuf = kmalloc(len + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * @of->mutex nests outside active ref and is used both to ensure that\n\t * the ops aren't called concurrently for the same open file, and\n\t * to provide exclusive access to ->prealloc_buf (when that exists).\n\t */\n\tmutex_lock(&of->mutex);\n\tif (!kernfs_get_active(of->kn)) {\n\t\tmutex_unlock(&of->mutex);\n\t\tlen = -ENODEV;\n\t\tgoto out_free;\n\t}\n\n\tif (copy_from_user(buf, user_buf, len)) {\n\t\tlen = -EFAULT;\n\t\tgoto out_unlock;\n\t}\n\tbuf[len] = '\\0';\t/* guarantee string termination */\n\n\tops = kernfs_ops(of->kn);\n\tif (ops->write)\n\t\tlen = ops->write(of, buf, len, *ppos);\n\telse\n\t\tlen = -EINVAL;\n\n\tif (len > 0)\n\t\t*ppos += len;\n\nout_unlock:\n\tkernfs_put_active(of->kn);\n\tmutex_unlock(&of->mutex);\nout_free:\n\tif (buf != of->prealloc_buf)\n\t\tkfree(buf);\n\treturn len;\n}"
  },
  {
    "function_name": "kernfs_fop_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
    "lines": "243-252",
    "snippet": "static ssize_t kernfs_fop_read(struct file *file, char __user *user_buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct kernfs_open_file *of = kernfs_of(file);\n\n\tif (of->kn->flags & KERNFS_HAS_SEQ_SHOW)\n\t\treturn seq_read(file, user_buf, count, ppos);\n\telse\n\t\treturn kernfs_file_direct_read(of, user_buf, count, ppos);\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/fsnotify.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_file_direct_read",
          "args": [
            "of",
            "user_buf",
            "count",
            "ppos"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_file_direct_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
          "lines": "184-234",
          "snippet": "static ssize_t kernfs_file_direct_read(struct kernfs_open_file *of,\n\t\t\t\t       char __user *user_buf, size_t count,\n\t\t\t\t       loff_t *ppos)\n{\n\tssize_t len = min_t(size_t, count, PAGE_SIZE);\n\tconst struct kernfs_ops *ops;\n\tchar *buf;\n\n\tbuf = of->prealloc_buf;\n\tif (!buf)\n\t\tbuf = kmalloc(len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * @of->mutex nests outside active ref and is used both to ensure that\n\t * the ops aren't called concurrently for the same open file, and\n\t * to provide exclusive access to ->prealloc_buf (when that exists).\n\t */\n\tmutex_lock(&of->mutex);\n\tif (!kernfs_get_active(of->kn)) {\n\t\tlen = -ENODEV;\n\t\tmutex_unlock(&of->mutex);\n\t\tgoto out_free;\n\t}\n\n\tof->event = atomic_read(&of->kn->attr.open->event);\n\tops = kernfs_ops(of->kn);\n\tif (ops->read)\n\t\tlen = ops->read(of, buf, len, *ppos);\n\telse\n\t\tlen = -EINVAL;\n\n\tif (len < 0)\n\t\tgoto out_unlock;\n\n\tif (copy_to_user(user_buf, buf, len)) {\n\t\tlen = -EFAULT;\n\t\tgoto out_unlock;\n\t}\n\n\t*ppos += len;\n\n out_unlock:\n\tkernfs_put_active(of->kn);\n\tmutex_unlock(&of->mutex);\n out_free:\n\tif (buf != of->prealloc_buf)\n\t\tkfree(buf);\n\treturn len;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic ssize_t kernfs_file_direct_read(struct kernfs_open_file *of,\n\t\t\t\t       char __user *user_buf, size_t count,\n\t\t\t\t       loff_t *ppos)\n{\n\tssize_t len = min_t(size_t, count, PAGE_SIZE);\n\tconst struct kernfs_ops *ops;\n\tchar *buf;\n\n\tbuf = of->prealloc_buf;\n\tif (!buf)\n\t\tbuf = kmalloc(len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * @of->mutex nests outside active ref and is used both to ensure that\n\t * the ops aren't called concurrently for the same open file, and\n\t * to provide exclusive access to ->prealloc_buf (when that exists).\n\t */\n\tmutex_lock(&of->mutex);\n\tif (!kernfs_get_active(of->kn)) {\n\t\tlen = -ENODEV;\n\t\tmutex_unlock(&of->mutex);\n\t\tgoto out_free;\n\t}\n\n\tof->event = atomic_read(&of->kn->attr.open->event);\n\tops = kernfs_ops(of->kn);\n\tif (ops->read)\n\t\tlen = ops->read(of, buf, len, *ppos);\n\telse\n\t\tlen = -EINVAL;\n\n\tif (len < 0)\n\t\tgoto out_unlock;\n\n\tif (copy_to_user(user_buf, buf, len)) {\n\t\tlen = -EFAULT;\n\t\tgoto out_unlock;\n\t}\n\n\t*ppos += len;\n\n out_unlock:\n\tkernfs_put_active(of->kn);\n\tmutex_unlock(&of->mutex);\n out_free:\n\tif (buf != of->prealloc_buf)\n\t\tkfree(buf);\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_read",
          "args": [
            "file",
            "user_buf",
            "count",
            "ppos"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "seq_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "158-298",
          "snippet": "ssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)\n{\n\tstruct seq_file *m = file->private_data;\n\tsize_t copied = 0;\n\tloff_t pos;\n\tsize_t n;\n\tvoid *p;\n\tint err = 0;\n\n\tmutex_lock(&m->lock);\n\n\t/*\n\t * seq_file->op->..m_start/m_stop/m_next may do special actions\n\t * or optimisations based on the file->f_version, so we want to\n\t * pass the file->f_version to those methods.\n\t *\n\t * seq_file->version is just copy of f_version, and seq_file\n\t * methods can treat it simply as file version.\n\t * It is copied in first and copied out after all operations.\n\t * It is convenient to have it as  part of structure to avoid the\n\t * need of passing another argument to all the seq_file methods.\n\t */\n\tm->version = file->f_version;\n\n\t/* Don't assume *ppos is where we left it */\n\tif (unlikely(*ppos != m->read_pos)) {\n\t\twhile ((err = traverse(m, *ppos)) == -EAGAIN)\n\t\t\t;\n\t\tif (err) {\n\t\t\t/* With prejudice... */\n\t\t\tm->read_pos = 0;\n\t\t\tm->version = 0;\n\t\t\tm->index = 0;\n\t\t\tm->count = 0;\n\t\t\tgoto Done;\n\t\t} else {\n\t\t\tm->read_pos = *ppos;\n\t\t}\n\t}\n\n\t/* grab buffer if we didn't have one */\n\tif (!m->buf) {\n\t\tm->buf = seq_buf_alloc(m->size = PAGE_SIZE);\n\t\tif (!m->buf)\n\t\t\tgoto Enomem;\n\t}\n\t/* if not empty - flush it first */\n\tif (m->count) {\n\t\tn = min(m->count, size);\n\t\terr = copy_to_user(buf, m->buf + m->from, n);\n\t\tif (err)\n\t\t\tgoto Efault;\n\t\tm->count -= n;\n\t\tm->from += n;\n\t\tsize -= n;\n\t\tbuf += n;\n\t\tcopied += n;\n\t\tif (!m->count)\n\t\t\tm->index++;\n\t\tif (!size)\n\t\t\tgoto Done;\n\t}\n\t/* we need at least one record in buffer */\n\tpos = m->index;\n\tp = m->op->start(m, &pos);\n\twhile (1) {\n\t\terr = PTR_ERR(p);\n\t\tif (!p || IS_ERR(p))\n\t\t\tbreak;\n\t\terr = m->op->show(m, p);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t\tif (unlikely(err))\n\t\t\tm->count = 0;\n\t\tif (unlikely(!m->count)) {\n\t\t\tp = m->op->next(m, p, &pos);\n\t\t\tm->index = pos;\n\t\t\tcontinue;\n\t\t}\n\t\tif (m->count < m->size)\n\t\t\tgoto Fill;\n\t\tm->op->stop(m, p);\n\t\tkvfree(m->buf);\n\t\tm->count = 0;\n\t\tm->buf = seq_buf_alloc(m->size <<= 1);\n\t\tif (!m->buf)\n\t\t\tgoto Enomem;\n\t\tm->version = 0;\n\t\tpos = m->index;\n\t\tp = m->op->start(m, &pos);\n\t}\n\tm->op->stop(m, p);\n\tm->count = 0;\n\tgoto Done;\nFill:\n\t/* they want more? let's try to get some more */\n\twhile (m->count < size) {\n\t\tsize_t offs = m->count;\n\t\tloff_t next = pos;\n\t\tp = m->op->next(m, p, &next);\n\t\tif (!p || IS_ERR(p)) {\n\t\t\terr = PTR_ERR(p);\n\t\t\tbreak;\n\t\t}\n\t\terr = m->op->show(m, p);\n\t\tif (seq_has_overflowed(m) || err) {\n\t\t\tm->count = offs;\n\t\t\tif (likely(err <= 0))\n\t\t\t\tbreak;\n\t\t}\n\t\tpos = next;\n\t}\n\tm->op->stop(m, p);\n\tn = min(m->count, size);\n\terr = copy_to_user(buf, m->buf, n);\n\tif (err)\n\t\tgoto Efault;\n\tcopied += n;\n\tm->count -= n;\n\tif (m->count)\n\t\tm->from = n;\n\telse\n\t\tpos++;\n\tm->index = pos;\nDone:\n\tif (!copied)\n\t\tcopied = err;\n\telse {\n\t\t*ppos += copied;\n\t\tm->read_pos += copied;\n\t}\n\tfile->f_version = m->version;\n\tmutex_unlock(&m->lock);\n\treturn copied;\nEnomem:\n\terr = -ENOMEM;\n\tgoto Done;\nEfault:\n\terr = -EFAULT;\n\tgoto Done;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)\n{\n\tstruct seq_file *m = file->private_data;\n\tsize_t copied = 0;\n\tloff_t pos;\n\tsize_t n;\n\tvoid *p;\n\tint err = 0;\n\n\tmutex_lock(&m->lock);\n\n\t/*\n\t * seq_file->op->..m_start/m_stop/m_next may do special actions\n\t * or optimisations based on the file->f_version, so we want to\n\t * pass the file->f_version to those methods.\n\t *\n\t * seq_file->version is just copy of f_version, and seq_file\n\t * methods can treat it simply as file version.\n\t * It is copied in first and copied out after all operations.\n\t * It is convenient to have it as  part of structure to avoid the\n\t * need of passing another argument to all the seq_file methods.\n\t */\n\tm->version = file->f_version;\n\n\t/* Don't assume *ppos is where we left it */\n\tif (unlikely(*ppos != m->read_pos)) {\n\t\twhile ((err = traverse(m, *ppos)) == -EAGAIN)\n\t\t\t;\n\t\tif (err) {\n\t\t\t/* With prejudice... */\n\t\t\tm->read_pos = 0;\n\t\t\tm->version = 0;\n\t\t\tm->index = 0;\n\t\t\tm->count = 0;\n\t\t\tgoto Done;\n\t\t} else {\n\t\t\tm->read_pos = *ppos;\n\t\t}\n\t}\n\n\t/* grab buffer if we didn't have one */\n\tif (!m->buf) {\n\t\tm->buf = seq_buf_alloc(m->size = PAGE_SIZE);\n\t\tif (!m->buf)\n\t\t\tgoto Enomem;\n\t}\n\t/* if not empty - flush it first */\n\tif (m->count) {\n\t\tn = min(m->count, size);\n\t\terr = copy_to_user(buf, m->buf + m->from, n);\n\t\tif (err)\n\t\t\tgoto Efault;\n\t\tm->count -= n;\n\t\tm->from += n;\n\t\tsize -= n;\n\t\tbuf += n;\n\t\tcopied += n;\n\t\tif (!m->count)\n\t\t\tm->index++;\n\t\tif (!size)\n\t\t\tgoto Done;\n\t}\n\t/* we need at least one record in buffer */\n\tpos = m->index;\n\tp = m->op->start(m, &pos);\n\twhile (1) {\n\t\terr = PTR_ERR(p);\n\t\tif (!p || IS_ERR(p))\n\t\t\tbreak;\n\t\terr = m->op->show(m, p);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t\tif (unlikely(err))\n\t\t\tm->count = 0;\n\t\tif (unlikely(!m->count)) {\n\t\t\tp = m->op->next(m, p, &pos);\n\t\t\tm->index = pos;\n\t\t\tcontinue;\n\t\t}\n\t\tif (m->count < m->size)\n\t\t\tgoto Fill;\n\t\tm->op->stop(m, p);\n\t\tkvfree(m->buf);\n\t\tm->count = 0;\n\t\tm->buf = seq_buf_alloc(m->size <<= 1);\n\t\tif (!m->buf)\n\t\t\tgoto Enomem;\n\t\tm->version = 0;\n\t\tpos = m->index;\n\t\tp = m->op->start(m, &pos);\n\t}\n\tm->op->stop(m, p);\n\tm->count = 0;\n\tgoto Done;\nFill:\n\t/* they want more? let's try to get some more */\n\twhile (m->count < size) {\n\t\tsize_t offs = m->count;\n\t\tloff_t next = pos;\n\t\tp = m->op->next(m, p, &next);\n\t\tif (!p || IS_ERR(p)) {\n\t\t\terr = PTR_ERR(p);\n\t\t\tbreak;\n\t\t}\n\t\terr = m->op->show(m, p);\n\t\tif (seq_has_overflowed(m) || err) {\n\t\t\tm->count = offs;\n\t\t\tif (likely(err <= 0))\n\t\t\t\tbreak;\n\t\t}\n\t\tpos = next;\n\t}\n\tm->op->stop(m, p);\n\tn = min(m->count, size);\n\terr = copy_to_user(buf, m->buf, n);\n\tif (err)\n\t\tgoto Efault;\n\tcopied += n;\n\tm->count -= n;\n\tif (m->count)\n\t\tm->from = n;\n\telse\n\t\tpos++;\n\tm->index = pos;\nDone:\n\tif (!copied)\n\t\tcopied = err;\n\telse {\n\t\t*ppos += copied;\n\t\tm->read_pos += copied;\n\t}\n\tfile->f_version = m->version;\n\tmutex_unlock(&m->lock);\n\treturn copied;\nEnomem:\n\terr = -ENOMEM;\n\tgoto Done;\nEfault:\n\terr = -EFAULT;\n\tgoto Done;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_of",
          "args": [
            "file"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_of",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
          "lines": "55-58",
          "snippet": "static struct kernfs_open_file *kernfs_of(struct file *file)\n{\n\treturn ((struct seq_file *)file->private_data)->private;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic struct kernfs_open_file *kernfs_of(struct file *file)\n{\n\treturn ((struct seq_file *)file->private_data)->private;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic ssize_t kernfs_fop_read(struct file *file, char __user *user_buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct kernfs_open_file *of = kernfs_of(file);\n\n\tif (of->kn->flags & KERNFS_HAS_SEQ_SHOW)\n\t\treturn seq_read(file, user_buf, count, ppos);\n\telse\n\t\treturn kernfs_file_direct_read(of, user_buf, count, ppos);\n}"
  },
  {
    "function_name": "kernfs_file_direct_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
    "lines": "184-234",
    "snippet": "static ssize_t kernfs_file_direct_read(struct kernfs_open_file *of,\n\t\t\t\t       char __user *user_buf, size_t count,\n\t\t\t\t       loff_t *ppos)\n{\n\tssize_t len = min_t(size_t, count, PAGE_SIZE);\n\tconst struct kernfs_ops *ops;\n\tchar *buf;\n\n\tbuf = of->prealloc_buf;\n\tif (!buf)\n\t\tbuf = kmalloc(len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * @of->mutex nests outside active ref and is used both to ensure that\n\t * the ops aren't called concurrently for the same open file, and\n\t * to provide exclusive access to ->prealloc_buf (when that exists).\n\t */\n\tmutex_lock(&of->mutex);\n\tif (!kernfs_get_active(of->kn)) {\n\t\tlen = -ENODEV;\n\t\tmutex_unlock(&of->mutex);\n\t\tgoto out_free;\n\t}\n\n\tof->event = atomic_read(&of->kn->attr.open->event);\n\tops = kernfs_ops(of->kn);\n\tif (ops->read)\n\t\tlen = ops->read(of, buf, len, *ppos);\n\telse\n\t\tlen = -EINVAL;\n\n\tif (len < 0)\n\t\tgoto out_unlock;\n\n\tif (copy_to_user(user_buf, buf, len)) {\n\t\tlen = -EFAULT;\n\t\tgoto out_unlock;\n\t}\n\n\t*ppos += len;\n\n out_unlock:\n\tkernfs_put_active(of->kn);\n\tmutex_unlock(&of->mutex);\n out_free:\n\tif (buf != of->prealloc_buf)\n\t\tkfree(buf);\n\treturn len;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/fsnotify.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&of->mutex"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_put_active",
          "args": [
            "of->kn"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_put_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "319-334",
          "snippet": "void kernfs_put_active(struct kernfs_node *kn)\n{\n\tstruct kernfs_root *root = kernfs_root(kn);\n\tint v;\n\n\tif (unlikely(!kn))\n\t\treturn;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_release(&kn->dep_map, 1, _RET_IP_);\n\tv = atomic_dec_return(&kn->active);\n\tif (likely(v != KN_DEACTIVATED_BIAS))\n\t\treturn;\n\n\twake_up_all(&root->deactivate_waitq);\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_put_active(struct kernfs_node *kn)\n{\n\tstruct kernfs_root *root = kernfs_root(kn);\n\tint v;\n\n\tif (unlikely(!kn))\n\t\treturn;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_release(&kn->dep_map, 1, _RET_IP_);\n\tv = atomic_dec_return(&kn->active);\n\tif (likely(v != KN_DEACTIVATED_BIAS))\n\t\treturn;\n\n\twake_up_all(&root->deactivate_waitq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "user_buf",
            "buf",
            "len"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->read",
          "args": [
            "of",
            "buf",
            "len",
            "*ppos"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_ops",
          "args": [
            "of->kn"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
          "lines": "64-69",
          "snippet": "static const struct kernfs_ops *kernfs_ops(struct kernfs_node *kn)\n{\n\tif (kn->flags & KERNFS_LOCKDEP)\n\t\tlockdep_assert_held(kn);\n\treturn kn->attr.ops;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic const struct kernfs_ops *kernfs_ops(struct kernfs_node *kn)\n{\n\tif (kn->flags & KERNFS_LOCKDEP)\n\t\tlockdep_assert_held(kn);\n\treturn kn->attr.ops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&of->kn->attr.open->event"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&of->mutex"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_get_active",
          "args": [
            "of->kn"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_get_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "299-310",
          "snippet": "struct kernfs_node *kernfs_get_active(struct kernfs_node *kn)\n{\n\tif (unlikely(!kn))\n\t\treturn NULL;\n\n\tif (!atomic_inc_unless_negative(&kn->active))\n\t\treturn NULL;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_acquire_read(&kn->dep_map, 0, 1, _RET_IP_);\n\treturn kn;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstruct kernfs_node *kernfs_get_active(struct kernfs_node *kn)\n{\n\tif (unlikely(!kn))\n\t\treturn NULL;\n\n\tif (!atomic_inc_unless_negative(&kn->active))\n\t\treturn NULL;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_acquire_read(&kn->dep_map, 0, 1, _RET_IP_);\n\treturn kn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&of->mutex"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "len",
            "GFP_KERNEL"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "count",
            "PAGE_SIZE"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic ssize_t kernfs_file_direct_read(struct kernfs_open_file *of,\n\t\t\t\t       char __user *user_buf, size_t count,\n\t\t\t\t       loff_t *ppos)\n{\n\tssize_t len = min_t(size_t, count, PAGE_SIZE);\n\tconst struct kernfs_ops *ops;\n\tchar *buf;\n\n\tbuf = of->prealloc_buf;\n\tif (!buf)\n\t\tbuf = kmalloc(len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * @of->mutex nests outside active ref and is used both to ensure that\n\t * the ops aren't called concurrently for the same open file, and\n\t * to provide exclusive access to ->prealloc_buf (when that exists).\n\t */\n\tmutex_lock(&of->mutex);\n\tif (!kernfs_get_active(of->kn)) {\n\t\tlen = -ENODEV;\n\t\tmutex_unlock(&of->mutex);\n\t\tgoto out_free;\n\t}\n\n\tof->event = atomic_read(&of->kn->attr.open->event);\n\tops = kernfs_ops(of->kn);\n\tif (ops->read)\n\t\tlen = ops->read(of, buf, len, *ppos);\n\telse\n\t\tlen = -EINVAL;\n\n\tif (len < 0)\n\t\tgoto out_unlock;\n\n\tif (copy_to_user(user_buf, buf, len)) {\n\t\tlen = -EFAULT;\n\t\tgoto out_unlock;\n\t}\n\n\t*ppos += len;\n\n out_unlock:\n\tkernfs_put_active(of->kn);\n\tmutex_unlock(&of->mutex);\n out_free:\n\tif (buf != of->prealloc_buf)\n\t\tkfree(buf);\n\treturn len;\n}"
  },
  {
    "function_name": "kernfs_seq_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
    "lines": "162-169",
    "snippet": "static int kernfs_seq_show(struct seq_file *sf, void *v)\n{\n\tstruct kernfs_open_file *of = sf->private;\n\n\tof->event = atomic_read(&of->kn->attr.open->event);\n\n\treturn of->kn->attr.ops->seq_show(sf, v);\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/fsnotify.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "of->kn->attr.ops->seq_show",
          "args": [
            "sf",
            "v"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "seq_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/fd.c",
          "lines": "18-62",
          "snippet": "static int seq_show(struct seq_file *m, void *v)\n{\n\tstruct files_struct *files = NULL;\n\tint f_flags = 0, ret = -ENOENT;\n\tstruct file *file = NULL;\n\tstruct task_struct *task;\n\n\ttask = get_proc_task(m->private);\n\tif (!task)\n\t\treturn -ENOENT;\n\n\tfiles = get_files_struct(task);\n\tput_task_struct(task);\n\n\tif (files) {\n\t\tint fd = proc_fd(m->private);\n\n\t\tspin_lock(&files->file_lock);\n\t\tfile = fcheck_files(files, fd);\n\t\tif (file) {\n\t\t\tstruct fdtable *fdt = files_fdtable(files);\n\n\t\t\tf_flags = file->f_flags;\n\t\t\tif (close_on_exec(fd, fdt))\n\t\t\t\tf_flags |= O_CLOEXEC;\n\n\t\t\tget_file(file);\n\t\t\tret = 0;\n\t\t}\n\t\tspin_unlock(&files->file_lock);\n\t\tput_files_struct(files);\n\t}\n\n\tif (!ret) {\n\t\tseq_printf(m, \"pos:\\t%lli\\nflags:\\t0%o\\nmnt_id:\\t%i\\n\",\n\t\t\t   (long long)file->f_pos, f_flags,\n\t\t\t   real_mount(file->f_path.mnt)->mnt_id);\n\t\tif (file->f_op->show_fdinfo)\n\t\t\tfile->f_op->show_fdinfo(m, file);\n\t\tret = seq_has_overflowed(m);\n\t\tfput(file);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include \"../mount.h\"",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/security.h>",
            "#include <linux/pid.h>",
            "#include <linux/namei.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/path.h>",
            "#include <linux/dcache.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include \"../mount.h\"\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/security.h>\n#include <linux/pid.h>\n#include <linux/namei.h>\n#include <linux/fdtable.h>\n#include <linux/path.h>\n#include <linux/dcache.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n\nstatic int seq_show(struct seq_file *m, void *v)\n{\n\tstruct files_struct *files = NULL;\n\tint f_flags = 0, ret = -ENOENT;\n\tstruct file *file = NULL;\n\tstruct task_struct *task;\n\n\ttask = get_proc_task(m->private);\n\tif (!task)\n\t\treturn -ENOENT;\n\n\tfiles = get_files_struct(task);\n\tput_task_struct(task);\n\n\tif (files) {\n\t\tint fd = proc_fd(m->private);\n\n\t\tspin_lock(&files->file_lock);\n\t\tfile = fcheck_files(files, fd);\n\t\tif (file) {\n\t\t\tstruct fdtable *fdt = files_fdtable(files);\n\n\t\t\tf_flags = file->f_flags;\n\t\t\tif (close_on_exec(fd, fdt))\n\t\t\t\tf_flags |= O_CLOEXEC;\n\n\t\t\tget_file(file);\n\t\t\tret = 0;\n\t\t}\n\t\tspin_unlock(&files->file_lock);\n\t\tput_files_struct(files);\n\t}\n\n\tif (!ret) {\n\t\tseq_printf(m, \"pos:\\t%lli\\nflags:\\t0%o\\nmnt_id:\\t%i\\n\",\n\t\t\t   (long long)file->f_pos, f_flags,\n\t\t\t   real_mount(file->f_path.mnt)->mnt_id);\n\t\tif (file->f_op->show_fdinfo)\n\t\t\tfile->f_op->show_fdinfo(m, file);\n\t\tret = seq_has_overflowed(m);\n\t\tfput(file);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&of->kn->attr.open->event"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic int kernfs_seq_show(struct seq_file *sf, void *v)\n{\n\tstruct kernfs_open_file *of = sf->private;\n\n\tof->event = atomic_read(&of->kn->attr.open->event);\n\n\treturn of->kn->attr.ops->seq_show(sf, v);\n}"
  },
  {
    "function_name": "kernfs_seq_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
    "lines": "153-160",
    "snippet": "static void kernfs_seq_stop(struct seq_file *sf, void *v)\n{\n\tstruct kernfs_open_file *of = sf->private;\n\n\tif (v != ERR_PTR(-ENODEV))\n\t\tkernfs_seq_stop_active(sf, v);\n\tmutex_unlock(&of->mutex);\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/fsnotify.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&of->mutex"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_seq_stop_active",
          "args": [
            "sf",
            "v"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_seq_stop_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
          "lines": "93-101",
          "snippet": "static void kernfs_seq_stop_active(struct seq_file *sf, void *v)\n{\n\tstruct kernfs_open_file *of = sf->private;\n\tconst struct kernfs_ops *ops = kernfs_ops(of->kn);\n\n\tif (ops->seq_stop)\n\t\tops->seq_stop(sf, v);\n\tkernfs_put_active(of->kn);\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic void kernfs_seq_stop_active(struct seq_file *sf, void *v)\n{\n\tstruct kernfs_open_file *of = sf->private;\n\tconst struct kernfs_ops *ops = kernfs_ops(of->kn);\n\n\tif (ops->seq_stop)\n\t\tops->seq_stop(sf, v);\n\tkernfs_put_active(of->kn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENODEV"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic void kernfs_seq_stop(struct seq_file *sf, void *v)\n{\n\tstruct kernfs_open_file *of = sf->private;\n\n\tif (v != ERR_PTR(-ENODEV))\n\t\tkernfs_seq_stop_active(sf, v);\n\tmutex_unlock(&of->mutex);\n}"
  },
  {
    "function_name": "kernfs_seq_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
    "lines": "132-151",
    "snippet": "static void *kernfs_seq_next(struct seq_file *sf, void *v, loff_t *ppos)\n{\n\tstruct kernfs_open_file *of = sf->private;\n\tconst struct kernfs_ops *ops = kernfs_ops(of->kn);\n\n\tif (ops->seq_next) {\n\t\tvoid *next = ops->seq_next(sf, v, ppos);\n\t\t/* see the comment above kernfs_seq_stop_active() */\n\t\tif (next == ERR_PTR(-ENODEV))\n\t\t\tkernfs_seq_stop_active(sf, next);\n\t\treturn next;\n\t} else {\n\t\t/*\n\t\t * The same behavior and code as single_open(), always\n\t\t * terminate after the initial read.\n\t\t */\n\t\t++*ppos;\n\t\treturn NULL;\n\t}\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/fsnotify.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_seq_stop_active",
          "args": [
            "sf",
            "next"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_seq_stop_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
          "lines": "93-101",
          "snippet": "static void kernfs_seq_stop_active(struct seq_file *sf, void *v)\n{\n\tstruct kernfs_open_file *of = sf->private;\n\tconst struct kernfs_ops *ops = kernfs_ops(of->kn);\n\n\tif (ops->seq_stop)\n\t\tops->seq_stop(sf, v);\n\tkernfs_put_active(of->kn);\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic void kernfs_seq_stop_active(struct seq_file *sf, void *v)\n{\n\tstruct kernfs_open_file *of = sf->private;\n\tconst struct kernfs_ops *ops = kernfs_ops(of->kn);\n\n\tif (ops->seq_stop)\n\t\tops->seq_stop(sf, v);\n\tkernfs_put_active(of->kn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENODEV"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->seq_next",
          "args": [
            "sf",
            "v",
            "ppos"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_ops",
          "args": [
            "of->kn"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
          "lines": "64-69",
          "snippet": "static const struct kernfs_ops *kernfs_ops(struct kernfs_node *kn)\n{\n\tif (kn->flags & KERNFS_LOCKDEP)\n\t\tlockdep_assert_held(kn);\n\treturn kn->attr.ops;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic const struct kernfs_ops *kernfs_ops(struct kernfs_node *kn)\n{\n\tif (kn->flags & KERNFS_LOCKDEP)\n\t\tlockdep_assert_held(kn);\n\treturn kn->attr.ops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic void *kernfs_seq_next(struct seq_file *sf, void *v, loff_t *ppos)\n{\n\tstruct kernfs_open_file *of = sf->private;\n\tconst struct kernfs_ops *ops = kernfs_ops(of->kn);\n\n\tif (ops->seq_next) {\n\t\tvoid *next = ops->seq_next(sf, v, ppos);\n\t\t/* see the comment above kernfs_seq_stop_active() */\n\t\tif (next == ERR_PTR(-ENODEV))\n\t\t\tkernfs_seq_stop_active(sf, next);\n\t\treturn next;\n\t} else {\n\t\t/*\n\t\t * The same behavior and code as single_open(), always\n\t\t * terminate after the initial read.\n\t\t */\n\t\t++*ppos;\n\t\treturn NULL;\n\t}\n}"
  },
  {
    "function_name": "kernfs_seq_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
    "lines": "103-130",
    "snippet": "static void *kernfs_seq_start(struct seq_file *sf, loff_t *ppos)\n{\n\tstruct kernfs_open_file *of = sf->private;\n\tconst struct kernfs_ops *ops;\n\n\t/*\n\t * @of->mutex nests outside active ref and is primarily to ensure that\n\t * the ops aren't called concurrently for the same open file.\n\t */\n\tmutex_lock(&of->mutex);\n\tif (!kernfs_get_active(of->kn))\n\t\treturn ERR_PTR(-ENODEV);\n\n\tops = kernfs_ops(of->kn);\n\tif (ops->seq_start) {\n\t\tvoid *next = ops->seq_start(sf, ppos);\n\t\t/* see the comment above kernfs_seq_stop_active() */\n\t\tif (next == ERR_PTR(-ENODEV))\n\t\t\tkernfs_seq_stop_active(sf, next);\n\t\treturn next;\n\t} else {\n\t\t/*\n\t\t * The same behavior and code as single_open().  Returns\n\t\t * !NULL if pos is at the beginning; otherwise, NULL.\n\t\t */\n\t\treturn NULL + !*ppos;\n\t}\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/fsnotify.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_seq_stop_active",
          "args": [
            "sf",
            "next"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_seq_stop_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
          "lines": "93-101",
          "snippet": "static void kernfs_seq_stop_active(struct seq_file *sf, void *v)\n{\n\tstruct kernfs_open_file *of = sf->private;\n\tconst struct kernfs_ops *ops = kernfs_ops(of->kn);\n\n\tif (ops->seq_stop)\n\t\tops->seq_stop(sf, v);\n\tkernfs_put_active(of->kn);\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic void kernfs_seq_stop_active(struct seq_file *sf, void *v)\n{\n\tstruct kernfs_open_file *of = sf->private;\n\tconst struct kernfs_ops *ops = kernfs_ops(of->kn);\n\n\tif (ops->seq_stop)\n\t\tops->seq_stop(sf, v);\n\tkernfs_put_active(of->kn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENODEV"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->seq_start",
          "args": [
            "sf",
            "ppos"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_ops",
          "args": [
            "of->kn"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
          "lines": "64-69",
          "snippet": "static const struct kernfs_ops *kernfs_ops(struct kernfs_node *kn)\n{\n\tif (kn->flags & KERNFS_LOCKDEP)\n\t\tlockdep_assert_held(kn);\n\treturn kn->attr.ops;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic const struct kernfs_ops *kernfs_ops(struct kernfs_node *kn)\n{\n\tif (kn->flags & KERNFS_LOCKDEP)\n\t\tlockdep_assert_held(kn);\n\treturn kn->attr.ops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENODEV"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_get_active",
          "args": [
            "of->kn"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_get_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "299-310",
          "snippet": "struct kernfs_node *kernfs_get_active(struct kernfs_node *kn)\n{\n\tif (unlikely(!kn))\n\t\treturn NULL;\n\n\tif (!atomic_inc_unless_negative(&kn->active))\n\t\treturn NULL;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_acquire_read(&kn->dep_map, 0, 1, _RET_IP_);\n\treturn kn;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nstruct kernfs_node *kernfs_get_active(struct kernfs_node *kn)\n{\n\tif (unlikely(!kn))\n\t\treturn NULL;\n\n\tif (!atomic_inc_unless_negative(&kn->active))\n\t\treturn NULL;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_acquire_read(&kn->dep_map, 0, 1, _RET_IP_);\n\treturn kn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&of->mutex"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic void *kernfs_seq_start(struct seq_file *sf, loff_t *ppos)\n{\n\tstruct kernfs_open_file *of = sf->private;\n\tconst struct kernfs_ops *ops;\n\n\t/*\n\t * @of->mutex nests outside active ref and is primarily to ensure that\n\t * the ops aren't called concurrently for the same open file.\n\t */\n\tmutex_lock(&of->mutex);\n\tif (!kernfs_get_active(of->kn))\n\t\treturn ERR_PTR(-ENODEV);\n\n\tops = kernfs_ops(of->kn);\n\tif (ops->seq_start) {\n\t\tvoid *next = ops->seq_start(sf, ppos);\n\t\t/* see the comment above kernfs_seq_stop_active() */\n\t\tif (next == ERR_PTR(-ENODEV))\n\t\t\tkernfs_seq_stop_active(sf, next);\n\t\treturn next;\n\t} else {\n\t\t/*\n\t\t * The same behavior and code as single_open().  Returns\n\t\t * !NULL if pos is at the beginning; otherwise, NULL.\n\t\t */\n\t\treturn NULL + !*ppos;\n\t}\n}"
  },
  {
    "function_name": "kernfs_seq_stop_active",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
    "lines": "93-101",
    "snippet": "static void kernfs_seq_stop_active(struct seq_file *sf, void *v)\n{\n\tstruct kernfs_open_file *of = sf->private;\n\tconst struct kernfs_ops *ops = kernfs_ops(of->kn);\n\n\tif (ops->seq_stop)\n\t\tops->seq_stop(sf, v);\n\tkernfs_put_active(of->kn);\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/fsnotify.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernfs_put_active",
          "args": [
            "of->kn"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_put_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/dir.c",
          "lines": "319-334",
          "snippet": "void kernfs_put_active(struct kernfs_node *kn)\n{\n\tstruct kernfs_root *root = kernfs_root(kn);\n\tint v;\n\n\tif (unlikely(!kn))\n\t\treturn;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_release(&kn->dep_map, 1, _RET_IP_);\n\tv = atomic_dec_return(&kn->active);\n\tif (likely(v != KN_DEACTIVATED_BIAS))\n\t\treturn;\n\n\twake_up_all(&root->deactivate_waitq);\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n\nvoid kernfs_put_active(struct kernfs_node *kn)\n{\n\tstruct kernfs_root *root = kernfs_root(kn);\n\tint v;\n\n\tif (unlikely(!kn))\n\t\treturn;\n\n\tif (kernfs_lockdep(kn))\n\t\trwsem_release(&kn->dep_map, 1, _RET_IP_);\n\tv = atomic_dec_return(&kn->active);\n\tif (likely(v != KN_DEACTIVATED_BIAS))\n\t\treturn;\n\n\twake_up_all(&root->deactivate_waitq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->seq_stop",
          "args": [
            "sf",
            "v"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_ops",
          "args": [
            "of->kn"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "kernfs_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
          "lines": "64-69",
          "snippet": "static const struct kernfs_ops *kernfs_ops(struct kernfs_node *kn)\n{\n\tif (kn->flags & KERNFS_LOCKDEP)\n\t\tlockdep_assert_held(kn);\n\treturn kn->attr.ops;\n}",
          "includes": [
            "#include \"kernfs-internal.h\"",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic const struct kernfs_ops *kernfs_ops(struct kernfs_node *kn)\n{\n\tif (kn->flags & KERNFS_LOCKDEP)\n\t\tlockdep_assert_held(kn);\n\treturn kn->attr.ops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic void kernfs_seq_stop_active(struct seq_file *sf, void *v)\n{\n\tstruct kernfs_open_file *of = sf->private;\n\tconst struct kernfs_ops *ops = kernfs_ops(of->kn);\n\n\tif (ops->seq_stop)\n\t\tops->seq_stop(sf, v);\n\tkernfs_put_active(of->kn);\n}"
  },
  {
    "function_name": "kernfs_ops",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
    "lines": "64-69",
    "snippet": "static const struct kernfs_ops *kernfs_ops(struct kernfs_node *kn)\n{\n\tif (kn->flags & KERNFS_LOCKDEP)\n\t\tlockdep_assert_held(kn);\n\treturn kn->attr.ops;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/fsnotify.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "kn"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic const struct kernfs_ops *kernfs_ops(struct kernfs_node *kn)\n{\n\tif (kn->flags & KERNFS_LOCKDEP)\n\t\tlockdep_assert_held(kn);\n\treturn kn->attr.ops;\n}"
  },
  {
    "function_name": "kernfs_of",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/kernfs/file.c",
    "lines": "55-58",
    "snippet": "static struct kernfs_open_file *kernfs_of(struct file *file)\n{\n\treturn ((struct seq_file *)file->private_data)->private;\n}",
    "includes": [
      "#include \"kernfs-internal.h\"",
      "#include <linux/fsnotify.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"kernfs-internal.h\"\n#include <linux/fsnotify.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/fs.h>\n\nstatic struct kernfs_open_file *kernfs_of(struct file *file)\n{\n\treturn ((struct seq_file *)file->private_data)->private;\n}"
  }
]