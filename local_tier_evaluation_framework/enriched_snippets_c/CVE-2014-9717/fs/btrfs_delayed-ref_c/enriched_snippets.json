[
  {
    "function_name": "btrfs_delayed_ref_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.c",
    "lines": "910-944",
    "snippet": "int btrfs_delayed_ref_init(void)\n{\n\tbtrfs_delayed_ref_head_cachep = kmem_cache_create(\n\t\t\t\t\"btrfs_delayed_ref_head\",\n\t\t\t\tsizeof(struct btrfs_delayed_ref_head), 0,\n\t\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD, NULL);\n\tif (!btrfs_delayed_ref_head_cachep)\n\t\tgoto fail;\n\n\tbtrfs_delayed_tree_ref_cachep = kmem_cache_create(\n\t\t\t\t\"btrfs_delayed_tree_ref\",\n\t\t\t\tsizeof(struct btrfs_delayed_tree_ref), 0,\n\t\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD, NULL);\n\tif (!btrfs_delayed_tree_ref_cachep)\n\t\tgoto fail;\n\n\tbtrfs_delayed_data_ref_cachep = kmem_cache_create(\n\t\t\t\t\"btrfs_delayed_data_ref\",\n\t\t\t\tsizeof(struct btrfs_delayed_data_ref), 0,\n\t\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD, NULL);\n\tif (!btrfs_delayed_data_ref_cachep)\n\t\tgoto fail;\n\n\tbtrfs_delayed_extent_op_cachep = kmem_cache_create(\n\t\t\t\t\"btrfs_delayed_extent_op\",\n\t\t\t\tsizeof(struct btrfs_delayed_extent_op), 0,\n\t\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD, NULL);\n\tif (!btrfs_delayed_extent_op_cachep)\n\t\tgoto fail;\n\n\treturn 0;\nfail:\n\tbtrfs_delayed_ref_exit();\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"ctree.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *btrfs_delayed_ref_head_cachep;",
      "struct kmem_cache *btrfs_delayed_tree_ref_cachep;",
      "struct kmem_cache *btrfs_delayed_data_ref_cachep;",
      "struct kmem_cache *btrfs_delayed_extent_op_cachep;",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_delayed_ref_exit",
          "args": [],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_delayed_ref_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.c",
          "lines": "898-908",
          "snippet": "void btrfs_delayed_ref_exit(void)\n{\n\tif (btrfs_delayed_ref_head_cachep)\n\t\tkmem_cache_destroy(btrfs_delayed_ref_head_cachep);\n\tif (btrfs_delayed_tree_ref_cachep)\n\t\tkmem_cache_destroy(btrfs_delayed_tree_ref_cachep);\n\tif (btrfs_delayed_data_ref_cachep)\n\t\tkmem_cache_destroy(btrfs_delayed_data_ref_cachep);\n\tif (btrfs_delayed_extent_op_cachep)\n\t\tkmem_cache_destroy(btrfs_delayed_extent_op_cachep);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"ctree.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *btrfs_delayed_ref_head_cachep;",
            "struct kmem_cache *btrfs_delayed_tree_ref_cachep;",
            "struct kmem_cache *btrfs_delayed_data_ref_cachep;",
            "struct kmem_cache *btrfs_delayed_extent_op_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"delayed-ref.h\"\n#include \"ctree.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstruct kmem_cache *btrfs_delayed_ref_head_cachep;\nstruct kmem_cache *btrfs_delayed_tree_ref_cachep;\nstruct kmem_cache *btrfs_delayed_data_ref_cachep;\nstruct kmem_cache *btrfs_delayed_extent_op_cachep;\n\nvoid btrfs_delayed_ref_exit(void)\n{\n\tif (btrfs_delayed_ref_head_cachep)\n\t\tkmem_cache_destroy(btrfs_delayed_ref_head_cachep);\n\tif (btrfs_delayed_tree_ref_cachep)\n\t\tkmem_cache_destroy(btrfs_delayed_tree_ref_cachep);\n\tif (btrfs_delayed_data_ref_cachep)\n\t\tkmem_cache_destroy(btrfs_delayed_data_ref_cachep);\n\tif (btrfs_delayed_extent_op_cachep)\n\t\tkmem_cache_destroy(btrfs_delayed_extent_op_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"btrfs_delayed_extent_op\"",
            "sizeof(struct btrfs_delayed_extent_op)",
            "0",
            "SLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD",
            "NULL"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"btrfs_delayed_data_ref\"",
            "sizeof(struct btrfs_delayed_data_ref)",
            "0",
            "SLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD",
            "NULL"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"btrfs_delayed_tree_ref\"",
            "sizeof(struct btrfs_delayed_tree_ref)",
            "0",
            "SLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD",
            "NULL"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"btrfs_delayed_ref_head\"",
            "sizeof(struct btrfs_delayed_ref_head)",
            "0",
            "SLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD",
            "NULL"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"delayed-ref.h\"\n#include \"ctree.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstruct kmem_cache *btrfs_delayed_ref_head_cachep;\nstruct kmem_cache *btrfs_delayed_tree_ref_cachep;\nstruct kmem_cache *btrfs_delayed_data_ref_cachep;\nstruct kmem_cache *btrfs_delayed_extent_op_cachep;\nstatic noinline struct;\n\nint btrfs_delayed_ref_init(void)\n{\n\tbtrfs_delayed_ref_head_cachep = kmem_cache_create(\n\t\t\t\t\"btrfs_delayed_ref_head\",\n\t\t\t\tsizeof(struct btrfs_delayed_ref_head), 0,\n\t\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD, NULL);\n\tif (!btrfs_delayed_ref_head_cachep)\n\t\tgoto fail;\n\n\tbtrfs_delayed_tree_ref_cachep = kmem_cache_create(\n\t\t\t\t\"btrfs_delayed_tree_ref\",\n\t\t\t\tsizeof(struct btrfs_delayed_tree_ref), 0,\n\t\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD, NULL);\n\tif (!btrfs_delayed_tree_ref_cachep)\n\t\tgoto fail;\n\n\tbtrfs_delayed_data_ref_cachep = kmem_cache_create(\n\t\t\t\t\"btrfs_delayed_data_ref\",\n\t\t\t\tsizeof(struct btrfs_delayed_data_ref), 0,\n\t\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD, NULL);\n\tif (!btrfs_delayed_data_ref_cachep)\n\t\tgoto fail;\n\n\tbtrfs_delayed_extent_op_cachep = kmem_cache_create(\n\t\t\t\t\"btrfs_delayed_extent_op\",\n\t\t\t\tsizeof(struct btrfs_delayed_extent_op), 0,\n\t\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD, NULL);\n\tif (!btrfs_delayed_extent_op_cachep)\n\t\tgoto fail;\n\n\treturn 0;\nfail:\n\tbtrfs_delayed_ref_exit();\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "btrfs_delayed_ref_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.c",
    "lines": "898-908",
    "snippet": "void btrfs_delayed_ref_exit(void)\n{\n\tif (btrfs_delayed_ref_head_cachep)\n\t\tkmem_cache_destroy(btrfs_delayed_ref_head_cachep);\n\tif (btrfs_delayed_tree_ref_cachep)\n\t\tkmem_cache_destroy(btrfs_delayed_tree_ref_cachep);\n\tif (btrfs_delayed_data_ref_cachep)\n\t\tkmem_cache_destroy(btrfs_delayed_data_ref_cachep);\n\tif (btrfs_delayed_extent_op_cachep)\n\t\tkmem_cache_destroy(btrfs_delayed_extent_op_cachep);\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"ctree.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *btrfs_delayed_ref_head_cachep;",
      "struct kmem_cache *btrfs_delayed_tree_ref_cachep;",
      "struct kmem_cache *btrfs_delayed_data_ref_cachep;",
      "struct kmem_cache *btrfs_delayed_extent_op_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "btrfs_delayed_extent_op_cachep"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "btrfs_delayed_data_ref_cachep"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "btrfs_delayed_tree_ref_cachep"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "btrfs_delayed_ref_head_cachep"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"delayed-ref.h\"\n#include \"ctree.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstruct kmem_cache *btrfs_delayed_ref_head_cachep;\nstruct kmem_cache *btrfs_delayed_tree_ref_cachep;\nstruct kmem_cache *btrfs_delayed_data_ref_cachep;\nstruct kmem_cache *btrfs_delayed_extent_op_cachep;\n\nvoid btrfs_delayed_ref_exit(void)\n{\n\tif (btrfs_delayed_ref_head_cachep)\n\t\tkmem_cache_destroy(btrfs_delayed_ref_head_cachep);\n\tif (btrfs_delayed_tree_ref_cachep)\n\t\tkmem_cache_destroy(btrfs_delayed_tree_ref_cachep);\n\tif (btrfs_delayed_data_ref_cachep)\n\t\tkmem_cache_destroy(btrfs_delayed_data_ref_cachep);\n\tif (btrfs_delayed_extent_op_cachep)\n\t\tkmem_cache_destroy(btrfs_delayed_extent_op_cachep);\n}"
  },
  {
    "function_name": "btrfs_find_delayed_ref_head",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.c",
    "lines": "889-896",
    "snippet": "struct btrfs_delayed_ref_head *\nbtrfs_find_delayed_ref_head(struct btrfs_trans_handle *trans, u64 bytenr)\n{\n\tstruct btrfs_delayed_ref_root *delayed_refs;\n\n\tdelayed_refs = &trans->transaction->delayed_refs;\n\treturn find_ref_head(&delayed_refs->href_root, bytenr, 0);\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"ctree.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_ref_head",
          "args": [
            "&delayed_refs->href_root",
            "bytenr",
            "0"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "find_ref_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.c",
          "lines": "204-235",
          "snippet": "static struct btrfs_delayed_ref_head *\nfind_ref_head(struct rb_root *root, u64 bytenr,\n\t      int return_bigger)\n{\n\tstruct rb_node *n;\n\tstruct btrfs_delayed_ref_head *entry;\n\n\tn = root->rb_node;\n\tentry = NULL;\n\twhile (n) {\n\t\tentry = rb_entry(n, struct btrfs_delayed_ref_head, href_node);\n\n\t\tif (bytenr < entry->node.bytenr)\n\t\t\tn = n->rb_left;\n\t\telse if (bytenr > entry->node.bytenr)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\tif (entry && return_bigger) {\n\t\tif (bytenr > entry->node.bytenr) {\n\t\t\tn = rb_next(&entry->href_node);\n\t\t\tif (!n)\n\t\t\t\tn = rb_first(root);\n\t\t\tentry = rb_entry(n, struct btrfs_delayed_ref_head,\n\t\t\t\t\t href_node);\n\t\t\treturn entry;\n\t\t}\n\t\treturn entry;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"ctree.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"delayed-ref.h\"\n#include \"ctree.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic struct btrfs_delayed_ref_head *\nfind_ref_head(struct rb_root *root, u64 bytenr,\n\t      int return_bigger)\n{\n\tstruct rb_node *n;\n\tstruct btrfs_delayed_ref_head *entry;\n\n\tn = root->rb_node;\n\tentry = NULL;\n\twhile (n) {\n\t\tentry = rb_entry(n, struct btrfs_delayed_ref_head, href_node);\n\n\t\tif (bytenr < entry->node.bytenr)\n\t\t\tn = n->rb_left;\n\t\telse if (bytenr > entry->node.bytenr)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\tif (entry && return_bigger) {\n\t\tif (bytenr > entry->node.bytenr) {\n\t\t\tn = rb_next(&entry->href_node);\n\t\t\tif (!n)\n\t\t\t\tn = rb_first(root);\n\t\t\tentry = rb_entry(n, struct btrfs_delayed_ref_head,\n\t\t\t\t\t href_node);\n\t\t\treturn entry;\n\t\t}\n\t\treturn entry;\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"delayed-ref.h\"\n#include \"ctree.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_delayed_ref_head *\nbtrfs_find_delayed_ref_head(struct btrfs_trans_handle *trans, u64 bytenr)\n{\n\tstruct btrfs_delayed_ref_root *delayed_refs;\n\n\tdelayed_refs = &trans->transaction->delayed_refs;\n\treturn find_ref_head(&delayed_refs->href_root, bytenr, 0);\n}"
  },
  {
    "function_name": "btrfs_add_delayed_extent_op",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.c",
    "lines": "859-882",
    "snippet": "int btrfs_add_delayed_extent_op(struct btrfs_fs_info *fs_info,\n\t\t\t\tstruct btrfs_trans_handle *trans,\n\t\t\t\tu64 bytenr, u64 num_bytes,\n\t\t\t\tstruct btrfs_delayed_extent_op *extent_op)\n{\n\tstruct btrfs_delayed_ref_head *head_ref;\n\tstruct btrfs_delayed_ref_root *delayed_refs;\n\n\thead_ref = kmem_cache_alloc(btrfs_delayed_ref_head_cachep, GFP_NOFS);\n\tif (!head_ref)\n\t\treturn -ENOMEM;\n\n\thead_ref->extent_op = extent_op;\n\n\tdelayed_refs = &trans->transaction->delayed_refs;\n\tspin_lock(&delayed_refs->lock);\n\n\tadd_delayed_ref_head(fs_info, trans, &head_ref->node, bytenr,\n\t\t\t\t   num_bytes, BTRFS_UPDATE_DELAYED_HEAD,\n\t\t\t\t   extent_op->is_data);\n\n\tspin_unlock(&delayed_refs->lock);\n\treturn 0;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"ctree.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *btrfs_delayed_ref_head_cachep;",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&delayed_refs->lock"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_delayed_ref_head",
          "args": [
            "fs_info",
            "trans",
            "&head_ref->node",
            "bytenr",
            "num_bytes",
            "BTRFS_UPDATE_DELAYED_HEAD",
            "extent_op->is_data"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "add_delayed_ref_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.c",
          "lines": "553-631",
          "snippet": "btrfs_delayed_ref_head *\nadd_delayed_ref_head(struct btrfs_fs_info *fs_info,\n\t\t     struct btrfs_trans_handle *trans,\n\t\t     struct btrfs_delayed_ref_node *ref, u64 bytenr,\n\t\t     u64 num_bytes, int action, int is_data)\n{\n\tstruct btrfs_delayed_ref_head *existing;\n\tstruct btrfs_delayed_ref_head *head_ref = NULL;\n\tstruct btrfs_delayed_ref_root *delayed_refs;\n\tint count_mod = 1;\n\tint must_insert_reserved = 0;\n\n\t/*\n\t * the head node stores the sum of all the mods, so dropping a ref\n\t * should drop the sum in the head node by one.\n\t */\n\tif (action == BTRFS_UPDATE_DELAYED_HEAD)\n\t\tcount_mod = 0;\n\telse if (action == BTRFS_DROP_DELAYED_REF)\n\t\tcount_mod = -1;\n\n\t/*\n\t * BTRFS_ADD_DELAYED_EXTENT means that we need to update\n\t * the reserved accounting when the extent is finally added, or\n\t * if a later modification deletes the delayed ref without ever\n\t * inserting the extent into the extent allocation tree.\n\t * ref->must_insert_reserved is the flag used to record\n\t * that accounting mods are required.\n\t *\n\t * Once we record must_insert_reserved, switch the action to\n\t * BTRFS_ADD_DELAYED_REF because other special casing is not required.\n\t */\n\tif (action == BTRFS_ADD_DELAYED_EXTENT)\n\t\tmust_insert_reserved = 1;\n\telse\n\t\tmust_insert_reserved = 0;\n\n\tdelayed_refs = &trans->transaction->delayed_refs;\n\n\t/* first set the basic ref node struct up */\n\tatomic_set(&ref->refs, 1);\n\tref->bytenr = bytenr;\n\tref->num_bytes = num_bytes;\n\tref->ref_mod = count_mod;\n\tref->type  = 0;\n\tref->action  = 0;\n\tref->is_head = 1;\n\tref->in_tree = 1;\n\tref->seq = 0;\n\n\thead_ref = btrfs_delayed_node_to_head(ref);\n\thead_ref->must_insert_reserved = must_insert_reserved;\n\thead_ref->is_data = is_data;\n\thead_ref->ref_root = RB_ROOT;\n\thead_ref->processing = 0;\n\n\tspin_lock_init(&head_ref->lock);\n\tmutex_init(&head_ref->mutex);\n\n\ttrace_add_delayed_ref_head(ref, head_ref, action);\n\n\texisting = htree_insert(&delayed_refs->href_root,\n\t\t\t\t&head_ref->href_node);\n\tif (existing) {\n\t\tupdate_existing_head_ref(&existing->node, ref);\n\t\t/*\n\t\t * we've updated the existing ref, free the newly\n\t\t * allocated ref\n\t\t */\n\t\tkmem_cache_free(btrfs_delayed_ref_head_cachep, head_ref);\n\t\thead_ref = existing;\n\t} else {\n\t\tdelayed_refs->num_heads++;\n\t\tdelayed_refs->num_heads_ready++;\n\t\tatomic_inc(&delayed_refs->num_entries);\n\t\ttrans->delayed_ref_updates++;\n\t}\n\treturn head_ref;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"ctree.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *btrfs_delayed_ref_head_cachep;",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"delayed-ref.h\"\n#include \"ctree.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstruct kmem_cache *btrfs_delayed_ref_head_cachep;\nstatic noinline struct;\n\nbtrfs_delayed_ref_head *\nadd_delayed_ref_head(struct btrfs_fs_info *fs_info,\n\t\t     struct btrfs_trans_handle *trans,\n\t\t     struct btrfs_delayed_ref_node *ref, u64 bytenr,\n\t\t     u64 num_bytes, int action, int is_data)\n{\n\tstruct btrfs_delayed_ref_head *existing;\n\tstruct btrfs_delayed_ref_head *head_ref = NULL;\n\tstruct btrfs_delayed_ref_root *delayed_refs;\n\tint count_mod = 1;\n\tint must_insert_reserved = 0;\n\n\t/*\n\t * the head node stores the sum of all the mods, so dropping a ref\n\t * should drop the sum in the head node by one.\n\t */\n\tif (action == BTRFS_UPDATE_DELAYED_HEAD)\n\t\tcount_mod = 0;\n\telse if (action == BTRFS_DROP_DELAYED_REF)\n\t\tcount_mod = -1;\n\n\t/*\n\t * BTRFS_ADD_DELAYED_EXTENT means that we need to update\n\t * the reserved accounting when the extent is finally added, or\n\t * if a later modification deletes the delayed ref without ever\n\t * inserting the extent into the extent allocation tree.\n\t * ref->must_insert_reserved is the flag used to record\n\t * that accounting mods are required.\n\t *\n\t * Once we record must_insert_reserved, switch the action to\n\t * BTRFS_ADD_DELAYED_REF because other special casing is not required.\n\t */\n\tif (action == BTRFS_ADD_DELAYED_EXTENT)\n\t\tmust_insert_reserved = 1;\n\telse\n\t\tmust_insert_reserved = 0;\n\n\tdelayed_refs = &trans->transaction->delayed_refs;\n\n\t/* first set the basic ref node struct up */\n\tatomic_set(&ref->refs, 1);\n\tref->bytenr = bytenr;\n\tref->num_bytes = num_bytes;\n\tref->ref_mod = count_mod;\n\tref->type  = 0;\n\tref->action  = 0;\n\tref->is_head = 1;\n\tref->in_tree = 1;\n\tref->seq = 0;\n\n\thead_ref = btrfs_delayed_node_to_head(ref);\n\thead_ref->must_insert_reserved = must_insert_reserved;\n\thead_ref->is_data = is_data;\n\thead_ref->ref_root = RB_ROOT;\n\thead_ref->processing = 0;\n\n\tspin_lock_init(&head_ref->lock);\n\tmutex_init(&head_ref->mutex);\n\n\ttrace_add_delayed_ref_head(ref, head_ref, action);\n\n\texisting = htree_insert(&delayed_refs->href_root,\n\t\t\t\t&head_ref->href_node);\n\tif (existing) {\n\t\tupdate_existing_head_ref(&existing->node, ref);\n\t\t/*\n\t\t * we've updated the existing ref, free the newly\n\t\t * allocated ref\n\t\t */\n\t\tkmem_cache_free(btrfs_delayed_ref_head_cachep, head_ref);\n\t\thead_ref = existing;\n\t} else {\n\t\tdelayed_refs->num_heads++;\n\t\tdelayed_refs->num_heads_ready++;\n\t\tatomic_inc(&delayed_refs->num_entries);\n\t\ttrans->delayed_ref_updates++;\n\t}\n\treturn head_ref;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&delayed_refs->lock"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "btrfs_delayed_ref_head_cachep",
            "GFP_NOFS"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"delayed-ref.h\"\n#include \"ctree.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstruct kmem_cache *btrfs_delayed_ref_head_cachep;\nstatic noinline struct;\n\nint btrfs_add_delayed_extent_op(struct btrfs_fs_info *fs_info,\n\t\t\t\tstruct btrfs_trans_handle *trans,\n\t\t\t\tu64 bytenr, u64 num_bytes,\n\t\t\t\tstruct btrfs_delayed_extent_op *extent_op)\n{\n\tstruct btrfs_delayed_ref_head *head_ref;\n\tstruct btrfs_delayed_ref_root *delayed_refs;\n\n\thead_ref = kmem_cache_alloc(btrfs_delayed_ref_head_cachep, GFP_NOFS);\n\tif (!head_ref)\n\t\treturn -ENOMEM;\n\n\thead_ref->extent_op = extent_op;\n\n\tdelayed_refs = &trans->transaction->delayed_refs;\n\tspin_lock(&delayed_refs->lock);\n\n\tadd_delayed_ref_head(fs_info, trans, &head_ref->node, bytenr,\n\t\t\t\t   num_bytes, BTRFS_UPDATE_DELAYED_HEAD,\n\t\t\t\t   extent_op->is_data);\n\n\tspin_unlock(&delayed_refs->lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_add_delayed_data_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.c",
    "lines": "813-857",
    "snippet": "int btrfs_add_delayed_data_ref(struct btrfs_fs_info *fs_info,\n\t\t\t       struct btrfs_trans_handle *trans,\n\t\t\t       u64 bytenr, u64 num_bytes,\n\t\t\t       u64 parent, u64 ref_root,\n\t\t\t       u64 owner, u64 offset, int action,\n\t\t\t       struct btrfs_delayed_extent_op *extent_op,\n\t\t\t       int no_quota)\n{\n\tstruct btrfs_delayed_data_ref *ref;\n\tstruct btrfs_delayed_ref_head *head_ref;\n\tstruct btrfs_delayed_ref_root *delayed_refs;\n\n\tif (!is_fstree(ref_root) || !fs_info->quota_enabled)\n\t\tno_quota = 0;\n\n\tBUG_ON(extent_op && !extent_op->is_data);\n\tref = kmem_cache_alloc(btrfs_delayed_data_ref_cachep, GFP_NOFS);\n\tif (!ref)\n\t\treturn -ENOMEM;\n\n\thead_ref = kmem_cache_alloc(btrfs_delayed_ref_head_cachep, GFP_NOFS);\n\tif (!head_ref) {\n\t\tkmem_cache_free(btrfs_delayed_data_ref_cachep, ref);\n\t\treturn -ENOMEM;\n\t}\n\n\thead_ref->extent_op = extent_op;\n\n\tdelayed_refs = &trans->transaction->delayed_refs;\n\tspin_lock(&delayed_refs->lock);\n\n\t/*\n\t * insert both the head node and the new ref without dropping\n\t * the spin lock\n\t */\n\thead_ref = add_delayed_ref_head(fs_info, trans, &head_ref->node,\n\t\t\t\t\tbytenr, num_bytes, action, 1);\n\n\tadd_delayed_data_ref(fs_info, trans, head_ref, &ref->node, bytenr,\n\t\t\t\t   num_bytes, parent, ref_root, owner, offset,\n\t\t\t\t   action, no_quota);\n\tspin_unlock(&delayed_refs->lock);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"ctree.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *btrfs_delayed_ref_head_cachep;",
      "struct kmem_cache *btrfs_delayed_data_ref_cachep;",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&delayed_refs->lock"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_delayed_data_ref",
          "args": [
            "fs_info",
            "trans",
            "head_ref",
            "&ref->node",
            "bytenr",
            "num_bytes",
            "parent",
            "ref_root",
            "owner",
            "offset",
            "action",
            "no_quota"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "add_delayed_data_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.c",
          "lines": "698-758",
          "snippet": "static noinline void\nadd_delayed_data_ref(struct btrfs_fs_info *fs_info,\n\t\t     struct btrfs_trans_handle *trans,\n\t\t     struct btrfs_delayed_ref_head *head_ref,\n\t\t     struct btrfs_delayed_ref_node *ref, u64 bytenr,\n\t\t     u64 num_bytes, u64 parent, u64 ref_root, u64 owner,\n\t\t     u64 offset, int action, int no_quota)\n{\n\tstruct btrfs_delayed_ref_node *existing;\n\tstruct btrfs_delayed_data_ref *full_ref;\n\tstruct btrfs_delayed_ref_root *delayed_refs;\n\tu64 seq = 0;\n\n\tif (action == BTRFS_ADD_DELAYED_EXTENT)\n\t\taction = BTRFS_ADD_DELAYED_REF;\n\n\tdelayed_refs = &trans->transaction->delayed_refs;\n\n\tif (is_fstree(ref_root))\n\t\tseq = atomic64_read(&fs_info->tree_mod_seq);\n\n\t/* first set the basic ref node struct up */\n\tatomic_set(&ref->refs, 1);\n\tref->bytenr = bytenr;\n\tref->num_bytes = num_bytes;\n\tref->ref_mod = 1;\n\tref->action = action;\n\tref->is_head = 0;\n\tref->in_tree = 1;\n\tref->no_quota = no_quota;\n\tref->seq = seq;\n\n\tfull_ref = btrfs_delayed_node_to_data_ref(ref);\n\tfull_ref->parent = parent;\n\tfull_ref->root = ref_root;\n\tif (parent)\n\t\tref->type = BTRFS_SHARED_DATA_REF_KEY;\n\telse\n\t\tref->type = BTRFS_EXTENT_DATA_REF_KEY;\n\n\tfull_ref->objectid = owner;\n\tfull_ref->offset = offset;\n\n\ttrace_add_delayed_data_ref(ref, full_ref, action);\n\n\tspin_lock(&head_ref->lock);\n\texisting = tree_insert(&head_ref->ref_root, &ref->rb_node);\n\tif (existing) {\n\t\tupdate_existing_ref(trans, delayed_refs, head_ref, existing,\n\t\t\t\t    ref);\n\t\t/*\n\t\t * we've updated the existing ref, free the newly\n\t\t * allocated ref\n\t\t */\n\t\tkmem_cache_free(btrfs_delayed_data_ref_cachep, full_ref);\n\t} else {\n\t\tatomic_inc(&delayed_refs->num_entries);\n\t\ttrans->delayed_ref_updates++;\n\t}\n\tspin_unlock(&head_ref->lock);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"ctree.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *btrfs_delayed_data_ref_cachep;",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"delayed-ref.h\"\n#include \"ctree.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstruct kmem_cache *btrfs_delayed_data_ref_cachep;\nstatic noinline struct;\n\nstatic noinline void\nadd_delayed_data_ref(struct btrfs_fs_info *fs_info,\n\t\t     struct btrfs_trans_handle *trans,\n\t\t     struct btrfs_delayed_ref_head *head_ref,\n\t\t     struct btrfs_delayed_ref_node *ref, u64 bytenr,\n\t\t     u64 num_bytes, u64 parent, u64 ref_root, u64 owner,\n\t\t     u64 offset, int action, int no_quota)\n{\n\tstruct btrfs_delayed_ref_node *existing;\n\tstruct btrfs_delayed_data_ref *full_ref;\n\tstruct btrfs_delayed_ref_root *delayed_refs;\n\tu64 seq = 0;\n\n\tif (action == BTRFS_ADD_DELAYED_EXTENT)\n\t\taction = BTRFS_ADD_DELAYED_REF;\n\n\tdelayed_refs = &trans->transaction->delayed_refs;\n\n\tif (is_fstree(ref_root))\n\t\tseq = atomic64_read(&fs_info->tree_mod_seq);\n\n\t/* first set the basic ref node struct up */\n\tatomic_set(&ref->refs, 1);\n\tref->bytenr = bytenr;\n\tref->num_bytes = num_bytes;\n\tref->ref_mod = 1;\n\tref->action = action;\n\tref->is_head = 0;\n\tref->in_tree = 1;\n\tref->no_quota = no_quota;\n\tref->seq = seq;\n\n\tfull_ref = btrfs_delayed_node_to_data_ref(ref);\n\tfull_ref->parent = parent;\n\tfull_ref->root = ref_root;\n\tif (parent)\n\t\tref->type = BTRFS_SHARED_DATA_REF_KEY;\n\telse\n\t\tref->type = BTRFS_EXTENT_DATA_REF_KEY;\n\n\tfull_ref->objectid = owner;\n\tfull_ref->offset = offset;\n\n\ttrace_add_delayed_data_ref(ref, full_ref, action);\n\n\tspin_lock(&head_ref->lock);\n\texisting = tree_insert(&head_ref->ref_root, &ref->rb_node);\n\tif (existing) {\n\t\tupdate_existing_ref(trans, delayed_refs, head_ref, existing,\n\t\t\t\t    ref);\n\t\t/*\n\t\t * we've updated the existing ref, free the newly\n\t\t * allocated ref\n\t\t */\n\t\tkmem_cache_free(btrfs_delayed_data_ref_cachep, full_ref);\n\t} else {\n\t\tatomic_inc(&delayed_refs->num_entries);\n\t\ttrans->delayed_ref_updates++;\n\t}\n\tspin_unlock(&head_ref->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_delayed_ref_head",
          "args": [
            "fs_info",
            "trans",
            "&head_ref->node",
            "bytenr",
            "num_bytes",
            "action",
            "1"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "add_delayed_ref_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.c",
          "lines": "553-631",
          "snippet": "btrfs_delayed_ref_head *\nadd_delayed_ref_head(struct btrfs_fs_info *fs_info,\n\t\t     struct btrfs_trans_handle *trans,\n\t\t     struct btrfs_delayed_ref_node *ref, u64 bytenr,\n\t\t     u64 num_bytes, int action, int is_data)\n{\n\tstruct btrfs_delayed_ref_head *existing;\n\tstruct btrfs_delayed_ref_head *head_ref = NULL;\n\tstruct btrfs_delayed_ref_root *delayed_refs;\n\tint count_mod = 1;\n\tint must_insert_reserved = 0;\n\n\t/*\n\t * the head node stores the sum of all the mods, so dropping a ref\n\t * should drop the sum in the head node by one.\n\t */\n\tif (action == BTRFS_UPDATE_DELAYED_HEAD)\n\t\tcount_mod = 0;\n\telse if (action == BTRFS_DROP_DELAYED_REF)\n\t\tcount_mod = -1;\n\n\t/*\n\t * BTRFS_ADD_DELAYED_EXTENT means that we need to update\n\t * the reserved accounting when the extent is finally added, or\n\t * if a later modification deletes the delayed ref without ever\n\t * inserting the extent into the extent allocation tree.\n\t * ref->must_insert_reserved is the flag used to record\n\t * that accounting mods are required.\n\t *\n\t * Once we record must_insert_reserved, switch the action to\n\t * BTRFS_ADD_DELAYED_REF because other special casing is not required.\n\t */\n\tif (action == BTRFS_ADD_DELAYED_EXTENT)\n\t\tmust_insert_reserved = 1;\n\telse\n\t\tmust_insert_reserved = 0;\n\n\tdelayed_refs = &trans->transaction->delayed_refs;\n\n\t/* first set the basic ref node struct up */\n\tatomic_set(&ref->refs, 1);\n\tref->bytenr = bytenr;\n\tref->num_bytes = num_bytes;\n\tref->ref_mod = count_mod;\n\tref->type  = 0;\n\tref->action  = 0;\n\tref->is_head = 1;\n\tref->in_tree = 1;\n\tref->seq = 0;\n\n\thead_ref = btrfs_delayed_node_to_head(ref);\n\thead_ref->must_insert_reserved = must_insert_reserved;\n\thead_ref->is_data = is_data;\n\thead_ref->ref_root = RB_ROOT;\n\thead_ref->processing = 0;\n\n\tspin_lock_init(&head_ref->lock);\n\tmutex_init(&head_ref->mutex);\n\n\ttrace_add_delayed_ref_head(ref, head_ref, action);\n\n\texisting = htree_insert(&delayed_refs->href_root,\n\t\t\t\t&head_ref->href_node);\n\tif (existing) {\n\t\tupdate_existing_head_ref(&existing->node, ref);\n\t\t/*\n\t\t * we've updated the existing ref, free the newly\n\t\t * allocated ref\n\t\t */\n\t\tkmem_cache_free(btrfs_delayed_ref_head_cachep, head_ref);\n\t\thead_ref = existing;\n\t} else {\n\t\tdelayed_refs->num_heads++;\n\t\tdelayed_refs->num_heads_ready++;\n\t\tatomic_inc(&delayed_refs->num_entries);\n\t\ttrans->delayed_ref_updates++;\n\t}\n\treturn head_ref;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"ctree.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *btrfs_delayed_ref_head_cachep;",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"delayed-ref.h\"\n#include \"ctree.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstruct kmem_cache *btrfs_delayed_ref_head_cachep;\nstatic noinline struct;\n\nbtrfs_delayed_ref_head *\nadd_delayed_ref_head(struct btrfs_fs_info *fs_info,\n\t\t     struct btrfs_trans_handle *trans,\n\t\t     struct btrfs_delayed_ref_node *ref, u64 bytenr,\n\t\t     u64 num_bytes, int action, int is_data)\n{\n\tstruct btrfs_delayed_ref_head *existing;\n\tstruct btrfs_delayed_ref_head *head_ref = NULL;\n\tstruct btrfs_delayed_ref_root *delayed_refs;\n\tint count_mod = 1;\n\tint must_insert_reserved = 0;\n\n\t/*\n\t * the head node stores the sum of all the mods, so dropping a ref\n\t * should drop the sum in the head node by one.\n\t */\n\tif (action == BTRFS_UPDATE_DELAYED_HEAD)\n\t\tcount_mod = 0;\n\telse if (action == BTRFS_DROP_DELAYED_REF)\n\t\tcount_mod = -1;\n\n\t/*\n\t * BTRFS_ADD_DELAYED_EXTENT means that we need to update\n\t * the reserved accounting when the extent is finally added, or\n\t * if a later modification deletes the delayed ref without ever\n\t * inserting the extent into the extent allocation tree.\n\t * ref->must_insert_reserved is the flag used to record\n\t * that accounting mods are required.\n\t *\n\t * Once we record must_insert_reserved, switch the action to\n\t * BTRFS_ADD_DELAYED_REF because other special casing is not required.\n\t */\n\tif (action == BTRFS_ADD_DELAYED_EXTENT)\n\t\tmust_insert_reserved = 1;\n\telse\n\t\tmust_insert_reserved = 0;\n\n\tdelayed_refs = &trans->transaction->delayed_refs;\n\n\t/* first set the basic ref node struct up */\n\tatomic_set(&ref->refs, 1);\n\tref->bytenr = bytenr;\n\tref->num_bytes = num_bytes;\n\tref->ref_mod = count_mod;\n\tref->type  = 0;\n\tref->action  = 0;\n\tref->is_head = 1;\n\tref->in_tree = 1;\n\tref->seq = 0;\n\n\thead_ref = btrfs_delayed_node_to_head(ref);\n\thead_ref->must_insert_reserved = must_insert_reserved;\n\thead_ref->is_data = is_data;\n\thead_ref->ref_root = RB_ROOT;\n\thead_ref->processing = 0;\n\n\tspin_lock_init(&head_ref->lock);\n\tmutex_init(&head_ref->mutex);\n\n\ttrace_add_delayed_ref_head(ref, head_ref, action);\n\n\texisting = htree_insert(&delayed_refs->href_root,\n\t\t\t\t&head_ref->href_node);\n\tif (existing) {\n\t\tupdate_existing_head_ref(&existing->node, ref);\n\t\t/*\n\t\t * we've updated the existing ref, free the newly\n\t\t * allocated ref\n\t\t */\n\t\tkmem_cache_free(btrfs_delayed_ref_head_cachep, head_ref);\n\t\thead_ref = existing;\n\t} else {\n\t\tdelayed_refs->num_heads++;\n\t\tdelayed_refs->num_heads_ready++;\n\t\tatomic_inc(&delayed_refs->num_entries);\n\t\ttrans->delayed_ref_updates++;\n\t}\n\treturn head_ref;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&delayed_refs->lock"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "btrfs_delayed_data_ref_cachep",
            "ref"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "btrfs_delayed_ref_head_cachep",
            "GFP_NOFS"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "extent_op && !extent_op->is_data"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_fstree",
          "args": [
            "ref_root"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "is_fstree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "4180-4186",
          "snippet": "static inline int is_fstree(u64 rootid)\n{\n\tif (rootid == BTRFS_FS_TREE_OBJECTID ||\n\t    (s64)rootid >= (s64)BTRFS_FIRST_FREE_OBJECTID)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_FIRST_FREE_OBJECTID 256ULL",
            "#define BTRFS_FS_TREE_OBJECTID 5ULL"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_FIRST_FREE_OBJECTID 256ULL\n#define BTRFS_FS_TREE_OBJECTID 5ULL\n\nstatic inline int is_fstree(u64 rootid)\n{\n\tif (rootid == BTRFS_FS_TREE_OBJECTID ||\n\t    (s64)rootid >= (s64)BTRFS_FIRST_FREE_OBJECTID)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"delayed-ref.h\"\n#include \"ctree.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstruct kmem_cache *btrfs_delayed_ref_head_cachep;\nstruct kmem_cache *btrfs_delayed_data_ref_cachep;\nstatic noinline struct;\n\nint btrfs_add_delayed_data_ref(struct btrfs_fs_info *fs_info,\n\t\t\t       struct btrfs_trans_handle *trans,\n\t\t\t       u64 bytenr, u64 num_bytes,\n\t\t\t       u64 parent, u64 ref_root,\n\t\t\t       u64 owner, u64 offset, int action,\n\t\t\t       struct btrfs_delayed_extent_op *extent_op,\n\t\t\t       int no_quota)\n{\n\tstruct btrfs_delayed_data_ref *ref;\n\tstruct btrfs_delayed_ref_head *head_ref;\n\tstruct btrfs_delayed_ref_root *delayed_refs;\n\n\tif (!is_fstree(ref_root) || !fs_info->quota_enabled)\n\t\tno_quota = 0;\n\n\tBUG_ON(extent_op && !extent_op->is_data);\n\tref = kmem_cache_alloc(btrfs_delayed_data_ref_cachep, GFP_NOFS);\n\tif (!ref)\n\t\treturn -ENOMEM;\n\n\thead_ref = kmem_cache_alloc(btrfs_delayed_ref_head_cachep, GFP_NOFS);\n\tif (!head_ref) {\n\t\tkmem_cache_free(btrfs_delayed_data_ref_cachep, ref);\n\t\treturn -ENOMEM;\n\t}\n\n\thead_ref->extent_op = extent_op;\n\n\tdelayed_refs = &trans->transaction->delayed_refs;\n\tspin_lock(&delayed_refs->lock);\n\n\t/*\n\t * insert both the head node and the new ref without dropping\n\t * the spin lock\n\t */\n\thead_ref = add_delayed_ref_head(fs_info, trans, &head_ref->node,\n\t\t\t\t\tbytenr, num_bytes, action, 1);\n\n\tadd_delayed_data_ref(fs_info, trans, head_ref, &ref->node, bytenr,\n\t\t\t\t   num_bytes, parent, ref_root, owner, offset,\n\t\t\t\t   action, no_quota);\n\tspin_unlock(&delayed_refs->lock);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_add_delayed_tree_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.c",
    "lines": "765-808",
    "snippet": "int btrfs_add_delayed_tree_ref(struct btrfs_fs_info *fs_info,\n\t\t\t       struct btrfs_trans_handle *trans,\n\t\t\t       u64 bytenr, u64 num_bytes, u64 parent,\n\t\t\t       u64 ref_root,  int level, int action,\n\t\t\t       struct btrfs_delayed_extent_op *extent_op,\n\t\t\t       int no_quota)\n{\n\tstruct btrfs_delayed_tree_ref *ref;\n\tstruct btrfs_delayed_ref_head *head_ref;\n\tstruct btrfs_delayed_ref_root *delayed_refs;\n\n\tif (!is_fstree(ref_root) || !fs_info->quota_enabled)\n\t\tno_quota = 0;\n\n\tBUG_ON(extent_op && extent_op->is_data);\n\tref = kmem_cache_alloc(btrfs_delayed_tree_ref_cachep, GFP_NOFS);\n\tif (!ref)\n\t\treturn -ENOMEM;\n\n\thead_ref = kmem_cache_alloc(btrfs_delayed_ref_head_cachep, GFP_NOFS);\n\tif (!head_ref) {\n\t\tkmem_cache_free(btrfs_delayed_tree_ref_cachep, ref);\n\t\treturn -ENOMEM;\n\t}\n\n\thead_ref->extent_op = extent_op;\n\n\tdelayed_refs = &trans->transaction->delayed_refs;\n\tspin_lock(&delayed_refs->lock);\n\n\t/*\n\t * insert both the head node and the new ref without dropping\n\t * the spin lock\n\t */\n\thead_ref = add_delayed_ref_head(fs_info, trans, &head_ref->node,\n\t\t\t\t\tbytenr, num_bytes, action, 0);\n\n\tadd_delayed_tree_ref(fs_info, trans, head_ref, &ref->node, bytenr,\n\t\t\t\t   num_bytes, parent, ref_root, level, action,\n\t\t\t\t   no_quota);\n\tspin_unlock(&delayed_refs->lock);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"ctree.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *btrfs_delayed_ref_head_cachep;",
      "struct kmem_cache *btrfs_delayed_tree_ref_cachep;",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&delayed_refs->lock"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_delayed_tree_ref",
          "args": [
            "fs_info",
            "trans",
            "head_ref",
            "&ref->node",
            "bytenr",
            "num_bytes",
            "parent",
            "ref_root",
            "level",
            "action",
            "no_quota"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "add_delayed_tree_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.c",
          "lines": "636-693",
          "snippet": "static noinline void\nadd_delayed_tree_ref(struct btrfs_fs_info *fs_info,\n\t\t     struct btrfs_trans_handle *trans,\n\t\t     struct btrfs_delayed_ref_head *head_ref,\n\t\t     struct btrfs_delayed_ref_node *ref, u64 bytenr,\n\t\t     u64 num_bytes, u64 parent, u64 ref_root, int level,\n\t\t     int action, int no_quota)\n{\n\tstruct btrfs_delayed_ref_node *existing;\n\tstruct btrfs_delayed_tree_ref *full_ref;\n\tstruct btrfs_delayed_ref_root *delayed_refs;\n\tu64 seq = 0;\n\n\tif (action == BTRFS_ADD_DELAYED_EXTENT)\n\t\taction = BTRFS_ADD_DELAYED_REF;\n\n\tif (is_fstree(ref_root))\n\t\tseq = atomic64_read(&fs_info->tree_mod_seq);\n\tdelayed_refs = &trans->transaction->delayed_refs;\n\n\t/* first set the basic ref node struct up */\n\tatomic_set(&ref->refs, 1);\n\tref->bytenr = bytenr;\n\tref->num_bytes = num_bytes;\n\tref->ref_mod = 1;\n\tref->action = action;\n\tref->is_head = 0;\n\tref->in_tree = 1;\n\tref->no_quota = no_quota;\n\tref->seq = seq;\n\n\tfull_ref = btrfs_delayed_node_to_tree_ref(ref);\n\tfull_ref->parent = parent;\n\tfull_ref->root = ref_root;\n\tif (parent)\n\t\tref->type = BTRFS_SHARED_BLOCK_REF_KEY;\n\telse\n\t\tref->type = BTRFS_TREE_BLOCK_REF_KEY;\n\tfull_ref->level = level;\n\n\ttrace_add_delayed_tree_ref(ref, full_ref, action);\n\n\tspin_lock(&head_ref->lock);\n\texisting = tree_insert(&head_ref->ref_root, &ref->rb_node);\n\tif (existing) {\n\t\tupdate_existing_ref(trans, delayed_refs, head_ref, existing,\n\t\t\t\t    ref);\n\t\t/*\n\t\t * we've updated the existing ref, free the newly\n\t\t * allocated ref\n\t\t */\n\t\tkmem_cache_free(btrfs_delayed_tree_ref_cachep, full_ref);\n\t} else {\n\t\tatomic_inc(&delayed_refs->num_entries);\n\t\ttrans->delayed_ref_updates++;\n\t}\n\tspin_unlock(&head_ref->lock);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"ctree.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *btrfs_delayed_tree_ref_cachep;",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"delayed-ref.h\"\n#include \"ctree.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstruct kmem_cache *btrfs_delayed_tree_ref_cachep;\nstatic noinline struct;\n\nstatic noinline void\nadd_delayed_tree_ref(struct btrfs_fs_info *fs_info,\n\t\t     struct btrfs_trans_handle *trans,\n\t\t     struct btrfs_delayed_ref_head *head_ref,\n\t\t     struct btrfs_delayed_ref_node *ref, u64 bytenr,\n\t\t     u64 num_bytes, u64 parent, u64 ref_root, int level,\n\t\t     int action, int no_quota)\n{\n\tstruct btrfs_delayed_ref_node *existing;\n\tstruct btrfs_delayed_tree_ref *full_ref;\n\tstruct btrfs_delayed_ref_root *delayed_refs;\n\tu64 seq = 0;\n\n\tif (action == BTRFS_ADD_DELAYED_EXTENT)\n\t\taction = BTRFS_ADD_DELAYED_REF;\n\n\tif (is_fstree(ref_root))\n\t\tseq = atomic64_read(&fs_info->tree_mod_seq);\n\tdelayed_refs = &trans->transaction->delayed_refs;\n\n\t/* first set the basic ref node struct up */\n\tatomic_set(&ref->refs, 1);\n\tref->bytenr = bytenr;\n\tref->num_bytes = num_bytes;\n\tref->ref_mod = 1;\n\tref->action = action;\n\tref->is_head = 0;\n\tref->in_tree = 1;\n\tref->no_quota = no_quota;\n\tref->seq = seq;\n\n\tfull_ref = btrfs_delayed_node_to_tree_ref(ref);\n\tfull_ref->parent = parent;\n\tfull_ref->root = ref_root;\n\tif (parent)\n\t\tref->type = BTRFS_SHARED_BLOCK_REF_KEY;\n\telse\n\t\tref->type = BTRFS_TREE_BLOCK_REF_KEY;\n\tfull_ref->level = level;\n\n\ttrace_add_delayed_tree_ref(ref, full_ref, action);\n\n\tspin_lock(&head_ref->lock);\n\texisting = tree_insert(&head_ref->ref_root, &ref->rb_node);\n\tif (existing) {\n\t\tupdate_existing_ref(trans, delayed_refs, head_ref, existing,\n\t\t\t\t    ref);\n\t\t/*\n\t\t * we've updated the existing ref, free the newly\n\t\t * allocated ref\n\t\t */\n\t\tkmem_cache_free(btrfs_delayed_tree_ref_cachep, full_ref);\n\t} else {\n\t\tatomic_inc(&delayed_refs->num_entries);\n\t\ttrans->delayed_ref_updates++;\n\t}\n\tspin_unlock(&head_ref->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_delayed_ref_head",
          "args": [
            "fs_info",
            "trans",
            "&head_ref->node",
            "bytenr",
            "num_bytes",
            "action",
            "0"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "add_delayed_ref_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.c",
          "lines": "553-631",
          "snippet": "btrfs_delayed_ref_head *\nadd_delayed_ref_head(struct btrfs_fs_info *fs_info,\n\t\t     struct btrfs_trans_handle *trans,\n\t\t     struct btrfs_delayed_ref_node *ref, u64 bytenr,\n\t\t     u64 num_bytes, int action, int is_data)\n{\n\tstruct btrfs_delayed_ref_head *existing;\n\tstruct btrfs_delayed_ref_head *head_ref = NULL;\n\tstruct btrfs_delayed_ref_root *delayed_refs;\n\tint count_mod = 1;\n\tint must_insert_reserved = 0;\n\n\t/*\n\t * the head node stores the sum of all the mods, so dropping a ref\n\t * should drop the sum in the head node by one.\n\t */\n\tif (action == BTRFS_UPDATE_DELAYED_HEAD)\n\t\tcount_mod = 0;\n\telse if (action == BTRFS_DROP_DELAYED_REF)\n\t\tcount_mod = -1;\n\n\t/*\n\t * BTRFS_ADD_DELAYED_EXTENT means that we need to update\n\t * the reserved accounting when the extent is finally added, or\n\t * if a later modification deletes the delayed ref without ever\n\t * inserting the extent into the extent allocation tree.\n\t * ref->must_insert_reserved is the flag used to record\n\t * that accounting mods are required.\n\t *\n\t * Once we record must_insert_reserved, switch the action to\n\t * BTRFS_ADD_DELAYED_REF because other special casing is not required.\n\t */\n\tif (action == BTRFS_ADD_DELAYED_EXTENT)\n\t\tmust_insert_reserved = 1;\n\telse\n\t\tmust_insert_reserved = 0;\n\n\tdelayed_refs = &trans->transaction->delayed_refs;\n\n\t/* first set the basic ref node struct up */\n\tatomic_set(&ref->refs, 1);\n\tref->bytenr = bytenr;\n\tref->num_bytes = num_bytes;\n\tref->ref_mod = count_mod;\n\tref->type  = 0;\n\tref->action  = 0;\n\tref->is_head = 1;\n\tref->in_tree = 1;\n\tref->seq = 0;\n\n\thead_ref = btrfs_delayed_node_to_head(ref);\n\thead_ref->must_insert_reserved = must_insert_reserved;\n\thead_ref->is_data = is_data;\n\thead_ref->ref_root = RB_ROOT;\n\thead_ref->processing = 0;\n\n\tspin_lock_init(&head_ref->lock);\n\tmutex_init(&head_ref->mutex);\n\n\ttrace_add_delayed_ref_head(ref, head_ref, action);\n\n\texisting = htree_insert(&delayed_refs->href_root,\n\t\t\t\t&head_ref->href_node);\n\tif (existing) {\n\t\tupdate_existing_head_ref(&existing->node, ref);\n\t\t/*\n\t\t * we've updated the existing ref, free the newly\n\t\t * allocated ref\n\t\t */\n\t\tkmem_cache_free(btrfs_delayed_ref_head_cachep, head_ref);\n\t\thead_ref = existing;\n\t} else {\n\t\tdelayed_refs->num_heads++;\n\t\tdelayed_refs->num_heads_ready++;\n\t\tatomic_inc(&delayed_refs->num_entries);\n\t\ttrans->delayed_ref_updates++;\n\t}\n\treturn head_ref;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"ctree.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *btrfs_delayed_ref_head_cachep;",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"delayed-ref.h\"\n#include \"ctree.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstruct kmem_cache *btrfs_delayed_ref_head_cachep;\nstatic noinline struct;\n\nbtrfs_delayed_ref_head *\nadd_delayed_ref_head(struct btrfs_fs_info *fs_info,\n\t\t     struct btrfs_trans_handle *trans,\n\t\t     struct btrfs_delayed_ref_node *ref, u64 bytenr,\n\t\t     u64 num_bytes, int action, int is_data)\n{\n\tstruct btrfs_delayed_ref_head *existing;\n\tstruct btrfs_delayed_ref_head *head_ref = NULL;\n\tstruct btrfs_delayed_ref_root *delayed_refs;\n\tint count_mod = 1;\n\tint must_insert_reserved = 0;\n\n\t/*\n\t * the head node stores the sum of all the mods, so dropping a ref\n\t * should drop the sum in the head node by one.\n\t */\n\tif (action == BTRFS_UPDATE_DELAYED_HEAD)\n\t\tcount_mod = 0;\n\telse if (action == BTRFS_DROP_DELAYED_REF)\n\t\tcount_mod = -1;\n\n\t/*\n\t * BTRFS_ADD_DELAYED_EXTENT means that we need to update\n\t * the reserved accounting when the extent is finally added, or\n\t * if a later modification deletes the delayed ref without ever\n\t * inserting the extent into the extent allocation tree.\n\t * ref->must_insert_reserved is the flag used to record\n\t * that accounting mods are required.\n\t *\n\t * Once we record must_insert_reserved, switch the action to\n\t * BTRFS_ADD_DELAYED_REF because other special casing is not required.\n\t */\n\tif (action == BTRFS_ADD_DELAYED_EXTENT)\n\t\tmust_insert_reserved = 1;\n\telse\n\t\tmust_insert_reserved = 0;\n\n\tdelayed_refs = &trans->transaction->delayed_refs;\n\n\t/* first set the basic ref node struct up */\n\tatomic_set(&ref->refs, 1);\n\tref->bytenr = bytenr;\n\tref->num_bytes = num_bytes;\n\tref->ref_mod = count_mod;\n\tref->type  = 0;\n\tref->action  = 0;\n\tref->is_head = 1;\n\tref->in_tree = 1;\n\tref->seq = 0;\n\n\thead_ref = btrfs_delayed_node_to_head(ref);\n\thead_ref->must_insert_reserved = must_insert_reserved;\n\thead_ref->is_data = is_data;\n\thead_ref->ref_root = RB_ROOT;\n\thead_ref->processing = 0;\n\n\tspin_lock_init(&head_ref->lock);\n\tmutex_init(&head_ref->mutex);\n\n\ttrace_add_delayed_ref_head(ref, head_ref, action);\n\n\texisting = htree_insert(&delayed_refs->href_root,\n\t\t\t\t&head_ref->href_node);\n\tif (existing) {\n\t\tupdate_existing_head_ref(&existing->node, ref);\n\t\t/*\n\t\t * we've updated the existing ref, free the newly\n\t\t * allocated ref\n\t\t */\n\t\tkmem_cache_free(btrfs_delayed_ref_head_cachep, head_ref);\n\t\thead_ref = existing;\n\t} else {\n\t\tdelayed_refs->num_heads++;\n\t\tdelayed_refs->num_heads_ready++;\n\t\tatomic_inc(&delayed_refs->num_entries);\n\t\ttrans->delayed_ref_updates++;\n\t}\n\treturn head_ref;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&delayed_refs->lock"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "btrfs_delayed_tree_ref_cachep",
            "ref"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "btrfs_delayed_ref_head_cachep",
            "GFP_NOFS"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "extent_op && extent_op->is_data"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_fstree",
          "args": [
            "ref_root"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "is_fstree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "4180-4186",
          "snippet": "static inline int is_fstree(u64 rootid)\n{\n\tif (rootid == BTRFS_FS_TREE_OBJECTID ||\n\t    (s64)rootid >= (s64)BTRFS_FIRST_FREE_OBJECTID)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_FIRST_FREE_OBJECTID 256ULL",
            "#define BTRFS_FS_TREE_OBJECTID 5ULL"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_FIRST_FREE_OBJECTID 256ULL\n#define BTRFS_FS_TREE_OBJECTID 5ULL\n\nstatic inline int is_fstree(u64 rootid)\n{\n\tif (rootid == BTRFS_FS_TREE_OBJECTID ||\n\t    (s64)rootid >= (s64)BTRFS_FIRST_FREE_OBJECTID)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"delayed-ref.h\"\n#include \"ctree.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstruct kmem_cache *btrfs_delayed_ref_head_cachep;\nstruct kmem_cache *btrfs_delayed_tree_ref_cachep;\nstatic noinline struct;\n\nint btrfs_add_delayed_tree_ref(struct btrfs_fs_info *fs_info,\n\t\t\t       struct btrfs_trans_handle *trans,\n\t\t\t       u64 bytenr, u64 num_bytes, u64 parent,\n\t\t\t       u64 ref_root,  int level, int action,\n\t\t\t       struct btrfs_delayed_extent_op *extent_op,\n\t\t\t       int no_quota)\n{\n\tstruct btrfs_delayed_tree_ref *ref;\n\tstruct btrfs_delayed_ref_head *head_ref;\n\tstruct btrfs_delayed_ref_root *delayed_refs;\n\n\tif (!is_fstree(ref_root) || !fs_info->quota_enabled)\n\t\tno_quota = 0;\n\n\tBUG_ON(extent_op && extent_op->is_data);\n\tref = kmem_cache_alloc(btrfs_delayed_tree_ref_cachep, GFP_NOFS);\n\tif (!ref)\n\t\treturn -ENOMEM;\n\n\thead_ref = kmem_cache_alloc(btrfs_delayed_ref_head_cachep, GFP_NOFS);\n\tif (!head_ref) {\n\t\tkmem_cache_free(btrfs_delayed_tree_ref_cachep, ref);\n\t\treturn -ENOMEM;\n\t}\n\n\thead_ref->extent_op = extent_op;\n\n\tdelayed_refs = &trans->transaction->delayed_refs;\n\tspin_lock(&delayed_refs->lock);\n\n\t/*\n\t * insert both the head node and the new ref without dropping\n\t * the spin lock\n\t */\n\thead_ref = add_delayed_ref_head(fs_info, trans, &head_ref->node,\n\t\t\t\t\tbytenr, num_bytes, action, 0);\n\n\tadd_delayed_tree_ref(fs_info, trans, head_ref, &ref->node, bytenr,\n\t\t\t\t   num_bytes, parent, ref_root, level, action,\n\t\t\t\t   no_quota);\n\tspin_unlock(&delayed_refs->lock);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "add_delayed_data_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.c",
    "lines": "698-758",
    "snippet": "static noinline void\nadd_delayed_data_ref(struct btrfs_fs_info *fs_info,\n\t\t     struct btrfs_trans_handle *trans,\n\t\t     struct btrfs_delayed_ref_head *head_ref,\n\t\t     struct btrfs_delayed_ref_node *ref, u64 bytenr,\n\t\t     u64 num_bytes, u64 parent, u64 ref_root, u64 owner,\n\t\t     u64 offset, int action, int no_quota)\n{\n\tstruct btrfs_delayed_ref_node *existing;\n\tstruct btrfs_delayed_data_ref *full_ref;\n\tstruct btrfs_delayed_ref_root *delayed_refs;\n\tu64 seq = 0;\n\n\tif (action == BTRFS_ADD_DELAYED_EXTENT)\n\t\taction = BTRFS_ADD_DELAYED_REF;\n\n\tdelayed_refs = &trans->transaction->delayed_refs;\n\n\tif (is_fstree(ref_root))\n\t\tseq = atomic64_read(&fs_info->tree_mod_seq);\n\n\t/* first set the basic ref node struct up */\n\tatomic_set(&ref->refs, 1);\n\tref->bytenr = bytenr;\n\tref->num_bytes = num_bytes;\n\tref->ref_mod = 1;\n\tref->action = action;\n\tref->is_head = 0;\n\tref->in_tree = 1;\n\tref->no_quota = no_quota;\n\tref->seq = seq;\n\n\tfull_ref = btrfs_delayed_node_to_data_ref(ref);\n\tfull_ref->parent = parent;\n\tfull_ref->root = ref_root;\n\tif (parent)\n\t\tref->type = BTRFS_SHARED_DATA_REF_KEY;\n\telse\n\t\tref->type = BTRFS_EXTENT_DATA_REF_KEY;\n\n\tfull_ref->objectid = owner;\n\tfull_ref->offset = offset;\n\n\ttrace_add_delayed_data_ref(ref, full_ref, action);\n\n\tspin_lock(&head_ref->lock);\n\texisting = tree_insert(&head_ref->ref_root, &ref->rb_node);\n\tif (existing) {\n\t\tupdate_existing_ref(trans, delayed_refs, head_ref, existing,\n\t\t\t\t    ref);\n\t\t/*\n\t\t * we've updated the existing ref, free the newly\n\t\t * allocated ref\n\t\t */\n\t\tkmem_cache_free(btrfs_delayed_data_ref_cachep, full_ref);\n\t} else {\n\t\tatomic_inc(&delayed_refs->num_entries);\n\t\ttrans->delayed_ref_updates++;\n\t}\n\tspin_unlock(&head_ref->lock);\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"ctree.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *btrfs_delayed_data_ref_cachep;",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&head_ref->lock"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&delayed_refs->num_entries"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "btrfs_delayed_data_ref_cachep",
            "full_ref"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_existing_ref",
          "args": [
            "trans",
            "delayed_refs",
            "head_ref",
            "existing",
            "ref"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "update_existing_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.c",
          "lines": "453-485",
          "snippet": "static noinline void\nupdate_existing_ref(struct btrfs_trans_handle *trans,\n\t\t    struct btrfs_delayed_ref_root *delayed_refs,\n\t\t    struct btrfs_delayed_ref_head *head,\n\t\t    struct btrfs_delayed_ref_node *existing,\n\t\t    struct btrfs_delayed_ref_node *update)\n{\n\tif (update->action != existing->action) {\n\t\t/*\n\t\t * this is effectively undoing either an add or a\n\t\t * drop.  We decrement the ref_mod, and if it goes\n\t\t * down to zero we just delete the entry without\n\t\t * every changing the extent allocation tree.\n\t\t */\n\t\texisting->ref_mod--;\n\t\tif (existing->ref_mod == 0)\n\t\t\tdrop_delayed_ref(trans, delayed_refs, head, existing);\n\t\telse\n\t\t\tWARN_ON(existing->type == BTRFS_TREE_BLOCK_REF_KEY ||\n\t\t\t\texisting->type == BTRFS_SHARED_BLOCK_REF_KEY);\n\t} else {\n\t\tWARN_ON(existing->type == BTRFS_TREE_BLOCK_REF_KEY ||\n\t\t\texisting->type == BTRFS_SHARED_BLOCK_REF_KEY);\n\t\t/*\n\t\t * the action on the existing ref matches\n\t\t * the action on the ref we're trying to add.\n\t\t * Bump the ref_mod by one so the backref that\n\t\t * is eventually added/removed has the correct\n\t\t * reference count\n\t\t */\n\t\texisting->ref_mod += update->ref_mod;\n\t}\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"ctree.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"delayed-ref.h\"\n#include \"ctree.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic noinline void\nupdate_existing_ref(struct btrfs_trans_handle *trans,\n\t\t    struct btrfs_delayed_ref_root *delayed_refs,\n\t\t    struct btrfs_delayed_ref_head *head,\n\t\t    struct btrfs_delayed_ref_node *existing,\n\t\t    struct btrfs_delayed_ref_node *update)\n{\n\tif (update->action != existing->action) {\n\t\t/*\n\t\t * this is effectively undoing either an add or a\n\t\t * drop.  We decrement the ref_mod, and if it goes\n\t\t * down to zero we just delete the entry without\n\t\t * every changing the extent allocation tree.\n\t\t */\n\t\texisting->ref_mod--;\n\t\tif (existing->ref_mod == 0)\n\t\t\tdrop_delayed_ref(trans, delayed_refs, head, existing);\n\t\telse\n\t\t\tWARN_ON(existing->type == BTRFS_TREE_BLOCK_REF_KEY ||\n\t\t\t\texisting->type == BTRFS_SHARED_BLOCK_REF_KEY);\n\t} else {\n\t\tWARN_ON(existing->type == BTRFS_TREE_BLOCK_REF_KEY ||\n\t\t\texisting->type == BTRFS_SHARED_BLOCK_REF_KEY);\n\t\t/*\n\t\t * the action on the existing ref matches\n\t\t * the action on the ref we're trying to add.\n\t\t * Bump the ref_mod by one so the backref that\n\t\t * is eventually added/removed has the correct\n\t\t * reference count\n\t\t */\n\t\texisting->ref_mod += update->ref_mod;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_insert",
          "args": [
            "&head_ref->ref_root",
            "&ref->rb_node"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "htree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.c",
          "lines": "169-196",
          "snippet": "static struct btrfs_delayed_ref_head *htree_insert(struct rb_root *root,\n\t\t\t\t\t\t   struct rb_node *node)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent_node = NULL;\n\tstruct btrfs_delayed_ref_head *entry;\n\tstruct btrfs_delayed_ref_head *ins;\n\tu64 bytenr;\n\n\tins = rb_entry(node, struct btrfs_delayed_ref_head, href_node);\n\tbytenr = ins->node.bytenr;\n\twhile (*p) {\n\t\tparent_node = *p;\n\t\tentry = rb_entry(parent_node, struct btrfs_delayed_ref_head,\n\t\t\t\t href_node);\n\n\t\tif (bytenr < entry->node.bytenr)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (bytenr > entry->node.bytenr)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\n\trb_link_node(node, parent_node, p);\n\trb_insert_color(node, root);\n\treturn NULL;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"ctree.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"delayed-ref.h\"\n#include \"ctree.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic struct btrfs_delayed_ref_head *htree_insert(struct rb_root *root,\n\t\t\t\t\t\t   struct rb_node *node)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent_node = NULL;\n\tstruct btrfs_delayed_ref_head *entry;\n\tstruct btrfs_delayed_ref_head *ins;\n\tu64 bytenr;\n\n\tins = rb_entry(node, struct btrfs_delayed_ref_head, href_node);\n\tbytenr = ins->node.bytenr;\n\twhile (*p) {\n\t\tparent_node = *p;\n\t\tentry = rb_entry(parent_node, struct btrfs_delayed_ref_head,\n\t\t\t\t href_node);\n\n\t\tif (bytenr < entry->node.bytenr)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (bytenr > entry->node.bytenr)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\n\trb_link_node(node, parent_node, p);\n\trb_insert_color(node, root);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&head_ref->lock"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_add_delayed_data_ref",
          "args": [
            "ref",
            "full_ref",
            "action"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_delayed_node_to_data_ref",
          "args": [
            "ref"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_delayed_node_to_data_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.h",
          "lines": "253-258",
          "snippet": "static inline struct btrfs_delayed_data_ref *\nbtrfs_delayed_node_to_data_ref(struct btrfs_delayed_ref_node *node)\n{\n\tWARN_ON(btrfs_delayed_ref_is_head(node));\n\treturn container_of(node, struct btrfs_delayed_data_ref, node);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct btrfs_delayed_data_ref *\nbtrfs_delayed_node_to_data_ref(struct btrfs_delayed_ref_node *node)\n{\n\tWARN_ON(btrfs_delayed_ref_is_head(node));\n\treturn container_of(node, struct btrfs_delayed_data_ref, node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&ref->refs",
            "1"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&fs_info->tree_mod_seq"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_fstree",
          "args": [
            "ref_root"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "is_fstree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "4180-4186",
          "snippet": "static inline int is_fstree(u64 rootid)\n{\n\tif (rootid == BTRFS_FS_TREE_OBJECTID ||\n\t    (s64)rootid >= (s64)BTRFS_FIRST_FREE_OBJECTID)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_FIRST_FREE_OBJECTID 256ULL",
            "#define BTRFS_FS_TREE_OBJECTID 5ULL"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_FIRST_FREE_OBJECTID 256ULL\n#define BTRFS_FS_TREE_OBJECTID 5ULL\n\nstatic inline int is_fstree(u64 rootid)\n{\n\tif (rootid == BTRFS_FS_TREE_OBJECTID ||\n\t    (s64)rootid >= (s64)BTRFS_FIRST_FREE_OBJECTID)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"delayed-ref.h\"\n#include \"ctree.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstruct kmem_cache *btrfs_delayed_data_ref_cachep;\nstatic noinline struct;\n\nstatic noinline void\nadd_delayed_data_ref(struct btrfs_fs_info *fs_info,\n\t\t     struct btrfs_trans_handle *trans,\n\t\t     struct btrfs_delayed_ref_head *head_ref,\n\t\t     struct btrfs_delayed_ref_node *ref, u64 bytenr,\n\t\t     u64 num_bytes, u64 parent, u64 ref_root, u64 owner,\n\t\t     u64 offset, int action, int no_quota)\n{\n\tstruct btrfs_delayed_ref_node *existing;\n\tstruct btrfs_delayed_data_ref *full_ref;\n\tstruct btrfs_delayed_ref_root *delayed_refs;\n\tu64 seq = 0;\n\n\tif (action == BTRFS_ADD_DELAYED_EXTENT)\n\t\taction = BTRFS_ADD_DELAYED_REF;\n\n\tdelayed_refs = &trans->transaction->delayed_refs;\n\n\tif (is_fstree(ref_root))\n\t\tseq = atomic64_read(&fs_info->tree_mod_seq);\n\n\t/* first set the basic ref node struct up */\n\tatomic_set(&ref->refs, 1);\n\tref->bytenr = bytenr;\n\tref->num_bytes = num_bytes;\n\tref->ref_mod = 1;\n\tref->action = action;\n\tref->is_head = 0;\n\tref->in_tree = 1;\n\tref->no_quota = no_quota;\n\tref->seq = seq;\n\n\tfull_ref = btrfs_delayed_node_to_data_ref(ref);\n\tfull_ref->parent = parent;\n\tfull_ref->root = ref_root;\n\tif (parent)\n\t\tref->type = BTRFS_SHARED_DATA_REF_KEY;\n\telse\n\t\tref->type = BTRFS_EXTENT_DATA_REF_KEY;\n\n\tfull_ref->objectid = owner;\n\tfull_ref->offset = offset;\n\n\ttrace_add_delayed_data_ref(ref, full_ref, action);\n\n\tspin_lock(&head_ref->lock);\n\texisting = tree_insert(&head_ref->ref_root, &ref->rb_node);\n\tif (existing) {\n\t\tupdate_existing_ref(trans, delayed_refs, head_ref, existing,\n\t\t\t\t    ref);\n\t\t/*\n\t\t * we've updated the existing ref, free the newly\n\t\t * allocated ref\n\t\t */\n\t\tkmem_cache_free(btrfs_delayed_data_ref_cachep, full_ref);\n\t} else {\n\t\tatomic_inc(&delayed_refs->num_entries);\n\t\ttrans->delayed_ref_updates++;\n\t}\n\tspin_unlock(&head_ref->lock);\n}"
  },
  {
    "function_name": "add_delayed_tree_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.c",
    "lines": "636-693",
    "snippet": "static noinline void\nadd_delayed_tree_ref(struct btrfs_fs_info *fs_info,\n\t\t     struct btrfs_trans_handle *trans,\n\t\t     struct btrfs_delayed_ref_head *head_ref,\n\t\t     struct btrfs_delayed_ref_node *ref, u64 bytenr,\n\t\t     u64 num_bytes, u64 parent, u64 ref_root, int level,\n\t\t     int action, int no_quota)\n{\n\tstruct btrfs_delayed_ref_node *existing;\n\tstruct btrfs_delayed_tree_ref *full_ref;\n\tstruct btrfs_delayed_ref_root *delayed_refs;\n\tu64 seq = 0;\n\n\tif (action == BTRFS_ADD_DELAYED_EXTENT)\n\t\taction = BTRFS_ADD_DELAYED_REF;\n\n\tif (is_fstree(ref_root))\n\t\tseq = atomic64_read(&fs_info->tree_mod_seq);\n\tdelayed_refs = &trans->transaction->delayed_refs;\n\n\t/* first set the basic ref node struct up */\n\tatomic_set(&ref->refs, 1);\n\tref->bytenr = bytenr;\n\tref->num_bytes = num_bytes;\n\tref->ref_mod = 1;\n\tref->action = action;\n\tref->is_head = 0;\n\tref->in_tree = 1;\n\tref->no_quota = no_quota;\n\tref->seq = seq;\n\n\tfull_ref = btrfs_delayed_node_to_tree_ref(ref);\n\tfull_ref->parent = parent;\n\tfull_ref->root = ref_root;\n\tif (parent)\n\t\tref->type = BTRFS_SHARED_BLOCK_REF_KEY;\n\telse\n\t\tref->type = BTRFS_TREE_BLOCK_REF_KEY;\n\tfull_ref->level = level;\n\n\ttrace_add_delayed_tree_ref(ref, full_ref, action);\n\n\tspin_lock(&head_ref->lock);\n\texisting = tree_insert(&head_ref->ref_root, &ref->rb_node);\n\tif (existing) {\n\t\tupdate_existing_ref(trans, delayed_refs, head_ref, existing,\n\t\t\t\t    ref);\n\t\t/*\n\t\t * we've updated the existing ref, free the newly\n\t\t * allocated ref\n\t\t */\n\t\tkmem_cache_free(btrfs_delayed_tree_ref_cachep, full_ref);\n\t} else {\n\t\tatomic_inc(&delayed_refs->num_entries);\n\t\ttrans->delayed_ref_updates++;\n\t}\n\tspin_unlock(&head_ref->lock);\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"ctree.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *btrfs_delayed_tree_ref_cachep;",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&head_ref->lock"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&delayed_refs->num_entries"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "btrfs_delayed_tree_ref_cachep",
            "full_ref"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_existing_ref",
          "args": [
            "trans",
            "delayed_refs",
            "head_ref",
            "existing",
            "ref"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "update_existing_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.c",
          "lines": "453-485",
          "snippet": "static noinline void\nupdate_existing_ref(struct btrfs_trans_handle *trans,\n\t\t    struct btrfs_delayed_ref_root *delayed_refs,\n\t\t    struct btrfs_delayed_ref_head *head,\n\t\t    struct btrfs_delayed_ref_node *existing,\n\t\t    struct btrfs_delayed_ref_node *update)\n{\n\tif (update->action != existing->action) {\n\t\t/*\n\t\t * this is effectively undoing either an add or a\n\t\t * drop.  We decrement the ref_mod, and if it goes\n\t\t * down to zero we just delete the entry without\n\t\t * every changing the extent allocation tree.\n\t\t */\n\t\texisting->ref_mod--;\n\t\tif (existing->ref_mod == 0)\n\t\t\tdrop_delayed_ref(trans, delayed_refs, head, existing);\n\t\telse\n\t\t\tWARN_ON(existing->type == BTRFS_TREE_BLOCK_REF_KEY ||\n\t\t\t\texisting->type == BTRFS_SHARED_BLOCK_REF_KEY);\n\t} else {\n\t\tWARN_ON(existing->type == BTRFS_TREE_BLOCK_REF_KEY ||\n\t\t\texisting->type == BTRFS_SHARED_BLOCK_REF_KEY);\n\t\t/*\n\t\t * the action on the existing ref matches\n\t\t * the action on the ref we're trying to add.\n\t\t * Bump the ref_mod by one so the backref that\n\t\t * is eventually added/removed has the correct\n\t\t * reference count\n\t\t */\n\t\texisting->ref_mod += update->ref_mod;\n\t}\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"ctree.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"delayed-ref.h\"\n#include \"ctree.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic noinline void\nupdate_existing_ref(struct btrfs_trans_handle *trans,\n\t\t    struct btrfs_delayed_ref_root *delayed_refs,\n\t\t    struct btrfs_delayed_ref_head *head,\n\t\t    struct btrfs_delayed_ref_node *existing,\n\t\t    struct btrfs_delayed_ref_node *update)\n{\n\tif (update->action != existing->action) {\n\t\t/*\n\t\t * this is effectively undoing either an add or a\n\t\t * drop.  We decrement the ref_mod, and if it goes\n\t\t * down to zero we just delete the entry without\n\t\t * every changing the extent allocation tree.\n\t\t */\n\t\texisting->ref_mod--;\n\t\tif (existing->ref_mod == 0)\n\t\t\tdrop_delayed_ref(trans, delayed_refs, head, existing);\n\t\telse\n\t\t\tWARN_ON(existing->type == BTRFS_TREE_BLOCK_REF_KEY ||\n\t\t\t\texisting->type == BTRFS_SHARED_BLOCK_REF_KEY);\n\t} else {\n\t\tWARN_ON(existing->type == BTRFS_TREE_BLOCK_REF_KEY ||\n\t\t\texisting->type == BTRFS_SHARED_BLOCK_REF_KEY);\n\t\t/*\n\t\t * the action on the existing ref matches\n\t\t * the action on the ref we're trying to add.\n\t\t * Bump the ref_mod by one so the backref that\n\t\t * is eventually added/removed has the correct\n\t\t * reference count\n\t\t */\n\t\texisting->ref_mod += update->ref_mod;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_insert",
          "args": [
            "&head_ref->ref_root",
            "&ref->rb_node"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "htree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.c",
          "lines": "169-196",
          "snippet": "static struct btrfs_delayed_ref_head *htree_insert(struct rb_root *root,\n\t\t\t\t\t\t   struct rb_node *node)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent_node = NULL;\n\tstruct btrfs_delayed_ref_head *entry;\n\tstruct btrfs_delayed_ref_head *ins;\n\tu64 bytenr;\n\n\tins = rb_entry(node, struct btrfs_delayed_ref_head, href_node);\n\tbytenr = ins->node.bytenr;\n\twhile (*p) {\n\t\tparent_node = *p;\n\t\tentry = rb_entry(parent_node, struct btrfs_delayed_ref_head,\n\t\t\t\t href_node);\n\n\t\tif (bytenr < entry->node.bytenr)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (bytenr > entry->node.bytenr)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\n\trb_link_node(node, parent_node, p);\n\trb_insert_color(node, root);\n\treturn NULL;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"ctree.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"delayed-ref.h\"\n#include \"ctree.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic struct btrfs_delayed_ref_head *htree_insert(struct rb_root *root,\n\t\t\t\t\t\t   struct rb_node *node)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent_node = NULL;\n\tstruct btrfs_delayed_ref_head *entry;\n\tstruct btrfs_delayed_ref_head *ins;\n\tu64 bytenr;\n\n\tins = rb_entry(node, struct btrfs_delayed_ref_head, href_node);\n\tbytenr = ins->node.bytenr;\n\twhile (*p) {\n\t\tparent_node = *p;\n\t\tentry = rb_entry(parent_node, struct btrfs_delayed_ref_head,\n\t\t\t\t href_node);\n\n\t\tif (bytenr < entry->node.bytenr)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (bytenr > entry->node.bytenr)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\n\trb_link_node(node, parent_node, p);\n\trb_insert_color(node, root);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&head_ref->lock"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_add_delayed_tree_ref",
          "args": [
            "ref",
            "full_ref",
            "action"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_delayed_node_to_tree_ref",
          "args": [
            "ref"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_delayed_node_to_tree_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.h",
          "lines": "246-251",
          "snippet": "static inline struct btrfs_delayed_tree_ref *\nbtrfs_delayed_node_to_tree_ref(struct btrfs_delayed_ref_node *node)\n{\n\tWARN_ON(btrfs_delayed_ref_is_head(node));\n\treturn container_of(node, struct btrfs_delayed_tree_ref, node);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct btrfs_delayed_tree_ref *\nbtrfs_delayed_node_to_tree_ref(struct btrfs_delayed_ref_node *node)\n{\n\tWARN_ON(btrfs_delayed_ref_is_head(node));\n\treturn container_of(node, struct btrfs_delayed_tree_ref, node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&ref->refs",
            "1"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&fs_info->tree_mod_seq"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_fstree",
          "args": [
            "ref_root"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "is_fstree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "4180-4186",
          "snippet": "static inline int is_fstree(u64 rootid)\n{\n\tif (rootid == BTRFS_FS_TREE_OBJECTID ||\n\t    (s64)rootid >= (s64)BTRFS_FIRST_FREE_OBJECTID)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_FIRST_FREE_OBJECTID 256ULL",
            "#define BTRFS_FS_TREE_OBJECTID 5ULL"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_FIRST_FREE_OBJECTID 256ULL\n#define BTRFS_FS_TREE_OBJECTID 5ULL\n\nstatic inline int is_fstree(u64 rootid)\n{\n\tif (rootid == BTRFS_FS_TREE_OBJECTID ||\n\t    (s64)rootid >= (s64)BTRFS_FIRST_FREE_OBJECTID)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"delayed-ref.h\"\n#include \"ctree.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstruct kmem_cache *btrfs_delayed_tree_ref_cachep;\nstatic noinline struct;\n\nstatic noinline void\nadd_delayed_tree_ref(struct btrfs_fs_info *fs_info,\n\t\t     struct btrfs_trans_handle *trans,\n\t\t     struct btrfs_delayed_ref_head *head_ref,\n\t\t     struct btrfs_delayed_ref_node *ref, u64 bytenr,\n\t\t     u64 num_bytes, u64 parent, u64 ref_root, int level,\n\t\t     int action, int no_quota)\n{\n\tstruct btrfs_delayed_ref_node *existing;\n\tstruct btrfs_delayed_tree_ref *full_ref;\n\tstruct btrfs_delayed_ref_root *delayed_refs;\n\tu64 seq = 0;\n\n\tif (action == BTRFS_ADD_DELAYED_EXTENT)\n\t\taction = BTRFS_ADD_DELAYED_REF;\n\n\tif (is_fstree(ref_root))\n\t\tseq = atomic64_read(&fs_info->tree_mod_seq);\n\tdelayed_refs = &trans->transaction->delayed_refs;\n\n\t/* first set the basic ref node struct up */\n\tatomic_set(&ref->refs, 1);\n\tref->bytenr = bytenr;\n\tref->num_bytes = num_bytes;\n\tref->ref_mod = 1;\n\tref->action = action;\n\tref->is_head = 0;\n\tref->in_tree = 1;\n\tref->no_quota = no_quota;\n\tref->seq = seq;\n\n\tfull_ref = btrfs_delayed_node_to_tree_ref(ref);\n\tfull_ref->parent = parent;\n\tfull_ref->root = ref_root;\n\tif (parent)\n\t\tref->type = BTRFS_SHARED_BLOCK_REF_KEY;\n\telse\n\t\tref->type = BTRFS_TREE_BLOCK_REF_KEY;\n\tfull_ref->level = level;\n\n\ttrace_add_delayed_tree_ref(ref, full_ref, action);\n\n\tspin_lock(&head_ref->lock);\n\texisting = tree_insert(&head_ref->ref_root, &ref->rb_node);\n\tif (existing) {\n\t\tupdate_existing_ref(trans, delayed_refs, head_ref, existing,\n\t\t\t\t    ref);\n\t\t/*\n\t\t * we've updated the existing ref, free the newly\n\t\t * allocated ref\n\t\t */\n\t\tkmem_cache_free(btrfs_delayed_tree_ref_cachep, full_ref);\n\t} else {\n\t\tatomic_inc(&delayed_refs->num_entries);\n\t\ttrans->delayed_ref_updates++;\n\t}\n\tspin_unlock(&head_ref->lock);\n}"
  },
  {
    "function_name": "add_delayed_ref_head",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.c",
    "lines": "553-631",
    "snippet": "btrfs_delayed_ref_head *\nadd_delayed_ref_head(struct btrfs_fs_info *fs_info,\n\t\t     struct btrfs_trans_handle *trans,\n\t\t     struct btrfs_delayed_ref_node *ref, u64 bytenr,\n\t\t     u64 num_bytes, int action, int is_data)\n{\n\tstruct btrfs_delayed_ref_head *existing;\n\tstruct btrfs_delayed_ref_head *head_ref = NULL;\n\tstruct btrfs_delayed_ref_root *delayed_refs;\n\tint count_mod = 1;\n\tint must_insert_reserved = 0;\n\n\t/*\n\t * the head node stores the sum of all the mods, so dropping a ref\n\t * should drop the sum in the head node by one.\n\t */\n\tif (action == BTRFS_UPDATE_DELAYED_HEAD)\n\t\tcount_mod = 0;\n\telse if (action == BTRFS_DROP_DELAYED_REF)\n\t\tcount_mod = -1;\n\n\t/*\n\t * BTRFS_ADD_DELAYED_EXTENT means that we need to update\n\t * the reserved accounting when the extent is finally added, or\n\t * if a later modification deletes the delayed ref without ever\n\t * inserting the extent into the extent allocation tree.\n\t * ref->must_insert_reserved is the flag used to record\n\t * that accounting mods are required.\n\t *\n\t * Once we record must_insert_reserved, switch the action to\n\t * BTRFS_ADD_DELAYED_REF because other special casing is not required.\n\t */\n\tif (action == BTRFS_ADD_DELAYED_EXTENT)\n\t\tmust_insert_reserved = 1;\n\telse\n\t\tmust_insert_reserved = 0;\n\n\tdelayed_refs = &trans->transaction->delayed_refs;\n\n\t/* first set the basic ref node struct up */\n\tatomic_set(&ref->refs, 1);\n\tref->bytenr = bytenr;\n\tref->num_bytes = num_bytes;\n\tref->ref_mod = count_mod;\n\tref->type  = 0;\n\tref->action  = 0;\n\tref->is_head = 1;\n\tref->in_tree = 1;\n\tref->seq = 0;\n\n\thead_ref = btrfs_delayed_node_to_head(ref);\n\thead_ref->must_insert_reserved = must_insert_reserved;\n\thead_ref->is_data = is_data;\n\thead_ref->ref_root = RB_ROOT;\n\thead_ref->processing = 0;\n\n\tspin_lock_init(&head_ref->lock);\n\tmutex_init(&head_ref->mutex);\n\n\ttrace_add_delayed_ref_head(ref, head_ref, action);\n\n\texisting = htree_insert(&delayed_refs->href_root,\n\t\t\t\t&head_ref->href_node);\n\tif (existing) {\n\t\tupdate_existing_head_ref(&existing->node, ref);\n\t\t/*\n\t\t * we've updated the existing ref, free the newly\n\t\t * allocated ref\n\t\t */\n\t\tkmem_cache_free(btrfs_delayed_ref_head_cachep, head_ref);\n\t\thead_ref = existing;\n\t} else {\n\t\tdelayed_refs->num_heads++;\n\t\tdelayed_refs->num_heads_ready++;\n\t\tatomic_inc(&delayed_refs->num_entries);\n\t\ttrans->delayed_ref_updates++;\n\t}\n\treturn head_ref;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"ctree.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *btrfs_delayed_ref_head_cachep;",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&delayed_refs->num_entries"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "btrfs_delayed_ref_head_cachep",
            "head_ref"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_existing_head_ref",
          "args": [
            "&existing->node",
            "ref"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "update_existing_head_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.c",
          "lines": "491-546",
          "snippet": "static noinline void\nupdate_existing_head_ref(struct btrfs_delayed_ref_node *existing,\n\t\t\t struct btrfs_delayed_ref_node *update)\n{\n\tstruct btrfs_delayed_ref_head *existing_ref;\n\tstruct btrfs_delayed_ref_head *ref;\n\n\texisting_ref = btrfs_delayed_node_to_head(existing);\n\tref = btrfs_delayed_node_to_head(update);\n\tBUG_ON(existing_ref->is_data != ref->is_data);\n\n\tspin_lock(&existing_ref->lock);\n\tif (ref->must_insert_reserved) {\n\t\t/* if the extent was freed and then\n\t\t * reallocated before the delayed ref\n\t\t * entries were processed, we can end up\n\t\t * with an existing head ref without\n\t\t * the must_insert_reserved flag set.\n\t\t * Set it again here\n\t\t */\n\t\texisting_ref->must_insert_reserved = ref->must_insert_reserved;\n\n\t\t/*\n\t\t * update the num_bytes so we make sure the accounting\n\t\t * is done correctly\n\t\t */\n\t\texisting->num_bytes = update->num_bytes;\n\n\t}\n\n\tif (ref->extent_op) {\n\t\tif (!existing_ref->extent_op) {\n\t\t\texisting_ref->extent_op = ref->extent_op;\n\t\t} else {\n\t\t\tif (ref->extent_op->update_key) {\n\t\t\t\tmemcpy(&existing_ref->extent_op->key,\n\t\t\t\t       &ref->extent_op->key,\n\t\t\t\t       sizeof(ref->extent_op->key));\n\t\t\t\texisting_ref->extent_op->update_key = 1;\n\t\t\t}\n\t\t\tif (ref->extent_op->update_flags) {\n\t\t\t\texisting_ref->extent_op->flags_to_set |=\n\t\t\t\t\tref->extent_op->flags_to_set;\n\t\t\t\texisting_ref->extent_op->update_flags = 1;\n\t\t\t}\n\t\t\tbtrfs_free_delayed_extent_op(ref->extent_op);\n\t\t}\n\t}\n\t/*\n\t * update the reference mod on the head to reflect this new operation,\n\t * only need the lock for this case cause we could be processing it\n\t * currently, for refs we just added we know we're a-ok.\n\t */\n\texisting->ref_mod += update->ref_mod;\n\tspin_unlock(&existing_ref->lock);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"ctree.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"delayed-ref.h\"\n#include \"ctree.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic noinline void\nupdate_existing_head_ref(struct btrfs_delayed_ref_node *existing,\n\t\t\t struct btrfs_delayed_ref_node *update)\n{\n\tstruct btrfs_delayed_ref_head *existing_ref;\n\tstruct btrfs_delayed_ref_head *ref;\n\n\texisting_ref = btrfs_delayed_node_to_head(existing);\n\tref = btrfs_delayed_node_to_head(update);\n\tBUG_ON(existing_ref->is_data != ref->is_data);\n\n\tspin_lock(&existing_ref->lock);\n\tif (ref->must_insert_reserved) {\n\t\t/* if the extent was freed and then\n\t\t * reallocated before the delayed ref\n\t\t * entries were processed, we can end up\n\t\t * with an existing head ref without\n\t\t * the must_insert_reserved flag set.\n\t\t * Set it again here\n\t\t */\n\t\texisting_ref->must_insert_reserved = ref->must_insert_reserved;\n\n\t\t/*\n\t\t * update the num_bytes so we make sure the accounting\n\t\t * is done correctly\n\t\t */\n\t\texisting->num_bytes = update->num_bytes;\n\n\t}\n\n\tif (ref->extent_op) {\n\t\tif (!existing_ref->extent_op) {\n\t\t\texisting_ref->extent_op = ref->extent_op;\n\t\t} else {\n\t\t\tif (ref->extent_op->update_key) {\n\t\t\t\tmemcpy(&existing_ref->extent_op->key,\n\t\t\t\t       &ref->extent_op->key,\n\t\t\t\t       sizeof(ref->extent_op->key));\n\t\t\t\texisting_ref->extent_op->update_key = 1;\n\t\t\t}\n\t\t\tif (ref->extent_op->update_flags) {\n\t\t\t\texisting_ref->extent_op->flags_to_set |=\n\t\t\t\t\tref->extent_op->flags_to_set;\n\t\t\t\texisting_ref->extent_op->update_flags = 1;\n\t\t\t}\n\t\t\tbtrfs_free_delayed_extent_op(ref->extent_op);\n\t\t}\n\t}\n\t/*\n\t * update the reference mod on the head to reflect this new operation,\n\t * only need the lock for this case cause we could be processing it\n\t * currently, for refs we just added we know we're a-ok.\n\t */\n\texisting->ref_mod += update->ref_mod;\n\tspin_unlock(&existing_ref->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "htree_insert",
          "args": [
            "&delayed_refs->href_root",
            "&head_ref->href_node"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "htree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.c",
          "lines": "169-196",
          "snippet": "static struct btrfs_delayed_ref_head *htree_insert(struct rb_root *root,\n\t\t\t\t\t\t   struct rb_node *node)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent_node = NULL;\n\tstruct btrfs_delayed_ref_head *entry;\n\tstruct btrfs_delayed_ref_head *ins;\n\tu64 bytenr;\n\n\tins = rb_entry(node, struct btrfs_delayed_ref_head, href_node);\n\tbytenr = ins->node.bytenr;\n\twhile (*p) {\n\t\tparent_node = *p;\n\t\tentry = rb_entry(parent_node, struct btrfs_delayed_ref_head,\n\t\t\t\t href_node);\n\n\t\tif (bytenr < entry->node.bytenr)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (bytenr > entry->node.bytenr)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\n\trb_link_node(node, parent_node, p);\n\trb_insert_color(node, root);\n\treturn NULL;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"ctree.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"delayed-ref.h\"\n#include \"ctree.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic struct btrfs_delayed_ref_head *htree_insert(struct rb_root *root,\n\t\t\t\t\t\t   struct rb_node *node)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent_node = NULL;\n\tstruct btrfs_delayed_ref_head *entry;\n\tstruct btrfs_delayed_ref_head *ins;\n\tu64 bytenr;\n\n\tins = rb_entry(node, struct btrfs_delayed_ref_head, href_node);\n\tbytenr = ins->node.bytenr;\n\twhile (*p) {\n\t\tparent_node = *p;\n\t\tentry = rb_entry(parent_node, struct btrfs_delayed_ref_head,\n\t\t\t\t href_node);\n\n\t\tif (bytenr < entry->node.bytenr)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (bytenr > entry->node.bytenr)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\n\trb_link_node(node, parent_node, p);\n\trb_insert_color(node, root);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_add_delayed_ref_head",
          "args": [
            "ref",
            "head_ref",
            "action"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&head_ref->mutex"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&head_ref->lock"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_delayed_node_to_head",
          "args": [
            "ref"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_delayed_node_to_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.h",
          "lines": "260-265",
          "snippet": "static inline struct btrfs_delayed_ref_head *\nbtrfs_delayed_node_to_head(struct btrfs_delayed_ref_node *node)\n{\n\tWARN_ON(!btrfs_delayed_ref_is_head(node));\n\treturn container_of(node, struct btrfs_delayed_ref_head, node);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct btrfs_delayed_ref_head *\nbtrfs_delayed_node_to_head(struct btrfs_delayed_ref_node *node)\n{\n\tWARN_ON(!btrfs_delayed_ref_is_head(node));\n\treturn container_of(node, struct btrfs_delayed_ref_head, node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&ref->refs",
            "1"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"delayed-ref.h\"\n#include \"ctree.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstruct kmem_cache *btrfs_delayed_ref_head_cachep;\nstatic noinline struct;\n\nbtrfs_delayed_ref_head *\nadd_delayed_ref_head(struct btrfs_fs_info *fs_info,\n\t\t     struct btrfs_trans_handle *trans,\n\t\t     struct btrfs_delayed_ref_node *ref, u64 bytenr,\n\t\t     u64 num_bytes, int action, int is_data)\n{\n\tstruct btrfs_delayed_ref_head *existing;\n\tstruct btrfs_delayed_ref_head *head_ref = NULL;\n\tstruct btrfs_delayed_ref_root *delayed_refs;\n\tint count_mod = 1;\n\tint must_insert_reserved = 0;\n\n\t/*\n\t * the head node stores the sum of all the mods, so dropping a ref\n\t * should drop the sum in the head node by one.\n\t */\n\tif (action == BTRFS_UPDATE_DELAYED_HEAD)\n\t\tcount_mod = 0;\n\telse if (action == BTRFS_DROP_DELAYED_REF)\n\t\tcount_mod = -1;\n\n\t/*\n\t * BTRFS_ADD_DELAYED_EXTENT means that we need to update\n\t * the reserved accounting when the extent is finally added, or\n\t * if a later modification deletes the delayed ref without ever\n\t * inserting the extent into the extent allocation tree.\n\t * ref->must_insert_reserved is the flag used to record\n\t * that accounting mods are required.\n\t *\n\t * Once we record must_insert_reserved, switch the action to\n\t * BTRFS_ADD_DELAYED_REF because other special casing is not required.\n\t */\n\tif (action == BTRFS_ADD_DELAYED_EXTENT)\n\t\tmust_insert_reserved = 1;\n\telse\n\t\tmust_insert_reserved = 0;\n\n\tdelayed_refs = &trans->transaction->delayed_refs;\n\n\t/* first set the basic ref node struct up */\n\tatomic_set(&ref->refs, 1);\n\tref->bytenr = bytenr;\n\tref->num_bytes = num_bytes;\n\tref->ref_mod = count_mod;\n\tref->type  = 0;\n\tref->action  = 0;\n\tref->is_head = 1;\n\tref->in_tree = 1;\n\tref->seq = 0;\n\n\thead_ref = btrfs_delayed_node_to_head(ref);\n\thead_ref->must_insert_reserved = must_insert_reserved;\n\thead_ref->is_data = is_data;\n\thead_ref->ref_root = RB_ROOT;\n\thead_ref->processing = 0;\n\n\tspin_lock_init(&head_ref->lock);\n\tmutex_init(&head_ref->mutex);\n\n\ttrace_add_delayed_ref_head(ref, head_ref, action);\n\n\texisting = htree_insert(&delayed_refs->href_root,\n\t\t\t\t&head_ref->href_node);\n\tif (existing) {\n\t\tupdate_existing_head_ref(&existing->node, ref);\n\t\t/*\n\t\t * we've updated the existing ref, free the newly\n\t\t * allocated ref\n\t\t */\n\t\tkmem_cache_free(btrfs_delayed_ref_head_cachep, head_ref);\n\t\thead_ref = existing;\n\t} else {\n\t\tdelayed_refs->num_heads++;\n\t\tdelayed_refs->num_heads_ready++;\n\t\tatomic_inc(&delayed_refs->num_entries);\n\t\ttrans->delayed_ref_updates++;\n\t}\n\treturn head_ref;\n}"
  },
  {
    "function_name": "update_existing_head_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.c",
    "lines": "491-546",
    "snippet": "static noinline void\nupdate_existing_head_ref(struct btrfs_delayed_ref_node *existing,\n\t\t\t struct btrfs_delayed_ref_node *update)\n{\n\tstruct btrfs_delayed_ref_head *existing_ref;\n\tstruct btrfs_delayed_ref_head *ref;\n\n\texisting_ref = btrfs_delayed_node_to_head(existing);\n\tref = btrfs_delayed_node_to_head(update);\n\tBUG_ON(existing_ref->is_data != ref->is_data);\n\n\tspin_lock(&existing_ref->lock);\n\tif (ref->must_insert_reserved) {\n\t\t/* if the extent was freed and then\n\t\t * reallocated before the delayed ref\n\t\t * entries were processed, we can end up\n\t\t * with an existing head ref without\n\t\t * the must_insert_reserved flag set.\n\t\t * Set it again here\n\t\t */\n\t\texisting_ref->must_insert_reserved = ref->must_insert_reserved;\n\n\t\t/*\n\t\t * update the num_bytes so we make sure the accounting\n\t\t * is done correctly\n\t\t */\n\t\texisting->num_bytes = update->num_bytes;\n\n\t}\n\n\tif (ref->extent_op) {\n\t\tif (!existing_ref->extent_op) {\n\t\t\texisting_ref->extent_op = ref->extent_op;\n\t\t} else {\n\t\t\tif (ref->extent_op->update_key) {\n\t\t\t\tmemcpy(&existing_ref->extent_op->key,\n\t\t\t\t       &ref->extent_op->key,\n\t\t\t\t       sizeof(ref->extent_op->key));\n\t\t\t\texisting_ref->extent_op->update_key = 1;\n\t\t\t}\n\t\t\tif (ref->extent_op->update_flags) {\n\t\t\t\texisting_ref->extent_op->flags_to_set |=\n\t\t\t\t\tref->extent_op->flags_to_set;\n\t\t\t\texisting_ref->extent_op->update_flags = 1;\n\t\t\t}\n\t\t\tbtrfs_free_delayed_extent_op(ref->extent_op);\n\t\t}\n\t}\n\t/*\n\t * update the reference mod on the head to reflect this new operation,\n\t * only need the lock for this case cause we could be processing it\n\t * currently, for refs we just added we know we're a-ok.\n\t */\n\texisting->ref_mod += update->ref_mod;\n\tspin_unlock(&existing_ref->lock);\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"ctree.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&existing_ref->lock"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_free_delayed_extent_op",
          "args": [
            "ref->extent_op"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_delayed_extent_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.h",
          "lines": "165-170",
          "snippet": "static inline void\nbtrfs_free_delayed_extent_op(struct btrfs_delayed_extent_op *op)\n{\n\tif (op)\n\t\tkmem_cache_free(btrfs_delayed_extent_op_cachep, op);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nbtrfs_free_delayed_extent_op(struct btrfs_delayed_extent_op *op)\n{\n\tif (op)\n\t\tkmem_cache_free(btrfs_delayed_extent_op_cachep, op);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&existing_ref->extent_op->key",
            "&ref->extent_op->key",
            "sizeof(ref->extent_op->key)"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&existing_ref->lock"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "existing_ref->is_data != ref->is_data"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_delayed_node_to_head",
          "args": [
            "update"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_delayed_node_to_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.h",
          "lines": "260-265",
          "snippet": "static inline struct btrfs_delayed_ref_head *\nbtrfs_delayed_node_to_head(struct btrfs_delayed_ref_node *node)\n{\n\tWARN_ON(!btrfs_delayed_ref_is_head(node));\n\treturn container_of(node, struct btrfs_delayed_ref_head, node);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct btrfs_delayed_ref_head *\nbtrfs_delayed_node_to_head(struct btrfs_delayed_ref_node *node)\n{\n\tWARN_ON(!btrfs_delayed_ref_is_head(node));\n\treturn container_of(node, struct btrfs_delayed_ref_head, node);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"delayed-ref.h\"\n#include \"ctree.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic noinline void\nupdate_existing_head_ref(struct btrfs_delayed_ref_node *existing,\n\t\t\t struct btrfs_delayed_ref_node *update)\n{\n\tstruct btrfs_delayed_ref_head *existing_ref;\n\tstruct btrfs_delayed_ref_head *ref;\n\n\texisting_ref = btrfs_delayed_node_to_head(existing);\n\tref = btrfs_delayed_node_to_head(update);\n\tBUG_ON(existing_ref->is_data != ref->is_data);\n\n\tspin_lock(&existing_ref->lock);\n\tif (ref->must_insert_reserved) {\n\t\t/* if the extent was freed and then\n\t\t * reallocated before the delayed ref\n\t\t * entries were processed, we can end up\n\t\t * with an existing head ref without\n\t\t * the must_insert_reserved flag set.\n\t\t * Set it again here\n\t\t */\n\t\texisting_ref->must_insert_reserved = ref->must_insert_reserved;\n\n\t\t/*\n\t\t * update the num_bytes so we make sure the accounting\n\t\t * is done correctly\n\t\t */\n\t\texisting->num_bytes = update->num_bytes;\n\n\t}\n\n\tif (ref->extent_op) {\n\t\tif (!existing_ref->extent_op) {\n\t\t\texisting_ref->extent_op = ref->extent_op;\n\t\t} else {\n\t\t\tif (ref->extent_op->update_key) {\n\t\t\t\tmemcpy(&existing_ref->extent_op->key,\n\t\t\t\t       &ref->extent_op->key,\n\t\t\t\t       sizeof(ref->extent_op->key));\n\t\t\t\texisting_ref->extent_op->update_key = 1;\n\t\t\t}\n\t\t\tif (ref->extent_op->update_flags) {\n\t\t\t\texisting_ref->extent_op->flags_to_set |=\n\t\t\t\t\tref->extent_op->flags_to_set;\n\t\t\t\texisting_ref->extent_op->update_flags = 1;\n\t\t\t}\n\t\t\tbtrfs_free_delayed_extent_op(ref->extent_op);\n\t\t}\n\t}\n\t/*\n\t * update the reference mod on the head to reflect this new operation,\n\t * only need the lock for this case cause we could be processing it\n\t * currently, for refs we just added we know we're a-ok.\n\t */\n\texisting->ref_mod += update->ref_mod;\n\tspin_unlock(&existing_ref->lock);\n}"
  },
  {
    "function_name": "update_existing_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.c",
    "lines": "453-485",
    "snippet": "static noinline void\nupdate_existing_ref(struct btrfs_trans_handle *trans,\n\t\t    struct btrfs_delayed_ref_root *delayed_refs,\n\t\t    struct btrfs_delayed_ref_head *head,\n\t\t    struct btrfs_delayed_ref_node *existing,\n\t\t    struct btrfs_delayed_ref_node *update)\n{\n\tif (update->action != existing->action) {\n\t\t/*\n\t\t * this is effectively undoing either an add or a\n\t\t * drop.  We decrement the ref_mod, and if it goes\n\t\t * down to zero we just delete the entry without\n\t\t * every changing the extent allocation tree.\n\t\t */\n\t\texisting->ref_mod--;\n\t\tif (existing->ref_mod == 0)\n\t\t\tdrop_delayed_ref(trans, delayed_refs, head, existing);\n\t\telse\n\t\t\tWARN_ON(existing->type == BTRFS_TREE_BLOCK_REF_KEY ||\n\t\t\t\texisting->type == BTRFS_SHARED_BLOCK_REF_KEY);\n\t} else {\n\t\tWARN_ON(existing->type == BTRFS_TREE_BLOCK_REF_KEY ||\n\t\t\texisting->type == BTRFS_SHARED_BLOCK_REF_KEY);\n\t\t/*\n\t\t * the action on the existing ref matches\n\t\t * the action on the ref we're trying to add.\n\t\t * Bump the ref_mod by one so the backref that\n\t\t * is eventually added/removed has the correct\n\t\t * reference count\n\t\t */\n\t\texisting->ref_mod += update->ref_mod;\n\t}\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"ctree.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "existing->type == BTRFS_TREE_BLOCK_REF_KEY ||\n\t\t\texisting->type == BTRFS_SHARED_BLOCK_REF_KEY"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "existing->type == BTRFS_TREE_BLOCK_REF_KEY ||\n\t\t\t\texisting->type == BTRFS_SHARED_BLOCK_REF_KEY"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drop_delayed_ref",
          "args": [
            "trans",
            "delayed_refs",
            "head",
            "existing"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "drop_delayed_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.c",
          "lines": "261-278",
          "snippet": "static inline void drop_delayed_ref(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_delayed_ref_root *delayed_refs,\n\t\t\t\t    struct btrfs_delayed_ref_head *head,\n\t\t\t\t    struct btrfs_delayed_ref_node *ref)\n{\n\tif (btrfs_delayed_ref_is_head(ref)) {\n\t\thead = btrfs_delayed_node_to_head(ref);\n\t\trb_erase(&head->href_node, &delayed_refs->href_root);\n\t} else {\n\t\tassert_spin_locked(&head->lock);\n\t\trb_erase(&ref->rb_node, &head->ref_root);\n\t}\n\tref->in_tree = 0;\n\tbtrfs_put_delayed_ref(ref);\n\tatomic_dec(&delayed_refs->num_entries);\n\tif (trans->delayed_ref_updates)\n\t\ttrans->delayed_ref_updates--;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"ctree.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"delayed-ref.h\"\n#include \"ctree.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void drop_delayed_ref(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_delayed_ref_root *delayed_refs,\n\t\t\t\t    struct btrfs_delayed_ref_head *head,\n\t\t\t\t    struct btrfs_delayed_ref_node *ref)\n{\n\tif (btrfs_delayed_ref_is_head(ref)) {\n\t\thead = btrfs_delayed_node_to_head(ref);\n\t\trb_erase(&head->href_node, &delayed_refs->href_root);\n\t} else {\n\t\tassert_spin_locked(&head->lock);\n\t\trb_erase(&ref->rb_node, &head->ref_root);\n\t}\n\tref->in_tree = 0;\n\tbtrfs_put_delayed_ref(ref);\n\tatomic_dec(&delayed_refs->num_entries);\n\tif (trans->delayed_ref_updates)\n\t\ttrans->delayed_ref_updates--;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"delayed-ref.h\"\n#include \"ctree.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic noinline void\nupdate_existing_ref(struct btrfs_trans_handle *trans,\n\t\t    struct btrfs_delayed_ref_root *delayed_refs,\n\t\t    struct btrfs_delayed_ref_head *head,\n\t\t    struct btrfs_delayed_ref_node *existing,\n\t\t    struct btrfs_delayed_ref_node *update)\n{\n\tif (update->action != existing->action) {\n\t\t/*\n\t\t * this is effectively undoing either an add or a\n\t\t * drop.  We decrement the ref_mod, and if it goes\n\t\t * down to zero we just delete the entry without\n\t\t * every changing the extent allocation tree.\n\t\t */\n\t\texisting->ref_mod--;\n\t\tif (existing->ref_mod == 0)\n\t\t\tdrop_delayed_ref(trans, delayed_refs, head, existing);\n\t\telse\n\t\t\tWARN_ON(existing->type == BTRFS_TREE_BLOCK_REF_KEY ||\n\t\t\t\texisting->type == BTRFS_SHARED_BLOCK_REF_KEY);\n\t} else {\n\t\tWARN_ON(existing->type == BTRFS_TREE_BLOCK_REF_KEY ||\n\t\t\texisting->type == BTRFS_SHARED_BLOCK_REF_KEY);\n\t\t/*\n\t\t * the action on the existing ref matches\n\t\t * the action on the ref we're trying to add.\n\t\t * Bump the ref_mod by one so the backref that\n\t\t * is eventually added/removed has the correct\n\t\t * reference count\n\t\t */\n\t\texisting->ref_mod += update->ref_mod;\n\t}\n}"
  },
  {
    "function_name": "btrfs_select_ref_head",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.c",
    "lines": "397-443",
    "snippet": "struct btrfs_delayed_ref_head *\nbtrfs_select_ref_head(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_delayed_ref_root *delayed_refs;\n\tstruct btrfs_delayed_ref_head *head;\n\tu64 start;\n\tbool loop = false;\n\n\tdelayed_refs = &trans->transaction->delayed_refs;\n\nagain:\n\tstart = delayed_refs->run_delayed_start;\n\thead = find_ref_head(&delayed_refs->href_root, start, 1);\n\tif (!head && !loop) {\n\t\tdelayed_refs->run_delayed_start = 0;\n\t\tstart = 0;\n\t\tloop = true;\n\t\thead = find_ref_head(&delayed_refs->href_root, start, 1);\n\t\tif (!head)\n\t\t\treturn NULL;\n\t} else if (!head && loop) {\n\t\treturn NULL;\n\t}\n\n\twhile (head->processing) {\n\t\tstruct rb_node *node;\n\n\t\tnode = rb_next(&head->href_node);\n\t\tif (!node) {\n\t\t\tif (loop)\n\t\t\t\treturn NULL;\n\t\t\tdelayed_refs->run_delayed_start = 0;\n\t\t\tstart = 0;\n\t\t\tloop = true;\n\t\t\tgoto again;\n\t\t}\n\t\thead = rb_entry(node, struct btrfs_delayed_ref_head,\n\t\t\t\thref_node);\n\t}\n\n\thead->processing = 1;\n\tWARN_ON(delayed_refs->num_heads_ready == 0);\n\tdelayed_refs->num_heads_ready--;\n\tdelayed_refs->run_delayed_start = head->node.bytenr +\n\t\thead->node.num_bytes;\n\treturn head;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"ctree.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "delayed_refs->num_heads_ready == 0"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structbtrfs_delayed_ref_head",
            "href_node"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "&head->href_node"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_ref_head",
          "args": [
            "&delayed_refs->href_root",
            "start",
            "1"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "find_ref_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.c",
          "lines": "204-235",
          "snippet": "static struct btrfs_delayed_ref_head *\nfind_ref_head(struct rb_root *root, u64 bytenr,\n\t      int return_bigger)\n{\n\tstruct rb_node *n;\n\tstruct btrfs_delayed_ref_head *entry;\n\n\tn = root->rb_node;\n\tentry = NULL;\n\twhile (n) {\n\t\tentry = rb_entry(n, struct btrfs_delayed_ref_head, href_node);\n\n\t\tif (bytenr < entry->node.bytenr)\n\t\t\tn = n->rb_left;\n\t\telse if (bytenr > entry->node.bytenr)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\tif (entry && return_bigger) {\n\t\tif (bytenr > entry->node.bytenr) {\n\t\t\tn = rb_next(&entry->href_node);\n\t\t\tif (!n)\n\t\t\t\tn = rb_first(root);\n\t\t\tentry = rb_entry(n, struct btrfs_delayed_ref_head,\n\t\t\t\t\t href_node);\n\t\t\treturn entry;\n\t\t}\n\t\treturn entry;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"ctree.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"delayed-ref.h\"\n#include \"ctree.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic struct btrfs_delayed_ref_head *\nfind_ref_head(struct rb_root *root, u64 bytenr,\n\t      int return_bigger)\n{\n\tstruct rb_node *n;\n\tstruct btrfs_delayed_ref_head *entry;\n\n\tn = root->rb_node;\n\tentry = NULL;\n\twhile (n) {\n\t\tentry = rb_entry(n, struct btrfs_delayed_ref_head, href_node);\n\n\t\tif (bytenr < entry->node.bytenr)\n\t\t\tn = n->rb_left;\n\t\telse if (bytenr > entry->node.bytenr)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\tif (entry && return_bigger) {\n\t\tif (bytenr > entry->node.bytenr) {\n\t\t\tn = rb_next(&entry->href_node);\n\t\t\tif (!n)\n\t\t\t\tn = rb_first(root);\n\t\t\tentry = rb_entry(n, struct btrfs_delayed_ref_head,\n\t\t\t\t\t href_node);\n\t\t\treturn entry;\n\t\t}\n\t\treturn entry;\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"delayed-ref.h\"\n#include \"ctree.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_delayed_ref_head *\nbtrfs_select_ref_head(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_delayed_ref_root *delayed_refs;\n\tstruct btrfs_delayed_ref_head *head;\n\tu64 start;\n\tbool loop = false;\n\n\tdelayed_refs = &trans->transaction->delayed_refs;\n\nagain:\n\tstart = delayed_refs->run_delayed_start;\n\thead = find_ref_head(&delayed_refs->href_root, start, 1);\n\tif (!head && !loop) {\n\t\tdelayed_refs->run_delayed_start = 0;\n\t\tstart = 0;\n\t\tloop = true;\n\t\thead = find_ref_head(&delayed_refs->href_root, start, 1);\n\t\tif (!head)\n\t\t\treturn NULL;\n\t} else if (!head && loop) {\n\t\treturn NULL;\n\t}\n\n\twhile (head->processing) {\n\t\tstruct rb_node *node;\n\n\t\tnode = rb_next(&head->href_node);\n\t\tif (!node) {\n\t\t\tif (loop)\n\t\t\t\treturn NULL;\n\t\t\tdelayed_refs->run_delayed_start = 0;\n\t\t\tstart = 0;\n\t\t\tloop = true;\n\t\t\tgoto again;\n\t\t}\n\t\thead = rb_entry(node, struct btrfs_delayed_ref_head,\n\t\t\t\thref_node);\n\t}\n\n\thead->processing = 1;\n\tWARN_ON(delayed_refs->num_heads_ready == 0);\n\tdelayed_refs->num_heads_ready--;\n\tdelayed_refs->run_delayed_start = head->node.bytenr +\n\t\thead->node.num_bytes;\n\treturn head;\n}"
  },
  {
    "function_name": "btrfs_check_delayed_seq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.c",
    "lines": "373-395",
    "snippet": "int btrfs_check_delayed_seq(struct btrfs_fs_info *fs_info,\n\t\t\t    struct btrfs_delayed_ref_root *delayed_refs,\n\t\t\t    u64 seq)\n{\n\tstruct seq_list *elem;\n\tint ret = 0;\n\n\tspin_lock(&fs_info->tree_mod_seq_lock);\n\tif (!list_empty(&fs_info->tree_mod_seq_list)) {\n\t\telem = list_first_entry(&fs_info->tree_mod_seq_list,\n\t\t\t\t\tstruct seq_list, list);\n\t\tif (seq >= elem->seq) {\n\t\t\tpr_debug(\"holding back delayed_ref %#x.%x, lowest is %#x.%x (%p)\\n\",\n\t\t\t\t (u32)(seq >> 32), (u32)seq,\n\t\t\t\t (u32)(elem->seq >> 32), (u32)elem->seq,\n\t\t\t\t delayed_refs);\n\t\t\tret = 1;\n\t\t}\n\t}\n\n\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"ctree.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->tree_mod_seq_lock"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"holding back delayed_ref %#x.%x, lowest is %#x.%x (%p)\\n\"",
            "(u32)(seq >> 32)",
            "(u32)seq",
            "(u32)(elem->seq >> 32)",
            "(u32)elem->seq",
            "delayed_refs"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "elem->seq >> 32"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "seq >> 32"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&fs_info->tree_mod_seq_list",
            "structseq_list",
            "list"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&fs_info->tree_mod_seq_list"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->tree_mod_seq_lock"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"delayed-ref.h\"\n#include \"ctree.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_check_delayed_seq(struct btrfs_fs_info *fs_info,\n\t\t\t    struct btrfs_delayed_ref_root *delayed_refs,\n\t\t\t    u64 seq)\n{\n\tstruct seq_list *elem;\n\tint ret = 0;\n\n\tspin_lock(&fs_info->tree_mod_seq_lock);\n\tif (!list_empty(&fs_info->tree_mod_seq_list)) {\n\t\telem = list_first_entry(&fs_info->tree_mod_seq_list,\n\t\t\t\t\tstruct seq_list, list);\n\t\tif (seq >= elem->seq) {\n\t\t\tpr_debug(\"holding back delayed_ref %#x.%x, lowest is %#x.%x (%p)\\n\",\n\t\t\t\t (u32)(seq >> 32), (u32)seq,\n\t\t\t\t (u32)(elem->seq >> 32), (u32)elem->seq,\n\t\t\t\t delayed_refs);\n\t\t\tret = 1;\n\t\t}\n\t}\n\n\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_merge_delayed_refs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.c",
    "lines": "331-371",
    "snippet": "void btrfs_merge_delayed_refs(struct btrfs_trans_handle *trans,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_delayed_ref_root *delayed_refs,\n\t\t\t      struct btrfs_delayed_ref_head *head)\n{\n\tstruct rb_node *node;\n\tu64 seq = 0;\n\n\tassert_spin_locked(&head->lock);\n\t/*\n\t * We don't have too much refs to merge in the case of delayed data\n\t * refs.\n\t */\n\tif (head->is_data)\n\t\treturn;\n\n\tspin_lock(&fs_info->tree_mod_seq_lock);\n\tif (!list_empty(&fs_info->tree_mod_seq_list)) {\n\t\tstruct seq_list *elem;\n\n\t\telem = list_first_entry(&fs_info->tree_mod_seq_list,\n\t\t\t\t\tstruct seq_list, list);\n\t\tseq = elem->seq;\n\t}\n\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\n\tnode = rb_first(&head->ref_root);\n\twhile (node) {\n\t\tstruct btrfs_delayed_ref_node *ref;\n\n\t\tref = rb_entry(node, struct btrfs_delayed_ref_node,\n\t\t\t       rb_node);\n\t\t/* We can't merge refs that are outside of our seq count */\n\t\tif (seq && ref->seq >= seq)\n\t\t\tbreak;\n\t\tif (merge_ref(trans, delayed_refs, head, ref, seq))\n\t\t\tnode = rb_first(&head->ref_root);\n\t\telse\n\t\t\tnode = rb_next(&ref->rb_node);\n\t}\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"ctree.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "&ref->rb_node"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&head->ref_root"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "merge_ref",
          "args": [
            "trans",
            "delayed_refs",
            "head",
            "ref",
            "seq"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "merge_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.c",
          "lines": "280-329",
          "snippet": "static int merge_ref(struct btrfs_trans_handle *trans,\n\t\t     struct btrfs_delayed_ref_root *delayed_refs,\n\t\t     struct btrfs_delayed_ref_head *head,\n\t\t     struct btrfs_delayed_ref_node *ref, u64 seq)\n{\n\tstruct rb_node *node;\n\tint mod = 0;\n\tint done = 0;\n\n\tnode = rb_next(&ref->rb_node);\n\twhile (!done && node) {\n\t\tstruct btrfs_delayed_ref_node *next;\n\n\t\tnext = rb_entry(node, struct btrfs_delayed_ref_node, rb_node);\n\t\tnode = rb_next(node);\n\t\tif (seq && next->seq >= seq)\n\t\t\tbreak;\n\t\tif (comp_entry(ref, next, 0))\n\t\t\tcontinue;\n\n\t\tif (ref->action == next->action) {\n\t\t\tmod = next->ref_mod;\n\t\t} else {\n\t\t\tif (ref->ref_mod < next->ref_mod) {\n\t\t\t\tstruct btrfs_delayed_ref_node *tmp;\n\n\t\t\t\ttmp = ref;\n\t\t\t\tref = next;\n\t\t\t\tnext = tmp;\n\t\t\t\tdone = 1;\n\t\t\t}\n\t\t\tmod = -next->ref_mod;\n\t\t}\n\n\t\tdrop_delayed_ref(trans, delayed_refs, head, next);\n\t\tref->ref_mod += mod;\n\t\tif (ref->ref_mod == 0) {\n\t\t\tdrop_delayed_ref(trans, delayed_refs, head, ref);\n\t\t\tdone = 1;\n\t\t} else {\n\t\t\t/*\n\t\t\t * You can't have multiples of the same ref on a tree\n\t\t\t * block.\n\t\t\t */\n\t\t\tWARN_ON(ref->type == BTRFS_TREE_BLOCK_REF_KEY ||\n\t\t\t\tref->type == BTRFS_SHARED_BLOCK_REF_KEY);\n\t\t}\n\t}\n\treturn done;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"ctree.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"delayed-ref.h\"\n#include \"ctree.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic int merge_ref(struct btrfs_trans_handle *trans,\n\t\t     struct btrfs_delayed_ref_root *delayed_refs,\n\t\t     struct btrfs_delayed_ref_head *head,\n\t\t     struct btrfs_delayed_ref_node *ref, u64 seq)\n{\n\tstruct rb_node *node;\n\tint mod = 0;\n\tint done = 0;\n\n\tnode = rb_next(&ref->rb_node);\n\twhile (!done && node) {\n\t\tstruct btrfs_delayed_ref_node *next;\n\n\t\tnext = rb_entry(node, struct btrfs_delayed_ref_node, rb_node);\n\t\tnode = rb_next(node);\n\t\tif (seq && next->seq >= seq)\n\t\t\tbreak;\n\t\tif (comp_entry(ref, next, 0))\n\t\t\tcontinue;\n\n\t\tif (ref->action == next->action) {\n\t\t\tmod = next->ref_mod;\n\t\t} else {\n\t\t\tif (ref->ref_mod < next->ref_mod) {\n\t\t\t\tstruct btrfs_delayed_ref_node *tmp;\n\n\t\t\t\ttmp = ref;\n\t\t\t\tref = next;\n\t\t\t\tnext = tmp;\n\t\t\t\tdone = 1;\n\t\t\t}\n\t\t\tmod = -next->ref_mod;\n\t\t}\n\n\t\tdrop_delayed_ref(trans, delayed_refs, head, next);\n\t\tref->ref_mod += mod;\n\t\tif (ref->ref_mod == 0) {\n\t\t\tdrop_delayed_ref(trans, delayed_refs, head, ref);\n\t\t\tdone = 1;\n\t\t} else {\n\t\t\t/*\n\t\t\t * You can't have multiples of the same ref on a tree\n\t\t\t * block.\n\t\t\t */\n\t\t\tWARN_ON(ref->type == BTRFS_TREE_BLOCK_REF_KEY ||\n\t\t\t\tref->type == BTRFS_SHARED_BLOCK_REF_KEY);\n\t\t}\n\t}\n\treturn done;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structbtrfs_delayed_ref_node",
            "rb_node"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&head->ref_root"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->tree_mod_seq_lock"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&fs_info->tree_mod_seq_list",
            "structseq_list",
            "list"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&fs_info->tree_mod_seq_list"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->tree_mod_seq_lock"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&head->lock"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"delayed-ref.h\"\n#include \"ctree.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_merge_delayed_refs(struct btrfs_trans_handle *trans,\n\t\t\t      struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_delayed_ref_root *delayed_refs,\n\t\t\t      struct btrfs_delayed_ref_head *head)\n{\n\tstruct rb_node *node;\n\tu64 seq = 0;\n\n\tassert_spin_locked(&head->lock);\n\t/*\n\t * We don't have too much refs to merge in the case of delayed data\n\t * refs.\n\t */\n\tif (head->is_data)\n\t\treturn;\n\n\tspin_lock(&fs_info->tree_mod_seq_lock);\n\tif (!list_empty(&fs_info->tree_mod_seq_list)) {\n\t\tstruct seq_list *elem;\n\n\t\telem = list_first_entry(&fs_info->tree_mod_seq_list,\n\t\t\t\t\tstruct seq_list, list);\n\t\tseq = elem->seq;\n\t}\n\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\n\tnode = rb_first(&head->ref_root);\n\twhile (node) {\n\t\tstruct btrfs_delayed_ref_node *ref;\n\n\t\tref = rb_entry(node, struct btrfs_delayed_ref_node,\n\t\t\t       rb_node);\n\t\t/* We can't merge refs that are outside of our seq count */\n\t\tif (seq && ref->seq >= seq)\n\t\t\tbreak;\n\t\tif (merge_ref(trans, delayed_refs, head, ref, seq))\n\t\t\tnode = rb_first(&head->ref_root);\n\t\telse\n\t\t\tnode = rb_next(&ref->rb_node);\n\t}\n}"
  },
  {
    "function_name": "merge_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.c",
    "lines": "280-329",
    "snippet": "static int merge_ref(struct btrfs_trans_handle *trans,\n\t\t     struct btrfs_delayed_ref_root *delayed_refs,\n\t\t     struct btrfs_delayed_ref_head *head,\n\t\t     struct btrfs_delayed_ref_node *ref, u64 seq)\n{\n\tstruct rb_node *node;\n\tint mod = 0;\n\tint done = 0;\n\n\tnode = rb_next(&ref->rb_node);\n\twhile (!done && node) {\n\t\tstruct btrfs_delayed_ref_node *next;\n\n\t\tnext = rb_entry(node, struct btrfs_delayed_ref_node, rb_node);\n\t\tnode = rb_next(node);\n\t\tif (seq && next->seq >= seq)\n\t\t\tbreak;\n\t\tif (comp_entry(ref, next, 0))\n\t\t\tcontinue;\n\n\t\tif (ref->action == next->action) {\n\t\t\tmod = next->ref_mod;\n\t\t} else {\n\t\t\tif (ref->ref_mod < next->ref_mod) {\n\t\t\t\tstruct btrfs_delayed_ref_node *tmp;\n\n\t\t\t\ttmp = ref;\n\t\t\t\tref = next;\n\t\t\t\tnext = tmp;\n\t\t\t\tdone = 1;\n\t\t\t}\n\t\t\tmod = -next->ref_mod;\n\t\t}\n\n\t\tdrop_delayed_ref(trans, delayed_refs, head, next);\n\t\tref->ref_mod += mod;\n\t\tif (ref->ref_mod == 0) {\n\t\t\tdrop_delayed_ref(trans, delayed_refs, head, ref);\n\t\t\tdone = 1;\n\t\t} else {\n\t\t\t/*\n\t\t\t * You can't have multiples of the same ref on a tree\n\t\t\t * block.\n\t\t\t */\n\t\t\tWARN_ON(ref->type == BTRFS_TREE_BLOCK_REF_KEY ||\n\t\t\t\tref->type == BTRFS_SHARED_BLOCK_REF_KEY);\n\t\t}\n\t}\n\treturn done;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"ctree.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ref->type == BTRFS_TREE_BLOCK_REF_KEY ||\n\t\t\t\tref->type == BTRFS_SHARED_BLOCK_REF_KEY"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drop_delayed_ref",
          "args": [
            "trans",
            "delayed_refs",
            "head",
            "ref"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "drop_delayed_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.c",
          "lines": "261-278",
          "snippet": "static inline void drop_delayed_ref(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_delayed_ref_root *delayed_refs,\n\t\t\t\t    struct btrfs_delayed_ref_head *head,\n\t\t\t\t    struct btrfs_delayed_ref_node *ref)\n{\n\tif (btrfs_delayed_ref_is_head(ref)) {\n\t\thead = btrfs_delayed_node_to_head(ref);\n\t\trb_erase(&head->href_node, &delayed_refs->href_root);\n\t} else {\n\t\tassert_spin_locked(&head->lock);\n\t\trb_erase(&ref->rb_node, &head->ref_root);\n\t}\n\tref->in_tree = 0;\n\tbtrfs_put_delayed_ref(ref);\n\tatomic_dec(&delayed_refs->num_entries);\n\tif (trans->delayed_ref_updates)\n\t\ttrans->delayed_ref_updates--;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"ctree.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"delayed-ref.h\"\n#include \"ctree.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void drop_delayed_ref(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_delayed_ref_root *delayed_refs,\n\t\t\t\t    struct btrfs_delayed_ref_head *head,\n\t\t\t\t    struct btrfs_delayed_ref_node *ref)\n{\n\tif (btrfs_delayed_ref_is_head(ref)) {\n\t\thead = btrfs_delayed_node_to_head(ref);\n\t\trb_erase(&head->href_node, &delayed_refs->href_root);\n\t} else {\n\t\tassert_spin_locked(&head->lock);\n\t\trb_erase(&ref->rb_node, &head->ref_root);\n\t}\n\tref->in_tree = 0;\n\tbtrfs_put_delayed_ref(ref);\n\tatomic_dec(&delayed_refs->num_entries);\n\tif (trans->delayed_ref_updates)\n\t\ttrans->delayed_ref_updates--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "comp_entry",
          "args": [
            "ref",
            "next",
            "0"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "comp_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.c",
          "lines": "91-132",
          "snippet": "static int comp_entry(struct btrfs_delayed_ref_node *ref2,\n\t\t      struct btrfs_delayed_ref_node *ref1,\n\t\t      bool compare_seq)\n{\n\tif (ref1->bytenr < ref2->bytenr)\n\t\treturn -1;\n\tif (ref1->bytenr > ref2->bytenr)\n\t\treturn 1;\n\tif (ref1->is_head && ref2->is_head)\n\t\treturn 0;\n\tif (ref2->is_head)\n\t\treturn -1;\n\tif (ref1->is_head)\n\t\treturn 1;\n\tif (ref1->type < ref2->type)\n\t\treturn -1;\n\tif (ref1->type > ref2->type)\n\t\treturn 1;\n\tif (ref1->no_quota > ref2->no_quota)\n\t\treturn 1;\n\tif (ref1->no_quota < ref2->no_quota)\n\t\treturn -1;\n\t/* merging of sequenced refs is not allowed */\n\tif (compare_seq) {\n\t\tif (ref1->seq < ref2->seq)\n\t\t\treturn -1;\n\t\tif (ref1->seq > ref2->seq)\n\t\t\treturn 1;\n\t}\n\tif (ref1->type == BTRFS_TREE_BLOCK_REF_KEY ||\n\t    ref1->type == BTRFS_SHARED_BLOCK_REF_KEY) {\n\t\treturn comp_tree_refs(btrfs_delayed_node_to_tree_ref(ref2),\n\t\t\t\t      btrfs_delayed_node_to_tree_ref(ref1),\n\t\t\t\t      ref1->type);\n\t} else if (ref1->type == BTRFS_EXTENT_DATA_REF_KEY ||\n\t\t   ref1->type == BTRFS_SHARED_DATA_REF_KEY) {\n\t\treturn comp_data_refs(btrfs_delayed_node_to_data_ref(ref2),\n\t\t\t\t      btrfs_delayed_node_to_data_ref(ref1));\n\t}\n\tBUG();\n\treturn 0;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"ctree.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"delayed-ref.h\"\n#include \"ctree.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic int comp_entry(struct btrfs_delayed_ref_node *ref2,\n\t\t      struct btrfs_delayed_ref_node *ref1,\n\t\t      bool compare_seq)\n{\n\tif (ref1->bytenr < ref2->bytenr)\n\t\treturn -1;\n\tif (ref1->bytenr > ref2->bytenr)\n\t\treturn 1;\n\tif (ref1->is_head && ref2->is_head)\n\t\treturn 0;\n\tif (ref2->is_head)\n\t\treturn -1;\n\tif (ref1->is_head)\n\t\treturn 1;\n\tif (ref1->type < ref2->type)\n\t\treturn -1;\n\tif (ref1->type > ref2->type)\n\t\treturn 1;\n\tif (ref1->no_quota > ref2->no_quota)\n\t\treturn 1;\n\tif (ref1->no_quota < ref2->no_quota)\n\t\treturn -1;\n\t/* merging of sequenced refs is not allowed */\n\tif (compare_seq) {\n\t\tif (ref1->seq < ref2->seq)\n\t\t\treturn -1;\n\t\tif (ref1->seq > ref2->seq)\n\t\t\treturn 1;\n\t}\n\tif (ref1->type == BTRFS_TREE_BLOCK_REF_KEY ||\n\t    ref1->type == BTRFS_SHARED_BLOCK_REF_KEY) {\n\t\treturn comp_tree_refs(btrfs_delayed_node_to_tree_ref(ref2),\n\t\t\t\t      btrfs_delayed_node_to_tree_ref(ref1),\n\t\t\t\t      ref1->type);\n\t} else if (ref1->type == BTRFS_EXTENT_DATA_REF_KEY ||\n\t\t   ref1->type == BTRFS_SHARED_DATA_REF_KEY) {\n\t\treturn comp_data_refs(btrfs_delayed_node_to_data_ref(ref2),\n\t\t\t\t      btrfs_delayed_node_to_data_ref(ref1));\n\t}\n\tBUG();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "node"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structbtrfs_delayed_ref_node",
            "rb_node"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "&ref->rb_node"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"delayed-ref.h\"\n#include \"ctree.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic int merge_ref(struct btrfs_trans_handle *trans,\n\t\t     struct btrfs_delayed_ref_root *delayed_refs,\n\t\t     struct btrfs_delayed_ref_head *head,\n\t\t     struct btrfs_delayed_ref_node *ref, u64 seq)\n{\n\tstruct rb_node *node;\n\tint mod = 0;\n\tint done = 0;\n\n\tnode = rb_next(&ref->rb_node);\n\twhile (!done && node) {\n\t\tstruct btrfs_delayed_ref_node *next;\n\n\t\tnext = rb_entry(node, struct btrfs_delayed_ref_node, rb_node);\n\t\tnode = rb_next(node);\n\t\tif (seq && next->seq >= seq)\n\t\t\tbreak;\n\t\tif (comp_entry(ref, next, 0))\n\t\t\tcontinue;\n\n\t\tif (ref->action == next->action) {\n\t\t\tmod = next->ref_mod;\n\t\t} else {\n\t\t\tif (ref->ref_mod < next->ref_mod) {\n\t\t\t\tstruct btrfs_delayed_ref_node *tmp;\n\n\t\t\t\ttmp = ref;\n\t\t\t\tref = next;\n\t\t\t\tnext = tmp;\n\t\t\t\tdone = 1;\n\t\t\t}\n\t\t\tmod = -next->ref_mod;\n\t\t}\n\n\t\tdrop_delayed_ref(trans, delayed_refs, head, next);\n\t\tref->ref_mod += mod;\n\t\tif (ref->ref_mod == 0) {\n\t\t\tdrop_delayed_ref(trans, delayed_refs, head, ref);\n\t\t\tdone = 1;\n\t\t} else {\n\t\t\t/*\n\t\t\t * You can't have multiples of the same ref on a tree\n\t\t\t * block.\n\t\t\t */\n\t\t\tWARN_ON(ref->type == BTRFS_TREE_BLOCK_REF_KEY ||\n\t\t\t\tref->type == BTRFS_SHARED_BLOCK_REF_KEY);\n\t\t}\n\t}\n\treturn done;\n}"
  },
  {
    "function_name": "drop_delayed_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.c",
    "lines": "261-278",
    "snippet": "static inline void drop_delayed_ref(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_delayed_ref_root *delayed_refs,\n\t\t\t\t    struct btrfs_delayed_ref_head *head,\n\t\t\t\t    struct btrfs_delayed_ref_node *ref)\n{\n\tif (btrfs_delayed_ref_is_head(ref)) {\n\t\thead = btrfs_delayed_node_to_head(ref);\n\t\trb_erase(&head->href_node, &delayed_refs->href_root);\n\t} else {\n\t\tassert_spin_locked(&head->lock);\n\t\trb_erase(&ref->rb_node, &head->ref_root);\n\t}\n\tref->in_tree = 0;\n\tbtrfs_put_delayed_ref(ref);\n\tatomic_dec(&delayed_refs->num_entries);\n\tif (trans->delayed_ref_updates)\n\t\ttrans->delayed_ref_updates--;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"ctree.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&delayed_refs->num_entries"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_put_delayed_ref",
          "args": [
            "ref"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_delayed_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.h",
          "lines": "172-193",
          "snippet": "static inline void btrfs_put_delayed_ref(struct btrfs_delayed_ref_node *ref)\n{\n\tWARN_ON(atomic_read(&ref->refs) == 0);\n\tif (atomic_dec_and_test(&ref->refs)) {\n\t\tWARN_ON(ref->in_tree);\n\t\tswitch (ref->type) {\n\t\tcase BTRFS_TREE_BLOCK_REF_KEY:\n\t\tcase BTRFS_SHARED_BLOCK_REF_KEY:\n\t\t\tkmem_cache_free(btrfs_delayed_tree_ref_cachep, ref);\n\t\t\tbreak;\n\t\tcase BTRFS_EXTENT_DATA_REF_KEY:\n\t\tcase BTRFS_SHARED_DATA_REF_KEY:\n\t\t\tkmem_cache_free(btrfs_delayed_data_ref_cachep, ref);\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tkmem_cache_free(btrfs_delayed_ref_head_cachep, ref);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void btrfs_put_delayed_ref(struct btrfs_delayed_ref_node *ref)\n{\n\tWARN_ON(atomic_read(&ref->refs) == 0);\n\tif (atomic_dec_and_test(&ref->refs)) {\n\t\tWARN_ON(ref->in_tree);\n\t\tswitch (ref->type) {\n\t\tcase BTRFS_TREE_BLOCK_REF_KEY:\n\t\tcase BTRFS_SHARED_BLOCK_REF_KEY:\n\t\t\tkmem_cache_free(btrfs_delayed_tree_ref_cachep, ref);\n\t\t\tbreak;\n\t\tcase BTRFS_EXTENT_DATA_REF_KEY:\n\t\tcase BTRFS_SHARED_DATA_REF_KEY:\n\t\t\tkmem_cache_free(btrfs_delayed_data_ref_cachep, ref);\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tkmem_cache_free(btrfs_delayed_ref_head_cachep, ref);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&ref->rb_node",
            "&head->ref_root"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&head->lock"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&head->href_node",
            "&delayed_refs->href_root"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_delayed_node_to_head",
          "args": [
            "ref"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_delayed_node_to_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.h",
          "lines": "260-265",
          "snippet": "static inline struct btrfs_delayed_ref_head *\nbtrfs_delayed_node_to_head(struct btrfs_delayed_ref_node *node)\n{\n\tWARN_ON(!btrfs_delayed_ref_is_head(node));\n\treturn container_of(node, struct btrfs_delayed_ref_head, node);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct btrfs_delayed_ref_head *\nbtrfs_delayed_node_to_head(struct btrfs_delayed_ref_node *node)\n{\n\tWARN_ON(!btrfs_delayed_ref_is_head(node));\n\treturn container_of(node, struct btrfs_delayed_ref_head, node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_delayed_ref_is_head",
          "args": [
            "ref"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_delayed_ref_is_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.h",
          "lines": "238-241",
          "snippet": "static int btrfs_delayed_ref_is_head(struct btrfs_delayed_ref_node *node)\n{\n\treturn node->is_head;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static int btrfs_delayed_ref_is_head(struct btrfs_delayed_ref_node *node)\n{\n\treturn node->is_head;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"delayed-ref.h\"\n#include \"ctree.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void drop_delayed_ref(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_delayed_ref_root *delayed_refs,\n\t\t\t\t    struct btrfs_delayed_ref_head *head,\n\t\t\t\t    struct btrfs_delayed_ref_node *ref)\n{\n\tif (btrfs_delayed_ref_is_head(ref)) {\n\t\thead = btrfs_delayed_node_to_head(ref);\n\t\trb_erase(&head->href_node, &delayed_refs->href_root);\n\t} else {\n\t\tassert_spin_locked(&head->lock);\n\t\trb_erase(&ref->rb_node, &head->ref_root);\n\t}\n\tref->in_tree = 0;\n\tbtrfs_put_delayed_ref(ref);\n\tatomic_dec(&delayed_refs->num_entries);\n\tif (trans->delayed_ref_updates)\n\t\ttrans->delayed_ref_updates--;\n}"
  },
  {
    "function_name": "btrfs_delayed_ref_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.c",
    "lines": "237-259",
    "snippet": "int btrfs_delayed_ref_lock(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_delayed_ref_head *head)\n{\n\tstruct btrfs_delayed_ref_root *delayed_refs;\n\n\tdelayed_refs = &trans->transaction->delayed_refs;\n\tassert_spin_locked(&delayed_refs->lock);\n\tif (mutex_trylock(&head->mutex))\n\t\treturn 0;\n\n\tatomic_inc(&head->node.refs);\n\tspin_unlock(&delayed_refs->lock);\n\n\tmutex_lock(&head->mutex);\n\tspin_lock(&delayed_refs->lock);\n\tif (!head->node.in_tree) {\n\t\tmutex_unlock(&head->mutex);\n\t\tbtrfs_put_delayed_ref(&head->node);\n\t\treturn -EAGAIN;\n\t}\n\tbtrfs_put_delayed_ref(&head->node);\n\treturn 0;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"ctree.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_put_delayed_ref",
          "args": [
            "&head->node"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_delayed_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.h",
          "lines": "172-193",
          "snippet": "static inline void btrfs_put_delayed_ref(struct btrfs_delayed_ref_node *ref)\n{\n\tWARN_ON(atomic_read(&ref->refs) == 0);\n\tif (atomic_dec_and_test(&ref->refs)) {\n\t\tWARN_ON(ref->in_tree);\n\t\tswitch (ref->type) {\n\t\tcase BTRFS_TREE_BLOCK_REF_KEY:\n\t\tcase BTRFS_SHARED_BLOCK_REF_KEY:\n\t\t\tkmem_cache_free(btrfs_delayed_tree_ref_cachep, ref);\n\t\t\tbreak;\n\t\tcase BTRFS_EXTENT_DATA_REF_KEY:\n\t\tcase BTRFS_SHARED_DATA_REF_KEY:\n\t\t\tkmem_cache_free(btrfs_delayed_data_ref_cachep, ref);\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tkmem_cache_free(btrfs_delayed_ref_head_cachep, ref);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void btrfs_put_delayed_ref(struct btrfs_delayed_ref_node *ref)\n{\n\tWARN_ON(atomic_read(&ref->refs) == 0);\n\tif (atomic_dec_and_test(&ref->refs)) {\n\t\tWARN_ON(ref->in_tree);\n\t\tswitch (ref->type) {\n\t\tcase BTRFS_TREE_BLOCK_REF_KEY:\n\t\tcase BTRFS_SHARED_BLOCK_REF_KEY:\n\t\t\tkmem_cache_free(btrfs_delayed_tree_ref_cachep, ref);\n\t\t\tbreak;\n\t\tcase BTRFS_EXTENT_DATA_REF_KEY:\n\t\tcase BTRFS_SHARED_DATA_REF_KEY:\n\t\t\tkmem_cache_free(btrfs_delayed_data_ref_cachep, ref);\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tkmem_cache_free(btrfs_delayed_ref_head_cachep, ref);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&head->mutex"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&delayed_refs->lock"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&head->mutex"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&delayed_refs->lock"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&head->node.refs"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_trylock",
          "args": [
            "&head->mutex"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&delayed_refs->lock"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"delayed-ref.h\"\n#include \"ctree.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_delayed_ref_lock(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_delayed_ref_head *head)\n{\n\tstruct btrfs_delayed_ref_root *delayed_refs;\n\n\tdelayed_refs = &trans->transaction->delayed_refs;\n\tassert_spin_locked(&delayed_refs->lock);\n\tif (mutex_trylock(&head->mutex))\n\t\treturn 0;\n\n\tatomic_inc(&head->node.refs);\n\tspin_unlock(&delayed_refs->lock);\n\n\tmutex_lock(&head->mutex);\n\tspin_lock(&delayed_refs->lock);\n\tif (!head->node.in_tree) {\n\t\tmutex_unlock(&head->mutex);\n\t\tbtrfs_put_delayed_ref(&head->node);\n\t\treturn -EAGAIN;\n\t}\n\tbtrfs_put_delayed_ref(&head->node);\n\treturn 0;\n}"
  },
  {
    "function_name": "find_ref_head",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.c",
    "lines": "204-235",
    "snippet": "static struct btrfs_delayed_ref_head *\nfind_ref_head(struct rb_root *root, u64 bytenr,\n\t      int return_bigger)\n{\n\tstruct rb_node *n;\n\tstruct btrfs_delayed_ref_head *entry;\n\n\tn = root->rb_node;\n\tentry = NULL;\n\twhile (n) {\n\t\tentry = rb_entry(n, struct btrfs_delayed_ref_head, href_node);\n\n\t\tif (bytenr < entry->node.bytenr)\n\t\t\tn = n->rb_left;\n\t\telse if (bytenr > entry->node.bytenr)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\tif (entry && return_bigger) {\n\t\tif (bytenr > entry->node.bytenr) {\n\t\t\tn = rb_next(&entry->href_node);\n\t\t\tif (!n)\n\t\t\t\tn = rb_first(root);\n\t\t\tentry = rb_entry(n, struct btrfs_delayed_ref_head,\n\t\t\t\t\t href_node);\n\t\t\treturn entry;\n\t\t}\n\t\treturn entry;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"ctree.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structbtrfs_delayed_ref_head",
            "href_node"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "root"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "&entry->href_node"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structbtrfs_delayed_ref_head",
            "href_node"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"delayed-ref.h\"\n#include \"ctree.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic struct btrfs_delayed_ref_head *\nfind_ref_head(struct rb_root *root, u64 bytenr,\n\t      int return_bigger)\n{\n\tstruct rb_node *n;\n\tstruct btrfs_delayed_ref_head *entry;\n\n\tn = root->rb_node;\n\tentry = NULL;\n\twhile (n) {\n\t\tentry = rb_entry(n, struct btrfs_delayed_ref_head, href_node);\n\n\t\tif (bytenr < entry->node.bytenr)\n\t\t\tn = n->rb_left;\n\t\telse if (bytenr > entry->node.bytenr)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\tif (entry && return_bigger) {\n\t\tif (bytenr > entry->node.bytenr) {\n\t\t\tn = rb_next(&entry->href_node);\n\t\t\tif (!n)\n\t\t\t\tn = rb_first(root);\n\t\t\tentry = rb_entry(n, struct btrfs_delayed_ref_head,\n\t\t\t\t\t href_node);\n\t\t\treturn entry;\n\t\t}\n\t\treturn entry;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "htree_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.c",
    "lines": "169-196",
    "snippet": "static struct btrfs_delayed_ref_head *htree_insert(struct rb_root *root,\n\t\t\t\t\t\t   struct rb_node *node)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent_node = NULL;\n\tstruct btrfs_delayed_ref_head *entry;\n\tstruct btrfs_delayed_ref_head *ins;\n\tu64 bytenr;\n\n\tins = rb_entry(node, struct btrfs_delayed_ref_head, href_node);\n\tbytenr = ins->node.bytenr;\n\twhile (*p) {\n\t\tparent_node = *p;\n\t\tentry = rb_entry(parent_node, struct btrfs_delayed_ref_head,\n\t\t\t\t href_node);\n\n\t\tif (bytenr < entry->node.bytenr)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (bytenr > entry->node.bytenr)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\n\trb_link_node(node, parent_node, p);\n\trb_insert_color(node, root);\n\treturn NULL;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"ctree.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "node",
            "root"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "node",
            "parent_node",
            "p"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent_node",
            "structbtrfs_delayed_ref_head",
            "href_node"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structbtrfs_delayed_ref_head",
            "href_node"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"delayed-ref.h\"\n#include \"ctree.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic struct btrfs_delayed_ref_head *htree_insert(struct rb_root *root,\n\t\t\t\t\t\t   struct rb_node *node)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent_node = NULL;\n\tstruct btrfs_delayed_ref_head *entry;\n\tstruct btrfs_delayed_ref_head *ins;\n\tu64 bytenr;\n\n\tins = rb_entry(node, struct btrfs_delayed_ref_head, href_node);\n\tbytenr = ins->node.bytenr;\n\twhile (*p) {\n\t\tparent_node = *p;\n\t\tentry = rb_entry(parent_node, struct btrfs_delayed_ref_head,\n\t\t\t\t href_node);\n\n\t\tif (bytenr < entry->node.bytenr)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (bytenr > entry->node.bytenr)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\n\trb_link_node(node, parent_node, p);\n\trb_insert_color(node, root);\n\treturn NULL;\n}"
  },
  {
    "function_name": "tree_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.c",
    "lines": "139-166",
    "snippet": "static struct btrfs_delayed_ref_node *tree_insert(struct rb_root *root,\n\t\t\t\t\t\t  struct rb_node *node)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent_node = NULL;\n\tstruct btrfs_delayed_ref_node *entry;\n\tstruct btrfs_delayed_ref_node *ins;\n\tint cmp;\n\n\tins = rb_entry(node, struct btrfs_delayed_ref_node, rb_node);\n\twhile (*p) {\n\t\tparent_node = *p;\n\t\tentry = rb_entry(parent_node, struct btrfs_delayed_ref_node,\n\t\t\t\t rb_node);\n\n\t\tcmp = comp_entry(entry, ins, 1);\n\t\tif (cmp < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (cmp > 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\n\trb_link_node(node, parent_node, p);\n\trb_insert_color(node, root);\n\treturn NULL;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"ctree.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "node",
            "root"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "node",
            "parent_node",
            "p"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "comp_entry",
          "args": [
            "entry",
            "ins",
            "1"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "comp_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.c",
          "lines": "91-132",
          "snippet": "static int comp_entry(struct btrfs_delayed_ref_node *ref2,\n\t\t      struct btrfs_delayed_ref_node *ref1,\n\t\t      bool compare_seq)\n{\n\tif (ref1->bytenr < ref2->bytenr)\n\t\treturn -1;\n\tif (ref1->bytenr > ref2->bytenr)\n\t\treturn 1;\n\tif (ref1->is_head && ref2->is_head)\n\t\treturn 0;\n\tif (ref2->is_head)\n\t\treturn -1;\n\tif (ref1->is_head)\n\t\treturn 1;\n\tif (ref1->type < ref2->type)\n\t\treturn -1;\n\tif (ref1->type > ref2->type)\n\t\treturn 1;\n\tif (ref1->no_quota > ref2->no_quota)\n\t\treturn 1;\n\tif (ref1->no_quota < ref2->no_quota)\n\t\treturn -1;\n\t/* merging of sequenced refs is not allowed */\n\tif (compare_seq) {\n\t\tif (ref1->seq < ref2->seq)\n\t\t\treturn -1;\n\t\tif (ref1->seq > ref2->seq)\n\t\t\treturn 1;\n\t}\n\tif (ref1->type == BTRFS_TREE_BLOCK_REF_KEY ||\n\t    ref1->type == BTRFS_SHARED_BLOCK_REF_KEY) {\n\t\treturn comp_tree_refs(btrfs_delayed_node_to_tree_ref(ref2),\n\t\t\t\t      btrfs_delayed_node_to_tree_ref(ref1),\n\t\t\t\t      ref1->type);\n\t} else if (ref1->type == BTRFS_EXTENT_DATA_REF_KEY ||\n\t\t   ref1->type == BTRFS_SHARED_DATA_REF_KEY) {\n\t\treturn comp_data_refs(btrfs_delayed_node_to_data_ref(ref2),\n\t\t\t\t      btrfs_delayed_node_to_data_ref(ref1));\n\t}\n\tBUG();\n\treturn 0;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"ctree.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"delayed-ref.h\"\n#include \"ctree.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic int comp_entry(struct btrfs_delayed_ref_node *ref2,\n\t\t      struct btrfs_delayed_ref_node *ref1,\n\t\t      bool compare_seq)\n{\n\tif (ref1->bytenr < ref2->bytenr)\n\t\treturn -1;\n\tif (ref1->bytenr > ref2->bytenr)\n\t\treturn 1;\n\tif (ref1->is_head && ref2->is_head)\n\t\treturn 0;\n\tif (ref2->is_head)\n\t\treturn -1;\n\tif (ref1->is_head)\n\t\treturn 1;\n\tif (ref1->type < ref2->type)\n\t\treturn -1;\n\tif (ref1->type > ref2->type)\n\t\treturn 1;\n\tif (ref1->no_quota > ref2->no_quota)\n\t\treturn 1;\n\tif (ref1->no_quota < ref2->no_quota)\n\t\treturn -1;\n\t/* merging of sequenced refs is not allowed */\n\tif (compare_seq) {\n\t\tif (ref1->seq < ref2->seq)\n\t\t\treturn -1;\n\t\tif (ref1->seq > ref2->seq)\n\t\t\treturn 1;\n\t}\n\tif (ref1->type == BTRFS_TREE_BLOCK_REF_KEY ||\n\t    ref1->type == BTRFS_SHARED_BLOCK_REF_KEY) {\n\t\treturn comp_tree_refs(btrfs_delayed_node_to_tree_ref(ref2),\n\t\t\t\t      btrfs_delayed_node_to_tree_ref(ref1),\n\t\t\t\t      ref1->type);\n\t} else if (ref1->type == BTRFS_EXTENT_DATA_REF_KEY ||\n\t\t   ref1->type == BTRFS_SHARED_DATA_REF_KEY) {\n\t\treturn comp_data_refs(btrfs_delayed_node_to_data_ref(ref2),\n\t\t\t\t      btrfs_delayed_node_to_data_ref(ref1));\n\t}\n\tBUG();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent_node",
            "structbtrfs_delayed_ref_node",
            "rb_node"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structbtrfs_delayed_ref_node",
            "rb_node"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"delayed-ref.h\"\n#include \"ctree.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic struct btrfs_delayed_ref_node *tree_insert(struct rb_root *root,\n\t\t\t\t\t\t  struct rb_node *node)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent_node = NULL;\n\tstruct btrfs_delayed_ref_node *entry;\n\tstruct btrfs_delayed_ref_node *ins;\n\tint cmp;\n\n\tins = rb_entry(node, struct btrfs_delayed_ref_node, rb_node);\n\twhile (*p) {\n\t\tparent_node = *p;\n\t\tentry = rb_entry(parent_node, struct btrfs_delayed_ref_node,\n\t\t\t\t rb_node);\n\n\t\tcmp = comp_entry(entry, ins, 1);\n\t\tif (cmp < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (cmp > 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\n\trb_link_node(node, parent_node, p);\n\trb_insert_color(node, root);\n\treturn NULL;\n}"
  },
  {
    "function_name": "comp_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.c",
    "lines": "91-132",
    "snippet": "static int comp_entry(struct btrfs_delayed_ref_node *ref2,\n\t\t      struct btrfs_delayed_ref_node *ref1,\n\t\t      bool compare_seq)\n{\n\tif (ref1->bytenr < ref2->bytenr)\n\t\treturn -1;\n\tif (ref1->bytenr > ref2->bytenr)\n\t\treturn 1;\n\tif (ref1->is_head && ref2->is_head)\n\t\treturn 0;\n\tif (ref2->is_head)\n\t\treturn -1;\n\tif (ref1->is_head)\n\t\treturn 1;\n\tif (ref1->type < ref2->type)\n\t\treturn -1;\n\tif (ref1->type > ref2->type)\n\t\treturn 1;\n\tif (ref1->no_quota > ref2->no_quota)\n\t\treturn 1;\n\tif (ref1->no_quota < ref2->no_quota)\n\t\treturn -1;\n\t/* merging of sequenced refs is not allowed */\n\tif (compare_seq) {\n\t\tif (ref1->seq < ref2->seq)\n\t\t\treturn -1;\n\t\tif (ref1->seq > ref2->seq)\n\t\t\treturn 1;\n\t}\n\tif (ref1->type == BTRFS_TREE_BLOCK_REF_KEY ||\n\t    ref1->type == BTRFS_SHARED_BLOCK_REF_KEY) {\n\t\treturn comp_tree_refs(btrfs_delayed_node_to_tree_ref(ref2),\n\t\t\t\t      btrfs_delayed_node_to_tree_ref(ref1),\n\t\t\t\t      ref1->type);\n\t} else if (ref1->type == BTRFS_EXTENT_DATA_REF_KEY ||\n\t\t   ref1->type == BTRFS_SHARED_DATA_REF_KEY) {\n\t\treturn comp_data_refs(btrfs_delayed_node_to_data_ref(ref2),\n\t\t\t\t      btrfs_delayed_node_to_data_ref(ref1));\n\t}\n\tBUG();\n\treturn 0;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"ctree.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "comp_data_refs",
          "args": [
            "btrfs_delayed_node_to_data_ref(ref2)",
            "btrfs_delayed_node_to_data_ref(ref1)"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "comp_data_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.c",
          "lines": "62-85",
          "snippet": "static int comp_data_refs(struct btrfs_delayed_data_ref *ref2,\n\t\t\t  struct btrfs_delayed_data_ref *ref1)\n{\n\tif (ref1->node.type == BTRFS_EXTENT_DATA_REF_KEY) {\n\t\tif (ref1->root < ref2->root)\n\t\t\treturn -1;\n\t\tif (ref1->root > ref2->root)\n\t\t\treturn 1;\n\t\tif (ref1->objectid < ref2->objectid)\n\t\t\treturn -1;\n\t\tif (ref1->objectid > ref2->objectid)\n\t\t\treturn 1;\n\t\tif (ref1->offset < ref2->offset)\n\t\t\treturn -1;\n\t\tif (ref1->offset > ref2->offset)\n\t\t\treturn 1;\n\t} else {\n\t\tif (ref1->parent < ref2->parent)\n\t\t\treturn -1;\n\t\tif (ref1->parent > ref2->parent)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"ctree.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"delayed-ref.h\"\n#include \"ctree.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic int comp_data_refs(struct btrfs_delayed_data_ref *ref2,\n\t\t\t  struct btrfs_delayed_data_ref *ref1)\n{\n\tif (ref1->node.type == BTRFS_EXTENT_DATA_REF_KEY) {\n\t\tif (ref1->root < ref2->root)\n\t\t\treturn -1;\n\t\tif (ref1->root > ref2->root)\n\t\t\treturn 1;\n\t\tif (ref1->objectid < ref2->objectid)\n\t\t\treturn -1;\n\t\tif (ref1->objectid > ref2->objectid)\n\t\t\treturn 1;\n\t\tif (ref1->offset < ref2->offset)\n\t\t\treturn -1;\n\t\tif (ref1->offset > ref2->offset)\n\t\t\treturn 1;\n\t} else {\n\t\tif (ref1->parent < ref2->parent)\n\t\t\treturn -1;\n\t\tif (ref1->parent > ref2->parent)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_delayed_node_to_data_ref",
          "args": [
            "ref1"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_delayed_node_to_data_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.h",
          "lines": "253-258",
          "snippet": "static inline struct btrfs_delayed_data_ref *\nbtrfs_delayed_node_to_data_ref(struct btrfs_delayed_ref_node *node)\n{\n\tWARN_ON(btrfs_delayed_ref_is_head(node));\n\treturn container_of(node, struct btrfs_delayed_data_ref, node);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct btrfs_delayed_data_ref *\nbtrfs_delayed_node_to_data_ref(struct btrfs_delayed_ref_node *node)\n{\n\tWARN_ON(btrfs_delayed_ref_is_head(node));\n\treturn container_of(node, struct btrfs_delayed_data_ref, node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "comp_tree_refs",
          "args": [
            "btrfs_delayed_node_to_tree_ref(ref2)",
            "btrfs_delayed_node_to_tree_ref(ref1)",
            "ref1->type"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "comp_tree_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.c",
          "lines": "42-57",
          "snippet": "static int comp_tree_refs(struct btrfs_delayed_tree_ref *ref2,\n\t\t\t  struct btrfs_delayed_tree_ref *ref1, int type)\n{\n\tif (type == BTRFS_TREE_BLOCK_REF_KEY) {\n\t\tif (ref1->root < ref2->root)\n\t\t\treturn -1;\n\t\tif (ref1->root > ref2->root)\n\t\t\treturn 1;\n\t} else {\n\t\tif (ref1->parent < ref2->parent)\n\t\t\treturn -1;\n\t\tif (ref1->parent > ref2->parent)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"ctree.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"delayed-ref.h\"\n#include \"ctree.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic int comp_tree_refs(struct btrfs_delayed_tree_ref *ref2,\n\t\t\t  struct btrfs_delayed_tree_ref *ref1, int type)\n{\n\tif (type == BTRFS_TREE_BLOCK_REF_KEY) {\n\t\tif (ref1->root < ref2->root)\n\t\t\treturn -1;\n\t\tif (ref1->root > ref2->root)\n\t\t\treturn 1;\n\t} else {\n\t\tif (ref1->parent < ref2->parent)\n\t\t\treturn -1;\n\t\tif (ref1->parent > ref2->parent)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_delayed_node_to_tree_ref",
          "args": [
            "ref1"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_delayed_node_to_tree_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.h",
          "lines": "246-251",
          "snippet": "static inline struct btrfs_delayed_tree_ref *\nbtrfs_delayed_node_to_tree_ref(struct btrfs_delayed_ref_node *node)\n{\n\tWARN_ON(btrfs_delayed_ref_is_head(node));\n\treturn container_of(node, struct btrfs_delayed_tree_ref, node);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct btrfs_delayed_tree_ref *\nbtrfs_delayed_node_to_tree_ref(struct btrfs_delayed_ref_node *node)\n{\n\tWARN_ON(btrfs_delayed_ref_is_head(node));\n\treturn container_of(node, struct btrfs_delayed_tree_ref, node);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"delayed-ref.h\"\n#include \"ctree.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic int comp_entry(struct btrfs_delayed_ref_node *ref2,\n\t\t      struct btrfs_delayed_ref_node *ref1,\n\t\t      bool compare_seq)\n{\n\tif (ref1->bytenr < ref2->bytenr)\n\t\treturn -1;\n\tif (ref1->bytenr > ref2->bytenr)\n\t\treturn 1;\n\tif (ref1->is_head && ref2->is_head)\n\t\treturn 0;\n\tif (ref2->is_head)\n\t\treturn -1;\n\tif (ref1->is_head)\n\t\treturn 1;\n\tif (ref1->type < ref2->type)\n\t\treturn -1;\n\tif (ref1->type > ref2->type)\n\t\treturn 1;\n\tif (ref1->no_quota > ref2->no_quota)\n\t\treturn 1;\n\tif (ref1->no_quota < ref2->no_quota)\n\t\treturn -1;\n\t/* merging of sequenced refs is not allowed */\n\tif (compare_seq) {\n\t\tif (ref1->seq < ref2->seq)\n\t\t\treturn -1;\n\t\tif (ref1->seq > ref2->seq)\n\t\t\treturn 1;\n\t}\n\tif (ref1->type == BTRFS_TREE_BLOCK_REF_KEY ||\n\t    ref1->type == BTRFS_SHARED_BLOCK_REF_KEY) {\n\t\treturn comp_tree_refs(btrfs_delayed_node_to_tree_ref(ref2),\n\t\t\t\t      btrfs_delayed_node_to_tree_ref(ref1),\n\t\t\t\t      ref1->type);\n\t} else if (ref1->type == BTRFS_EXTENT_DATA_REF_KEY ||\n\t\t   ref1->type == BTRFS_SHARED_DATA_REF_KEY) {\n\t\treturn comp_data_refs(btrfs_delayed_node_to_data_ref(ref2),\n\t\t\t\t      btrfs_delayed_node_to_data_ref(ref1));\n\t}\n\tBUG();\n\treturn 0;\n}"
  },
  {
    "function_name": "comp_data_refs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.c",
    "lines": "62-85",
    "snippet": "static int comp_data_refs(struct btrfs_delayed_data_ref *ref2,\n\t\t\t  struct btrfs_delayed_data_ref *ref1)\n{\n\tif (ref1->node.type == BTRFS_EXTENT_DATA_REF_KEY) {\n\t\tif (ref1->root < ref2->root)\n\t\t\treturn -1;\n\t\tif (ref1->root > ref2->root)\n\t\t\treturn 1;\n\t\tif (ref1->objectid < ref2->objectid)\n\t\t\treturn -1;\n\t\tif (ref1->objectid > ref2->objectid)\n\t\t\treturn 1;\n\t\tif (ref1->offset < ref2->offset)\n\t\t\treturn -1;\n\t\tif (ref1->offset > ref2->offset)\n\t\t\treturn 1;\n\t} else {\n\t\tif (ref1->parent < ref2->parent)\n\t\t\treturn -1;\n\t\tif (ref1->parent > ref2->parent)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"ctree.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"delayed-ref.h\"\n#include \"ctree.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic int comp_data_refs(struct btrfs_delayed_data_ref *ref2,\n\t\t\t  struct btrfs_delayed_data_ref *ref1)\n{\n\tif (ref1->node.type == BTRFS_EXTENT_DATA_REF_KEY) {\n\t\tif (ref1->root < ref2->root)\n\t\t\treturn -1;\n\t\tif (ref1->root > ref2->root)\n\t\t\treturn 1;\n\t\tif (ref1->objectid < ref2->objectid)\n\t\t\treturn -1;\n\t\tif (ref1->objectid > ref2->objectid)\n\t\t\treturn 1;\n\t\tif (ref1->offset < ref2->offset)\n\t\t\treturn -1;\n\t\tif (ref1->offset > ref2->offset)\n\t\t\treturn 1;\n\t} else {\n\t\tif (ref1->parent < ref2->parent)\n\t\t\treturn -1;\n\t\tif (ref1->parent > ref2->parent)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "comp_tree_refs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.c",
    "lines": "42-57",
    "snippet": "static int comp_tree_refs(struct btrfs_delayed_tree_ref *ref2,\n\t\t\t  struct btrfs_delayed_tree_ref *ref1, int type)\n{\n\tif (type == BTRFS_TREE_BLOCK_REF_KEY) {\n\t\tif (ref1->root < ref2->root)\n\t\t\treturn -1;\n\t\tif (ref1->root > ref2->root)\n\t\t\treturn 1;\n\t} else {\n\t\tif (ref1->parent < ref2->parent)\n\t\t\treturn -1;\n\t\tif (ref1->parent > ref2->parent)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"transaction.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"ctree.h\"",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"transaction.h\"\n#include \"delayed-ref.h\"\n#include \"ctree.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic int comp_tree_refs(struct btrfs_delayed_tree_ref *ref2,\n\t\t\t  struct btrfs_delayed_tree_ref *ref1, int type)\n{\n\tif (type == BTRFS_TREE_BLOCK_REF_KEY) {\n\t\tif (ref1->root < ref2->root)\n\t\t\treturn -1;\n\t\tif (ref1->root > ref2->root)\n\t\t\treturn 1;\n\t} else {\n\t\tif (ref1->parent < ref2->parent)\n\t\t\treturn -1;\n\t\tif (ref1->parent > ref2->parent)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
  }
]