[
  {
    "function_name": "xfs_buf_update_cksum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
    "lines": "374-379",
    "snippet": "static inline void\nxfs_buf_update_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\txfs_update_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t cksum_offset);\n}",
    "includes": [
      "#include <linux/list_lru.h>",
      "#include <linux/uio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_update_cksum",
          "args": [
            "bp->b_addr",
            "BBTOB(bp->b_length)",
            "cksum_offset"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_update_cksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_cksum.h",
          "lines": "44-50",
          "snippet": "static inline void\nxfs_update_cksum(char *buffer, size_t length, unsigned long cksum_offset)\n{\n\t__uint32_t crc = xfs_start_cksum(buffer, length, cksum_offset);\n\n\t*(__le32 *)(buffer + cksum_offset) = xfs_end_cksum(crc);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nxfs_update_cksum(char *buffer, size_t length, unsigned long cksum_offset)\n{\n\t__uint32_t crc = xfs_start_cksum(buffer, length, cksum_offset);\n\n\t*(__le32 *)(buffer + cksum_offset) = xfs_end_cksum(crc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BBTOB",
          "args": [
            "bp->b_length"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void\nxfs_buf_update_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\txfs_update_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t cksum_offset);\n}"
  },
  {
    "function_name": "xfs_buf_verify_cksum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
    "lines": "367-372",
    "snippet": "static inline int\nxfs_buf_verify_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\treturn xfs_verify_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t\tcksum_offset);\n}",
    "includes": [
      "#include <linux/list_lru.h>",
      "#include <linux/uio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_verify_cksum",
          "args": [
            "bp->b_addr",
            "BBTOB(bp->b_length)",
            "cksum_offset"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_verify_cksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_cksum.h",
          "lines": "55-61",
          "snippet": "static inline int\nxfs_verify_cksum(char *buffer, size_t length, unsigned long cksum_offset)\n{\n\t__uint32_t crc = xfs_start_cksum(buffer, length, cksum_offset);\n\n\treturn *(__le32 *)(buffer + cksum_offset) == xfs_end_cksum(crc);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int\nxfs_verify_cksum(char *buffer, size_t length, unsigned long cksum_offset)\n{\n\t__uint32_t crc = xfs_start_cksum(buffer, length, cksum_offset);\n\n\treturn *(__le32 *)(buffer + cksum_offset) == xfs_end_cksum(crc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BBTOB",
          "args": [
            "bp->b_length"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline int\nxfs_buf_verify_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\treturn xfs_verify_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t\tcksum_offset);\n}"
  },
  {
    "function_name": "xfs_buf_relse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
    "lines": "361-365",
    "snippet": "static inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}",
    "includes": [
      "#include <linux/list_lru.h>",
      "#include <linux/uio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_rele",
          "args": [
            "bp"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_rele",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "866-920",
          "snippet": "void\nxfs_buf_rele(\n\txfs_buf_t\t\t*bp)\n{\n\tstruct xfs_perag\t*pag = bp->b_pag;\n\n\ttrace_xfs_buf_rele(bp, _RET_IP_);\n\n\tif (!pag) {\n\t\tASSERT(list_empty(&bp->b_lru));\n\t\tASSERT(RB_EMPTY_NODE(&bp->b_rbnode));\n\t\tif (atomic_dec_and_test(&bp->b_hold))\n\t\t\txfs_buf_free(bp);\n\t\treturn;\n\t}\n\n\tASSERT(!RB_EMPTY_NODE(&bp->b_rbnode));\n\n\tASSERT(atomic_read(&bp->b_hold) > 0);\n\tif (atomic_dec_and_lock(&bp->b_hold, &pag->pag_buf_lock)) {\n\t\tspin_lock(&bp->b_lock);\n\t\tif (!(bp->b_flags & XBF_STALE) && atomic_read(&bp->b_lru_ref)) {\n\t\t\t/*\n\t\t\t * If the buffer is added to the LRU take a new\n\t\t\t * reference to the buffer for the LRU and clear the\n\t\t\t * (now stale) dispose list state flag\n\t\t\t */\n\t\t\tif (list_lru_add(&bp->b_target->bt_lru, &bp->b_lru)) {\n\t\t\t\tbp->b_state &= ~XFS_BSTATE_DISPOSE;\n\t\t\t\tatomic_inc(&bp->b_hold);\n\t\t\t}\n\t\t\tspin_unlock(&bp->b_lock);\n\t\t\tspin_unlock(&pag->pag_buf_lock);\n\t\t} else {\n\t\t\t/*\n\t\t\t * most of the time buffers will already be removed from\n\t\t\t * the LRU, so optimise that case by checking for the\n\t\t\t * XFS_BSTATE_DISPOSE flag indicating the last list the\n\t\t\t * buffer was on was the disposal list\n\t\t\t */\n\t\t\tif (!(bp->b_state & XFS_BSTATE_DISPOSE)) {\n\t\t\t\tlist_lru_del(&bp->b_target->bt_lru, &bp->b_lru);\n\t\t\t} else {\n\t\t\t\tASSERT(list_empty(&bp->b_lru));\n\t\t\t}\n\t\t\tspin_unlock(&bp->b_lock);\n\n\t\t\tASSERT(!(bp->b_flags & _XBF_DELWRI_Q));\n\t\t\trb_erase(&bp->b_rbnode, &pag->pag_buf_tree);\n\t\t\tspin_unlock(&pag->pag_buf_lock);\n\t\t\txfs_perag_put(pag);\n\t\t\txfs_buf_free(bp);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_rele(\n\txfs_buf_t\t\t*bp)\n{\n\tstruct xfs_perag\t*pag = bp->b_pag;\n\n\ttrace_xfs_buf_rele(bp, _RET_IP_);\n\n\tif (!pag) {\n\t\tASSERT(list_empty(&bp->b_lru));\n\t\tASSERT(RB_EMPTY_NODE(&bp->b_rbnode));\n\t\tif (atomic_dec_and_test(&bp->b_hold))\n\t\t\txfs_buf_free(bp);\n\t\treturn;\n\t}\n\n\tASSERT(!RB_EMPTY_NODE(&bp->b_rbnode));\n\n\tASSERT(atomic_read(&bp->b_hold) > 0);\n\tif (atomic_dec_and_lock(&bp->b_hold, &pag->pag_buf_lock)) {\n\t\tspin_lock(&bp->b_lock);\n\t\tif (!(bp->b_flags & XBF_STALE) && atomic_read(&bp->b_lru_ref)) {\n\t\t\t/*\n\t\t\t * If the buffer is added to the LRU take a new\n\t\t\t * reference to the buffer for the LRU and clear the\n\t\t\t * (now stale) dispose list state flag\n\t\t\t */\n\t\t\tif (list_lru_add(&bp->b_target->bt_lru, &bp->b_lru)) {\n\t\t\t\tbp->b_state &= ~XFS_BSTATE_DISPOSE;\n\t\t\t\tatomic_inc(&bp->b_hold);\n\t\t\t}\n\t\t\tspin_unlock(&bp->b_lock);\n\t\t\tspin_unlock(&pag->pag_buf_lock);\n\t\t} else {\n\t\t\t/*\n\t\t\t * most of the time buffers will already be removed from\n\t\t\t * the LRU, so optimise that case by checking for the\n\t\t\t * XFS_BSTATE_DISPOSE flag indicating the last list the\n\t\t\t * buffer was on was the disposal list\n\t\t\t */\n\t\t\tif (!(bp->b_state & XFS_BSTATE_DISPOSE)) {\n\t\t\t\tlist_lru_del(&bp->b_target->bt_lru, &bp->b_lru);\n\t\t\t} else {\n\t\t\t\tASSERT(list_empty(&bp->b_lru));\n\t\t\t}\n\t\t\tspin_unlock(&bp->b_lock);\n\n\t\t\tASSERT(!(bp->b_flags & _XBF_DELWRI_Q));\n\t\t\trb_erase(&bp->b_rbnode, &pag->pag_buf_tree);\n\t\t\tspin_unlock(&pag->pag_buf_lock);\n\t\t\txfs_perag_put(pag);\n\t\t\txfs_buf_free(bp);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_unlock",
          "args": [
            "bp"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "971-979",
          "snippet": "void\nxfs_buf_unlock(\n\tstruct xfs_buf\t\t*bp)\n{\n\tXB_CLEAR_OWNER(bp);\n\tup(&bp->b_sema);\n\n\ttrace_xfs_buf_unlock(bp, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_unlock(\n\tstruct xfs_buf\t\t*bp)\n{\n\tXB_CLEAR_OWNER(bp);\n\tup(&bp->b_sema);\n\n\ttrace_xfs_buf_unlock(bp, _RET_IP_);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}"
  },
  {
    "function_name": "xfs_buf_ispinned",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
    "lines": "356-359",
    "snippet": "static inline int xfs_buf_ispinned(struct xfs_buf *bp)\n{\n\treturn atomic_read(&bp->b_pin_count);\n}",
    "includes": [
      "#include <linux/list_lru.h>",
      "#include <linux/uio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&bp->b_pin_count"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline int xfs_buf_ispinned(struct xfs_buf *bp)\n{\n\treturn atomic_read(&bp->b_pin_count);\n}"
  },
  {
    "function_name": "xfs_buf_set_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
    "lines": "351-354",
    "snippet": "static inline void xfs_buf_set_ref(struct xfs_buf *bp, int lru_ref)\n{\n\tatomic_set(&bp->b_lru_ref, lru_ref);\n}",
    "includes": [
      "#include <linux/list_lru.h>",
      "#include <linux/uio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&bp->b_lru_ref",
            "lru_ref"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_set_ref(struct xfs_buf *bp, int lru_ref)\n{\n\tatomic_set(&bp->b_lru_ref, lru_ref);\n}"
  },
  {
    "function_name": "xfs_buf_readahead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
    "lines": "256-265",
    "snippet": "static inline void\nxfs_buf_readahead(\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tsize_t\t\t\tnumblks,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_buf_readahead_map(target, &map, 1, ops);\n}",
    "includes": [
      "#include <linux/list_lru.h>",
      "#include <linux/uio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_readahead_map",
          "args": [
            "target",
            "&map",
            "1",
            "ops"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_readahead_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "671-683",
          "snippet": "void\nxfs_buf_readahead_map(\n\tstruct xfs_buftarg\t*target,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\tconst struct xfs_buf_ops *ops)\n{\n\tif (bdi_read_congested(target->bt_bdi))\n\t\treturn;\n\n\txfs_buf_read_map(target, map, nmaps,\n\t\t     XBF_TRYLOCK|XBF_ASYNC|XBF_READ_AHEAD, ops);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_readahead_map(\n\tstruct xfs_buftarg\t*target,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\tconst struct xfs_buf_ops *ops)\n{\n\tif (bdi_read_congested(target->bt_bdi))\n\t\treturn;\n\n\txfs_buf_read_map(target, map, nmaps,\n\t\t     XBF_TRYLOCK|XBF_ASYNC|XBF_READ_AHEAD, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEFINE_SINGLE_BUF_MAP",
          "args": [
            "map",
            "blkno",
            "numblks"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void\nxfs_buf_readahead(\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tsize_t\t\t\tnumblks,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_buf_readahead_map(target, &map, 1, ops);\n}"
  },
  {
    "function_name": "xfs_buf_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
    "lines": "244-254",
    "snippet": "static inline struct xfs_buf *\nxfs_buf_read(\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tsize_t\t\t\tnumblks,\n\txfs_buf_flags_t\t\tflags,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_buf_read_map(target, &map, 1, flags, ops);\n}",
    "includes": [
      "#include <linux/list_lru.h>",
      "#include <linux/uio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_read_map",
          "args": [
            "target",
            "&map",
            "1",
            "flags",
            "ops"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_read_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "631-665",
          "snippet": "xfs_buf_t *\nxfs_buf_read_map(\n\tstruct xfs_buftarg\t*target,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\txfs_buf_flags_t\t\tflags,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\n\n\tflags |= XBF_READ;\n\n\tbp = xfs_buf_get_map(target, map, nmaps, flags);\n\tif (bp) {\n\t\ttrace_xfs_buf_read(bp, flags, _RET_IP_);\n\n\t\tif (!XFS_BUF_ISDONE(bp)) {\n\t\t\tXFS_STATS_INC(xb_get_read);\n\t\t\tbp->b_ops = ops;\n\t\t\t_xfs_buf_read(bp, flags);\n\t\t} else if (flags & XBF_ASYNC) {\n\t\t\t/*\n\t\t\t * Read ahead call which is already satisfied,\n\t\t\t * drop the buffer\n\t\t\t */\n\t\t\txfs_buf_relse(bp);\n\t\t\treturn NULL;\n\t\t} else {\n\t\t\t/* We do not want read in the flags */\n\t\t\tbp->b_flags &= ~XBF_READ;\n\t\t}\n\t}\n\n\treturn bp;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nxfs_buf_t *\nxfs_buf_read_map(\n\tstruct xfs_buftarg\t*target,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\txfs_buf_flags_t\t\tflags,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\n\n\tflags |= XBF_READ;\n\n\tbp = xfs_buf_get_map(target, map, nmaps, flags);\n\tif (bp) {\n\t\ttrace_xfs_buf_read(bp, flags, _RET_IP_);\n\n\t\tif (!XFS_BUF_ISDONE(bp)) {\n\t\t\tXFS_STATS_INC(xb_get_read);\n\t\t\tbp->b_ops = ops;\n\t\t\t_xfs_buf_read(bp, flags);\n\t\t} else if (flags & XBF_ASYNC) {\n\t\t\t/*\n\t\t\t * Read ahead call which is already satisfied,\n\t\t\t * drop the buffer\n\t\t\t */\n\t\t\txfs_buf_relse(bp);\n\t\t\treturn NULL;\n\t\t} else {\n\t\t\t/* We do not want read in the flags */\n\t\t\tbp->b_flags &= ~XBF_READ;\n\t\t}\n\t}\n\n\treturn bp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEFINE_SINGLE_BUF_MAP",
          "args": [
            "map",
            "blkno",
            "numblks"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline struct xfs_buf *\nxfs_buf_read(\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tsize_t\t\t\tnumblks,\n\txfs_buf_flags_t\t\tflags,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_buf_read_map(target, &map, 1, flags, ops);\n}"
  },
  {
    "function_name": "xfs_buf_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
    "lines": "233-242",
    "snippet": "static inline struct xfs_buf *\nxfs_buf_get(\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tsize_t\t\t\tnumblks,\n\txfs_buf_flags_t\t\tflags)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_buf_get_map(target, &map, 1, flags);\n}",
    "includes": [
      "#include <linux/list_lru.h>",
      "#include <linux/uio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_get_map",
          "args": [
            "target",
            "&map",
            "1",
            "flags"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_get_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "563-611",
          "snippet": "struct xfs_buf *\nxfs_buf_get_map(\n\tstruct xfs_buftarg\t*target,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\txfs_buf_flags_t\t\tflags)\n{\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_buf\t\t*new_bp;\n\tint\t\t\terror = 0;\n\n\tbp = _xfs_buf_find(target, map, nmaps, flags, NULL);\n\tif (likely(bp))\n\t\tgoto found;\n\n\tnew_bp = _xfs_buf_alloc(target, map, nmaps, flags);\n\tif (unlikely(!new_bp))\n\t\treturn NULL;\n\n\terror = xfs_buf_allocate_memory(new_bp, flags);\n\tif (error) {\n\t\txfs_buf_free(new_bp);\n\t\treturn NULL;\n\t}\n\n\tbp = _xfs_buf_find(target, map, nmaps, flags, new_bp);\n\tif (!bp) {\n\t\txfs_buf_free(new_bp);\n\t\treturn NULL;\n\t}\n\n\tif (bp != new_bp)\n\t\txfs_buf_free(new_bp);\n\nfound:\n\tif (!bp->b_addr) {\n\t\terror = _xfs_buf_map_pages(bp, flags);\n\t\tif (unlikely(error)) {\n\t\t\txfs_warn(target->bt_mount,\n\t\t\t\t\"%s: failed to map pagesn\", __func__);\n\t\t\txfs_buf_relse(bp);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tXFS_STATS_INC(xb_get);\n\ttrace_xfs_buf_get(bp, flags, _RET_IP_);\n\treturn bp;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nstruct xfs_buf *\nxfs_buf_get_map(\n\tstruct xfs_buftarg\t*target,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\txfs_buf_flags_t\t\tflags)\n{\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_buf\t\t*new_bp;\n\tint\t\t\terror = 0;\n\n\tbp = _xfs_buf_find(target, map, nmaps, flags, NULL);\n\tif (likely(bp))\n\t\tgoto found;\n\n\tnew_bp = _xfs_buf_alloc(target, map, nmaps, flags);\n\tif (unlikely(!new_bp))\n\t\treturn NULL;\n\n\terror = xfs_buf_allocate_memory(new_bp, flags);\n\tif (error) {\n\t\txfs_buf_free(new_bp);\n\t\treturn NULL;\n\t}\n\n\tbp = _xfs_buf_find(target, map, nmaps, flags, new_bp);\n\tif (!bp) {\n\t\txfs_buf_free(new_bp);\n\t\treturn NULL;\n\t}\n\n\tif (bp != new_bp)\n\t\txfs_buf_free(new_bp);\n\nfound:\n\tif (!bp->b_addr) {\n\t\terror = _xfs_buf_map_pages(bp, flags);\n\t\tif (unlikely(error)) {\n\t\t\txfs_warn(target->bt_mount,\n\t\t\t\t\"%s: failed to map pagesn\", __func__);\n\t\t\txfs_buf_relse(bp);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tXFS_STATS_INC(xb_get);\n\ttrace_xfs_buf_get(bp, flags, _RET_IP_);\n\treturn bp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEFINE_SINGLE_BUF_MAP",
          "args": [
            "map",
            "blkno",
            "numblks"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline struct xfs_buf *\nxfs_buf_get(\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tsize_t\t\t\tnumblks,\n\txfs_buf_flags_t\t\tflags)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_buf_get_map(target, &map, 1, flags);\n}"
  },
  {
    "function_name": "xfs_buf_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
    "lines": "211-220",
    "snippet": "static inline struct xfs_buf *\nxfs_buf_alloc(\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tsize_t\t\t\tnumblks,\n\txfs_buf_flags_t\t\tflags)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn _xfs_buf_alloc(target, &map, 1, flags);\n}",
    "includes": [
      "#include <linux/list_lru.h>",
      "#include <linux/uio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_xfs_buf_alloc",
          "args": [
            "target",
            "&map",
            "1",
            "flags"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_buf_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "148-208",
          "snippet": "struct xfs_buf *\n_xfs_buf_alloc(\n\tstruct xfs_buftarg\t*target,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\txfs_buf_flags_t\t\tflags)\n{\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\tbp = kmem_zone_zalloc(xfs_buf_zone, KM_NOFS);\n\tif (unlikely(!bp))\n\t\treturn NULL;\n\n\t/*\n\t * We don't want certain flags to appear in b_flags unless they are\n\t * specifically set by later operations on the buffer.\n\t */\n\tflags &= ~(XBF_UNMAPPED | XBF_TRYLOCK | XBF_ASYNC | XBF_READ_AHEAD);\n\n\tatomic_set(&bp->b_hold, 1);\n\tatomic_set(&bp->b_lru_ref, 1);\n\tinit_completion(&bp->b_iowait);\n\tINIT_LIST_HEAD(&bp->b_lru);\n\tINIT_LIST_HEAD(&bp->b_list);\n\tRB_CLEAR_NODE(&bp->b_rbnode);\n\tsema_init(&bp->b_sema, 0); /* held, no waiters */\n\tspin_lock_init(&bp->b_lock);\n\tXB_SET_OWNER(bp);\n\tbp->b_target = target;\n\tbp->b_flags = flags;\n\n\t/*\n\t * Set length and io_length to the same value initially.\n\t * I/O routines should use io_length, which will be the same in\n\t * most cases but may be reset (e.g. XFS recovery).\n\t */\n\terror = xfs_buf_get_maps(bp, nmaps);\n\tif (error)  {\n\t\tkmem_zone_free(xfs_buf_zone, bp);\n\t\treturn NULL;\n\t}\n\n\tbp->b_bn = map[0].bm_bn;\n\tbp->b_length = 0;\n\tfor (i = 0; i < nmaps; i++) {\n\t\tbp->b_maps[i].bm_bn = map[i].bm_bn;\n\t\tbp->b_maps[i].bm_len = map[i].bm_len;\n\t\tbp->b_length += map[i].bm_len;\n\t}\n\tbp->b_io_length = bp->b_length;\n\n\tatomic_set(&bp->b_pin_count, 0);\n\tinit_waitqueue_head(&bp->b_waiters);\n\n\tXFS_STATS_INC(xb_create);\n\ttrace_xfs_buf_init(bp, _RET_IP_);\n\n\treturn bp;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static kmem_zone_t *xfs_buf_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nstatic kmem_zone_t *xfs_buf_zone;\n\nstruct xfs_buf *\n_xfs_buf_alloc(\n\tstruct xfs_buftarg\t*target,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\txfs_buf_flags_t\t\tflags)\n{\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\tbp = kmem_zone_zalloc(xfs_buf_zone, KM_NOFS);\n\tif (unlikely(!bp))\n\t\treturn NULL;\n\n\t/*\n\t * We don't want certain flags to appear in b_flags unless they are\n\t * specifically set by later operations on the buffer.\n\t */\n\tflags &= ~(XBF_UNMAPPED | XBF_TRYLOCK | XBF_ASYNC | XBF_READ_AHEAD);\n\n\tatomic_set(&bp->b_hold, 1);\n\tatomic_set(&bp->b_lru_ref, 1);\n\tinit_completion(&bp->b_iowait);\n\tINIT_LIST_HEAD(&bp->b_lru);\n\tINIT_LIST_HEAD(&bp->b_list);\n\tRB_CLEAR_NODE(&bp->b_rbnode);\n\tsema_init(&bp->b_sema, 0); /* held, no waiters */\n\tspin_lock_init(&bp->b_lock);\n\tXB_SET_OWNER(bp);\n\tbp->b_target = target;\n\tbp->b_flags = flags;\n\n\t/*\n\t * Set length and io_length to the same value initially.\n\t * I/O routines should use io_length, which will be the same in\n\t * most cases but may be reset (e.g. XFS recovery).\n\t */\n\terror = xfs_buf_get_maps(bp, nmaps);\n\tif (error)  {\n\t\tkmem_zone_free(xfs_buf_zone, bp);\n\t\treturn NULL;\n\t}\n\n\tbp->b_bn = map[0].bm_bn;\n\tbp->b_length = 0;\n\tfor (i = 0; i < nmaps; i++) {\n\t\tbp->b_maps[i].bm_bn = map[i].bm_bn;\n\t\tbp->b_maps[i].bm_len = map[i].bm_len;\n\t\tbp->b_length += map[i].bm_len;\n\t}\n\tbp->b_io_length = bp->b_length;\n\n\tatomic_set(&bp->b_pin_count, 0);\n\tinit_waitqueue_head(&bp->b_waiters);\n\n\tXFS_STATS_INC(xb_create);\n\ttrace_xfs_buf_init(bp, _RET_IP_);\n\n\treturn bp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEFINE_SINGLE_BUF_MAP",
          "args": [
            "map",
            "blkno",
            "numblks"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline struct xfs_buf *\nxfs_buf_alloc(\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tsize_t\t\t\tnumblks,\n\txfs_buf_flags_t\t\tflags)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn _xfs_buf_alloc(target, &map, 1, flags);\n}"
  },
  {
    "function_name": "xfs_incore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
    "lines": "196-205",
    "snippet": "static inline struct xfs_buf *\nxfs_incore(\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tsize_t\t\t\tnumblks,\n\txfs_buf_flags_t\t\tflags)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn _xfs_buf_find(target, &map, 1, flags, NULL);\n}",
    "includes": [
      "#include <linux/list_lru.h>",
      "#include <linux/uio.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/list.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_xfs_buf_find",
          "args": [
            "target",
            "&map",
            "1",
            "flags",
            "NULL"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_buf_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "433-556",
          "snippet": "xfs_buf_t *\n_xfs_buf_find(\n\tstruct xfs_buftarg\t*btp,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\txfs_buf_flags_t\t\tflags,\n\txfs_buf_t\t\t*new_bp)\n{\n\tsize_t\t\t\tnumbytes;\n\tstruct xfs_perag\t*pag;\n\tstruct rb_node\t\t**rbp;\n\tstruct rb_node\t\t*parent;\n\txfs_buf_t\t\t*bp;\n\txfs_daddr_t\t\tblkno = map[0].bm_bn;\n\txfs_daddr_t\t\teofs;\n\tint\t\t\tnumblks = 0;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < nmaps; i++)\n\t\tnumblks += map[i].bm_len;\n\tnumbytes = BBTOB(numblks);\n\n\t/* Check for IOs smaller than the sector size / not sector aligned */\n\tASSERT(!(numbytes < btp->bt_meta_sectorsize));\n\tASSERT(!(BBTOB(blkno) & (xfs_off_t)btp->bt_meta_sectormask));\n\n\t/*\n\t * Corrupted block numbers can get through to here, unfortunately, so we\n\t * have to check that the buffer falls within the filesystem bounds.\n\t */\n\teofs = XFS_FSB_TO_BB(btp->bt_mount, btp->bt_mount->m_sb.sb_dblocks);\n\tif (blkno < 0 || blkno >= eofs) {\n\t\t/*\n\t\t * XXX (dgc): we should really be returning -EFSCORRUPTED here,\n\t\t * but none of the higher level infrastructure supports\n\t\t * returning a specific error on buffer lookup failures.\n\t\t */\n\t\txfs_alert(btp->bt_mount,\n\t\t\t  \"%s: Block out of range: block 0x%llx, EOFS 0x%llx \",\n\t\t\t  __func__, blkno, eofs);\n\t\tWARN_ON(1);\n\t\treturn NULL;\n\t}\n\n\t/* get tree root */\n\tpag = xfs_perag_get(btp->bt_mount,\n\t\t\t\txfs_daddr_to_agno(btp->bt_mount, blkno));\n\n\t/* walk tree */\n\tspin_lock(&pag->pag_buf_lock);\n\trbp = &pag->pag_buf_tree.rb_node;\n\tparent = NULL;\n\tbp = NULL;\n\twhile (*rbp) {\n\t\tparent = *rbp;\n\t\tbp = rb_entry(parent, struct xfs_buf, b_rbnode);\n\n\t\tif (blkno < bp->b_bn)\n\t\t\trbp = &(*rbp)->rb_left;\n\t\telse if (blkno > bp->b_bn)\n\t\t\trbp = &(*rbp)->rb_right;\n\t\telse {\n\t\t\t/*\n\t\t\t * found a block number match. If the range doesn't\n\t\t\t * match, the only way this is allowed is if the buffer\n\t\t\t * in the cache is stale and the transaction that made\n\t\t\t * it stale has not yet committed. i.e. we are\n\t\t\t * reallocating a busy extent. Skip this buffer and\n\t\t\t * continue searching to the right for an exact match.\n\t\t\t */\n\t\t\tif (bp->b_length != numblks) {\n\t\t\t\tASSERT(bp->b_flags & XBF_STALE);\n\t\t\t\trbp = &(*rbp)->rb_right;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tatomic_inc(&bp->b_hold);\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\t/* No match found */\n\tif (new_bp) {\n\t\trb_link_node(&new_bp->b_rbnode, parent, rbp);\n\t\trb_insert_color(&new_bp->b_rbnode, &pag->pag_buf_tree);\n\t\t/* the buffer keeps the perag reference until it is freed */\n\t\tnew_bp->b_pag = pag;\n\t\tspin_unlock(&pag->pag_buf_lock);\n\t} else {\n\t\tXFS_STATS_INC(xb_miss_locked);\n\t\tspin_unlock(&pag->pag_buf_lock);\n\t\txfs_perag_put(pag);\n\t}\n\treturn new_bp;\n\nfound:\n\tspin_unlock(&pag->pag_buf_lock);\n\txfs_perag_put(pag);\n\n\tif (!xfs_buf_trylock(bp)) {\n\t\tif (flags & XBF_TRYLOCK) {\n\t\t\txfs_buf_rele(bp);\n\t\t\tXFS_STATS_INC(xb_busy_locked);\n\t\t\treturn NULL;\n\t\t}\n\t\txfs_buf_lock(bp);\n\t\tXFS_STATS_INC(xb_get_locked_waited);\n\t}\n\n\t/*\n\t * if the buffer is stale, clear all the external state associated with\n\t * it. We need to keep flags such as how we allocated the buffer memory\n\t * intact here.\n\t */\n\tif (bp->b_flags & XBF_STALE) {\n\t\tASSERT((bp->b_flags & _XBF_DELWRI_Q) == 0);\n\t\tASSERT(bp->b_iodone == NULL);\n\t\tbp->b_flags &= _XBF_KMEM | _XBF_PAGES;\n\t\tbp->b_ops = NULL;\n\t}\n\n\ttrace_xfs_buf_find(bp, flags, _RET_IP_);\n\tXFS_STATS_INC(xb_get_locked);\n\treturn bp;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nxfs_buf_t *\n_xfs_buf_find(\n\tstruct xfs_buftarg\t*btp,\n\tstruct xfs_buf_map\t*map,\n\tint\t\t\tnmaps,\n\txfs_buf_flags_t\t\tflags,\n\txfs_buf_t\t\t*new_bp)\n{\n\tsize_t\t\t\tnumbytes;\n\tstruct xfs_perag\t*pag;\n\tstruct rb_node\t\t**rbp;\n\tstruct rb_node\t\t*parent;\n\txfs_buf_t\t\t*bp;\n\txfs_daddr_t\t\tblkno = map[0].bm_bn;\n\txfs_daddr_t\t\teofs;\n\tint\t\t\tnumblks = 0;\n\tint\t\t\ti;\n\n\tfor (i = 0; i < nmaps; i++)\n\t\tnumblks += map[i].bm_len;\n\tnumbytes = BBTOB(numblks);\n\n\t/* Check for IOs smaller than the sector size / not sector aligned */\n\tASSERT(!(numbytes < btp->bt_meta_sectorsize));\n\tASSERT(!(BBTOB(blkno) & (xfs_off_t)btp->bt_meta_sectormask));\n\n\t/*\n\t * Corrupted block numbers can get through to here, unfortunately, so we\n\t * have to check that the buffer falls within the filesystem bounds.\n\t */\n\teofs = XFS_FSB_TO_BB(btp->bt_mount, btp->bt_mount->m_sb.sb_dblocks);\n\tif (blkno < 0 || blkno >= eofs) {\n\t\t/*\n\t\t * XXX (dgc): we should really be returning -EFSCORRUPTED here,\n\t\t * but none of the higher level infrastructure supports\n\t\t * returning a specific error on buffer lookup failures.\n\t\t */\n\t\txfs_alert(btp->bt_mount,\n\t\t\t  \"%s: Block out of range: block 0x%llx, EOFS 0x%llx \",\n\t\t\t  __func__, blkno, eofs);\n\t\tWARN_ON(1);\n\t\treturn NULL;\n\t}\n\n\t/* get tree root */\n\tpag = xfs_perag_get(btp->bt_mount,\n\t\t\t\txfs_daddr_to_agno(btp->bt_mount, blkno));\n\n\t/* walk tree */\n\tspin_lock(&pag->pag_buf_lock);\n\trbp = &pag->pag_buf_tree.rb_node;\n\tparent = NULL;\n\tbp = NULL;\n\twhile (*rbp) {\n\t\tparent = *rbp;\n\t\tbp = rb_entry(parent, struct xfs_buf, b_rbnode);\n\n\t\tif (blkno < bp->b_bn)\n\t\t\trbp = &(*rbp)->rb_left;\n\t\telse if (blkno > bp->b_bn)\n\t\t\trbp = &(*rbp)->rb_right;\n\t\telse {\n\t\t\t/*\n\t\t\t * found a block number match. If the range doesn't\n\t\t\t * match, the only way this is allowed is if the buffer\n\t\t\t * in the cache is stale and the transaction that made\n\t\t\t * it stale has not yet committed. i.e. we are\n\t\t\t * reallocating a busy extent. Skip this buffer and\n\t\t\t * continue searching to the right for an exact match.\n\t\t\t */\n\t\t\tif (bp->b_length != numblks) {\n\t\t\t\tASSERT(bp->b_flags & XBF_STALE);\n\t\t\t\trbp = &(*rbp)->rb_right;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tatomic_inc(&bp->b_hold);\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\t/* No match found */\n\tif (new_bp) {\n\t\trb_link_node(&new_bp->b_rbnode, parent, rbp);\n\t\trb_insert_color(&new_bp->b_rbnode, &pag->pag_buf_tree);\n\t\t/* the buffer keeps the perag reference until it is freed */\n\t\tnew_bp->b_pag = pag;\n\t\tspin_unlock(&pag->pag_buf_lock);\n\t} else {\n\t\tXFS_STATS_INC(xb_miss_locked);\n\t\tspin_unlock(&pag->pag_buf_lock);\n\t\txfs_perag_put(pag);\n\t}\n\treturn new_bp;\n\nfound:\n\tspin_unlock(&pag->pag_buf_lock);\n\txfs_perag_put(pag);\n\n\tif (!xfs_buf_trylock(bp)) {\n\t\tif (flags & XBF_TRYLOCK) {\n\t\t\txfs_buf_rele(bp);\n\t\t\tXFS_STATS_INC(xb_busy_locked);\n\t\t\treturn NULL;\n\t\t}\n\t\txfs_buf_lock(bp);\n\t\tXFS_STATS_INC(xb_get_locked_waited);\n\t}\n\n\t/*\n\t * if the buffer is stale, clear all the external state associated with\n\t * it. We need to keep flags such as how we allocated the buffer memory\n\t * intact here.\n\t */\n\tif (bp->b_flags & XBF_STALE) {\n\t\tASSERT((bp->b_flags & _XBF_DELWRI_Q) == 0);\n\t\tASSERT(bp->b_iodone == NULL);\n\t\tbp->b_flags &= _XBF_KMEM | _XBF_PAGES;\n\t\tbp->b_ops = NULL;\n\t}\n\n\ttrace_xfs_buf_find(bp, flags, _RET_IP_);\n\tXFS_STATS_INC(xb_get_locked);\n\treturn bp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEFINE_SINGLE_BUF_MAP",
          "args": [
            "map",
            "blkno",
            "numblks"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline struct xfs_buf *\nxfs_incore(\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tsize_t\t\t\tnumblks,\n\txfs_buf_flags_t\t\tflags)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn _xfs_buf_find(target, &map, 1, flags, NULL);\n}"
  }
]