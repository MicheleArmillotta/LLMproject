[
  {
    "function_name": "iopen_go_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glops.c",
    "lines": "537-551",
    "snippet": "static void iopen_go_callback(struct gfs2_glock *gl, bool remote)\n{\n\tstruct gfs2_inode *ip = (struct gfs2_inode *)gl->gl_object;\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\n\tif (!remote || (sdp->sd_vfs->s_flags & MS_RDONLY))\n\t\treturn;\n\n\tif (gl->gl_demote_state == LM_ST_UNLOCKED &&\n\t    gl->gl_state == LM_ST_SHARED && ip) {\n\t\tgl->gl_lockref.count++;\n\t\tif (queue_work(gfs2_delete_workqueue, &gl->gl_delete) == 0)\n\t\t\tgl->gl_lockref.count--;\n\t}\n}",
    "includes": [
      "#include \"dir.h\"",
      "#include \"trans.h\"",
      "#include \"util.h\"",
      "#include \"rgrp.h\"",
      "#include \"recovery.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/posix_acl.h>",
      "#include <linux/bio.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "gfs2_delete_workqueue",
            "&gl->gl_delete"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dir.h\"\n#include \"trans.h\"\n#include \"util.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/posix_acl.h>\n#include <linux/bio.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic void iopen_go_callback(struct gfs2_glock *gl, bool remote)\n{\n\tstruct gfs2_inode *ip = (struct gfs2_inode *)gl->gl_object;\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\n\tif (!remote || (sdp->sd_vfs->s_flags & MS_RDONLY))\n\t\treturn;\n\n\tif (gl->gl_demote_state == LM_ST_UNLOCKED &&\n\t    gl->gl_state == LM_ST_SHARED && ip) {\n\t\tgl->gl_lockref.count++;\n\t\tif (queue_work(gfs2_delete_workqueue, &gl->gl_delete) == 0)\n\t\t\tgl->gl_lockref.count--;\n\t}\n}"
  },
  {
    "function_name": "freeze_go_demote_ok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glops.c",
    "lines": "526-529",
    "snippet": "static int freeze_go_demote_ok(const struct gfs2_glock *gl)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"dir.h\"",
      "#include \"trans.h\"",
      "#include \"util.h\"",
      "#include \"rgrp.h\"",
      "#include \"recovery.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/posix_acl.h>",
      "#include <linux/bio.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"dir.h\"\n#include \"trans.h\"\n#include \"util.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/posix_acl.h>\n#include <linux/bio.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic int freeze_go_demote_ok(const struct gfs2_glock *gl)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "freeze_go_xmote_bh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glops.c",
    "lines": "493-517",
    "snippet": "static int freeze_go_xmote_bh(struct gfs2_glock *gl, struct gfs2_holder *gh)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_jdesc->jd_inode);\n\tstruct gfs2_glock *j_gl = ip->i_gl;\n\tstruct gfs2_log_header_host head;\n\tint error;\n\n\tif (test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags)) {\n\t\tj_gl->gl_ops->go_inval(j_gl, DIO_METADATA);\n\n\t\terror = gfs2_find_jhead(sdp->sd_jdesc, &head);\n\t\tif (error)\n\t\t\tgfs2_consist(sdp);\n\t\tif (!(head.lh_flags & GFS2_LOG_HEAD_UNMOUNT))\n\t\t\tgfs2_consist(sdp);\n\n\t\t/*  Initialize some head of the log stuff  */\n\t\tif (!test_bit(SDF_SHUTDOWN, &sdp->sd_flags)) {\n\t\t\tsdp->sd_log_sequence = head.lh_sequence + 1;\n\t\t\tgfs2_log_pointers_init(sdp, head.lh_blkno);\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"dir.h\"",
      "#include \"trans.h\"",
      "#include \"util.h\"",
      "#include \"rgrp.h\"",
      "#include \"recovery.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/posix_acl.h>",
      "#include <linux/bio.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_log_pointers_init",
          "args": [
            "sdp",
            "head.lh_blkno"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_log_pointers_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/log.h",
          "lines": "42-49",
          "snippet": "static inline void gfs2_log_pointers_init(struct gfs2_sbd *sdp,\n\t\t\t\t\t  unsigned int value)\n{\n\tif (++value == sdp->sd_jdesc->jd_blocks) {\n\t\tvalue = 0;\n\t}\n\tsdp->sd_log_head = sdp->sd_log_tail = value;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/writeback.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic inline void gfs2_log_pointers_init(struct gfs2_sbd *sdp,\n\t\t\t\t\t  unsigned int value)\n{\n\tif (++value == sdp->sd_jdesc->jd_blocks) {\n\t\tvalue = 0;\n\t}\n\tsdp->sd_log_head = sdp->sd_log_tail = value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "SDF_SHUTDOWN",
            "&sdp->sd_flags"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_consist",
          "args": [
            "sdp"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_consist",
          "args": [
            "sdp"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_find_jhead",
          "args": [
            "sdp->sd_jdesc",
            "&head"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_find_jhead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/recovery.c",
          "lines": "263-299",
          "snippet": "int gfs2_find_jhead(struct gfs2_jdesc *jd, struct gfs2_log_header_host *head)\n{\n\tstruct gfs2_log_header_host lh_1, lh_m;\n\tu32 blk_1, blk_2, blk_m;\n\tint error;\n\n\tblk_1 = 0;\n\tblk_2 = jd->jd_blocks - 1;\n\n\tfor (;;) {\n\t\tblk_m = (blk_1 + blk_2) / 2;\n\n\t\terror = find_good_lh(jd, &blk_1, &lh_1);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = find_good_lh(jd, &blk_m, &lh_m);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (blk_1 == blk_m || blk_m == blk_2)\n\t\t\tbreak;\n\n\t\tif (lh_1.lh_sequence <= lh_m.lh_sequence)\n\t\t\tblk_1 = blk_m;\n\t\telse\n\t\t\tblk_2 = blk_m;\n\t}\n\n\terror = jhead_scan(jd, &lh_1);\n\tif (error)\n\t\treturn error;\n\n\t*head = lh_1;\n\n\treturn error;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"recovery.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint gfs2_find_jhead(struct gfs2_jdesc *jd, struct gfs2_log_header_host *head)\n{\n\tstruct gfs2_log_header_host lh_1, lh_m;\n\tu32 blk_1, blk_2, blk_m;\n\tint error;\n\n\tblk_1 = 0;\n\tblk_2 = jd->jd_blocks - 1;\n\n\tfor (;;) {\n\t\tblk_m = (blk_1 + blk_2) / 2;\n\n\t\terror = find_good_lh(jd, &blk_1, &lh_1);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = find_good_lh(jd, &blk_m, &lh_m);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (blk_1 == blk_m || blk_m == blk_2)\n\t\t\tbreak;\n\n\t\tif (lh_1.lh_sequence <= lh_m.lh_sequence)\n\t\t\tblk_1 = blk_m;\n\t\telse\n\t\t\tblk_2 = blk_m;\n\t}\n\n\terror = jhead_scan(jd, &lh_1);\n\tif (error)\n\t\treturn error;\n\n\t*head = lh_1;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "j_gl->gl_ops->go_inval",
          "args": [
            "j_gl",
            "DIO_METADATA"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "sdp->sd_jdesc->jd_inode"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dir.h\"\n#include \"trans.h\"\n#include \"util.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/posix_acl.h>\n#include <linux/bio.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic int freeze_go_xmote_bh(struct gfs2_glock *gl, struct gfs2_holder *gh)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_inode *ip = GFS2_I(sdp->sd_jdesc->jd_inode);\n\tstruct gfs2_glock *j_gl = ip->i_gl;\n\tstruct gfs2_log_header_host head;\n\tint error;\n\n\tif (test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags)) {\n\t\tj_gl->gl_ops->go_inval(j_gl, DIO_METADATA);\n\n\t\terror = gfs2_find_jhead(sdp->sd_jdesc, &head);\n\t\tif (error)\n\t\t\tgfs2_consist(sdp);\n\t\tif (!(head.lh_flags & GFS2_LOG_HEAD_UNMOUNT))\n\t\t\tgfs2_consist(sdp);\n\n\t\t/*  Initialize some head of the log stuff  */\n\t\tif (!test_bit(SDF_SHUTDOWN, &sdp->sd_flags)) {\n\t\t\tsdp->sd_log_sequence = head.lh_sequence + 1;\n\t\t\tgfs2_log_pointers_init(sdp, head.lh_blkno);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "freeze_go_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glops.c",
    "lines": "469-485",
    "snippet": "static void freeze_go_sync(struct gfs2_glock *gl)\n{\n\tint error = 0;\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\n\tif (gl->gl_state == LM_ST_SHARED &&\n\t    test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags)) {\n\t\tatomic_set(&sdp->sd_freeze_state, SFS_STARTING_FREEZE);\n\t\terror = freeze_super(sdp->sd_vfs);\n\t\tif (error) {\n\t\t\tprintk(KERN_INFO \"GFS2: couldn't freeze filesystem: %d\\n\", error);\n\t\t\tgfs2_assert_withdraw(sdp, 0);\n\t\t}\n\t\tqueue_work(gfs2_freeze_wq, &sdp->sd_freeze_work);\n\t\tgfs2_log_flush(sdp, NULL, FREEZE_FLUSH);\n\t}\n}",
    "includes": [
      "#include \"dir.h\"",
      "#include \"trans.h\"",
      "#include \"util.h\"",
      "#include \"rgrp.h\"",
      "#include \"recovery.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/posix_acl.h>",
      "#include <linux/bio.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct workqueue_struct *gfs2_freeze_wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_log_flush",
          "args": [
            "sdp",
            "NULL",
            "FREEZE_FLUSH"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_log_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/log.c",
          "lines": "704-787",
          "snippet": "void gfs2_log_flush(struct gfs2_sbd *sdp, struct gfs2_glock *gl,\n\t\t    enum gfs2_flush_type type)\n{\n\tstruct gfs2_trans *tr;\n\tenum gfs2_freeze_state state = atomic_read(&sdp->sd_freeze_state);\n\n\tdown_write(&sdp->sd_log_flush_lock);\n\n\t/* Log might have been flushed while we waited for the flush lock */\n\tif (gl && !test_bit(GLF_LFLUSH, &gl->gl_flags)) {\n\t\tup_write(&sdp->sd_log_flush_lock);\n\t\treturn;\n\t}\n\ttrace_gfs2_log_flush(sdp, 1);\n\n\tsdp->sd_log_flush_head = sdp->sd_log_head;\n\tsdp->sd_log_flush_wrapped = 0;\n\ttr = sdp->sd_log_tr;\n\tif (tr) {\n\t\tsdp->sd_log_tr = NULL;\n\t\tINIT_LIST_HEAD(&tr->tr_ail1_list);\n\t\tINIT_LIST_HEAD(&tr->tr_ail2_list);\n\t\ttr->tr_first = sdp->sd_log_flush_head;\n\t\tif (unlikely (state == SFS_FROZEN))\n\t\t\tgfs2_assert_withdraw(sdp, !tr->tr_num_buf_new && !tr->tr_num_databuf_new);\n\t}\n\n\tif (unlikely(state == SFS_FROZEN))\n\t\tgfs2_assert_withdraw(sdp, !sdp->sd_log_num_revoke);\n\tgfs2_assert_withdraw(sdp,\n\t\t\tsdp->sd_log_num_revoke == sdp->sd_log_commited_revoke);\n\n\tgfs2_ordered_write(sdp);\n\tlops_before_commit(sdp, tr);\n\tgfs2_log_flush_bio(sdp, WRITE);\n\n\tif (sdp->sd_log_head != sdp->sd_log_flush_head) {\n\t\tlog_flush_wait(sdp);\n\t\tlog_write_header(sdp, 0);\n\t} else if (sdp->sd_log_tail != current_tail(sdp) && !sdp->sd_log_idle){\n\t\tatomic_dec(&sdp->sd_log_blks_free); /* Adjust for unreserved buffer */\n\t\ttrace_gfs2_log_blocks(sdp, -1);\n\t\tlog_write_header(sdp, 0);\n\t}\n\tlops_after_commit(sdp, tr);\n\n\tgfs2_log_lock(sdp);\n\tsdp->sd_log_head = sdp->sd_log_flush_head;\n\tsdp->sd_log_blks_reserved = 0;\n\tsdp->sd_log_commited_revoke = 0;\n\n\tspin_lock(&sdp->sd_ail_lock);\n\tif (tr && !list_empty(&tr->tr_ail1_list)) {\n\t\tlist_add(&tr->tr_list, &sdp->sd_ail1_list);\n\t\ttr = NULL;\n\t}\n\tspin_unlock(&sdp->sd_ail_lock);\n\tgfs2_log_unlock(sdp);\n\n\tif (type != NORMAL_FLUSH) {\n\t\tif (!sdp->sd_log_idle) {\n\t\t\tfor (;;) {\n\t\t\t\tgfs2_ail1_start(sdp);\n\t\t\t\tgfs2_ail1_wait(sdp);\n\t\t\t\tif (gfs2_ail1_empty(sdp))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tatomic_dec(&sdp->sd_log_blks_free); /* Adjust for unreserved buffer */\n\t\t\ttrace_gfs2_log_blocks(sdp, -1);\n\t\t\tsdp->sd_log_flush_wrapped = 0;\n\t\t\tlog_write_header(sdp, 0);\n\t\t\tsdp->sd_log_head = sdp->sd_log_flush_head;\n\t\t}\n\t\tif (type == SHUTDOWN_FLUSH || type == FREEZE_FLUSH)\n\t\t\tgfs2_log_shutdown(sdp);\n\t\tif (type == FREEZE_FLUSH)\n\t\t\tatomic_set(&sdp->sd_freeze_state, SFS_FROZEN);\n\t}\n\n\ttrace_gfs2_log_flush(sdp, 0);\n\tup_write(&sdp->sd_log_flush_lock);\n\n\tkfree(tr);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/list_sort.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_log_flush(struct gfs2_sbd *sdp, struct gfs2_glock *gl,\n\t\t    enum gfs2_flush_type type)\n{\n\tstruct gfs2_trans *tr;\n\tenum gfs2_freeze_state state = atomic_read(&sdp->sd_freeze_state);\n\n\tdown_write(&sdp->sd_log_flush_lock);\n\n\t/* Log might have been flushed while we waited for the flush lock */\n\tif (gl && !test_bit(GLF_LFLUSH, &gl->gl_flags)) {\n\t\tup_write(&sdp->sd_log_flush_lock);\n\t\treturn;\n\t}\n\ttrace_gfs2_log_flush(sdp, 1);\n\n\tsdp->sd_log_flush_head = sdp->sd_log_head;\n\tsdp->sd_log_flush_wrapped = 0;\n\ttr = sdp->sd_log_tr;\n\tif (tr) {\n\t\tsdp->sd_log_tr = NULL;\n\t\tINIT_LIST_HEAD(&tr->tr_ail1_list);\n\t\tINIT_LIST_HEAD(&tr->tr_ail2_list);\n\t\ttr->tr_first = sdp->sd_log_flush_head;\n\t\tif (unlikely (state == SFS_FROZEN))\n\t\t\tgfs2_assert_withdraw(sdp, !tr->tr_num_buf_new && !tr->tr_num_databuf_new);\n\t}\n\n\tif (unlikely(state == SFS_FROZEN))\n\t\tgfs2_assert_withdraw(sdp, !sdp->sd_log_num_revoke);\n\tgfs2_assert_withdraw(sdp,\n\t\t\tsdp->sd_log_num_revoke == sdp->sd_log_commited_revoke);\n\n\tgfs2_ordered_write(sdp);\n\tlops_before_commit(sdp, tr);\n\tgfs2_log_flush_bio(sdp, WRITE);\n\n\tif (sdp->sd_log_head != sdp->sd_log_flush_head) {\n\t\tlog_flush_wait(sdp);\n\t\tlog_write_header(sdp, 0);\n\t} else if (sdp->sd_log_tail != current_tail(sdp) && !sdp->sd_log_idle){\n\t\tatomic_dec(&sdp->sd_log_blks_free); /* Adjust for unreserved buffer */\n\t\ttrace_gfs2_log_blocks(sdp, -1);\n\t\tlog_write_header(sdp, 0);\n\t}\n\tlops_after_commit(sdp, tr);\n\n\tgfs2_log_lock(sdp);\n\tsdp->sd_log_head = sdp->sd_log_flush_head;\n\tsdp->sd_log_blks_reserved = 0;\n\tsdp->sd_log_commited_revoke = 0;\n\n\tspin_lock(&sdp->sd_ail_lock);\n\tif (tr && !list_empty(&tr->tr_ail1_list)) {\n\t\tlist_add(&tr->tr_list, &sdp->sd_ail1_list);\n\t\ttr = NULL;\n\t}\n\tspin_unlock(&sdp->sd_ail_lock);\n\tgfs2_log_unlock(sdp);\n\n\tif (type != NORMAL_FLUSH) {\n\t\tif (!sdp->sd_log_idle) {\n\t\t\tfor (;;) {\n\t\t\t\tgfs2_ail1_start(sdp);\n\t\t\t\tgfs2_ail1_wait(sdp);\n\t\t\t\tif (gfs2_ail1_empty(sdp))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tatomic_dec(&sdp->sd_log_blks_free); /* Adjust for unreserved buffer */\n\t\t\ttrace_gfs2_log_blocks(sdp, -1);\n\t\t\tsdp->sd_log_flush_wrapped = 0;\n\t\t\tlog_write_header(sdp, 0);\n\t\t\tsdp->sd_log_head = sdp->sd_log_flush_head;\n\t\t}\n\t\tif (type == SHUTDOWN_FLUSH || type == FREEZE_FLUSH)\n\t\t\tgfs2_log_shutdown(sdp);\n\t\tif (type == FREEZE_FLUSH)\n\t\t\tatomic_set(&sdp->sd_freeze_state, SFS_FROZEN);\n\t}\n\n\ttrace_gfs2_log_flush(sdp, 0);\n\tup_write(&sdp->sd_log_flush_lock);\n\n\tkfree(tr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "gfs2_freeze_wq",
            "&sdp->sd_freeze_work"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_assert_withdraw",
          "args": [
            "sdp",
            "0"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"GFS2: couldn't freeze filesystem: %d\\n\"",
            "error"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "freeze_super",
          "args": [
            "sdp->sd_vfs"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&sdp->sd_freeze_state",
            "SFS_STARTING_FREEZE"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "SDF_JOURNAL_LIVE",
            "&sdp->sd_flags"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dir.h\"\n#include \"trans.h\"\n#include \"util.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/posix_acl.h>\n#include <linux/bio.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstruct workqueue_struct *gfs2_freeze_wq;\n\nstatic void freeze_go_sync(struct gfs2_glock *gl)\n{\n\tint error = 0;\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\n\tif (gl->gl_state == LM_ST_SHARED &&\n\t    test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags)) {\n\t\tatomic_set(&sdp->sd_freeze_state, SFS_STARTING_FREEZE);\n\t\terror = freeze_super(sdp->sd_vfs);\n\t\tif (error) {\n\t\t\tprintk(KERN_INFO \"GFS2: couldn't freeze filesystem: %d\\n\", error);\n\t\t\tgfs2_assert_withdraw(sdp, 0);\n\t\t}\n\t\tqueue_work(gfs2_freeze_wq, &sdp->sd_freeze_work);\n\t\tgfs2_log_flush(sdp, NULL, FREEZE_FLUSH);\n\t}\n}"
  },
  {
    "function_name": "inode_go_dump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glops.c",
    "lines": "448-459",
    "snippet": "static void inode_go_dump(struct seq_file *seq, const struct gfs2_glock *gl)\n{\n\tconst struct gfs2_inode *ip = gl->gl_object;\n\tif (ip == NULL)\n\t\treturn;\n\tgfs2_print_dbg(seq, \" I: n:%llu/%llu t:%u f:0x%02lx d:0x%08x s:%llu\\n\",\n\t\t  (unsigned long long)ip->i_no_formal_ino,\n\t\t  (unsigned long long)ip->i_no_addr,\n\t\t  IF2DT(ip->i_inode.i_mode), ip->i_flags,\n\t\t  (unsigned int)ip->i_diskflags,\n\t\t  (unsigned long long)i_size_read(&ip->i_inode));\n}",
    "includes": [
      "#include \"dir.h\"",
      "#include \"trans.h\"",
      "#include \"util.h\"",
      "#include \"rgrp.h\"",
      "#include \"recovery.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/posix_acl.h>",
      "#include <linux/bio.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_print_dbg",
          "args": [
            "seq",
            "\" I: n:%llu/%llu t:%u f:0x%02lx d:0x%08x s:%llu\\n\"",
            "(unsigned long long)ip->i_no_formal_ino",
            "(unsigned long long)ip->i_no_addr",
            "IF2DT(ip->i_inode.i_mode)",
            "ip->i_flags",
            "(unsigned int)ip->i_diskflags",
            "(unsigned long long)i_size_read(&ip->i_inode)"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_print_dbg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "897-914",
          "snippet": "void gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (seq) {\n\t\tseq_vprintf(seq, fmt, args);\n\t} else {\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\n\t\tpr_err(\"%pV\", &vaf);\n\t}\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_print_dbg(struct seq_file *seq, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (seq) {\n\t\tseq_vprintf(seq, fmt, args);\n\t} else {\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\n\t\tpr_err(\"%pV\", &vaf);\n\t}\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "&ip->i_inode"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF2DT",
          "args": [
            "ip->i_inode.i_mode"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dir.h\"\n#include \"trans.h\"\n#include \"util.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/posix_acl.h>\n#include <linux/bio.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic void inode_go_dump(struct seq_file *seq, const struct gfs2_glock *gl)\n{\n\tconst struct gfs2_inode *ip = gl->gl_object;\n\tif (ip == NULL)\n\t\treturn;\n\tgfs2_print_dbg(seq, \" I: n:%llu/%llu t:%u f:0x%02lx d:0x%08x s:%llu\\n\",\n\t\t  (unsigned long long)ip->i_no_formal_ino,\n\t\t  (unsigned long long)ip->i_no_addr,\n\t\t  IF2DT(ip->i_inode.i_mode), ip->i_flags,\n\t\t  (unsigned int)ip->i_diskflags,\n\t\t  (unsigned long long)i_size_read(&ip->i_inode));\n}"
  },
  {
    "function_name": "inode_go_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glops.c",
    "lines": "408-439",
    "snippet": "static int inode_go_lock(struct gfs2_holder *gh)\n{\n\tstruct gfs2_glock *gl = gh->gh_gl;\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_inode *ip = gl->gl_object;\n\tint error = 0;\n\n\tif (!ip || (gh->gh_flags & GL_SKIP))\n\t\treturn 0;\n\n\tif (test_bit(GIF_INVALID, &ip->i_flags)) {\n\t\terror = gfs2_inode_refresh(ip);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (gh->gh_state != LM_ST_DEFERRED)\n\t\tinode_dio_wait(&ip->i_inode);\n\n\tif ((ip->i_diskflags & GFS2_DIF_TRUNC_IN_PROG) &&\n\t    (gl->gl_state == LM_ST_EXCLUSIVE) &&\n\t    (gh->gh_state == LM_ST_EXCLUSIVE)) {\n\t\tspin_lock(&sdp->sd_trunc_lock);\n\t\tif (list_empty(&ip->i_trunc_list))\n\t\t\tlist_add(&sdp->sd_trunc_list, &ip->i_trunc_list);\n\t\tspin_unlock(&sdp->sd_trunc_lock);\n\t\twake_up(&sdp->sd_quota_wait);\n\t\treturn 1;\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"dir.h\"",
      "#include \"trans.h\"",
      "#include \"util.h\"",
      "#include \"rgrp.h\"",
      "#include \"recovery.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/posix_acl.h>",
      "#include <linux/bio.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&sdp->sd_quota_wait"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_wake_up_statfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "1409-1414",
          "snippet": "void gfs2_wake_up_statfs(struct gfs2_sbd *sdp) {\n\tif (!sdp->sd_statfs_force_sync) {\n\t\tsdp->sd_statfs_force_sync = 1;\n\t\twake_up(&sdp->sd_quota_wait);\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_wake_up_statfs(struct gfs2_sbd *sdp) {\n\tif (!sdp->sd_statfs_force_sync) {\n\t\tsdp->sd_statfs_force_sync = 1;\n\t\twake_up(&sdp->sd_quota_wait);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sdp->sd_trunc_lock"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&sdp->sd_trunc_list",
            "&ip->i_trunc_list"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ip->i_trunc_list"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sdp->sd_trunc_lock"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_dio_wait",
          "args": [
            "&ip->i_inode"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "inode_dio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1941-1945",
          "snippet": "void inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_inode_refresh",
          "args": [
            "ip"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_inode_refresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glops.c",
          "lines": "384-398",
          "snippet": "int gfs2_inode_refresh(struct gfs2_inode *ip)\n{\n\tstruct buffer_head *dibh;\n\tint error;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_dinode_in(ip, dibh->b_data);\n\tbrelse(dibh);\n\tclear_bit(GIF_INVALID, &ip->i_flags);\n\n\treturn error;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"util.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/posix_acl.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"trans.h\"\n#include \"util.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/posix_acl.h>\n#include <linux/bio.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_inode_refresh(struct gfs2_inode *ip)\n{\n\tstruct buffer_head *dibh;\n\tint error;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_dinode_in(ip, dibh->b_data);\n\tbrelse(dibh);\n\tclear_bit(GIF_INVALID, &ip->i_flags);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "GIF_INVALID",
            "&ip->i_flags"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dir.h\"\n#include \"trans.h\"\n#include \"util.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/posix_acl.h>\n#include <linux/bio.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic int inode_go_lock(struct gfs2_holder *gh)\n{\n\tstruct gfs2_glock *gl = gh->gh_gl;\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_inode *ip = gl->gl_object;\n\tint error = 0;\n\n\tif (!ip || (gh->gh_flags & GL_SKIP))\n\t\treturn 0;\n\n\tif (test_bit(GIF_INVALID, &ip->i_flags)) {\n\t\terror = gfs2_inode_refresh(ip);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (gh->gh_state != LM_ST_DEFERRED)\n\t\tinode_dio_wait(&ip->i_inode);\n\n\tif ((ip->i_diskflags & GFS2_DIF_TRUNC_IN_PROG) &&\n\t    (gl->gl_state == LM_ST_EXCLUSIVE) &&\n\t    (gh->gh_state == LM_ST_EXCLUSIVE)) {\n\t\tspin_lock(&sdp->sd_trunc_lock);\n\t\tif (list_empty(&ip->i_trunc_list))\n\t\t\tlist_add(&sdp->sd_trunc_list, &ip->i_trunc_list);\n\t\tspin_unlock(&sdp->sd_trunc_lock);\n\t\twake_up(&sdp->sd_quota_wait);\n\t\treturn 1;\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "gfs2_inode_refresh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glops.c",
    "lines": "384-398",
    "snippet": "int gfs2_inode_refresh(struct gfs2_inode *ip)\n{\n\tstruct buffer_head *dibh;\n\tint error;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_dinode_in(ip, dibh->b_data);\n\tbrelse(dibh);\n\tclear_bit(GIF_INVALID, &ip->i_flags);\n\n\treturn error;\n}",
    "includes": [
      "#include \"dir.h\"",
      "#include \"trans.h\"",
      "#include \"util.h\"",
      "#include \"rgrp.h\"",
      "#include \"recovery.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/posix_acl.h>",
      "#include <linux/bio.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "GIF_INVALID",
            "&ip->i_flags"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "dibh"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_dinode_in",
          "args": [
            "ip",
            "dibh->b_data"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dinode_in",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glops.c",
          "lines": "317-375",
          "snippet": "static int gfs2_dinode_in(struct gfs2_inode *ip, const void *buf)\n{\n\tconst struct gfs2_dinode *str = buf;\n\tstruct timespec atime;\n\tu16 height, depth;\n\n\tif (unlikely(ip->i_no_addr != be64_to_cpu(str->di_num.no_addr)))\n\t\tgoto corrupt;\n\tip->i_no_formal_ino = be64_to_cpu(str->di_num.no_formal_ino);\n\tip->i_inode.i_mode = be32_to_cpu(str->di_mode);\n\tip->i_inode.i_rdev = 0;\n\tswitch (ip->i_inode.i_mode & S_IFMT) {\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\t\tip->i_inode.i_rdev = MKDEV(be32_to_cpu(str->di_major),\n\t\t\t\t\t   be32_to_cpu(str->di_minor));\n\t\tbreak;\n\t};\n\n\ti_uid_write(&ip->i_inode, be32_to_cpu(str->di_uid));\n\ti_gid_write(&ip->i_inode, be32_to_cpu(str->di_gid));\n\tgfs2_set_nlink(&ip->i_inode, be32_to_cpu(str->di_nlink));\n\ti_size_write(&ip->i_inode, be64_to_cpu(str->di_size));\n\tgfs2_set_inode_blocks(&ip->i_inode, be64_to_cpu(str->di_blocks));\n\tatime.tv_sec = be64_to_cpu(str->di_atime);\n\tatime.tv_nsec = be32_to_cpu(str->di_atime_nsec);\n\tif (timespec_compare(&ip->i_inode.i_atime, &atime) < 0)\n\t\tip->i_inode.i_atime = atime;\n\tip->i_inode.i_mtime.tv_sec = be64_to_cpu(str->di_mtime);\n\tip->i_inode.i_mtime.tv_nsec = be32_to_cpu(str->di_mtime_nsec);\n\tip->i_inode.i_ctime.tv_sec = be64_to_cpu(str->di_ctime);\n\tip->i_inode.i_ctime.tv_nsec = be32_to_cpu(str->di_ctime_nsec);\n\n\tip->i_goal = be64_to_cpu(str->di_goal_meta);\n\tip->i_generation = be64_to_cpu(str->di_generation);\n\n\tip->i_diskflags = be32_to_cpu(str->di_flags);\n\tip->i_eattr = be64_to_cpu(str->di_eattr);\n\t/* i_diskflags and i_eattr must be set before gfs2_set_inode_flags() */\n\tgfs2_set_inode_flags(&ip->i_inode);\n\theight = be16_to_cpu(str->di_height);\n\tif (unlikely(height > GFS2_MAX_META_HEIGHT))\n\t\tgoto corrupt;\n\tip->i_height = (u8)height;\n\n\tdepth = be16_to_cpu(str->di_depth);\n\tif (unlikely(depth > GFS2_DIR_MAX_DEPTH))\n\t\tgoto corrupt;\n\tip->i_depth = (u8)depth;\n\tip->i_entries = be32_to_cpu(str->di_entries);\n\n\tif (S_ISREG(ip->i_inode.i_mode))\n\t\tgfs2_set_aops(&ip->i_inode);\n\n\treturn 0;\ncorrupt:\n\tgfs2_consist_inode(ip);\n\treturn -EIO;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"util.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/posix_acl.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"trans.h\"\n#include \"util.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/posix_acl.h>\n#include <linux/bio.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic int gfs2_dinode_in(struct gfs2_inode *ip, const void *buf)\n{\n\tconst struct gfs2_dinode *str = buf;\n\tstruct timespec atime;\n\tu16 height, depth;\n\n\tif (unlikely(ip->i_no_addr != be64_to_cpu(str->di_num.no_addr)))\n\t\tgoto corrupt;\n\tip->i_no_formal_ino = be64_to_cpu(str->di_num.no_formal_ino);\n\tip->i_inode.i_mode = be32_to_cpu(str->di_mode);\n\tip->i_inode.i_rdev = 0;\n\tswitch (ip->i_inode.i_mode & S_IFMT) {\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\t\tip->i_inode.i_rdev = MKDEV(be32_to_cpu(str->di_major),\n\t\t\t\t\t   be32_to_cpu(str->di_minor));\n\t\tbreak;\n\t};\n\n\ti_uid_write(&ip->i_inode, be32_to_cpu(str->di_uid));\n\ti_gid_write(&ip->i_inode, be32_to_cpu(str->di_gid));\n\tgfs2_set_nlink(&ip->i_inode, be32_to_cpu(str->di_nlink));\n\ti_size_write(&ip->i_inode, be64_to_cpu(str->di_size));\n\tgfs2_set_inode_blocks(&ip->i_inode, be64_to_cpu(str->di_blocks));\n\tatime.tv_sec = be64_to_cpu(str->di_atime);\n\tatime.tv_nsec = be32_to_cpu(str->di_atime_nsec);\n\tif (timespec_compare(&ip->i_inode.i_atime, &atime) < 0)\n\t\tip->i_inode.i_atime = atime;\n\tip->i_inode.i_mtime.tv_sec = be64_to_cpu(str->di_mtime);\n\tip->i_inode.i_mtime.tv_nsec = be32_to_cpu(str->di_mtime_nsec);\n\tip->i_inode.i_ctime.tv_sec = be64_to_cpu(str->di_ctime);\n\tip->i_inode.i_ctime.tv_nsec = be32_to_cpu(str->di_ctime_nsec);\n\n\tip->i_goal = be64_to_cpu(str->di_goal_meta);\n\tip->i_generation = be64_to_cpu(str->di_generation);\n\n\tip->i_diskflags = be32_to_cpu(str->di_flags);\n\tip->i_eattr = be64_to_cpu(str->di_eattr);\n\t/* i_diskflags and i_eattr must be set before gfs2_set_inode_flags() */\n\tgfs2_set_inode_flags(&ip->i_inode);\n\theight = be16_to_cpu(str->di_height);\n\tif (unlikely(height > GFS2_MAX_META_HEIGHT))\n\t\tgoto corrupt;\n\tip->i_height = (u8)height;\n\n\tdepth = be16_to_cpu(str->di_depth);\n\tif (unlikely(depth > GFS2_DIR_MAX_DEPTH))\n\t\tgoto corrupt;\n\tip->i_depth = (u8)depth;\n\tip->i_entries = be32_to_cpu(str->di_entries);\n\n\tif (S_ISREG(ip->i_inode.i_mode))\n\t\tgfs2_set_aops(&ip->i_inode);\n\n\treturn 0;\ncorrupt:\n\tgfs2_consist_inode(ip);\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_meta_inode_buffer",
          "args": [
            "ip",
            "&dibh"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_meta_inode_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/meta_io.h",
          "lines": "66-70",
          "snippet": "static inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline int gfs2_meta_inode_buffer(struct gfs2_inode *ip,\n\t\t\t\t\t struct buffer_head **bhp)\n{\n\treturn gfs2_meta_indirect_buffer(ip, 0, ip->i_no_addr, bhp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dir.h\"\n#include \"trans.h\"\n#include \"util.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/posix_acl.h>\n#include <linux/bio.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_inode_refresh(struct gfs2_inode *ip)\n{\n\tstruct buffer_head *dibh;\n\tint error;\n\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (error)\n\t\treturn error;\n\n\terror = gfs2_dinode_in(ip, dibh->b_data);\n\tbrelse(dibh);\n\tclear_bit(GIF_INVALID, &ip->i_flags);\n\n\treturn error;\n}"
  },
  {
    "function_name": "gfs2_dinode_in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glops.c",
    "lines": "317-375",
    "snippet": "static int gfs2_dinode_in(struct gfs2_inode *ip, const void *buf)\n{\n\tconst struct gfs2_dinode *str = buf;\n\tstruct timespec atime;\n\tu16 height, depth;\n\n\tif (unlikely(ip->i_no_addr != be64_to_cpu(str->di_num.no_addr)))\n\t\tgoto corrupt;\n\tip->i_no_formal_ino = be64_to_cpu(str->di_num.no_formal_ino);\n\tip->i_inode.i_mode = be32_to_cpu(str->di_mode);\n\tip->i_inode.i_rdev = 0;\n\tswitch (ip->i_inode.i_mode & S_IFMT) {\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\t\tip->i_inode.i_rdev = MKDEV(be32_to_cpu(str->di_major),\n\t\t\t\t\t   be32_to_cpu(str->di_minor));\n\t\tbreak;\n\t};\n\n\ti_uid_write(&ip->i_inode, be32_to_cpu(str->di_uid));\n\ti_gid_write(&ip->i_inode, be32_to_cpu(str->di_gid));\n\tgfs2_set_nlink(&ip->i_inode, be32_to_cpu(str->di_nlink));\n\ti_size_write(&ip->i_inode, be64_to_cpu(str->di_size));\n\tgfs2_set_inode_blocks(&ip->i_inode, be64_to_cpu(str->di_blocks));\n\tatime.tv_sec = be64_to_cpu(str->di_atime);\n\tatime.tv_nsec = be32_to_cpu(str->di_atime_nsec);\n\tif (timespec_compare(&ip->i_inode.i_atime, &atime) < 0)\n\t\tip->i_inode.i_atime = atime;\n\tip->i_inode.i_mtime.tv_sec = be64_to_cpu(str->di_mtime);\n\tip->i_inode.i_mtime.tv_nsec = be32_to_cpu(str->di_mtime_nsec);\n\tip->i_inode.i_ctime.tv_sec = be64_to_cpu(str->di_ctime);\n\tip->i_inode.i_ctime.tv_nsec = be32_to_cpu(str->di_ctime_nsec);\n\n\tip->i_goal = be64_to_cpu(str->di_goal_meta);\n\tip->i_generation = be64_to_cpu(str->di_generation);\n\n\tip->i_diskflags = be32_to_cpu(str->di_flags);\n\tip->i_eattr = be64_to_cpu(str->di_eattr);\n\t/* i_diskflags and i_eattr must be set before gfs2_set_inode_flags() */\n\tgfs2_set_inode_flags(&ip->i_inode);\n\theight = be16_to_cpu(str->di_height);\n\tif (unlikely(height > GFS2_MAX_META_HEIGHT))\n\t\tgoto corrupt;\n\tip->i_height = (u8)height;\n\n\tdepth = be16_to_cpu(str->di_depth);\n\tif (unlikely(depth > GFS2_DIR_MAX_DEPTH))\n\t\tgoto corrupt;\n\tip->i_depth = (u8)depth;\n\tip->i_entries = be32_to_cpu(str->di_entries);\n\n\tif (S_ISREG(ip->i_inode.i_mode))\n\t\tgfs2_set_aops(&ip->i_inode);\n\n\treturn 0;\ncorrupt:\n\tgfs2_consist_inode(ip);\n\treturn -EIO;\n}",
    "includes": [
      "#include \"dir.h\"",
      "#include \"trans.h\"",
      "#include \"util.h\"",
      "#include \"rgrp.h\"",
      "#include \"recovery.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/posix_acl.h>",
      "#include <linux/bio.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_consist_inode",
          "args": [
            "ip"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_set_aops",
          "args": [
            "&ip->i_inode"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_set_aops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/aops.c",
          "lines": "1218-1230",
          "snippet": "void gfs2_set_aops(struct inode *inode)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\n\tif (gfs2_is_writeback(ip))\n\t\tinode->i_mapping->a_ops = &gfs2_writeback_aops;\n\telse if (gfs2_is_ordered(ip))\n\t\tinode->i_mapping->a_ops = &gfs2_ordered_aops;\n\telse if (gfs2_is_jdata(ip))\n\t\tinode->i_mapping->a_ops = &gfs2_jdata_aops;\n\telse\n\t\tBUG();\n}",
          "includes": [
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"trans.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/aio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/fs.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct address_space_operations gfs2_writeback_aops = {\n\t.writepage = gfs2_writepage,\n\t.writepages = gfs2_writepages,\n\t.readpage = gfs2_readpage,\n\t.readpages = gfs2_readpages,\n\t.write_begin = gfs2_write_begin,\n\t.write_end = gfs2_write_end,\n\t.bmap = gfs2_bmap,\n\t.invalidatepage = gfs2_invalidatepage,\n\t.releasepage = gfs2_releasepage,\n\t.direct_IO = gfs2_direct_IO,\n\t.migratepage = buffer_migrate_page,\n\t.is_partially_uptodate = block_is_partially_uptodate,\n\t.error_remove_page = generic_error_remove_page,\n};",
            "static const struct address_space_operations gfs2_ordered_aops = {\n\t.writepage = gfs2_writepage,\n\t.writepages = gfs2_writepages,\n\t.readpage = gfs2_readpage,\n\t.readpages = gfs2_readpages,\n\t.write_begin = gfs2_write_begin,\n\t.write_end = gfs2_write_end,\n\t.set_page_dirty = gfs2_set_page_dirty,\n\t.bmap = gfs2_bmap,\n\t.invalidatepage = gfs2_invalidatepage,\n\t.releasepage = gfs2_releasepage,\n\t.direct_IO = gfs2_direct_IO,\n\t.migratepage = buffer_migrate_page,\n\t.is_partially_uptodate = block_is_partially_uptodate,\n\t.error_remove_page = generic_error_remove_page,\n};",
            "static const struct address_space_operations gfs2_jdata_aops = {\n\t.writepage = gfs2_jdata_writepage,\n\t.writepages = gfs2_jdata_writepages,\n\t.readpage = gfs2_readpage,\n\t.readpages = gfs2_readpages,\n\t.write_begin = gfs2_write_begin,\n\t.write_end = gfs2_write_end,\n\t.set_page_dirty = gfs2_set_page_dirty,\n\t.bmap = gfs2_bmap,\n\t.invalidatepage = gfs2_invalidatepage,\n\t.releasepage = gfs2_releasepage,\n\t.is_partially_uptodate = block_is_partially_uptodate,\n\t.error_remove_page = generic_error_remove_page,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"glops.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"trans.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <trace/events/writeback.h>\n#include <linux/aio.h>\n#include <linux/backing-dev.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/fs.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic const struct address_space_operations gfs2_writeback_aops = {\n\t.writepage = gfs2_writepage,\n\t.writepages = gfs2_writepages,\n\t.readpage = gfs2_readpage,\n\t.readpages = gfs2_readpages,\n\t.write_begin = gfs2_write_begin,\n\t.write_end = gfs2_write_end,\n\t.bmap = gfs2_bmap,\n\t.invalidatepage = gfs2_invalidatepage,\n\t.releasepage = gfs2_releasepage,\n\t.direct_IO = gfs2_direct_IO,\n\t.migratepage = buffer_migrate_page,\n\t.is_partially_uptodate = block_is_partially_uptodate,\n\t.error_remove_page = generic_error_remove_page,\n};\nstatic const struct address_space_operations gfs2_ordered_aops = {\n\t.writepage = gfs2_writepage,\n\t.writepages = gfs2_writepages,\n\t.readpage = gfs2_readpage,\n\t.readpages = gfs2_readpages,\n\t.write_begin = gfs2_write_begin,\n\t.write_end = gfs2_write_end,\n\t.set_page_dirty = gfs2_set_page_dirty,\n\t.bmap = gfs2_bmap,\n\t.invalidatepage = gfs2_invalidatepage,\n\t.releasepage = gfs2_releasepage,\n\t.direct_IO = gfs2_direct_IO,\n\t.migratepage = buffer_migrate_page,\n\t.is_partially_uptodate = block_is_partially_uptodate,\n\t.error_remove_page = generic_error_remove_page,\n};\nstatic const struct address_space_operations gfs2_jdata_aops = {\n\t.writepage = gfs2_jdata_writepage,\n\t.writepages = gfs2_jdata_writepages,\n\t.readpage = gfs2_readpage,\n\t.readpages = gfs2_readpages,\n\t.write_begin = gfs2_write_begin,\n\t.write_end = gfs2_write_end,\n\t.set_page_dirty = gfs2_set_page_dirty,\n\t.bmap = gfs2_bmap,\n\t.invalidatepage = gfs2_invalidatepage,\n\t.releasepage = gfs2_releasepage,\n\t.is_partially_uptodate = block_is_partially_uptodate,\n\t.error_remove_page = generic_error_remove_page,\n};\n\nvoid gfs2_set_aops(struct inode *inode)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\n\tif (gfs2_is_writeback(ip))\n\t\tinode->i_mapping->a_ops = &gfs2_writeback_aops;\n\telse if (gfs2_is_ordered(ip))\n\t\tinode->i_mapping->a_ops = &gfs2_ordered_aops;\n\telse if (gfs2_is_jdata(ip))\n\t\tinode->i_mapping->a_ops = &gfs2_jdata_aops;\n\telse\n\t\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "ip->i_inode.i_mode"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "str->di_entries"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "depth > GFS2_DIR_MAX_DEPTH"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "str->di_depth"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "height > GFS2_MAX_META_HEIGHT"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "str->di_height"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_set_inode_flags",
          "args": [
            "&ip->i_inode"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_set_inode_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/file.c",
          "lines": "177-194",
          "snippet": "void gfs2_set_inode_flags(struct inode *inode)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tunsigned int flags = inode->i_flags;\n\n\tflags &= ~(S_SYNC|S_APPEND|S_IMMUTABLE|S_NOATIME|S_DIRSYNC|S_NOSEC);\n\tif ((ip->i_eattr == 0) && !is_sxid(inode->i_mode))\n\t\tinode->i_flags |= S_NOSEC;\n\tif (ip->i_diskflags & GFS2_DIF_IMMUTABLE)\n\t\tflags |= S_IMMUTABLE;\n\tif (ip->i_diskflags & GFS2_DIF_APPENDONLY)\n\t\tflags |= S_APPEND;\n\tif (ip->i_diskflags & GFS2_DIF_NOATIME)\n\t\tflags |= S_NOATIME;\n\tif (ip->i_diskflags & GFS2_DIF_SYNC)\n\t\tflags |= S_SYNC;\n\tinode->i_flags = flags;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/delay.h>",
            "#include <linux/aio.h>",
            "#include <linux/dlm_plock.h>",
            "#include <linux/dlm.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/writeback.h>",
            "#include <linux/crc32.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/delay.h>\n#include <linux/aio.h>\n#include <linux/dlm_plock.h>\n#include <linux/dlm.h>\n#include <asm/uaccess.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/blkdev.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_set_inode_flags(struct inode *inode)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tunsigned int flags = inode->i_flags;\n\n\tflags &= ~(S_SYNC|S_APPEND|S_IMMUTABLE|S_NOATIME|S_DIRSYNC|S_NOSEC);\n\tif ((ip->i_eattr == 0) && !is_sxid(inode->i_mode))\n\t\tinode->i_flags |= S_NOSEC;\n\tif (ip->i_diskflags & GFS2_DIF_IMMUTABLE)\n\t\tflags |= S_IMMUTABLE;\n\tif (ip->i_diskflags & GFS2_DIF_APPENDONLY)\n\t\tflags |= S_APPEND;\n\tif (ip->i_diskflags & GFS2_DIF_NOATIME)\n\t\tflags |= S_NOATIME;\n\tif (ip->i_diskflags & GFS2_DIF_SYNC)\n\t\tflags |= S_SYNC;\n\tinode->i_flags = flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "str->di_eattr"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "str->di_flags"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "str->di_generation"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "str->di_goal_meta"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "str->di_ctime_nsec"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "str->di_ctime"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "str->di_mtime_nsec"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "str->di_mtime"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec_compare",
          "args": [
            "&ip->i_inode.i_atime",
            "&atime"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "str->di_atime_nsec"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "str->di_atime"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_set_inode_blocks",
          "args": [
            "&ip->i_inode",
            "be64_to_cpu(str->di_blocks)"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_set_inode_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/inode.h",
          "lines": "50-54",
          "snippet": "static inline void gfs2_set_inode_blocks(struct inode *inode, u64 blocks)\n{\n\tinode->i_blocks = blocks <<\n\t\t(GFS2_SB(inode)->sd_sb.sb_bsize_shift - GFS2_BASIC_BLOCK_SHIFT);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <linux/mm.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <linux/mm.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline void gfs2_set_inode_blocks(struct inode *inode, u64 blocks)\n{\n\tinode->i_blocks = blocks <<\n\t\t(GFS2_SB(inode)->sd_sb.sb_bsize_shift - GFS2_BASIC_BLOCK_SHIFT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "str->di_blocks"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "&ip->i_inode",
            "be64_to_cpu(str->di_size)"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "str->di_size"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_set_nlink",
          "args": [
            "&ip->i_inode",
            "be32_to_cpu(str->di_nlink)"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glops.c",
          "lines": "302-315",
          "snippet": "static void gfs2_set_nlink(struct inode *inode, u32 nlink)\n{\n\t/*\n\t * We will need to review setting the nlink count here in the\n\t * light of the forthcoming ro bind mount work. This is a reminder\n\t * to do that.\n\t */\n\tif ((inode->i_nlink != nlink) && (inode->i_nlink != 0)) {\n\t\tif (nlink == 0)\n\t\t\tclear_nlink(inode);\n\t\telse\n\t\t\tset_nlink(inode, nlink);\n\t}\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"util.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/posix_acl.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"trans.h\"\n#include \"util.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/posix_acl.h>\n#include <linux/bio.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic void gfs2_set_nlink(struct inode *inode, u32 nlink)\n{\n\t/*\n\t * We will need to review setting the nlink count here in the\n\t * light of the forthcoming ro bind mount work. This is a reminder\n\t * to do that.\n\t */\n\tif ((inode->i_nlink != nlink) && (inode->i_nlink != 0)) {\n\t\tif (nlink == 0)\n\t\t\tclear_nlink(inode);\n\t\telse\n\t\t\tset_nlink(inode, nlink);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "str->di_nlink"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_gid_write",
          "args": [
            "&ip->i_inode",
            "be32_to_cpu(str->di_gid)"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "str->di_gid"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_write",
          "args": [
            "&ip->i_inode",
            "be32_to_cpu(str->di_uid)"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "str->di_uid"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MKDEV",
          "args": [
            "be32_to_cpu(str->di_major)",
            "be32_to_cpu(str->di_minor)"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "str->di_minor"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "str->di_major"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "str->di_mode"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "str->di_num.no_formal_ino"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ip->i_no_addr != be64_to_cpu(str->di_num.no_addr)"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "str->di_num.no_addr"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dir.h\"\n#include \"trans.h\"\n#include \"util.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/posix_acl.h>\n#include <linux/bio.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic int gfs2_dinode_in(struct gfs2_inode *ip, const void *buf)\n{\n\tconst struct gfs2_dinode *str = buf;\n\tstruct timespec atime;\n\tu16 height, depth;\n\n\tif (unlikely(ip->i_no_addr != be64_to_cpu(str->di_num.no_addr)))\n\t\tgoto corrupt;\n\tip->i_no_formal_ino = be64_to_cpu(str->di_num.no_formal_ino);\n\tip->i_inode.i_mode = be32_to_cpu(str->di_mode);\n\tip->i_inode.i_rdev = 0;\n\tswitch (ip->i_inode.i_mode & S_IFMT) {\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\t\tip->i_inode.i_rdev = MKDEV(be32_to_cpu(str->di_major),\n\t\t\t\t\t   be32_to_cpu(str->di_minor));\n\t\tbreak;\n\t};\n\n\ti_uid_write(&ip->i_inode, be32_to_cpu(str->di_uid));\n\ti_gid_write(&ip->i_inode, be32_to_cpu(str->di_gid));\n\tgfs2_set_nlink(&ip->i_inode, be32_to_cpu(str->di_nlink));\n\ti_size_write(&ip->i_inode, be64_to_cpu(str->di_size));\n\tgfs2_set_inode_blocks(&ip->i_inode, be64_to_cpu(str->di_blocks));\n\tatime.tv_sec = be64_to_cpu(str->di_atime);\n\tatime.tv_nsec = be32_to_cpu(str->di_atime_nsec);\n\tif (timespec_compare(&ip->i_inode.i_atime, &atime) < 0)\n\t\tip->i_inode.i_atime = atime;\n\tip->i_inode.i_mtime.tv_sec = be64_to_cpu(str->di_mtime);\n\tip->i_inode.i_mtime.tv_nsec = be32_to_cpu(str->di_mtime_nsec);\n\tip->i_inode.i_ctime.tv_sec = be64_to_cpu(str->di_ctime);\n\tip->i_inode.i_ctime.tv_nsec = be32_to_cpu(str->di_ctime_nsec);\n\n\tip->i_goal = be64_to_cpu(str->di_goal_meta);\n\tip->i_generation = be64_to_cpu(str->di_generation);\n\n\tip->i_diskflags = be32_to_cpu(str->di_flags);\n\tip->i_eattr = be64_to_cpu(str->di_eattr);\n\t/* i_diskflags and i_eattr must be set before gfs2_set_inode_flags() */\n\tgfs2_set_inode_flags(&ip->i_inode);\n\theight = be16_to_cpu(str->di_height);\n\tif (unlikely(height > GFS2_MAX_META_HEIGHT))\n\t\tgoto corrupt;\n\tip->i_height = (u8)height;\n\n\tdepth = be16_to_cpu(str->di_depth);\n\tif (unlikely(depth > GFS2_DIR_MAX_DEPTH))\n\t\tgoto corrupt;\n\tip->i_depth = (u8)depth;\n\tip->i_entries = be32_to_cpu(str->di_entries);\n\n\tif (S_ISREG(ip->i_inode.i_mode))\n\t\tgfs2_set_aops(&ip->i_inode);\n\n\treturn 0;\ncorrupt:\n\tgfs2_consist_inode(ip);\n\treturn -EIO;\n}"
  },
  {
    "function_name": "gfs2_set_nlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glops.c",
    "lines": "302-315",
    "snippet": "static void gfs2_set_nlink(struct inode *inode, u32 nlink)\n{\n\t/*\n\t * We will need to review setting the nlink count here in the\n\t * light of the forthcoming ro bind mount work. This is a reminder\n\t * to do that.\n\t */\n\tif ((inode->i_nlink != nlink) && (inode->i_nlink != 0)) {\n\t\tif (nlink == 0)\n\t\t\tclear_nlink(inode);\n\t\telse\n\t\t\tset_nlink(inode, nlink);\n\t}\n}",
    "includes": [
      "#include \"dir.h\"",
      "#include \"trans.h\"",
      "#include \"util.h\"",
      "#include \"rgrp.h\"",
      "#include \"recovery.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/posix_acl.h>",
      "#include <linux/bio.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "nlink"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glops.c",
          "lines": "302-315",
          "snippet": "static void gfs2_set_nlink(struct inode *inode, u32 nlink)\n{\n\t/*\n\t * We will need to review setting the nlink count here in the\n\t * light of the forthcoming ro bind mount work. This is a reminder\n\t * to do that.\n\t */\n\tif ((inode->i_nlink != nlink) && (inode->i_nlink != 0)) {\n\t\tif (nlink == 0)\n\t\t\tclear_nlink(inode);\n\t\telse\n\t\t\tset_nlink(inode, nlink);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "inode"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dir.h\"\n#include \"trans.h\"\n#include \"util.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/posix_acl.h>\n#include <linux/bio.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic void gfs2_set_nlink(struct inode *inode, u32 nlink)\n{\n\t/*\n\t * We will need to review setting the nlink count here in the\n\t * light of the forthcoming ro bind mount work. This is a reminder\n\t * to do that.\n\t */\n\tif ((inode->i_nlink != nlink) && (inode->i_nlink != 0)) {\n\t\tif (nlink == 0)\n\t\t\tclear_nlink(inode);\n\t\telse\n\t\t\tset_nlink(inode, nlink);\n\t}\n}"
  },
  {
    "function_name": "inode_go_demote_ok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glops.c",
    "lines": "274-289",
    "snippet": "static int inode_go_demote_ok(const struct gfs2_glock *gl)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_holder *gh;\n\n\tif (sdp->sd_jindex == gl->gl_object || sdp->sd_rindex == gl->gl_object)\n\t\treturn 0;\n\n\tif (!list_empty(&gl->gl_holders)) {\n\t\tgh = list_entry(gl->gl_holders.next, struct gfs2_holder, gh_list);\n\t\tif (gh->gh_list.next != &gl->gl_holders)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"dir.h\"",
      "#include \"trans.h\"",
      "#include \"util.h\"",
      "#include \"rgrp.h\"",
      "#include \"recovery.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/posix_acl.h>",
      "#include <linux/bio.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "gl->gl_holders.next",
            "structgfs2_holder",
            "gh_list"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&gl->gl_holders"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dir.h\"\n#include \"trans.h\"\n#include \"util.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/posix_acl.h>\n#include <linux/bio.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic int inode_go_demote_ok(const struct gfs2_glock *gl)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_holder *gh;\n\n\tif (sdp->sd_jindex == gl->gl_object || sdp->sd_rindex == gl->gl_object)\n\t\treturn 0;\n\n\tif (!list_empty(&gl->gl_holders)) {\n\t\tgh = list_entry(gl->gl_holders.next, struct gfs2_holder, gh_list);\n\t\tif (gh->gh_list.next != &gl->gl_holders)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "inode_go_inval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glops.c",
    "lines": "243-265",
    "snippet": "static void inode_go_inval(struct gfs2_glock *gl, int flags)\n{\n\tstruct gfs2_inode *ip = gl->gl_object;\n\n\tgfs2_assert_withdraw(gl->gl_sbd, !atomic_read(&gl->gl_ail_count));\n\n\tif (flags & DIO_METADATA) {\n\t\tstruct address_space *mapping = gfs2_glock2aspace(gl);\n\t\ttruncate_inode_pages(mapping, 0);\n\t\tif (ip) {\n\t\t\tset_bit(GIF_INVALID, &ip->i_flags);\n\t\t\tforget_all_cached_acls(&ip->i_inode);\n\t\t\tgfs2_dir_hash_inval(ip);\n\t\t}\n\t}\n\n\tif (ip == GFS2_I(gl->gl_sbd->sd_rindex)) {\n\t\tgfs2_log_flush(gl->gl_sbd, NULL, NORMAL_FLUSH);\n\t\tgl->gl_sbd->sd_rindex_uptodate = 0;\n\t}\n\tif (ip && S_ISREG(ip->i_inode.i_mode))\n\t\ttruncate_inode_pages(ip->i_inode.i_mapping, 0);\n}",
    "includes": [
      "#include \"dir.h\"",
      "#include \"trans.h\"",
      "#include \"util.h\"",
      "#include \"rgrp.h\"",
      "#include \"recovery.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/posix_acl.h>",
      "#include <linux/bio.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "truncate_inode_pages",
          "args": [
            "ip->i_inode.i_mapping",
            "0"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "ip->i_inode.i_mode"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_log_flush",
          "args": [
            "gl->gl_sbd",
            "NULL",
            "NORMAL_FLUSH"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_log_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/log.c",
          "lines": "704-787",
          "snippet": "void gfs2_log_flush(struct gfs2_sbd *sdp, struct gfs2_glock *gl,\n\t\t    enum gfs2_flush_type type)\n{\n\tstruct gfs2_trans *tr;\n\tenum gfs2_freeze_state state = atomic_read(&sdp->sd_freeze_state);\n\n\tdown_write(&sdp->sd_log_flush_lock);\n\n\t/* Log might have been flushed while we waited for the flush lock */\n\tif (gl && !test_bit(GLF_LFLUSH, &gl->gl_flags)) {\n\t\tup_write(&sdp->sd_log_flush_lock);\n\t\treturn;\n\t}\n\ttrace_gfs2_log_flush(sdp, 1);\n\n\tsdp->sd_log_flush_head = sdp->sd_log_head;\n\tsdp->sd_log_flush_wrapped = 0;\n\ttr = sdp->sd_log_tr;\n\tif (tr) {\n\t\tsdp->sd_log_tr = NULL;\n\t\tINIT_LIST_HEAD(&tr->tr_ail1_list);\n\t\tINIT_LIST_HEAD(&tr->tr_ail2_list);\n\t\ttr->tr_first = sdp->sd_log_flush_head;\n\t\tif (unlikely (state == SFS_FROZEN))\n\t\t\tgfs2_assert_withdraw(sdp, !tr->tr_num_buf_new && !tr->tr_num_databuf_new);\n\t}\n\n\tif (unlikely(state == SFS_FROZEN))\n\t\tgfs2_assert_withdraw(sdp, !sdp->sd_log_num_revoke);\n\tgfs2_assert_withdraw(sdp,\n\t\t\tsdp->sd_log_num_revoke == sdp->sd_log_commited_revoke);\n\n\tgfs2_ordered_write(sdp);\n\tlops_before_commit(sdp, tr);\n\tgfs2_log_flush_bio(sdp, WRITE);\n\n\tif (sdp->sd_log_head != sdp->sd_log_flush_head) {\n\t\tlog_flush_wait(sdp);\n\t\tlog_write_header(sdp, 0);\n\t} else if (sdp->sd_log_tail != current_tail(sdp) && !sdp->sd_log_idle){\n\t\tatomic_dec(&sdp->sd_log_blks_free); /* Adjust for unreserved buffer */\n\t\ttrace_gfs2_log_blocks(sdp, -1);\n\t\tlog_write_header(sdp, 0);\n\t}\n\tlops_after_commit(sdp, tr);\n\n\tgfs2_log_lock(sdp);\n\tsdp->sd_log_head = sdp->sd_log_flush_head;\n\tsdp->sd_log_blks_reserved = 0;\n\tsdp->sd_log_commited_revoke = 0;\n\n\tspin_lock(&sdp->sd_ail_lock);\n\tif (tr && !list_empty(&tr->tr_ail1_list)) {\n\t\tlist_add(&tr->tr_list, &sdp->sd_ail1_list);\n\t\ttr = NULL;\n\t}\n\tspin_unlock(&sdp->sd_ail_lock);\n\tgfs2_log_unlock(sdp);\n\n\tif (type != NORMAL_FLUSH) {\n\t\tif (!sdp->sd_log_idle) {\n\t\t\tfor (;;) {\n\t\t\t\tgfs2_ail1_start(sdp);\n\t\t\t\tgfs2_ail1_wait(sdp);\n\t\t\t\tif (gfs2_ail1_empty(sdp))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tatomic_dec(&sdp->sd_log_blks_free); /* Adjust for unreserved buffer */\n\t\t\ttrace_gfs2_log_blocks(sdp, -1);\n\t\t\tsdp->sd_log_flush_wrapped = 0;\n\t\t\tlog_write_header(sdp, 0);\n\t\t\tsdp->sd_log_head = sdp->sd_log_flush_head;\n\t\t}\n\t\tif (type == SHUTDOWN_FLUSH || type == FREEZE_FLUSH)\n\t\t\tgfs2_log_shutdown(sdp);\n\t\tif (type == FREEZE_FLUSH)\n\t\t\tatomic_set(&sdp->sd_freeze_state, SFS_FROZEN);\n\t}\n\n\ttrace_gfs2_log_flush(sdp, 0);\n\tup_write(&sdp->sd_log_flush_lock);\n\n\tkfree(tr);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/list_sort.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_log_flush(struct gfs2_sbd *sdp, struct gfs2_glock *gl,\n\t\t    enum gfs2_flush_type type)\n{\n\tstruct gfs2_trans *tr;\n\tenum gfs2_freeze_state state = atomic_read(&sdp->sd_freeze_state);\n\n\tdown_write(&sdp->sd_log_flush_lock);\n\n\t/* Log might have been flushed while we waited for the flush lock */\n\tif (gl && !test_bit(GLF_LFLUSH, &gl->gl_flags)) {\n\t\tup_write(&sdp->sd_log_flush_lock);\n\t\treturn;\n\t}\n\ttrace_gfs2_log_flush(sdp, 1);\n\n\tsdp->sd_log_flush_head = sdp->sd_log_head;\n\tsdp->sd_log_flush_wrapped = 0;\n\ttr = sdp->sd_log_tr;\n\tif (tr) {\n\t\tsdp->sd_log_tr = NULL;\n\t\tINIT_LIST_HEAD(&tr->tr_ail1_list);\n\t\tINIT_LIST_HEAD(&tr->tr_ail2_list);\n\t\ttr->tr_first = sdp->sd_log_flush_head;\n\t\tif (unlikely (state == SFS_FROZEN))\n\t\t\tgfs2_assert_withdraw(sdp, !tr->tr_num_buf_new && !tr->tr_num_databuf_new);\n\t}\n\n\tif (unlikely(state == SFS_FROZEN))\n\t\tgfs2_assert_withdraw(sdp, !sdp->sd_log_num_revoke);\n\tgfs2_assert_withdraw(sdp,\n\t\t\tsdp->sd_log_num_revoke == sdp->sd_log_commited_revoke);\n\n\tgfs2_ordered_write(sdp);\n\tlops_before_commit(sdp, tr);\n\tgfs2_log_flush_bio(sdp, WRITE);\n\n\tif (sdp->sd_log_head != sdp->sd_log_flush_head) {\n\t\tlog_flush_wait(sdp);\n\t\tlog_write_header(sdp, 0);\n\t} else if (sdp->sd_log_tail != current_tail(sdp) && !sdp->sd_log_idle){\n\t\tatomic_dec(&sdp->sd_log_blks_free); /* Adjust for unreserved buffer */\n\t\ttrace_gfs2_log_blocks(sdp, -1);\n\t\tlog_write_header(sdp, 0);\n\t}\n\tlops_after_commit(sdp, tr);\n\n\tgfs2_log_lock(sdp);\n\tsdp->sd_log_head = sdp->sd_log_flush_head;\n\tsdp->sd_log_blks_reserved = 0;\n\tsdp->sd_log_commited_revoke = 0;\n\n\tspin_lock(&sdp->sd_ail_lock);\n\tif (tr && !list_empty(&tr->tr_ail1_list)) {\n\t\tlist_add(&tr->tr_list, &sdp->sd_ail1_list);\n\t\ttr = NULL;\n\t}\n\tspin_unlock(&sdp->sd_ail_lock);\n\tgfs2_log_unlock(sdp);\n\n\tif (type != NORMAL_FLUSH) {\n\t\tif (!sdp->sd_log_idle) {\n\t\t\tfor (;;) {\n\t\t\t\tgfs2_ail1_start(sdp);\n\t\t\t\tgfs2_ail1_wait(sdp);\n\t\t\t\tif (gfs2_ail1_empty(sdp))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tatomic_dec(&sdp->sd_log_blks_free); /* Adjust for unreserved buffer */\n\t\t\ttrace_gfs2_log_blocks(sdp, -1);\n\t\t\tsdp->sd_log_flush_wrapped = 0;\n\t\t\tlog_write_header(sdp, 0);\n\t\t\tsdp->sd_log_head = sdp->sd_log_flush_head;\n\t\t}\n\t\tif (type == SHUTDOWN_FLUSH || type == FREEZE_FLUSH)\n\t\t\tgfs2_log_shutdown(sdp);\n\t\tif (type == FREEZE_FLUSH)\n\t\t\tatomic_set(&sdp->sd_freeze_state, SFS_FROZEN);\n\t}\n\n\ttrace_gfs2_log_flush(sdp, 0);\n\tup_write(&sdp->sd_log_flush_lock);\n\n\tkfree(tr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_I",
          "args": [
            "gl->gl_sbd->sd_rindex"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "408-411",
          "snippet": "static inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_inode *GFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct gfs2_inode, i_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_dir_hash_inval",
          "args": [
            "ip"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_dir_hash_inval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/dir.c",
          "lines": "389-394",
          "snippet": "void gfs2_dir_hash_inval(struct gfs2_inode *ip)\n{\n\t__be64 *hc = ip->i_hash_cache;\n\tip->i_hash_cache = NULL;\n\tkvfree(hc);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"bmap.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"dir.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"bmap.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"dir.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_dir_hash_inval(struct gfs2_inode *ip)\n{\n\t__be64 *hc = ip->i_hash_cache;\n\tip->i_hash_cache = NULL;\n\tkvfree(hc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "forget_all_cached_acls",
          "args": [
            "&ip->i_inode"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "forget_all_cached_acls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "84-96",
          "snippet": "void forget_all_cached_acls(struct inode *inode)\n{\n\tstruct posix_acl *old_access, *old_default;\n\tspin_lock(&inode->i_lock);\n\told_access = inode->i_acl;\n\told_default = inode->i_default_acl;\n\tinode->i_acl = inode->i_default_acl = ACL_NOT_CACHED;\n\tspin_unlock(&inode->i_lock);\n\tif (old_access != ACL_NOT_CACHED)\n\t\tposix_acl_release(old_access);\n\tif (old_default != ACL_NOT_CACHED)\n\t\tposix_acl_release(old_default);\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid forget_all_cached_acls(struct inode *inode)\n{\n\tstruct posix_acl *old_access, *old_default;\n\tspin_lock(&inode->i_lock);\n\told_access = inode->i_acl;\n\told_default = inode->i_default_acl;\n\tinode->i_acl = inode->i_default_acl = ACL_NOT_CACHED;\n\tspin_unlock(&inode->i_lock);\n\tif (old_access != ACL_NOT_CACHED)\n\t\tposix_acl_release(old_access);\n\tif (old_default != ACL_NOT_CACHED)\n\t\tposix_acl_release(old_default);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "GIF_INVALID",
            "&ip->i_flags"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages",
          "args": [
            "mapping",
            "0"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_glock2aspace",
          "args": [
            "gl"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock2aspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.h",
          "lines": "174-179",
          "snippet": "static inline struct address_space *gfs2_glock2aspace(struct gfs2_glock *gl)\n{\n\tif (gl->gl_ops->go_flags & GLOF_ASPACE)\n\t\treturn (struct address_space *)(gl + 1);\n\treturn NULL;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/parser.h>\n#include <linux/sched.h>\n\nstatic inline struct address_space *gfs2_glock2aspace(struct gfs2_glock *gl)\n{\n\tif (gl->gl_ops->go_flags & GLOF_ASPACE)\n\t\treturn (struct address_space *)(gl + 1);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_assert_withdraw",
          "args": [
            "gl->gl_sbd",
            "!atomic_read(&gl->gl_ail_count)"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&gl->gl_ail_count"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dir.h\"\n#include \"trans.h\"\n#include \"util.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/posix_acl.h>\n#include <linux/bio.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic void inode_go_inval(struct gfs2_glock *gl, int flags)\n{\n\tstruct gfs2_inode *ip = gl->gl_object;\n\n\tgfs2_assert_withdraw(gl->gl_sbd, !atomic_read(&gl->gl_ail_count));\n\n\tif (flags & DIO_METADATA) {\n\t\tstruct address_space *mapping = gfs2_glock2aspace(gl);\n\t\ttruncate_inode_pages(mapping, 0);\n\t\tif (ip) {\n\t\t\tset_bit(GIF_INVALID, &ip->i_flags);\n\t\t\tforget_all_cached_acls(&ip->i_inode);\n\t\t\tgfs2_dir_hash_inval(ip);\n\t\t}\n\t}\n\n\tif (ip == GFS2_I(gl->gl_sbd->sd_rindex)) {\n\t\tgfs2_log_flush(gl->gl_sbd, NULL, NORMAL_FLUSH);\n\t\tgl->gl_sbd->sd_rindex_uptodate = 0;\n\t}\n\tif (ip && S_ISREG(ip->i_inode.i_mode))\n\t\ttruncate_inode_pages(ip->i_inode.i_mapping, 0);\n}"
  },
  {
    "function_name": "inode_go_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glops.c",
    "lines": "195-230",
    "snippet": "static void inode_go_sync(struct gfs2_glock *gl)\n{\n\tstruct gfs2_inode *ip = gl->gl_object;\n\tstruct address_space *metamapping = gfs2_glock2aspace(gl);\n\tint error;\n\n\tif (ip && !S_ISREG(ip->i_inode.i_mode))\n\t\tip = NULL;\n\tif (ip) {\n\t\tif (test_and_clear_bit(GIF_SW_PAGED, &ip->i_flags))\n\t\t\tunmap_shared_mapping_range(ip->i_inode.i_mapping, 0, 0);\n\t\tinode_dio_wait(&ip->i_inode);\n\t}\n\tif (!test_and_clear_bit(GLF_DIRTY, &gl->gl_flags))\n\t\treturn;\n\n\tGLOCK_BUG_ON(gl, gl->gl_state != LM_ST_EXCLUSIVE);\n\n\tgfs2_log_flush(gl->gl_sbd, gl, NORMAL_FLUSH);\n\tfilemap_fdatawrite(metamapping);\n\tif (ip) {\n\t\tstruct address_space *mapping = ip->i_inode.i_mapping;\n\t\tfilemap_fdatawrite(mapping);\n\t\terror = filemap_fdatawait(mapping);\n\t\tmapping_set_error(mapping, error);\n\t}\n\terror = filemap_fdatawait(metamapping);\n\tmapping_set_error(metamapping, error);\n\tgfs2_ail_empty_gl(gl);\n\t/*\n\t * Writeback of the data mapping may cause the dirty flag to be set\n\t * so we have to clear it again here.\n\t */\n\tsmp_mb__before_atomic();\n\tclear_bit(GLF_DIRTY, &gl->gl_flags);\n}",
    "includes": [
      "#include \"dir.h\"",
      "#include \"trans.h\"",
      "#include \"util.h\"",
      "#include \"rgrp.h\"",
      "#include \"recovery.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/posix_acl.h>",
      "#include <linux/bio.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "GLF_DIRTY",
            "&gl->gl_flags"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb__before_atomic",
          "args": [],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_ail_empty_gl",
          "args": [
            "gl"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ail_empty_gl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glops.c",
          "lines": "81-108",
          "snippet": "static void gfs2_ail_empty_gl(struct gfs2_glock *gl)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_trans tr;\n\n\tmemset(&tr, 0, sizeof(tr));\n\tINIT_LIST_HEAD(&tr.tr_buf);\n\tINIT_LIST_HEAD(&tr.tr_databuf);\n\ttr.tr_revokes = atomic_read(&gl->gl_ail_count);\n\n\tif (!tr.tr_revokes)\n\t\treturn;\n\n\t/* A shortened, inline version of gfs2_trans_begin()\n         * tr->alloced is not set since the transaction structure is\n         * on the stack */\n\ttr.tr_reserved = 1 + gfs2_struct2blk(sdp, tr.tr_revokes, sizeof(u64));\n\ttr.tr_ip = _RET_IP_;\n\tif (gfs2_log_reserve(sdp, tr.tr_reserved) < 0)\n\t\treturn;\n\tWARN_ON_ONCE(current->journal_info);\n\tcurrent->journal_info = &tr;\n\n\t__gfs2_ail_flush(gl, 0, tr.tr_revokes);\n\n\tgfs2_trans_end(sdp);\n\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"util.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/posix_acl.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"trans.h\"\n#include \"util.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/posix_acl.h>\n#include <linux/bio.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic void gfs2_ail_empty_gl(struct gfs2_glock *gl)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_trans tr;\n\n\tmemset(&tr, 0, sizeof(tr));\n\tINIT_LIST_HEAD(&tr.tr_buf);\n\tINIT_LIST_HEAD(&tr.tr_databuf);\n\ttr.tr_revokes = atomic_read(&gl->gl_ail_count);\n\n\tif (!tr.tr_revokes)\n\t\treturn;\n\n\t/* A shortened, inline version of gfs2_trans_begin()\n         * tr->alloced is not set since the transaction structure is\n         * on the stack */\n\ttr.tr_reserved = 1 + gfs2_struct2blk(sdp, tr.tr_revokes, sizeof(u64));\n\ttr.tr_ip = _RET_IP_;\n\tif (gfs2_log_reserve(sdp, tr.tr_reserved) < 0)\n\t\treturn;\n\tWARN_ON_ONCE(current->journal_info);\n\tcurrent->journal_info = &tr;\n\n\t__gfs2_ail_flush(gl, 0, tr.tr_revokes);\n\n\tgfs2_trans_end(sdp);\n\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_set_error",
          "args": [
            "metamapping",
            "error"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_fdatawait",
          "args": [
            "metamapping"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_set_error",
          "args": [
            "mapping",
            "error"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_fdatawait",
          "args": [
            "mapping"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_fdatawrite",
          "args": [
            "mapping"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_fdatawrite",
          "args": [
            "metamapping"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_log_flush",
          "args": [
            "gl->gl_sbd",
            "gl",
            "NORMAL_FLUSH"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_log_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/log.c",
          "lines": "704-787",
          "snippet": "void gfs2_log_flush(struct gfs2_sbd *sdp, struct gfs2_glock *gl,\n\t\t    enum gfs2_flush_type type)\n{\n\tstruct gfs2_trans *tr;\n\tenum gfs2_freeze_state state = atomic_read(&sdp->sd_freeze_state);\n\n\tdown_write(&sdp->sd_log_flush_lock);\n\n\t/* Log might have been flushed while we waited for the flush lock */\n\tif (gl && !test_bit(GLF_LFLUSH, &gl->gl_flags)) {\n\t\tup_write(&sdp->sd_log_flush_lock);\n\t\treturn;\n\t}\n\ttrace_gfs2_log_flush(sdp, 1);\n\n\tsdp->sd_log_flush_head = sdp->sd_log_head;\n\tsdp->sd_log_flush_wrapped = 0;\n\ttr = sdp->sd_log_tr;\n\tif (tr) {\n\t\tsdp->sd_log_tr = NULL;\n\t\tINIT_LIST_HEAD(&tr->tr_ail1_list);\n\t\tINIT_LIST_HEAD(&tr->tr_ail2_list);\n\t\ttr->tr_first = sdp->sd_log_flush_head;\n\t\tif (unlikely (state == SFS_FROZEN))\n\t\t\tgfs2_assert_withdraw(sdp, !tr->tr_num_buf_new && !tr->tr_num_databuf_new);\n\t}\n\n\tif (unlikely(state == SFS_FROZEN))\n\t\tgfs2_assert_withdraw(sdp, !sdp->sd_log_num_revoke);\n\tgfs2_assert_withdraw(sdp,\n\t\t\tsdp->sd_log_num_revoke == sdp->sd_log_commited_revoke);\n\n\tgfs2_ordered_write(sdp);\n\tlops_before_commit(sdp, tr);\n\tgfs2_log_flush_bio(sdp, WRITE);\n\n\tif (sdp->sd_log_head != sdp->sd_log_flush_head) {\n\t\tlog_flush_wait(sdp);\n\t\tlog_write_header(sdp, 0);\n\t} else if (sdp->sd_log_tail != current_tail(sdp) && !sdp->sd_log_idle){\n\t\tatomic_dec(&sdp->sd_log_blks_free); /* Adjust for unreserved buffer */\n\t\ttrace_gfs2_log_blocks(sdp, -1);\n\t\tlog_write_header(sdp, 0);\n\t}\n\tlops_after_commit(sdp, tr);\n\n\tgfs2_log_lock(sdp);\n\tsdp->sd_log_head = sdp->sd_log_flush_head;\n\tsdp->sd_log_blks_reserved = 0;\n\tsdp->sd_log_commited_revoke = 0;\n\n\tspin_lock(&sdp->sd_ail_lock);\n\tif (tr && !list_empty(&tr->tr_ail1_list)) {\n\t\tlist_add(&tr->tr_list, &sdp->sd_ail1_list);\n\t\ttr = NULL;\n\t}\n\tspin_unlock(&sdp->sd_ail_lock);\n\tgfs2_log_unlock(sdp);\n\n\tif (type != NORMAL_FLUSH) {\n\t\tif (!sdp->sd_log_idle) {\n\t\t\tfor (;;) {\n\t\t\t\tgfs2_ail1_start(sdp);\n\t\t\t\tgfs2_ail1_wait(sdp);\n\t\t\t\tif (gfs2_ail1_empty(sdp))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tatomic_dec(&sdp->sd_log_blks_free); /* Adjust for unreserved buffer */\n\t\t\ttrace_gfs2_log_blocks(sdp, -1);\n\t\t\tsdp->sd_log_flush_wrapped = 0;\n\t\t\tlog_write_header(sdp, 0);\n\t\t\tsdp->sd_log_head = sdp->sd_log_flush_head;\n\t\t}\n\t\tif (type == SHUTDOWN_FLUSH || type == FREEZE_FLUSH)\n\t\t\tgfs2_log_shutdown(sdp);\n\t\tif (type == FREEZE_FLUSH)\n\t\t\tatomic_set(&sdp->sd_freeze_state, SFS_FROZEN);\n\t}\n\n\ttrace_gfs2_log_flush(sdp, 0);\n\tup_write(&sdp->sd_log_flush_lock);\n\n\tkfree(tr);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/list_sort.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_log_flush(struct gfs2_sbd *sdp, struct gfs2_glock *gl,\n\t\t    enum gfs2_flush_type type)\n{\n\tstruct gfs2_trans *tr;\n\tenum gfs2_freeze_state state = atomic_read(&sdp->sd_freeze_state);\n\n\tdown_write(&sdp->sd_log_flush_lock);\n\n\t/* Log might have been flushed while we waited for the flush lock */\n\tif (gl && !test_bit(GLF_LFLUSH, &gl->gl_flags)) {\n\t\tup_write(&sdp->sd_log_flush_lock);\n\t\treturn;\n\t}\n\ttrace_gfs2_log_flush(sdp, 1);\n\n\tsdp->sd_log_flush_head = sdp->sd_log_head;\n\tsdp->sd_log_flush_wrapped = 0;\n\ttr = sdp->sd_log_tr;\n\tif (tr) {\n\t\tsdp->sd_log_tr = NULL;\n\t\tINIT_LIST_HEAD(&tr->tr_ail1_list);\n\t\tINIT_LIST_HEAD(&tr->tr_ail2_list);\n\t\ttr->tr_first = sdp->sd_log_flush_head;\n\t\tif (unlikely (state == SFS_FROZEN))\n\t\t\tgfs2_assert_withdraw(sdp, !tr->tr_num_buf_new && !tr->tr_num_databuf_new);\n\t}\n\n\tif (unlikely(state == SFS_FROZEN))\n\t\tgfs2_assert_withdraw(sdp, !sdp->sd_log_num_revoke);\n\tgfs2_assert_withdraw(sdp,\n\t\t\tsdp->sd_log_num_revoke == sdp->sd_log_commited_revoke);\n\n\tgfs2_ordered_write(sdp);\n\tlops_before_commit(sdp, tr);\n\tgfs2_log_flush_bio(sdp, WRITE);\n\n\tif (sdp->sd_log_head != sdp->sd_log_flush_head) {\n\t\tlog_flush_wait(sdp);\n\t\tlog_write_header(sdp, 0);\n\t} else if (sdp->sd_log_tail != current_tail(sdp) && !sdp->sd_log_idle){\n\t\tatomic_dec(&sdp->sd_log_blks_free); /* Adjust for unreserved buffer */\n\t\ttrace_gfs2_log_blocks(sdp, -1);\n\t\tlog_write_header(sdp, 0);\n\t}\n\tlops_after_commit(sdp, tr);\n\n\tgfs2_log_lock(sdp);\n\tsdp->sd_log_head = sdp->sd_log_flush_head;\n\tsdp->sd_log_blks_reserved = 0;\n\tsdp->sd_log_commited_revoke = 0;\n\n\tspin_lock(&sdp->sd_ail_lock);\n\tif (tr && !list_empty(&tr->tr_ail1_list)) {\n\t\tlist_add(&tr->tr_list, &sdp->sd_ail1_list);\n\t\ttr = NULL;\n\t}\n\tspin_unlock(&sdp->sd_ail_lock);\n\tgfs2_log_unlock(sdp);\n\n\tif (type != NORMAL_FLUSH) {\n\t\tif (!sdp->sd_log_idle) {\n\t\t\tfor (;;) {\n\t\t\t\tgfs2_ail1_start(sdp);\n\t\t\t\tgfs2_ail1_wait(sdp);\n\t\t\t\tif (gfs2_ail1_empty(sdp))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tatomic_dec(&sdp->sd_log_blks_free); /* Adjust for unreserved buffer */\n\t\t\ttrace_gfs2_log_blocks(sdp, -1);\n\t\t\tsdp->sd_log_flush_wrapped = 0;\n\t\t\tlog_write_header(sdp, 0);\n\t\t\tsdp->sd_log_head = sdp->sd_log_flush_head;\n\t\t}\n\t\tif (type == SHUTDOWN_FLUSH || type == FREEZE_FLUSH)\n\t\t\tgfs2_log_shutdown(sdp);\n\t\tif (type == FREEZE_FLUSH)\n\t\t\tatomic_set(&sdp->sd_freeze_state, SFS_FROZEN);\n\t}\n\n\ttrace_gfs2_log_flush(sdp, 0);\n\tup_write(&sdp->sd_log_flush_lock);\n\n\tkfree(tr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GLOCK_BUG_ON",
          "args": [
            "gl",
            "gl->gl_state != LM_ST_EXCLUSIVE"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "GLF_DIRTY",
            "&gl->gl_flags"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_dio_wait",
          "args": [
            "&ip->i_inode"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "inode_dio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1941-1945",
          "snippet": "void inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unmap_shared_mapping_range",
          "args": [
            "ip->i_inode.i_mapping",
            "0",
            "0"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "ip->i_inode.i_mode"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_glock2aspace",
          "args": [
            "gl"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock2aspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.h",
          "lines": "174-179",
          "snippet": "static inline struct address_space *gfs2_glock2aspace(struct gfs2_glock *gl)\n{\n\tif (gl->gl_ops->go_flags & GLOF_ASPACE)\n\t\treturn (struct address_space *)(gl + 1);\n\treturn NULL;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/parser.h>\n#include <linux/sched.h>\n\nstatic inline struct address_space *gfs2_glock2aspace(struct gfs2_glock *gl)\n{\n\tif (gl->gl_ops->go_flags & GLOF_ASPACE)\n\t\treturn (struct address_space *)(gl + 1);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dir.h\"\n#include \"trans.h\"\n#include \"util.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/posix_acl.h>\n#include <linux/bio.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic void inode_go_sync(struct gfs2_glock *gl)\n{\n\tstruct gfs2_inode *ip = gl->gl_object;\n\tstruct address_space *metamapping = gfs2_glock2aspace(gl);\n\tint error;\n\n\tif (ip && !S_ISREG(ip->i_inode.i_mode))\n\t\tip = NULL;\n\tif (ip) {\n\t\tif (test_and_clear_bit(GIF_SW_PAGED, &ip->i_flags))\n\t\t\tunmap_shared_mapping_range(ip->i_inode.i_mapping, 0, 0);\n\t\tinode_dio_wait(&ip->i_inode);\n\t}\n\tif (!test_and_clear_bit(GLF_DIRTY, &gl->gl_flags))\n\t\treturn;\n\n\tGLOCK_BUG_ON(gl, gl->gl_state != LM_ST_EXCLUSIVE);\n\n\tgfs2_log_flush(gl->gl_sbd, gl, NORMAL_FLUSH);\n\tfilemap_fdatawrite(metamapping);\n\tif (ip) {\n\t\tstruct address_space *mapping = ip->i_inode.i_mapping;\n\t\tfilemap_fdatawrite(mapping);\n\t\terror = filemap_fdatawait(mapping);\n\t\tmapping_set_error(mapping, error);\n\t}\n\terror = filemap_fdatawait(metamapping);\n\tmapping_set_error(metamapping, error);\n\tgfs2_ail_empty_gl(gl);\n\t/*\n\t * Writeback of the data mapping may cause the dirty flag to be set\n\t * so we have to clear it again here.\n\t */\n\tsmp_mb__before_atomic();\n\tclear_bit(GLF_DIRTY, &gl->gl_flags);\n}"
  },
  {
    "function_name": "rgrp_go_inval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glops.c",
    "lines": "174-187",
    "snippet": "static void rgrp_go_inval(struct gfs2_glock *gl, int flags)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct address_space *mapping = &sdp->sd_aspace;\n\n\tWARN_ON_ONCE(!(flags & DIO_METADATA));\n\tgfs2_assert_withdraw(sdp, !atomic_read(&gl->gl_ail_count));\n\ttruncate_inode_pages_range(mapping, gl->gl_vm.start, gl->gl_vm.end);\n\n\tif (gl->gl_object) {\n\t\tstruct gfs2_rgrpd *rgd = (struct gfs2_rgrpd *)gl->gl_object;\n\t\trgd->rd_flags &= ~GFS2_RDF_UPTODATE;\n\t}\n}",
    "includes": [
      "#include \"dir.h\"",
      "#include \"trans.h\"",
      "#include \"util.h\"",
      "#include \"rgrp.h\"",
      "#include \"recovery.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/posix_acl.h>",
      "#include <linux/bio.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "truncate_inode_pages_range",
          "args": [
            "mapping",
            "gl->gl_vm.start",
            "gl->gl_vm.end"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_assert_withdraw",
          "args": [
            "sdp",
            "!atomic_read(&gl->gl_ail_count)"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&gl->gl_ail_count"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(flags & DIO_METADATA)"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dir.h\"\n#include \"trans.h\"\n#include \"util.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/posix_acl.h>\n#include <linux/bio.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic void rgrp_go_inval(struct gfs2_glock *gl, int flags)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct address_space *mapping = &sdp->sd_aspace;\n\n\tWARN_ON_ONCE(!(flags & DIO_METADATA));\n\tgfs2_assert_withdraw(sdp, !atomic_read(&gl->gl_ail_count));\n\ttruncate_inode_pages_range(mapping, gl->gl_vm.start, gl->gl_vm.end);\n\n\tif (gl->gl_object) {\n\t\tstruct gfs2_rgrpd *rgd = (struct gfs2_rgrpd *)gl->gl_object;\n\t\trgd->rd_flags &= ~GFS2_RDF_UPTODATE;\n\t}\n}"
  },
  {
    "function_name": "rgrp_go_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glops.c",
    "lines": "140-162",
    "snippet": "static void rgrp_go_sync(struct gfs2_glock *gl)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct address_space *mapping = &sdp->sd_aspace;\n\tstruct gfs2_rgrpd *rgd;\n\tint error;\n\n\tif (!test_and_clear_bit(GLF_DIRTY, &gl->gl_flags))\n\t\treturn;\n\tGLOCK_BUG_ON(gl, gl->gl_state != LM_ST_EXCLUSIVE);\n\n\tgfs2_log_flush(sdp, gl, NORMAL_FLUSH);\n\tfilemap_fdatawrite_range(mapping, gl->gl_vm.start, gl->gl_vm.end);\n\terror = filemap_fdatawait_range(mapping, gl->gl_vm.start, gl->gl_vm.end);\n\tmapping_set_error(mapping, error);\n\tgfs2_ail_empty_gl(gl);\n\n\tspin_lock(&gl->gl_spin);\n\trgd = gl->gl_object;\n\tif (rgd)\n\t\tgfs2_free_clones(rgd);\n\tspin_unlock(&gl->gl_spin);\n}",
    "includes": [
      "#include \"dir.h\"",
      "#include \"trans.h\"",
      "#include \"util.h\"",
      "#include \"rgrp.h\"",
      "#include \"recovery.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/posix_acl.h>",
      "#include <linux/bio.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&gl->gl_spin"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_free_clones",
          "args": [
            "rgd"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_free_clones",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/rgrp.c",
          "lines": "587-596",
          "snippet": "void gfs2_free_clones(struct gfs2_rgrpd *rgd)\n{\n\tint x;\n\n\tfor (x = 0; x < rgd->rd_length; x++) {\n\t\tstruct gfs2_bitmap *bi = rgd->rd_bits + x;\n\t\tkfree(bi->bi_clone);\n\t\tbi->bi_clone = NULL;\n\t}\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"inode.h\"",
            "#include \"log.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/random.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"inode.h\"\n#include \"log.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/random.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/prefetch.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nvoid gfs2_free_clones(struct gfs2_rgrpd *rgd)\n{\n\tint x;\n\n\tfor (x = 0; x < rgd->rd_length; x++) {\n\t\tstruct gfs2_bitmap *bi = rgd->rd_bits + x;\n\t\tkfree(bi->bi_clone);\n\t\tbi->bi_clone = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&gl->gl_spin"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_ail_empty_gl",
          "args": [
            "gl"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ail_empty_gl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glops.c",
          "lines": "81-108",
          "snippet": "static void gfs2_ail_empty_gl(struct gfs2_glock *gl)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_trans tr;\n\n\tmemset(&tr, 0, sizeof(tr));\n\tINIT_LIST_HEAD(&tr.tr_buf);\n\tINIT_LIST_HEAD(&tr.tr_databuf);\n\ttr.tr_revokes = atomic_read(&gl->gl_ail_count);\n\n\tif (!tr.tr_revokes)\n\t\treturn;\n\n\t/* A shortened, inline version of gfs2_trans_begin()\n         * tr->alloced is not set since the transaction structure is\n         * on the stack */\n\ttr.tr_reserved = 1 + gfs2_struct2blk(sdp, tr.tr_revokes, sizeof(u64));\n\ttr.tr_ip = _RET_IP_;\n\tif (gfs2_log_reserve(sdp, tr.tr_reserved) < 0)\n\t\treturn;\n\tWARN_ON_ONCE(current->journal_info);\n\tcurrent->journal_info = &tr;\n\n\t__gfs2_ail_flush(gl, 0, tr.tr_revokes);\n\n\tgfs2_trans_end(sdp);\n\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"util.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/posix_acl.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"trans.h\"\n#include \"util.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/posix_acl.h>\n#include <linux/bio.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic void gfs2_ail_empty_gl(struct gfs2_glock *gl)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_trans tr;\n\n\tmemset(&tr, 0, sizeof(tr));\n\tINIT_LIST_HEAD(&tr.tr_buf);\n\tINIT_LIST_HEAD(&tr.tr_databuf);\n\ttr.tr_revokes = atomic_read(&gl->gl_ail_count);\n\n\tif (!tr.tr_revokes)\n\t\treturn;\n\n\t/* A shortened, inline version of gfs2_trans_begin()\n         * tr->alloced is not set since the transaction structure is\n         * on the stack */\n\ttr.tr_reserved = 1 + gfs2_struct2blk(sdp, tr.tr_revokes, sizeof(u64));\n\ttr.tr_ip = _RET_IP_;\n\tif (gfs2_log_reserve(sdp, tr.tr_reserved) < 0)\n\t\treturn;\n\tWARN_ON_ONCE(current->journal_info);\n\tcurrent->journal_info = &tr;\n\n\t__gfs2_ail_flush(gl, 0, tr.tr_revokes);\n\n\tgfs2_trans_end(sdp);\n\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_set_error",
          "args": [
            "mapping",
            "error"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_fdatawait_range",
          "args": [
            "mapping",
            "gl->gl_vm.start",
            "gl->gl_vm.end"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_fdatawrite_range",
          "args": [
            "mapping",
            "gl->gl_vm.start",
            "gl->gl_vm.end"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_log_flush",
          "args": [
            "sdp",
            "gl",
            "NORMAL_FLUSH"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_log_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/log.c",
          "lines": "704-787",
          "snippet": "void gfs2_log_flush(struct gfs2_sbd *sdp, struct gfs2_glock *gl,\n\t\t    enum gfs2_flush_type type)\n{\n\tstruct gfs2_trans *tr;\n\tenum gfs2_freeze_state state = atomic_read(&sdp->sd_freeze_state);\n\n\tdown_write(&sdp->sd_log_flush_lock);\n\n\t/* Log might have been flushed while we waited for the flush lock */\n\tif (gl && !test_bit(GLF_LFLUSH, &gl->gl_flags)) {\n\t\tup_write(&sdp->sd_log_flush_lock);\n\t\treturn;\n\t}\n\ttrace_gfs2_log_flush(sdp, 1);\n\n\tsdp->sd_log_flush_head = sdp->sd_log_head;\n\tsdp->sd_log_flush_wrapped = 0;\n\ttr = sdp->sd_log_tr;\n\tif (tr) {\n\t\tsdp->sd_log_tr = NULL;\n\t\tINIT_LIST_HEAD(&tr->tr_ail1_list);\n\t\tINIT_LIST_HEAD(&tr->tr_ail2_list);\n\t\ttr->tr_first = sdp->sd_log_flush_head;\n\t\tif (unlikely (state == SFS_FROZEN))\n\t\t\tgfs2_assert_withdraw(sdp, !tr->tr_num_buf_new && !tr->tr_num_databuf_new);\n\t}\n\n\tif (unlikely(state == SFS_FROZEN))\n\t\tgfs2_assert_withdraw(sdp, !sdp->sd_log_num_revoke);\n\tgfs2_assert_withdraw(sdp,\n\t\t\tsdp->sd_log_num_revoke == sdp->sd_log_commited_revoke);\n\n\tgfs2_ordered_write(sdp);\n\tlops_before_commit(sdp, tr);\n\tgfs2_log_flush_bio(sdp, WRITE);\n\n\tif (sdp->sd_log_head != sdp->sd_log_flush_head) {\n\t\tlog_flush_wait(sdp);\n\t\tlog_write_header(sdp, 0);\n\t} else if (sdp->sd_log_tail != current_tail(sdp) && !sdp->sd_log_idle){\n\t\tatomic_dec(&sdp->sd_log_blks_free); /* Adjust for unreserved buffer */\n\t\ttrace_gfs2_log_blocks(sdp, -1);\n\t\tlog_write_header(sdp, 0);\n\t}\n\tlops_after_commit(sdp, tr);\n\n\tgfs2_log_lock(sdp);\n\tsdp->sd_log_head = sdp->sd_log_flush_head;\n\tsdp->sd_log_blks_reserved = 0;\n\tsdp->sd_log_commited_revoke = 0;\n\n\tspin_lock(&sdp->sd_ail_lock);\n\tif (tr && !list_empty(&tr->tr_ail1_list)) {\n\t\tlist_add(&tr->tr_list, &sdp->sd_ail1_list);\n\t\ttr = NULL;\n\t}\n\tspin_unlock(&sdp->sd_ail_lock);\n\tgfs2_log_unlock(sdp);\n\n\tif (type != NORMAL_FLUSH) {\n\t\tif (!sdp->sd_log_idle) {\n\t\t\tfor (;;) {\n\t\t\t\tgfs2_ail1_start(sdp);\n\t\t\t\tgfs2_ail1_wait(sdp);\n\t\t\t\tif (gfs2_ail1_empty(sdp))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tatomic_dec(&sdp->sd_log_blks_free); /* Adjust for unreserved buffer */\n\t\t\ttrace_gfs2_log_blocks(sdp, -1);\n\t\t\tsdp->sd_log_flush_wrapped = 0;\n\t\t\tlog_write_header(sdp, 0);\n\t\t\tsdp->sd_log_head = sdp->sd_log_flush_head;\n\t\t}\n\t\tif (type == SHUTDOWN_FLUSH || type == FREEZE_FLUSH)\n\t\t\tgfs2_log_shutdown(sdp);\n\t\tif (type == FREEZE_FLUSH)\n\t\t\tatomic_set(&sdp->sd_freeze_state, SFS_FROZEN);\n\t}\n\n\ttrace_gfs2_log_flush(sdp, 0);\n\tup_write(&sdp->sd_log_flush_lock);\n\n\tkfree(tr);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/list_sort.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_log_flush(struct gfs2_sbd *sdp, struct gfs2_glock *gl,\n\t\t    enum gfs2_flush_type type)\n{\n\tstruct gfs2_trans *tr;\n\tenum gfs2_freeze_state state = atomic_read(&sdp->sd_freeze_state);\n\n\tdown_write(&sdp->sd_log_flush_lock);\n\n\t/* Log might have been flushed while we waited for the flush lock */\n\tif (gl && !test_bit(GLF_LFLUSH, &gl->gl_flags)) {\n\t\tup_write(&sdp->sd_log_flush_lock);\n\t\treturn;\n\t}\n\ttrace_gfs2_log_flush(sdp, 1);\n\n\tsdp->sd_log_flush_head = sdp->sd_log_head;\n\tsdp->sd_log_flush_wrapped = 0;\n\ttr = sdp->sd_log_tr;\n\tif (tr) {\n\t\tsdp->sd_log_tr = NULL;\n\t\tINIT_LIST_HEAD(&tr->tr_ail1_list);\n\t\tINIT_LIST_HEAD(&tr->tr_ail2_list);\n\t\ttr->tr_first = sdp->sd_log_flush_head;\n\t\tif (unlikely (state == SFS_FROZEN))\n\t\t\tgfs2_assert_withdraw(sdp, !tr->tr_num_buf_new && !tr->tr_num_databuf_new);\n\t}\n\n\tif (unlikely(state == SFS_FROZEN))\n\t\tgfs2_assert_withdraw(sdp, !sdp->sd_log_num_revoke);\n\tgfs2_assert_withdraw(sdp,\n\t\t\tsdp->sd_log_num_revoke == sdp->sd_log_commited_revoke);\n\n\tgfs2_ordered_write(sdp);\n\tlops_before_commit(sdp, tr);\n\tgfs2_log_flush_bio(sdp, WRITE);\n\n\tif (sdp->sd_log_head != sdp->sd_log_flush_head) {\n\t\tlog_flush_wait(sdp);\n\t\tlog_write_header(sdp, 0);\n\t} else if (sdp->sd_log_tail != current_tail(sdp) && !sdp->sd_log_idle){\n\t\tatomic_dec(&sdp->sd_log_blks_free); /* Adjust for unreserved buffer */\n\t\ttrace_gfs2_log_blocks(sdp, -1);\n\t\tlog_write_header(sdp, 0);\n\t}\n\tlops_after_commit(sdp, tr);\n\n\tgfs2_log_lock(sdp);\n\tsdp->sd_log_head = sdp->sd_log_flush_head;\n\tsdp->sd_log_blks_reserved = 0;\n\tsdp->sd_log_commited_revoke = 0;\n\n\tspin_lock(&sdp->sd_ail_lock);\n\tif (tr && !list_empty(&tr->tr_ail1_list)) {\n\t\tlist_add(&tr->tr_list, &sdp->sd_ail1_list);\n\t\ttr = NULL;\n\t}\n\tspin_unlock(&sdp->sd_ail_lock);\n\tgfs2_log_unlock(sdp);\n\n\tif (type != NORMAL_FLUSH) {\n\t\tif (!sdp->sd_log_idle) {\n\t\t\tfor (;;) {\n\t\t\t\tgfs2_ail1_start(sdp);\n\t\t\t\tgfs2_ail1_wait(sdp);\n\t\t\t\tif (gfs2_ail1_empty(sdp))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tatomic_dec(&sdp->sd_log_blks_free); /* Adjust for unreserved buffer */\n\t\t\ttrace_gfs2_log_blocks(sdp, -1);\n\t\t\tsdp->sd_log_flush_wrapped = 0;\n\t\t\tlog_write_header(sdp, 0);\n\t\t\tsdp->sd_log_head = sdp->sd_log_flush_head;\n\t\t}\n\t\tif (type == SHUTDOWN_FLUSH || type == FREEZE_FLUSH)\n\t\t\tgfs2_log_shutdown(sdp);\n\t\tif (type == FREEZE_FLUSH)\n\t\t\tatomic_set(&sdp->sd_freeze_state, SFS_FROZEN);\n\t}\n\n\ttrace_gfs2_log_flush(sdp, 0);\n\tup_write(&sdp->sd_log_flush_lock);\n\n\tkfree(tr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GLOCK_BUG_ON",
          "args": [
            "gl",
            "gl->gl_state != LM_ST_EXCLUSIVE"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "GLF_DIRTY",
            "&gl->gl_flags"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1129-1139",
          "snippet": "static inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_clear_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr &= ~mask;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dir.h\"\n#include \"trans.h\"\n#include \"util.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/posix_acl.h>\n#include <linux/bio.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic void rgrp_go_sync(struct gfs2_glock *gl)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct address_space *mapping = &sdp->sd_aspace;\n\tstruct gfs2_rgrpd *rgd;\n\tint error;\n\n\tif (!test_and_clear_bit(GLF_DIRTY, &gl->gl_flags))\n\t\treturn;\n\tGLOCK_BUG_ON(gl, gl->gl_state != LM_ST_EXCLUSIVE);\n\n\tgfs2_log_flush(sdp, gl, NORMAL_FLUSH);\n\tfilemap_fdatawrite_range(mapping, gl->gl_vm.start, gl->gl_vm.end);\n\terror = filemap_fdatawait_range(mapping, gl->gl_vm.start, gl->gl_vm.end);\n\tmapping_set_error(mapping, error);\n\tgfs2_ail_empty_gl(gl);\n\n\tspin_lock(&gl->gl_spin);\n\trgd = gl->gl_object;\n\tif (rgd)\n\t\tgfs2_free_clones(rgd);\n\tspin_unlock(&gl->gl_spin);\n}"
  },
  {
    "function_name": "gfs2_ail_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glops.c",
    "lines": "110-129",
    "snippet": "void gfs2_ail_flush(struct gfs2_glock *gl, bool fsync)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tunsigned int revokes = atomic_read(&gl->gl_ail_count);\n\tunsigned int max_revokes = (sdp->sd_sb.sb_bsize - sizeof(struct gfs2_log_descriptor)) / sizeof(u64);\n\tint ret;\n\n\tif (!revokes)\n\t\treturn;\n\n\twhile (revokes > max_revokes)\n\t\tmax_revokes += (sdp->sd_sb.sb_bsize - sizeof(struct gfs2_meta_header)) / sizeof(u64);\n\n\tret = gfs2_trans_begin(sdp, 0, max_revokes);\n\tif (ret)\n\t\treturn;\n\t__gfs2_ail_flush(gl, fsync, max_revokes);\n\tgfs2_trans_end(sdp);\n\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n}",
    "includes": [
      "#include \"dir.h\"",
      "#include \"trans.h\"",
      "#include \"util.h\"",
      "#include \"rgrp.h\"",
      "#include \"recovery.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/posix_acl.h>",
      "#include <linux/bio.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_log_flush",
          "args": [
            "sdp",
            "NULL",
            "NORMAL_FLUSH"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_log_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/log.c",
          "lines": "704-787",
          "snippet": "void gfs2_log_flush(struct gfs2_sbd *sdp, struct gfs2_glock *gl,\n\t\t    enum gfs2_flush_type type)\n{\n\tstruct gfs2_trans *tr;\n\tenum gfs2_freeze_state state = atomic_read(&sdp->sd_freeze_state);\n\n\tdown_write(&sdp->sd_log_flush_lock);\n\n\t/* Log might have been flushed while we waited for the flush lock */\n\tif (gl && !test_bit(GLF_LFLUSH, &gl->gl_flags)) {\n\t\tup_write(&sdp->sd_log_flush_lock);\n\t\treturn;\n\t}\n\ttrace_gfs2_log_flush(sdp, 1);\n\n\tsdp->sd_log_flush_head = sdp->sd_log_head;\n\tsdp->sd_log_flush_wrapped = 0;\n\ttr = sdp->sd_log_tr;\n\tif (tr) {\n\t\tsdp->sd_log_tr = NULL;\n\t\tINIT_LIST_HEAD(&tr->tr_ail1_list);\n\t\tINIT_LIST_HEAD(&tr->tr_ail2_list);\n\t\ttr->tr_first = sdp->sd_log_flush_head;\n\t\tif (unlikely (state == SFS_FROZEN))\n\t\t\tgfs2_assert_withdraw(sdp, !tr->tr_num_buf_new && !tr->tr_num_databuf_new);\n\t}\n\n\tif (unlikely(state == SFS_FROZEN))\n\t\tgfs2_assert_withdraw(sdp, !sdp->sd_log_num_revoke);\n\tgfs2_assert_withdraw(sdp,\n\t\t\tsdp->sd_log_num_revoke == sdp->sd_log_commited_revoke);\n\n\tgfs2_ordered_write(sdp);\n\tlops_before_commit(sdp, tr);\n\tgfs2_log_flush_bio(sdp, WRITE);\n\n\tif (sdp->sd_log_head != sdp->sd_log_flush_head) {\n\t\tlog_flush_wait(sdp);\n\t\tlog_write_header(sdp, 0);\n\t} else if (sdp->sd_log_tail != current_tail(sdp) && !sdp->sd_log_idle){\n\t\tatomic_dec(&sdp->sd_log_blks_free); /* Adjust for unreserved buffer */\n\t\ttrace_gfs2_log_blocks(sdp, -1);\n\t\tlog_write_header(sdp, 0);\n\t}\n\tlops_after_commit(sdp, tr);\n\n\tgfs2_log_lock(sdp);\n\tsdp->sd_log_head = sdp->sd_log_flush_head;\n\tsdp->sd_log_blks_reserved = 0;\n\tsdp->sd_log_commited_revoke = 0;\n\n\tspin_lock(&sdp->sd_ail_lock);\n\tif (tr && !list_empty(&tr->tr_ail1_list)) {\n\t\tlist_add(&tr->tr_list, &sdp->sd_ail1_list);\n\t\ttr = NULL;\n\t}\n\tspin_unlock(&sdp->sd_ail_lock);\n\tgfs2_log_unlock(sdp);\n\n\tif (type != NORMAL_FLUSH) {\n\t\tif (!sdp->sd_log_idle) {\n\t\t\tfor (;;) {\n\t\t\t\tgfs2_ail1_start(sdp);\n\t\t\t\tgfs2_ail1_wait(sdp);\n\t\t\t\tif (gfs2_ail1_empty(sdp))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tatomic_dec(&sdp->sd_log_blks_free); /* Adjust for unreserved buffer */\n\t\t\ttrace_gfs2_log_blocks(sdp, -1);\n\t\t\tsdp->sd_log_flush_wrapped = 0;\n\t\t\tlog_write_header(sdp, 0);\n\t\t\tsdp->sd_log_head = sdp->sd_log_flush_head;\n\t\t}\n\t\tif (type == SHUTDOWN_FLUSH || type == FREEZE_FLUSH)\n\t\t\tgfs2_log_shutdown(sdp);\n\t\tif (type == FREEZE_FLUSH)\n\t\t\tatomic_set(&sdp->sd_freeze_state, SFS_FROZEN);\n\t}\n\n\ttrace_gfs2_log_flush(sdp, 0);\n\tup_write(&sdp->sd_log_flush_lock);\n\n\tkfree(tr);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/list_sort.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_log_flush(struct gfs2_sbd *sdp, struct gfs2_glock *gl,\n\t\t    enum gfs2_flush_type type)\n{\n\tstruct gfs2_trans *tr;\n\tenum gfs2_freeze_state state = atomic_read(&sdp->sd_freeze_state);\n\n\tdown_write(&sdp->sd_log_flush_lock);\n\n\t/* Log might have been flushed while we waited for the flush lock */\n\tif (gl && !test_bit(GLF_LFLUSH, &gl->gl_flags)) {\n\t\tup_write(&sdp->sd_log_flush_lock);\n\t\treturn;\n\t}\n\ttrace_gfs2_log_flush(sdp, 1);\n\n\tsdp->sd_log_flush_head = sdp->sd_log_head;\n\tsdp->sd_log_flush_wrapped = 0;\n\ttr = sdp->sd_log_tr;\n\tif (tr) {\n\t\tsdp->sd_log_tr = NULL;\n\t\tINIT_LIST_HEAD(&tr->tr_ail1_list);\n\t\tINIT_LIST_HEAD(&tr->tr_ail2_list);\n\t\ttr->tr_first = sdp->sd_log_flush_head;\n\t\tif (unlikely (state == SFS_FROZEN))\n\t\t\tgfs2_assert_withdraw(sdp, !tr->tr_num_buf_new && !tr->tr_num_databuf_new);\n\t}\n\n\tif (unlikely(state == SFS_FROZEN))\n\t\tgfs2_assert_withdraw(sdp, !sdp->sd_log_num_revoke);\n\tgfs2_assert_withdraw(sdp,\n\t\t\tsdp->sd_log_num_revoke == sdp->sd_log_commited_revoke);\n\n\tgfs2_ordered_write(sdp);\n\tlops_before_commit(sdp, tr);\n\tgfs2_log_flush_bio(sdp, WRITE);\n\n\tif (sdp->sd_log_head != sdp->sd_log_flush_head) {\n\t\tlog_flush_wait(sdp);\n\t\tlog_write_header(sdp, 0);\n\t} else if (sdp->sd_log_tail != current_tail(sdp) && !sdp->sd_log_idle){\n\t\tatomic_dec(&sdp->sd_log_blks_free); /* Adjust for unreserved buffer */\n\t\ttrace_gfs2_log_blocks(sdp, -1);\n\t\tlog_write_header(sdp, 0);\n\t}\n\tlops_after_commit(sdp, tr);\n\n\tgfs2_log_lock(sdp);\n\tsdp->sd_log_head = sdp->sd_log_flush_head;\n\tsdp->sd_log_blks_reserved = 0;\n\tsdp->sd_log_commited_revoke = 0;\n\n\tspin_lock(&sdp->sd_ail_lock);\n\tif (tr && !list_empty(&tr->tr_ail1_list)) {\n\t\tlist_add(&tr->tr_list, &sdp->sd_ail1_list);\n\t\ttr = NULL;\n\t}\n\tspin_unlock(&sdp->sd_ail_lock);\n\tgfs2_log_unlock(sdp);\n\n\tif (type != NORMAL_FLUSH) {\n\t\tif (!sdp->sd_log_idle) {\n\t\t\tfor (;;) {\n\t\t\t\tgfs2_ail1_start(sdp);\n\t\t\t\tgfs2_ail1_wait(sdp);\n\t\t\t\tif (gfs2_ail1_empty(sdp))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tatomic_dec(&sdp->sd_log_blks_free); /* Adjust for unreserved buffer */\n\t\t\ttrace_gfs2_log_blocks(sdp, -1);\n\t\t\tsdp->sd_log_flush_wrapped = 0;\n\t\t\tlog_write_header(sdp, 0);\n\t\t\tsdp->sd_log_head = sdp->sd_log_flush_head;\n\t\t}\n\t\tif (type == SHUTDOWN_FLUSH || type == FREEZE_FLUSH)\n\t\t\tgfs2_log_shutdown(sdp);\n\t\tif (type == FREEZE_FLUSH)\n\t\t\tatomic_set(&sdp->sd_freeze_state, SFS_FROZEN);\n\t}\n\n\ttrace_gfs2_log_flush(sdp, 0);\n\tup_write(&sdp->sd_log_flush_lock);\n\n\tkfree(tr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_end",
          "args": [
            "sdp"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "88-123",
          "snippet": "void gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__gfs2_ail_flush",
          "args": [
            "gl",
            "fsync",
            "max_revokes"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "__gfs2_ail_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glops.c",
          "lines": "52-78",
          "snippet": "static void __gfs2_ail_flush(struct gfs2_glock *gl, bool fsync,\n\t\t\t     unsigned int nr_revokes)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct list_head *head = &gl->gl_ail_list;\n\tstruct gfs2_bufdata *bd, *tmp;\n\tstruct buffer_head *bh;\n\tconst unsigned long b_state = (1UL << BH_Dirty)|(1UL << BH_Pinned)|(1UL << BH_Lock);\n\n\tgfs2_log_lock(sdp);\n\tspin_lock(&sdp->sd_ail_lock);\n\tlist_for_each_entry_safe_reverse(bd, tmp, head, bd_ail_gl_list) {\n\t\tif (nr_revokes == 0)\n\t\t\tbreak;\n\t\tbh = bd->bd_bh;\n\t\tif (bh->b_state & b_state) {\n\t\t\tif (fsync)\n\t\t\t\tcontinue;\n\t\t\tgfs2_ail_error(gl, bh);\n\t\t}\n\t\tgfs2_trans_add_revoke(sdp, bd);\n\t\tnr_revokes--;\n\t}\n\tGLOCK_BUG_ON(gl, !fsync && atomic_read(&gl->gl_ail_count));\n\tspin_unlock(&sdp->sd_ail_lock);\n\tgfs2_log_unlock(sdp);\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"util.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/posix_acl.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"trans.h\"\n#include \"util.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/posix_acl.h>\n#include <linux/bio.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic void __gfs2_ail_flush(struct gfs2_glock *gl, bool fsync,\n\t\t\t     unsigned int nr_revokes)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct list_head *head = &gl->gl_ail_list;\n\tstruct gfs2_bufdata *bd, *tmp;\n\tstruct buffer_head *bh;\n\tconst unsigned long b_state = (1UL << BH_Dirty)|(1UL << BH_Pinned)|(1UL << BH_Lock);\n\n\tgfs2_log_lock(sdp);\n\tspin_lock(&sdp->sd_ail_lock);\n\tlist_for_each_entry_safe_reverse(bd, tmp, head, bd_ail_gl_list) {\n\t\tif (nr_revokes == 0)\n\t\t\tbreak;\n\t\tbh = bd->bd_bh;\n\t\tif (bh->b_state & b_state) {\n\t\t\tif (fsync)\n\t\t\t\tcontinue;\n\t\t\tgfs2_ail_error(gl, bh);\n\t\t}\n\t\tgfs2_trans_add_revoke(sdp, bd);\n\t\tnr_revokes--;\n\t}\n\tGLOCK_BUG_ON(gl, !fsync && atomic_read(&gl->gl_ail_count));\n\tspin_unlock(&sdp->sd_ail_lock);\n\tgfs2_log_unlock(sdp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_begin",
          "args": [
            "sdp",
            "0",
            "max_revokes"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "31-75",
          "snippet": "int gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,\n\t\t     unsigned int revokes)\n{\n\tstruct gfs2_trans *tr;\n\tint error;\n\n\tBUG_ON(current->journal_info);\n\tBUG_ON(blocks == 0 && revokes == 0);\n\n\tif (!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))\n\t\treturn -EROFS;\n\n\ttr = kzalloc(sizeof(struct gfs2_trans), GFP_NOFS);\n\tif (!tr)\n\t\treturn -ENOMEM;\n\n\ttr->tr_ip = _RET_IP_;\n\ttr->tr_blocks = blocks;\n\ttr->tr_revokes = revokes;\n\ttr->tr_reserved = 1;\n\ttr->tr_alloced = 1;\n\tif (blocks)\n\t\ttr->tr_reserved += 6 + blocks;\n\tif (revokes)\n\t\ttr->tr_reserved += gfs2_struct2blk(sdp, revokes,\n\t\t\t\t\t\t   sizeof(u64));\n\tINIT_LIST_HEAD(&tr->tr_databuf);\n\tINIT_LIST_HEAD(&tr->tr_buf);\n\n\tsb_start_intwrite(sdp->sd_vfs);\n\n\terror = gfs2_log_reserve(sdp, tr->tr_reserved);\n\tif (error)\n\t\tgoto fail;\n\n\tcurrent->journal_info = tr;\n\n\treturn 0;\n\nfail:\n\tsb_end_intwrite(sdp->sd_vfs);\n\tkfree(tr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&gl->gl_ail_count"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dir.h\"\n#include \"trans.h\"\n#include \"util.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/posix_acl.h>\n#include <linux/bio.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nvoid gfs2_ail_flush(struct gfs2_glock *gl, bool fsync)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tunsigned int revokes = atomic_read(&gl->gl_ail_count);\n\tunsigned int max_revokes = (sdp->sd_sb.sb_bsize - sizeof(struct gfs2_log_descriptor)) / sizeof(u64);\n\tint ret;\n\n\tif (!revokes)\n\t\treturn;\n\n\twhile (revokes > max_revokes)\n\t\tmax_revokes += (sdp->sd_sb.sb_bsize - sizeof(struct gfs2_meta_header)) / sizeof(u64);\n\n\tret = gfs2_trans_begin(sdp, 0, max_revokes);\n\tif (ret)\n\t\treturn;\n\t__gfs2_ail_flush(gl, fsync, max_revokes);\n\tgfs2_trans_end(sdp);\n\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n}"
  },
  {
    "function_name": "gfs2_ail_empty_gl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glops.c",
    "lines": "81-108",
    "snippet": "static void gfs2_ail_empty_gl(struct gfs2_glock *gl)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_trans tr;\n\n\tmemset(&tr, 0, sizeof(tr));\n\tINIT_LIST_HEAD(&tr.tr_buf);\n\tINIT_LIST_HEAD(&tr.tr_databuf);\n\ttr.tr_revokes = atomic_read(&gl->gl_ail_count);\n\n\tif (!tr.tr_revokes)\n\t\treturn;\n\n\t/* A shortened, inline version of gfs2_trans_begin()\n         * tr->alloced is not set since the transaction structure is\n         * on the stack */\n\ttr.tr_reserved = 1 + gfs2_struct2blk(sdp, tr.tr_revokes, sizeof(u64));\n\ttr.tr_ip = _RET_IP_;\n\tif (gfs2_log_reserve(sdp, tr.tr_reserved) < 0)\n\t\treturn;\n\tWARN_ON_ONCE(current->journal_info);\n\tcurrent->journal_info = &tr;\n\n\t__gfs2_ail_flush(gl, 0, tr.tr_revokes);\n\n\tgfs2_trans_end(sdp);\n\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n}",
    "includes": [
      "#include \"dir.h\"",
      "#include \"trans.h\"",
      "#include \"util.h\"",
      "#include \"rgrp.h\"",
      "#include \"recovery.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/posix_acl.h>",
      "#include <linux/bio.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_log_flush",
          "args": [
            "sdp",
            "NULL",
            "NORMAL_FLUSH"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_log_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/log.c",
          "lines": "704-787",
          "snippet": "void gfs2_log_flush(struct gfs2_sbd *sdp, struct gfs2_glock *gl,\n\t\t    enum gfs2_flush_type type)\n{\n\tstruct gfs2_trans *tr;\n\tenum gfs2_freeze_state state = atomic_read(&sdp->sd_freeze_state);\n\n\tdown_write(&sdp->sd_log_flush_lock);\n\n\t/* Log might have been flushed while we waited for the flush lock */\n\tif (gl && !test_bit(GLF_LFLUSH, &gl->gl_flags)) {\n\t\tup_write(&sdp->sd_log_flush_lock);\n\t\treturn;\n\t}\n\ttrace_gfs2_log_flush(sdp, 1);\n\n\tsdp->sd_log_flush_head = sdp->sd_log_head;\n\tsdp->sd_log_flush_wrapped = 0;\n\ttr = sdp->sd_log_tr;\n\tif (tr) {\n\t\tsdp->sd_log_tr = NULL;\n\t\tINIT_LIST_HEAD(&tr->tr_ail1_list);\n\t\tINIT_LIST_HEAD(&tr->tr_ail2_list);\n\t\ttr->tr_first = sdp->sd_log_flush_head;\n\t\tif (unlikely (state == SFS_FROZEN))\n\t\t\tgfs2_assert_withdraw(sdp, !tr->tr_num_buf_new && !tr->tr_num_databuf_new);\n\t}\n\n\tif (unlikely(state == SFS_FROZEN))\n\t\tgfs2_assert_withdraw(sdp, !sdp->sd_log_num_revoke);\n\tgfs2_assert_withdraw(sdp,\n\t\t\tsdp->sd_log_num_revoke == sdp->sd_log_commited_revoke);\n\n\tgfs2_ordered_write(sdp);\n\tlops_before_commit(sdp, tr);\n\tgfs2_log_flush_bio(sdp, WRITE);\n\n\tif (sdp->sd_log_head != sdp->sd_log_flush_head) {\n\t\tlog_flush_wait(sdp);\n\t\tlog_write_header(sdp, 0);\n\t} else if (sdp->sd_log_tail != current_tail(sdp) && !sdp->sd_log_idle){\n\t\tatomic_dec(&sdp->sd_log_blks_free); /* Adjust for unreserved buffer */\n\t\ttrace_gfs2_log_blocks(sdp, -1);\n\t\tlog_write_header(sdp, 0);\n\t}\n\tlops_after_commit(sdp, tr);\n\n\tgfs2_log_lock(sdp);\n\tsdp->sd_log_head = sdp->sd_log_flush_head;\n\tsdp->sd_log_blks_reserved = 0;\n\tsdp->sd_log_commited_revoke = 0;\n\n\tspin_lock(&sdp->sd_ail_lock);\n\tif (tr && !list_empty(&tr->tr_ail1_list)) {\n\t\tlist_add(&tr->tr_list, &sdp->sd_ail1_list);\n\t\ttr = NULL;\n\t}\n\tspin_unlock(&sdp->sd_ail_lock);\n\tgfs2_log_unlock(sdp);\n\n\tif (type != NORMAL_FLUSH) {\n\t\tif (!sdp->sd_log_idle) {\n\t\t\tfor (;;) {\n\t\t\t\tgfs2_ail1_start(sdp);\n\t\t\t\tgfs2_ail1_wait(sdp);\n\t\t\t\tif (gfs2_ail1_empty(sdp))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tatomic_dec(&sdp->sd_log_blks_free); /* Adjust for unreserved buffer */\n\t\t\ttrace_gfs2_log_blocks(sdp, -1);\n\t\t\tsdp->sd_log_flush_wrapped = 0;\n\t\t\tlog_write_header(sdp, 0);\n\t\t\tsdp->sd_log_head = sdp->sd_log_flush_head;\n\t\t}\n\t\tif (type == SHUTDOWN_FLUSH || type == FREEZE_FLUSH)\n\t\t\tgfs2_log_shutdown(sdp);\n\t\tif (type == FREEZE_FLUSH)\n\t\t\tatomic_set(&sdp->sd_freeze_state, SFS_FROZEN);\n\t}\n\n\ttrace_gfs2_log_flush(sdp, 0);\n\tup_write(&sdp->sd_log_flush_lock);\n\n\tkfree(tr);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/list_sort.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_log_flush(struct gfs2_sbd *sdp, struct gfs2_glock *gl,\n\t\t    enum gfs2_flush_type type)\n{\n\tstruct gfs2_trans *tr;\n\tenum gfs2_freeze_state state = atomic_read(&sdp->sd_freeze_state);\n\n\tdown_write(&sdp->sd_log_flush_lock);\n\n\t/* Log might have been flushed while we waited for the flush lock */\n\tif (gl && !test_bit(GLF_LFLUSH, &gl->gl_flags)) {\n\t\tup_write(&sdp->sd_log_flush_lock);\n\t\treturn;\n\t}\n\ttrace_gfs2_log_flush(sdp, 1);\n\n\tsdp->sd_log_flush_head = sdp->sd_log_head;\n\tsdp->sd_log_flush_wrapped = 0;\n\ttr = sdp->sd_log_tr;\n\tif (tr) {\n\t\tsdp->sd_log_tr = NULL;\n\t\tINIT_LIST_HEAD(&tr->tr_ail1_list);\n\t\tINIT_LIST_HEAD(&tr->tr_ail2_list);\n\t\ttr->tr_first = sdp->sd_log_flush_head;\n\t\tif (unlikely (state == SFS_FROZEN))\n\t\t\tgfs2_assert_withdraw(sdp, !tr->tr_num_buf_new && !tr->tr_num_databuf_new);\n\t}\n\n\tif (unlikely(state == SFS_FROZEN))\n\t\tgfs2_assert_withdraw(sdp, !sdp->sd_log_num_revoke);\n\tgfs2_assert_withdraw(sdp,\n\t\t\tsdp->sd_log_num_revoke == sdp->sd_log_commited_revoke);\n\n\tgfs2_ordered_write(sdp);\n\tlops_before_commit(sdp, tr);\n\tgfs2_log_flush_bio(sdp, WRITE);\n\n\tif (sdp->sd_log_head != sdp->sd_log_flush_head) {\n\t\tlog_flush_wait(sdp);\n\t\tlog_write_header(sdp, 0);\n\t} else if (sdp->sd_log_tail != current_tail(sdp) && !sdp->sd_log_idle){\n\t\tatomic_dec(&sdp->sd_log_blks_free); /* Adjust for unreserved buffer */\n\t\ttrace_gfs2_log_blocks(sdp, -1);\n\t\tlog_write_header(sdp, 0);\n\t}\n\tlops_after_commit(sdp, tr);\n\n\tgfs2_log_lock(sdp);\n\tsdp->sd_log_head = sdp->sd_log_flush_head;\n\tsdp->sd_log_blks_reserved = 0;\n\tsdp->sd_log_commited_revoke = 0;\n\n\tspin_lock(&sdp->sd_ail_lock);\n\tif (tr && !list_empty(&tr->tr_ail1_list)) {\n\t\tlist_add(&tr->tr_list, &sdp->sd_ail1_list);\n\t\ttr = NULL;\n\t}\n\tspin_unlock(&sdp->sd_ail_lock);\n\tgfs2_log_unlock(sdp);\n\n\tif (type != NORMAL_FLUSH) {\n\t\tif (!sdp->sd_log_idle) {\n\t\t\tfor (;;) {\n\t\t\t\tgfs2_ail1_start(sdp);\n\t\t\t\tgfs2_ail1_wait(sdp);\n\t\t\t\tif (gfs2_ail1_empty(sdp))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tatomic_dec(&sdp->sd_log_blks_free); /* Adjust for unreserved buffer */\n\t\t\ttrace_gfs2_log_blocks(sdp, -1);\n\t\t\tsdp->sd_log_flush_wrapped = 0;\n\t\t\tlog_write_header(sdp, 0);\n\t\t\tsdp->sd_log_head = sdp->sd_log_flush_head;\n\t\t}\n\t\tif (type == SHUTDOWN_FLUSH || type == FREEZE_FLUSH)\n\t\t\tgfs2_log_shutdown(sdp);\n\t\tif (type == FREEZE_FLUSH)\n\t\t\tatomic_set(&sdp->sd_freeze_state, SFS_FROZEN);\n\t}\n\n\ttrace_gfs2_log_flush(sdp, 0);\n\tup_write(&sdp->sd_log_flush_lock);\n\n\tkfree(tr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_trans_end",
          "args": [
            "sdp"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "88-123",
          "snippet": "void gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_end(struct gfs2_sbd *sdp)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\ts64 nbuf;\n\tint alloced = tr->tr_alloced;\n\n\tBUG_ON(!tr);\n\tcurrent->journal_info = NULL;\n\n\tif (!tr->tr_touched) {\n\t\tgfs2_log_release(sdp, tr->tr_reserved);\n\t\tif (alloced) {\n\t\t\tkfree(tr);\n\t\t\tsb_end_intwrite(sdp->sd_vfs);\n\t\t}\n\t\treturn;\n\t}\n\n\tnbuf = tr->tr_num_buf_new + tr->tr_num_databuf_new;\n\tnbuf -= tr->tr_num_buf_rm;\n\tnbuf -= tr->tr_num_databuf_rm;\n\n\tif (gfs2_assert_withdraw(sdp, (nbuf <= tr->tr_blocks) &&\n\t\t\t\t       (tr->tr_num_revoke <= tr->tr_revokes)))\n\t\tgfs2_print_trans(tr);\n\n\tgfs2_log_commit(sdp, tr);\n\tif (alloced && !tr->tr_attached)\n\t\t\tkfree(tr);\n\tup_read(&sdp->sd_log_flush_lock);\n\n\tif (sdp->sd_vfs->s_flags & MS_SYNCHRONOUS)\n\t\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n\tif (alloced)\n\t\tsb_end_intwrite(sdp->sd_vfs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__gfs2_ail_flush",
          "args": [
            "gl",
            "0",
            "tr.tr_revokes"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "__gfs2_ail_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glops.c",
          "lines": "52-78",
          "snippet": "static void __gfs2_ail_flush(struct gfs2_glock *gl, bool fsync,\n\t\t\t     unsigned int nr_revokes)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct list_head *head = &gl->gl_ail_list;\n\tstruct gfs2_bufdata *bd, *tmp;\n\tstruct buffer_head *bh;\n\tconst unsigned long b_state = (1UL << BH_Dirty)|(1UL << BH_Pinned)|(1UL << BH_Lock);\n\n\tgfs2_log_lock(sdp);\n\tspin_lock(&sdp->sd_ail_lock);\n\tlist_for_each_entry_safe_reverse(bd, tmp, head, bd_ail_gl_list) {\n\t\tif (nr_revokes == 0)\n\t\t\tbreak;\n\t\tbh = bd->bd_bh;\n\t\tif (bh->b_state & b_state) {\n\t\t\tif (fsync)\n\t\t\t\tcontinue;\n\t\t\tgfs2_ail_error(gl, bh);\n\t\t}\n\t\tgfs2_trans_add_revoke(sdp, bd);\n\t\tnr_revokes--;\n\t}\n\tGLOCK_BUG_ON(gl, !fsync && atomic_read(&gl->gl_ail_count));\n\tspin_unlock(&sdp->sd_ail_lock);\n\tgfs2_log_unlock(sdp);\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"util.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/posix_acl.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"trans.h\"\n#include \"util.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/posix_acl.h>\n#include <linux/bio.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic void __gfs2_ail_flush(struct gfs2_glock *gl, bool fsync,\n\t\t\t     unsigned int nr_revokes)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct list_head *head = &gl->gl_ail_list;\n\tstruct gfs2_bufdata *bd, *tmp;\n\tstruct buffer_head *bh;\n\tconst unsigned long b_state = (1UL << BH_Dirty)|(1UL << BH_Pinned)|(1UL << BH_Lock);\n\n\tgfs2_log_lock(sdp);\n\tspin_lock(&sdp->sd_ail_lock);\n\tlist_for_each_entry_safe_reverse(bd, tmp, head, bd_ail_gl_list) {\n\t\tif (nr_revokes == 0)\n\t\t\tbreak;\n\t\tbh = bd->bd_bh;\n\t\tif (bh->b_state & b_state) {\n\t\t\tif (fsync)\n\t\t\t\tcontinue;\n\t\t\tgfs2_ail_error(gl, bh);\n\t\t}\n\t\tgfs2_trans_add_revoke(sdp, bd);\n\t\tnr_revokes--;\n\t}\n\tGLOCK_BUG_ON(gl, !fsync && atomic_read(&gl->gl_ail_count));\n\tspin_unlock(&sdp->sd_ail_lock);\n\tgfs2_log_unlock(sdp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "current->journal_info"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_log_reserve",
          "args": [
            "sdp",
            "tr.tr_reserved"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_log_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/log.c",
          "lines": "340-390",
          "snippet": "int gfs2_log_reserve(struct gfs2_sbd *sdp, unsigned int blks)\n{\n\tint ret = 0;\n\tunsigned reserved_blks = 7 * (4096 / sdp->sd_vfs->s_blocksize);\n\tunsigned wanted = blks + reserved_blks;\n\tDEFINE_WAIT(wait);\n\tint did_wait = 0;\n\tunsigned int free_blocks;\n\n\tif (gfs2_assert_warn(sdp, blks) ||\n\t    gfs2_assert_warn(sdp, blks <= sdp->sd_jdesc->jd_blocks))\n\t\treturn -EINVAL;\nretry:\n\tfree_blocks = atomic_read(&sdp->sd_log_blks_free);\n\tif (unlikely(free_blocks <= wanted)) {\n\t\tdo {\n\t\t\tprepare_to_wait_exclusive(&sdp->sd_log_waitq, &wait,\n\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\t\twake_up(&sdp->sd_logd_waitq);\n\t\t\tdid_wait = 1;\n\t\t\tif (atomic_read(&sdp->sd_log_blks_free) <= wanted)\n\t\t\t\tio_schedule();\n\t\t\tfree_blocks = atomic_read(&sdp->sd_log_blks_free);\n\t\t} while(free_blocks <= wanted);\n\t\tfinish_wait(&sdp->sd_log_waitq, &wait);\n\t}\n\tatomic_inc(&sdp->sd_reserving_log);\n\tif (atomic_cmpxchg(&sdp->sd_log_blks_free, free_blocks,\n\t\t\t\tfree_blocks - blks) != free_blocks) {\n\t\tif (atomic_dec_and_test(&sdp->sd_reserving_log))\n\t\t\twake_up(&sdp->sd_reserving_log_wait);\n\t\tgoto retry;\n\t}\n\ttrace_gfs2_log_blocks(sdp, -blks);\n\n\t/*\n\t * If we waited, then so might others, wake them up _after_ we get\n\t * our share of the log.\n\t */\n\tif (unlikely(did_wait))\n\t\twake_up(&sdp->sd_log_waitq);\n\n\tdown_read(&sdp->sd_log_flush_lock);\n\tif (unlikely(!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))) {\n\t\tgfs2_log_release(sdp, blks);\n\t\tret = -EROFS;\n\t}\n\tif (atomic_dec_and_test(&sdp->sd_reserving_log))\n\t\twake_up(&sdp->sd_reserving_log_wait);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/list_sort.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint gfs2_log_reserve(struct gfs2_sbd *sdp, unsigned int blks)\n{\n\tint ret = 0;\n\tunsigned reserved_blks = 7 * (4096 / sdp->sd_vfs->s_blocksize);\n\tunsigned wanted = blks + reserved_blks;\n\tDEFINE_WAIT(wait);\n\tint did_wait = 0;\n\tunsigned int free_blocks;\n\n\tif (gfs2_assert_warn(sdp, blks) ||\n\t    gfs2_assert_warn(sdp, blks <= sdp->sd_jdesc->jd_blocks))\n\t\treturn -EINVAL;\nretry:\n\tfree_blocks = atomic_read(&sdp->sd_log_blks_free);\n\tif (unlikely(free_blocks <= wanted)) {\n\t\tdo {\n\t\t\tprepare_to_wait_exclusive(&sdp->sd_log_waitq, &wait,\n\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\t\twake_up(&sdp->sd_logd_waitq);\n\t\t\tdid_wait = 1;\n\t\t\tif (atomic_read(&sdp->sd_log_blks_free) <= wanted)\n\t\t\t\tio_schedule();\n\t\t\tfree_blocks = atomic_read(&sdp->sd_log_blks_free);\n\t\t} while(free_blocks <= wanted);\n\t\tfinish_wait(&sdp->sd_log_waitq, &wait);\n\t}\n\tatomic_inc(&sdp->sd_reserving_log);\n\tif (atomic_cmpxchg(&sdp->sd_log_blks_free, free_blocks,\n\t\t\t\tfree_blocks - blks) != free_blocks) {\n\t\tif (atomic_dec_and_test(&sdp->sd_reserving_log))\n\t\t\twake_up(&sdp->sd_reserving_log_wait);\n\t\tgoto retry;\n\t}\n\ttrace_gfs2_log_blocks(sdp, -blks);\n\n\t/*\n\t * If we waited, then so might others, wake them up _after_ we get\n\t * our share of the log.\n\t */\n\tif (unlikely(did_wait))\n\t\twake_up(&sdp->sd_log_waitq);\n\n\tdown_read(&sdp->sd_log_flush_lock);\n\tif (unlikely(!test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags))) {\n\t\tgfs2_log_release(sdp, blks);\n\t\tret = -EROFS;\n\t}\n\tif (atomic_dec_and_test(&sdp->sd_reserving_log))\n\t\twake_up(&sdp->sd_reserving_log_wait);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_struct2blk",
          "args": [
            "sdp",
            "tr.tr_revokes",
            "sizeof(u64)"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_struct2blk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/log.c",
          "lines": "48-64",
          "snippet": "unsigned int gfs2_struct2blk(struct gfs2_sbd *sdp, unsigned int nstruct,\n\t\t\t     unsigned int ssize)\n{\n\tunsigned int blks;\n\tunsigned int first, second;\n\n\tblks = 1;\n\tfirst = (sdp->sd_sb.sb_bsize - sizeof(struct gfs2_log_descriptor)) / ssize;\n\n\tif (nstruct > first) {\n\t\tsecond = (sdp->sd_sb.sb_bsize -\n\t\t\t  sizeof(struct gfs2_meta_header)) / ssize;\n\t\tblks += DIV_ROUND_UP(nstruct - first, second);\n\t}\n\n\treturn blks;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/crc32.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/list_sort.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/crc32.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nunsigned int gfs2_struct2blk(struct gfs2_sbd *sdp, unsigned int nstruct,\n\t\t\t     unsigned int ssize)\n{\n\tunsigned int blks;\n\tunsigned int first, second;\n\n\tblks = 1;\n\tfirst = (sdp->sd_sb.sb_bsize - sizeof(struct gfs2_log_descriptor)) / ssize;\n\n\tif (nstruct > first) {\n\t\tsecond = (sdp->sd_sb.sb_bsize -\n\t\t\t  sizeof(struct gfs2_meta_header)) / ssize;\n\t\tblks += DIV_ROUND_UP(nstruct - first, second);\n\t}\n\n\treturn blks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&gl->gl_ail_count"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tr.tr_databuf"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tr.tr_buf"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&tr",
            "0",
            "sizeof(tr)"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dir.h\"\n#include \"trans.h\"\n#include \"util.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/posix_acl.h>\n#include <linux/bio.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic void gfs2_ail_empty_gl(struct gfs2_glock *gl)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct gfs2_trans tr;\n\n\tmemset(&tr, 0, sizeof(tr));\n\tINIT_LIST_HEAD(&tr.tr_buf);\n\tINIT_LIST_HEAD(&tr.tr_databuf);\n\ttr.tr_revokes = atomic_read(&gl->gl_ail_count);\n\n\tif (!tr.tr_revokes)\n\t\treturn;\n\n\t/* A shortened, inline version of gfs2_trans_begin()\n         * tr->alloced is not set since the transaction structure is\n         * on the stack */\n\ttr.tr_reserved = 1 + gfs2_struct2blk(sdp, tr.tr_revokes, sizeof(u64));\n\ttr.tr_ip = _RET_IP_;\n\tif (gfs2_log_reserve(sdp, tr.tr_reserved) < 0)\n\t\treturn;\n\tWARN_ON_ONCE(current->journal_info);\n\tcurrent->journal_info = &tr;\n\n\t__gfs2_ail_flush(gl, 0, tr.tr_revokes);\n\n\tgfs2_trans_end(sdp);\n\tgfs2_log_flush(sdp, NULL, NORMAL_FLUSH);\n}"
  },
  {
    "function_name": "__gfs2_ail_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glops.c",
    "lines": "52-78",
    "snippet": "static void __gfs2_ail_flush(struct gfs2_glock *gl, bool fsync,\n\t\t\t     unsigned int nr_revokes)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct list_head *head = &gl->gl_ail_list;\n\tstruct gfs2_bufdata *bd, *tmp;\n\tstruct buffer_head *bh;\n\tconst unsigned long b_state = (1UL << BH_Dirty)|(1UL << BH_Pinned)|(1UL << BH_Lock);\n\n\tgfs2_log_lock(sdp);\n\tspin_lock(&sdp->sd_ail_lock);\n\tlist_for_each_entry_safe_reverse(bd, tmp, head, bd_ail_gl_list) {\n\t\tif (nr_revokes == 0)\n\t\t\tbreak;\n\t\tbh = bd->bd_bh;\n\t\tif (bh->b_state & b_state) {\n\t\t\tif (fsync)\n\t\t\t\tcontinue;\n\t\t\tgfs2_ail_error(gl, bh);\n\t\t}\n\t\tgfs2_trans_add_revoke(sdp, bd);\n\t\tnr_revokes--;\n\t}\n\tGLOCK_BUG_ON(gl, !fsync && atomic_read(&gl->gl_ail_count));\n\tspin_unlock(&sdp->sd_ail_lock);\n\tgfs2_log_unlock(sdp);\n}",
    "includes": [
      "#include \"dir.h\"",
      "#include \"trans.h\"",
      "#include \"util.h\"",
      "#include \"rgrp.h\"",
      "#include \"recovery.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/posix_acl.h>",
      "#include <linux/bio.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_log_unlock",
          "args": [
            "sdp"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_log_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/log.h",
          "lines": "36-40",
          "snippet": "static inline void gfs2_log_unlock(struct gfs2_sbd *sdp)\n__releases(&sdp->sd_log_lock)\n{\n\tspin_unlock(&sdp->sd_log_lock);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/writeback.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic inline void gfs2_log_unlock(struct gfs2_sbd *sdp)\n__releases(&sdp->sd_log_lock)\n{\n\tspin_unlock(&sdp->sd_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sdp->sd_ail_lock"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GLOCK_BUG_ON",
          "args": [
            "gl",
            "!fsync && atomic_read(&gl->gl_ail_count)"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&gl->gl_ail_count"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_trans_add_revoke",
          "args": [
            "sdp",
            "bd"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_trans_add_revoke",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/trans.c",
          "lines": "249-257",
          "snippet": "void gfs2_trans_add_revoke(struct gfs2_sbd *sdp, struct gfs2_bufdata *bd)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\n\tBUG_ON(!list_empty(&bd->bd_list));\n\tgfs2_add_revoke(sdp, bd);\n\ttr->tr_touched = 1;\n\ttr->tr_num_revoke++;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"util.h\"\n#include \"trans.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_trans_add_revoke(struct gfs2_sbd *sdp, struct gfs2_bufdata *bd)\n{\n\tstruct gfs2_trans *tr = current->journal_info;\n\n\tBUG_ON(!list_empty(&bd->bd_list));\n\tgfs2_add_revoke(sdp, bd);\n\ttr->tr_touched = 1;\n\ttr->tr_num_revoke++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_ail_error",
          "args": [
            "gl",
            "bh"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ail_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glops.c",
          "lines": "33-42",
          "snippet": "static void gfs2_ail_error(struct gfs2_glock *gl, const struct buffer_head *bh)\n{\n\tfs_err(gl->gl_sbd, \"AIL buffer %p: blocknr %llu state 0x%08lx mapping %p page state 0x%lx\\n\",\n\t       bh, (unsigned long long)bh->b_blocknr, bh->b_state,\n\t       bh->b_page->mapping, bh->b_page->flags);\n\tfs_err(gl->gl_sbd, \"AIL glock %u:%llu mapping %p\\n\",\n\t       gl->gl_name.ln_type, gl->gl_name.ln_number,\n\t       gfs2_glock2aspace(gl));\n\tgfs2_lm_withdraw(gl->gl_sbd, \"AIL error\\n\");\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"trans.h\"",
            "#include \"util.h\"",
            "#include \"rgrp.h\"",
            "#include \"recovery.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/posix_acl.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"trans.h\"\n#include \"util.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/posix_acl.h>\n#include <linux/bio.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic void gfs2_ail_error(struct gfs2_glock *gl, const struct buffer_head *bh)\n{\n\tfs_err(gl->gl_sbd, \"AIL buffer %p: blocknr %llu state 0x%08lx mapping %p page state 0x%lx\\n\",\n\t       bh, (unsigned long long)bh->b_blocknr, bh->b_state,\n\t       bh->b_page->mapping, bh->b_page->flags);\n\tfs_err(gl->gl_sbd, \"AIL glock %u:%llu mapping %p\\n\",\n\t       gl->gl_name.ln_type, gl->gl_name.ln_number,\n\t       gfs2_glock2aspace(gl));\n\tgfs2_lm_withdraw(gl->gl_sbd, \"AIL error\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe_reverse",
          "args": [
            "bd",
            "tmp",
            "head",
            "bd_ail_gl_list"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sdp->sd_ail_lock"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_log_lock",
          "args": [
            "sdp"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_log_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/log.h",
          "lines": "24-28",
          "snippet": "static inline void gfs2_log_lock(struct gfs2_sbd *sdp)\n__acquires(&sdp->sd_log_lock)\n{\n\tspin_lock(&sdp->sd_log_lock);\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/writeback.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic inline void gfs2_log_lock(struct gfs2_sbd *sdp)\n__acquires(&sdp->sd_log_lock)\n{\n\tspin_lock(&sdp->sd_log_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dir.h\"\n#include \"trans.h\"\n#include \"util.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/posix_acl.h>\n#include <linux/bio.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic void __gfs2_ail_flush(struct gfs2_glock *gl, bool fsync,\n\t\t\t     unsigned int nr_revokes)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct list_head *head = &gl->gl_ail_list;\n\tstruct gfs2_bufdata *bd, *tmp;\n\tstruct buffer_head *bh;\n\tconst unsigned long b_state = (1UL << BH_Dirty)|(1UL << BH_Pinned)|(1UL << BH_Lock);\n\n\tgfs2_log_lock(sdp);\n\tspin_lock(&sdp->sd_ail_lock);\n\tlist_for_each_entry_safe_reverse(bd, tmp, head, bd_ail_gl_list) {\n\t\tif (nr_revokes == 0)\n\t\t\tbreak;\n\t\tbh = bd->bd_bh;\n\t\tif (bh->b_state & b_state) {\n\t\t\tif (fsync)\n\t\t\t\tcontinue;\n\t\t\tgfs2_ail_error(gl, bh);\n\t\t}\n\t\tgfs2_trans_add_revoke(sdp, bd);\n\t\tnr_revokes--;\n\t}\n\tGLOCK_BUG_ON(gl, !fsync && atomic_read(&gl->gl_ail_count));\n\tspin_unlock(&sdp->sd_ail_lock);\n\tgfs2_log_unlock(sdp);\n}"
  },
  {
    "function_name": "gfs2_ail_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glops.c",
    "lines": "33-42",
    "snippet": "static void gfs2_ail_error(struct gfs2_glock *gl, const struct buffer_head *bh)\n{\n\tfs_err(gl->gl_sbd, \"AIL buffer %p: blocknr %llu state 0x%08lx mapping %p page state 0x%lx\\n\",\n\t       bh, (unsigned long long)bh->b_blocknr, bh->b_state,\n\t       bh->b_page->mapping, bh->b_page->flags);\n\tfs_err(gl->gl_sbd, \"AIL glock %u:%llu mapping %p\\n\",\n\t       gl->gl_name.ln_type, gl->gl_name.ln_number,\n\t       gfs2_glock2aspace(gl));\n\tgfs2_lm_withdraw(gl->gl_sbd, \"AIL error\\n\");\n}",
    "includes": [
      "#include \"dir.h\"",
      "#include \"trans.h\"",
      "#include \"util.h\"",
      "#include \"rgrp.h\"",
      "#include \"recovery.h\"",
      "#include \"meta_io.h\"",
      "#include \"log.h\"",
      "#include \"inode.h\"",
      "#include \"glops.h\"",
      "#include \"glock.h\"",
      "#include \"bmap.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <linux/posix_acl.h>",
      "#include <linux/bio.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_lm_withdraw",
          "args": [
            "gl->gl_sbd",
            "\"AIL error\\n\""
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_lm_withdraw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/util.c",
          "lines": "38-79",
          "snippet": "int gfs2_lm_withdraw(struct gfs2_sbd *sdp, const char *fmt, ...)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tconst struct lm_lockops *lm = ls->ls_ops;\n\tva_list args;\n\tstruct va_format vaf;\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW &&\n\t    test_and_set_bit(SDF_SHUTDOWN, &sdp->sd_flags))\n\t\treturn 0;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tfs_err(sdp, \"%pV\", &vaf);\n\n\tva_end(args);\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW) {\n\t\tfs_err(sdp, \"about to withdraw this file system\\n\");\n\t\tBUG_ON(sdp->sd_args.ar_debug);\n\n\t\tkobject_uevent(&sdp->sd_kobj, KOBJ_OFFLINE);\n\n\t\tif (!strcmp(sdp->sd_lockstruct.ls_ops->lm_proto_name, \"lock_dlm\"))\n\t\t\twait_for_completion(&sdp->sd_wdack);\n\n\t\tif (lm->lm_unmount) {\n\t\t\tfs_err(sdp, \"telling LM to unmount\\n\");\n\t\t\tlm->lm_unmount(sdp);\n\t\t}\n\t\tfs_err(sdp, \"withdrawn\\n\");\n\t\tdump_stack();\n\t}\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_PANIC)\n\t\tpanic(\"GFS2: fsid=%s: panic requested\\n\", sdp->sd_fsname);\n\n\treturn -1;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/crc32.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/crc32.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_lm_withdraw(struct gfs2_sbd *sdp, const char *fmt, ...)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tconst struct lm_lockops *lm = ls->ls_ops;\n\tva_list args;\n\tstruct va_format vaf;\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW &&\n\t    test_and_set_bit(SDF_SHUTDOWN, &sdp->sd_flags))\n\t\treturn 0;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tfs_err(sdp, \"%pV\", &vaf);\n\n\tva_end(args);\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW) {\n\t\tfs_err(sdp, \"about to withdraw this file system\\n\");\n\t\tBUG_ON(sdp->sd_args.ar_debug);\n\n\t\tkobject_uevent(&sdp->sd_kobj, KOBJ_OFFLINE);\n\n\t\tif (!strcmp(sdp->sd_lockstruct.ls_ops->lm_proto_name, \"lock_dlm\"))\n\t\t\twait_for_completion(&sdp->sd_wdack);\n\n\t\tif (lm->lm_unmount) {\n\t\t\tfs_err(sdp, \"telling LM to unmount\\n\");\n\t\t\tlm->lm_unmount(sdp);\n\t\t}\n\t\tfs_err(sdp, \"withdrawn\\n\");\n\t\tdump_stack();\n\t}\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_PANIC)\n\t\tpanic(\"GFS2: fsid=%s: panic requested\\n\", sdp->sd_fsname);\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_err",
          "args": [
            "gl->gl_sbd",
            "\"AIL glock %u:%llu mapping %p\\n\"",
            "gl->gl_name.ln_type",
            "gl->gl_name.ln_number",
            "gfs2_glock2aspace(gl)"
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_vfs_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_debug.c",
          "lines": "43-56",
          "snippet": "void cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nvoid cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock2aspace",
          "args": [
            "gl"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock2aspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.h",
          "lines": "174-179",
          "snippet": "static inline struct address_space *gfs2_glock2aspace(struct gfs2_glock *gl)\n{\n\tif (gl->gl_ops->go_flags & GLOF_ASPACE)\n\t\treturn (struct address_space *)(gl + 1);\n\treturn NULL;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/parser.h>\n#include <linux/sched.h>\n\nstatic inline struct address_space *gfs2_glock2aspace(struct gfs2_glock *gl)\n{\n\tif (gl->gl_ops->go_flags & GLOF_ASPACE)\n\t\treturn (struct address_space *)(gl + 1);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dir.h\"\n#include \"trans.h\"\n#include \"util.h\"\n#include \"rgrp.h\"\n#include \"recovery.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/posix_acl.h>\n#include <linux/bio.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nstatic void gfs2_ail_error(struct gfs2_glock *gl, const struct buffer_head *bh)\n{\n\tfs_err(gl->gl_sbd, \"AIL buffer %p: blocknr %llu state 0x%08lx mapping %p page state 0x%lx\\n\",\n\t       bh, (unsigned long long)bh->b_blocknr, bh->b_state,\n\t       bh->b_page->mapping, bh->b_page->flags);\n\tfs_err(gl->gl_sbd, \"AIL glock %u:%llu mapping %p\\n\",\n\t       gl->gl_name.ln_type, gl->gl_name.ln_number,\n\t       gfs2_glock2aspace(gl));\n\tgfs2_lm_withdraw(gl->gl_sbd, \"AIL error\\n\");\n}"
  }
]