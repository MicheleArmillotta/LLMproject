[
  {
    "function_name": "init_pipe_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
    "lines": "1114-1126",
    "snippet": "static int __init init_pipe_fs(void)\n{\n\tint err = register_filesystem(&pipe_fs_type);\n\n\tif (!err) {\n\t\tpipe_mnt = kern_mount(&pipe_fs_type);\n\t\tif (IS_ERR(pipe_mnt)) {\n\t\t\terr = PTR_ERR(pipe_mnt);\n\t\t\tunregister_filesystem(&pipe_fs_type);\n\t\t}\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type pipe_fs_type = {\n\t.name\t\t= \"pipefs\",\n\t.mount\t\t= pipefs_mount,\n\t.kill_sb\t= kill_anon_super,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&pipe_fs_type"
          ],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "pipe_mnt"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "pipe_mnt"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_mount",
          "args": [
            "&pipe_fs_type"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic struct file_system_type pipe_fs_type = {\n\t.name\t\t= \"pipefs\",\n\t.mount\t\t= pipefs_mount,\n\t.kill_sb\t= kill_anon_super,\n};\n\nstatic int __init init_pipe_fs(void)\n{\n\tint err = register_filesystem(&pipe_fs_type);\n\n\tif (!err) {\n\t\tpipe_mnt = kern_mount(&pipe_fs_type);\n\t\tif (IS_ERR(pipe_mnt)) {\n\t\t\terr = PTR_ERR(pipe_mnt);\n\t\t\tunregister_filesystem(&pipe_fs_type);\n\t\t}\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "pipefs_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
    "lines": "1101-1106",
    "snippet": "static struct dentry *pipefs_mount(struct file_system_type *fs_type,\n\t\t\t int flags, const char *dev_name, void *data)\n{\n\treturn mount_pseudo(fs_type, \"pipe:\", &pipefs_ops,\n\t\t\t&pipefs_dentry_operations, PIPEFS_MAGIC);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct dentry_operations pipefs_dentry_operations = {\n\t.d_dname\t= pipefs_dname,\n};",
      "static const struct super_operations pipefs_ops = {\n\t.destroy_inode = free_inode_nonrcu,\n\t.statfs = simple_statfs,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_pseudo",
          "args": [
            "fs_type",
            "\"pipe:\"",
            "&pipefs_ops",
            "&pipefs_dentry_operations",
            "PIPEFS_MAGIC"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "mount_pseudo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "216-260",
          "snippet": "struct dentry *mount_pseudo(struct file_system_type *fs_type, char *name,\n\tconst struct super_operations *ops,\n\tconst struct dentry_operations *dops, unsigned long magic)\n{\n\tstruct super_block *s;\n\tstruct dentry *dentry;\n\tstruct inode *root;\n\tstruct qstr d_name = QSTR_INIT(name, strlen(name));\n\n\ts = sget(fs_type, NULL, set_anon_super, MS_NOUSER, NULL);\n\tif (IS_ERR(s))\n\t\treturn ERR_CAST(s);\n\n\ts->s_maxbytes = MAX_LFS_FILESIZE;\n\ts->s_blocksize = PAGE_SIZE;\n\ts->s_blocksize_bits = PAGE_SHIFT;\n\ts->s_magic = magic;\n\ts->s_op = ops ? ops : &simple_super_operations;\n\ts->s_time_gran = 1;\n\troot = new_inode(s);\n\tif (!root)\n\t\tgoto Enomem;\n\t/*\n\t * since this is the first inode, make it number 1. New inodes created\n\t * after this must take care not to collide with it (by passing\n\t * max_reserved of 1 to iunique).\n\t */\n\troot->i_ino = 1;\n\troot->i_mode = S_IFDIR | S_IRUSR | S_IWUSR;\n\troot->i_atime = root->i_mtime = root->i_ctime = CURRENT_TIME;\n\tdentry = __d_alloc(s, &d_name);\n\tif (!dentry) {\n\t\tiput(root);\n\t\tgoto Enomem;\n\t}\n\td_instantiate(dentry, root);\n\ts->s_root = dentry;\n\ts->s_d_op = dops;\n\ts->s_flags |= MS_ACTIVE;\n\treturn dget(s->s_root);\n\nEnomem:\n\tdeactivate_locked_super(s);\n\treturn ERR_PTR(-ENOMEM);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct super_operations simple_super_operations = {\n\t.statfs\t\t= simple_statfs,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic const struct super_operations simple_super_operations = {\n\t.statfs\t\t= simple_statfs,\n};\n\nstruct dentry *mount_pseudo(struct file_system_type *fs_type, char *name,\n\tconst struct super_operations *ops,\n\tconst struct dentry_operations *dops, unsigned long magic)\n{\n\tstruct super_block *s;\n\tstruct dentry *dentry;\n\tstruct inode *root;\n\tstruct qstr d_name = QSTR_INIT(name, strlen(name));\n\n\ts = sget(fs_type, NULL, set_anon_super, MS_NOUSER, NULL);\n\tif (IS_ERR(s))\n\t\treturn ERR_CAST(s);\n\n\ts->s_maxbytes = MAX_LFS_FILESIZE;\n\ts->s_blocksize = PAGE_SIZE;\n\ts->s_blocksize_bits = PAGE_SHIFT;\n\ts->s_magic = magic;\n\ts->s_op = ops ? ops : &simple_super_operations;\n\ts->s_time_gran = 1;\n\troot = new_inode(s);\n\tif (!root)\n\t\tgoto Enomem;\n\t/*\n\t * since this is the first inode, make it number 1. New inodes created\n\t * after this must take care not to collide with it (by passing\n\t * max_reserved of 1 to iunique).\n\t */\n\troot->i_ino = 1;\n\troot->i_mode = S_IFDIR | S_IRUSR | S_IWUSR;\n\troot->i_atime = root->i_mtime = root->i_ctime = CURRENT_TIME;\n\tdentry = __d_alloc(s, &d_name);\n\tif (!dentry) {\n\t\tiput(root);\n\t\tgoto Enomem;\n\t}\n\td_instantiate(dentry, root);\n\ts->s_root = dentry;\n\ts->s_d_op = dops;\n\ts->s_flags |= MS_ACTIVE;\n\treturn dget(s->s_root);\n\nEnomem:\n\tdeactivate_locked_super(s);\n\treturn ERR_PTR(-ENOMEM);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic const struct dentry_operations pipefs_dentry_operations = {\n\t.d_dname\t= pipefs_dname,\n};\nstatic const struct super_operations pipefs_ops = {\n\t.destroy_inode = free_inode_nonrcu,\n\t.statfs = simple_statfs,\n};\n\nstatic struct dentry *pipefs_mount(struct file_system_type *fs_type,\n\t\t\t int flags, const char *dev_name, void *data)\n{\n\treturn mount_pseudo(fs_type, \"pipe:\", &pipefs_ops,\n\t\t\t&pipefs_dentry_operations, PIPEFS_MAGIC);\n}"
  },
  {
    "function_name": "pipe_fcntl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
    "lines": "1048-1088",
    "snippet": "long pipe_fcntl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct pipe_inode_info *pipe;\n\tlong ret;\n\n\tpipe = get_pipe_info(file);\n\tif (!pipe)\n\t\treturn -EBADF;\n\n\t__pipe_lock(pipe);\n\n\tswitch (cmd) {\n\tcase F_SETPIPE_SZ: {\n\t\tunsigned int size, nr_pages;\n\n\t\tsize = round_pipe_size(arg);\n\t\tnr_pages = size >> PAGE_SHIFT;\n\n\t\tret = -EINVAL;\n\t\tif (!nr_pages)\n\t\t\tgoto out;\n\n\t\tif (!capable(CAP_SYS_RESOURCE) && size > pipe_max_size) {\n\t\t\tret = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = pipe_set_size(pipe, nr_pages);\n\t\tbreak;\n\t\t}\n\tcase F_GETPIPE_SZ:\n\t\tret = pipe->buffers * PAGE_SIZE;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\nout:\n\t__pipe_unlock(pipe);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int pipe_max_size = 1048576;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__pipe_unlock",
          "args": [
            "pipe"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "84-87",
          "snippet": "static inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe_set_size",
          "args": [
            "pipe",
            "nr_pages"
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "pipe_set_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "964-1007",
          "snippet": "static long pipe_set_size(struct pipe_inode_info *pipe, unsigned long nr_pages)\n{\n\tstruct pipe_buffer *bufs;\n\n\t/*\n\t * We can shrink the pipe, if arg >= pipe->nrbufs. Since we don't\n\t * expect a lot of shrink+grow operations, just free and allocate\n\t * again like we would do for growing. If the pipe currently\n\t * contains more buffers than arg, then return busy.\n\t */\n\tif (nr_pages < pipe->nrbufs)\n\t\treturn -EBUSY;\n\n\tbufs = kcalloc(nr_pages, sizeof(*bufs), GFP_KERNEL | __GFP_NOWARN);\n\tif (unlikely(!bufs))\n\t\treturn -ENOMEM;\n\n\t/*\n\t * The pipe array wraps around, so just start the new one at zero\n\t * and adjust the indexes.\n\t */\n\tif (pipe->nrbufs) {\n\t\tunsigned int tail;\n\t\tunsigned int head;\n\n\t\ttail = pipe->curbuf + pipe->nrbufs;\n\t\tif (tail < pipe->buffers)\n\t\t\ttail = 0;\n\t\telse\n\t\t\ttail &= (pipe->buffers - 1);\n\n\t\thead = pipe->nrbufs - tail;\n\t\tif (head)\n\t\t\tmemcpy(bufs, pipe->bufs + pipe->curbuf, head * sizeof(struct pipe_buffer));\n\t\tif (tail)\n\t\t\tmemcpy(bufs + head, pipe->bufs, tail * sizeof(struct pipe_buffer));\n\t}\n\n\tpipe->curbuf = 0;\n\tkfree(pipe->bufs);\n\tpipe->bufs = bufs;\n\tpipe->buffers = nr_pages;\n\treturn nr_pages * PAGE_SIZE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic long pipe_set_size(struct pipe_inode_info *pipe, unsigned long nr_pages)\n{\n\tstruct pipe_buffer *bufs;\n\n\t/*\n\t * We can shrink the pipe, if arg >= pipe->nrbufs. Since we don't\n\t * expect a lot of shrink+grow operations, just free and allocate\n\t * again like we would do for growing. If the pipe currently\n\t * contains more buffers than arg, then return busy.\n\t */\n\tif (nr_pages < pipe->nrbufs)\n\t\treturn -EBUSY;\n\n\tbufs = kcalloc(nr_pages, sizeof(*bufs), GFP_KERNEL | __GFP_NOWARN);\n\tif (unlikely(!bufs))\n\t\treturn -ENOMEM;\n\n\t/*\n\t * The pipe array wraps around, so just start the new one at zero\n\t * and adjust the indexes.\n\t */\n\tif (pipe->nrbufs) {\n\t\tunsigned int tail;\n\t\tunsigned int head;\n\n\t\ttail = pipe->curbuf + pipe->nrbufs;\n\t\tif (tail < pipe->buffers)\n\t\t\ttail = 0;\n\t\telse\n\t\t\ttail &= (pipe->buffers - 1);\n\n\t\thead = pipe->nrbufs - tail;\n\t\tif (head)\n\t\t\tmemcpy(bufs, pipe->bufs + pipe->curbuf, head * sizeof(struct pipe_buffer));\n\t\tif (tail)\n\t\t\tmemcpy(bufs + head, pipe->bufs, tail * sizeof(struct pipe_buffer));\n\t}\n\n\tpipe->curbuf = 0;\n\tkfree(pipe->bufs);\n\tpipe->bufs = bufs;\n\tpipe->buffers = nr_pages;\n\treturn nr_pages * PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_RESOURCE"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "round_pipe_size",
          "args": [
            "arg"
          ],
          "line": 1063
        },
        "resolved": true,
        "details": {
          "function_name": "round_pipe_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "1013-1019",
          "snippet": "static inline unsigned int round_pipe_size(unsigned int size)\n{\n\tunsigned long nr_pages;\n\n\tnr_pages = (size + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\treturn roundup_pow_of_two(nr_pages) << PAGE_SHIFT;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline unsigned int round_pipe_size(unsigned int size)\n{\n\tunsigned long nr_pages;\n\n\tnr_pages = (size + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\treturn roundup_pow_of_two(nr_pages) << PAGE_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pipe_lock",
          "args": [
            "pipe"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "79-82",
          "snippet": "static inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pipe_info",
          "args": [
            "file"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "get_pipe_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "1043-1046",
          "snippet": "struct pipe_inode_info *get_pipe_info(struct file *file)\n{\n\treturn file->f_op == &pipefifo_fops ? file->private_data : NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations pipefifo_fops = {\n\t.open\t\t= fifo_open,\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= pipe_read,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= pipe_write,\n\t.poll\t\t= pipe_poll,\n\t.unlocked_ioctl\t= pipe_ioctl,\n\t.release\t= pipe_release,\n\t.fasync\t\t= pipe_fasync,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nconst struct file_operations pipefifo_fops = {\n\t.open\t\t= fifo_open,\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= pipe_read,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= pipe_write,\n\t.poll\t\t= pipe_poll,\n\t.unlocked_ioctl\t= pipe_ioctl,\n\t.release\t= pipe_release,\n\t.fasync\t\t= pipe_fasync,\n};\n\nstruct pipe_inode_info *get_pipe_info(struct file *file)\n{\n\treturn file->f_op == &pipefifo_fops ? file->private_data : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nunsigned int pipe_max_size = 1048576;\n\nlong pipe_fcntl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct pipe_inode_info *pipe;\n\tlong ret;\n\n\tpipe = get_pipe_info(file);\n\tif (!pipe)\n\t\treturn -EBADF;\n\n\t__pipe_lock(pipe);\n\n\tswitch (cmd) {\n\tcase F_SETPIPE_SZ: {\n\t\tunsigned int size, nr_pages;\n\n\t\tsize = round_pipe_size(arg);\n\t\tnr_pages = size >> PAGE_SHIFT;\n\n\t\tret = -EINVAL;\n\t\tif (!nr_pages)\n\t\t\tgoto out;\n\n\t\tif (!capable(CAP_SYS_RESOURCE) && size > pipe_max_size) {\n\t\t\tret = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = pipe_set_size(pipe, nr_pages);\n\t\tbreak;\n\t\t}\n\tcase F_GETPIPE_SZ:\n\t\tret = pipe->buffers * PAGE_SIZE;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\nout:\n\t__pipe_unlock(pipe);\n\treturn ret;\n}"
  },
  {
    "function_name": "get_pipe_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
    "lines": "1043-1046",
    "snippet": "struct pipe_inode_info *get_pipe_info(struct file *file)\n{\n\treturn file->f_op == &pipefifo_fops ? file->private_data : NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct file_operations pipefifo_fops = {\n\t.open\t\t= fifo_open,\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= pipe_read,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= pipe_write,\n\t.poll\t\t= pipe_poll,\n\t.unlocked_ioctl\t= pipe_ioctl,\n\t.release\t= pipe_release,\n\t.fasync\t\t= pipe_fasync,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nconst struct file_operations pipefifo_fops = {\n\t.open\t\t= fifo_open,\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= pipe_read,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= pipe_write,\n\t.poll\t\t= pipe_poll,\n\t.unlocked_ioctl\t= pipe_ioctl,\n\t.release\t= pipe_release,\n\t.fasync\t\t= pipe_fasync,\n};\n\nstruct pipe_inode_info *get_pipe_info(struct file *file)\n{\n\treturn file->f_op == &pipefifo_fops ? file->private_data : NULL;\n}"
  },
  {
    "function_name": "pipe_proc_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
    "lines": "1025-1036",
    "snippet": "int pipe_proc_fn(struct ctl_table *table, int write, void __user *buf,\n\t\t size_t *lenp, loff_t *ppos)\n{\n\tint ret;\n\n\tret = proc_dointvec_minmax(table, write, buf, lenp, ppos);\n\tif (ret < 0 || !write)\n\t\treturn ret;\n\n\tpipe_max_size = round_pipe_size(pipe_max_size);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int pipe_max_size = 1048576;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "round_pipe_size",
          "args": [
            "pipe_max_size"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "round_pipe_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "1013-1019",
          "snippet": "static inline unsigned int round_pipe_size(unsigned int size)\n{\n\tunsigned long nr_pages;\n\n\tnr_pages = (size + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\treturn roundup_pow_of_two(nr_pages) << PAGE_SHIFT;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline unsigned int round_pipe_size(unsigned int size)\n{\n\tunsigned long nr_pages;\n\n\tnr_pages = (size + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\treturn roundup_pow_of_two(nr_pages) << PAGE_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_dointvec_minmax",
          "args": [
            "table",
            "write",
            "buf",
            "lenp",
            "ppos"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nunsigned int pipe_max_size = 1048576;\n\nint pipe_proc_fn(struct ctl_table *table, int write, void __user *buf,\n\t\t size_t *lenp, loff_t *ppos)\n{\n\tint ret;\n\n\tret = proc_dointvec_minmax(table, write, buf, lenp, ppos);\n\tif (ret < 0 || !write)\n\t\treturn ret;\n\n\tpipe_max_size = round_pipe_size(pipe_max_size);\n\treturn ret;\n}"
  },
  {
    "function_name": "round_pipe_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
    "lines": "1013-1019",
    "snippet": "static inline unsigned int round_pipe_size(unsigned int size)\n{\n\tunsigned long nr_pages;\n\n\tnr_pages = (size + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\treturn roundup_pow_of_two(nr_pages) << PAGE_SHIFT;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "roundup_pow_of_two",
          "args": [
            "nr_pages"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline unsigned int round_pipe_size(unsigned int size)\n{\n\tunsigned long nr_pages;\n\n\tnr_pages = (size + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\treturn roundup_pow_of_two(nr_pages) << PAGE_SHIFT;\n}"
  },
  {
    "function_name": "pipe_set_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
    "lines": "964-1007",
    "snippet": "static long pipe_set_size(struct pipe_inode_info *pipe, unsigned long nr_pages)\n{\n\tstruct pipe_buffer *bufs;\n\n\t/*\n\t * We can shrink the pipe, if arg >= pipe->nrbufs. Since we don't\n\t * expect a lot of shrink+grow operations, just free and allocate\n\t * again like we would do for growing. If the pipe currently\n\t * contains more buffers than arg, then return busy.\n\t */\n\tif (nr_pages < pipe->nrbufs)\n\t\treturn -EBUSY;\n\n\tbufs = kcalloc(nr_pages, sizeof(*bufs), GFP_KERNEL | __GFP_NOWARN);\n\tif (unlikely(!bufs))\n\t\treturn -ENOMEM;\n\n\t/*\n\t * The pipe array wraps around, so just start the new one at zero\n\t * and adjust the indexes.\n\t */\n\tif (pipe->nrbufs) {\n\t\tunsigned int tail;\n\t\tunsigned int head;\n\n\t\ttail = pipe->curbuf + pipe->nrbufs;\n\t\tif (tail < pipe->buffers)\n\t\t\ttail = 0;\n\t\telse\n\t\t\ttail &= (pipe->buffers - 1);\n\n\t\thead = pipe->nrbufs - tail;\n\t\tif (head)\n\t\t\tmemcpy(bufs, pipe->bufs + pipe->curbuf, head * sizeof(struct pipe_buffer));\n\t\tif (tail)\n\t\t\tmemcpy(bufs + head, pipe->bufs, tail * sizeof(struct pipe_buffer));\n\t}\n\n\tpipe->curbuf = 0;\n\tkfree(pipe->bufs);\n\tpipe->bufs = bufs;\n\tpipe->buffers = nr_pages;\n\treturn nr_pages * PAGE_SIZE;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pipe->bufs"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bufs + head",
            "pipe->bufs",
            "tail * sizeof(struct pipe_buffer)"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bufs",
            "pipe->bufs + pipe->curbuf",
            "head * sizeof(struct pipe_buffer)"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!bufs"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "nr_pages",
            "sizeof(*bufs)",
            "GFP_KERNEL | __GFP_NOWARN"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic long pipe_set_size(struct pipe_inode_info *pipe, unsigned long nr_pages)\n{\n\tstruct pipe_buffer *bufs;\n\n\t/*\n\t * We can shrink the pipe, if arg >= pipe->nrbufs. Since we don't\n\t * expect a lot of shrink+grow operations, just free and allocate\n\t * again like we would do for growing. If the pipe currently\n\t * contains more buffers than arg, then return busy.\n\t */\n\tif (nr_pages < pipe->nrbufs)\n\t\treturn -EBUSY;\n\n\tbufs = kcalloc(nr_pages, sizeof(*bufs), GFP_KERNEL | __GFP_NOWARN);\n\tif (unlikely(!bufs))\n\t\treturn -ENOMEM;\n\n\t/*\n\t * The pipe array wraps around, so just start the new one at zero\n\t * and adjust the indexes.\n\t */\n\tif (pipe->nrbufs) {\n\t\tunsigned int tail;\n\t\tunsigned int head;\n\n\t\ttail = pipe->curbuf + pipe->nrbufs;\n\t\tif (tail < pipe->buffers)\n\t\t\ttail = 0;\n\t\telse\n\t\t\ttail &= (pipe->buffers - 1);\n\n\t\thead = pipe->nrbufs - tail;\n\t\tif (head)\n\t\t\tmemcpy(bufs, pipe->bufs + pipe->curbuf, head * sizeof(struct pipe_buffer));\n\t\tif (tail)\n\t\t\tmemcpy(bufs + head, pipe->bufs, tail * sizeof(struct pipe_buffer));\n\t}\n\n\tpipe->curbuf = 0;\n\tkfree(pipe->bufs);\n\tpipe->bufs = bufs;\n\tpipe->buffers = nr_pages;\n\treturn nr_pages * PAGE_SIZE;\n}"
  },
  {
    "function_name": "fifo_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
    "lines": "822-945",
    "snippet": "static int fifo_open(struct inode *inode, struct file *filp)\n{\n\tstruct pipe_inode_info *pipe;\n\tbool is_pipe = inode->i_sb->s_magic == PIPEFS_MAGIC;\n\tint ret;\n\n\tfilp->f_version = 0;\n\n\tspin_lock(&inode->i_lock);\n\tif (inode->i_pipe) {\n\t\tpipe = inode->i_pipe;\n\t\tpipe->files++;\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\tpipe = alloc_pipe_info();\n\t\tif (!pipe)\n\t\t\treturn -ENOMEM;\n\t\tpipe->files = 1;\n\t\tspin_lock(&inode->i_lock);\n\t\tif (unlikely(inode->i_pipe)) {\n\t\t\tinode->i_pipe->files++;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tfree_pipe_info(pipe);\n\t\t\tpipe = inode->i_pipe;\n\t\t} else {\n\t\t\tinode->i_pipe = pipe;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t}\n\t}\n\tfilp->private_data = pipe;\n\t/* OK, we have a pipe and it's pinned down */\n\n\t__pipe_lock(pipe);\n\n\t/* We can only do regular read/write on fifos */\n\tfilp->f_mode &= (FMODE_READ | FMODE_WRITE);\n\n\tswitch (filp->f_mode) {\n\tcase FMODE_READ:\n\t/*\n\t *  O_RDONLY\n\t *  POSIX.1 says that O_NONBLOCK means return with the FIFO\n\t *  opened, even when there is no process writing the FIFO.\n\t */\n\t\tpipe->r_counter++;\n\t\tif (pipe->readers++ == 0)\n\t\t\twake_up_partner(pipe);\n\n\t\tif (!is_pipe && !pipe->writers) {\n\t\t\tif ((filp->f_flags & O_NONBLOCK)) {\n\t\t\t\t/* suppress POLLHUP until we have\n\t\t\t\t * seen a writer */\n\t\t\t\tfilp->f_version = pipe->w_counter;\n\t\t\t} else {\n\t\t\t\tif (wait_for_partner(pipe, &pipe->w_counter))\n\t\t\t\t\tgoto err_rd;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\n\tcase FMODE_WRITE:\n\t/*\n\t *  O_WRONLY\n\t *  POSIX.1 says that O_NONBLOCK means return -1 with\n\t *  errno=ENXIO when there is no process reading the FIFO.\n\t */\n\t\tret = -ENXIO;\n\t\tif (!is_pipe && (filp->f_flags & O_NONBLOCK) && !pipe->readers)\n\t\t\tgoto err;\n\n\t\tpipe->w_counter++;\n\t\tif (!pipe->writers++)\n\t\t\twake_up_partner(pipe);\n\n\t\tif (!is_pipe && !pipe->readers) {\n\t\t\tif (wait_for_partner(pipe, &pipe->r_counter))\n\t\t\t\tgoto err_wr;\n\t\t}\n\t\tbreak;\n\t\n\tcase FMODE_READ | FMODE_WRITE:\n\t/*\n\t *  O_RDWR\n\t *  POSIX.1 leaves this case \"undefined\" when O_NONBLOCK is set.\n\t *  This implementation will NEVER block on a O_RDWR open, since\n\t *  the process can at least talk to itself.\n\t */\n\n\t\tpipe->readers++;\n\t\tpipe->writers++;\n\t\tpipe->r_counter++;\n\t\tpipe->w_counter++;\n\t\tif (pipe->readers == 1 || pipe->writers == 1)\n\t\t\twake_up_partner(pipe);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t/* Ok! */\n\t__pipe_unlock(pipe);\n\treturn 0;\n\nerr_rd:\n\tif (!--pipe->readers)\n\t\twake_up_interruptible(&pipe->wait);\n\tret = -ERESTARTSYS;\n\tgoto err;\n\nerr_wr:\n\tif (!--pipe->writers)\n\t\twake_up_interruptible(&pipe->wait);\n\tret = -ERESTARTSYS;\n\tgoto err;\n\nerr:\n\t__pipe_unlock(pipe);\n\n\tput_pipe_info(inode, pipe);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_pipe_info",
          "args": [
            "inode",
            "pipe"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "put_pipe_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "532-545",
          "snippet": "static void put_pipe_info(struct inode *inode, struct pipe_inode_info *pipe)\n{\n\tint kill = 0;\n\n\tspin_lock(&inode->i_lock);\n\tif (!--pipe->files) {\n\t\tinode->i_pipe = NULL;\n\t\tkill = 1;\n\t}\n\tspin_unlock(&inode->i_lock);\n\n\tif (kill)\n\t\tfree_pipe_info(pipe);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic void put_pipe_info(struct inode *inode, struct pipe_inode_info *pipe)\n{\n\tint kill = 0;\n\n\tspin_lock(&inode->i_lock);\n\tif (!--pipe->files) {\n\t\tinode->i_pipe = NULL;\n\t\tkill = 1;\n\t}\n\tspin_unlock(&inode->i_lock);\n\n\tif (kill)\n\t\tfree_pipe_info(pipe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pipe_unlock",
          "args": [
            "pipe"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "84-87",
          "snippet": "static inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_interruptible",
          "args": [
            "&pipe->wait"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_interruptible",
          "args": [
            "&pipe->wait"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_partner",
          "args": [
            "pipe"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_partner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "817-820",
          "snippet": "static void wake_up_partner(struct pipe_inode_info *pipe)\n{\n\twake_up_interruptible(&pipe->wait);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic void wake_up_partner(struct pipe_inode_info *pipe)\n{\n\twake_up_interruptible(&pipe->wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_partner",
          "args": [
            "pipe",
            "&pipe->r_counter"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "wait_for_partner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "805-815",
          "snippet": "static int wait_for_partner(struct pipe_inode_info *pipe, unsigned int *cnt)\n{\n\tint cur = *cnt;\t\n\n\twhile (cur == *cnt) {\n\t\tpipe_wait(pipe);\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t}\n\treturn cur == *cnt ? -ERESTARTSYS : 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic int wait_for_partner(struct pipe_inode_info *pipe, unsigned int *cnt)\n{\n\tint cur = *cnt;\t\n\n\twhile (cur == *cnt) {\n\t\tpipe_wait(pipe);\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t}\n\treturn cur == *cnt ? -ERESTARTSYS : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pipe_lock",
          "args": [
            "pipe"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "79-82",
          "snippet": "static inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_pipe_info",
          "args": [
            "pipe"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "free_pipe_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "608-621",
          "snippet": "void free_pipe_info(struct pipe_inode_info *pipe)\n{\n\tint i;\n\n\tfor (i = 0; i < pipe->buffers; i++) {\n\t\tstruct pipe_buffer *buf = pipe->bufs + i;\n\t\tif (buf->ops)\n\t\t\tbuf->ops->release(pipe, buf);\n\t}\n\tif (pipe->tmp_page)\n\t\t__free_page(pipe->tmp_page);\n\tkfree(pipe->bufs);\n\tkfree(pipe);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nvoid free_pipe_info(struct pipe_inode_info *pipe)\n{\n\tint i;\n\n\tfor (i = 0; i < pipe->buffers; i++) {\n\t\tstruct pipe_buffer *buf = pipe->bufs + i;\n\t\tif (buf->ops)\n\t\t\tbuf->ops->release(pipe, buf);\n\t}\n\tif (pipe->tmp_page)\n\t\t__free_page(pipe->tmp_page);\n\tkfree(pipe->bufs);\n\tkfree(pipe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "inode->i_pipe"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_pipe_info",
          "args": [],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_pipe_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "588-606",
          "snippet": "struct pipe_inode_info *alloc_pipe_info(void)\n{\n\tstruct pipe_inode_info *pipe;\n\n\tpipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL);\n\tif (pipe) {\n\t\tpipe->bufs = kzalloc(sizeof(struct pipe_buffer) * PIPE_DEF_BUFFERS, GFP_KERNEL);\n\t\tif (pipe->bufs) {\n\t\t\tinit_waitqueue_head(&pipe->wait);\n\t\t\tpipe->r_counter = pipe->w_counter = 1;\n\t\t\tpipe->buffers = PIPE_DEF_BUFFERS;\n\t\t\tmutex_init(&pipe->mutex);\n\t\t\treturn pipe;\n\t\t}\n\t\tkfree(pipe);\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstruct pipe_inode_info *alloc_pipe_info(void)\n{\n\tstruct pipe_inode_info *pipe;\n\n\tpipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL);\n\tif (pipe) {\n\t\tpipe->bufs = kzalloc(sizeof(struct pipe_buffer) * PIPE_DEF_BUFFERS, GFP_KERNEL);\n\t\tif (pipe->bufs) {\n\t\t\tinit_waitqueue_head(&pipe->wait);\n\t\t\tpipe->r_counter = pipe->w_counter = 1;\n\t\t\tpipe->buffers = PIPE_DEF_BUFFERS;\n\t\t\tmutex_init(&pipe->mutex);\n\t\t\treturn pipe;\n\t\t}\n\t\tkfree(pipe);\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic int fifo_open(struct inode *inode, struct file *filp)\n{\n\tstruct pipe_inode_info *pipe;\n\tbool is_pipe = inode->i_sb->s_magic == PIPEFS_MAGIC;\n\tint ret;\n\n\tfilp->f_version = 0;\n\n\tspin_lock(&inode->i_lock);\n\tif (inode->i_pipe) {\n\t\tpipe = inode->i_pipe;\n\t\tpipe->files++;\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\tpipe = alloc_pipe_info();\n\t\tif (!pipe)\n\t\t\treturn -ENOMEM;\n\t\tpipe->files = 1;\n\t\tspin_lock(&inode->i_lock);\n\t\tif (unlikely(inode->i_pipe)) {\n\t\t\tinode->i_pipe->files++;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tfree_pipe_info(pipe);\n\t\t\tpipe = inode->i_pipe;\n\t\t} else {\n\t\t\tinode->i_pipe = pipe;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t}\n\t}\n\tfilp->private_data = pipe;\n\t/* OK, we have a pipe and it's pinned down */\n\n\t__pipe_lock(pipe);\n\n\t/* We can only do regular read/write on fifos */\n\tfilp->f_mode &= (FMODE_READ | FMODE_WRITE);\n\n\tswitch (filp->f_mode) {\n\tcase FMODE_READ:\n\t/*\n\t *  O_RDONLY\n\t *  POSIX.1 says that O_NONBLOCK means return with the FIFO\n\t *  opened, even when there is no process writing the FIFO.\n\t */\n\t\tpipe->r_counter++;\n\t\tif (pipe->readers++ == 0)\n\t\t\twake_up_partner(pipe);\n\n\t\tif (!is_pipe && !pipe->writers) {\n\t\t\tif ((filp->f_flags & O_NONBLOCK)) {\n\t\t\t\t/* suppress POLLHUP until we have\n\t\t\t\t * seen a writer */\n\t\t\t\tfilp->f_version = pipe->w_counter;\n\t\t\t} else {\n\t\t\t\tif (wait_for_partner(pipe, &pipe->w_counter))\n\t\t\t\t\tgoto err_rd;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t\n\tcase FMODE_WRITE:\n\t/*\n\t *  O_WRONLY\n\t *  POSIX.1 says that O_NONBLOCK means return -1 with\n\t *  errno=ENXIO when there is no process reading the FIFO.\n\t */\n\t\tret = -ENXIO;\n\t\tif (!is_pipe && (filp->f_flags & O_NONBLOCK) && !pipe->readers)\n\t\t\tgoto err;\n\n\t\tpipe->w_counter++;\n\t\tif (!pipe->writers++)\n\t\t\twake_up_partner(pipe);\n\n\t\tif (!is_pipe && !pipe->readers) {\n\t\t\tif (wait_for_partner(pipe, &pipe->r_counter))\n\t\t\t\tgoto err_wr;\n\t\t}\n\t\tbreak;\n\t\n\tcase FMODE_READ | FMODE_WRITE:\n\t/*\n\t *  O_RDWR\n\t *  POSIX.1 leaves this case \"undefined\" when O_NONBLOCK is set.\n\t *  This implementation will NEVER block on a O_RDWR open, since\n\t *  the process can at least talk to itself.\n\t */\n\n\t\tpipe->readers++;\n\t\tpipe->writers++;\n\t\tpipe->r_counter++;\n\t\tpipe->w_counter++;\n\t\tif (pipe->readers == 1 || pipe->writers == 1)\n\t\t\twake_up_partner(pipe);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t/* Ok! */\n\t__pipe_unlock(pipe);\n\treturn 0;\n\nerr_rd:\n\tif (!--pipe->readers)\n\t\twake_up_interruptible(&pipe->wait);\n\tret = -ERESTARTSYS;\n\tgoto err;\n\nerr_wr:\n\tif (!--pipe->writers)\n\t\twake_up_interruptible(&pipe->wait);\n\tret = -ERESTARTSYS;\n\tgoto err;\n\nerr:\n\t__pipe_unlock(pipe);\n\n\tput_pipe_info(inode, pipe);\n\treturn ret;\n}"
  },
  {
    "function_name": "wake_up_partner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
    "lines": "817-820",
    "snippet": "static void wake_up_partner(struct pipe_inode_info *pipe)\n{\n\twake_up_interruptible(&pipe->wait);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_interruptible",
          "args": [
            "&pipe->wait"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic void wake_up_partner(struct pipe_inode_info *pipe)\n{\n\twake_up_interruptible(&pipe->wait);\n}"
  },
  {
    "function_name": "wait_for_partner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
    "lines": "805-815",
    "snippet": "static int wait_for_partner(struct pipe_inode_info *pipe, unsigned int *cnt)\n{\n\tint cur = *cnt;\t\n\n\twhile (cur == *cnt) {\n\t\tpipe_wait(pipe);\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t}\n\treturn cur == *cnt ? -ERESTARTSYS : 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe_wait",
          "args": [
            "pipe"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "pipe_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "104-117",
          "snippet": "void pipe_wait(struct pipe_inode_info *pipe)\n{\n\tDEFINE_WAIT(wait);\n\n\t/*\n\t * Pipes are system-local resources, so sleeping on them\n\t * is considered a noninteractive wait:\n\t */\n\tprepare_to_wait(&pipe->wait, &wait, TASK_INTERRUPTIBLE);\n\tpipe_unlock(pipe);\n\tschedule();\n\tfinish_wait(&pipe->wait, &wait);\n\tpipe_lock(pipe);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nvoid pipe_wait(struct pipe_inode_info *pipe)\n{\n\tDEFINE_WAIT(wait);\n\n\t/*\n\t * Pipes are system-local resources, so sleeping on them\n\t * is considered a noninteractive wait:\n\t */\n\tprepare_to_wait(&pipe->wait, &wait, TASK_INTERRUPTIBLE);\n\tpipe_unlock(pipe);\n\tschedule();\n\tfinish_wait(&pipe->wait, &wait);\n\tpipe_lock(pipe);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic int wait_for_partner(struct pipe_inode_info *pipe, unsigned int *cnt)\n{\n\tint cur = *cnt;\t\n\n\twhile (cur == *cnt) {\n\t\tpipe_wait(pipe);\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t}\n\treturn cur == *cnt ? -ERESTARTSYS : 0;\n}"
  },
  {
    "function_name": "do_pipe_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
    "lines": "763-772",
    "snippet": "int do_pipe_flags(int *fd, int flags)\n{\n\tstruct file *files[2];\n\tint error = __do_pipe_flags(fd, files, flags);\n\tif (!error) {\n\t\tfd_install(fd[0], files[0]);\n\t\tfd_install(fd[1], files[1]);\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fd_install",
          "args": [
            "fd[1]",
            "files[1]"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "fd_install",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "563-566",
          "snippet": "void fd_install(unsigned int fd, struct file *file)\n{\n\t__fd_install(current->files, fd, file);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid fd_install(unsigned int fd, struct file *file)\n{\n\t__fd_install(current->files, fd, file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__do_pipe_flags",
          "args": [
            "fd",
            "files",
            "flags"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "__do_pipe_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "728-761",
          "snippet": "static int __do_pipe_flags(int *fd, struct file **files, int flags)\n{\n\tint error;\n\tint fdw, fdr;\n\n\tif (flags & ~(O_CLOEXEC | O_NONBLOCK | O_DIRECT))\n\t\treturn -EINVAL;\n\n\terror = create_pipe_files(files, flags);\n\tif (error)\n\t\treturn error;\n\n\terror = get_unused_fd_flags(flags);\n\tif (error < 0)\n\t\tgoto err_read_pipe;\n\tfdr = error;\n\n\terror = get_unused_fd_flags(flags);\n\tif (error < 0)\n\t\tgoto err_fdr;\n\tfdw = error;\n\n\taudit_fd_pair(fdr, fdw);\n\tfd[0] = fdr;\n\tfd[1] = fdw;\n\treturn 0;\n\n err_fdr:\n\tput_unused_fd(fdr);\n err_read_pipe:\n\tfput(files[0]);\n\tfput(files[1]);\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic int __do_pipe_flags(int *fd, struct file **files, int flags)\n{\n\tint error;\n\tint fdw, fdr;\n\n\tif (flags & ~(O_CLOEXEC | O_NONBLOCK | O_DIRECT))\n\t\treturn -EINVAL;\n\n\terror = create_pipe_files(files, flags);\n\tif (error)\n\t\treturn error;\n\n\terror = get_unused_fd_flags(flags);\n\tif (error < 0)\n\t\tgoto err_read_pipe;\n\tfdr = error;\n\n\terror = get_unused_fd_flags(flags);\n\tif (error < 0)\n\t\tgoto err_fdr;\n\tfdw = error;\n\n\taudit_fd_pair(fdr, fdw);\n\tfd[0] = fdr;\n\tfd[1] = fdw;\n\treturn 0;\n\n err_fdr:\n\tput_unused_fd(fdr);\n err_read_pipe:\n\tfput(files[0]);\n\tfput(files[1]);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nint do_pipe_flags(int *fd, int flags)\n{\n\tstruct file *files[2];\n\tint error = __do_pipe_flags(fd, files, flags);\n\tif (!error) {\n\t\tfd_install(fd[0], files[0]);\n\t\tfd_install(fd[1], files[1]);\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "__do_pipe_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
    "lines": "728-761",
    "snippet": "static int __do_pipe_flags(int *fd, struct file **files, int flags)\n{\n\tint error;\n\tint fdw, fdr;\n\n\tif (flags & ~(O_CLOEXEC | O_NONBLOCK | O_DIRECT))\n\t\treturn -EINVAL;\n\n\terror = create_pipe_files(files, flags);\n\tif (error)\n\t\treturn error;\n\n\terror = get_unused_fd_flags(flags);\n\tif (error < 0)\n\t\tgoto err_read_pipe;\n\tfdr = error;\n\n\terror = get_unused_fd_flags(flags);\n\tif (error < 0)\n\t\tgoto err_fdr;\n\tfdw = error;\n\n\taudit_fd_pair(fdr, fdw);\n\tfd[0] = fdr;\n\tfd[1] = fdw;\n\treturn 0;\n\n err_fdr:\n\tput_unused_fd(fdr);\n err_read_pipe:\n\tfput(files[0]);\n\tfput(files[1]);\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "files[1]"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "293-300",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_unused_fd",
          "args": [
            "fdr"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "put_unused_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "522-528",
          "snippet": "void put_unused_fd(unsigned int fd)\n{\n\tstruct files_struct *files = current->files;\n\tspin_lock(&files->file_lock);\n\t__put_unused_fd(files, fd);\n\tspin_unlock(&files->file_lock);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid put_unused_fd(unsigned int fd)\n{\n\tstruct files_struct *files = current->files;\n\tspin_lock(&files->file_lock);\n\t__put_unused_fd(files, fd);\n\tspin_unlock(&files->file_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_fd_pair",
          "args": [
            "fdr",
            "fdw"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_unused_fd_flags",
          "args": [
            "flags"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "get_unused_fd_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "508-511",
          "snippet": "int get_unused_fd_flags(unsigned flags)\n{\n\treturn __alloc_fd(current->files, 0, rlimit(RLIMIT_NOFILE), flags);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint get_unused_fd_flags(unsigned flags)\n{\n\treturn __alloc_fd(current->files, 0, rlimit(RLIMIT_NOFILE), flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_pipe_files",
          "args": [
            "files",
            "flags"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "create_pipe_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "678-726",
          "snippet": "int create_pipe_files(struct file **res, int flags)\n{\n\tint err;\n\tstruct inode *inode = get_pipe_inode();\n\tstruct file *f;\n\tstruct path path;\n\tstatic struct qstr name = { .name = \"\" };\n\n\tif (!inode)\n\t\treturn -ENFILE;\n\n\terr = -ENOMEM;\n\tpath.dentry = d_alloc_pseudo(pipe_mnt->mnt_sb, &name);\n\tif (!path.dentry)\n\t\tgoto err_inode;\n\tpath.mnt = mntget(pipe_mnt);\n\n\td_instantiate(path.dentry, inode);\n\n\terr = -ENFILE;\n\tf = alloc_file(&path, FMODE_WRITE, &pipefifo_fops);\n\tif (IS_ERR(f))\n\t\tgoto err_dentry;\n\n\tf->f_flags = O_WRONLY | (flags & (O_NONBLOCK | O_DIRECT));\n\tf->private_data = inode->i_pipe;\n\n\tres[0] = alloc_file(&path, FMODE_READ, &pipefifo_fops);\n\tif (IS_ERR(res[0]))\n\t\tgoto err_file;\n\n\tpath_get(&path);\n\tres[0]->private_data = inode->i_pipe;\n\tres[0]->f_flags = O_RDONLY | (flags & O_NONBLOCK);\n\tres[1] = f;\n\treturn 0;\n\nerr_file:\n\tput_filp(f);\nerr_dentry:\n\tfree_pipe_info(inode->i_pipe);\n\tpath_put(&path);\n\treturn err;\n\nerr_inode:\n\tfree_pipe_info(inode->i_pipe);\n\tiput(inode);\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations pipefifo_fops = {\n\t.open\t\t= fifo_open,\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= pipe_read,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= pipe_write,\n\t.poll\t\t= pipe_poll,\n\t.unlocked_ioctl\t= pipe_ioctl,\n\t.release\t= pipe_release,\n\t.fasync\t\t= pipe_fasync,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nconst struct file_operations pipefifo_fops = {\n\t.open\t\t= fifo_open,\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= pipe_read,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= pipe_write,\n\t.poll\t\t= pipe_poll,\n\t.unlocked_ioctl\t= pipe_ioctl,\n\t.release\t= pipe_release,\n\t.fasync\t\t= pipe_fasync,\n};\n\nint create_pipe_files(struct file **res, int flags)\n{\n\tint err;\n\tstruct inode *inode = get_pipe_inode();\n\tstruct file *f;\n\tstruct path path;\n\tstatic struct qstr name = { .name = \"\" };\n\n\tif (!inode)\n\t\treturn -ENFILE;\n\n\terr = -ENOMEM;\n\tpath.dentry = d_alloc_pseudo(pipe_mnt->mnt_sb, &name);\n\tif (!path.dentry)\n\t\tgoto err_inode;\n\tpath.mnt = mntget(pipe_mnt);\n\n\td_instantiate(path.dentry, inode);\n\n\terr = -ENFILE;\n\tf = alloc_file(&path, FMODE_WRITE, &pipefifo_fops);\n\tif (IS_ERR(f))\n\t\tgoto err_dentry;\n\n\tf->f_flags = O_WRONLY | (flags & (O_NONBLOCK | O_DIRECT));\n\tf->private_data = inode->i_pipe;\n\n\tres[0] = alloc_file(&path, FMODE_READ, &pipefifo_fops);\n\tif (IS_ERR(res[0]))\n\t\tgoto err_file;\n\n\tpath_get(&path);\n\tres[0]->private_data = inode->i_pipe;\n\tres[0]->f_flags = O_RDONLY | (flags & O_NONBLOCK);\n\tres[1] = f;\n\treturn 0;\n\nerr_file:\n\tput_filp(f);\nerr_dentry:\n\tfree_pipe_info(inode->i_pipe);\n\tpath_put(&path);\n\treturn err;\n\nerr_inode:\n\tfree_pipe_info(inode->i_pipe);\n\tiput(inode);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic int __do_pipe_flags(int *fd, struct file **files, int flags)\n{\n\tint error;\n\tint fdw, fdr;\n\n\tif (flags & ~(O_CLOEXEC | O_NONBLOCK | O_DIRECT))\n\t\treturn -EINVAL;\n\n\terror = create_pipe_files(files, flags);\n\tif (error)\n\t\treturn error;\n\n\terror = get_unused_fd_flags(flags);\n\tif (error < 0)\n\t\tgoto err_read_pipe;\n\tfdr = error;\n\n\terror = get_unused_fd_flags(flags);\n\tif (error < 0)\n\t\tgoto err_fdr;\n\tfdw = error;\n\n\taudit_fd_pair(fdr, fdw);\n\tfd[0] = fdr;\n\tfd[1] = fdw;\n\treturn 0;\n\n err_fdr:\n\tput_unused_fd(fdr);\n err_read_pipe:\n\tfput(files[0]);\n\tfput(files[1]);\n\treturn error;\n}"
  },
  {
    "function_name": "create_pipe_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
    "lines": "678-726",
    "snippet": "int create_pipe_files(struct file **res, int flags)\n{\n\tint err;\n\tstruct inode *inode = get_pipe_inode();\n\tstruct file *f;\n\tstruct path path;\n\tstatic struct qstr name = { .name = \"\" };\n\n\tif (!inode)\n\t\treturn -ENFILE;\n\n\terr = -ENOMEM;\n\tpath.dentry = d_alloc_pseudo(pipe_mnt->mnt_sb, &name);\n\tif (!path.dentry)\n\t\tgoto err_inode;\n\tpath.mnt = mntget(pipe_mnt);\n\n\td_instantiate(path.dentry, inode);\n\n\terr = -ENFILE;\n\tf = alloc_file(&path, FMODE_WRITE, &pipefifo_fops);\n\tif (IS_ERR(f))\n\t\tgoto err_dentry;\n\n\tf->f_flags = O_WRONLY | (flags & (O_NONBLOCK | O_DIRECT));\n\tf->private_data = inode->i_pipe;\n\n\tres[0] = alloc_file(&path, FMODE_READ, &pipefifo_fops);\n\tif (IS_ERR(res[0]))\n\t\tgoto err_file;\n\n\tpath_get(&path);\n\tres[0]->private_data = inode->i_pipe;\n\tres[0]->f_flags = O_RDONLY | (flags & O_NONBLOCK);\n\tres[1] = f;\n\treturn 0;\n\nerr_file:\n\tput_filp(f);\nerr_dentry:\n\tfree_pipe_info(inode->i_pipe);\n\tpath_put(&path);\n\treturn err;\n\nerr_inode:\n\tfree_pipe_info(inode->i_pipe);\n\tiput(inode);\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct file_operations pipefifo_fops = {\n\t.open\t\t= fifo_open,\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= pipe_read,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= pipe_write,\n\t.poll\t\t= pipe_poll,\n\t.unlocked_ioctl\t= pipe_ioctl,\n\t.release\t= pipe_release,\n\t.fasync\t\t= pipe_fasync,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_pipe_info",
          "args": [
            "inode->i_pipe"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "free_pipe_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "608-621",
          "snippet": "void free_pipe_info(struct pipe_inode_info *pipe)\n{\n\tint i;\n\n\tfor (i = 0; i < pipe->buffers; i++) {\n\t\tstruct pipe_buffer *buf = pipe->bufs + i;\n\t\tif (buf->ops)\n\t\t\tbuf->ops->release(pipe, buf);\n\t}\n\tif (pipe->tmp_page)\n\t\t__free_page(pipe->tmp_page);\n\tkfree(pipe->bufs);\n\tkfree(pipe);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nvoid free_pipe_info(struct pipe_inode_info *pipe)\n{\n\tint i;\n\n\tfor (i = 0; i < pipe->buffers; i++) {\n\t\tstruct pipe_buffer *buf = pipe->bufs + i;\n\t\tif (buf->ops)\n\t\t\tbuf->ops->release(pipe, buf);\n\t}\n\tif (pipe->tmp_page)\n\t\t__free_page(pipe->tmp_page);\n\tkfree(pipe->bufs);\n\tkfree(pipe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "489-493",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_filp",
          "args": [
            "f"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "put_filp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "304-310",
          "snippet": "void put_filp(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tsecurity_file_free(file);\n\t\tfile_free(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid put_filp(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tsecurity_file_free(file);\n\t\tfile_free(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_get",
          "args": [
            "&path"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "path_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "476-480",
          "snippet": "void path_get(const struct path *path)\n{\n\tmntget(path->mnt);\n\tdget(path->dentry);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_get(const struct path *path)\n{\n\tmntget(path->mnt);\n\tdget(path->dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "res[0]"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_file",
          "args": [
            "&path",
            "FMODE_READ",
            "&pipefifo_fops"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "158-181",
          "snippet": "struct file *alloc_file(struct path *path, fmode_t mode,\n\t\tconst struct file_operations *fop)\n{\n\tstruct file *file;\n\n\tfile = get_empty_filp();\n\tif (IS_ERR(file))\n\t\treturn file;\n\n\tfile->f_path = *path;\n\tfile->f_inode = path->dentry->d_inode;\n\tfile->f_mapping = path->dentry->d_inode->i_mapping;\n\tif ((mode & FMODE_READ) &&\n\t     likely(fop->read || fop->aio_read || fop->read_iter))\n\t\tmode |= FMODE_CAN_READ;\n\tif ((mode & FMODE_WRITE) &&\n\t     likely(fop->write || fop->aio_write || fop->write_iter))\n\t\tmode |= FMODE_CAN_WRITE;\n\tfile->f_mode = mode;\n\tfile->f_op = fop;\n\tif ((mode & (FMODE_READ | FMODE_WRITE)) == FMODE_READ)\n\t\ti_readcount_inc(path->dentry->d_inode);\n\treturn file;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstruct file *alloc_file(struct path *path, fmode_t mode,\n\t\tconst struct file_operations *fop)\n{\n\tstruct file *file;\n\n\tfile = get_empty_filp();\n\tif (IS_ERR(file))\n\t\treturn file;\n\n\tfile->f_path = *path;\n\tfile->f_inode = path->dentry->d_inode;\n\tfile->f_mapping = path->dentry->d_inode->i_mapping;\n\tif ((mode & FMODE_READ) &&\n\t     likely(fop->read || fop->aio_read || fop->read_iter))\n\t\tmode |= FMODE_CAN_READ;\n\tif ((mode & FMODE_WRITE) &&\n\t     likely(fop->write || fop->aio_write || fop->write_iter))\n\t\tmode |= FMODE_CAN_WRITE;\n\tfile->f_mode = mode;\n\tfile->f_op = fop;\n\tif ((mode & (FMODE_READ | FMODE_WRITE)) == FMODE_READ)\n\t\ti_readcount_inc(path->dentry->d_inode);\n\treturn file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "f"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "path.dentry",
            "inode"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mntget",
          "args": [
            "pipe_mnt"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "mntget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1130-1135",
          "snippet": "struct vfsmount *mntget(struct vfsmount *mnt)\n{\n\tif (mnt)\n\t\tmnt_add_count(real_mount(mnt), 1);\n\treturn mnt;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstruct vfsmount *mntget(struct vfsmount *mnt)\n{\n\tif (mnt)\n\t\tmnt_add_count(real_mount(mnt), 1);\n\treturn mnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_alloc_pseudo",
          "args": [
            "pipe_mnt->mnt_sb",
            "&name"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "d_alloc_pseudo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1618-1621",
          "snippet": "struct dentry *d_alloc_pseudo(struct super_block *sb, const struct qstr *name)\n{\n\treturn __d_alloc(sb, name);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_alloc_pseudo(struct super_block *sb, const struct qstr *name)\n{\n\treturn __d_alloc(sb, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pipe_inode",
          "args": [],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "get_pipe_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "638-676",
          "snippet": "static struct inode * get_pipe_inode(void)\n{\n\tstruct inode *inode = new_inode_pseudo(pipe_mnt->mnt_sb);\n\tstruct pipe_inode_info *pipe;\n\n\tif (!inode)\n\t\tgoto fail_inode;\n\n\tinode->i_ino = get_next_ino();\n\n\tpipe = alloc_pipe_info();\n\tif (!pipe)\n\t\tgoto fail_iput;\n\n\tinode->i_pipe = pipe;\n\tpipe->files = 2;\n\tpipe->readers = pipe->writers = 1;\n\tinode->i_fop = &pipefifo_fops;\n\n\t/*\n\t * Mark the inode dirty from the very beginning,\n\t * that way it will never be moved to the dirty\n\t * list because \"mark_inode_dirty()\" will think\n\t * that it already _is_ on the dirty list.\n\t */\n\tinode->i_state = I_DIRTY;\n\tinode->i_mode = S_IFIFO | S_IRUSR | S_IWUSR;\n\tinode->i_uid = current_fsuid();\n\tinode->i_gid = current_fsgid();\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\n\treturn inode;\n\nfail_iput:\n\tiput(inode);\n\nfail_inode:\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations pipefifo_fops = {\n\t.open\t\t= fifo_open,\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= pipe_read,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= pipe_write,\n\t.poll\t\t= pipe_poll,\n\t.unlocked_ioctl\t= pipe_ioctl,\n\t.release\t= pipe_release,\n\t.fasync\t\t= pipe_fasync,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nconst struct file_operations pipefifo_fops = {\n\t.open\t\t= fifo_open,\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= pipe_read,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= pipe_write,\n\t.poll\t\t= pipe_poll,\n\t.unlocked_ioctl\t= pipe_ioctl,\n\t.release\t= pipe_release,\n\t.fasync\t\t= pipe_fasync,\n};\n\nstatic struct inode * get_pipe_inode(void)\n{\n\tstruct inode *inode = new_inode_pseudo(pipe_mnt->mnt_sb);\n\tstruct pipe_inode_info *pipe;\n\n\tif (!inode)\n\t\tgoto fail_inode;\n\n\tinode->i_ino = get_next_ino();\n\n\tpipe = alloc_pipe_info();\n\tif (!pipe)\n\t\tgoto fail_iput;\n\n\tinode->i_pipe = pipe;\n\tpipe->files = 2;\n\tpipe->readers = pipe->writers = 1;\n\tinode->i_fop = &pipefifo_fops;\n\n\t/*\n\t * Mark the inode dirty from the very beginning,\n\t * that way it will never be moved to the dirty\n\t * list because \"mark_inode_dirty()\" will think\n\t * that it already _is_ on the dirty list.\n\t */\n\tinode->i_state = I_DIRTY;\n\tinode->i_mode = S_IFIFO | S_IRUSR | S_IWUSR;\n\tinode->i_uid = current_fsuid();\n\tinode->i_gid = current_fsgid();\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\n\treturn inode;\n\nfail_iput:\n\tiput(inode);\n\nfail_inode:\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nconst struct file_operations pipefifo_fops = {\n\t.open\t\t= fifo_open,\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= pipe_read,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= pipe_write,\n\t.poll\t\t= pipe_poll,\n\t.unlocked_ioctl\t= pipe_ioctl,\n\t.release\t= pipe_release,\n\t.fasync\t\t= pipe_fasync,\n};\n\nint create_pipe_files(struct file **res, int flags)\n{\n\tint err;\n\tstruct inode *inode = get_pipe_inode();\n\tstruct file *f;\n\tstruct path path;\n\tstatic struct qstr name = { .name = \"\" };\n\n\tif (!inode)\n\t\treturn -ENFILE;\n\n\terr = -ENOMEM;\n\tpath.dentry = d_alloc_pseudo(pipe_mnt->mnt_sb, &name);\n\tif (!path.dentry)\n\t\tgoto err_inode;\n\tpath.mnt = mntget(pipe_mnt);\n\n\td_instantiate(path.dentry, inode);\n\n\terr = -ENFILE;\n\tf = alloc_file(&path, FMODE_WRITE, &pipefifo_fops);\n\tif (IS_ERR(f))\n\t\tgoto err_dentry;\n\n\tf->f_flags = O_WRONLY | (flags & (O_NONBLOCK | O_DIRECT));\n\tf->private_data = inode->i_pipe;\n\n\tres[0] = alloc_file(&path, FMODE_READ, &pipefifo_fops);\n\tif (IS_ERR(res[0]))\n\t\tgoto err_file;\n\n\tpath_get(&path);\n\tres[0]->private_data = inode->i_pipe;\n\tres[0]->f_flags = O_RDONLY | (flags & O_NONBLOCK);\n\tres[1] = f;\n\treturn 0;\n\nerr_file:\n\tput_filp(f);\nerr_dentry:\n\tfree_pipe_info(inode->i_pipe);\n\tpath_put(&path);\n\treturn err;\n\nerr_inode:\n\tfree_pipe_info(inode->i_pipe);\n\tiput(inode);\n\treturn err;\n}"
  },
  {
    "function_name": "get_pipe_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
    "lines": "638-676",
    "snippet": "static struct inode * get_pipe_inode(void)\n{\n\tstruct inode *inode = new_inode_pseudo(pipe_mnt->mnt_sb);\n\tstruct pipe_inode_info *pipe;\n\n\tif (!inode)\n\t\tgoto fail_inode;\n\n\tinode->i_ino = get_next_ino();\n\n\tpipe = alloc_pipe_info();\n\tif (!pipe)\n\t\tgoto fail_iput;\n\n\tinode->i_pipe = pipe;\n\tpipe->files = 2;\n\tpipe->readers = pipe->writers = 1;\n\tinode->i_fop = &pipefifo_fops;\n\n\t/*\n\t * Mark the inode dirty from the very beginning,\n\t * that way it will never be moved to the dirty\n\t * list because \"mark_inode_dirty()\" will think\n\t * that it already _is_ on the dirty list.\n\t */\n\tinode->i_state = I_DIRTY;\n\tinode->i_mode = S_IFIFO | S_IRUSR | S_IWUSR;\n\tinode->i_uid = current_fsuid();\n\tinode->i_gid = current_fsgid();\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\n\treturn inode;\n\nfail_iput:\n\tiput(inode);\n\nfail_inode:\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct file_operations pipefifo_fops = {\n\t.open\t\t= fifo_open,\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= pipe_read,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= pipe_write,\n\t.poll\t\t= pipe_poll,\n\t.unlocked_ioctl\t= pipe_ioctl,\n\t.release\t= pipe_release,\n\t.fasync\t\t= pipe_fasync,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fsgid",
          "args": [],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_pipe_info",
          "args": [],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_pipe_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "588-606",
          "snippet": "struct pipe_inode_info *alloc_pipe_info(void)\n{\n\tstruct pipe_inode_info *pipe;\n\n\tpipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL);\n\tif (pipe) {\n\t\tpipe->bufs = kzalloc(sizeof(struct pipe_buffer) * PIPE_DEF_BUFFERS, GFP_KERNEL);\n\t\tif (pipe->bufs) {\n\t\t\tinit_waitqueue_head(&pipe->wait);\n\t\t\tpipe->r_counter = pipe->w_counter = 1;\n\t\t\tpipe->buffers = PIPE_DEF_BUFFERS;\n\t\t\tmutex_init(&pipe->mutex);\n\t\t\treturn pipe;\n\t\t}\n\t\tkfree(pipe);\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstruct pipe_inode_info *alloc_pipe_info(void)\n{\n\tstruct pipe_inode_info *pipe;\n\n\tpipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL);\n\tif (pipe) {\n\t\tpipe->bufs = kzalloc(sizeof(struct pipe_buffer) * PIPE_DEF_BUFFERS, GFP_KERNEL);\n\t\tif (pipe->bufs) {\n\t\t\tinit_waitqueue_head(&pipe->wait);\n\t\t\tpipe->r_counter = pipe->w_counter = 1;\n\t\t\tpipe->buffers = PIPE_DEF_BUFFERS;\n\t\t\tmutex_init(&pipe->mutex);\n\t\t\treturn pipe;\n\t\t}\n\t\tkfree(pipe);\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_next_ino",
          "args": [],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "get_next_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "828-845",
          "snippet": "unsigned int get_next_ino(void)\n{\n\tunsigned int *p = &get_cpu_var(last_ino);\n\tunsigned int res = *p;\n\n#ifdef CONFIG_SMP\n\tif (unlikely((res & (LAST_INO_BATCH-1)) == 0)) {\n\t\tstatic atomic_t shared_last_ino;\n\t\tint next = atomic_add_return(LAST_INO_BATCH, &shared_last_ino);\n\n\t\tres = next - LAST_INO_BATCH;\n\t}\n#endif\n\n\t*p = ++res;\n\tput_cpu_var(last_ino);\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define LAST_INO_BATCH 1024"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned int, last_ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n#define LAST_INO_BATCH 1024\n\nstatic DEFINE_PER_CPU(unsigned int, last_ino);\n\nunsigned int get_next_ino(void)\n{\n\tunsigned int *p = &get_cpu_var(last_ino);\n\tunsigned int res = *p;\n\n#ifdef CONFIG_SMP\n\tif (unlikely((res & (LAST_INO_BATCH-1)) == 0)) {\n\t\tstatic atomic_t shared_last_ino;\n\t\tint next = atomic_add_return(LAST_INO_BATCH, &shared_last_ino);\n\n\t\tres = next - LAST_INO_BATCH;\n\t}\n#endif\n\n\t*p = ++res;\n\tput_cpu_var(last_ino);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_inode_pseudo",
          "args": [
            "pipe_mnt->mnt_sb"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "new_inode_pseudo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "858-869",
          "snippet": "struct inode *new_inode_pseudo(struct super_block *sb)\n{\n\tstruct inode *inode = alloc_inode(sb);\n\n\tif (inode) {\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_state = 0;\n\t\tspin_unlock(&inode->i_lock);\n\t\tINIT_LIST_HEAD(&inode->i_sb_list);\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *new_inode_pseudo(struct super_block *sb)\n{\n\tstruct inode *inode = alloc_inode(sb);\n\n\tif (inode) {\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_state = 0;\n\t\tspin_unlock(&inode->i_lock);\n\t\tINIT_LIST_HEAD(&inode->i_sb_list);\n\t}\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nconst struct file_operations pipefifo_fops = {\n\t.open\t\t= fifo_open,\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= pipe_read,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= pipe_write,\n\t.poll\t\t= pipe_poll,\n\t.unlocked_ioctl\t= pipe_ioctl,\n\t.release\t= pipe_release,\n\t.fasync\t\t= pipe_fasync,\n};\n\nstatic struct inode * get_pipe_inode(void)\n{\n\tstruct inode *inode = new_inode_pseudo(pipe_mnt->mnt_sb);\n\tstruct pipe_inode_info *pipe;\n\n\tif (!inode)\n\t\tgoto fail_inode;\n\n\tinode->i_ino = get_next_ino();\n\n\tpipe = alloc_pipe_info();\n\tif (!pipe)\n\t\tgoto fail_iput;\n\n\tinode->i_pipe = pipe;\n\tpipe->files = 2;\n\tpipe->readers = pipe->writers = 1;\n\tinode->i_fop = &pipefifo_fops;\n\n\t/*\n\t * Mark the inode dirty from the very beginning,\n\t * that way it will never be moved to the dirty\n\t * list because \"mark_inode_dirty()\" will think\n\t * that it already _is_ on the dirty list.\n\t */\n\tinode->i_state = I_DIRTY;\n\tinode->i_mode = S_IFIFO | S_IRUSR | S_IWUSR;\n\tinode->i_uid = current_fsuid();\n\tinode->i_gid = current_fsgid();\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\n\treturn inode;\n\nfail_iput:\n\tiput(inode);\n\nfail_inode:\n\treturn NULL;\n}"
  },
  {
    "function_name": "pipefs_dname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
    "lines": "628-632",
    "snippet": "static char *pipefs_dname(struct dentry *dentry, char *buffer, int buflen)\n{\n\treturn dynamic_dname(dentry, buffer, buflen, \"pipe:[%lu]\",\n\t\t\t\tdentry->d_inode->i_ino);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dynamic_dname",
          "args": [
            "dentry",
            "buffer",
            "buflen",
            "\"pipe:[%lu]\"",
            "dentry->d_inode->i_ino"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "dynamic_dname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "3082-3098",
          "snippet": "char *dynamic_dname(struct dentry *dentry, char *buffer, int buflen,\n\t\t\tconst char *fmt, ...)\n{\n\tva_list args;\n\tchar temp[64];\n\tint sz;\n\n\tva_start(args, fmt);\n\tsz = vsnprintf(temp, sizeof(temp), fmt, args) + 1;\n\tva_end(args);\n\n\tif (sz > sizeof(temp) || sz > buflen)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tbuffer += buflen - sz;\n\treturn memcpy(buffer, temp, sz);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nchar *dynamic_dname(struct dentry *dentry, char *buffer, int buflen,\n\t\t\tconst char *fmt, ...)\n{\n\tva_list args;\n\tchar temp[64];\n\tint sz;\n\n\tva_start(args, fmt);\n\tsz = vsnprintf(temp, sizeof(temp), fmt, args) + 1;\n\tva_end(args);\n\n\tif (sz > sizeof(temp) || sz > buflen)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tbuffer += buflen - sz;\n\treturn memcpy(buffer, temp, sz);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic char *pipefs_dname(struct dentry *dentry, char *buffer, int buflen)\n{\n\treturn dynamic_dname(dentry, buffer, buflen, \"pipe:[%lu]\",\n\t\t\t\tdentry->d_inode->i_ino);\n}"
  },
  {
    "function_name": "free_pipe_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
    "lines": "608-621",
    "snippet": "void free_pipe_info(struct pipe_inode_info *pipe)\n{\n\tint i;\n\n\tfor (i = 0; i < pipe->buffers; i++) {\n\t\tstruct pipe_buffer *buf = pipe->bufs + i;\n\t\tif (buf->ops)\n\t\t\tbuf->ops->release(pipe, buf);\n\t}\n\tif (pipe->tmp_page)\n\t\t__free_page(pipe->tmp_page);\n\tkfree(pipe->bufs);\n\tkfree(pipe);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pipe"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pipe->bufs"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "pipe->tmp_page"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buf->ops->release",
          "args": [
            "pipe",
            "buf"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nvoid free_pipe_info(struct pipe_inode_info *pipe)\n{\n\tint i;\n\n\tfor (i = 0; i < pipe->buffers; i++) {\n\t\tstruct pipe_buffer *buf = pipe->bufs + i;\n\t\tif (buf->ops)\n\t\t\tbuf->ops->release(pipe, buf);\n\t}\n\tif (pipe->tmp_page)\n\t\t__free_page(pipe->tmp_page);\n\tkfree(pipe->bufs);\n\tkfree(pipe);\n}"
  },
  {
    "function_name": "alloc_pipe_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
    "lines": "588-606",
    "snippet": "struct pipe_inode_info *alloc_pipe_info(void)\n{\n\tstruct pipe_inode_info *pipe;\n\n\tpipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL);\n\tif (pipe) {\n\t\tpipe->bufs = kzalloc(sizeof(struct pipe_buffer) * PIPE_DEF_BUFFERS, GFP_KERNEL);\n\t\tif (pipe->bufs) {\n\t\t\tinit_waitqueue_head(&pipe->wait);\n\t\t\tpipe->r_counter = pipe->w_counter = 1;\n\t\t\tpipe->buffers = PIPE_DEF_BUFFERS;\n\t\t\tmutex_init(&pipe->mutex);\n\t\t\treturn pipe;\n\t\t}\n\t\tkfree(pipe);\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pipe"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&pipe->mutex"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&pipe->wait"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct pipe_buffer) * PIPE_DEF_BUFFERS",
            "GFP_KERNEL"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct pipe_inode_info)",
            "GFP_KERNEL"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstruct pipe_inode_info *alloc_pipe_info(void)\n{\n\tstruct pipe_inode_info *pipe;\n\n\tpipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL);\n\tif (pipe) {\n\t\tpipe->bufs = kzalloc(sizeof(struct pipe_buffer) * PIPE_DEF_BUFFERS, GFP_KERNEL);\n\t\tif (pipe->bufs) {\n\t\t\tinit_waitqueue_head(&pipe->wait);\n\t\t\tpipe->r_counter = pipe->w_counter = 1;\n\t\t\tpipe->buffers = PIPE_DEF_BUFFERS;\n\t\t\tmutex_init(&pipe->mutex);\n\t\t\treturn pipe;\n\t\t}\n\t\tkfree(pipe);\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "pipe_fasync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
    "lines": "569-586",
    "snippet": "static int\npipe_fasync(int fd, struct file *filp, int on)\n{\n\tstruct pipe_inode_info *pipe = filp->private_data;\n\tint retval = 0;\n\n\t__pipe_lock(pipe);\n\tif (filp->f_mode & FMODE_READ)\n\t\tretval = fasync_helper(fd, filp, on, &pipe->fasync_readers);\n\tif ((filp->f_mode & FMODE_WRITE) && retval >= 0) {\n\t\tretval = fasync_helper(fd, filp, on, &pipe->fasync_writers);\n\t\tif (retval < 0 && (filp->f_mode & FMODE_READ))\n\t\t\t/* this can happen only if on == T */\n\t\t\tfasync_helper(-1, filp, 0, &pipe->fasync_readers);\n\t}\n\t__pipe_unlock(pipe);\n\treturn retval;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__pipe_unlock",
          "args": [
            "pipe"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "84-87",
          "snippet": "static inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fasync_helper",
          "args": [
            "-1",
            "filp",
            "0",
            "&pipe->fasync_readers"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "fasync_helper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fcntl.c",
          "lines": "686-691",
          "snippet": "int fasync_helper(int fd, struct file * filp, int on, struct fasync_struct **fapp)\n{\n\tif (!on)\n\t\treturn fasync_remove_entry(filp, fapp);\n\treturn fasync_add_entry(fd, filp, fapp);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/poll.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/siginfo.h>\n#include <asm/poll.h>\n#include <linux/shmem_fs.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nint fasync_helper(int fd, struct file * filp, int on, struct fasync_struct **fapp)\n{\n\tif (!on)\n\t\treturn fasync_remove_entry(filp, fapp);\n\treturn fasync_add_entry(fd, filp, fapp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pipe_lock",
          "args": [
            "pipe"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "79-82",
          "snippet": "static inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic int\npipe_fasync(int fd, struct file *filp, int on)\n{\n\tstruct pipe_inode_info *pipe = filp->private_data;\n\tint retval = 0;\n\n\t__pipe_lock(pipe);\n\tif (filp->f_mode & FMODE_READ)\n\t\tretval = fasync_helper(fd, filp, on, &pipe->fasync_readers);\n\tif ((filp->f_mode & FMODE_WRITE) && retval >= 0) {\n\t\tretval = fasync_helper(fd, filp, on, &pipe->fasync_writers);\n\t\tif (retval < 0 && (filp->f_mode & FMODE_READ))\n\t\t\t/* this can happen only if on == T */\n\t\t\tfasync_helper(-1, filp, 0, &pipe->fasync_readers);\n\t}\n\t__pipe_unlock(pipe);\n\treturn retval;\n}"
  },
  {
    "function_name": "pipe_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
    "lines": "547-567",
    "snippet": "static int\npipe_release(struct inode *inode, struct file *file)\n{\n\tstruct pipe_inode_info *pipe = file->private_data;\n\n\t__pipe_lock(pipe);\n\tif (file->f_mode & FMODE_READ)\n\t\tpipe->readers--;\n\tif (file->f_mode & FMODE_WRITE)\n\t\tpipe->writers--;\n\n\tif (pipe->readers || pipe->writers) {\n\t\twake_up_interruptible_sync_poll(&pipe->wait, POLLIN | POLLOUT | POLLRDNORM | POLLWRNORM | POLLERR | POLLHUP);\n\t\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n\t\tkill_fasync(&pipe->fasync_writers, SIGIO, POLL_OUT);\n\t}\n\t__pipe_unlock(pipe);\n\n\tput_pipe_info(inode, pipe);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_pipe_info",
          "args": [
            "inode",
            "pipe"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "put_pipe_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "532-545",
          "snippet": "static void put_pipe_info(struct inode *inode, struct pipe_inode_info *pipe)\n{\n\tint kill = 0;\n\n\tspin_lock(&inode->i_lock);\n\tif (!--pipe->files) {\n\t\tinode->i_pipe = NULL;\n\t\tkill = 1;\n\t}\n\tspin_unlock(&inode->i_lock);\n\n\tif (kill)\n\t\tfree_pipe_info(pipe);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic void put_pipe_info(struct inode *inode, struct pipe_inode_info *pipe)\n{\n\tint kill = 0;\n\n\tspin_lock(&inode->i_lock);\n\tif (!--pipe->files) {\n\t\tinode->i_pipe = NULL;\n\t\tkill = 1;\n\t}\n\tspin_unlock(&inode->i_lock);\n\n\tif (kill)\n\t\tfree_pipe_info(pipe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pipe_unlock",
          "args": [
            "pipe"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "84-87",
          "snippet": "static inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill_fasync",
          "args": [
            "&pipe->fasync_writers",
            "SIGIO",
            "POLL_OUT"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "kill_fasync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fcntl.c",
          "lines": "723-733",
          "snippet": "void kill_fasync(struct fasync_struct **fp, int sig, int band)\n{\n\t/* First a quick test without locking: usually\n\t * the list is empty.\n\t */\n\tif (*fp) {\n\t\trcu_read_lock();\n\t\tkill_fasync_rcu(rcu_dereference(*fp), sig, band);\n\t\trcu_read_unlock();\n\t}\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/poll.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/siginfo.h>\n#include <asm/poll.h>\n#include <linux/shmem_fs.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nvoid kill_fasync(struct fasync_struct **fp, int sig, int band)\n{\n\t/* First a quick test without locking: usually\n\t * the list is empty.\n\t */\n\tif (*fp) {\n\t\trcu_read_lock();\n\t\tkill_fasync_rcu(rcu_dereference(*fp), sig, band);\n\t\trcu_read_unlock();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_interruptible_sync_poll",
          "args": [
            "&pipe->wait",
            "POLLIN | POLLOUT | POLLRDNORM | POLLWRNORM | POLLERR | POLLHUP"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pipe_lock",
          "args": [
            "pipe"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "79-82",
          "snippet": "static inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic int\npipe_release(struct inode *inode, struct file *file)\n{\n\tstruct pipe_inode_info *pipe = file->private_data;\n\n\t__pipe_lock(pipe);\n\tif (file->f_mode & FMODE_READ)\n\t\tpipe->readers--;\n\tif (file->f_mode & FMODE_WRITE)\n\t\tpipe->writers--;\n\n\tif (pipe->readers || pipe->writers) {\n\t\twake_up_interruptible_sync_poll(&pipe->wait, POLLIN | POLLOUT | POLLRDNORM | POLLWRNORM | POLLERR | POLLHUP);\n\t\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n\t\tkill_fasync(&pipe->fasync_writers, SIGIO, POLL_OUT);\n\t}\n\t__pipe_unlock(pipe);\n\n\tput_pipe_info(inode, pipe);\n\treturn 0;\n}"
  },
  {
    "function_name": "put_pipe_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
    "lines": "532-545",
    "snippet": "static void put_pipe_info(struct inode *inode, struct pipe_inode_info *pipe)\n{\n\tint kill = 0;\n\n\tspin_lock(&inode->i_lock);\n\tif (!--pipe->files) {\n\t\tinode->i_pipe = NULL;\n\t\tkill = 1;\n\t}\n\tspin_unlock(&inode->i_lock);\n\n\tif (kill)\n\t\tfree_pipe_info(pipe);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_pipe_info",
          "args": [
            "pipe"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "free_pipe_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "608-621",
          "snippet": "void free_pipe_info(struct pipe_inode_info *pipe)\n{\n\tint i;\n\n\tfor (i = 0; i < pipe->buffers; i++) {\n\t\tstruct pipe_buffer *buf = pipe->bufs + i;\n\t\tif (buf->ops)\n\t\t\tbuf->ops->release(pipe, buf);\n\t}\n\tif (pipe->tmp_page)\n\t\t__free_page(pipe->tmp_page);\n\tkfree(pipe->bufs);\n\tkfree(pipe);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nvoid free_pipe_info(struct pipe_inode_info *pipe)\n{\n\tint i;\n\n\tfor (i = 0; i < pipe->buffers; i++) {\n\t\tstruct pipe_buffer *buf = pipe->bufs + i;\n\t\tif (buf->ops)\n\t\t\tbuf->ops->release(pipe, buf);\n\t}\n\tif (pipe->tmp_page)\n\t\t__free_page(pipe->tmp_page);\n\tkfree(pipe->bufs);\n\tkfree(pipe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic void put_pipe_info(struct inode *inode, struct pipe_inode_info *pipe)\n{\n\tint kill = 0;\n\n\tspin_lock(&inode->i_lock);\n\tif (!--pipe->files) {\n\t\tinode->i_pipe = NULL;\n\t\tkill = 1;\n\t}\n\tspin_unlock(&inode->i_lock);\n\n\tif (kill)\n\t\tfree_pipe_info(pipe);\n}"
  },
  {
    "function_name": "pipe_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
    "lines": "501-530",
    "snippet": "static unsigned int\npipe_poll(struct file *filp, poll_table *wait)\n{\n\tunsigned int mask;\n\tstruct pipe_inode_info *pipe = filp->private_data;\n\tint nrbufs;\n\n\tpoll_wait(filp, &pipe->wait, wait);\n\n\t/* Reading only -- no need for acquiring the semaphore.  */\n\tnrbufs = pipe->nrbufs;\n\tmask = 0;\n\tif (filp->f_mode & FMODE_READ) {\n\t\tmask = (nrbufs > 0) ? POLLIN | POLLRDNORM : 0;\n\t\tif (!pipe->writers && filp->f_version != pipe->w_counter)\n\t\t\tmask |= POLLHUP;\n\t}\n\n\tif (filp->f_mode & FMODE_WRITE) {\n\t\tmask |= (nrbufs < pipe->buffers) ? POLLOUT | POLLWRNORM : 0;\n\t\t/*\n\t\t * Most Unices do not set POLLERR for FIFOs but on Linux they\n\t\t * behave exactly like pipes for poll().\n\t\t */\n\t\tif (!pipe->readers)\n\t\t\tmask |= POLLERR;\n\t}\n\n\treturn mask;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "poll_wait",
          "args": [
            "filp",
            "&pipe->wait",
            "wait"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic unsigned int\npipe_poll(struct file *filp, poll_table *wait)\n{\n\tunsigned int mask;\n\tstruct pipe_inode_info *pipe = filp->private_data;\n\tint nrbufs;\n\n\tpoll_wait(filp, &pipe->wait, wait);\n\n\t/* Reading only -- no need for acquiring the semaphore.  */\n\tnrbufs = pipe->nrbufs;\n\tmask = 0;\n\tif (filp->f_mode & FMODE_READ) {\n\t\tmask = (nrbufs > 0) ? POLLIN | POLLRDNORM : 0;\n\t\tif (!pipe->writers && filp->f_version != pipe->w_counter)\n\t\t\tmask |= POLLHUP;\n\t}\n\n\tif (filp->f_mode & FMODE_WRITE) {\n\t\tmask |= (nrbufs < pipe->buffers) ? POLLOUT | POLLWRNORM : 0;\n\t\t/*\n\t\t * Most Unices do not set POLLERR for FIFOs but on Linux they\n\t\t * behave exactly like pipes for poll().\n\t\t */\n\t\tif (!pipe->readers)\n\t\t\tmask |= POLLERR;\n\t}\n\n\treturn mask;\n}"
  },
  {
    "function_name": "pipe_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
    "lines": "477-498",
    "snippet": "static long pipe_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct pipe_inode_info *pipe = filp->private_data;\n\tint count, buf, nrbufs;\n\n\tswitch (cmd) {\n\t\tcase FIONREAD:\n\t\t\t__pipe_lock(pipe);\n\t\t\tcount = 0;\n\t\t\tbuf = pipe->curbuf;\n\t\t\tnrbufs = pipe->nrbufs;\n\t\t\twhile (--nrbufs >= 0) {\n\t\t\t\tcount += pipe->bufs[buf].len;\n\t\t\t\tbuf = (buf+1) & (pipe->buffers - 1);\n\t\t\t}\n\t\t\t__pipe_unlock(pipe);\n\n\t\t\treturn put_user(count, (int __user *)arg);\n\t\tdefault:\n\t\t\treturn -ENOIOCTLCMD;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "count",
            "(int __user *)arg"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pipe_unlock",
          "args": [
            "pipe"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "84-87",
          "snippet": "static inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pipe_lock",
          "args": [
            "pipe"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "79-82",
          "snippet": "static inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic long pipe_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct pipe_inode_info *pipe = filp->private_data;\n\tint count, buf, nrbufs;\n\n\tswitch (cmd) {\n\t\tcase FIONREAD:\n\t\t\t__pipe_lock(pipe);\n\t\t\tcount = 0;\n\t\t\tbuf = pipe->curbuf;\n\t\t\tnrbufs = pipe->nrbufs;\n\t\t\twhile (--nrbufs >= 0) {\n\t\t\t\tcount += pipe->bufs[buf].len;\n\t\t\t\tbuf = (buf+1) & (pipe->buffers - 1);\n\t\t\t}\n\t\t\t__pipe_unlock(pipe);\n\n\t\t\treturn put_user(count, (int __user *)arg);\n\t\tdefault:\n\t\t\treturn -ENOIOCTLCMD;\n\t}\n}"
  },
  {
    "function_name": "pipe_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
    "lines": "338-475",
    "snippet": "static ssize_t\npipe_write(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *filp = iocb->ki_filp;\n\tstruct pipe_inode_info *pipe = filp->private_data;\n\tssize_t ret = 0;\n\tint do_wakeup = 0;\n\tsize_t total_len = iov_iter_count(from);\n\tssize_t chars;\n\n\t/* Null write succeeds. */\n\tif (unlikely(total_len == 0))\n\t\treturn 0;\n\n\t__pipe_lock(pipe);\n\n\tif (!pipe->readers) {\n\t\tsend_sig(SIGPIPE, current, 0);\n\t\tret = -EPIPE;\n\t\tgoto out;\n\t}\n\n\t/* We try to merge small writes */\n\tchars = total_len & (PAGE_SIZE-1); /* size of the last buffer */\n\tif (pipe->nrbufs && chars != 0) {\n\t\tint lastbuf = (pipe->curbuf + pipe->nrbufs - 1) &\n\t\t\t\t\t\t\t(pipe->buffers - 1);\n\t\tstruct pipe_buffer *buf = pipe->bufs + lastbuf;\n\t\tconst struct pipe_buf_operations *ops = buf->ops;\n\t\tint offset = buf->offset + buf->len;\n\n\t\tif (ops->can_merge && offset + chars <= PAGE_SIZE) {\n\t\t\tint error = ops->confirm(pipe, buf);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\n\t\t\tret = copy_page_from_iter(buf->page, offset, chars, from);\n\t\t\tif (unlikely(ret < chars)) {\n\t\t\t\terror = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tdo_wakeup = 1;\n\t\t\tbuf->len += chars;\n\t\t\tret = chars;\n\t\t\tif (!iov_iter_count(from))\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfor (;;) {\n\t\tint bufs;\n\n\t\tif (!pipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\t\tbufs = pipe->nrbufs;\n\t\tif (bufs < pipe->buffers) {\n\t\t\tint newbuf = (pipe->curbuf + bufs) & (pipe->buffers-1);\n\t\t\tstruct pipe_buffer *buf = pipe->bufs + newbuf;\n\t\t\tstruct page *page = pipe->tmp_page;\n\t\t\tint copied;\n\n\t\t\tif (!page) {\n\t\t\t\tpage = alloc_page(GFP_HIGHUSER);\n\t\t\t\tif (unlikely(!page)) {\n\t\t\t\t\tret = ret ? : -ENOMEM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpipe->tmp_page = page;\n\t\t\t}\n\t\t\t/* Always wake up, even if the copy fails. Otherwise\n\t\t\t * we lock up (O_NONBLOCK-)readers that sleep due to\n\t\t\t * syscall merging.\n\t\t\t * FIXME! Is this really true?\n\t\t\t */\n\t\t\tdo_wakeup = 1;\n\t\t\tcopied = copy_page_from_iter(page, 0, PAGE_SIZE, from);\n\t\t\tif (unlikely(copied < PAGE_SIZE && iov_iter_count(from))) {\n\t\t\t\tif (!ret)\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret += copied;\n\n\t\t\t/* Insert it into the buffer array */\n\t\t\tbuf->page = page;\n\t\t\tbuf->ops = &anon_pipe_buf_ops;\n\t\t\tbuf->offset = 0;\n\t\t\tbuf->len = copied;\n\t\t\tbuf->flags = 0;\n\t\t\tif (is_packetized(filp)) {\n\t\t\t\tbuf->ops = &packet_pipe_buf_ops;\n\t\t\t\tbuf->flags = PIPE_BUF_FLAG_PACKET;\n\t\t\t}\n\t\t\tpipe->nrbufs = ++bufs;\n\t\t\tpipe->tmp_page = NULL;\n\n\t\t\tif (!iov_iter_count(from))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (bufs < pipe->buffers)\n\t\t\tcontinue;\n\t\tif (filp->f_flags & O_NONBLOCK) {\n\t\t\tif (!ret)\n\t\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tif (signal_pending(current)) {\n\t\t\tif (!ret)\n\t\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tif (do_wakeup) {\n\t\t\twake_up_interruptible_sync_poll(&pipe->wait, POLLIN | POLLRDNORM);\n\t\t\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n\t\t\tdo_wakeup = 0;\n\t\t}\n\t\tpipe->waiting_writers++;\n\t\tpipe_wait(pipe);\n\t\tpipe->waiting_writers--;\n\t}\nout:\n\t__pipe_unlock(pipe);\n\tif (do_wakeup) {\n\t\twake_up_interruptible_sync_poll(&pipe->wait, POLLIN | POLLRDNORM);\n\t\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n\t}\n\tif (ret > 0 && sb_start_write_trylock(file_inode(filp)->i_sb)) {\n\t\tint err = file_update_time(filp);\n\t\tif (err)\n\t\t\tret = err;\n\t\tsb_end_write(file_inode(filp)->i_sb);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct pipe_buf_operations anon_pipe_buf_ops = {\n\t.can_merge = 1,\n\t.confirm = generic_pipe_buf_confirm,\n\t.release = anon_pipe_buf_release,\n\t.steal = generic_pipe_buf_steal,\n\t.get = generic_pipe_buf_get,\n};",
      "static const struct pipe_buf_operations packet_pipe_buf_ops = {\n\t.can_merge = 0,\n\t.confirm = generic_pipe_buf_confirm,\n\t.release = anon_pipe_buf_release,\n\t.steal = generic_pipe_buf_steal,\n\t.get = generic_pipe_buf_get,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sb_end_write",
          "args": [
            "file_inode(filp)->i_sb"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_update_time",
          "args": [
            "filp"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "file_update_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1716-1748",
          "snippet": "int file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_fs_time(inode->i_sb);\n\tif (!timespec_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_fs_time(inode->i_sb);\n\tif (!timespec_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_start_write_trylock",
          "args": [
            "file_inode(filp)->i_sb"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill_fasync",
          "args": [
            "&pipe->fasync_readers",
            "SIGIO",
            "POLL_IN"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "kill_fasync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fcntl.c",
          "lines": "723-733",
          "snippet": "void kill_fasync(struct fasync_struct **fp, int sig, int band)\n{\n\t/* First a quick test without locking: usually\n\t * the list is empty.\n\t */\n\tif (*fp) {\n\t\trcu_read_lock();\n\t\tkill_fasync_rcu(rcu_dereference(*fp), sig, band);\n\t\trcu_read_unlock();\n\t}\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/poll.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/siginfo.h>\n#include <asm/poll.h>\n#include <linux/shmem_fs.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nvoid kill_fasync(struct fasync_struct **fp, int sig, int band)\n{\n\t/* First a quick test without locking: usually\n\t * the list is empty.\n\t */\n\tif (*fp) {\n\t\trcu_read_lock();\n\t\tkill_fasync_rcu(rcu_dereference(*fp), sig, band);\n\t\trcu_read_unlock();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_interruptible_sync_poll",
          "args": [
            "&pipe->wait",
            "POLLIN | POLLRDNORM"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pipe_unlock",
          "args": [
            "pipe"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "84-87",
          "snippet": "static inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe_wait",
          "args": [
            "pipe"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "pipe_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "104-117",
          "snippet": "void pipe_wait(struct pipe_inode_info *pipe)\n{\n\tDEFINE_WAIT(wait);\n\n\t/*\n\t * Pipes are system-local resources, so sleeping on them\n\t * is considered a noninteractive wait:\n\t */\n\tprepare_to_wait(&pipe->wait, &wait, TASK_INTERRUPTIBLE);\n\tpipe_unlock(pipe);\n\tschedule();\n\tfinish_wait(&pipe->wait, &wait);\n\tpipe_lock(pipe);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nvoid pipe_wait(struct pipe_inode_info *pipe)\n{\n\tDEFINE_WAIT(wait);\n\n\t/*\n\t * Pipes are system-local resources, so sleeping on them\n\t * is considered a noninteractive wait:\n\t */\n\tprepare_to_wait(&pipe->wait, &wait, TASK_INTERRUPTIBLE);\n\tpipe_unlock(pipe);\n\tschedule();\n\tfinish_wait(&pipe->wait, &wait);\n\tpipe_lock(pipe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_interruptible_sync_poll",
          "args": [
            "&pipe->wait",
            "POLLIN | POLLRDNORM"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "from"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_packetized",
          "args": [
            "filp"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "is_packetized",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "333-336",
          "snippet": "static inline int is_packetized(struct file *file)\n{\n\treturn (file->f_flags & O_DIRECT) != 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline int is_packetized(struct file *file)\n{\n\treturn (file->f_flags & O_DIRECT) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "copied < PAGE_SIZE && iov_iter_count(from)"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "from"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_page_from_iter",
          "args": [
            "page",
            "0",
            "PAGE_SIZE",
            "from"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!page"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_HIGHUSER"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_sig",
          "args": [
            "SIGPIPE",
            "current",
            "0"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "send_sigurg_to_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fcntl.c",
          "lines": "518-523",
          "snippet": "static void send_sigurg_to_task(struct task_struct *p,\n\t\t\t\tstruct fown_struct *fown, int group)\n{\n\tif (sigio_perm(p, fown, SIGURG))\n\t\tdo_send_sig_info(SIGURG, SEND_SIG_PRIV, p, group);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/poll.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/siginfo.h>\n#include <asm/poll.h>\n#include <linux/shmem_fs.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nstatic void send_sigurg_to_task(struct task_struct *p,\n\t\t\t\tstruct fown_struct *fown, int group)\n{\n\tif (sigio_perm(p, fown, SIGURG))\n\t\tdo_send_sig_info(SIGURG, SEND_SIG_PRIV, p, group);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "from"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret < chars"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_page_from_iter",
          "args": [
            "buf->page",
            "offset",
            "chars",
            "from"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->confirm",
          "args": [
            "pipe",
            "buf"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pipe_lock",
          "args": [
            "pipe"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "79-82",
          "snippet": "static inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "total_len == 0"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "from"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic const struct pipe_buf_operations anon_pipe_buf_ops = {\n\t.can_merge = 1,\n\t.confirm = generic_pipe_buf_confirm,\n\t.release = anon_pipe_buf_release,\n\t.steal = generic_pipe_buf_steal,\n\t.get = generic_pipe_buf_get,\n};\nstatic const struct pipe_buf_operations packet_pipe_buf_ops = {\n\t.can_merge = 0,\n\t.confirm = generic_pipe_buf_confirm,\n\t.release = anon_pipe_buf_release,\n\t.steal = generic_pipe_buf_steal,\n\t.get = generic_pipe_buf_get,\n};\n\nstatic ssize_t\npipe_write(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *filp = iocb->ki_filp;\n\tstruct pipe_inode_info *pipe = filp->private_data;\n\tssize_t ret = 0;\n\tint do_wakeup = 0;\n\tsize_t total_len = iov_iter_count(from);\n\tssize_t chars;\n\n\t/* Null write succeeds. */\n\tif (unlikely(total_len == 0))\n\t\treturn 0;\n\n\t__pipe_lock(pipe);\n\n\tif (!pipe->readers) {\n\t\tsend_sig(SIGPIPE, current, 0);\n\t\tret = -EPIPE;\n\t\tgoto out;\n\t}\n\n\t/* We try to merge small writes */\n\tchars = total_len & (PAGE_SIZE-1); /* size of the last buffer */\n\tif (pipe->nrbufs && chars != 0) {\n\t\tint lastbuf = (pipe->curbuf + pipe->nrbufs - 1) &\n\t\t\t\t\t\t\t(pipe->buffers - 1);\n\t\tstruct pipe_buffer *buf = pipe->bufs + lastbuf;\n\t\tconst struct pipe_buf_operations *ops = buf->ops;\n\t\tint offset = buf->offset + buf->len;\n\n\t\tif (ops->can_merge && offset + chars <= PAGE_SIZE) {\n\t\t\tint error = ops->confirm(pipe, buf);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\n\t\t\tret = copy_page_from_iter(buf->page, offset, chars, from);\n\t\t\tif (unlikely(ret < chars)) {\n\t\t\t\terror = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tdo_wakeup = 1;\n\t\t\tbuf->len += chars;\n\t\t\tret = chars;\n\t\t\tif (!iov_iter_count(from))\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfor (;;) {\n\t\tint bufs;\n\n\t\tif (!pipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\t\tbufs = pipe->nrbufs;\n\t\tif (bufs < pipe->buffers) {\n\t\t\tint newbuf = (pipe->curbuf + bufs) & (pipe->buffers-1);\n\t\t\tstruct pipe_buffer *buf = pipe->bufs + newbuf;\n\t\t\tstruct page *page = pipe->tmp_page;\n\t\t\tint copied;\n\n\t\t\tif (!page) {\n\t\t\t\tpage = alloc_page(GFP_HIGHUSER);\n\t\t\t\tif (unlikely(!page)) {\n\t\t\t\t\tret = ret ? : -ENOMEM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpipe->tmp_page = page;\n\t\t\t}\n\t\t\t/* Always wake up, even if the copy fails. Otherwise\n\t\t\t * we lock up (O_NONBLOCK-)readers that sleep due to\n\t\t\t * syscall merging.\n\t\t\t * FIXME! Is this really true?\n\t\t\t */\n\t\t\tdo_wakeup = 1;\n\t\t\tcopied = copy_page_from_iter(page, 0, PAGE_SIZE, from);\n\t\t\tif (unlikely(copied < PAGE_SIZE && iov_iter_count(from))) {\n\t\t\t\tif (!ret)\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret += copied;\n\n\t\t\t/* Insert it into the buffer array */\n\t\t\tbuf->page = page;\n\t\t\tbuf->ops = &anon_pipe_buf_ops;\n\t\t\tbuf->offset = 0;\n\t\t\tbuf->len = copied;\n\t\t\tbuf->flags = 0;\n\t\t\tif (is_packetized(filp)) {\n\t\t\t\tbuf->ops = &packet_pipe_buf_ops;\n\t\t\t\tbuf->flags = PIPE_BUF_FLAG_PACKET;\n\t\t\t}\n\t\t\tpipe->nrbufs = ++bufs;\n\t\t\tpipe->tmp_page = NULL;\n\n\t\t\tif (!iov_iter_count(from))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (bufs < pipe->buffers)\n\t\t\tcontinue;\n\t\tif (filp->f_flags & O_NONBLOCK) {\n\t\t\tif (!ret)\n\t\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tif (signal_pending(current)) {\n\t\t\tif (!ret)\n\t\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tif (do_wakeup) {\n\t\t\twake_up_interruptible_sync_poll(&pipe->wait, POLLIN | POLLRDNORM);\n\t\t\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n\t\t\tdo_wakeup = 0;\n\t\t}\n\t\tpipe->waiting_writers++;\n\t\tpipe_wait(pipe);\n\t\tpipe->waiting_writers--;\n\t}\nout:\n\t__pipe_unlock(pipe);\n\tif (do_wakeup) {\n\t\twake_up_interruptible_sync_poll(&pipe->wait, POLLIN | POLLRDNORM);\n\t\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n\t}\n\tif (ret > 0 && sb_start_write_trylock(file_inode(filp)->i_sb)) {\n\t\tint err = file_update_time(filp);\n\t\tif (err)\n\t\t\tret = err;\n\t\tsb_end_write(file_inode(filp)->i_sb);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "is_packetized",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
    "lines": "333-336",
    "snippet": "static inline int is_packetized(struct file *file)\n{\n\treturn (file->f_flags & O_DIRECT) != 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline int is_packetized(struct file *file)\n{\n\treturn (file->f_flags & O_DIRECT) != 0;\n}"
  },
  {
    "function_name": "pipe_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
    "lines": "229-331",
    "snippet": "static ssize_t\npipe_read(struct kiocb *iocb, struct iov_iter *to)\n{\n\tsize_t total_len = iov_iter_count(to);\n\tstruct file *filp = iocb->ki_filp;\n\tstruct pipe_inode_info *pipe = filp->private_data;\n\tint do_wakeup;\n\tssize_t ret;\n\n\t/* Null read succeeds. */\n\tif (unlikely(total_len == 0))\n\t\treturn 0;\n\n\tdo_wakeup = 0;\n\tret = 0;\n\t__pipe_lock(pipe);\n\tfor (;;) {\n\t\tint bufs = pipe->nrbufs;\n\t\tif (bufs) {\n\t\t\tint curbuf = pipe->curbuf;\n\t\t\tstruct pipe_buffer *buf = pipe->bufs + curbuf;\n\t\t\tconst struct pipe_buf_operations *ops = buf->ops;\n\t\t\tsize_t chars = buf->len;\n\t\t\tsize_t written;\n\t\t\tint error;\n\n\t\t\tif (chars > total_len)\n\t\t\t\tchars = total_len;\n\n\t\t\terror = ops->confirm(pipe, buf);\n\t\t\tif (error) {\n\t\t\t\tif (!ret)\n\t\t\t\t\tret = error;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\twritten = copy_page_to_iter(buf->page, buf->offset, chars, to);\n\t\t\tif (unlikely(written < chars)) {\n\t\t\t\tif (!ret)\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret += chars;\n\t\t\tbuf->offset += chars;\n\t\t\tbuf->len -= chars;\n\n\t\t\t/* Was it a packet buffer? Clean up and exit */\n\t\t\tif (buf->flags & PIPE_BUF_FLAG_PACKET) {\n\t\t\t\ttotal_len = chars;\n\t\t\t\tbuf->len = 0;\n\t\t\t}\n\n\t\t\tif (!buf->len) {\n\t\t\t\tbuf->ops = NULL;\n\t\t\t\tops->release(pipe, buf);\n\t\t\t\tcurbuf = (curbuf + 1) & (pipe->buffers - 1);\n\t\t\t\tpipe->curbuf = curbuf;\n\t\t\t\tpipe->nrbufs = --bufs;\n\t\t\t\tdo_wakeup = 1;\n\t\t\t}\n\t\t\ttotal_len -= chars;\n\t\t\tif (!total_len)\n\t\t\t\tbreak;\t/* common path: read succeeded */\n\t\t}\n\t\tif (bufs)\t/* More to do? */\n\t\t\tcontinue;\n\t\tif (!pipe->writers)\n\t\t\tbreak;\n\t\tif (!pipe->waiting_writers) {\n\t\t\t/* syscall merging: Usually we must not sleep\n\t\t\t * if O_NONBLOCK is set, or if we got some data.\n\t\t\t * But if a writer sleeps in kernel space, then\n\t\t\t * we can wait for that data without violating POSIX.\n\t\t\t */\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tif (filp->f_flags & O_NONBLOCK) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (signal_pending(current)) {\n\t\t\tif (!ret)\n\t\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tif (do_wakeup) {\n\t\t\twake_up_interruptible_sync_poll(&pipe->wait, POLLOUT | POLLWRNORM);\n \t\t\tkill_fasync(&pipe->fasync_writers, SIGIO, POLL_OUT);\n\t\t}\n\t\tpipe_wait(pipe);\n\t}\n\t__pipe_unlock(pipe);\n\n\t/* Signal writers asynchronously that there is more room. */\n\tif (do_wakeup) {\n\t\twake_up_interruptible_sync_poll(&pipe->wait, POLLOUT | POLLWRNORM);\n\t\tkill_fasync(&pipe->fasync_writers, SIGIO, POLL_OUT);\n\t}\n\tif (ret > 0)\n\t\tfile_accessed(filp);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "file_accessed",
          "args": [
            "filp"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill_fasync",
          "args": [
            "&pipe->fasync_writers",
            "SIGIO",
            "POLL_OUT"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "kill_fasync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fcntl.c",
          "lines": "723-733",
          "snippet": "void kill_fasync(struct fasync_struct **fp, int sig, int band)\n{\n\t/* First a quick test without locking: usually\n\t * the list is empty.\n\t */\n\tif (*fp) {\n\t\trcu_read_lock();\n\t\tkill_fasync_rcu(rcu_dereference(*fp), sig, band);\n\t\trcu_read_unlock();\n\t}\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/poll.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/siginfo.h>\n#include <asm/poll.h>\n#include <linux/shmem_fs.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nvoid kill_fasync(struct fasync_struct **fp, int sig, int band)\n{\n\t/* First a quick test without locking: usually\n\t * the list is empty.\n\t */\n\tif (*fp) {\n\t\trcu_read_lock();\n\t\tkill_fasync_rcu(rcu_dereference(*fp), sig, band);\n\t\trcu_read_unlock();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_interruptible_sync_poll",
          "args": [
            "&pipe->wait",
            "POLLOUT | POLLWRNORM"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pipe_unlock",
          "args": [
            "pipe"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "84-87",
          "snippet": "static inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe_wait",
          "args": [
            "pipe"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "pipe_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "104-117",
          "snippet": "void pipe_wait(struct pipe_inode_info *pipe)\n{\n\tDEFINE_WAIT(wait);\n\n\t/*\n\t * Pipes are system-local resources, so sleeping on them\n\t * is considered a noninteractive wait:\n\t */\n\tprepare_to_wait(&pipe->wait, &wait, TASK_INTERRUPTIBLE);\n\tpipe_unlock(pipe);\n\tschedule();\n\tfinish_wait(&pipe->wait, &wait);\n\tpipe_lock(pipe);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nvoid pipe_wait(struct pipe_inode_info *pipe)\n{\n\tDEFINE_WAIT(wait);\n\n\t/*\n\t * Pipes are system-local resources, so sleeping on them\n\t * is considered a noninteractive wait:\n\t */\n\tprepare_to_wait(&pipe->wait, &wait, TASK_INTERRUPTIBLE);\n\tpipe_unlock(pipe);\n\tschedule();\n\tfinish_wait(&pipe->wait, &wait);\n\tpipe_lock(pipe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_interruptible_sync_poll",
          "args": [
            "&pipe->wait",
            "POLLOUT | POLLWRNORM"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->release",
          "args": [
            "pipe",
            "buf"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "written < chars"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_page_to_iter",
          "args": [
            "buf->page",
            "buf->offset",
            "chars",
            "to"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->confirm",
          "args": [
            "pipe",
            "buf"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pipe_lock",
          "args": [
            "pipe"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "79-82",
          "snippet": "static inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "total_len == 0"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "to"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic ssize_t\npipe_read(struct kiocb *iocb, struct iov_iter *to)\n{\n\tsize_t total_len = iov_iter_count(to);\n\tstruct file *filp = iocb->ki_filp;\n\tstruct pipe_inode_info *pipe = filp->private_data;\n\tint do_wakeup;\n\tssize_t ret;\n\n\t/* Null read succeeds. */\n\tif (unlikely(total_len == 0))\n\t\treturn 0;\n\n\tdo_wakeup = 0;\n\tret = 0;\n\t__pipe_lock(pipe);\n\tfor (;;) {\n\t\tint bufs = pipe->nrbufs;\n\t\tif (bufs) {\n\t\t\tint curbuf = pipe->curbuf;\n\t\t\tstruct pipe_buffer *buf = pipe->bufs + curbuf;\n\t\t\tconst struct pipe_buf_operations *ops = buf->ops;\n\t\t\tsize_t chars = buf->len;\n\t\t\tsize_t written;\n\t\t\tint error;\n\n\t\t\tif (chars > total_len)\n\t\t\t\tchars = total_len;\n\n\t\t\terror = ops->confirm(pipe, buf);\n\t\t\tif (error) {\n\t\t\t\tif (!ret)\n\t\t\t\t\tret = error;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\twritten = copy_page_to_iter(buf->page, buf->offset, chars, to);\n\t\t\tif (unlikely(written < chars)) {\n\t\t\t\tif (!ret)\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret += chars;\n\t\t\tbuf->offset += chars;\n\t\t\tbuf->len -= chars;\n\n\t\t\t/* Was it a packet buffer? Clean up and exit */\n\t\t\tif (buf->flags & PIPE_BUF_FLAG_PACKET) {\n\t\t\t\ttotal_len = chars;\n\t\t\t\tbuf->len = 0;\n\t\t\t}\n\n\t\t\tif (!buf->len) {\n\t\t\t\tbuf->ops = NULL;\n\t\t\t\tops->release(pipe, buf);\n\t\t\t\tcurbuf = (curbuf + 1) & (pipe->buffers - 1);\n\t\t\t\tpipe->curbuf = curbuf;\n\t\t\t\tpipe->nrbufs = --bufs;\n\t\t\t\tdo_wakeup = 1;\n\t\t\t}\n\t\t\ttotal_len -= chars;\n\t\t\tif (!total_len)\n\t\t\t\tbreak;\t/* common path: read succeeded */\n\t\t}\n\t\tif (bufs)\t/* More to do? */\n\t\t\tcontinue;\n\t\tif (!pipe->writers)\n\t\t\tbreak;\n\t\tif (!pipe->waiting_writers) {\n\t\t\t/* syscall merging: Usually we must not sleep\n\t\t\t * if O_NONBLOCK is set, or if we got some data.\n\t\t\t * But if a writer sleeps in kernel space, then\n\t\t\t * we can wait for that data without violating POSIX.\n\t\t\t */\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tif (filp->f_flags & O_NONBLOCK) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (signal_pending(current)) {\n\t\t\tif (!ret)\n\t\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tif (do_wakeup) {\n\t\t\twake_up_interruptible_sync_poll(&pipe->wait, POLLOUT | POLLWRNORM);\n \t\t\tkill_fasync(&pipe->fasync_writers, SIGIO, POLL_OUT);\n\t\t}\n\t\tpipe_wait(pipe);\n\t}\n\t__pipe_unlock(pipe);\n\n\t/* Signal writers asynchronously that there is more room. */\n\tif (do_wakeup) {\n\t\twake_up_interruptible_sync_poll(&pipe->wait, POLLOUT | POLLWRNORM);\n\t\tkill_fasync(&pipe->fasync_writers, SIGIO, POLL_OUT);\n\t}\n\tif (ret > 0)\n\t\tfile_accessed(filp);\n\treturn ret;\n}"
  },
  {
    "function_name": "generic_pipe_buf_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
    "lines": "206-210",
    "snippet": "void generic_pipe_buf_release(struct pipe_inode_info *pipe,\n\t\t\t      struct pipe_buffer *buf)\n{\n\tpage_cache_release(buf->page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "buf->page"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nvoid generic_pipe_buf_release(struct pipe_inode_info *pipe,\n\t\t\t      struct pipe_buffer *buf)\n{\n\tpage_cache_release(buf->page);\n}"
  },
  {
    "function_name": "generic_pipe_buf_confirm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
    "lines": "191-195",
    "snippet": "int generic_pipe_buf_confirm(struct pipe_inode_info *info,\n\t\t\t     struct pipe_buffer *buf)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nint generic_pipe_buf_confirm(struct pipe_inode_info *info,\n\t\t\t     struct pipe_buffer *buf)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "generic_pipe_buf_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
    "lines": "176-179",
    "snippet": "void generic_pipe_buf_get(struct pipe_inode_info *pipe, struct pipe_buffer *buf)\n{\n\tpage_cache_get(buf->page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_get",
          "args": [
            "buf->page"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nvoid generic_pipe_buf_get(struct pipe_inode_info *pipe, struct pipe_buffer *buf)\n{\n\tpage_cache_get(buf->page);\n}"
  },
  {
    "function_name": "generic_pipe_buf_steal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
    "lines": "147-163",
    "snippet": "int generic_pipe_buf_steal(struct pipe_inode_info *pipe,\n\t\t\t   struct pipe_buffer *buf)\n{\n\tstruct page *page = buf->page;\n\n\t/*\n\t * A reference of one is golden, that means that the owner of this\n\t * page is the only one holding a reference to it. lock the page\n\t * and return OK.\n\t */\n\tif (page_count(page) == 1) {\n\t\tlock_page(page);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lock_page",
          "args": [
            "page"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "page"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nint generic_pipe_buf_steal(struct pipe_inode_info *pipe,\n\t\t\t   struct pipe_buffer *buf)\n{\n\tstruct page *page = buf->page;\n\n\t/*\n\t * A reference of one is golden, that means that the owner of this\n\t * page is the only one holding a reference to it. lock the page\n\t * and return OK.\n\t */\n\tif (page_count(page) == 1) {\n\t\tlock_page(page);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "anon_pipe_buf_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
    "lines": "119-133",
    "snippet": "static void anon_pipe_buf_release(struct pipe_inode_info *pipe,\n\t\t\t\t  struct pipe_buffer *buf)\n{\n\tstruct page *page = buf->page;\n\n\t/*\n\t * If nobody else uses this page, and we don't already have a\n\t * temporary page, let's keep track of it as a one-deep\n\t * allocation cache. (Otherwise just release our reference to it)\n\t */\n\tif (page_count(page) == 1 && !pipe->tmp_page)\n\t\tpipe->tmp_page = page;\n\telse\n\t\tpage_cache_release(page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "page"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic void anon_pipe_buf_release(struct pipe_inode_info *pipe,\n\t\t\t\t  struct pipe_buffer *buf)\n{\n\tstruct page *page = buf->page;\n\n\t/*\n\t * If nobody else uses this page, and we don't already have a\n\t * temporary page, let's keep track of it as a one-deep\n\t * allocation cache. (Otherwise just release our reference to it)\n\t */\n\tif (page_count(page) == 1 && !pipe->tmp_page)\n\t\tpipe->tmp_page = page;\n\telse\n\t\tpage_cache_release(page);\n}"
  },
  {
    "function_name": "pipe_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
    "lines": "104-117",
    "snippet": "void pipe_wait(struct pipe_inode_info *pipe)\n{\n\tDEFINE_WAIT(wait);\n\n\t/*\n\t * Pipes are system-local resources, so sleeping on them\n\t * is considered a noninteractive wait:\n\t */\n\tprepare_to_wait(&pipe->wait, &wait, TASK_INTERRUPTIBLE);\n\tpipe_unlock(pipe);\n\tschedule();\n\tfinish_wait(&pipe->wait, &wait);\n\tpipe_lock(pipe);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pipe_lock",
          "args": [
            "pipe"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "79-82",
          "snippet": "static inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "&pipe->wait",
            "&wait"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe_unlock",
          "args": [
            "pipe"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "84-87",
          "snippet": "static inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_to_wait",
          "args": [
            "&pipe->wait",
            "&wait",
            "TASK_INTERRUPTIBLE"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT",
          "args": [
            "wait"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nvoid pipe_wait(struct pipe_inode_info *pipe)\n{\n\tDEFINE_WAIT(wait);\n\n\t/*\n\t * Pipes are system-local resources, so sleeping on them\n\t * is considered a noninteractive wait:\n\t */\n\tprepare_to_wait(&pipe->wait, &wait, TASK_INTERRUPTIBLE);\n\tpipe_unlock(pipe);\n\tschedule();\n\tfinish_wait(&pipe->wait, &wait);\n\tpipe_lock(pipe);\n}"
  },
  {
    "function_name": "pipe_double_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
    "lines": "89-101",
    "snippet": "void pipe_double_lock(struct pipe_inode_info *pipe1,\n\t\t      struct pipe_inode_info *pipe2)\n{\n\tBUG_ON(pipe1 == pipe2);\n\n\tif (pipe1 < pipe2) {\n\t\tpipe_lock_nested(pipe1, I_MUTEX_PARENT);\n\t\tpipe_lock_nested(pipe2, I_MUTEX_CHILD);\n\t} else {\n\t\tpipe_lock_nested(pipe2, I_MUTEX_PARENT);\n\t\tpipe_lock_nested(pipe1, I_MUTEX_CHILD);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pipe_lock_nested",
          "args": [
            "pipe1",
            "I_MUTEX_CHILD"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "pipe_lock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "57-61",
          "snippet": "static void pipe_lock_nested(struct pipe_inode_info *pipe, int subclass)\n{\n\tif (pipe->files)\n\t\tmutex_lock_nested(&pipe->mutex, subclass);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic void pipe_lock_nested(struct pipe_inode_info *pipe, int subclass)\n{\n\tif (pipe->files)\n\t\tmutex_lock_nested(&pipe->mutex, subclass);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "pipe1 == pipe2"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nvoid pipe_double_lock(struct pipe_inode_info *pipe1,\n\t\t      struct pipe_inode_info *pipe2)\n{\n\tBUG_ON(pipe1 == pipe2);\n\n\tif (pipe1 < pipe2) {\n\t\tpipe_lock_nested(pipe1, I_MUTEX_PARENT);\n\t\tpipe_lock_nested(pipe2, I_MUTEX_CHILD);\n\t} else {\n\t\tpipe_lock_nested(pipe2, I_MUTEX_PARENT);\n\t\tpipe_lock_nested(pipe1, I_MUTEX_CHILD);\n\t}\n}"
  },
  {
    "function_name": "__pipe_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
    "lines": "84-87",
    "snippet": "static inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&pipe->mutex"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}"
  },
  {
    "function_name": "__pipe_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
    "lines": "79-82",
    "snippet": "static inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&pipe->mutex",
            "I_MUTEX_PARENT"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}"
  },
  {
    "function_name": "pipe_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
    "lines": "72-76",
    "snippet": "void pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tif (pipe->files)\n\t\tmutex_unlock(&pipe->mutex);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&pipe->mutex"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nvoid pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tif (pipe->files)\n\t\tmutex_unlock(&pipe->mutex);\n}"
  },
  {
    "function_name": "pipe_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
    "lines": "63-69",
    "snippet": "void pipe_lock(struct pipe_inode_info *pipe)\n{\n\t/*\n\t * pipe_lock() nests non-pipe inode locks (for writing to a file)\n\t */\n\tpipe_lock_nested(pipe, I_MUTEX_PARENT);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pipe_lock_nested",
          "args": [
            "pipe",
            "I_MUTEX_PARENT"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "pipe_lock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "57-61",
          "snippet": "static void pipe_lock_nested(struct pipe_inode_info *pipe, int subclass)\n{\n\tif (pipe->files)\n\t\tmutex_lock_nested(&pipe->mutex, subclass);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic void pipe_lock_nested(struct pipe_inode_info *pipe, int subclass)\n{\n\tif (pipe->files)\n\t\tmutex_lock_nested(&pipe->mutex, subclass);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nvoid pipe_lock(struct pipe_inode_info *pipe)\n{\n\t/*\n\t * pipe_lock() nests non-pipe inode locks (for writing to a file)\n\t */\n\tpipe_lock_nested(pipe, I_MUTEX_PARENT);\n}"
  },
  {
    "function_name": "pipe_lock_nested",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
    "lines": "57-61",
    "snippet": "static void pipe_lock_nested(struct pipe_inode_info *pipe, int subclass)\n{\n\tif (pipe->files)\n\t\tmutex_lock_nested(&pipe->mutex, subclass);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/ioctls.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/audit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/uio.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/magic.h>",
      "#include <linux/mount.h>",
      "#include <linux/log2.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/poll.h>",
      "#include <linux/file.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&pipe->mutex",
            "subclass"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic void pipe_lock_nested(struct pipe_inode_info *pipe, int subclass)\n{\n\tif (pipe->files)\n\t\tmutex_lock_nested(&pipe->mutex, subclass);\n}"
  }
]