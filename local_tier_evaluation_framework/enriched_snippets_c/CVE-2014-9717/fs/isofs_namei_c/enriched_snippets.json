[
  {
    "function_name": "isofs_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/namei.c",
    "lines": "151-172",
    "snippet": "struct dentry *isofs_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\n{\n\tint found;\n\tunsigned long uninitialized_var(block);\n\tunsigned long uninitialized_var(offset);\n\tstruct inode *inode;\n\tstruct page *page;\n\n\tpage = alloc_page(GFP_USER);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfound = isofs_find_entry(dir, dentry,\n\t\t\t\t&block, &offset,\n\t\t\t\tpage_address(page),\n\t\t\t\t1024 + page_address(page));\n\t__free_page(page);\n\n\tinode = found ? isofs_iget(dir->i_sb, block, offset) : NULL;\n\n\treturn d_splice_alias(inode, dentry);\n}",
    "includes": [
      "#include \"isofs.h\"",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_splice_alias",
          "args": [
            "inode",
            "dentry"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "d_splice_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2741-2792",
          "snippet": "struct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nstruct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isofs_iget",
          "args": [
            "dir->i_sb",
            "block",
            "offset"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "isofs_iget_reloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/isofs.h",
          "lines": "133-138",
          "snippet": "static inline struct inode *isofs_iget_reloc(struct super_block *sb,\n\t\t\t\t\t     unsigned long block,\n\t\t\t\t\t     unsigned long offset)\n{\n\treturn __isofs_iget(sb, block, offset, 1);\n}",
          "includes": [
            "#include <asm/unaligned.h>",
            "#include <linux/iso_fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int get_rock_ridge_filename(struct iso_directory_record *, char *, struct inode *);",
            "extern int isofs_name_translate(struct iso_directory_record *, char *, struct inode *);",
            "int get_joliet_filename(struct iso_directory_record *, unsigned char *, struct inode *);",
            "int get_acorn_filename(struct iso_directory_record *, char *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unaligned.h>\n#include <linux/iso_fs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nextern int get_rock_ridge_filename(struct iso_directory_record *, char *, struct inode *);\nextern int isofs_name_translate(struct iso_directory_record *, char *, struct inode *);\nint get_joliet_filename(struct iso_directory_record *, unsigned char *, struct inode *);\nint get_acorn_filename(struct iso_directory_record *, char *, struct inode *);\n\nstatic inline struct inode *isofs_iget_reloc(struct super_block *sb,\n\t\t\t\t\t     unsigned long block,\n\t\t\t\t\t     unsigned long offset)\n{\n\treturn __isofs_iget(sb, block, offset, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "page"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isofs_find_entry",
          "args": [
            "dir",
            "dentry",
            "&block",
            "&offset",
            "page_address(page)",
            "1024 + page_address(page)"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "isofs_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/namei.c",
          "lines": "34-149",
          "snippet": "static unsigned long\nisofs_find_entry(struct inode *dir, struct dentry *dentry,\n\tunsigned long *block_rv, unsigned long *offset_rv,\n\tchar *tmpname, struct iso_directory_record *tmpde)\n{\n\tunsigned long bufsize = ISOFS_BUFFER_SIZE(dir);\n\tunsigned char bufbits = ISOFS_BUFFER_BITS(dir);\n\tunsigned long block, f_pos, offset, block_saved, offset_saved;\n\tstruct buffer_head *bh = NULL;\n\tstruct isofs_sb_info *sbi = ISOFS_SB(dir->i_sb);\n\n\tif (!ISOFS_I(dir)->i_first_extent)\n\t\treturn 0;\n\n\tf_pos = 0;\n\toffset = 0;\n\tblock = 0;\n\n\twhile (f_pos < dir->i_size) {\n\t\tstruct iso_directory_record *de;\n\t\tint de_len, match, i, dlen;\n\t\tchar *dpnt;\n\n\t\tif (!bh) {\n\t\t\tbh = isofs_bread(dir, block);\n\t\t\tif (!bh)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\tde = (struct iso_directory_record *) (bh->b_data + offset);\n\n\t\tde_len = *(unsigned char *) de;\n\t\tif (!de_len) {\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\tf_pos = (f_pos + ISOFS_BLOCK_SIZE) & ~(ISOFS_BLOCK_SIZE - 1);\n\t\t\tblock = f_pos >> bufbits;\n\t\t\toffset = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tblock_saved = bh->b_blocknr;\n\t\toffset_saved = offset;\n\t\toffset += de_len;\n\t\tf_pos += de_len;\n\n\t\t/* Make sure we have a full directory entry */\n\t\tif (offset >= bufsize) {\n\t\t\tint slop = bufsize - offset + de_len;\n\t\t\tmemcpy(tmpde, de, slop);\n\t\t\toffset &= bufsize - 1;\n\t\t\tblock++;\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\tif (offset) {\n\t\t\t\tbh = isofs_bread(dir, block);\n\t\t\t\tif (!bh)\n\t\t\t\t\treturn 0;\n\t\t\t\tmemcpy((void *) tmpde + slop, bh->b_data, offset);\n\t\t\t}\n\t\t\tde = tmpde;\n\t\t}\n\n\t\tdlen = de->name_len[0];\n\t\tdpnt = de->name;\n\t\t/* Basic sanity check, whether name doesn't exceed dir entry */\n\t\tif (de_len < dlen + sizeof(struct iso_directory_record)) {\n\t\t\tprintk(KERN_NOTICE \"iso9660: Corrupted directory entry\"\n\t\t\t       \" in block %lu of inode %lu\\n\", block,\n\t\t\t       dir->i_ino);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (sbi->s_rock &&\n\t\t    ((i = get_rock_ridge_filename(de, tmpname, dir)))) {\n\t\t\tdlen = i;\t/* possibly -1 */\n\t\t\tdpnt = tmpname;\n#ifdef CONFIG_JOLIET\n\t\t} else if (sbi->s_joliet_level) {\n\t\t\tdlen = get_joliet_filename(de, tmpname, dir);\n\t\t\tdpnt = tmpname;\n#endif\n\t\t} else if (sbi->s_mapping == 'a') {\n\t\t\tdlen = get_acorn_filename(de, tmpname, dir);\n\t\t\tdpnt = tmpname;\n\t\t} else if (sbi->s_mapping == 'n') {\n\t\t\tdlen = isofs_name_translate(de, tmpname, dir);\n\t\t\tdpnt = tmpname;\n\t\t}\n\n\t\t/*\n\t\t * Skip hidden or associated files unless hide or showassoc,\n\t\t * respectively, is set\n\t\t */\n\t\tmatch = 0;\n\t\tif (dlen > 0 &&\n\t\t\t(!sbi->s_hide ||\n\t\t\t\t(!(de->flags[-sbi->s_high_sierra] & 1))) &&\n\t\t\t(sbi->s_showassoc ||\n\t\t\t\t(!(de->flags[-sbi->s_high_sierra] & 4)))) {\n\t\t\tif (dpnt && (dlen > 1 || dpnt[0] > 1))\n\t\t\t\tmatch = (isofs_cmp(dentry, dpnt, dlen) == 0);\n\t\t}\n\t\tif (match) {\n\t\t\tisofs_normalize_block_and_offset(de,\n\t\t\t\t\t\t\t &block_saved,\n\t\t\t\t\t\t\t &offset_saved);\n\t\t\t*block_rv = block_saved;\n\t\t\t*offset_rv = offset_saved;\n\t\t\tbrelse(bh);\n\t\t\treturn 1;\n\t\t}\n\t}\n\tbrelse(bh);\n\treturn 0;\n}",
          "includes": [
            "#include \"isofs.h\"",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"isofs.h\"\n#include <linux/gfp.h>\n\nstatic unsigned long\nisofs_find_entry(struct inode *dir, struct dentry *dentry,\n\tunsigned long *block_rv, unsigned long *offset_rv,\n\tchar *tmpname, struct iso_directory_record *tmpde)\n{\n\tunsigned long bufsize = ISOFS_BUFFER_SIZE(dir);\n\tunsigned char bufbits = ISOFS_BUFFER_BITS(dir);\n\tunsigned long block, f_pos, offset, block_saved, offset_saved;\n\tstruct buffer_head *bh = NULL;\n\tstruct isofs_sb_info *sbi = ISOFS_SB(dir->i_sb);\n\n\tif (!ISOFS_I(dir)->i_first_extent)\n\t\treturn 0;\n\n\tf_pos = 0;\n\toffset = 0;\n\tblock = 0;\n\n\twhile (f_pos < dir->i_size) {\n\t\tstruct iso_directory_record *de;\n\t\tint de_len, match, i, dlen;\n\t\tchar *dpnt;\n\n\t\tif (!bh) {\n\t\t\tbh = isofs_bread(dir, block);\n\t\t\tif (!bh)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\tde = (struct iso_directory_record *) (bh->b_data + offset);\n\n\t\tde_len = *(unsigned char *) de;\n\t\tif (!de_len) {\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\tf_pos = (f_pos + ISOFS_BLOCK_SIZE) & ~(ISOFS_BLOCK_SIZE - 1);\n\t\t\tblock = f_pos >> bufbits;\n\t\t\toffset = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tblock_saved = bh->b_blocknr;\n\t\toffset_saved = offset;\n\t\toffset += de_len;\n\t\tf_pos += de_len;\n\n\t\t/* Make sure we have a full directory entry */\n\t\tif (offset >= bufsize) {\n\t\t\tint slop = bufsize - offset + de_len;\n\t\t\tmemcpy(tmpde, de, slop);\n\t\t\toffset &= bufsize - 1;\n\t\t\tblock++;\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\tif (offset) {\n\t\t\t\tbh = isofs_bread(dir, block);\n\t\t\t\tif (!bh)\n\t\t\t\t\treturn 0;\n\t\t\t\tmemcpy((void *) tmpde + slop, bh->b_data, offset);\n\t\t\t}\n\t\t\tde = tmpde;\n\t\t}\n\n\t\tdlen = de->name_len[0];\n\t\tdpnt = de->name;\n\t\t/* Basic sanity check, whether name doesn't exceed dir entry */\n\t\tif (de_len < dlen + sizeof(struct iso_directory_record)) {\n\t\t\tprintk(KERN_NOTICE \"iso9660: Corrupted directory entry\"\n\t\t\t       \" in block %lu of inode %lu\\n\", block,\n\t\t\t       dir->i_ino);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (sbi->s_rock &&\n\t\t    ((i = get_rock_ridge_filename(de, tmpname, dir)))) {\n\t\t\tdlen = i;\t/* possibly -1 */\n\t\t\tdpnt = tmpname;\n#ifdef CONFIG_JOLIET\n\t\t} else if (sbi->s_joliet_level) {\n\t\t\tdlen = get_joliet_filename(de, tmpname, dir);\n\t\t\tdpnt = tmpname;\n#endif\n\t\t} else if (sbi->s_mapping == 'a') {\n\t\t\tdlen = get_acorn_filename(de, tmpname, dir);\n\t\t\tdpnt = tmpname;\n\t\t} else if (sbi->s_mapping == 'n') {\n\t\t\tdlen = isofs_name_translate(de, tmpname, dir);\n\t\t\tdpnt = tmpname;\n\t\t}\n\n\t\t/*\n\t\t * Skip hidden or associated files unless hide or showassoc,\n\t\t * respectively, is set\n\t\t */\n\t\tmatch = 0;\n\t\tif (dlen > 0 &&\n\t\t\t(!sbi->s_hide ||\n\t\t\t\t(!(de->flags[-sbi->s_high_sierra] & 1))) &&\n\t\t\t(sbi->s_showassoc ||\n\t\t\t\t(!(de->flags[-sbi->s_high_sierra] & 4)))) {\n\t\t\tif (dpnt && (dlen > 1 || dpnt[0] > 1))\n\t\t\t\tmatch = (isofs_cmp(dentry, dpnt, dlen) == 0);\n\t\t}\n\t\tif (match) {\n\t\t\tisofs_normalize_block_and_offset(de,\n\t\t\t\t\t\t\t &block_saved,\n\t\t\t\t\t\t\t &offset_saved);\n\t\t\t*block_rv = block_saved;\n\t\t\t*offset_rv = offset_saved;\n\t\t\tbrelse(bh);\n\t\t\treturn 1;\n\t\t}\n\t}\n\tbrelse(bh);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_USER"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"isofs.h\"\n#include <linux/gfp.h>\n\nstruct dentry *isofs_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\n{\n\tint found;\n\tunsigned long uninitialized_var(block);\n\tunsigned long uninitialized_var(offset);\n\tstruct inode *inode;\n\tstruct page *page;\n\n\tpage = alloc_page(GFP_USER);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfound = isofs_find_entry(dir, dentry,\n\t\t\t\t&block, &offset,\n\t\t\t\tpage_address(page),\n\t\t\t\t1024 + page_address(page));\n\t__free_page(page);\n\n\tinode = found ? isofs_iget(dir->i_sb, block, offset) : NULL;\n\n\treturn d_splice_alias(inode, dentry);\n}"
  },
  {
    "function_name": "isofs_find_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/namei.c",
    "lines": "34-149",
    "snippet": "static unsigned long\nisofs_find_entry(struct inode *dir, struct dentry *dentry,\n\tunsigned long *block_rv, unsigned long *offset_rv,\n\tchar *tmpname, struct iso_directory_record *tmpde)\n{\n\tunsigned long bufsize = ISOFS_BUFFER_SIZE(dir);\n\tunsigned char bufbits = ISOFS_BUFFER_BITS(dir);\n\tunsigned long block, f_pos, offset, block_saved, offset_saved;\n\tstruct buffer_head *bh = NULL;\n\tstruct isofs_sb_info *sbi = ISOFS_SB(dir->i_sb);\n\n\tif (!ISOFS_I(dir)->i_first_extent)\n\t\treturn 0;\n\n\tf_pos = 0;\n\toffset = 0;\n\tblock = 0;\n\n\twhile (f_pos < dir->i_size) {\n\t\tstruct iso_directory_record *de;\n\t\tint de_len, match, i, dlen;\n\t\tchar *dpnt;\n\n\t\tif (!bh) {\n\t\t\tbh = isofs_bread(dir, block);\n\t\t\tif (!bh)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\tde = (struct iso_directory_record *) (bh->b_data + offset);\n\n\t\tde_len = *(unsigned char *) de;\n\t\tif (!de_len) {\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\tf_pos = (f_pos + ISOFS_BLOCK_SIZE) & ~(ISOFS_BLOCK_SIZE - 1);\n\t\t\tblock = f_pos >> bufbits;\n\t\t\toffset = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tblock_saved = bh->b_blocknr;\n\t\toffset_saved = offset;\n\t\toffset += de_len;\n\t\tf_pos += de_len;\n\n\t\t/* Make sure we have a full directory entry */\n\t\tif (offset >= bufsize) {\n\t\t\tint slop = bufsize - offset + de_len;\n\t\t\tmemcpy(tmpde, de, slop);\n\t\t\toffset &= bufsize - 1;\n\t\t\tblock++;\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\tif (offset) {\n\t\t\t\tbh = isofs_bread(dir, block);\n\t\t\t\tif (!bh)\n\t\t\t\t\treturn 0;\n\t\t\t\tmemcpy((void *) tmpde + slop, bh->b_data, offset);\n\t\t\t}\n\t\t\tde = tmpde;\n\t\t}\n\n\t\tdlen = de->name_len[0];\n\t\tdpnt = de->name;\n\t\t/* Basic sanity check, whether name doesn't exceed dir entry */\n\t\tif (de_len < dlen + sizeof(struct iso_directory_record)) {\n\t\t\tprintk(KERN_NOTICE \"iso9660: Corrupted directory entry\"\n\t\t\t       \" in block %lu of inode %lu\\n\", block,\n\t\t\t       dir->i_ino);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (sbi->s_rock &&\n\t\t    ((i = get_rock_ridge_filename(de, tmpname, dir)))) {\n\t\t\tdlen = i;\t/* possibly -1 */\n\t\t\tdpnt = tmpname;\n#ifdef CONFIG_JOLIET\n\t\t} else if (sbi->s_joliet_level) {\n\t\t\tdlen = get_joliet_filename(de, tmpname, dir);\n\t\t\tdpnt = tmpname;\n#endif\n\t\t} else if (sbi->s_mapping == 'a') {\n\t\t\tdlen = get_acorn_filename(de, tmpname, dir);\n\t\t\tdpnt = tmpname;\n\t\t} else if (sbi->s_mapping == 'n') {\n\t\t\tdlen = isofs_name_translate(de, tmpname, dir);\n\t\t\tdpnt = tmpname;\n\t\t}\n\n\t\t/*\n\t\t * Skip hidden or associated files unless hide or showassoc,\n\t\t * respectively, is set\n\t\t */\n\t\tmatch = 0;\n\t\tif (dlen > 0 &&\n\t\t\t(!sbi->s_hide ||\n\t\t\t\t(!(de->flags[-sbi->s_high_sierra] & 1))) &&\n\t\t\t(sbi->s_showassoc ||\n\t\t\t\t(!(de->flags[-sbi->s_high_sierra] & 4)))) {\n\t\t\tif (dpnt && (dlen > 1 || dpnt[0] > 1))\n\t\t\t\tmatch = (isofs_cmp(dentry, dpnt, dlen) == 0);\n\t\t}\n\t\tif (match) {\n\t\t\tisofs_normalize_block_and_offset(de,\n\t\t\t\t\t\t\t &block_saved,\n\t\t\t\t\t\t\t &offset_saved);\n\t\t\t*block_rv = block_saved;\n\t\t\t*offset_rv = offset_saved;\n\t\t\tbrelse(bh);\n\t\t\treturn 1;\n\t\t}\n\t}\n\tbrelse(bh);\n\treturn 0;\n}",
    "includes": [
      "#include \"isofs.h\"",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "isofs_normalize_block_and_offset",
          "args": [
            "de",
            "&block_saved",
            "&offset_saved"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "isofs_normalize_block_and_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/isofs.h",
          "lines": "182-193",
          "snippet": "static inline void\nisofs_normalize_block_and_offset(struct iso_directory_record* de,\n\t\t\t\t unsigned long *block,\n\t\t\t\t unsigned long *offset)\n{\n\t/* Only directories are normalized. */\n\tif (de->flags[0] & 2) {\n\t\t*offset = 0;\n\t\t*block = (unsigned long)isonum_733(de->extent)\n\t\t\t+ (unsigned long)isonum_711(de->ext_attr_length);\n\t}\n}",
          "includes": [
            "#include <asm/unaligned.h>",
            "#include <linux/iso_fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct dentry *isofs_lookup(struct inode *, struct dentry *, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unaligned.h>\n#include <linux/iso_fs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nextern struct dentry *isofs_lookup(struct inode *, struct dentry *, unsigned int flags);\n\nstatic inline void\nisofs_normalize_block_and_offset(struct iso_directory_record* de,\n\t\t\t\t unsigned long *block,\n\t\t\t\t unsigned long *offset)\n{\n\t/* Only directories are normalized. */\n\tif (de->flags[0] & 2) {\n\t\t*offset = 0;\n\t\t*block = (unsigned long)isonum_733(de->extent)\n\t\t\t+ (unsigned long)isonum_711(de->ext_attr_length);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "isofs_cmp",
          "args": [
            "dentry",
            "dpnt",
            "dlen"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "isofs_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/namei.c",
          "lines": "17-26",
          "snippet": "static int\nisofs_cmp(struct dentry *dentry, const char *compare, int dlen)\n{\n\tstruct qstr qstr;\n\tqstr.name = compare;\n\tqstr.len = dlen;\n\tif (likely(!dentry->d_op))\n\t\treturn dentry->d_name.len != dlen || memcmp(dentry->d_name.name, compare, dlen);\n\treturn dentry->d_op->d_compare(NULL, NULL, dentry->d_name.len, dentry->d_name.name, &qstr);\n}",
          "includes": [
            "#include \"isofs.h\"",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"isofs.h\"\n#include <linux/gfp.h>\n\nstatic int\nisofs_cmp(struct dentry *dentry, const char *compare, int dlen)\n{\n\tstruct qstr qstr;\n\tqstr.name = compare;\n\tqstr.len = dlen;\n\tif (likely(!dentry->d_op))\n\t\treturn dentry->d_name.len != dlen || memcmp(dentry->d_name.name, compare, dlen);\n\treturn dentry->d_op->d_compare(NULL, NULL, dentry->d_name.len, dentry->d_name.name, &qstr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "isofs_name_translate",
          "args": [
            "de",
            "tmpname",
            "dir"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "isofs_name_translate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/dir.c",
          "lines": "16-46",
          "snippet": "int isofs_name_translate(struct iso_directory_record *de, char *new, struct inode *inode)\n{\n\tchar * old = de->name;\n\tint len = de->name_len[0];\n\tint i;\n\n\tfor (i = 0; i < len; i++) {\n\t\tunsigned char c = old[i];\n\t\tif (!c)\n\t\t\tbreak;\n\n\t\tif (c >= 'A' && c <= 'Z')\n\t\t\tc |= 0x20;\t/* lower case */\n\n\t\t/* Drop trailing '.;1' (ISO 9660:1988 7.5.1 requires period) */\n\t\tif (c == '.' && i == len - 3 && old[i + 1] == ';' && old[i + 2] == '1')\n\t\t\tbreak;\n\n\t\t/* Drop trailing ';1' */\n\t\tif (c == ';' && i == len - 2 && old[i + 1] == '1')\n\t\t\tbreak;\n\n\t\t/* Convert remaining ';' to '.' */\n\t\t/* Also '/' to '.' (broken Acorn-generated ISO9660 images) */\n\t\tif (c == ';' || c == '/')\n\t\t\tc = '.';\n\n\t\tnew[i] = c;\n\t}\n\treturn i;\n}",
          "includes": [
            "#include \"isofs.h\"",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"isofs.h\"\n#include <linux/gfp.h>\n\nint isofs_name_translate(struct iso_directory_record *de, char *new, struct inode *inode)\n{\n\tchar * old = de->name;\n\tint len = de->name_len[0];\n\tint i;\n\n\tfor (i = 0; i < len; i++) {\n\t\tunsigned char c = old[i];\n\t\tif (!c)\n\t\t\tbreak;\n\n\t\tif (c >= 'A' && c <= 'Z')\n\t\t\tc |= 0x20;\t/* lower case */\n\n\t\t/* Drop trailing '.;1' (ISO 9660:1988 7.5.1 requires period) */\n\t\tif (c == '.' && i == len - 3 && old[i + 1] == ';' && old[i + 2] == '1')\n\t\t\tbreak;\n\n\t\t/* Drop trailing ';1' */\n\t\tif (c == ';' && i == len - 2 && old[i + 1] == '1')\n\t\t\tbreak;\n\n\t\t/* Convert remaining ';' to '.' */\n\t\t/* Also '/' to '.' (broken Acorn-generated ISO9660 images) */\n\t\tif (c == ';' || c == '/')\n\t\t\tc = '.';\n\n\t\tnew[i] = c;\n\t}\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_acorn_filename",
          "args": [
            "de",
            "tmpname",
            "dir"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "get_acorn_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/dir.c",
          "lines": "49-76",
          "snippet": "int get_acorn_filename(struct iso_directory_record *de,\n\t\t\t    char *retname, struct inode *inode)\n{\n\tint std;\n\tunsigned char *chr;\n\tint retnamlen = isofs_name_translate(de, retname, inode);\n\n\tif (retnamlen == 0)\n\t\treturn 0;\n\tstd = sizeof(struct iso_directory_record) + de->name_len[0];\n\tif (std & 1)\n\t\tstd++;\n\tif ((*((unsigned char *) de) - std) != 32)\n\t\treturn retnamlen;\n\tchr = ((unsigned char *) de) + std;\n\tif (strncmp(chr, \"ARCHIMEDES\", 10))\n\t\treturn retnamlen;\n\tif ((*retname == '_') && ((chr[19] & 1) == 1))\n\t\t*retname = '!';\n\tif (((de->flags[0] & 2) == 0) && (chr[13] == 0xff)\n\t\t&& ((chr[12] & 0xf0) == 0xf0)) {\n\t\tretname[retnamlen] = ',';\n\t\tsprintf(retname+retnamlen+1, \"%3.3x\",\n\t\t\t((chr[12] & 0xf) << 8) | chr[11]);\n\t\tretnamlen += 4;\n\t}\n\treturn retnamlen;\n}",
          "includes": [
            "#include \"isofs.h\"",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"isofs.h\"\n#include <linux/gfp.h>\n\nint get_acorn_filename(struct iso_directory_record *de,\n\t\t\t    char *retname, struct inode *inode)\n{\n\tint std;\n\tunsigned char *chr;\n\tint retnamlen = isofs_name_translate(de, retname, inode);\n\n\tif (retnamlen == 0)\n\t\treturn 0;\n\tstd = sizeof(struct iso_directory_record) + de->name_len[0];\n\tif (std & 1)\n\t\tstd++;\n\tif ((*((unsigned char *) de) - std) != 32)\n\t\treturn retnamlen;\n\tchr = ((unsigned char *) de) + std;\n\tif (strncmp(chr, \"ARCHIMEDES\", 10))\n\t\treturn retnamlen;\n\tif ((*retname == '_') && ((chr[19] & 1) == 1))\n\t\t*retname = '!';\n\tif (((de->flags[0] & 2) == 0) && (chr[13] == 0xff)\n\t\t&& ((chr[12] & 0xf0) == 0xf0)) {\n\t\tretname[retnamlen] = ',';\n\t\tsprintf(retname+retnamlen+1, \"%3.3x\",\n\t\t\t((chr[12] & 0xf) << 8) | chr[11]);\n\t\tretnamlen += 4;\n\t}\n\treturn retnamlen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_joliet_filename",
          "args": [
            "de",
            "tmpname",
            "dir"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "get_joliet_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/joliet.c",
          "lines": "40-69",
          "snippet": "int\nget_joliet_filename(struct iso_directory_record * de, unsigned char *outname, struct inode * inode)\n{\n\tunsigned char utf8;\n\tstruct nls_table *nls;\n\tunsigned char len = 0;\n\n\tutf8 = ISOFS_SB(inode->i_sb)->s_utf8;\n\tnls = ISOFS_SB(inode->i_sb)->s_nls_iocharset;\n\n\tif (utf8) {\n\t\tlen = utf16s_to_utf8s((const wchar_t *) de->name,\n\t\t\t\tde->name_len[0] >> 1, UTF16_BIG_ENDIAN,\n\t\t\t\toutname, PAGE_SIZE);\n\t} else {\n\t\tlen = uni16_to_x8(outname, (__be16 *) de->name,\n\t\t\t\tde->name_len[0] >> 1, nls);\n\t}\n\tif ((len > 2) && (outname[len-2] == ';') && (outname[len-1] == '1'))\n\t\tlen -= 2;\n\n\t/*\n\t * Windows doesn't like periods at the end of a name,\n\t * so neither do we\n\t */\n\twhile (len >= 2 && (outname[len-1] == '.'))\n\t\tlen--;\n\n\treturn len;\n}",
          "includes": [
            "#include \"isofs.h\"",
            "#include <linux/nls.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"isofs.h\"\n#include <linux/nls.h>\n#include <linux/types.h>\n\nint\nget_joliet_filename(struct iso_directory_record * de, unsigned char *outname, struct inode * inode)\n{\n\tunsigned char utf8;\n\tstruct nls_table *nls;\n\tunsigned char len = 0;\n\n\tutf8 = ISOFS_SB(inode->i_sb)->s_utf8;\n\tnls = ISOFS_SB(inode->i_sb)->s_nls_iocharset;\n\n\tif (utf8) {\n\t\tlen = utf16s_to_utf8s((const wchar_t *) de->name,\n\t\t\t\tde->name_len[0] >> 1, UTF16_BIG_ENDIAN,\n\t\t\t\toutname, PAGE_SIZE);\n\t} else {\n\t\tlen = uni16_to_x8(outname, (__be16 *) de->name,\n\t\t\t\tde->name_len[0] >> 1, nls);\n\t}\n\tif ((len > 2) && (outname[len-2] == ';') && (outname[len-1] == '1'))\n\t\tlen -= 2;\n\n\t/*\n\t * Windows doesn't like periods at the end of a name,\n\t * so neither do we\n\t */\n\twhile (len >= 2 && (outname[len-1] == '.'))\n\t\tlen--;\n\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_rock_ridge_filename",
          "args": [
            "de",
            "tmpname",
            "dir"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "get_rock_ridge_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/rock.c",
          "lines": "197-295",
          "snippet": "int get_rock_ridge_filename(struct iso_directory_record *de,\n\t\t\t    char *retname, struct inode *inode)\n{\n\tstruct rock_state rs;\n\tstruct rock_ridge *rr;\n\tint sig;\n\tint retnamlen = 0;\n\tint truncate = 0;\n\tint ret = 0;\n\n\tif (!ISOFS_SB(inode->i_sb)->s_rock)\n\t\treturn 0;\n\t*retname = 0;\n\n\tinit_rock_state(&rs, inode);\n\tsetup_rock_ridge(de, inode, &rs);\nrepeat:\n\n\twhile (rs.len > 2) { /* There may be one byte for padding somewhere */\n\t\trr = (struct rock_ridge *)rs.chr;\n\t\t/*\n\t\t * Ignore rock ridge info if rr->len is out of range, but\n\t\t * don't return -EIO because that would make the file\n\t\t * invisible.\n\t\t */\n\t\tif (rr->len < 3)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\t\tsig = isonum_721(rs.chr);\n\t\tif (rock_check_overflow(&rs, sig))\n\t\t\tgoto eio;\n\t\trs.chr += rr->len;\n\t\trs.len -= rr->len;\n\t\t/*\n\t\t * As above, just ignore the rock ridge info if rr->len\n\t\t * is bogus.\n\t\t */\n\t\tif (rs.len < 0)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\n\t\tswitch (sig) {\n\t\tcase SIG('R', 'R'):\n\t\t\tif ((rr->u.RR.flags[0] & RR_NM) == 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('S', 'P'):\n\t\t\tif (check_sp(rr, inode))\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('C', 'E'):\n\t\t\trs.cont_extent = isonum_733(rr->u.CE.extent);\n\t\t\trs.cont_offset = isonum_733(rr->u.CE.offset);\n\t\t\trs.cont_size = isonum_733(rr->u.CE.size);\n\t\t\tbreak;\n\t\tcase SIG('N', 'M'):\n\t\t\tif (truncate)\n\t\t\t\tbreak;\n\t\t\tif (rr->len < 5)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * If the flags are 2 or 4, this indicates '.' or '..'.\n\t\t\t * We don't want to do anything with this, because it\n\t\t\t * screws up the code that calls us.  We don't really\n\t\t\t * care anyways, since we can just use the non-RR\n\t\t\t * name.\n\t\t\t */\n\t\t\tif (rr->u.NM.flags & 6)\n\t\t\t\tbreak;\n\n\t\t\tif (rr->u.NM.flags & ~1) {\n\t\t\t\tprintk(\"Unsupported NM flag settings (%d)\\n\",\n\t\t\t\t\trr->u.NM.flags);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((strlen(retname) + rr->len - 5) >= 254) {\n\t\t\t\ttruncate = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstrncat(retname, rr->u.NM.name, rr->len - 5);\n\t\t\tretnamlen += rr->len - 5;\n\t\t\tbreak;\n\t\tcase SIG('R', 'E'):\n\t\t\tkfree(rs.buffer);\n\t\t\treturn -1;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tret = rock_continue(&rs);\n\tif (ret == 0)\n\t\tgoto repeat;\n\tif (ret == 1)\n\t\treturn retnamlen; /* If 0, this file did not have a NM field */\nout:\n\tkfree(rs.buffer);\n\treturn ret;\neio:\n\tret = -EIO;\n\tgoto out;\n}",
          "includes": [
            "#include \"rock.h\"",
            "#include \"isofs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rock.h\"\n#include \"isofs.h\"\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n\nint get_rock_ridge_filename(struct iso_directory_record *de,\n\t\t\t    char *retname, struct inode *inode)\n{\n\tstruct rock_state rs;\n\tstruct rock_ridge *rr;\n\tint sig;\n\tint retnamlen = 0;\n\tint truncate = 0;\n\tint ret = 0;\n\n\tif (!ISOFS_SB(inode->i_sb)->s_rock)\n\t\treturn 0;\n\t*retname = 0;\n\n\tinit_rock_state(&rs, inode);\n\tsetup_rock_ridge(de, inode, &rs);\nrepeat:\n\n\twhile (rs.len > 2) { /* There may be one byte for padding somewhere */\n\t\trr = (struct rock_ridge *)rs.chr;\n\t\t/*\n\t\t * Ignore rock ridge info if rr->len is out of range, but\n\t\t * don't return -EIO because that would make the file\n\t\t * invisible.\n\t\t */\n\t\tif (rr->len < 3)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\t\tsig = isonum_721(rs.chr);\n\t\tif (rock_check_overflow(&rs, sig))\n\t\t\tgoto eio;\n\t\trs.chr += rr->len;\n\t\trs.len -= rr->len;\n\t\t/*\n\t\t * As above, just ignore the rock ridge info if rr->len\n\t\t * is bogus.\n\t\t */\n\t\tif (rs.len < 0)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\n\t\tswitch (sig) {\n\t\tcase SIG('R', 'R'):\n\t\t\tif ((rr->u.RR.flags[0] & RR_NM) == 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('S', 'P'):\n\t\t\tif (check_sp(rr, inode))\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('C', 'E'):\n\t\t\trs.cont_extent = isonum_733(rr->u.CE.extent);\n\t\t\trs.cont_offset = isonum_733(rr->u.CE.offset);\n\t\t\trs.cont_size = isonum_733(rr->u.CE.size);\n\t\t\tbreak;\n\t\tcase SIG('N', 'M'):\n\t\t\tif (truncate)\n\t\t\t\tbreak;\n\t\t\tif (rr->len < 5)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * If the flags are 2 or 4, this indicates '.' or '..'.\n\t\t\t * We don't want to do anything with this, because it\n\t\t\t * screws up the code that calls us.  We don't really\n\t\t\t * care anyways, since we can just use the non-RR\n\t\t\t * name.\n\t\t\t */\n\t\t\tif (rr->u.NM.flags & 6)\n\t\t\t\tbreak;\n\n\t\t\tif (rr->u.NM.flags & ~1) {\n\t\t\t\tprintk(\"Unsupported NM flag settings (%d)\\n\",\n\t\t\t\t\trr->u.NM.flags);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((strlen(retname) + rr->len - 5) >= 254) {\n\t\t\t\ttruncate = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstrncat(retname, rr->u.NM.name, rr->len - 5);\n\t\t\tretnamlen += rr->len - 5;\n\t\t\tbreak;\n\t\tcase SIG('R', 'E'):\n\t\t\tkfree(rs.buffer);\n\t\t\treturn -1;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tret = rock_continue(&rs);\n\tif (ret == 0)\n\t\tgoto repeat;\n\tif (ret == 1)\n\t\treturn retnamlen; /* If 0, this file did not have a NM field */\nout:\n\tkfree(rs.buffer);\n\treturn ret;\neio:\n\tret = -EIO;\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_NOTICE \"iso9660: Corrupted directory entry\"\n\t\t\t       \" in block %lu of inode %lu\\n\"",
            "block",
            "dir->i_ino"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "__cachefiles_printk_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cachefiles/namei.c",
          "lines": "30-75",
          "snippet": "static noinline\nvoid __cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\tconst char *prefix,\n\t\t\t\tu8 *keybuf)\n{\n\tstruct fscache_cookie *cookie;\n\tunsigned keylen, loop;\n\n\tpr_err(\"%sobject: OBJ%x\\n\", prefix, object->fscache.debug_id);\n\tpr_err(\"%sobjstate=%s fl=%lx wbusy=%x ev=%lx[%lx]\\n\",\n\t       prefix, object->fscache.state->name,\n\t       object->fscache.flags, work_busy(&object->fscache.work),\n\t       object->fscache.events, object->fscache.event_mask);\n\tpr_err(\"%sops=%u inp=%u exc=%u\\n\",\n\t       prefix, object->fscache.n_ops, object->fscache.n_in_progress,\n\t       object->fscache.n_exclusive);\n\tpr_err(\"%sparent=%p\\n\",\n\t       prefix, object->fscache.parent);\n\n\tspin_lock(&object->fscache.lock);\n\tcookie = object->fscache.cookie;\n\tif (cookie) {\n\t\tpr_err(\"%scookie=%p [pr=%p nd=%p fl=%lx]\\n\",\n\t\t       prefix,\n\t\t       object->fscache.cookie,\n\t\t       object->fscache.cookie->parent,\n\t\t       object->fscache.cookie->netfs_data,\n\t\t       object->fscache.cookie->flags);\n\t\tif (keybuf && cookie->def)\n\t\t\tkeylen = cookie->def->get_key(cookie->netfs_data, keybuf,\n\t\t\t\t\t\t      CACHEFILES_KEYBUF_SIZE);\n\t\telse\n\t\t\tkeylen = 0;\n\t} else {\n\t\tpr_err(\"%scookie=NULL\\n\", prefix);\n\t\tkeylen = 0;\n\t}\n\tspin_unlock(&object->fscache.lock);\n\n\tif (keylen) {\n\t\tpr_err(\"%skey=[%u] '\", prefix, keylen);\n\t\tfor (loop = 0; loop < keylen; loop++)\n\t\t\tpr_cont(\"%02x\", keybuf[loop]);\n\t\tpr_cont(\"'\\n\");\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define CACHEFILES_KEYBUF_SIZE 512"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\n#define CACHEFILES_KEYBUF_SIZE 512\n\nstatic noinline\nvoid __cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\tconst char *prefix,\n\t\t\t\tu8 *keybuf)\n{\n\tstruct fscache_cookie *cookie;\n\tunsigned keylen, loop;\n\n\tpr_err(\"%sobject: OBJ%x\\n\", prefix, object->fscache.debug_id);\n\tpr_err(\"%sobjstate=%s fl=%lx wbusy=%x ev=%lx[%lx]\\n\",\n\t       prefix, object->fscache.state->name,\n\t       object->fscache.flags, work_busy(&object->fscache.work),\n\t       object->fscache.events, object->fscache.event_mask);\n\tpr_err(\"%sops=%u inp=%u exc=%u\\n\",\n\t       prefix, object->fscache.n_ops, object->fscache.n_in_progress,\n\t       object->fscache.n_exclusive);\n\tpr_err(\"%sparent=%p\\n\",\n\t       prefix, object->fscache.parent);\n\n\tspin_lock(&object->fscache.lock);\n\tcookie = object->fscache.cookie;\n\tif (cookie) {\n\t\tpr_err(\"%scookie=%p [pr=%p nd=%p fl=%lx]\\n\",\n\t\t       prefix,\n\t\t       object->fscache.cookie,\n\t\t       object->fscache.cookie->parent,\n\t\t       object->fscache.cookie->netfs_data,\n\t\t       object->fscache.cookie->flags);\n\t\tif (keybuf && cookie->def)\n\t\t\tkeylen = cookie->def->get_key(cookie->netfs_data, keybuf,\n\t\t\t\t\t\t      CACHEFILES_KEYBUF_SIZE);\n\t\telse\n\t\t\tkeylen = 0;\n\t} else {\n\t\tpr_err(\"%scookie=NULL\\n\", prefix);\n\t\tkeylen = 0;\n\t}\n\tspin_unlock(&object->fscache.lock);\n\n\tif (keylen) {\n\t\tpr_err(\"%skey=[%u] '\", prefix, keylen);\n\t\tfor (loop = 0; loop < keylen; loop++)\n\t\t\tpr_cont(\"%02x\", keybuf[loop]);\n\t\tpr_cont(\"'\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(void *) tmpde + slop",
            "bh->b_data",
            "offset"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isofs_bread",
          "args": [
            "dir",
            "block"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tmpde",
            "de",
            "slop"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isofs_bread",
          "args": [
            "dir",
            "block"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISOFS_I",
          "args": [
            "dir"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "ISOFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/isofs.h",
          "lines": "67-70",
          "snippet": "static inline struct iso_inode_info *ISOFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct iso_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <asm/unaligned.h>",
            "#include <linux/iso_fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int get_rock_ridge_filename(struct iso_directory_record *, char *, struct inode *);",
            "extern int isofs_name_translate(struct iso_directory_record *, char *, struct inode *);",
            "int get_joliet_filename(struct iso_directory_record *, unsigned char *, struct inode *);",
            "int get_acorn_filename(struct iso_directory_record *, char *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unaligned.h>\n#include <linux/iso_fs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nextern int get_rock_ridge_filename(struct iso_directory_record *, char *, struct inode *);\nextern int isofs_name_translate(struct iso_directory_record *, char *, struct inode *);\nint get_joliet_filename(struct iso_directory_record *, unsigned char *, struct inode *);\nint get_acorn_filename(struct iso_directory_record *, char *, struct inode *);\n\nstatic inline struct iso_inode_info *ISOFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct iso_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ISOFS_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "ISOFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/isofs.h",
          "lines": "62-65",
          "snippet": "static inline struct isofs_sb_info *ISOFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <asm/unaligned.h>",
            "#include <linux/iso_fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unaligned.h>\n#include <linux/iso_fs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline struct isofs_sb_info *ISOFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ISOFS_BUFFER_BITS",
          "args": [
            "dir"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISOFS_BUFFER_SIZE",
          "args": [
            "dir"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"isofs.h\"\n#include <linux/gfp.h>\n\nstatic unsigned long\nisofs_find_entry(struct inode *dir, struct dentry *dentry,\n\tunsigned long *block_rv, unsigned long *offset_rv,\n\tchar *tmpname, struct iso_directory_record *tmpde)\n{\n\tunsigned long bufsize = ISOFS_BUFFER_SIZE(dir);\n\tunsigned char bufbits = ISOFS_BUFFER_BITS(dir);\n\tunsigned long block, f_pos, offset, block_saved, offset_saved;\n\tstruct buffer_head *bh = NULL;\n\tstruct isofs_sb_info *sbi = ISOFS_SB(dir->i_sb);\n\n\tif (!ISOFS_I(dir)->i_first_extent)\n\t\treturn 0;\n\n\tf_pos = 0;\n\toffset = 0;\n\tblock = 0;\n\n\twhile (f_pos < dir->i_size) {\n\t\tstruct iso_directory_record *de;\n\t\tint de_len, match, i, dlen;\n\t\tchar *dpnt;\n\n\t\tif (!bh) {\n\t\t\tbh = isofs_bread(dir, block);\n\t\t\tif (!bh)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\tde = (struct iso_directory_record *) (bh->b_data + offset);\n\n\t\tde_len = *(unsigned char *) de;\n\t\tif (!de_len) {\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\tf_pos = (f_pos + ISOFS_BLOCK_SIZE) & ~(ISOFS_BLOCK_SIZE - 1);\n\t\t\tblock = f_pos >> bufbits;\n\t\t\toffset = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tblock_saved = bh->b_blocknr;\n\t\toffset_saved = offset;\n\t\toffset += de_len;\n\t\tf_pos += de_len;\n\n\t\t/* Make sure we have a full directory entry */\n\t\tif (offset >= bufsize) {\n\t\t\tint slop = bufsize - offset + de_len;\n\t\t\tmemcpy(tmpde, de, slop);\n\t\t\toffset &= bufsize - 1;\n\t\t\tblock++;\n\t\t\tbrelse(bh);\n\t\t\tbh = NULL;\n\t\t\tif (offset) {\n\t\t\t\tbh = isofs_bread(dir, block);\n\t\t\t\tif (!bh)\n\t\t\t\t\treturn 0;\n\t\t\t\tmemcpy((void *) tmpde + slop, bh->b_data, offset);\n\t\t\t}\n\t\t\tde = tmpde;\n\t\t}\n\n\t\tdlen = de->name_len[0];\n\t\tdpnt = de->name;\n\t\t/* Basic sanity check, whether name doesn't exceed dir entry */\n\t\tif (de_len < dlen + sizeof(struct iso_directory_record)) {\n\t\t\tprintk(KERN_NOTICE \"iso9660: Corrupted directory entry\"\n\t\t\t       \" in block %lu of inode %lu\\n\", block,\n\t\t\t       dir->i_ino);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (sbi->s_rock &&\n\t\t    ((i = get_rock_ridge_filename(de, tmpname, dir)))) {\n\t\t\tdlen = i;\t/* possibly -1 */\n\t\t\tdpnt = tmpname;\n#ifdef CONFIG_JOLIET\n\t\t} else if (sbi->s_joliet_level) {\n\t\t\tdlen = get_joliet_filename(de, tmpname, dir);\n\t\t\tdpnt = tmpname;\n#endif\n\t\t} else if (sbi->s_mapping == 'a') {\n\t\t\tdlen = get_acorn_filename(de, tmpname, dir);\n\t\t\tdpnt = tmpname;\n\t\t} else if (sbi->s_mapping == 'n') {\n\t\t\tdlen = isofs_name_translate(de, tmpname, dir);\n\t\t\tdpnt = tmpname;\n\t\t}\n\n\t\t/*\n\t\t * Skip hidden or associated files unless hide or showassoc,\n\t\t * respectively, is set\n\t\t */\n\t\tmatch = 0;\n\t\tif (dlen > 0 &&\n\t\t\t(!sbi->s_hide ||\n\t\t\t\t(!(de->flags[-sbi->s_high_sierra] & 1))) &&\n\t\t\t(sbi->s_showassoc ||\n\t\t\t\t(!(de->flags[-sbi->s_high_sierra] & 4)))) {\n\t\t\tif (dpnt && (dlen > 1 || dpnt[0] > 1))\n\t\t\t\tmatch = (isofs_cmp(dentry, dpnt, dlen) == 0);\n\t\t}\n\t\tif (match) {\n\t\t\tisofs_normalize_block_and_offset(de,\n\t\t\t\t\t\t\t &block_saved,\n\t\t\t\t\t\t\t &offset_saved);\n\t\t\t*block_rv = block_saved;\n\t\t\t*offset_rv = offset_saved;\n\t\t\tbrelse(bh);\n\t\t\treturn 1;\n\t\t}\n\t}\n\tbrelse(bh);\n\treturn 0;\n}"
  },
  {
    "function_name": "isofs_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/namei.c",
    "lines": "17-26",
    "snippet": "static int\nisofs_cmp(struct dentry *dentry, const char *compare, int dlen)\n{\n\tstruct qstr qstr;\n\tqstr.name = compare;\n\tqstr.len = dlen;\n\tif (likely(!dentry->d_op))\n\t\treturn dentry->d_name.len != dlen || memcmp(dentry->d_name.name, compare, dlen);\n\treturn dentry->d_op->d_compare(NULL, NULL, dentry->d_name.len, dentry->d_name.name, &qstr);\n}",
    "includes": [
      "#include \"isofs.h\"",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dentry->d_op->d_compare",
          "args": [
            "NULL",
            "NULL",
            "dentry->d_name.len",
            "dentry->d_name.name",
            "&qstr"
          ],
          "line": 25
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "dentry->d_name.name",
            "compare",
            "dlen"
          ],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!dentry->d_op"
          ],
          "line": 23
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"isofs.h\"\n#include <linux/gfp.h>\n\nstatic int\nisofs_cmp(struct dentry *dentry, const char *compare, int dlen)\n{\n\tstruct qstr qstr;\n\tqstr.name = compare;\n\tqstr.len = dlen;\n\tif (likely(!dentry->d_op))\n\t\treturn dentry->d_name.len != dlen || memcmp(dentry->d_name.name, compare, dlen);\n\treturn dentry->d_op->d_compare(NULL, NULL, dentry->d_name.len, dentry->d_name.name, &qstr);\n}"
  }
]