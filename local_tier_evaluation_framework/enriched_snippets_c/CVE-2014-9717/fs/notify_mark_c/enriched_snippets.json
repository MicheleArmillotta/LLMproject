[
  {
    "function_name": "fsnotify_mark_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
    "lines": "483-493",
    "snippet": "static int __init fsnotify_mark_init(void)\n{\n\tstruct task_struct *thread;\n\n\tthread = kthread_run(fsnotify_mark_destroy, NULL,\n\t\t\t     \"fsnotify_mark\");\n\tif (IS_ERR(thread))\n\t\tpanic(\"unable to start fsnotify mark destruction thread.\");\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fsnotify.h\"",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/atomic.h>",
      "#include <linux/srcu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"unable to start fsnotify mark destruction thread.\""
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "thread"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "fsnotify_mark_destroy",
            "NULL",
            "\"fsnotify_mark\""
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstatic int __init fsnotify_mark_init(void)\n{\n\tstruct task_struct *thread;\n\n\tthread = kthread_run(fsnotify_mark_destroy, NULL,\n\t\t\t     \"fsnotify_mark\");\n\tif (IS_ERR(thread))\n\t\tpanic(\"unable to start fsnotify mark destruction thread.\");\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fsnotify_mark_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
    "lines": "459-481",
    "snippet": "static int fsnotify_mark_destroy(void *ignored)\n{\n\tstruct fsnotify_mark *mark, *next;\n\tstruct list_head private_destroy_list;\n\n\tfor (;;) {\n\t\tspin_lock(&destroy_lock);\n\t\t/* exchange the list head */\n\t\tlist_replace_init(&destroy_list, &private_destroy_list);\n\t\tspin_unlock(&destroy_lock);\n\n\t\tsynchronize_srcu(&fsnotify_mark_srcu);\n\n\t\tlist_for_each_entry_safe(mark, next, &private_destroy_list, g_list) {\n\t\t\tlist_del_init(&mark->g_list);\n\t\t\tfsnotify_put_mark(mark);\n\t\t}\n\n\t\twait_event_interruptible(destroy_waitq, !list_empty(&destroy_list));\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fsnotify.h\"",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/atomic.h>",
      "#include <linux/srcu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct srcu_struct fsnotify_mark_srcu;",
      "static DEFINE_SPINLOCK(destroy_lock);",
      "static LIST_HEAD(destroy_list);",
      "static DECLARE_WAIT_QUEUE_HEAD(destroy_waitq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_event_interruptible",
          "args": [
            "destroy_waitq",
            "!list_empty(&destroy_list)"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&destroy_list"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_put_mark",
          "args": [
            "mark"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_put_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
          "lines": "104-111",
          "snippet": "void fsnotify_put_mark(struct fsnotify_mark *mark)\n{\n\tif (atomic_dec_and_test(&mark->refcnt)) {\n\t\tif (mark->group)\n\t\t\tfsnotify_put_group(mark->group);\n\t\tmark->free_mark(mark);\n\t}\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/srcu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_put_mark(struct fsnotify_mark *mark)\n{\n\tif (atomic_dec_and_test(&mark->refcnt)) {\n\t\tif (mark->group)\n\t\t\tfsnotify_put_group(mark->group);\n\t\tmark->free_mark(mark);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&mark->g_list"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "mark",
            "next",
            "&private_destroy_list",
            "g_list"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synchronize_srcu",
          "args": [
            "&fsnotify_mark_srcu"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&destroy_lock"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_replace_init",
          "args": [
            "&destroy_list",
            "&private_destroy_list"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&destroy_lock"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstruct srcu_struct fsnotify_mark_srcu;\nstatic DEFINE_SPINLOCK(destroy_lock);\nstatic LIST_HEAD(destroy_list);\nstatic DECLARE_WAIT_QUEUE_HEAD(destroy_waitq);\n\nstatic int fsnotify_mark_destroy(void *ignored)\n{\n\tstruct fsnotify_mark *mark, *next;\n\tstruct list_head private_destroy_list;\n\n\tfor (;;) {\n\t\tspin_lock(&destroy_lock);\n\t\t/* exchange the list head */\n\t\tlist_replace_init(&destroy_list, &private_destroy_list);\n\t\tspin_unlock(&destroy_lock);\n\n\t\tsynchronize_srcu(&fsnotify_mark_srcu);\n\n\t\tlist_for_each_entry_safe(mark, next, &private_destroy_list, g_list) {\n\t\t\tlist_del_init(&mark->g_list);\n\t\t\tfsnotify_put_mark(mark);\n\t\t}\n\n\t\twait_event_interruptible(destroy_waitq, !list_empty(&destroy_list));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fsnotify_init_mark",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
    "lines": "450-457",
    "snippet": "void fsnotify_init_mark(struct fsnotify_mark *mark,\n\t\t\tvoid (*free_mark)(struct fsnotify_mark *mark))\n{\n\tmemset(mark, 0, sizeof(*mark));\n\tspin_lock_init(&mark->lock);\n\tatomic_set(&mark->refcnt, 1);\n\tmark->free_mark = free_mark;\n}",
    "includes": [
      "#include \"fsnotify.h\"",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/atomic.h>",
      "#include <linux/srcu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&mark->refcnt",
            "1"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&mark->lock"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "mark",
            "0",
            "sizeof(*mark)"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_init_mark(struct fsnotify_mark *mark,\n\t\t\tvoid (*free_mark)(struct fsnotify_mark *mark))\n{\n\tmemset(mark, 0, sizeof(*mark));\n\tspin_lock_init(&mark->lock);\n\tatomic_set(&mark->refcnt, 1);\n\tmark->free_mark = free_mark;\n}"
  },
  {
    "function_name": "fsnotify_duplicate_mark",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
    "lines": "435-445",
    "snippet": "void fsnotify_duplicate_mark(struct fsnotify_mark *new, struct fsnotify_mark *old)\n{\n\tassert_spin_locked(&old->lock);\n\tnew->inode = old->inode;\n\tnew->mnt = old->mnt;\n\tif (old->group)\n\t\tfsnotify_get_group(old->group);\n\tnew->group = old->group;\n\tnew->mask = old->mask;\n\tnew->free_mark = old->free_mark;\n}",
    "includes": [
      "#include \"fsnotify.h\"",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/atomic.h>",
      "#include <linux/srcu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsnotify_get_group",
          "args": [
            "old->group"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_get_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/group.c",
          "lines": "71-74",
          "snippet": "void fsnotify_get_group(struct fsnotify_group *group)\n{\n\tatomic_inc(&group->refcnt);\n}",
          "includes": [
            "#include <linux/atomic.h>",
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/wait.h>",
            "#include <linux/rculist.h>",
            "#include <linux/srcu.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/atomic.h>\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/wait.h>\n#include <linux/rculist.h>\n#include <linux/srcu.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n\nvoid fsnotify_get_group(struct fsnotify_group *group)\n{\n\tatomic_inc(&group->refcnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&old->lock"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_duplicate_mark(struct fsnotify_mark *new, struct fsnotify_mark *old)\n{\n\tassert_spin_locked(&old->lock);\n\tnew->inode = old->inode;\n\tnew->mnt = old->mnt;\n\tif (old->group)\n\t\tfsnotify_get_group(old->group);\n\tnew->group = old->group;\n\tnew->mask = old->mask;\n\tnew->free_mark = old->free_mark;\n}"
  },
  {
    "function_name": "fsnotify_clear_marks_by_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
    "lines": "430-433",
    "snippet": "void fsnotify_clear_marks_by_group(struct fsnotify_group *group)\n{\n\tfsnotify_clear_marks_by_group_flags(group, (unsigned int)-1);\n}",
    "includes": [
      "#include \"fsnotify.h\"",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/atomic.h>",
      "#include <linux/srcu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsnotify_clear_marks_by_group_flags",
          "args": [
            "group",
            "(unsigned int)-1"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_clear_marks_by_group_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
          "lines": "411-425",
          "snippet": "void fsnotify_clear_marks_by_group_flags(struct fsnotify_group *group,\n\t\t\t\t\t unsigned int flags)\n{\n\tstruct fsnotify_mark *lmark, *mark;\n\n\tmutex_lock_nested(&group->mark_mutex, SINGLE_DEPTH_NESTING);\n\tlist_for_each_entry_safe(mark, lmark, &group->marks_list, g_list) {\n\t\tif (mark->flags & flags) {\n\t\t\tfsnotify_get_mark(mark);\n\t\t\tfsnotify_destroy_mark_locked(mark, group);\n\t\t\tfsnotify_put_mark(mark);\n\t\t}\n\t}\n\tmutex_unlock(&group->mark_mutex);\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/srcu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_clear_marks_by_group_flags(struct fsnotify_group *group,\n\t\t\t\t\t unsigned int flags)\n{\n\tstruct fsnotify_mark *lmark, *mark;\n\n\tmutex_lock_nested(&group->mark_mutex, SINGLE_DEPTH_NESTING);\n\tlist_for_each_entry_safe(mark, lmark, &group->marks_list, g_list) {\n\t\tif (mark->flags & flags) {\n\t\t\tfsnotify_get_mark(mark);\n\t\t\tfsnotify_destroy_mark_locked(mark, group);\n\t\t\tfsnotify_put_mark(mark);\n\t\t}\n\t}\n\tmutex_unlock(&group->mark_mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_clear_marks_by_group(struct fsnotify_group *group)\n{\n\tfsnotify_clear_marks_by_group_flags(group, (unsigned int)-1);\n}"
  },
  {
    "function_name": "fsnotify_clear_marks_by_group_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
    "lines": "411-425",
    "snippet": "void fsnotify_clear_marks_by_group_flags(struct fsnotify_group *group,\n\t\t\t\t\t unsigned int flags)\n{\n\tstruct fsnotify_mark *lmark, *mark;\n\n\tmutex_lock_nested(&group->mark_mutex, SINGLE_DEPTH_NESTING);\n\tlist_for_each_entry_safe(mark, lmark, &group->marks_list, g_list) {\n\t\tif (mark->flags & flags) {\n\t\t\tfsnotify_get_mark(mark);\n\t\t\tfsnotify_destroy_mark_locked(mark, group);\n\t\t\tfsnotify_put_mark(mark);\n\t\t}\n\t}\n\tmutex_unlock(&group->mark_mutex);\n}",
    "includes": [
      "#include \"fsnotify.h\"",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/atomic.h>",
      "#include <linux/srcu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&group->mark_mutex"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_put_mark",
          "args": [
            "mark"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_put_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
          "lines": "104-111",
          "snippet": "void fsnotify_put_mark(struct fsnotify_mark *mark)\n{\n\tif (atomic_dec_and_test(&mark->refcnt)) {\n\t\tif (mark->group)\n\t\t\tfsnotify_put_group(mark->group);\n\t\tmark->free_mark(mark);\n\t}\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/srcu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_put_mark(struct fsnotify_mark *mark)\n{\n\tif (atomic_dec_and_test(&mark->refcnt)) {\n\t\tif (mark->group)\n\t\t\tfsnotify_put_group(mark->group);\n\t\tmark->free_mark(mark);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_destroy_mark_locked",
          "args": [
            "mark",
            "group"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_destroy_mark_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
          "lines": "129-196",
          "snippet": "void fsnotify_destroy_mark_locked(struct fsnotify_mark *mark,\n\t\t\t\t  struct fsnotify_group *group)\n{\n\tstruct inode *inode = NULL;\n\n\tBUG_ON(!mutex_is_locked(&group->mark_mutex));\n\n\tspin_lock(&mark->lock);\n\n\t/* something else already called this function on this mark */\n\tif (!(mark->flags & FSNOTIFY_MARK_FLAG_ALIVE)) {\n\t\tspin_unlock(&mark->lock);\n\t\treturn;\n\t}\n\n\tmark->flags &= ~FSNOTIFY_MARK_FLAG_ALIVE;\n\n\tif (mark->flags & FSNOTIFY_MARK_FLAG_INODE) {\n\t\tinode = mark->inode;\n\t\tfsnotify_destroy_inode_mark(mark);\n\t} else if (mark->flags & FSNOTIFY_MARK_FLAG_VFSMOUNT)\n\t\tfsnotify_destroy_vfsmount_mark(mark);\n\telse\n\t\tBUG();\n\n\tlist_del_init(&mark->g_list);\n\n\tspin_unlock(&mark->lock);\n\n\tif (inode && (mark->flags & FSNOTIFY_MARK_FLAG_OBJECT_PINNED))\n\t\tiput(inode);\n\t/* release lock temporarily */\n\tmutex_unlock(&group->mark_mutex);\n\n\tspin_lock(&destroy_lock);\n\tlist_add(&mark->g_list, &destroy_list);\n\tspin_unlock(&destroy_lock);\n\twake_up(&destroy_waitq);\n\t/*\n\t * We don't necessarily have a ref on mark from caller so the above destroy\n\t * may have actually freed it, unless this group provides a 'freeing_mark'\n\t * function which must be holding a reference.\n\t */\n\n\t/*\n\t * Some groups like to know that marks are being freed.  This is a\n\t * callback to the group function to let it know that this mark\n\t * is being freed.\n\t */\n\tif (group->ops->freeing_mark)\n\t\tgroup->ops->freeing_mark(mark, group);\n\n\t/*\n\t * __fsnotify_update_child_dentry_flags(inode);\n\t *\n\t * I really want to call that, but we can't, we have no idea if the inode\n\t * still exists the second we drop the mark->lock.\n\t *\n\t * The next time an event arrive to this inode from one of it's children\n\t * __fsnotify_parent will see that the inode doesn't care about it's\n\t * children and will update all of these flags then.  So really this\n\t * is just a lazy update (and could be a perf win...)\n\t */\n\n\tatomic_dec(&group->num_marks);\n\n\tmutex_lock_nested(&group->mark_mutex, SINGLE_DEPTH_NESTING);\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/srcu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(destroy_lock);",
            "static LIST_HEAD(destroy_list);",
            "static DECLARE_WAIT_QUEUE_HEAD(destroy_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstatic DEFINE_SPINLOCK(destroy_lock);\nstatic LIST_HEAD(destroy_list);\nstatic DECLARE_WAIT_QUEUE_HEAD(destroy_waitq);\n\nvoid fsnotify_destroy_mark_locked(struct fsnotify_mark *mark,\n\t\t\t\t  struct fsnotify_group *group)\n{\n\tstruct inode *inode = NULL;\n\n\tBUG_ON(!mutex_is_locked(&group->mark_mutex));\n\n\tspin_lock(&mark->lock);\n\n\t/* something else already called this function on this mark */\n\tif (!(mark->flags & FSNOTIFY_MARK_FLAG_ALIVE)) {\n\t\tspin_unlock(&mark->lock);\n\t\treturn;\n\t}\n\n\tmark->flags &= ~FSNOTIFY_MARK_FLAG_ALIVE;\n\n\tif (mark->flags & FSNOTIFY_MARK_FLAG_INODE) {\n\t\tinode = mark->inode;\n\t\tfsnotify_destroy_inode_mark(mark);\n\t} else if (mark->flags & FSNOTIFY_MARK_FLAG_VFSMOUNT)\n\t\tfsnotify_destroy_vfsmount_mark(mark);\n\telse\n\t\tBUG();\n\n\tlist_del_init(&mark->g_list);\n\n\tspin_unlock(&mark->lock);\n\n\tif (inode && (mark->flags & FSNOTIFY_MARK_FLAG_OBJECT_PINNED))\n\t\tiput(inode);\n\t/* release lock temporarily */\n\tmutex_unlock(&group->mark_mutex);\n\n\tspin_lock(&destroy_lock);\n\tlist_add(&mark->g_list, &destroy_list);\n\tspin_unlock(&destroy_lock);\n\twake_up(&destroy_waitq);\n\t/*\n\t * We don't necessarily have a ref on mark from caller so the above destroy\n\t * may have actually freed it, unless this group provides a 'freeing_mark'\n\t * function which must be holding a reference.\n\t */\n\n\t/*\n\t * Some groups like to know that marks are being freed.  This is a\n\t * callback to the group function to let it know that this mark\n\t * is being freed.\n\t */\n\tif (group->ops->freeing_mark)\n\t\tgroup->ops->freeing_mark(mark, group);\n\n\t/*\n\t * __fsnotify_update_child_dentry_flags(inode);\n\t *\n\t * I really want to call that, but we can't, we have no idea if the inode\n\t * still exists the second we drop the mark->lock.\n\t *\n\t * The next time an event arrive to this inode from one of it's children\n\t * __fsnotify_parent will see that the inode doesn't care about it's\n\t * children and will update all of these flags then.  So really this\n\t * is just a lazy update (and could be a perf win...)\n\t */\n\n\tatomic_dec(&group->num_marks);\n\n\tmutex_lock_nested(&group->mark_mutex, SINGLE_DEPTH_NESTING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_get_mark",
          "args": [
            "mark"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_get_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
          "lines": "99-102",
          "snippet": "void fsnotify_get_mark(struct fsnotify_mark *mark)\n{\n\tatomic_inc(&mark->refcnt);\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/srcu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_get_mark(struct fsnotify_mark *mark)\n{\n\tatomic_inc(&mark->refcnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "mark",
            "lmark",
            "&group->marks_list",
            "g_list"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&group->mark_mutex",
            "SINGLE_DEPTH_NESTING"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_clear_marks_by_group_flags(struct fsnotify_group *group,\n\t\t\t\t\t unsigned int flags)\n{\n\tstruct fsnotify_mark *lmark, *mark;\n\n\tmutex_lock_nested(&group->mark_mutex, SINGLE_DEPTH_NESTING);\n\tlist_for_each_entry_safe(mark, lmark, &group->marks_list, g_list) {\n\t\tif (mark->flags & flags) {\n\t\t\tfsnotify_get_mark(mark);\n\t\t\tfsnotify_destroy_mark_locked(mark, group);\n\t\t\tfsnotify_put_mark(mark);\n\t\t}\n\t}\n\tmutex_unlock(&group->mark_mutex);\n}"
  },
  {
    "function_name": "fsnotify_find_mark",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
    "lines": "394-406",
    "snippet": "struct fsnotify_mark *fsnotify_find_mark(struct hlist_head *head,\n\t\t\t\t\t struct fsnotify_group *group)\n{\n\tstruct fsnotify_mark *mark;\n\n\thlist_for_each_entry(mark, head, obj_list) {\n\t\tif (mark->group == group) {\n\t\t\tfsnotify_get_mark(mark);\n\t\t\treturn mark;\n\t\t}\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"fsnotify.h\"",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/atomic.h>",
      "#include <linux/srcu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsnotify_get_mark",
          "args": [
            "mark"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_get_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
          "lines": "99-102",
          "snippet": "void fsnotify_get_mark(struct fsnotify_mark *mark)\n{\n\tatomic_inc(&mark->refcnt);\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/srcu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_get_mark(struct fsnotify_mark *mark)\n{\n\tatomic_inc(&mark->refcnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "mark",
            "head",
            "obj_list"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstruct fsnotify_mark *fsnotify_find_mark(struct hlist_head *head,\n\t\t\t\t\t struct fsnotify_group *group)\n{\n\tstruct fsnotify_mark *mark;\n\n\thlist_for_each_entry(mark, head, obj_list) {\n\t\tif (mark->group == group) {\n\t\t\tfsnotify_get_mark(mark);\n\t\t\treturn mark;\n\t\t}\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "fsnotify_add_mark",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
    "lines": "380-388",
    "snippet": "int fsnotify_add_mark(struct fsnotify_mark *mark, struct fsnotify_group *group,\n\t\t      struct inode *inode, struct vfsmount *mnt, int allow_dups)\n{\n\tint ret;\n\tmutex_lock(&group->mark_mutex);\n\tret = fsnotify_add_mark_locked(mark, group, inode, mnt, allow_dups);\n\tmutex_unlock(&group->mark_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"fsnotify.h\"",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/atomic.h>",
      "#include <linux/srcu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&group->mark_mutex"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_add_mark_locked",
          "args": [
            "mark",
            "group",
            "inode",
            "mnt",
            "allow_dups"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_add_mark_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
          "lines": "318-378",
          "snippet": "int fsnotify_add_mark_locked(struct fsnotify_mark *mark,\n\t\t\t     struct fsnotify_group *group, struct inode *inode,\n\t\t\t     struct vfsmount *mnt, int allow_dups)\n{\n\tint ret = 0;\n\n\tBUG_ON(inode && mnt);\n\tBUG_ON(!inode && !mnt);\n\tBUG_ON(!mutex_is_locked(&group->mark_mutex));\n\n\t/*\n\t * LOCKING ORDER!!!!\n\t * group->mark_mutex\n\t * mark->lock\n\t * inode->i_lock\n\t */\n\tspin_lock(&mark->lock);\n\tmark->flags |= FSNOTIFY_MARK_FLAG_ALIVE;\n\n\tfsnotify_get_group(group);\n\tmark->group = group;\n\tlist_add(&mark->g_list, &group->marks_list);\n\tatomic_inc(&group->num_marks);\n\tfsnotify_get_mark(mark); /* for i_list and g_list */\n\n\tif (inode) {\n\t\tret = fsnotify_add_inode_mark(mark, group, inode, allow_dups);\n\t\tif (ret)\n\t\t\tgoto err;\n\t} else if (mnt) {\n\t\tret = fsnotify_add_vfsmount_mark(mark, group, mnt, allow_dups);\n\t\tif (ret)\n\t\t\tgoto err;\n\t} else {\n\t\tBUG();\n\t}\n\n\t/* this will pin the object if appropriate */\n\tfsnotify_set_mark_mask_locked(mark, mark->mask);\n\tspin_unlock(&mark->lock);\n\n\tif (inode)\n\t\t__fsnotify_update_child_dentry_flags(inode);\n\n\treturn ret;\nerr:\n\tmark->flags &= ~FSNOTIFY_MARK_FLAG_ALIVE;\n\tlist_del_init(&mark->g_list);\n\tfsnotify_put_group(group);\n\tmark->group = NULL;\n\tatomic_dec(&group->num_marks);\n\n\tspin_unlock(&mark->lock);\n\n\tspin_lock(&destroy_lock);\n\tlist_add(&mark->g_list, &destroy_list);\n\tspin_unlock(&destroy_lock);\n\twake_up(&destroy_waitq);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/srcu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(destroy_lock);",
            "static LIST_HEAD(destroy_list);",
            "static DECLARE_WAIT_QUEUE_HEAD(destroy_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstatic DEFINE_SPINLOCK(destroy_lock);\nstatic LIST_HEAD(destroy_list);\nstatic DECLARE_WAIT_QUEUE_HEAD(destroy_waitq);\n\nint fsnotify_add_mark_locked(struct fsnotify_mark *mark,\n\t\t\t     struct fsnotify_group *group, struct inode *inode,\n\t\t\t     struct vfsmount *mnt, int allow_dups)\n{\n\tint ret = 0;\n\n\tBUG_ON(inode && mnt);\n\tBUG_ON(!inode && !mnt);\n\tBUG_ON(!mutex_is_locked(&group->mark_mutex));\n\n\t/*\n\t * LOCKING ORDER!!!!\n\t * group->mark_mutex\n\t * mark->lock\n\t * inode->i_lock\n\t */\n\tspin_lock(&mark->lock);\n\tmark->flags |= FSNOTIFY_MARK_FLAG_ALIVE;\n\n\tfsnotify_get_group(group);\n\tmark->group = group;\n\tlist_add(&mark->g_list, &group->marks_list);\n\tatomic_inc(&group->num_marks);\n\tfsnotify_get_mark(mark); /* for i_list and g_list */\n\n\tif (inode) {\n\t\tret = fsnotify_add_inode_mark(mark, group, inode, allow_dups);\n\t\tif (ret)\n\t\t\tgoto err;\n\t} else if (mnt) {\n\t\tret = fsnotify_add_vfsmount_mark(mark, group, mnt, allow_dups);\n\t\tif (ret)\n\t\t\tgoto err;\n\t} else {\n\t\tBUG();\n\t}\n\n\t/* this will pin the object if appropriate */\n\tfsnotify_set_mark_mask_locked(mark, mark->mask);\n\tspin_unlock(&mark->lock);\n\n\tif (inode)\n\t\t__fsnotify_update_child_dentry_flags(inode);\n\n\treturn ret;\nerr:\n\tmark->flags &= ~FSNOTIFY_MARK_FLAG_ALIVE;\n\tlist_del_init(&mark->g_list);\n\tfsnotify_put_group(group);\n\tmark->group = NULL;\n\tatomic_dec(&group->num_marks);\n\n\tspin_unlock(&mark->lock);\n\n\tspin_lock(&destroy_lock);\n\tlist_add(&mark->g_list, &destroy_list);\n\tspin_unlock(&destroy_lock);\n\twake_up(&destroy_waitq);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&group->mark_mutex"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint fsnotify_add_mark(struct fsnotify_mark *mark, struct fsnotify_group *group,\n\t\t      struct inode *inode, struct vfsmount *mnt, int allow_dups)\n{\n\tint ret;\n\tmutex_lock(&group->mark_mutex);\n\tret = fsnotify_add_mark_locked(mark, group, inode, mnt, allow_dups);\n\tmutex_unlock(&group->mark_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "fsnotify_add_mark_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
    "lines": "318-378",
    "snippet": "int fsnotify_add_mark_locked(struct fsnotify_mark *mark,\n\t\t\t     struct fsnotify_group *group, struct inode *inode,\n\t\t\t     struct vfsmount *mnt, int allow_dups)\n{\n\tint ret = 0;\n\n\tBUG_ON(inode && mnt);\n\tBUG_ON(!inode && !mnt);\n\tBUG_ON(!mutex_is_locked(&group->mark_mutex));\n\n\t/*\n\t * LOCKING ORDER!!!!\n\t * group->mark_mutex\n\t * mark->lock\n\t * inode->i_lock\n\t */\n\tspin_lock(&mark->lock);\n\tmark->flags |= FSNOTIFY_MARK_FLAG_ALIVE;\n\n\tfsnotify_get_group(group);\n\tmark->group = group;\n\tlist_add(&mark->g_list, &group->marks_list);\n\tatomic_inc(&group->num_marks);\n\tfsnotify_get_mark(mark); /* for i_list and g_list */\n\n\tif (inode) {\n\t\tret = fsnotify_add_inode_mark(mark, group, inode, allow_dups);\n\t\tif (ret)\n\t\t\tgoto err;\n\t} else if (mnt) {\n\t\tret = fsnotify_add_vfsmount_mark(mark, group, mnt, allow_dups);\n\t\tif (ret)\n\t\t\tgoto err;\n\t} else {\n\t\tBUG();\n\t}\n\n\t/* this will pin the object if appropriate */\n\tfsnotify_set_mark_mask_locked(mark, mark->mask);\n\tspin_unlock(&mark->lock);\n\n\tif (inode)\n\t\t__fsnotify_update_child_dentry_flags(inode);\n\n\treturn ret;\nerr:\n\tmark->flags &= ~FSNOTIFY_MARK_FLAG_ALIVE;\n\tlist_del_init(&mark->g_list);\n\tfsnotify_put_group(group);\n\tmark->group = NULL;\n\tatomic_dec(&group->num_marks);\n\n\tspin_unlock(&mark->lock);\n\n\tspin_lock(&destroy_lock);\n\tlist_add(&mark->g_list, &destroy_list);\n\tspin_unlock(&destroy_lock);\n\twake_up(&destroy_waitq);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"fsnotify.h\"",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/atomic.h>",
      "#include <linux/srcu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(destroy_lock);",
      "static LIST_HEAD(destroy_list);",
      "static DECLARE_WAIT_QUEUE_HEAD(destroy_waitq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&destroy_waitq"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&destroy_lock"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&mark->g_list",
            "&destroy_list"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&destroy_lock"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&group->num_marks"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_put_group",
          "args": [
            "group"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_put_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/group.c",
          "lines": "79-83",
          "snippet": "void fsnotify_put_group(struct fsnotify_group *group)\n{\n\tif (atomic_dec_and_test(&group->refcnt))\n\t\tfsnotify_final_destroy_group(group);\n}",
          "includes": [
            "#include <linux/atomic.h>",
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/wait.h>",
            "#include <linux/rculist.h>",
            "#include <linux/srcu.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/atomic.h>\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/wait.h>\n#include <linux/rculist.h>\n#include <linux/srcu.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n\nvoid fsnotify_put_group(struct fsnotify_group *group)\n{\n\tif (atomic_dec_and_test(&group->refcnt))\n\t\tfsnotify_final_destroy_group(group);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&mark->g_list"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__fsnotify_update_child_dentry_flags",
          "args": [
            "inode"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "__fsnotify_update_child_dentry_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fsnotify.c",
          "lines": "52-87",
          "snippet": "void __fsnotify_update_child_dentry_flags(struct inode *inode)\n{\n\tstruct dentry *alias;\n\tint watched;\n\n\tif (!S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\t/* determine if the children should tell inode about their events */\n\twatched = fsnotify_inode_watches_children(inode);\n\n\tspin_lock(&inode->i_lock);\n\t/* run all of the dentries associated with this inode.  Since this is a\n\t * directory, there damn well better only be one item on this list */\n\thlist_for_each_entry(alias, &inode->i_dentry, d_u.d_alias) {\n\t\tstruct dentry *child;\n\n\t\t/* run all of the children of the original inode and fix their\n\t\t * d_flags to indicate parental interest (their parent is the\n\t\t * original inode) */\n\t\tspin_lock(&alias->d_lock);\n\t\tlist_for_each_entry(child, &alias->d_subdirs, d_child) {\n\t\t\tif (!child->d_inode)\n\t\t\t\tcontinue;\n\n\t\t\tspin_lock_nested(&child->d_lock, DENTRY_D_LOCK_NESTED);\n\t\t\tif (watched)\n\t\t\t\tchild->d_flags |= DCACHE_FSNOTIFY_PARENT_WATCHED;\n\t\t\telse\n\t\t\t\tchild->d_flags &= ~DCACHE_FSNOTIFY_PARENT_WATCHED;\n\t\t\tspin_unlock(&child->d_lock);\n\t\t}\n\t\tspin_unlock(&alias->d_lock);\n\t}\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"../mount.h\"",
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/srcu.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/gfp.h>",
            "#include <linux/fs.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../mount.h\"\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/srcu.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n#include <linux/dcache.h>\n\nvoid __fsnotify_update_child_dentry_flags(struct inode *inode)\n{\n\tstruct dentry *alias;\n\tint watched;\n\n\tif (!S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\t/* determine if the children should tell inode about their events */\n\twatched = fsnotify_inode_watches_children(inode);\n\n\tspin_lock(&inode->i_lock);\n\t/* run all of the dentries associated with this inode.  Since this is a\n\t * directory, there damn well better only be one item on this list */\n\thlist_for_each_entry(alias, &inode->i_dentry, d_u.d_alias) {\n\t\tstruct dentry *child;\n\n\t\t/* run all of the children of the original inode and fix their\n\t\t * d_flags to indicate parental interest (their parent is the\n\t\t * original inode) */\n\t\tspin_lock(&alias->d_lock);\n\t\tlist_for_each_entry(child, &alias->d_subdirs, d_child) {\n\t\t\tif (!child->d_inode)\n\t\t\t\tcontinue;\n\n\t\t\tspin_lock_nested(&child->d_lock, DENTRY_D_LOCK_NESTED);\n\t\t\tif (watched)\n\t\t\t\tchild->d_flags |= DCACHE_FSNOTIFY_PARENT_WATCHED;\n\t\t\telse\n\t\t\t\tchild->d_flags &= ~DCACHE_FSNOTIFY_PARENT_WATCHED;\n\t\t\tspin_unlock(&child->d_lock);\n\t\t}\n\t\tspin_unlock(&alias->d_lock);\n\t}\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_set_mark_mask_locked",
          "args": [
            "mark",
            "mark->mask"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_set_mark_mask_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
          "lines": "227-235",
          "snippet": "void fsnotify_set_mark_mask_locked(struct fsnotify_mark *mark, __u32 mask)\n{\n\tassert_spin_locked(&mark->lock);\n\n\tmark->mask = mask;\n\n\tif (mark->flags & FSNOTIFY_MARK_FLAG_INODE)\n\t\tfsnotify_set_inode_mark_mask_locked(mark, mask);\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/srcu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_set_mark_mask_locked(struct fsnotify_mark *mark, __u32 mask)\n{\n\tassert_spin_locked(&mark->lock);\n\n\tmark->mask = mask;\n\n\tif (mark->flags & FSNOTIFY_MARK_FLAG_INODE)\n\t\tfsnotify_set_inode_mark_mask_locked(mark, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_add_vfsmount_mark",
          "args": [
            "mark",
            "group",
            "mnt",
            "allow_dups"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_add_vfsmount_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/vfsmount_mark.c",
          "lines": "108-127",
          "snippet": "int fsnotify_add_vfsmount_mark(struct fsnotify_mark *mark,\n\t\t\t       struct fsnotify_group *group, struct vfsmount *mnt,\n\t\t\t       int allow_dups)\n{\n\tstruct mount *m = real_mount(mnt);\n\tint ret;\n\n\tmark->flags |= FSNOTIFY_MARK_FLAG_VFSMOUNT;\n\n\tBUG_ON(!mutex_is_locked(&group->mark_mutex));\n\tassert_spin_locked(&mark->lock);\n\n\tspin_lock(&mnt->mnt_root->d_lock);\n\tmark->mnt = mnt;\n\tret = fsnotify_add_mark_list(&m->mnt_fsnotify_marks, mark, allow_dups);\n\tm->mnt_fsnotify_mask = fsnotify_recalc_mask(&m->mnt_fsnotify_marks);\n\tspin_unlock(&mnt->mnt_root->d_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"../mount.h\"",
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../mount.h\"\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint fsnotify_add_vfsmount_mark(struct fsnotify_mark *mark,\n\t\t\t       struct fsnotify_group *group, struct vfsmount *mnt,\n\t\t\t       int allow_dups)\n{\n\tstruct mount *m = real_mount(mnt);\n\tint ret;\n\n\tmark->flags |= FSNOTIFY_MARK_FLAG_VFSMOUNT;\n\n\tBUG_ON(!mutex_is_locked(&group->mark_mutex));\n\tassert_spin_locked(&mark->lock);\n\n\tspin_lock(&mnt->mnt_root->d_lock);\n\tmark->mnt = mnt;\n\tret = fsnotify_add_mark_list(&m->mnt_fsnotify_marks, mark, allow_dups);\n\tm->mnt_fsnotify_mask = fsnotify_recalc_mask(&m->mnt_fsnotify_marks);\n\tspin_unlock(&mnt->mnt_root->d_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_add_inode_mark",
          "args": [
            "mark",
            "group",
            "inode",
            "allow_dups"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_add_inode_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inode_mark.c",
          "lines": "143-162",
          "snippet": "int fsnotify_add_inode_mark(struct fsnotify_mark *mark,\n\t\t\t    struct fsnotify_group *group, struct inode *inode,\n\t\t\t    int allow_dups)\n{\n\tint ret;\n\n\tmark->flags |= FSNOTIFY_MARK_FLAG_INODE;\n\n\tBUG_ON(!mutex_is_locked(&group->mark_mutex));\n\tassert_spin_locked(&mark->lock);\n\n\tspin_lock(&inode->i_lock);\n\tmark->inode = inode;\n\tret = fsnotify_add_mark_list(&inode->i_fsnotify_marks, mark,\n\t\t\t\t     allow_dups);\n\tinode->i_fsnotify_mask = fsnotify_recalc_mask(&inode->i_fsnotify_marks);\n\tspin_unlock(&inode->i_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"../internal.h\"",
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../internal.h\"\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint fsnotify_add_inode_mark(struct fsnotify_mark *mark,\n\t\t\t    struct fsnotify_group *group, struct inode *inode,\n\t\t\t    int allow_dups)\n{\n\tint ret;\n\n\tmark->flags |= FSNOTIFY_MARK_FLAG_INODE;\n\n\tBUG_ON(!mutex_is_locked(&group->mark_mutex));\n\tassert_spin_locked(&mark->lock);\n\n\tspin_lock(&inode->i_lock);\n\tmark->inode = inode;\n\tret = fsnotify_add_mark_list(&inode->i_fsnotify_marks, mark,\n\t\t\t\t     allow_dups);\n\tinode->i_fsnotify_mask = fsnotify_recalc_mask(&inode->i_fsnotify_marks);\n\tspin_unlock(&inode->i_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_get_mark",
          "args": [
            "mark"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_get_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
          "lines": "99-102",
          "snippet": "void fsnotify_get_mark(struct fsnotify_mark *mark)\n{\n\tatomic_inc(&mark->refcnt);\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/srcu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_get_mark(struct fsnotify_mark *mark)\n{\n\tatomic_inc(&mark->refcnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&group->num_marks"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_get_group",
          "args": [
            "group"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_get_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/group.c",
          "lines": "71-74",
          "snippet": "void fsnotify_get_group(struct fsnotify_group *group)\n{\n\tatomic_inc(&group->refcnt);\n}",
          "includes": [
            "#include <linux/atomic.h>",
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/wait.h>",
            "#include <linux/rculist.h>",
            "#include <linux/srcu.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/atomic.h>\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/wait.h>\n#include <linux/rculist.h>\n#include <linux/srcu.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n\nvoid fsnotify_get_group(struct fsnotify_group *group)\n{\n\tatomic_inc(&group->refcnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!mutex_is_locked(&group->mark_mutex)"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&group->mark_mutex"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!inode && !mnt"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "inode && mnt"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstatic DEFINE_SPINLOCK(destroy_lock);\nstatic LIST_HEAD(destroy_list);\nstatic DECLARE_WAIT_QUEUE_HEAD(destroy_waitq);\n\nint fsnotify_add_mark_locked(struct fsnotify_mark *mark,\n\t\t\t     struct fsnotify_group *group, struct inode *inode,\n\t\t\t     struct vfsmount *mnt, int allow_dups)\n{\n\tint ret = 0;\n\n\tBUG_ON(inode && mnt);\n\tBUG_ON(!inode && !mnt);\n\tBUG_ON(!mutex_is_locked(&group->mark_mutex));\n\n\t/*\n\t * LOCKING ORDER!!!!\n\t * group->mark_mutex\n\t * mark->lock\n\t * inode->i_lock\n\t */\n\tspin_lock(&mark->lock);\n\tmark->flags |= FSNOTIFY_MARK_FLAG_ALIVE;\n\n\tfsnotify_get_group(group);\n\tmark->group = group;\n\tlist_add(&mark->g_list, &group->marks_list);\n\tatomic_inc(&group->num_marks);\n\tfsnotify_get_mark(mark); /* for i_list and g_list */\n\n\tif (inode) {\n\t\tret = fsnotify_add_inode_mark(mark, group, inode, allow_dups);\n\t\tif (ret)\n\t\t\tgoto err;\n\t} else if (mnt) {\n\t\tret = fsnotify_add_vfsmount_mark(mark, group, mnt, allow_dups);\n\t\tif (ret)\n\t\t\tgoto err;\n\t} else {\n\t\tBUG();\n\t}\n\n\t/* this will pin the object if appropriate */\n\tfsnotify_set_mark_mask_locked(mark, mark->mask);\n\tspin_unlock(&mark->lock);\n\n\tif (inode)\n\t\t__fsnotify_update_child_dentry_flags(inode);\n\n\treturn ret;\nerr:\n\tmark->flags &= ~FSNOTIFY_MARK_FLAG_ALIVE;\n\tlist_del_init(&mark->g_list);\n\tfsnotify_put_group(group);\n\tmark->group = NULL;\n\tatomic_dec(&group->num_marks);\n\n\tspin_unlock(&mark->lock);\n\n\tspin_lock(&destroy_lock);\n\tlist_add(&mark->g_list, &destroy_list);\n\tspin_unlock(&destroy_lock);\n\twake_up(&destroy_waitq);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "fsnotify_add_mark_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
    "lines": "281-311",
    "snippet": "int fsnotify_add_mark_list(struct hlist_head *head, struct fsnotify_mark *mark,\n\t\t\t   int allow_dups)\n{\n\tstruct fsnotify_mark *lmark, *last = NULL;\n\tint cmp;\n\n\t/* is mark the first mark? */\n\tif (hlist_empty(head)) {\n\t\thlist_add_head_rcu(&mark->obj_list, head);\n\t\treturn 0;\n\t}\n\n\t/* should mark be in the middle of the current list? */\n\thlist_for_each_entry(lmark, head, obj_list) {\n\t\tlast = lmark;\n\n\t\tif ((lmark->group == mark->group) && !allow_dups)\n\t\t\treturn -EEXIST;\n\n\t\tcmp = fsnotify_compare_groups(lmark->group, mark->group);\n\t\tif (cmp >= 0) {\n\t\t\thlist_add_before_rcu(&mark->obj_list, &lmark->obj_list);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tBUG_ON(last == NULL);\n\t/* mark should be the last entry.  last is the current last entry */\n\thlist_add_behind_rcu(&mark->obj_list, &last->obj_list);\n\treturn 0;\n}",
    "includes": [
      "#include \"fsnotify.h\"",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/atomic.h>",
      "#include <linux/srcu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_add_behind_rcu",
          "args": [
            "&mark->obj_list",
            "&last->obj_list"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "last == NULL"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_add_before_rcu",
          "args": [
            "&mark->obj_list",
            "&lmark->obj_list"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_compare_groups",
          "args": [
            "lmark->group",
            "mark->group"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_compare_groups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
          "lines": "263-278",
          "snippet": "int fsnotify_compare_groups(struct fsnotify_group *a, struct fsnotify_group *b)\n{\n\tif (a == b)\n\t\treturn 0;\n\tif (!a)\n\t\treturn 1;\n\tif (!b)\n\t\treturn -1;\n\tif (a->priority < b->priority)\n\t\treturn 1;\n\tif (a->priority > b->priority)\n\t\treturn -1;\n\tif (a < b)\n\t\treturn 1;\n\treturn -1;\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/srcu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint fsnotify_compare_groups(struct fsnotify_group *a, struct fsnotify_group *b)\n{\n\tif (a == b)\n\t\treturn 0;\n\tif (!a)\n\t\treturn 1;\n\tif (!b)\n\t\treturn -1;\n\tif (a->priority < b->priority)\n\t\treturn 1;\n\tif (a->priority > b->priority)\n\t\treturn -1;\n\tif (a < b)\n\t\treturn 1;\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "lmark",
            "head",
            "obj_list"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_add_head_rcu",
          "args": [
            "&mark->obj_list",
            "head"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "head"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint fsnotify_add_mark_list(struct hlist_head *head, struct fsnotify_mark *mark,\n\t\t\t   int allow_dups)\n{\n\tstruct fsnotify_mark *lmark, *last = NULL;\n\tint cmp;\n\n\t/* is mark the first mark? */\n\tif (hlist_empty(head)) {\n\t\thlist_add_head_rcu(&mark->obj_list, head);\n\t\treturn 0;\n\t}\n\n\t/* should mark be in the middle of the current list? */\n\thlist_for_each_entry(lmark, head, obj_list) {\n\t\tlast = lmark;\n\n\t\tif ((lmark->group == mark->group) && !allow_dups)\n\t\t\treturn -EEXIST;\n\n\t\tcmp = fsnotify_compare_groups(lmark->group, mark->group);\n\t\tif (cmp >= 0) {\n\t\t\thlist_add_before_rcu(&mark->obj_list, &lmark->obj_list);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tBUG_ON(last == NULL);\n\t/* mark should be the last entry.  last is the current last entry */\n\thlist_add_behind_rcu(&mark->obj_list, &last->obj_list);\n\treturn 0;\n}"
  },
  {
    "function_name": "fsnotify_compare_groups",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
    "lines": "263-278",
    "snippet": "int fsnotify_compare_groups(struct fsnotify_group *a, struct fsnotify_group *b)\n{\n\tif (a == b)\n\t\treturn 0;\n\tif (!a)\n\t\treturn 1;\n\tif (!b)\n\t\treturn -1;\n\tif (a->priority < b->priority)\n\t\treturn 1;\n\tif (a->priority > b->priority)\n\t\treturn -1;\n\tif (a < b)\n\t\treturn 1;\n\treturn -1;\n}",
    "includes": [
      "#include \"fsnotify.h\"",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/atomic.h>",
      "#include <linux/srcu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint fsnotify_compare_groups(struct fsnotify_group *a, struct fsnotify_group *b)\n{\n\tif (a == b)\n\t\treturn 0;\n\tif (!a)\n\t\treturn 1;\n\tif (!b)\n\t\treturn -1;\n\tif (a->priority < b->priority)\n\t\treturn 1;\n\tif (a->priority > b->priority)\n\t\treturn -1;\n\tif (a < b)\n\t\treturn 1;\n\treturn -1;\n}"
  },
  {
    "function_name": "fsnotify_set_mark_ignored_mask_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
    "lines": "237-242",
    "snippet": "void fsnotify_set_mark_ignored_mask_locked(struct fsnotify_mark *mark, __u32 mask)\n{\n\tassert_spin_locked(&mark->lock);\n\n\tmark->ignored_mask = mask;\n}",
    "includes": [
      "#include \"fsnotify.h\"",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/atomic.h>",
      "#include <linux/srcu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&mark->lock"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_set_mark_ignored_mask_locked(struct fsnotify_mark *mark, __u32 mask)\n{\n\tassert_spin_locked(&mark->lock);\n\n\tmark->ignored_mask = mask;\n}"
  },
  {
    "function_name": "fsnotify_set_mark_mask_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
    "lines": "227-235",
    "snippet": "void fsnotify_set_mark_mask_locked(struct fsnotify_mark *mark, __u32 mask)\n{\n\tassert_spin_locked(&mark->lock);\n\n\tmark->mask = mask;\n\n\tif (mark->flags & FSNOTIFY_MARK_FLAG_INODE)\n\t\tfsnotify_set_inode_mark_mask_locked(mark, mask);\n}",
    "includes": [
      "#include \"fsnotify.h\"",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/atomic.h>",
      "#include <linux/srcu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsnotify_set_inode_mark_mask_locked",
          "args": [
            "mark",
            "mask"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_set_inode_mark_mask_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inode_mark.c",
          "lines": "115-134",
          "snippet": "void fsnotify_set_inode_mark_mask_locked(struct fsnotify_mark *mark,\n\t\t\t\t\t __u32 mask)\n{\n\tstruct inode *inode;\n\n\tassert_spin_locked(&mark->lock);\n\n\tif (mask &&\n\t    mark->inode &&\n\t    !(mark->flags & FSNOTIFY_MARK_FLAG_OBJECT_PINNED)) {\n\t\tmark->flags |= FSNOTIFY_MARK_FLAG_OBJECT_PINNED;\n\t\tinode = igrab(mark->inode);\n\t\t/*\n\t\t * we shouldn't be able to get here if the inode wasn't\n\t\t * already safely held in memory.  But bug in case it\n\t\t * ever is wrong.\n\t\t */\n\t\tBUG_ON(!inode);\n\t}\n}",
          "includes": [
            "#include \"../internal.h\"",
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../internal.h\"\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_set_inode_mark_mask_locked(struct fsnotify_mark *mark,\n\t\t\t\t\t __u32 mask)\n{\n\tstruct inode *inode;\n\n\tassert_spin_locked(&mark->lock);\n\n\tif (mask &&\n\t    mark->inode &&\n\t    !(mark->flags & FSNOTIFY_MARK_FLAG_OBJECT_PINNED)) {\n\t\tmark->flags |= FSNOTIFY_MARK_FLAG_OBJECT_PINNED;\n\t\tinode = igrab(mark->inode);\n\t\t/*\n\t\t * we shouldn't be able to get here if the inode wasn't\n\t\t * already safely held in memory.  But bug in case it\n\t\t * ever is wrong.\n\t\t */\n\t\tBUG_ON(!inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&mark->lock"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_set_mark_mask_locked(struct fsnotify_mark *mark, __u32 mask)\n{\n\tassert_spin_locked(&mark->lock);\n\n\tmark->mask = mask;\n\n\tif (mark->flags & FSNOTIFY_MARK_FLAG_INODE)\n\t\tfsnotify_set_inode_mark_mask_locked(mark, mask);\n}"
  },
  {
    "function_name": "fsnotify_destroy_marks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
    "lines": "210-225",
    "snippet": "void fsnotify_destroy_marks(struct list_head *to_free)\n{\n\tstruct fsnotify_mark *mark, *lmark;\n\tstruct fsnotify_group *group;\n\n\tlist_for_each_entry_safe(mark, lmark, to_free, free_list) {\n\t\tspin_lock(&mark->lock);\n\t\tfsnotify_get_group(mark->group);\n\t\tgroup = mark->group;\n\t\tspin_unlock(&mark->lock);\n\n\t\tfsnotify_destroy_mark(mark, group);\n\t\tfsnotify_put_mark(mark);\n\t\tfsnotify_put_group(group);\n\t}\n}",
    "includes": [
      "#include \"fsnotify.h\"",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/atomic.h>",
      "#include <linux/srcu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsnotify_put_group",
          "args": [
            "group"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_put_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/group.c",
          "lines": "79-83",
          "snippet": "void fsnotify_put_group(struct fsnotify_group *group)\n{\n\tif (atomic_dec_and_test(&group->refcnt))\n\t\tfsnotify_final_destroy_group(group);\n}",
          "includes": [
            "#include <linux/atomic.h>",
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/wait.h>",
            "#include <linux/rculist.h>",
            "#include <linux/srcu.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/atomic.h>\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/wait.h>\n#include <linux/rculist.h>\n#include <linux/srcu.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n\nvoid fsnotify_put_group(struct fsnotify_group *group)\n{\n\tif (atomic_dec_and_test(&group->refcnt))\n\t\tfsnotify_final_destroy_group(group);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_put_mark",
          "args": [
            "mark"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_put_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
          "lines": "104-111",
          "snippet": "void fsnotify_put_mark(struct fsnotify_mark *mark)\n{\n\tif (atomic_dec_and_test(&mark->refcnt)) {\n\t\tif (mark->group)\n\t\t\tfsnotify_put_group(mark->group);\n\t\tmark->free_mark(mark);\n\t}\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/srcu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_put_mark(struct fsnotify_mark *mark)\n{\n\tif (atomic_dec_and_test(&mark->refcnt)) {\n\t\tif (mark->group)\n\t\t\tfsnotify_put_group(mark->group);\n\t\tmark->free_mark(mark);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_destroy_mark",
          "args": [
            "mark",
            "group"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_destroy_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
          "lines": "198-204",
          "snippet": "void fsnotify_destroy_mark(struct fsnotify_mark *mark,\n\t\t\t   struct fsnotify_group *group)\n{\n\tmutex_lock_nested(&group->mark_mutex, SINGLE_DEPTH_NESTING);\n\tfsnotify_destroy_mark_locked(mark, group);\n\tmutex_unlock(&group->mark_mutex);\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/srcu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_destroy_mark(struct fsnotify_mark *mark,\n\t\t\t   struct fsnotify_group *group)\n{\n\tmutex_lock_nested(&group->mark_mutex, SINGLE_DEPTH_NESTING);\n\tfsnotify_destroy_mark_locked(mark, group);\n\tmutex_unlock(&group->mark_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mark->lock"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_get_group",
          "args": [
            "mark->group"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_get_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/group.c",
          "lines": "71-74",
          "snippet": "void fsnotify_get_group(struct fsnotify_group *group)\n{\n\tatomic_inc(&group->refcnt);\n}",
          "includes": [
            "#include <linux/atomic.h>",
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/wait.h>",
            "#include <linux/rculist.h>",
            "#include <linux/srcu.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/atomic.h>\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/wait.h>\n#include <linux/rculist.h>\n#include <linux/srcu.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n\nvoid fsnotify_get_group(struct fsnotify_group *group)\n{\n\tatomic_inc(&group->refcnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mark->lock"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "mark",
            "lmark",
            "to_free",
            "free_list"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_destroy_marks(struct list_head *to_free)\n{\n\tstruct fsnotify_mark *mark, *lmark;\n\tstruct fsnotify_group *group;\n\n\tlist_for_each_entry_safe(mark, lmark, to_free, free_list) {\n\t\tspin_lock(&mark->lock);\n\t\tfsnotify_get_group(mark->group);\n\t\tgroup = mark->group;\n\t\tspin_unlock(&mark->lock);\n\n\t\tfsnotify_destroy_mark(mark, group);\n\t\tfsnotify_put_mark(mark);\n\t\tfsnotify_put_group(group);\n\t}\n}"
  },
  {
    "function_name": "fsnotify_destroy_mark",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
    "lines": "198-204",
    "snippet": "void fsnotify_destroy_mark(struct fsnotify_mark *mark,\n\t\t\t   struct fsnotify_group *group)\n{\n\tmutex_lock_nested(&group->mark_mutex, SINGLE_DEPTH_NESTING);\n\tfsnotify_destroy_mark_locked(mark, group);\n\tmutex_unlock(&group->mark_mutex);\n}",
    "includes": [
      "#include \"fsnotify.h\"",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/atomic.h>",
      "#include <linux/srcu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&group->mark_mutex"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_destroy_mark_locked",
          "args": [
            "mark",
            "group"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_destroy_mark_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
          "lines": "129-196",
          "snippet": "void fsnotify_destroy_mark_locked(struct fsnotify_mark *mark,\n\t\t\t\t  struct fsnotify_group *group)\n{\n\tstruct inode *inode = NULL;\n\n\tBUG_ON(!mutex_is_locked(&group->mark_mutex));\n\n\tspin_lock(&mark->lock);\n\n\t/* something else already called this function on this mark */\n\tif (!(mark->flags & FSNOTIFY_MARK_FLAG_ALIVE)) {\n\t\tspin_unlock(&mark->lock);\n\t\treturn;\n\t}\n\n\tmark->flags &= ~FSNOTIFY_MARK_FLAG_ALIVE;\n\n\tif (mark->flags & FSNOTIFY_MARK_FLAG_INODE) {\n\t\tinode = mark->inode;\n\t\tfsnotify_destroy_inode_mark(mark);\n\t} else if (mark->flags & FSNOTIFY_MARK_FLAG_VFSMOUNT)\n\t\tfsnotify_destroy_vfsmount_mark(mark);\n\telse\n\t\tBUG();\n\n\tlist_del_init(&mark->g_list);\n\n\tspin_unlock(&mark->lock);\n\n\tif (inode && (mark->flags & FSNOTIFY_MARK_FLAG_OBJECT_PINNED))\n\t\tiput(inode);\n\t/* release lock temporarily */\n\tmutex_unlock(&group->mark_mutex);\n\n\tspin_lock(&destroy_lock);\n\tlist_add(&mark->g_list, &destroy_list);\n\tspin_unlock(&destroy_lock);\n\twake_up(&destroy_waitq);\n\t/*\n\t * We don't necessarily have a ref on mark from caller so the above destroy\n\t * may have actually freed it, unless this group provides a 'freeing_mark'\n\t * function which must be holding a reference.\n\t */\n\n\t/*\n\t * Some groups like to know that marks are being freed.  This is a\n\t * callback to the group function to let it know that this mark\n\t * is being freed.\n\t */\n\tif (group->ops->freeing_mark)\n\t\tgroup->ops->freeing_mark(mark, group);\n\n\t/*\n\t * __fsnotify_update_child_dentry_flags(inode);\n\t *\n\t * I really want to call that, but we can't, we have no idea if the inode\n\t * still exists the second we drop the mark->lock.\n\t *\n\t * The next time an event arrive to this inode from one of it's children\n\t * __fsnotify_parent will see that the inode doesn't care about it's\n\t * children and will update all of these flags then.  So really this\n\t * is just a lazy update (and could be a perf win...)\n\t */\n\n\tatomic_dec(&group->num_marks);\n\n\tmutex_lock_nested(&group->mark_mutex, SINGLE_DEPTH_NESTING);\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/srcu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(destroy_lock);",
            "static LIST_HEAD(destroy_list);",
            "static DECLARE_WAIT_QUEUE_HEAD(destroy_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstatic DEFINE_SPINLOCK(destroy_lock);\nstatic LIST_HEAD(destroy_list);\nstatic DECLARE_WAIT_QUEUE_HEAD(destroy_waitq);\n\nvoid fsnotify_destroy_mark_locked(struct fsnotify_mark *mark,\n\t\t\t\t  struct fsnotify_group *group)\n{\n\tstruct inode *inode = NULL;\n\n\tBUG_ON(!mutex_is_locked(&group->mark_mutex));\n\n\tspin_lock(&mark->lock);\n\n\t/* something else already called this function on this mark */\n\tif (!(mark->flags & FSNOTIFY_MARK_FLAG_ALIVE)) {\n\t\tspin_unlock(&mark->lock);\n\t\treturn;\n\t}\n\n\tmark->flags &= ~FSNOTIFY_MARK_FLAG_ALIVE;\n\n\tif (mark->flags & FSNOTIFY_MARK_FLAG_INODE) {\n\t\tinode = mark->inode;\n\t\tfsnotify_destroy_inode_mark(mark);\n\t} else if (mark->flags & FSNOTIFY_MARK_FLAG_VFSMOUNT)\n\t\tfsnotify_destroy_vfsmount_mark(mark);\n\telse\n\t\tBUG();\n\n\tlist_del_init(&mark->g_list);\n\n\tspin_unlock(&mark->lock);\n\n\tif (inode && (mark->flags & FSNOTIFY_MARK_FLAG_OBJECT_PINNED))\n\t\tiput(inode);\n\t/* release lock temporarily */\n\tmutex_unlock(&group->mark_mutex);\n\n\tspin_lock(&destroy_lock);\n\tlist_add(&mark->g_list, &destroy_list);\n\tspin_unlock(&destroy_lock);\n\twake_up(&destroy_waitq);\n\t/*\n\t * We don't necessarily have a ref on mark from caller so the above destroy\n\t * may have actually freed it, unless this group provides a 'freeing_mark'\n\t * function which must be holding a reference.\n\t */\n\n\t/*\n\t * Some groups like to know that marks are being freed.  This is a\n\t * callback to the group function to let it know that this mark\n\t * is being freed.\n\t */\n\tif (group->ops->freeing_mark)\n\t\tgroup->ops->freeing_mark(mark, group);\n\n\t/*\n\t * __fsnotify_update_child_dentry_flags(inode);\n\t *\n\t * I really want to call that, but we can't, we have no idea if the inode\n\t * still exists the second we drop the mark->lock.\n\t *\n\t * The next time an event arrive to this inode from one of it's children\n\t * __fsnotify_parent will see that the inode doesn't care about it's\n\t * children and will update all of these flags then.  So really this\n\t * is just a lazy update (and could be a perf win...)\n\t */\n\n\tatomic_dec(&group->num_marks);\n\n\tmutex_lock_nested(&group->mark_mutex, SINGLE_DEPTH_NESTING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&group->mark_mutex",
            "SINGLE_DEPTH_NESTING"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_destroy_mark(struct fsnotify_mark *mark,\n\t\t\t   struct fsnotify_group *group)\n{\n\tmutex_lock_nested(&group->mark_mutex, SINGLE_DEPTH_NESTING);\n\tfsnotify_destroy_mark_locked(mark, group);\n\tmutex_unlock(&group->mark_mutex);\n}"
  },
  {
    "function_name": "fsnotify_destroy_mark_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
    "lines": "129-196",
    "snippet": "void fsnotify_destroy_mark_locked(struct fsnotify_mark *mark,\n\t\t\t\t  struct fsnotify_group *group)\n{\n\tstruct inode *inode = NULL;\n\n\tBUG_ON(!mutex_is_locked(&group->mark_mutex));\n\n\tspin_lock(&mark->lock);\n\n\t/* something else already called this function on this mark */\n\tif (!(mark->flags & FSNOTIFY_MARK_FLAG_ALIVE)) {\n\t\tspin_unlock(&mark->lock);\n\t\treturn;\n\t}\n\n\tmark->flags &= ~FSNOTIFY_MARK_FLAG_ALIVE;\n\n\tif (mark->flags & FSNOTIFY_MARK_FLAG_INODE) {\n\t\tinode = mark->inode;\n\t\tfsnotify_destroy_inode_mark(mark);\n\t} else if (mark->flags & FSNOTIFY_MARK_FLAG_VFSMOUNT)\n\t\tfsnotify_destroy_vfsmount_mark(mark);\n\telse\n\t\tBUG();\n\n\tlist_del_init(&mark->g_list);\n\n\tspin_unlock(&mark->lock);\n\n\tif (inode && (mark->flags & FSNOTIFY_MARK_FLAG_OBJECT_PINNED))\n\t\tiput(inode);\n\t/* release lock temporarily */\n\tmutex_unlock(&group->mark_mutex);\n\n\tspin_lock(&destroy_lock);\n\tlist_add(&mark->g_list, &destroy_list);\n\tspin_unlock(&destroy_lock);\n\twake_up(&destroy_waitq);\n\t/*\n\t * We don't necessarily have a ref on mark from caller so the above destroy\n\t * may have actually freed it, unless this group provides a 'freeing_mark'\n\t * function which must be holding a reference.\n\t */\n\n\t/*\n\t * Some groups like to know that marks are being freed.  This is a\n\t * callback to the group function to let it know that this mark\n\t * is being freed.\n\t */\n\tif (group->ops->freeing_mark)\n\t\tgroup->ops->freeing_mark(mark, group);\n\n\t/*\n\t * __fsnotify_update_child_dentry_flags(inode);\n\t *\n\t * I really want to call that, but we can't, we have no idea if the inode\n\t * still exists the second we drop the mark->lock.\n\t *\n\t * The next time an event arrive to this inode from one of it's children\n\t * __fsnotify_parent will see that the inode doesn't care about it's\n\t * children and will update all of these flags then.  So really this\n\t * is just a lazy update (and could be a perf win...)\n\t */\n\n\tatomic_dec(&group->num_marks);\n\n\tmutex_lock_nested(&group->mark_mutex, SINGLE_DEPTH_NESTING);\n}",
    "includes": [
      "#include \"fsnotify.h\"",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/atomic.h>",
      "#include <linux/srcu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(destroy_lock);",
      "static LIST_HEAD(destroy_list);",
      "static DECLARE_WAIT_QUEUE_HEAD(destroy_waitq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&group->mark_mutex",
            "SINGLE_DEPTH_NESTING"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&group->num_marks"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "group->ops->freeing_mark",
          "args": [
            "mark",
            "group"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&destroy_waitq"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&destroy_lock"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&mark->g_list",
            "&destroy_list"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&destroy_lock"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&group->mark_mutex"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&mark->g_list"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_destroy_vfsmount_mark",
          "args": [
            "mark"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_destroy_vfsmount_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/vfsmount_mark.c",
          "lines": "69-84",
          "snippet": "void fsnotify_destroy_vfsmount_mark(struct fsnotify_mark *mark)\n{\n\tstruct vfsmount *mnt = mark->mnt;\n\tstruct mount *m = real_mount(mnt);\n\n\tBUG_ON(!mutex_is_locked(&mark->group->mark_mutex));\n\tassert_spin_locked(&mark->lock);\n\n\tspin_lock(&mnt->mnt_root->d_lock);\n\n\thlist_del_init_rcu(&mark->obj_list);\n\tmark->mnt = NULL;\n\n\tm->mnt_fsnotify_mask = fsnotify_recalc_mask(&m->mnt_fsnotify_marks);\n\tspin_unlock(&mnt->mnt_root->d_lock);\n}",
          "includes": [
            "#include \"../mount.h\"",
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../mount.h\"\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_destroy_vfsmount_mark(struct fsnotify_mark *mark)\n{\n\tstruct vfsmount *mnt = mark->mnt;\n\tstruct mount *m = real_mount(mnt);\n\n\tBUG_ON(!mutex_is_locked(&mark->group->mark_mutex));\n\tassert_spin_locked(&mark->lock);\n\n\tspin_lock(&mnt->mnt_root->d_lock);\n\n\thlist_del_init_rcu(&mark->obj_list);\n\tmark->mnt = NULL;\n\n\tm->mnt_fsnotify_mask = fsnotify_recalc_mask(&m->mnt_fsnotify_marks);\n\tspin_unlock(&mnt->mnt_root->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_destroy_inode_mark",
          "args": [
            "mark"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_destroy_inode_mark",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/inode_mark.c",
          "lines": "46-65",
          "snippet": "void fsnotify_destroy_inode_mark(struct fsnotify_mark *mark)\n{\n\tstruct inode *inode = mark->inode;\n\n\tBUG_ON(!mutex_is_locked(&mark->group->mark_mutex));\n\tassert_spin_locked(&mark->lock);\n\n\tspin_lock(&inode->i_lock);\n\n\thlist_del_init_rcu(&mark->obj_list);\n\tmark->inode = NULL;\n\n\t/*\n\t * this mark is now off the inode->i_fsnotify_marks list and we\n\t * hold the inode->i_lock, so this is the perfect time to update the\n\t * inode->i_fsnotify_mask\n\t */\n\tinode->i_fsnotify_mask = fsnotify_recalc_mask(&inode->i_fsnotify_marks);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"../internal.h\"",
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../internal.h\"\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_destroy_inode_mark(struct fsnotify_mark *mark)\n{\n\tstruct inode *inode = mark->inode;\n\n\tBUG_ON(!mutex_is_locked(&mark->group->mark_mutex));\n\tassert_spin_locked(&mark->lock);\n\n\tspin_lock(&inode->i_lock);\n\n\thlist_del_init_rcu(&mark->obj_list);\n\tmark->inode = NULL;\n\n\t/*\n\t * this mark is now off the inode->i_fsnotify_marks list and we\n\t * hold the inode->i_lock, so this is the perfect time to update the\n\t * inode->i_fsnotify_mask\n\t */\n\tinode->i_fsnotify_mask = fsnotify_recalc_mask(&inode->i_fsnotify_marks);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!mutex_is_locked(&group->mark_mutex)"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&group->mark_mutex"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstatic DEFINE_SPINLOCK(destroy_lock);\nstatic LIST_HEAD(destroy_list);\nstatic DECLARE_WAIT_QUEUE_HEAD(destroy_waitq);\n\nvoid fsnotify_destroy_mark_locked(struct fsnotify_mark *mark,\n\t\t\t\t  struct fsnotify_group *group)\n{\n\tstruct inode *inode = NULL;\n\n\tBUG_ON(!mutex_is_locked(&group->mark_mutex));\n\n\tspin_lock(&mark->lock);\n\n\t/* something else already called this function on this mark */\n\tif (!(mark->flags & FSNOTIFY_MARK_FLAG_ALIVE)) {\n\t\tspin_unlock(&mark->lock);\n\t\treturn;\n\t}\n\n\tmark->flags &= ~FSNOTIFY_MARK_FLAG_ALIVE;\n\n\tif (mark->flags & FSNOTIFY_MARK_FLAG_INODE) {\n\t\tinode = mark->inode;\n\t\tfsnotify_destroy_inode_mark(mark);\n\t} else if (mark->flags & FSNOTIFY_MARK_FLAG_VFSMOUNT)\n\t\tfsnotify_destroy_vfsmount_mark(mark);\n\telse\n\t\tBUG();\n\n\tlist_del_init(&mark->g_list);\n\n\tspin_unlock(&mark->lock);\n\n\tif (inode && (mark->flags & FSNOTIFY_MARK_FLAG_OBJECT_PINNED))\n\t\tiput(inode);\n\t/* release lock temporarily */\n\tmutex_unlock(&group->mark_mutex);\n\n\tspin_lock(&destroy_lock);\n\tlist_add(&mark->g_list, &destroy_list);\n\tspin_unlock(&destroy_lock);\n\twake_up(&destroy_waitq);\n\t/*\n\t * We don't necessarily have a ref on mark from caller so the above destroy\n\t * may have actually freed it, unless this group provides a 'freeing_mark'\n\t * function which must be holding a reference.\n\t */\n\n\t/*\n\t * Some groups like to know that marks are being freed.  This is a\n\t * callback to the group function to let it know that this mark\n\t * is being freed.\n\t */\n\tif (group->ops->freeing_mark)\n\t\tgroup->ops->freeing_mark(mark, group);\n\n\t/*\n\t * __fsnotify_update_child_dentry_flags(inode);\n\t *\n\t * I really want to call that, but we can't, we have no idea if the inode\n\t * still exists the second we drop the mark->lock.\n\t *\n\t * The next time an event arrive to this inode from one of it's children\n\t * __fsnotify_parent will see that the inode doesn't care about it's\n\t * children and will update all of these flags then.  So really this\n\t * is just a lazy update (and could be a perf win...)\n\t */\n\n\tatomic_dec(&group->num_marks);\n\n\tmutex_lock_nested(&group->mark_mutex, SINGLE_DEPTH_NESTING);\n}"
  },
  {
    "function_name": "fsnotify_recalc_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
    "lines": "114-122",
    "snippet": "u32 fsnotify_recalc_mask(struct hlist_head *head)\n{\n\tu32 new_mask = 0;\n\tstruct fsnotify_mark *mark;\n\n\thlist_for_each_entry(mark, head, obj_list)\n\t\tnew_mask |= mark->mask;\n\treturn new_mask;\n}",
    "includes": [
      "#include \"fsnotify.h\"",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/atomic.h>",
      "#include <linux/srcu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "mark",
            "head",
            "obj_list"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nu32 fsnotify_recalc_mask(struct hlist_head *head)\n{\n\tu32 new_mask = 0;\n\tstruct fsnotify_mark *mark;\n\n\thlist_for_each_entry(mark, head, obj_list)\n\t\tnew_mask |= mark->mask;\n\treturn new_mask;\n}"
  },
  {
    "function_name": "fsnotify_put_mark",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
    "lines": "104-111",
    "snippet": "void fsnotify_put_mark(struct fsnotify_mark *mark)\n{\n\tif (atomic_dec_and_test(&mark->refcnt)) {\n\t\tif (mark->group)\n\t\t\tfsnotify_put_group(mark->group);\n\t\tmark->free_mark(mark);\n\t}\n}",
    "includes": [
      "#include \"fsnotify.h\"",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/atomic.h>",
      "#include <linux/srcu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark->free_mark",
          "args": [
            "mark"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_put_group",
          "args": [
            "mark->group"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_put_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/group.c",
          "lines": "79-83",
          "snippet": "void fsnotify_put_group(struct fsnotify_group *group)\n{\n\tif (atomic_dec_and_test(&group->refcnt))\n\t\tfsnotify_final_destroy_group(group);\n}",
          "includes": [
            "#include <linux/atomic.h>",
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/wait.h>",
            "#include <linux/rculist.h>",
            "#include <linux/srcu.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/atomic.h>\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/wait.h>\n#include <linux/rculist.h>\n#include <linux/srcu.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n\nvoid fsnotify_put_group(struct fsnotify_group *group)\n{\n\tif (atomic_dec_and_test(&group->refcnt))\n\t\tfsnotify_final_destroy_group(group);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&mark->refcnt"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_put_mark(struct fsnotify_mark *mark)\n{\n\tif (atomic_dec_and_test(&mark->refcnt)) {\n\t\tif (mark->group)\n\t\t\tfsnotify_put_group(mark->group);\n\t\tmark->free_mark(mark);\n\t}\n}"
  },
  {
    "function_name": "fsnotify_get_mark",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/mark.c",
    "lines": "99-102",
    "snippet": "void fsnotify_get_mark(struct fsnotify_mark *mark)\n{\n\tatomic_inc(&mark->refcnt);\n}",
    "includes": [
      "#include \"fsnotify.h\"",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/atomic.h>",
      "#include <linux/srcu.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&mark->refcnt"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/srcu.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_get_mark(struct fsnotify_mark *mark)\n{\n\tatomic_inc(&mark->refcnt);\n}"
  }
]