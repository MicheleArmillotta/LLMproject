[
  {
    "function_name": "squashfs_decompress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/decompressor_multi.c",
    "lines": "185-198",
    "snippet": "int squashfs_decompress(struct squashfs_sb_info *msblk, struct buffer_head **bh,\n\tint b, int offset, int length, struct squashfs_page_actor *output)\n{\n\tint res;\n\tstruct squashfs_stream *stream = msblk->stream;\n\tstruct decomp_stream *decomp_stream = get_decomp_stream(msblk, stream);\n\tres = msblk->decompressor->decompress(msblk, decomp_stream->stream,\n\t\tbh, b, offset, length, output);\n\tput_decomp_stream(decomp_stream, stream);\n\tif (res < 0)\n\t\tERROR(\"%s decompression failed, data probably corrupt\\n\",\n\t\t\tmsblk->decompressor->name);\n\treturn res;\n}",
    "includes": [
      "#include \"squashfs.h\"",
      "#include \"decompressor.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/cpumask.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"%s decompression failed, data probably corrupt\\n\"",
            "msblk->decompressor->name"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_decomp_stream",
          "args": [
            "decomp_stream",
            "stream"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "put_decomp_stream",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/decompressor_multi.c",
          "lines": "55-62",
          "snippet": "static void put_decomp_stream(struct decomp_stream *decomp_strm,\n\t\t\t\tstruct squashfs_stream *stream)\n{\n\tmutex_lock(&stream->mutex);\n\tlist_add(&decomp_strm->list, &stream->strm_list);\n\tmutex_unlock(&stream->mutex);\n\twake_up(&stream->wait);\n}",
          "includes": [
            "#include \"squashfs.h\"",
            "#include \"decompressor.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/cpumask.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"squashfs.h\"\n#include \"decompressor.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/cpumask.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/types.h>\n\nstatic void put_decomp_stream(struct decomp_stream *decomp_strm,\n\t\t\t\tstruct squashfs_stream *stream)\n{\n\tmutex_lock(&stream->mutex);\n\tlist_add(&decomp_strm->list, &stream->strm_list);\n\tmutex_unlock(&stream->mutex);\n\twake_up(&stream->wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "msblk->decompressor->decompress",
          "args": [
            "msblk",
            "decomp_stream->stream",
            "bh",
            "b",
            "offset",
            "length",
            "output"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_decomp_stream",
          "args": [
            "msblk",
            "stream"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "get_decomp_stream",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/decompressor_multi.c",
          "lines": "129-182",
          "snippet": "static struct decomp_stream *get_decomp_stream(struct squashfs_sb_info *msblk,\n\t\t\t\t\tstruct squashfs_stream *stream)\n{\n\tstruct decomp_stream *decomp_strm;\n\n\twhile (1) {\n\t\tmutex_lock(&stream->mutex);\n\n\t\t/* There is available decomp_stream */\n\t\tif (!list_empty(&stream->strm_list)) {\n\t\t\tdecomp_strm = list_entry(stream->strm_list.prev,\n\t\t\t\tstruct decomp_stream, list);\n\t\t\tlist_del(&decomp_strm->list);\n\t\t\tmutex_unlock(&stream->mutex);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If there is no available decomp and already full,\n\t\t * let's wait for releasing decomp from other users.\n\t\t */\n\t\tif (stream->avail_decomp >= MAX_DECOMPRESSOR)\n\t\t\tgoto wait;\n\n\t\t/* Let's allocate new decomp */\n\t\tdecomp_strm = kmalloc(sizeof(*decomp_strm), GFP_KERNEL);\n\t\tif (!decomp_strm)\n\t\t\tgoto wait;\n\n\t\tdecomp_strm->stream = msblk->decompressor->init(msblk,\n\t\t\t\t\t\tstream->comp_opts);\n\t\tif (IS_ERR(decomp_strm->stream)) {\n\t\t\tkfree(decomp_strm);\n\t\t\tgoto wait;\n\t\t}\n\n\t\tstream->avail_decomp++;\n\t\tWARN_ON(stream->avail_decomp > MAX_DECOMPRESSOR);\n\n\t\tmutex_unlock(&stream->mutex);\n\t\tbreak;\nwait:\n\t\t/*\n\t\t * If system memory is tough, let's for other's\n\t\t * releasing instead of hurting VM because it could\n\t\t * make page cache thrashing.\n\t\t */\n\t\tmutex_unlock(&stream->mutex);\n\t\twait_event(stream->wait,\n\t\t\t!list_empty(&stream->strm_list));\n\t}\n\n\treturn decomp_strm;\n}",
          "includes": [
            "#include \"squashfs.h\"",
            "#include \"decompressor.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/cpumask.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define MAX_DECOMPRESSOR\t(num_online_cpus() * 2)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"squashfs.h\"\n#include \"decompressor.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/cpumask.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/types.h>\n\n#define MAX_DECOMPRESSOR\t(num_online_cpus() * 2)\n\nstatic struct decomp_stream *get_decomp_stream(struct squashfs_sb_info *msblk,\n\t\t\t\t\tstruct squashfs_stream *stream)\n{\n\tstruct decomp_stream *decomp_strm;\n\n\twhile (1) {\n\t\tmutex_lock(&stream->mutex);\n\n\t\t/* There is available decomp_stream */\n\t\tif (!list_empty(&stream->strm_list)) {\n\t\t\tdecomp_strm = list_entry(stream->strm_list.prev,\n\t\t\t\tstruct decomp_stream, list);\n\t\t\tlist_del(&decomp_strm->list);\n\t\t\tmutex_unlock(&stream->mutex);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If there is no available decomp and already full,\n\t\t * let's wait for releasing decomp from other users.\n\t\t */\n\t\tif (stream->avail_decomp >= MAX_DECOMPRESSOR)\n\t\t\tgoto wait;\n\n\t\t/* Let's allocate new decomp */\n\t\tdecomp_strm = kmalloc(sizeof(*decomp_strm), GFP_KERNEL);\n\t\tif (!decomp_strm)\n\t\t\tgoto wait;\n\n\t\tdecomp_strm->stream = msblk->decompressor->init(msblk,\n\t\t\t\t\t\tstream->comp_opts);\n\t\tif (IS_ERR(decomp_strm->stream)) {\n\t\t\tkfree(decomp_strm);\n\t\t\tgoto wait;\n\t\t}\n\n\t\tstream->avail_decomp++;\n\t\tWARN_ON(stream->avail_decomp > MAX_DECOMPRESSOR);\n\n\t\tmutex_unlock(&stream->mutex);\n\t\tbreak;\nwait:\n\t\t/*\n\t\t * If system memory is tough, let's for other's\n\t\t * releasing instead of hurting VM because it could\n\t\t * make page cache thrashing.\n\t\t */\n\t\tmutex_unlock(&stream->mutex);\n\t\twait_event(stream->wait,\n\t\t\t!list_empty(&stream->strm_list));\n\t}\n\n\treturn decomp_strm;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"squashfs.h\"\n#include \"decompressor.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/cpumask.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/types.h>\n\nint squashfs_decompress(struct squashfs_sb_info *msblk, struct buffer_head **bh,\n\tint b, int offset, int length, struct squashfs_page_actor *output)\n{\n\tint res;\n\tstruct squashfs_stream *stream = msblk->stream;\n\tstruct decomp_stream *decomp_stream = get_decomp_stream(msblk, stream);\n\tres = msblk->decompressor->decompress(msblk, decomp_stream->stream,\n\t\tbh, b, offset, length, output);\n\tput_decomp_stream(decomp_stream, stream);\n\tif (res < 0)\n\t\tERROR(\"%s decompression failed, data probably corrupt\\n\",\n\t\t\tmsblk->decompressor->name);\n\treturn res;\n}"
  },
  {
    "function_name": "get_decomp_stream",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/decompressor_multi.c",
    "lines": "129-182",
    "snippet": "static struct decomp_stream *get_decomp_stream(struct squashfs_sb_info *msblk,\n\t\t\t\t\tstruct squashfs_stream *stream)\n{\n\tstruct decomp_stream *decomp_strm;\n\n\twhile (1) {\n\t\tmutex_lock(&stream->mutex);\n\n\t\t/* There is available decomp_stream */\n\t\tif (!list_empty(&stream->strm_list)) {\n\t\t\tdecomp_strm = list_entry(stream->strm_list.prev,\n\t\t\t\tstruct decomp_stream, list);\n\t\t\tlist_del(&decomp_strm->list);\n\t\t\tmutex_unlock(&stream->mutex);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If there is no available decomp and already full,\n\t\t * let's wait for releasing decomp from other users.\n\t\t */\n\t\tif (stream->avail_decomp >= MAX_DECOMPRESSOR)\n\t\t\tgoto wait;\n\n\t\t/* Let's allocate new decomp */\n\t\tdecomp_strm = kmalloc(sizeof(*decomp_strm), GFP_KERNEL);\n\t\tif (!decomp_strm)\n\t\t\tgoto wait;\n\n\t\tdecomp_strm->stream = msblk->decompressor->init(msblk,\n\t\t\t\t\t\tstream->comp_opts);\n\t\tif (IS_ERR(decomp_strm->stream)) {\n\t\t\tkfree(decomp_strm);\n\t\t\tgoto wait;\n\t\t}\n\n\t\tstream->avail_decomp++;\n\t\tWARN_ON(stream->avail_decomp > MAX_DECOMPRESSOR);\n\n\t\tmutex_unlock(&stream->mutex);\n\t\tbreak;\nwait:\n\t\t/*\n\t\t * If system memory is tough, let's for other's\n\t\t * releasing instead of hurting VM because it could\n\t\t * make page cache thrashing.\n\t\t */\n\t\tmutex_unlock(&stream->mutex);\n\t\twait_event(stream->wait,\n\t\t\t!list_empty(&stream->strm_list));\n\t}\n\n\treturn decomp_strm;\n}",
    "includes": [
      "#include \"squashfs.h\"",
      "#include \"decompressor.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/cpumask.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define MAX_DECOMPRESSOR\t(num_online_cpus() * 2)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "stream->wait",
            "!list_empty(&stream->strm_list)"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&stream->strm_list"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&stream->mutex"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&stream->mutex"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "stream->avail_decomp > MAX_DECOMPRESSOR"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "decomp_strm"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "decomp_strm->stream"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msblk->decompressor->init",
          "args": [
            "msblk",
            "stream->comp_opts"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*decomp_strm)",
            "GFP_KERNEL"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&stream->mutex"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&decomp_strm->list"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "stream->strm_list.prev",
            "structdecomp_stream",
            "list"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&stream->mutex"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"squashfs.h\"\n#include \"decompressor.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/cpumask.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/types.h>\n\n#define MAX_DECOMPRESSOR\t(num_online_cpus() * 2)\n\nstatic struct decomp_stream *get_decomp_stream(struct squashfs_sb_info *msblk,\n\t\t\t\t\tstruct squashfs_stream *stream)\n{\n\tstruct decomp_stream *decomp_strm;\n\n\twhile (1) {\n\t\tmutex_lock(&stream->mutex);\n\n\t\t/* There is available decomp_stream */\n\t\tif (!list_empty(&stream->strm_list)) {\n\t\t\tdecomp_strm = list_entry(stream->strm_list.prev,\n\t\t\t\tstruct decomp_stream, list);\n\t\t\tlist_del(&decomp_strm->list);\n\t\t\tmutex_unlock(&stream->mutex);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If there is no available decomp and already full,\n\t\t * let's wait for releasing decomp from other users.\n\t\t */\n\t\tif (stream->avail_decomp >= MAX_DECOMPRESSOR)\n\t\t\tgoto wait;\n\n\t\t/* Let's allocate new decomp */\n\t\tdecomp_strm = kmalloc(sizeof(*decomp_strm), GFP_KERNEL);\n\t\tif (!decomp_strm)\n\t\t\tgoto wait;\n\n\t\tdecomp_strm->stream = msblk->decompressor->init(msblk,\n\t\t\t\t\t\tstream->comp_opts);\n\t\tif (IS_ERR(decomp_strm->stream)) {\n\t\t\tkfree(decomp_strm);\n\t\t\tgoto wait;\n\t\t}\n\n\t\tstream->avail_decomp++;\n\t\tWARN_ON(stream->avail_decomp > MAX_DECOMPRESSOR);\n\n\t\tmutex_unlock(&stream->mutex);\n\t\tbreak;\nwait:\n\t\t/*\n\t\t * If system memory is tough, let's for other's\n\t\t * releasing instead of hurting VM because it could\n\t\t * make page cache thrashing.\n\t\t */\n\t\tmutex_unlock(&stream->mutex);\n\t\twait_event(stream->wait,\n\t\t\t!list_empty(&stream->strm_list));\n\t}\n\n\treturn decomp_strm;\n}"
  },
  {
    "function_name": "squashfs_decompressor_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/decompressor_multi.c",
    "lines": "108-126",
    "snippet": "void squashfs_decompressor_destroy(struct squashfs_sb_info *msblk)\n{\n\tstruct squashfs_stream *stream = msblk->stream;\n\tif (stream) {\n\t\tstruct decomp_stream *decomp_strm;\n\n\t\twhile (!list_empty(&stream->strm_list)) {\n\t\t\tdecomp_strm = list_entry(stream->strm_list.prev,\n\t\t\t\t\t\tstruct decomp_stream, list);\n\t\t\tlist_del(&decomp_strm->list);\n\t\t\tmsblk->decompressor->free(decomp_strm->stream);\n\t\t\tkfree(decomp_strm);\n\t\t\tstream->avail_decomp--;\n\t\t}\n\t\tWARN_ON(stream->avail_decomp);\n\t\tkfree(stream->comp_opts);\n\t\tkfree(stream);\n\t}\n}",
    "includes": [
      "#include \"squashfs.h\"",
      "#include \"decompressor.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/cpumask.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "stream"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "stream->comp_opts"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "stream->avail_decomp"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "decomp_strm"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msblk->decompressor->free",
          "args": [
            "decomp_strm->stream"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&decomp_strm->list"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "stream->strm_list.prev",
            "structdecomp_stream",
            "list"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&stream->strm_list"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"squashfs.h\"\n#include \"decompressor.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/cpumask.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/types.h>\n\nvoid squashfs_decompressor_destroy(struct squashfs_sb_info *msblk)\n{\n\tstruct squashfs_stream *stream = msblk->stream;\n\tif (stream) {\n\t\tstruct decomp_stream *decomp_strm;\n\n\t\twhile (!list_empty(&stream->strm_list)) {\n\t\t\tdecomp_strm = list_entry(stream->strm_list.prev,\n\t\t\t\t\t\tstruct decomp_stream, list);\n\t\t\tlist_del(&decomp_strm->list);\n\t\t\tmsblk->decompressor->free(decomp_strm->stream);\n\t\t\tkfree(decomp_strm);\n\t\t\tstream->avail_decomp--;\n\t\t}\n\t\tWARN_ON(stream->avail_decomp);\n\t\tkfree(stream->comp_opts);\n\t\tkfree(stream);\n\t}\n}"
  },
  {
    "function_name": "squashfs_decompressor_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/decompressor_multi.c",
    "lines": "64-105",
    "snippet": "void *squashfs_decompressor_create(struct squashfs_sb_info *msblk,\n\t\t\t\tvoid *comp_opts)\n{\n\tstruct squashfs_stream *stream;\n\tstruct decomp_stream *decomp_strm = NULL;\n\tint err = -ENOMEM;\n\n\tstream = kzalloc(sizeof(*stream), GFP_KERNEL);\n\tif (!stream)\n\t\tgoto out;\n\n\tstream->comp_opts = comp_opts;\n\tmutex_init(&stream->mutex);\n\tINIT_LIST_HEAD(&stream->strm_list);\n\tinit_waitqueue_head(&stream->wait);\n\n\t/*\n\t * We should have a decompressor at least as default\n\t * so if we fail to allocate new decompressor dynamically,\n\t * we could always fall back to default decompressor and\n\t * file system works.\n\t */\n\tdecomp_strm = kmalloc(sizeof(*decomp_strm), GFP_KERNEL);\n\tif (!decomp_strm)\n\t\tgoto out;\n\n\tdecomp_strm->stream = msblk->decompressor->init(msblk,\n\t\t\t\t\t\tstream->comp_opts);\n\tif (IS_ERR(decomp_strm->stream)) {\n\t\terr = PTR_ERR(decomp_strm->stream);\n\t\tgoto out;\n\t}\n\n\tlist_add(&decomp_strm->list, &stream->strm_list);\n\tstream->avail_decomp = 1;\n\treturn stream;\n\nout:\n\tkfree(decomp_strm);\n\tkfree(stream);\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include \"squashfs.h\"",
      "#include \"decompressor.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/cpumask.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "stream"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "decomp_strm"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&decomp_strm->list",
            "&stream->strm_list"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "decomp_strm->stream"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "decomp_strm->stream"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msblk->decompressor->init",
          "args": [
            "msblk",
            "stream->comp_opts"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*decomp_strm)",
            "GFP_KERNEL"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&stream->wait"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&stream->strm_list"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&stream->mutex"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*stream)",
            "GFP_KERNEL"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"squashfs.h\"\n#include \"decompressor.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/cpumask.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/types.h>\n\nvoid *squashfs_decompressor_create(struct squashfs_sb_info *msblk,\n\t\t\t\tvoid *comp_opts)\n{\n\tstruct squashfs_stream *stream;\n\tstruct decomp_stream *decomp_strm = NULL;\n\tint err = -ENOMEM;\n\n\tstream = kzalloc(sizeof(*stream), GFP_KERNEL);\n\tif (!stream)\n\t\tgoto out;\n\n\tstream->comp_opts = comp_opts;\n\tmutex_init(&stream->mutex);\n\tINIT_LIST_HEAD(&stream->strm_list);\n\tinit_waitqueue_head(&stream->wait);\n\n\t/*\n\t * We should have a decompressor at least as default\n\t * so if we fail to allocate new decompressor dynamically,\n\t * we could always fall back to default decompressor and\n\t * file system works.\n\t */\n\tdecomp_strm = kmalloc(sizeof(*decomp_strm), GFP_KERNEL);\n\tif (!decomp_strm)\n\t\tgoto out;\n\n\tdecomp_strm->stream = msblk->decompressor->init(msblk,\n\t\t\t\t\t\tstream->comp_opts);\n\tif (IS_ERR(decomp_strm->stream)) {\n\t\terr = PTR_ERR(decomp_strm->stream);\n\t\tgoto out;\n\t}\n\n\tlist_add(&decomp_strm->list, &stream->strm_list);\n\tstream->avail_decomp = 1;\n\treturn stream;\n\nout:\n\tkfree(decomp_strm);\n\tkfree(stream);\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "put_decomp_stream",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/decompressor_multi.c",
    "lines": "55-62",
    "snippet": "static void put_decomp_stream(struct decomp_stream *decomp_strm,\n\t\t\t\tstruct squashfs_stream *stream)\n{\n\tmutex_lock(&stream->mutex);\n\tlist_add(&decomp_strm->list, &stream->strm_list);\n\tmutex_unlock(&stream->mutex);\n\twake_up(&stream->wait);\n}",
    "includes": [
      "#include \"squashfs.h\"",
      "#include \"decompressor.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/cpumask.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&stream->wait"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&stream->mutex"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&decomp_strm->list",
            "&stream->strm_list"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&stream->mutex"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"squashfs.h\"\n#include \"decompressor.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/cpumask.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/types.h>\n\nstatic void put_decomp_stream(struct decomp_stream *decomp_strm,\n\t\t\t\tstruct squashfs_stream *stream)\n{\n\tmutex_lock(&stream->mutex);\n\tlist_add(&decomp_strm->list, &stream->strm_list);\n\tmutex_unlock(&stream->mutex);\n\twake_up(&stream->wait);\n}"
  },
  {
    "function_name": "squashfs_max_decompressors",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/decompressor_multi.c",
    "lines": "34-37",
    "snippet": "int squashfs_max_decompressors(void)\n{\n\treturn MAX_DECOMPRESSOR;\n}",
    "includes": [
      "#include \"squashfs.h\"",
      "#include \"decompressor.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/cpumask.h>",
      "#include <linux/wait.h>",
      "#include <linux/sched.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define MAX_DECOMPRESSOR\t(num_online_cpus() * 2)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"squashfs.h\"\n#include \"decompressor.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/cpumask.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/types.h>\n\n#define MAX_DECOMPRESSOR\t(num_online_cpus() * 2)\n\nint squashfs_max_decompressors(void)\n{\n\treturn MAX_DECOMPRESSOR;\n}"
  }
]