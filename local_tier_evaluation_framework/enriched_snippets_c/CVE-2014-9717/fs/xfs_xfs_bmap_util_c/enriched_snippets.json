[
  {
    "function_name": "xfs_swap_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
    "lines": "1612-1860",
    "snippet": "int\nxfs_swap_extents(\n\txfs_inode_t\t*ip,\t/* target inode */\n\txfs_inode_t\t*tip,\t/* tmp inode */\n\txfs_swapext_t\t*sxp)\n{\n\txfs_mount_t\t*mp = ip->i_mount;\n\txfs_trans_t\t*tp;\n\txfs_bstat_t\t*sbp = &sxp->sx_stat;\n\txfs_ifork_t\t*tempifp, *ifp, *tifp;\n\tint\t\tsrc_log_flags, target_log_flags;\n\tint\t\terror = 0;\n\tint\t\taforkblks = 0;\n\tint\t\ttaforkblks = 0;\n\t__uint64_t\ttmp;\n\tint\t\tlock_flags;\n\n\ttempifp = kmem_alloc(sizeof(xfs_ifork_t), KM_MAYFAIL);\n\tif (!tempifp) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Lock up the inodes against other IO and truncate to begin with.\n\t * Then we can ensure the inodes are flushed and have no page cache\n\t * safely. Once we have done this we can take the ilocks and do the rest\n\t * of the checks.\n\t */\n\tlock_flags = XFS_IOLOCK_EXCL;\n\txfs_lock_two_inodes(ip, tip, XFS_IOLOCK_EXCL);\n\n\t/* Verify that both files have the same format */\n\tif ((ip->i_d.di_mode & S_IFMT) != (tip->i_d.di_mode & S_IFMT)) {\n\t\terror = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\t/* Verify both files are either real-time or non-realtime */\n\tif (XFS_IS_REALTIME_INODE(ip) != XFS_IS_REALTIME_INODE(tip)) {\n\t\terror = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\terror = xfs_swap_extent_flush(ip);\n\tif (error)\n\t\tgoto out_unlock;\n\terror = xfs_swap_extent_flush(tip);\n\tif (error)\n\t\tgoto out_unlock;\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_SWAPEXT);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_ichange, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\tgoto out_unlock;\n\t}\n\txfs_lock_two_inodes(ip, tip, XFS_ILOCK_EXCL);\n\tlock_flags |= XFS_ILOCK_EXCL;\n\n\t/* Verify all data are being swapped */\n\tif (sxp->sx_offset != 0 ||\n\t    sxp->sx_length != ip->i_d.di_size ||\n\t    sxp->sx_length != tip->i_d.di_size) {\n\t\terror = -EFAULT;\n\t\tgoto out_trans_cancel;\n\t}\n\n\ttrace_xfs_swap_extent_before(ip, 0);\n\ttrace_xfs_swap_extent_before(tip, 1);\n\n\t/* check inode formats now that data is flushed */\n\terror = xfs_swap_extents_check_format(ip, tip);\n\tif (error) {\n\t\txfs_notice(mp,\n\t\t    \"%s: inode 0x%llx format is incompatible for exchanging.\",\n\t\t\t\t__func__, ip->i_ino);\n\t\tgoto out_trans_cancel;\n\t}\n\n\t/*\n\t * Compare the current change & modify times with that\n\t * passed in.  If they differ, we abort this swap.\n\t * This is the mechanism used to ensure the calling\n\t * process that the file was not changed out from\n\t * under it.\n\t */\n\tif ((sbp->bs_ctime.tv_sec != VFS_I(ip)->i_ctime.tv_sec) ||\n\t    (sbp->bs_ctime.tv_nsec != VFS_I(ip)->i_ctime.tv_nsec) ||\n\t    (sbp->bs_mtime.tv_sec != VFS_I(ip)->i_mtime.tv_sec) ||\n\t    (sbp->bs_mtime.tv_nsec != VFS_I(ip)->i_mtime.tv_nsec)) {\n\t\terror = -EBUSY;\n\t\tgoto out_trans_cancel;\n\t}\n\t/*\n\t * Count the number of extended attribute blocks\n\t */\n\tif ( ((XFS_IFORK_Q(ip) != 0) && (ip->i_d.di_anextents > 0)) &&\n\t     (ip->i_d.di_aformat != XFS_DINODE_FMT_LOCAL)) {\n\t\terror = xfs_bmap_count_blocks(tp, ip, XFS_ATTR_FORK, &aforkblks);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\t}\n\tif ( ((XFS_IFORK_Q(tip) != 0) && (tip->i_d.di_anextents > 0)) &&\n\t     (tip->i_d.di_aformat != XFS_DINODE_FMT_LOCAL)) {\n\t\terror = xfs_bmap_count_blocks(tp, tip, XFS_ATTR_FORK,\n\t\t\t&taforkblks);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\t}\n\n\txfs_trans_ijoin(tp, ip, lock_flags);\n\txfs_trans_ijoin(tp, tip, lock_flags);\n\n\t/*\n\t * Before we've swapped the forks, lets set the owners of the forks\n\t * appropriately. We have to do this as we are demand paging the btree\n\t * buffers, and so the validation done on read will expect the owner\n\t * field to be correctly set. Once we change the owners, we can swap the\n\t * inode forks.\n\t *\n\t * Note the trickiness in setting the log flags - we set the owner log\n\t * flag on the opposite inode (i.e. the inode we are setting the new\n\t * owner to be) because once we swap the forks and log that, log\n\t * recovery is going to see the fork as owned by the swapped inode,\n\t * not the pre-swapped inodes.\n\t */\n\tsrc_log_flags = XFS_ILOG_CORE;\n\ttarget_log_flags = XFS_ILOG_CORE;\n\tif (ip->i_d.di_version == 3 &&\n\t    ip->i_d.di_format == XFS_DINODE_FMT_BTREE) {\n\t\ttarget_log_flags |= XFS_ILOG_DOWNER;\n\t\terror = xfs_bmbt_change_owner(tp, ip, XFS_DATA_FORK,\n\t\t\t\t\t      tip->i_ino, NULL);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\t}\n\n\tif (tip->i_d.di_version == 3 &&\n\t    tip->i_d.di_format == XFS_DINODE_FMT_BTREE) {\n\t\tsrc_log_flags |= XFS_ILOG_DOWNER;\n\t\terror = xfs_bmbt_change_owner(tp, tip, XFS_DATA_FORK,\n\t\t\t\t\t      ip->i_ino, NULL);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\t}\n\n\t/*\n\t * Swap the data forks of the inodes\n\t */\n\tifp = &ip->i_df;\n\ttifp = &tip->i_df;\n\t*tempifp = *ifp;\t/* struct copy */\n\t*ifp = *tifp;\t\t/* struct copy */\n\t*tifp = *tempifp;\t/* struct copy */\n\n\t/*\n\t * Fix the on-disk inode values\n\t */\n\ttmp = (__uint64_t)ip->i_d.di_nblocks;\n\tip->i_d.di_nblocks = tip->i_d.di_nblocks - taforkblks + aforkblks;\n\ttip->i_d.di_nblocks = tmp + taforkblks - aforkblks;\n\n\ttmp = (__uint64_t) ip->i_d.di_nextents;\n\tip->i_d.di_nextents = tip->i_d.di_nextents;\n\ttip->i_d.di_nextents = tmp;\n\n\ttmp = (__uint64_t) ip->i_d.di_format;\n\tip->i_d.di_format = tip->i_d.di_format;\n\ttip->i_d.di_format = tmp;\n\n\t/*\n\t * The extents in the source inode could still contain speculative\n\t * preallocation beyond EOF (e.g. the file is open but not modified\n\t * while defrag is in progress). In that case, we need to copy over the\n\t * number of delalloc blocks the data fork in the source inode is\n\t * tracking beyond EOF so that when the fork is truncated away when the\n\t * temporary inode is unlinked we don't underrun the i_delayed_blks\n\t * counter on that inode.\n\t */\n\tASSERT(tip->i_delayed_blks == 0);\n\ttip->i_delayed_blks = ip->i_delayed_blks;\n\tip->i_delayed_blks = 0;\n\n\tswitch (ip->i_d.di_format) {\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\t/* If the extents fit in the inode, fix the\n\t\t * pointer.  Otherwise it's already NULL or\n\t\t * pointing to the extent.\n\t\t */\n\t\tif (ip->i_d.di_nextents <= XFS_INLINE_EXTS) {\n\t\t\tifp->if_u1.if_extents =\n\t\t\t\tifp->if_u2.if_inline_ext;\n\t\t}\n\t\tsrc_log_flags |= XFS_ILOG_DEXT;\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tASSERT(ip->i_d.di_version < 3 ||\n\t\t       (src_log_flags & XFS_ILOG_DOWNER));\n\t\tsrc_log_flags |= XFS_ILOG_DBROOT;\n\t\tbreak;\n\t}\n\n\tswitch (tip->i_d.di_format) {\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\t/* If the extents fit in the inode, fix the\n\t\t * pointer.  Otherwise it's already NULL or\n\t\t * pointing to the extent.\n\t\t */\n\t\tif (tip->i_d.di_nextents <= XFS_INLINE_EXTS) {\n\t\t\ttifp->if_u1.if_extents =\n\t\t\t\ttifp->if_u2.if_inline_ext;\n\t\t}\n\t\ttarget_log_flags |= XFS_ILOG_DEXT;\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\ttarget_log_flags |= XFS_ILOG_DBROOT;\n\t\tASSERT(tip->i_d.di_version < 3 ||\n\t\t       (target_log_flags & XFS_ILOG_DOWNER));\n\t\tbreak;\n\t}\n\n\txfs_trans_log_inode(tp, ip,  src_log_flags);\n\txfs_trans_log_inode(tp, tip, target_log_flags);\n\n\t/*\n\t * If this is a synchronous mount, make sure that the\n\t * transaction goes to disk before returning to the user.\n\t */\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(tp);\n\n\terror = xfs_trans_commit(tp, 0);\n\n\ttrace_xfs_swap_extent_after(ip, 0);\n\ttrace_xfs_swap_extent_after(tip, 1);\nout:\n\tkmem_free(tempifp);\n\treturn error;\n\nout_unlock:\n\txfs_iunlock(ip, lock_flags);\n\txfs_iunlock(tip, lock_flags);\n\tgoto out;\n\nout_trans_cancel:\n\txfs_trans_cancel(tp, 0);\n\tgoto out_unlock;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_cancel",
          "args": [
            "tp",
            "0"
          ],
          "line": 1858
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "937-986",
          "snippet": "void\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "tip",
            "lock_flags"
          ],
          "line": 1854
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "tempifp"
          ],
          "line": 1849
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_swap_extent_after",
          "args": [
            "tip",
            "1"
          ],
          "line": 1847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_swap_extent_after",
          "args": [
            "ip",
            "0"
          ],
          "line": 1846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_commit",
          "args": [
            "tp",
            "0"
          ],
          "line": 1844
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "845-927",
          "snippet": "int\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_set_sync",
          "args": [
            "tp"
          ],
          "line": 1842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "tp",
            "tip",
            "target_log_flags"
          ],
          "line": 1835
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "tip->i_d.di_version < 3 ||\n\t\t       (target_log_flags & XFS_ILOG_DOWNER)"
          ],
          "line": 1829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_d.di_version < 3 ||\n\t\t       (src_log_flags & XFS_ILOG_DOWNER)"
          ],
          "line": 1809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "tip->i_delayed_blks == 0"
          ],
          "line": 1792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_change_owner",
          "args": [
            "tp",
            "tip",
            "XFS_DATA_FORK",
            "ip->i_ino",
            "NULL"
          ],
          "line": 1753
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_change_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "858-883",
          "snippet": "int\nxfs_bmbt_change_owner(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork,\n\txfs_ino_t\t\tnew_owner,\n\tstruct list_head\t*buffer_list)\n{\n\tstruct xfs_btree_cur\t*cur;\n\tint\t\t\terror;\n\n\tASSERT(tp || buffer_list);\n\tASSERT(!(tp && buffer_list));\n\tif (whichfork == XFS_DATA_FORK)\n\t\tASSERT(ip->i_d.di_format == XFS_DINODE_FMT_BTREE);\n\telse\n\t\tASSERT(ip->i_d.di_aformat == XFS_DINODE_FMT_BTREE);\n\n\tcur = xfs_bmbt_init_cursor(ip->i_mount, tp, ip, whichfork);\n\tif (!cur)\n\t\treturn -ENOMEM;\n\n\terror = xfs_btree_change_owner(cur, new_owner, buffer_list);\n\txfs_btree_del_cursor(cur, error ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_bmbt_change_owner(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork,\n\txfs_ino_t\t\tnew_owner,\n\tstruct list_head\t*buffer_list)\n{\n\tstruct xfs_btree_cur\t*cur;\n\tint\t\t\terror;\n\n\tASSERT(tp || buffer_list);\n\tASSERT(!(tp && buffer_list));\n\tif (whichfork == XFS_DATA_FORK)\n\t\tASSERT(ip->i_d.di_format == XFS_DINODE_FMT_BTREE);\n\telse\n\t\tASSERT(ip->i_d.di_aformat == XFS_DINODE_FMT_BTREE);\n\n\tcur = xfs_bmbt_init_cursor(ip->i_mount, tp, ip, whichfork);\n\tif (!cur)\n\t\treturn -ENOMEM;\n\n\terror = xfs_btree_change_owner(cur, new_owner, buffer_list);\n\txfs_btree_del_cursor(cur, error ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ijoin",
          "args": [
            "tp",
            "tip",
            "lock_flags"
          ],
          "line": 1724
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ijoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "37-57",
          "snippet": "void\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_count_blocks",
          "args": [
            "tp",
            "tip",
            "XFS_ATTR_FORK",
            "&taforkblks"
          ],
          "line": 1717
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_count_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "393-436",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_bmap_count_blocks(\n\txfs_trans_t\t\t*tp,\t\t/* transaction pointer */\n\txfs_inode_t\t\t*ip,\t\t/* incore inode */\n\tint\t\t\twhichfork,\t/* data or attr fork */\n\tint\t\t\t*count)\t\t/* out: count of blocks */\n{\n\tstruct xfs_btree_block\t*block;\t/* current btree block */\n\txfs_fsblock_t\t\tbno;\t/* block # of \"block\" */\n\txfs_ifork_t\t\t*ifp;\t/* fork structure */\n\tint\t\t\tlevel;\t/* btree level, for checking */\n\txfs_mount_t\t\t*mp;\t/* file system mount structure */\n\t__be64\t\t\t*pp;\t/* pointer to block address */\n\n\tbno = NULLFSBLOCK;\n\tmp = ip->i_mount;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif ( XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS ) {\n\t\txfs_bmap_count_leaves(ifp, 0,\n\t\t\tifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t),\n\t\t\tcount);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Root level must use BMAP_BROOT_PTR_ADDR macro to get ptr out.\n\t */\n\tblock = ifp->if_broot;\n\tlevel = be16_to_cpu(block->bb_level);\n\tASSERT(level > 0);\n\tpp = XFS_BMAP_BROOT_PTR_ADDR(mp, block, 1, ifp->if_broot_bytes);\n\tbno = be64_to_cpu(*pp);\n\tASSERT(bno != NULLFSBLOCK);\n\tASSERT(XFS_FSB_TO_AGNO(mp, bno) < mp->m_sb.sb_agcount);\n\tASSERT(XFS_FSB_TO_AGBNO(mp, bno) < mp->m_sb.sb_agblocks);\n\n\tif (unlikely(xfs_bmap_count_tree(mp, tp, ifp, bno, level, count) < 0)) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmap_count_blocks(2)\", XFS_ERRLEVEL_LOW,\n\t\t\t\t mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error */\nxfs_bmap_count_blocks(\n\txfs_trans_t\t\t*tp,\t\t/* transaction pointer */\n\txfs_inode_t\t\t*ip,\t\t/* incore inode */\n\tint\t\t\twhichfork,\t/* data or attr fork */\n\tint\t\t\t*count)\t\t/* out: count of blocks */\n{\n\tstruct xfs_btree_block\t*block;\t/* current btree block */\n\txfs_fsblock_t\t\tbno;\t/* block # of \"block\" */\n\txfs_ifork_t\t\t*ifp;\t/* fork structure */\n\tint\t\t\tlevel;\t/* btree level, for checking */\n\txfs_mount_t\t\t*mp;\t/* file system mount structure */\n\t__be64\t\t\t*pp;\t/* pointer to block address */\n\n\tbno = NULLFSBLOCK;\n\tmp = ip->i_mount;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif ( XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS ) {\n\t\txfs_bmap_count_leaves(ifp, 0,\n\t\t\tifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t),\n\t\t\tcount);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Root level must use BMAP_BROOT_PTR_ADDR macro to get ptr out.\n\t */\n\tblock = ifp->if_broot;\n\tlevel = be16_to_cpu(block->bb_level);\n\tASSERT(level > 0);\n\tpp = XFS_BMAP_BROOT_PTR_ADDR(mp, block, 1, ifp->if_broot_bytes);\n\tbno = be64_to_cpu(*pp);\n\tASSERT(bno != NULLFSBLOCK);\n\tASSERT(XFS_FSB_TO_AGNO(mp, bno) < mp->m_sb.sb_agcount);\n\tASSERT(XFS_FSB_TO_AGBNO(mp, bno) < mp->m_sb.sb_agblocks);\n\n\tif (unlikely(xfs_bmap_count_tree(mp, tp, ifp, bno, level, count) < 0)) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmap_count_blocks(2)\", XFS_ERRLEVEL_LOW,\n\t\t\t\t mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_Q",
          "args": [
            "tip"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_Q",
          "args": [
            "ip"
          ],
          "line": 1709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "ip"
          ],
          "line": 1702
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "78-81",
          "snippet": "static inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_notice",
          "args": [
            "mp",
            "\"%s: inode 0x%llx format is incompatible for exchanging.\"",
            "__func__",
            "ip->i_ino"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_swap_extents_check_format",
          "args": [
            "ip",
            "tip"
          ],
          "line": 1684
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_swap_extents_check_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "1518-1586",
          "snippet": "static int\nxfs_swap_extents_check_format(\n\txfs_inode_t\t*ip,\t/* target inode */\n\txfs_inode_t\t*tip)\t/* tmp inode */\n{\n\n\t/* Should never get a local format */\n\tif (ip->i_d.di_format == XFS_DINODE_FMT_LOCAL ||\n\t    tip->i_d.di_format == XFS_DINODE_FMT_LOCAL)\n\t\treturn -EINVAL;\n\n\t/*\n\t * if the target inode has less extents that then temporary inode then\n\t * why did userspace call us?\n\t */\n\tif (ip->i_d.di_nextents < tip->i_d.di_nextents)\n\t\treturn -EINVAL;\n\n\t/*\n\t * if the target inode is in extent form and the temp inode is in btree\n\t * form then we will end up with the target inode in the wrong format\n\t * as we already know there are less extents in the temp inode.\n\t */\n\tif (ip->i_d.di_format == XFS_DINODE_FMT_EXTENTS &&\n\t    tip->i_d.di_format == XFS_DINODE_FMT_BTREE)\n\t\treturn -EINVAL;\n\n\t/* Check temp in extent form to max in target */\n\tif (tip->i_d.di_format == XFS_DINODE_FMT_EXTENTS &&\n\t    XFS_IFORK_NEXTENTS(tip, XFS_DATA_FORK) >\n\t\t\tXFS_IFORK_MAXEXT(ip, XFS_DATA_FORK))\n\t\treturn -EINVAL;\n\n\t/* Check target in extent form to max in temp */\n\tif (ip->i_d.di_format == XFS_DINODE_FMT_EXTENTS &&\n\t    XFS_IFORK_NEXTENTS(ip, XFS_DATA_FORK) >\n\t\t\tXFS_IFORK_MAXEXT(tip, XFS_DATA_FORK))\n\t\treturn -EINVAL;\n\n\t/*\n\t * If we are in a btree format, check that the temp root block will fit\n\t * in the target and that it has enough extents to be in btree format\n\t * in the target.\n\t *\n\t * Note that we have to be careful to allow btree->extent conversions\n\t * (a common defrag case) which will occur when the temp inode is in\n\t * extent format...\n\t */\n\tif (tip->i_d.di_format == XFS_DINODE_FMT_BTREE) {\n\t\tif (XFS_IFORK_BOFF(ip) &&\n\t\t    XFS_BMAP_BMDR_SPACE(tip->i_df.if_broot) > XFS_IFORK_BOFF(ip))\n\t\t\treturn -EINVAL;\n\t\tif (XFS_IFORK_NEXTENTS(tip, XFS_DATA_FORK) <=\n\t\t    XFS_IFORK_MAXEXT(ip, XFS_DATA_FORK))\n\t\t\treturn -EINVAL;\n\t}\n\n\t/* Reciprocal target->temp btree format checks */\n\tif (ip->i_d.di_format == XFS_DINODE_FMT_BTREE) {\n\t\tif (XFS_IFORK_BOFF(tip) &&\n\t\t    XFS_BMAP_BMDR_SPACE(ip->i_df.if_broot) > XFS_IFORK_BOFF(tip))\n\t\t\treturn -EINVAL;\n\t\tif (XFS_IFORK_NEXTENTS(ip, XFS_DATA_FORK) <=\n\t\t    XFS_IFORK_MAXEXT(tip, XFS_DATA_FORK))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int\nxfs_swap_extents_check_format(\n\txfs_inode_t\t*ip,\t/* target inode */\n\txfs_inode_t\t*tip)\t/* tmp inode */\n{\n\n\t/* Should never get a local format */\n\tif (ip->i_d.di_format == XFS_DINODE_FMT_LOCAL ||\n\t    tip->i_d.di_format == XFS_DINODE_FMT_LOCAL)\n\t\treturn -EINVAL;\n\n\t/*\n\t * if the target inode has less extents that then temporary inode then\n\t * why did userspace call us?\n\t */\n\tif (ip->i_d.di_nextents < tip->i_d.di_nextents)\n\t\treturn -EINVAL;\n\n\t/*\n\t * if the target inode is in extent form and the temp inode is in btree\n\t * form then we will end up with the target inode in the wrong format\n\t * as we already know there are less extents in the temp inode.\n\t */\n\tif (ip->i_d.di_format == XFS_DINODE_FMT_EXTENTS &&\n\t    tip->i_d.di_format == XFS_DINODE_FMT_BTREE)\n\t\treturn -EINVAL;\n\n\t/* Check temp in extent form to max in target */\n\tif (tip->i_d.di_format == XFS_DINODE_FMT_EXTENTS &&\n\t    XFS_IFORK_NEXTENTS(tip, XFS_DATA_FORK) >\n\t\t\tXFS_IFORK_MAXEXT(ip, XFS_DATA_FORK))\n\t\treturn -EINVAL;\n\n\t/* Check target in extent form to max in temp */\n\tif (ip->i_d.di_format == XFS_DINODE_FMT_EXTENTS &&\n\t    XFS_IFORK_NEXTENTS(ip, XFS_DATA_FORK) >\n\t\t\tXFS_IFORK_MAXEXT(tip, XFS_DATA_FORK))\n\t\treturn -EINVAL;\n\n\t/*\n\t * If we are in a btree format, check that the temp root block will fit\n\t * in the target and that it has enough extents to be in btree format\n\t * in the target.\n\t *\n\t * Note that we have to be careful to allow btree->extent conversions\n\t * (a common defrag case) which will occur when the temp inode is in\n\t * extent format...\n\t */\n\tif (tip->i_d.di_format == XFS_DINODE_FMT_BTREE) {\n\t\tif (XFS_IFORK_BOFF(ip) &&\n\t\t    XFS_BMAP_BMDR_SPACE(tip->i_df.if_broot) > XFS_IFORK_BOFF(ip))\n\t\t\treturn -EINVAL;\n\t\tif (XFS_IFORK_NEXTENTS(tip, XFS_DATA_FORK) <=\n\t\t    XFS_IFORK_MAXEXT(ip, XFS_DATA_FORK))\n\t\t\treturn -EINVAL;\n\t}\n\n\t/* Reciprocal target->temp btree format checks */\n\tif (ip->i_d.di_format == XFS_DINODE_FMT_BTREE) {\n\t\tif (XFS_IFORK_BOFF(tip) &&\n\t\t    XFS_BMAP_BMDR_SPACE(ip->i_df.if_broot) > XFS_IFORK_BOFF(tip))\n\t\t\treturn -EINVAL;\n\t\tif (XFS_IFORK_NEXTENTS(ip, XFS_DATA_FORK) <=\n\t\t    XFS_IFORK_MAXEXT(tip, XFS_DATA_FORK))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_swap_extent_before",
          "args": [
            "tip",
            "1"
          ],
          "line": 1681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_swap_extent_before",
          "args": [
            "ip",
            "0"
          ],
          "line": 1680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_lock_two_inodes",
          "args": [
            "ip",
            "tip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 1669
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_lock_two_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "448-487",
          "snippet": "void\nxfs_lock_two_inodes(\n\txfs_inode_t\t\t*ip0,\n\txfs_inode_t\t\t*ip1,\n\tuint\t\t\tlock_mode)\n{\n\txfs_inode_t\t\t*temp;\n\tint\t\t\tattempts = 0;\n\txfs_log_item_t\t\t*lp;\n\n\tif (lock_mode & (XFS_IOLOCK_SHARED|XFS_IOLOCK_EXCL))\n\t\tASSERT((lock_mode & (XFS_ILOCK_SHARED|XFS_ILOCK_EXCL)) == 0);\n\tASSERT(ip0->i_ino != ip1->i_ino);\n\n\tif (ip0->i_ino > ip1->i_ino) {\n\t\ttemp = ip0;\n\t\tip0 = ip1;\n\t\tip1 = temp;\n\t}\n\n again:\n\txfs_ilock(ip0, xfs_lock_inumorder(lock_mode, 0));\n\n\t/*\n\t * If the first lock we have locked is in the AIL, we must TRY to get\n\t * the second lock. If we can't get it, we must release the first one\n\t * and try again.\n\t */\n\tlp = (xfs_log_item_t *)ip0->i_itemp;\n\tif (lp && (lp->li_flags & XFS_LI_IN_AIL)) {\n\t\tif (!xfs_ilock_nowait(ip1, xfs_lock_inumorder(lock_mode, 1))) {\n\t\t\txfs_iunlock(ip0, lock_mode);\n\t\t\tif ((++attempts % 5) == 0)\n\t\t\t\tdelay(1); /* Don't just spin the CPU */\n\t\t\tgoto again;\n\t\t}\n\t} else {\n\t\txfs_ilock(ip1, xfs_lock_inumorder(lock_mode, 1));\n\t}\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_lock_two_inodes(\n\txfs_inode_t\t\t*ip0,\n\txfs_inode_t\t\t*ip1,\n\tuint\t\t\tlock_mode)\n{\n\txfs_inode_t\t\t*temp;\n\tint\t\t\tattempts = 0;\n\txfs_log_item_t\t\t*lp;\n\n\tif (lock_mode & (XFS_IOLOCK_SHARED|XFS_IOLOCK_EXCL))\n\t\tASSERT((lock_mode & (XFS_ILOCK_SHARED|XFS_ILOCK_EXCL)) == 0);\n\tASSERT(ip0->i_ino != ip1->i_ino);\n\n\tif (ip0->i_ino > ip1->i_ino) {\n\t\ttemp = ip0;\n\t\tip0 = ip1;\n\t\tip1 = temp;\n\t}\n\n again:\n\txfs_ilock(ip0, xfs_lock_inumorder(lock_mode, 0));\n\n\t/*\n\t * If the first lock we have locked is in the AIL, we must TRY to get\n\t * the second lock. If we can't get it, we must release the first one\n\t * and try again.\n\t */\n\tlp = (xfs_log_item_t *)ip0->i_itemp;\n\tif (lp && (lp->li_flags & XFS_LI_IN_AIL)) {\n\t\tif (!xfs_ilock_nowait(ip1, xfs_lock_inumorder(lock_mode, 1))) {\n\t\t\txfs_iunlock(ip0, lock_mode);\n\t\t\tif ((++attempts % 5) == 0)\n\t\t\t\tdelay(1); /* Don't just spin the CPU */\n\t\t\tgoto again;\n\t\t}\n\t} else {\n\t\txfs_ilock(ip1, xfs_lock_inumorder(lock_mode, 1));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve",
          "args": [
            "tp",
            "&M_RES(mp)->tr_ichange",
            "0",
            "0"
          ],
          "line": 1664
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "168-279",
          "snippet": "int\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 1664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_alloc",
          "args": [
            "mp",
            "XFS_TRANS_SWAPEXT"
          ],
          "line": 1663
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "57-68",
          "snippet": "xfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_swap_extent_flush",
          "args": [
            "tip"
          ],
          "line": 1659
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_swap_extent_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "1588-1610",
          "snippet": "static int\nxfs_swap_extent_flush(\n\tstruct xfs_inode\t*ip)\n{\n\tint\terror;\n\n\terror = filemap_write_and_wait(VFS_I(ip)->i_mapping);\n\tif (error)\n\t\treturn error;\n\ttruncate_pagecache_range(VFS_I(ip), 0, -1);\n\n\t/* Verify O_DIRECT for ftmp */\n\tif (VFS_I(ip)->i_mapping->nrpages)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Don't try to swap extents on mmap()d files because we can't lock\n\t * out races against page faults safely.\n\t */\n\tif (mapping_mapped(VFS_I(ip)->i_mapping))\n\t\treturn -EBUSY;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int\nxfs_swap_extent_flush(\n\tstruct xfs_inode\t*ip)\n{\n\tint\terror;\n\n\terror = filemap_write_and_wait(VFS_I(ip)->i_mapping);\n\tif (error)\n\t\treturn error;\n\ttruncate_pagecache_range(VFS_I(ip), 0, -1);\n\n\t/* Verify O_DIRECT for ftmp */\n\tif (VFS_I(ip)->i_mapping->nrpages)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Don't try to swap extents on mmap()d files because we can't lock\n\t * out races against page faults safely.\n\t */\n\tif (mapping_mapped(VFS_I(ip)->i_mapping))\n\t\treturn -EBUSY;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IS_REALTIME_INODE",
          "args": [
            "tip"
          ],
          "line": 1651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_REALTIME_INODE",
          "args": [
            "ip"
          ],
          "line": 1651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_alloc",
          "args": [
            "sizeof(xfs_ifork_t)",
            "KM_MAYFAIL"
          ],
          "line": 1629
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "45-62",
          "snippet": "void *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_swap_extents(\n\txfs_inode_t\t*ip,\t/* target inode */\n\txfs_inode_t\t*tip,\t/* tmp inode */\n\txfs_swapext_t\t*sxp)\n{\n\txfs_mount_t\t*mp = ip->i_mount;\n\txfs_trans_t\t*tp;\n\txfs_bstat_t\t*sbp = &sxp->sx_stat;\n\txfs_ifork_t\t*tempifp, *ifp, *tifp;\n\tint\t\tsrc_log_flags, target_log_flags;\n\tint\t\terror = 0;\n\tint\t\taforkblks = 0;\n\tint\t\ttaforkblks = 0;\n\t__uint64_t\ttmp;\n\tint\t\tlock_flags;\n\n\ttempifp = kmem_alloc(sizeof(xfs_ifork_t), KM_MAYFAIL);\n\tif (!tempifp) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Lock up the inodes against other IO and truncate to begin with.\n\t * Then we can ensure the inodes are flushed and have no page cache\n\t * safely. Once we have done this we can take the ilocks and do the rest\n\t * of the checks.\n\t */\n\tlock_flags = XFS_IOLOCK_EXCL;\n\txfs_lock_two_inodes(ip, tip, XFS_IOLOCK_EXCL);\n\n\t/* Verify that both files have the same format */\n\tif ((ip->i_d.di_mode & S_IFMT) != (tip->i_d.di_mode & S_IFMT)) {\n\t\terror = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\t/* Verify both files are either real-time or non-realtime */\n\tif (XFS_IS_REALTIME_INODE(ip) != XFS_IS_REALTIME_INODE(tip)) {\n\t\terror = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\terror = xfs_swap_extent_flush(ip);\n\tif (error)\n\t\tgoto out_unlock;\n\terror = xfs_swap_extent_flush(tip);\n\tif (error)\n\t\tgoto out_unlock;\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_SWAPEXT);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_ichange, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\tgoto out_unlock;\n\t}\n\txfs_lock_two_inodes(ip, tip, XFS_ILOCK_EXCL);\n\tlock_flags |= XFS_ILOCK_EXCL;\n\n\t/* Verify all data are being swapped */\n\tif (sxp->sx_offset != 0 ||\n\t    sxp->sx_length != ip->i_d.di_size ||\n\t    sxp->sx_length != tip->i_d.di_size) {\n\t\terror = -EFAULT;\n\t\tgoto out_trans_cancel;\n\t}\n\n\ttrace_xfs_swap_extent_before(ip, 0);\n\ttrace_xfs_swap_extent_before(tip, 1);\n\n\t/* check inode formats now that data is flushed */\n\terror = xfs_swap_extents_check_format(ip, tip);\n\tif (error) {\n\t\txfs_notice(mp,\n\t\t    \"%s: inode 0x%llx format is incompatible for exchanging.\",\n\t\t\t\t__func__, ip->i_ino);\n\t\tgoto out_trans_cancel;\n\t}\n\n\t/*\n\t * Compare the current change & modify times with that\n\t * passed in.  If they differ, we abort this swap.\n\t * This is the mechanism used to ensure the calling\n\t * process that the file was not changed out from\n\t * under it.\n\t */\n\tif ((sbp->bs_ctime.tv_sec != VFS_I(ip)->i_ctime.tv_sec) ||\n\t    (sbp->bs_ctime.tv_nsec != VFS_I(ip)->i_ctime.tv_nsec) ||\n\t    (sbp->bs_mtime.tv_sec != VFS_I(ip)->i_mtime.tv_sec) ||\n\t    (sbp->bs_mtime.tv_nsec != VFS_I(ip)->i_mtime.tv_nsec)) {\n\t\terror = -EBUSY;\n\t\tgoto out_trans_cancel;\n\t}\n\t/*\n\t * Count the number of extended attribute blocks\n\t */\n\tif ( ((XFS_IFORK_Q(ip) != 0) && (ip->i_d.di_anextents > 0)) &&\n\t     (ip->i_d.di_aformat != XFS_DINODE_FMT_LOCAL)) {\n\t\terror = xfs_bmap_count_blocks(tp, ip, XFS_ATTR_FORK, &aforkblks);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\t}\n\tif ( ((XFS_IFORK_Q(tip) != 0) && (tip->i_d.di_anextents > 0)) &&\n\t     (tip->i_d.di_aformat != XFS_DINODE_FMT_LOCAL)) {\n\t\terror = xfs_bmap_count_blocks(tp, tip, XFS_ATTR_FORK,\n\t\t\t&taforkblks);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\t}\n\n\txfs_trans_ijoin(tp, ip, lock_flags);\n\txfs_trans_ijoin(tp, tip, lock_flags);\n\n\t/*\n\t * Before we've swapped the forks, lets set the owners of the forks\n\t * appropriately. We have to do this as we are demand paging the btree\n\t * buffers, and so the validation done on read will expect the owner\n\t * field to be correctly set. Once we change the owners, we can swap the\n\t * inode forks.\n\t *\n\t * Note the trickiness in setting the log flags - we set the owner log\n\t * flag on the opposite inode (i.e. the inode we are setting the new\n\t * owner to be) because once we swap the forks and log that, log\n\t * recovery is going to see the fork as owned by the swapped inode,\n\t * not the pre-swapped inodes.\n\t */\n\tsrc_log_flags = XFS_ILOG_CORE;\n\ttarget_log_flags = XFS_ILOG_CORE;\n\tif (ip->i_d.di_version == 3 &&\n\t    ip->i_d.di_format == XFS_DINODE_FMT_BTREE) {\n\t\ttarget_log_flags |= XFS_ILOG_DOWNER;\n\t\terror = xfs_bmbt_change_owner(tp, ip, XFS_DATA_FORK,\n\t\t\t\t\t      tip->i_ino, NULL);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\t}\n\n\tif (tip->i_d.di_version == 3 &&\n\t    tip->i_d.di_format == XFS_DINODE_FMT_BTREE) {\n\t\tsrc_log_flags |= XFS_ILOG_DOWNER;\n\t\terror = xfs_bmbt_change_owner(tp, tip, XFS_DATA_FORK,\n\t\t\t\t\t      ip->i_ino, NULL);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\t}\n\n\t/*\n\t * Swap the data forks of the inodes\n\t */\n\tifp = &ip->i_df;\n\ttifp = &tip->i_df;\n\t*tempifp = *ifp;\t/* struct copy */\n\t*ifp = *tifp;\t\t/* struct copy */\n\t*tifp = *tempifp;\t/* struct copy */\n\n\t/*\n\t * Fix the on-disk inode values\n\t */\n\ttmp = (__uint64_t)ip->i_d.di_nblocks;\n\tip->i_d.di_nblocks = tip->i_d.di_nblocks - taforkblks + aforkblks;\n\ttip->i_d.di_nblocks = tmp + taforkblks - aforkblks;\n\n\ttmp = (__uint64_t) ip->i_d.di_nextents;\n\tip->i_d.di_nextents = tip->i_d.di_nextents;\n\ttip->i_d.di_nextents = tmp;\n\n\ttmp = (__uint64_t) ip->i_d.di_format;\n\tip->i_d.di_format = tip->i_d.di_format;\n\ttip->i_d.di_format = tmp;\n\n\t/*\n\t * The extents in the source inode could still contain speculative\n\t * preallocation beyond EOF (e.g. the file is open but not modified\n\t * while defrag is in progress). In that case, we need to copy over the\n\t * number of delalloc blocks the data fork in the source inode is\n\t * tracking beyond EOF so that when the fork is truncated away when the\n\t * temporary inode is unlinked we don't underrun the i_delayed_blks\n\t * counter on that inode.\n\t */\n\tASSERT(tip->i_delayed_blks == 0);\n\ttip->i_delayed_blks = ip->i_delayed_blks;\n\tip->i_delayed_blks = 0;\n\n\tswitch (ip->i_d.di_format) {\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\t/* If the extents fit in the inode, fix the\n\t\t * pointer.  Otherwise it's already NULL or\n\t\t * pointing to the extent.\n\t\t */\n\t\tif (ip->i_d.di_nextents <= XFS_INLINE_EXTS) {\n\t\t\tifp->if_u1.if_extents =\n\t\t\t\tifp->if_u2.if_inline_ext;\n\t\t}\n\t\tsrc_log_flags |= XFS_ILOG_DEXT;\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tASSERT(ip->i_d.di_version < 3 ||\n\t\t       (src_log_flags & XFS_ILOG_DOWNER));\n\t\tsrc_log_flags |= XFS_ILOG_DBROOT;\n\t\tbreak;\n\t}\n\n\tswitch (tip->i_d.di_format) {\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\t/* If the extents fit in the inode, fix the\n\t\t * pointer.  Otherwise it's already NULL or\n\t\t * pointing to the extent.\n\t\t */\n\t\tif (tip->i_d.di_nextents <= XFS_INLINE_EXTS) {\n\t\t\ttifp->if_u1.if_extents =\n\t\t\t\ttifp->if_u2.if_inline_ext;\n\t\t}\n\t\ttarget_log_flags |= XFS_ILOG_DEXT;\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\ttarget_log_flags |= XFS_ILOG_DBROOT;\n\t\tASSERT(tip->i_d.di_version < 3 ||\n\t\t       (target_log_flags & XFS_ILOG_DOWNER));\n\t\tbreak;\n\t}\n\n\txfs_trans_log_inode(tp, ip,  src_log_flags);\n\txfs_trans_log_inode(tp, tip, target_log_flags);\n\n\t/*\n\t * If this is a synchronous mount, make sure that the\n\t * transaction goes to disk before returning to the user.\n\t */\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(tp);\n\n\terror = xfs_trans_commit(tp, 0);\n\n\ttrace_xfs_swap_extent_after(ip, 0);\n\ttrace_xfs_swap_extent_after(tip, 1);\nout:\n\tkmem_free(tempifp);\n\treturn error;\n\nout_unlock:\n\txfs_iunlock(ip, lock_flags);\n\txfs_iunlock(tip, lock_flags);\n\tgoto out;\n\nout_trans_cancel:\n\txfs_trans_cancel(tp, 0);\n\tgoto out_unlock;\n}"
  },
  {
    "function_name": "xfs_swap_extent_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
    "lines": "1588-1610",
    "snippet": "static int\nxfs_swap_extent_flush(\n\tstruct xfs_inode\t*ip)\n{\n\tint\terror;\n\n\terror = filemap_write_and_wait(VFS_I(ip)->i_mapping);\n\tif (error)\n\t\treturn error;\n\ttruncate_pagecache_range(VFS_I(ip), 0, -1);\n\n\t/* Verify O_DIRECT for ftmp */\n\tif (VFS_I(ip)->i_mapping->nrpages)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Don't try to swap extents on mmap()d files because we can't lock\n\t * out races against page faults safely.\n\t */\n\tif (mapping_mapped(VFS_I(ip)->i_mapping))\n\t\treturn -EBUSY;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mapping_mapped",
          "args": [
            "VFS_I(ip)->i_mapping"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "ip"
          ],
          "line": 1607
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "78-81",
          "snippet": "static inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_pagecache_range",
          "args": [
            "VFS_I(ip)",
            "0",
            "-1"
          ],
          "line": 1597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait",
          "args": [
            "VFS_I(ip)->i_mapping"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int\nxfs_swap_extent_flush(\n\tstruct xfs_inode\t*ip)\n{\n\tint\terror;\n\n\terror = filemap_write_and_wait(VFS_I(ip)->i_mapping);\n\tif (error)\n\t\treturn error;\n\ttruncate_pagecache_range(VFS_I(ip), 0, -1);\n\n\t/* Verify O_DIRECT for ftmp */\n\tif (VFS_I(ip)->i_mapping->nrpages)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Don't try to swap extents on mmap()d files because we can't lock\n\t * out races against page faults safely.\n\t */\n\tif (mapping_mapped(VFS_I(ip)->i_mapping))\n\t\treturn -EBUSY;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_swap_extents_check_format",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
    "lines": "1518-1586",
    "snippet": "static int\nxfs_swap_extents_check_format(\n\txfs_inode_t\t*ip,\t/* target inode */\n\txfs_inode_t\t*tip)\t/* tmp inode */\n{\n\n\t/* Should never get a local format */\n\tif (ip->i_d.di_format == XFS_DINODE_FMT_LOCAL ||\n\t    tip->i_d.di_format == XFS_DINODE_FMT_LOCAL)\n\t\treturn -EINVAL;\n\n\t/*\n\t * if the target inode has less extents that then temporary inode then\n\t * why did userspace call us?\n\t */\n\tif (ip->i_d.di_nextents < tip->i_d.di_nextents)\n\t\treturn -EINVAL;\n\n\t/*\n\t * if the target inode is in extent form and the temp inode is in btree\n\t * form then we will end up with the target inode in the wrong format\n\t * as we already know there are less extents in the temp inode.\n\t */\n\tif (ip->i_d.di_format == XFS_DINODE_FMT_EXTENTS &&\n\t    tip->i_d.di_format == XFS_DINODE_FMT_BTREE)\n\t\treturn -EINVAL;\n\n\t/* Check temp in extent form to max in target */\n\tif (tip->i_d.di_format == XFS_DINODE_FMT_EXTENTS &&\n\t    XFS_IFORK_NEXTENTS(tip, XFS_DATA_FORK) >\n\t\t\tXFS_IFORK_MAXEXT(ip, XFS_DATA_FORK))\n\t\treturn -EINVAL;\n\n\t/* Check target in extent form to max in temp */\n\tif (ip->i_d.di_format == XFS_DINODE_FMT_EXTENTS &&\n\t    XFS_IFORK_NEXTENTS(ip, XFS_DATA_FORK) >\n\t\t\tXFS_IFORK_MAXEXT(tip, XFS_DATA_FORK))\n\t\treturn -EINVAL;\n\n\t/*\n\t * If we are in a btree format, check that the temp root block will fit\n\t * in the target and that it has enough extents to be in btree format\n\t * in the target.\n\t *\n\t * Note that we have to be careful to allow btree->extent conversions\n\t * (a common defrag case) which will occur when the temp inode is in\n\t * extent format...\n\t */\n\tif (tip->i_d.di_format == XFS_DINODE_FMT_BTREE) {\n\t\tif (XFS_IFORK_BOFF(ip) &&\n\t\t    XFS_BMAP_BMDR_SPACE(tip->i_df.if_broot) > XFS_IFORK_BOFF(ip))\n\t\t\treturn -EINVAL;\n\t\tif (XFS_IFORK_NEXTENTS(tip, XFS_DATA_FORK) <=\n\t\t    XFS_IFORK_MAXEXT(ip, XFS_DATA_FORK))\n\t\t\treturn -EINVAL;\n\t}\n\n\t/* Reciprocal target->temp btree format checks */\n\tif (ip->i_d.di_format == XFS_DINODE_FMT_BTREE) {\n\t\tif (XFS_IFORK_BOFF(tip) &&\n\t\t    XFS_BMAP_BMDR_SPACE(ip->i_df.if_broot) > XFS_IFORK_BOFF(tip))\n\t\t\treturn -EINVAL;\n\t\tif (XFS_IFORK_NEXTENTS(ip, XFS_DATA_FORK) <=\n\t\t    XFS_IFORK_MAXEXT(tip, XFS_DATA_FORK))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_IFORK_MAXEXT",
          "args": [
            "tip",
            "XFS_DATA_FORK"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_NEXTENTS",
          "args": [
            "ip",
            "XFS_DATA_FORK"
          ],
          "line": 1580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_BOFF",
          "args": [
            "tip"
          ],
          "line": 1578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BMAP_BMDR_SPACE",
          "args": [
            "ip->i_df.if_broot"
          ],
          "line": 1578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_BOFF",
          "args": [
            "tip"
          ],
          "line": 1577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_MAXEXT",
          "args": [
            "ip",
            "XFS_DATA_FORK"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_NEXTENTS",
          "args": [
            "tip",
            "XFS_DATA_FORK"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_BOFF",
          "args": [
            "ip"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BMAP_BMDR_SPACE",
          "args": [
            "tip->i_df.if_broot"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_BOFF",
          "args": [
            "ip"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_MAXEXT",
          "args": [
            "tip",
            "XFS_DATA_FORK"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_NEXTENTS",
          "args": [
            "ip",
            "XFS_DATA_FORK"
          ],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_MAXEXT",
          "args": [
            "ip",
            "XFS_DATA_FORK"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_NEXTENTS",
          "args": [
            "tip",
            "XFS_DATA_FORK"
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int\nxfs_swap_extents_check_format(\n\txfs_inode_t\t*ip,\t/* target inode */\n\txfs_inode_t\t*tip)\t/* tmp inode */\n{\n\n\t/* Should never get a local format */\n\tif (ip->i_d.di_format == XFS_DINODE_FMT_LOCAL ||\n\t    tip->i_d.di_format == XFS_DINODE_FMT_LOCAL)\n\t\treturn -EINVAL;\n\n\t/*\n\t * if the target inode has less extents that then temporary inode then\n\t * why did userspace call us?\n\t */\n\tif (ip->i_d.di_nextents < tip->i_d.di_nextents)\n\t\treturn -EINVAL;\n\n\t/*\n\t * if the target inode is in extent form and the temp inode is in btree\n\t * form then we will end up with the target inode in the wrong format\n\t * as we already know there are less extents in the temp inode.\n\t */\n\tif (ip->i_d.di_format == XFS_DINODE_FMT_EXTENTS &&\n\t    tip->i_d.di_format == XFS_DINODE_FMT_BTREE)\n\t\treturn -EINVAL;\n\n\t/* Check temp in extent form to max in target */\n\tif (tip->i_d.di_format == XFS_DINODE_FMT_EXTENTS &&\n\t    XFS_IFORK_NEXTENTS(tip, XFS_DATA_FORK) >\n\t\t\tXFS_IFORK_MAXEXT(ip, XFS_DATA_FORK))\n\t\treturn -EINVAL;\n\n\t/* Check target in extent form to max in temp */\n\tif (ip->i_d.di_format == XFS_DINODE_FMT_EXTENTS &&\n\t    XFS_IFORK_NEXTENTS(ip, XFS_DATA_FORK) >\n\t\t\tXFS_IFORK_MAXEXT(tip, XFS_DATA_FORK))\n\t\treturn -EINVAL;\n\n\t/*\n\t * If we are in a btree format, check that the temp root block will fit\n\t * in the target and that it has enough extents to be in btree format\n\t * in the target.\n\t *\n\t * Note that we have to be careful to allow btree->extent conversions\n\t * (a common defrag case) which will occur when the temp inode is in\n\t * extent format...\n\t */\n\tif (tip->i_d.di_format == XFS_DINODE_FMT_BTREE) {\n\t\tif (XFS_IFORK_BOFF(ip) &&\n\t\t    XFS_BMAP_BMDR_SPACE(tip->i_df.if_broot) > XFS_IFORK_BOFF(ip))\n\t\t\treturn -EINVAL;\n\t\tif (XFS_IFORK_NEXTENTS(tip, XFS_DATA_FORK) <=\n\t\t    XFS_IFORK_MAXEXT(ip, XFS_DATA_FORK))\n\t\t\treturn -EINVAL;\n\t}\n\n\t/* Reciprocal target->temp btree format checks */\n\tif (ip->i_d.di_format == XFS_DINODE_FMT_BTREE) {\n\t\tif (XFS_IFORK_BOFF(tip) &&\n\t\t    XFS_BMAP_BMDR_SPACE(ip->i_df.if_broot) > XFS_IFORK_BOFF(tip))\n\t\t\treturn -EINVAL;\n\t\tif (XFS_IFORK_NEXTENTS(ip, XFS_DATA_FORK) <=\n\t\t    XFS_IFORK_MAXEXT(tip, XFS_DATA_FORK))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_collapse_file_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
    "lines": "1390-1496",
    "snippet": "int\nxfs_collapse_file_space(\n\tstruct xfs_inode\t*ip,\n\txfs_off_t\t\toffset,\n\txfs_off_t\t\tlen)\n{\n\tint\t\t\tdone = 0;\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\tstruct xfs_bmap_free\tfree_list;\n\txfs_fsblock_t\t\tfirst_block;\n\tint\t\t\tcommitted;\n\txfs_fileoff_t\t\tstart_fsb;\n\txfs_fileoff_t\t\tnext_fsb;\n\txfs_fileoff_t\t\tshift_fsb;\n\n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\n\ttrace_xfs_collapse_file_space(ip);\n\n\tnext_fsb = XFS_B_TO_FSB(mp, offset + len);\n\tshift_fsb = XFS_B_TO_FSB(mp, len);\n\n\terror = xfs_free_file_space(ip, offset, len);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Trim eofblocks to avoid shifting uninitialized post-eof preallocation\n\t * into the accessible region of the file.\n\t */\n\tif (xfs_can_free_eofblocks(ip, true)) {\n\t\terror = xfs_free_eofblocks(mp, ip, false);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * Writeback and invalidate cache for the remainder of the file as we're\n\t * about to shift down every extent from the collapse range to EOF. The\n\t * free of the collapse range above might have already done some of\n\t * this, but we shouldn't rely on it to do anything outside of the range\n\t * that was freed.\n\t */\n\terror = filemap_write_and_wait_range(VFS_I(ip)->i_mapping,\n\t\t\t\t\t     offset + len, -1);\n\tif (error)\n\t\treturn error;\n\terror = invalidate_inode_pages2_range(VFS_I(ip)->i_mapping,\n\t\t\t\t\t(offset + len) >> PAGE_CACHE_SHIFT, -1);\n\tif (error)\n\t\treturn error;\n\n\twhile (!error && !done) {\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_DIOSTRAT);\n\t\t/*\n\t\t * We would need to reserve permanent block for transaction.\n\t\t * This will come into picture when after shifting extent into\n\t\t * hole we found that adjacent extents can be merged which\n\t\t * may lead to freeing of a block during record update.\n\t\t */\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_write,\n\t\t\t\tXFS_DIOSTRAT_SPACE_RES(mp, 0), 0);\n\t\tif (error) {\n\t\t\txfs_trans_cancel(tp, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\terror = xfs_trans_reserve_quota(tp, mp, ip->i_udquot,\n\t\t\t\tip->i_gdquot, ip->i_pdquot,\n\t\t\t\tXFS_DIOSTRAT_SPACE_RES(mp, 0), 0,\n\t\t\t\tXFS_QMOPT_RES_REGBLKS);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\txfs_trans_ijoin(tp, ip, 0);\n\n\t\txfs_bmap_init(&free_list, &first_block);\n\n\t\t/*\n\t\t * We are using the write transaction in which max 2 bmbt\n\t\t * updates are allowed\n\t\t */\n\t\tstart_fsb = next_fsb;\n\t\terror = xfs_bmap_shift_extents(tp, ip, start_fsb, shift_fsb,\n\t\t\t\t&done, &next_fsb, &first_block, &free_list,\n\t\t\t\tXFS_BMAP_MAX_SHIFT_EXTENTS);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t}\n\n\treturn error;\n\nout:\n\txfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 1494
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_cancel",
          "args": [
            "tp",
            "XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT"
          ],
          "line": 1493
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "937-986",
          "snippet": "void\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_commit",
          "args": [
            "tp",
            "XFS_TRANS_RELEASE_LOG_RES"
          ],
          "line": 1486
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "845-927",
          "snippet": "int\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_finish",
          "args": [
            "&tp",
            "&free_list",
            "&committed"
          ],
          "line": 1482
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "68-143",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_bmap_finish(\n\txfs_trans_t\t\t**tp,\t\t/* transaction pointer addr */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*committed)\t/* xact committed or not */\n{\n\txfs_efd_log_item_t\t*efd;\t\t/* extent free data */\n\txfs_efi_log_item_t\t*efi;\t\t/* extent free intention */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_bmap_free_item_t\t*free;\t\t/* free extent item */\n\tstruct xfs_trans_res\ttres;\t\t/* new log reservation */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount structure */\n\txfs_bmap_free_item_t\t*next;\t\t/* next item on free list */\n\txfs_trans_t\t\t*ntp;\t\t/* new transaction pointer */\n\n\tASSERT((*tp)->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tif (flist->xbf_count == 0) {\n\t\t*committed = 0;\n\t\treturn 0;\n\t}\n\tntp = *tp;\n\tefi = xfs_trans_get_efi(ntp, flist->xbf_count);\n\tfor (free = flist->xbf_first; free; free = free->xbfi_next)\n\t\txfs_trans_log_efi_extent(ntp, efi, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\n\ttres.tr_logres = ntp->t_log_res;\n\ttres.tr_logcount = ntp->t_log_count;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\tntp = xfs_trans_dup(*tp);\n\terror = xfs_trans_commit(*tp, 0);\n\t*tp = ntp;\n\t*committed = 1;\n\t/*\n\t * We have a new transaction, so we should return committed=1,\n\t * even though we're returning an error.\n\t */\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(ntp->t_ticket);\n\n\terror = xfs_trans_reserve(ntp, &tres, 0, 0);\n\tif (error)\n\t\treturn error;\n\tefd = xfs_trans_get_efd(ntp, efi, flist->xbf_count);\n\tfor (free = flist->xbf_first; free != NULL; free = next) {\n\t\tnext = free->xbfi_next;\n\t\tif ((error = xfs_free_extent(ntp, free->xbfi_startblock,\n\t\t\t\tfree->xbfi_blockcount))) {\n\t\t\t/*\n\t\t\t * The bmap free list will be cleaned up at a\n\t\t\t * higher level.  The EFI will be canceled when\n\t\t\t * this transaction is aborted.\n\t\t\t * Need to force shutdown here to make sure it\n\t\t\t * happens, since this transaction may not be\n\t\t\t * dirty yet.\n\t\t\t */\n\t\t\tmp = ntp->t_mountp;\n\t\t\tif (!XFS_FORCED_SHUTDOWN(mp))\n\t\t\t\txfs_force_shutdown(mp,\n\t\t\t\t\t\t   (error == -EFSCORRUPTED) ?\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE :\n\t\t\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\txfs_trans_log_efd_extent(ntp, efd, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error */\nxfs_bmap_finish(\n\txfs_trans_t\t\t**tp,\t\t/* transaction pointer addr */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*committed)\t/* xact committed or not */\n{\n\txfs_efd_log_item_t\t*efd;\t\t/* extent free data */\n\txfs_efi_log_item_t\t*efi;\t\t/* extent free intention */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_bmap_free_item_t\t*free;\t\t/* free extent item */\n\tstruct xfs_trans_res\ttres;\t\t/* new log reservation */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount structure */\n\txfs_bmap_free_item_t\t*next;\t\t/* next item on free list */\n\txfs_trans_t\t\t*ntp;\t\t/* new transaction pointer */\n\n\tASSERT((*tp)->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tif (flist->xbf_count == 0) {\n\t\t*committed = 0;\n\t\treturn 0;\n\t}\n\tntp = *tp;\n\tefi = xfs_trans_get_efi(ntp, flist->xbf_count);\n\tfor (free = flist->xbf_first; free; free = free->xbfi_next)\n\t\txfs_trans_log_efi_extent(ntp, efi, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\n\ttres.tr_logres = ntp->t_log_res;\n\ttres.tr_logcount = ntp->t_log_count;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\tntp = xfs_trans_dup(*tp);\n\terror = xfs_trans_commit(*tp, 0);\n\t*tp = ntp;\n\t*committed = 1;\n\t/*\n\t * We have a new transaction, so we should return committed=1,\n\t * even though we're returning an error.\n\t */\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(ntp->t_ticket);\n\n\terror = xfs_trans_reserve(ntp, &tres, 0, 0);\n\tif (error)\n\t\treturn error;\n\tefd = xfs_trans_get_efd(ntp, efi, flist->xbf_count);\n\tfor (free = flist->xbf_first; free != NULL; free = next) {\n\t\tnext = free->xbfi_next;\n\t\tif ((error = xfs_free_extent(ntp, free->xbfi_startblock,\n\t\t\t\tfree->xbfi_blockcount))) {\n\t\t\t/*\n\t\t\t * The bmap free list will be cleaned up at a\n\t\t\t * higher level.  The EFI will be canceled when\n\t\t\t * this transaction is aborted.\n\t\t\t * Need to force shutdown here to make sure it\n\t\t\t * happens, since this transaction may not be\n\t\t\t * dirty yet.\n\t\t\t */\n\t\t\tmp = ntp->t_mountp;\n\t\t\tif (!XFS_FORCED_SHUTDOWN(mp))\n\t\t\t\txfs_force_shutdown(mp,\n\t\t\t\t\t\t   (error == -EFSCORRUPTED) ?\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE :\n\t\t\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\txfs_trans_log_efd_extent(ntp, efd, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_shift_extents",
          "args": [
            "tp",
            "ip",
            "start_fsb",
            "shift_fsb",
            "&done",
            "&next_fsb",
            "&first_block",
            "&free_list",
            "XFS_BMAP_MAX_SHIFT_EXTENTS"
          ],
          "line": 1476
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_shift_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "5593-5698",
          "snippet": "int\nxfs_bmap_shift_extents(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tstart_fsb,\n\txfs_fileoff_t\t\toffset_shift_fsb,\n\tint\t\t\t*done,\n\txfs_fileoff_t\t\t*next_fsb,\n\txfs_fsblock_t\t\t*firstblock,\n\tstruct xfs_bmap_free\t*flist,\n\tint\t\t\tnum_exts)\n{\n\tstruct xfs_btree_cur\t\t*cur = NULL;\n\tstruct xfs_bmbt_rec_host\t*gotp;\n\tstruct xfs_bmbt_irec            got;\n\tstruct xfs_mount\t\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t\t*ifp;\n\txfs_extnum_t\t\t\tnexts = 0;\n\txfs_extnum_t\t\t\tcurrent_ext;\n\tint\t\t\t\terror = 0;\n\tint\t\t\t\twhichfork = XFS_DATA_FORK;\n\tint\t\t\t\tlogflags = 0;\n\tint\t\t\t\ttotal_extents;\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmap_shift_extents\",\n\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\t/* Read in all the extents */\n\t\terror = xfs_iread_extents(tp, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (ifp->if_flags & XFS_IFBROOT) {\n\t\tcur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);\n\t\tcur->bc_private.b.firstblock = *firstblock;\n\t\tcur->bc_private.b.flist = flist;\n\t\tcur->bc_private.b.flags = 0;\n\t}\n\n\t/*\n\t * Look up the extent index for the fsb where we start shifting. We can\n\t * henceforth iterate with current_ext as extent list changes are locked\n\t * out via ilock.\n\t *\n\t * gotp can be null in 2 cases: 1) if there are no extents or 2)\n\t * start_fsb lies in a hole beyond which there are no extents. Either\n\t * way, we are done.\n\t */\n\tgotp = xfs_iext_bno_to_ext(ifp, start_fsb, &current_ext);\n\tif (!gotp) {\n\t\t*done = 1;\n\t\tgoto del_cursor;\n\t}\n\n\t/*\n\t * There may be delalloc extents in the data fork before the range we\n\t * are collapsing out, so we cannot use the count of real extents here.\n\t * Instead we have to calculate it from the incore fork.\n\t */\n\ttotal_extents = ifp->if_bytes / sizeof(xfs_bmbt_rec_t);\n\twhile (nexts++ < num_exts && current_ext < total_extents) {\n\t\terror = xfs_bmse_shift_one(ip, whichfork, offset_shift_fsb,\n\t\t\t\t\t&current_ext, gotp, cur, &logflags);\n\t\tif (error)\n\t\t\tgoto del_cursor;\n\n\t\t/* update total extent count and grab the next record */\n\t\ttotal_extents = ifp->if_bytes / sizeof(xfs_bmbt_rec_t);\n\t\tif (current_ext >= total_extents)\n\t\t\tbreak;\n\t\tgotp = xfs_iext_get_ext(ifp, current_ext);\n\t}\n\n\t/* Check if we are done */\n\tif (current_ext == total_extents) {\n\t\t*done = 1;\n\t} else if (next_fsb) {\n\t\txfs_bmbt_get_all(gotp, &got);\n\t\t*next_fsb = got.br_startoff;\n\t}\n\ndel_cursor:\n\tif (cur)\n\t\txfs_btree_del_cursor(cur,\n\t\t\terror ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\n\n\tif (logflags)\n\t\txfs_trans_log_inode(tp, ip, logflags);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmap_shift_extents(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tstart_fsb,\n\txfs_fileoff_t\t\toffset_shift_fsb,\n\tint\t\t\t*done,\n\txfs_fileoff_t\t\t*next_fsb,\n\txfs_fsblock_t\t\t*firstblock,\n\tstruct xfs_bmap_free\t*flist,\n\tint\t\t\tnum_exts)\n{\n\tstruct xfs_btree_cur\t\t*cur = NULL;\n\tstruct xfs_bmbt_rec_host\t*gotp;\n\tstruct xfs_bmbt_irec            got;\n\tstruct xfs_mount\t\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t\t*ifp;\n\txfs_extnum_t\t\t\tnexts = 0;\n\txfs_extnum_t\t\t\tcurrent_ext;\n\tint\t\t\t\terror = 0;\n\tint\t\t\t\twhichfork = XFS_DATA_FORK;\n\tint\t\t\t\tlogflags = 0;\n\tint\t\t\t\ttotal_extents;\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmap_shift_extents\",\n\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\t/* Read in all the extents */\n\t\terror = xfs_iread_extents(tp, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (ifp->if_flags & XFS_IFBROOT) {\n\t\tcur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);\n\t\tcur->bc_private.b.firstblock = *firstblock;\n\t\tcur->bc_private.b.flist = flist;\n\t\tcur->bc_private.b.flags = 0;\n\t}\n\n\t/*\n\t * Look up the extent index for the fsb where we start shifting. We can\n\t * henceforth iterate with current_ext as extent list changes are locked\n\t * out via ilock.\n\t *\n\t * gotp can be null in 2 cases: 1) if there are no extents or 2)\n\t * start_fsb lies in a hole beyond which there are no extents. Either\n\t * way, we are done.\n\t */\n\tgotp = xfs_iext_bno_to_ext(ifp, start_fsb, &current_ext);\n\tif (!gotp) {\n\t\t*done = 1;\n\t\tgoto del_cursor;\n\t}\n\n\t/*\n\t * There may be delalloc extents in the data fork before the range we\n\t * are collapsing out, so we cannot use the count of real extents here.\n\t * Instead we have to calculate it from the incore fork.\n\t */\n\ttotal_extents = ifp->if_bytes / sizeof(xfs_bmbt_rec_t);\n\twhile (nexts++ < num_exts && current_ext < total_extents) {\n\t\terror = xfs_bmse_shift_one(ip, whichfork, offset_shift_fsb,\n\t\t\t\t\t&current_ext, gotp, cur, &logflags);\n\t\tif (error)\n\t\t\tgoto del_cursor;\n\n\t\t/* update total extent count and grab the next record */\n\t\ttotal_extents = ifp->if_bytes / sizeof(xfs_bmbt_rec_t);\n\t\tif (current_ext >= total_extents)\n\t\t\tbreak;\n\t\tgotp = xfs_iext_get_ext(ifp, current_ext);\n\t}\n\n\t/* Check if we are done */\n\tif (current_ext == total_extents) {\n\t\t*done = 1;\n\t} else if (next_fsb) {\n\t\txfs_bmbt_get_all(gotp, &got);\n\t\t*next_fsb = got.br_startoff;\n\t}\n\ndel_cursor:\n\tif (cur)\n\t\txfs_btree_del_cursor(cur,\n\t\t\terror ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\n\n\tif (logflags)\n\t\txfs_trans_log_inode(tp, ip, logflags);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_init",
          "args": [
            "&free_list",
            "&first_block"
          ],
          "line": 1469
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.h",
          "lines": "133-137",
          "snippet": "static inline void xfs_bmap_init(xfs_bmap_free_t *flp, xfs_fsblock_t *fbp)\n{\n\t((flp)->xbf_first = NULL, (flp)->xbf_count = 0, \\\n\t\t(flp)->xbf_low = 0, *(fbp) = NULLFSBLOCK);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_bmap_init(xfs_bmap_free_t *flp, xfs_fsblock_t *fbp)\n{\n\t((flp)->xbf_first = NULL, (flp)->xbf_count = 0, \\\n\t\t(flp)->xbf_low = 0, *(fbp) = NULLFSBLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ijoin",
          "args": [
            "tp",
            "ip",
            "0"
          ],
          "line": 1467
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ijoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "37-57",
          "snippet": "void\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve_quota",
          "args": [
            "tp",
            "mp",
            "ip->i_udquot",
            "ip->i_gdquot",
            "ip->i_pdquot",
            "XFS_DIOSTRAT_SPACE_RES(mp, 0)",
            "0",
            "XFS_QMOPT_RES_REGBLKS"
          ],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve_quota_bydquots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
          "lines": "740-794",
          "snippet": "int\nxfs_trans_reserve_quota_bydquots(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dquot\t*udqp,\n\tstruct xfs_dquot\t*gdqp,\n\tstruct xfs_dquot\t*pdqp,\n\tlong\t\t\tnblks,\n\tlong\t\t\tninos,\n\tuint\t\t\tflags)\n{\n\tint\t\terror;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) || !XFS_IS_QUOTA_ON(mp))\n\t\treturn 0;\n\n\tif (tp && tp->t_dqinfo == NULL)\n\t\txfs_trans_alloc_dqinfo(tp);\n\n\tASSERT(flags & XFS_QMOPT_RESBLK_MASK);\n\n\tif (udqp) {\n\t\terror = xfs_trans_dqresv(tp, mp, udqp, nblks, ninos,\n\t\t\t\t\t(flags & ~XFS_QMOPT_ENOSPC));\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (gdqp) {\n\t\terror = xfs_trans_dqresv(tp, mp, gdqp, nblks, ninos, flags);\n\t\tif (error)\n\t\t\tgoto unwind_usr;\n\t}\n\n\tif (pdqp) {\n\t\terror = xfs_trans_dqresv(tp, mp, pdqp, nblks, ninos, flags);\n\t\tif (error)\n\t\t\tgoto unwind_grp;\n\t}\n\n\t/*\n\t * Didn't change anything critical, so, no need to log\n\t */\n\treturn 0;\n\nunwind_grp:\n\tflags |= XFS_QMOPT_FORCE_RES;\n\tif (gdqp)\n\t\txfs_trans_dqresv(tp, mp, gdqp, -nblks, -ninos, flags);\nunwind_usr:\n\tflags |= XFS_QMOPT_FORCE_RES;\n\tif (udqp)\n\t\txfs_trans_dqresv(tp, mp, udqp, -nblks, -ninos, flags);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_trans_reserve_quota_bydquots(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dquot\t*udqp,\n\tstruct xfs_dquot\t*gdqp,\n\tstruct xfs_dquot\t*pdqp,\n\tlong\t\t\tnblks,\n\tlong\t\t\tninos,\n\tuint\t\t\tflags)\n{\n\tint\t\terror;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) || !XFS_IS_QUOTA_ON(mp))\n\t\treturn 0;\n\n\tif (tp && tp->t_dqinfo == NULL)\n\t\txfs_trans_alloc_dqinfo(tp);\n\n\tASSERT(flags & XFS_QMOPT_RESBLK_MASK);\n\n\tif (udqp) {\n\t\terror = xfs_trans_dqresv(tp, mp, udqp, nblks, ninos,\n\t\t\t\t\t(flags & ~XFS_QMOPT_ENOSPC));\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (gdqp) {\n\t\terror = xfs_trans_dqresv(tp, mp, gdqp, nblks, ninos, flags);\n\t\tif (error)\n\t\t\tgoto unwind_usr;\n\t}\n\n\tif (pdqp) {\n\t\terror = xfs_trans_dqresv(tp, mp, pdqp, nblks, ninos, flags);\n\t\tif (error)\n\t\t\tgoto unwind_grp;\n\t}\n\n\t/*\n\t * Didn't change anything critical, so, no need to log\n\t */\n\treturn 0;\n\nunwind_grp:\n\tflags |= XFS_QMOPT_FORCE_RES;\n\tif (gdqp)\n\t\txfs_trans_dqresv(tp, mp, gdqp, -nblks, -ninos, flags);\nunwind_usr:\n\tflags |= XFS_QMOPT_FORCE_RES;\n\tif (udqp)\n\t\txfs_trans_dqresv(tp, mp, udqp, -nblks, -ninos, flags);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_DIOSTRAT_SPACE_RES",
          "args": [
            "mp",
            "0"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve",
          "args": [
            "tp",
            "&M_RES(mp)->tr_write",
            "XFS_DIOSTRAT_SPACE_RES(mp, 0)",
            "0"
          ],
          "line": 1452
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "168-279",
          "snippet": "int\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_DIOSTRAT_SPACE_RES",
          "args": [
            "mp",
            "0"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_alloc",
          "args": [
            "mp",
            "XFS_TRANS_DIOSTRAT"
          ],
          "line": 1445
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "57-68",
          "snippet": "xfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "invalidate_inode_pages2_range",
          "args": [
            "VFS_I(ip)->i_mapping",
            "(offset + len) >> PAGE_CACHE_SHIFT",
            "-1"
          ],
          "line": 1439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "ip"
          ],
          "line": 1439
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "78-81",
          "snippet": "static inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait_range",
          "args": [
            "VFS_I(ip)->i_mapping",
            "offset + len",
            "-1"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_free_eofblocks",
          "args": [
            "mp",
            "ip",
            "false"
          ],
          "line": 1423
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_free_eofblocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "833-926",
          "snippet": "int\nxfs_free_eofblocks(\n\txfs_mount_t\t*mp,\n\txfs_inode_t\t*ip,\n\tbool\t\tneed_iolock)\n{\n\txfs_trans_t\t*tp;\n\tint\t\terror;\n\txfs_fileoff_t\tend_fsb;\n\txfs_fileoff_t\tlast_fsb;\n\txfs_filblks_t\tmap_len;\n\tint\t\tnimaps;\n\txfs_bmbt_irec_t\timap;\n\n\t/*\n\t * Figure out if there are any blocks beyond the end\n\t * of the file.  If not, then there is nothing to do.\n\t */\n\tend_fsb = XFS_B_TO_FSB(mp, (xfs_ufsize_t)XFS_ISIZE(ip));\n\tlast_fsb = XFS_B_TO_FSB(mp, mp->m_super->s_maxbytes);\n\tif (last_fsb <= end_fsb)\n\t\treturn 0;\n\tmap_len = last_fsb - end_fsb;\n\n\tnimaps = 1;\n\txfs_ilock(ip, XFS_ILOCK_SHARED);\n\terror = xfs_bmapi_read(ip, end_fsb, map_len, &imap, &nimaps, 0);\n\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\n\tif (!error && (nimaps != 0) &&\n\t    (imap.br_startblock != HOLESTARTBLOCK ||\n\t     ip->i_delayed_blks)) {\n\t\t/*\n\t\t * Attach the dquots to the inode up front.\n\t\t */\n\t\terror = xfs_qm_dqattach(ip, 0);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/*\n\t\t * There are blocks after the end of file.\n\t\t * Free them up now by truncating the file to\n\t\t * its current size.\n\t\t */\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_INACTIVE);\n\n\t\tif (need_iolock) {\n\t\t\tif (!xfs_ilock_nowait(ip, XFS_IOLOCK_EXCL)) {\n\t\t\t\txfs_trans_cancel(tp, 0);\n\t\t\t\treturn -EAGAIN;\n\t\t\t}\n\t\t}\n\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\n\t\tif (error) {\n\t\t\tASSERT(XFS_FORCED_SHUTDOWN(mp));\n\t\t\txfs_trans_cancel(tp, 0);\n\t\t\tif (need_iolock)\n\t\t\t\txfs_iunlock(ip, XFS_IOLOCK_EXCL);\n\t\t\treturn error;\n\t\t}\n\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\txfs_trans_ijoin(tp, ip, 0);\n\n\t\t/*\n\t\t * Do not update the on-disk file size.  If we update the\n\t\t * on-disk file size and then the system crashes before the\n\t\t * contents of the file are flushed to disk then the files\n\t\t * may be full of holes (ie NULL files bug).\n\t\t */\n\t\terror = xfs_itruncate_extents(&tp, ip, XFS_DATA_FORK,\n\t\t\t\t\t      XFS_ISIZE(ip));\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * If we get an error at this point we simply don't\n\t\t\t * bother truncating the file.\n\t\t\t */\n\t\t\txfs_trans_cancel(tp,\n\t\t\t\t\t (XFS_TRANS_RELEASE_LOG_RES |\n\t\t\t\t\t  XFS_TRANS_ABORT));\n\t\t} else {\n\t\t\terror = xfs_trans_commit(tp,\n\t\t\t\t\t\tXFS_TRANS_RELEASE_LOG_RES);\n\t\t\tif (!error)\n\t\t\t\txfs_inode_clear_eofblocks_tag(ip);\n\t\t}\n\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\tif (need_iolock)\n\t\t\txfs_iunlock(ip, XFS_IOLOCK_EXCL);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_free_eofblocks(\n\txfs_mount_t\t*mp,\n\txfs_inode_t\t*ip,\n\tbool\t\tneed_iolock)\n{\n\txfs_trans_t\t*tp;\n\tint\t\terror;\n\txfs_fileoff_t\tend_fsb;\n\txfs_fileoff_t\tlast_fsb;\n\txfs_filblks_t\tmap_len;\n\tint\t\tnimaps;\n\txfs_bmbt_irec_t\timap;\n\n\t/*\n\t * Figure out if there are any blocks beyond the end\n\t * of the file.  If not, then there is nothing to do.\n\t */\n\tend_fsb = XFS_B_TO_FSB(mp, (xfs_ufsize_t)XFS_ISIZE(ip));\n\tlast_fsb = XFS_B_TO_FSB(mp, mp->m_super->s_maxbytes);\n\tif (last_fsb <= end_fsb)\n\t\treturn 0;\n\tmap_len = last_fsb - end_fsb;\n\n\tnimaps = 1;\n\txfs_ilock(ip, XFS_ILOCK_SHARED);\n\terror = xfs_bmapi_read(ip, end_fsb, map_len, &imap, &nimaps, 0);\n\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\n\tif (!error && (nimaps != 0) &&\n\t    (imap.br_startblock != HOLESTARTBLOCK ||\n\t     ip->i_delayed_blks)) {\n\t\t/*\n\t\t * Attach the dquots to the inode up front.\n\t\t */\n\t\terror = xfs_qm_dqattach(ip, 0);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/*\n\t\t * There are blocks after the end of file.\n\t\t * Free them up now by truncating the file to\n\t\t * its current size.\n\t\t */\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_INACTIVE);\n\n\t\tif (need_iolock) {\n\t\t\tif (!xfs_ilock_nowait(ip, XFS_IOLOCK_EXCL)) {\n\t\t\t\txfs_trans_cancel(tp, 0);\n\t\t\t\treturn -EAGAIN;\n\t\t\t}\n\t\t}\n\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\n\t\tif (error) {\n\t\t\tASSERT(XFS_FORCED_SHUTDOWN(mp));\n\t\t\txfs_trans_cancel(tp, 0);\n\t\t\tif (need_iolock)\n\t\t\t\txfs_iunlock(ip, XFS_IOLOCK_EXCL);\n\t\t\treturn error;\n\t\t}\n\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\txfs_trans_ijoin(tp, ip, 0);\n\n\t\t/*\n\t\t * Do not update the on-disk file size.  If we update the\n\t\t * on-disk file size and then the system crashes before the\n\t\t * contents of the file are flushed to disk then the files\n\t\t * may be full of holes (ie NULL files bug).\n\t\t */\n\t\terror = xfs_itruncate_extents(&tp, ip, XFS_DATA_FORK,\n\t\t\t\t\t      XFS_ISIZE(ip));\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * If we get an error at this point we simply don't\n\t\t\t * bother truncating the file.\n\t\t\t */\n\t\t\txfs_trans_cancel(tp,\n\t\t\t\t\t (XFS_TRANS_RELEASE_LOG_RES |\n\t\t\t\t\t  XFS_TRANS_ABORT));\n\t\t} else {\n\t\t\terror = xfs_trans_commit(tp,\n\t\t\t\t\t\tXFS_TRANS_RELEASE_LOG_RES);\n\t\t\tif (!error)\n\t\t\t\txfs_inode_clear_eofblocks_tag(ip);\n\t\t}\n\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\tif (need_iolock)\n\t\t\txfs_iunlock(ip, XFS_IOLOCK_EXCL);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_can_free_eofblocks",
          "args": [
            "ip",
            "true"
          ],
          "line": 1422
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_can_free_eofblocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "797-826",
          "snippet": "bool\nxfs_can_free_eofblocks(struct xfs_inode *ip, bool force)\n{\n\t/* prealloc/delalloc exists only on regular files */\n\tif (!S_ISREG(ip->i_d.di_mode))\n\t\treturn false;\n\n\t/*\n\t * Zero sized files with no cached pages and delalloc blocks will not\n\t * have speculative prealloc/delalloc blocks to remove.\n\t */\n\tif (VFS_I(ip)->i_size == 0 &&\n\t    VFS_I(ip)->i_mapping->nrpages == 0 &&\n\t    ip->i_delayed_blks == 0)\n\t\treturn false;\n\n\t/* If we haven't read in the extent list, then don't do it now. */\n\tif (!(ip->i_df.if_flags & XFS_IFEXTENTS))\n\t\treturn false;\n\n\t/*\n\t * Do not free real preallocated or append-only files unless the file\n\t * has delalloc blocks and we are forced to remove them.\n\t */\n\tif (ip->i_d.di_flags & (XFS_DIFLAG_PREALLOC | XFS_DIFLAG_APPEND))\n\t\tif (!force || ip->i_delayed_blks == 0)\n\t\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nbool\nxfs_can_free_eofblocks(struct xfs_inode *ip, bool force)\n{\n\t/* prealloc/delalloc exists only on regular files */\n\tif (!S_ISREG(ip->i_d.di_mode))\n\t\treturn false;\n\n\t/*\n\t * Zero sized files with no cached pages and delalloc blocks will not\n\t * have speculative prealloc/delalloc blocks to remove.\n\t */\n\tif (VFS_I(ip)->i_size == 0 &&\n\t    VFS_I(ip)->i_mapping->nrpages == 0 &&\n\t    ip->i_delayed_blks == 0)\n\t\treturn false;\n\n\t/* If we haven't read in the extent list, then don't do it now. */\n\tif (!(ip->i_df.if_flags & XFS_IFEXTENTS))\n\t\treturn false;\n\n\t/*\n\t * Do not free real preallocated or append-only files unless the file\n\t * has delalloc blocks and we are forced to remove them.\n\t */\n\tif (ip->i_d.di_flags & (XFS_DIFLAG_PREALLOC | XFS_DIFLAG_APPEND))\n\t\tif (!force || ip->i_delayed_blks == 0)\n\t\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_free_file_space",
          "args": [
            "ip",
            "offset",
            "len"
          ],
          "line": 1414
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_free_file_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "1165-1336",
          "snippet": "int\nxfs_free_file_space(\n\tstruct xfs_inode\t*ip,\n\txfs_off_t\t\toffset,\n\txfs_off_t\t\tlen)\n{\n\tint\t\t\tcommitted;\n\tint\t\t\tdone;\n\txfs_fileoff_t\t\tendoffset_fsb;\n\tint\t\t\terror;\n\txfs_fsblock_t\t\tfirstfsb;\n\txfs_bmap_free_t\t\tfree_list;\n\txfs_bmbt_irec_t\t\timap;\n\txfs_off_t\t\tioffset;\n\txfs_off_t\t\tiendoffset;\n\txfs_extlen_t\t\tmod=0;\n\txfs_mount_t\t\t*mp;\n\tint\t\t\tnimap;\n\tuint\t\t\tresblks;\n\txfs_off_t\t\trounding;\n\tint\t\t\trt;\n\txfs_fileoff_t\t\tstartoffset_fsb;\n\txfs_trans_t\t\t*tp;\n\n\tmp = ip->i_mount;\n\n\ttrace_xfs_free_file_space(ip);\n\n\terror = xfs_qm_dqattach(ip, 0);\n\tif (error)\n\t\treturn error;\n\n\terror = 0;\n\tif (len <= 0)\t/* if nothing being freed */\n\t\treturn error;\n\trt = XFS_IS_REALTIME_INODE(ip);\n\tstartoffset_fsb\t= XFS_B_TO_FSB(mp, offset);\n\tendoffset_fsb = XFS_B_TO_FSBT(mp, offset + len);\n\n\t/* wait for the completion of any pending DIOs */\n\tinode_dio_wait(VFS_I(ip));\n\n\trounding = max_t(xfs_off_t, 1 << mp->m_sb.sb_blocklog, PAGE_CACHE_SIZE);\n\tioffset = round_down(offset, rounding);\n\tiendoffset = round_up(offset + len, rounding) - 1;\n\terror = filemap_write_and_wait_range(VFS_I(ip)->i_mapping, ioffset,\n\t\t\t\t\t     iendoffset);\n\tif (error)\n\t\tgoto out;\n\ttruncate_pagecache_range(VFS_I(ip), ioffset, iendoffset);\n\n\t/*\n\t * Need to zero the stuff we're not freeing, on disk.\n\t * If it's a realtime file & can't use unwritten extents then we\n\t * actually need to zero the extent edges.  Otherwise xfs_bunmapi\n\t * will take care of it for us.\n\t */\n\tif (rt && !xfs_sb_version_hasextflgbit(&mp->m_sb)) {\n\t\tnimap = 1;\n\t\terror = xfs_bmapi_read(ip, startoffset_fsb, 1,\n\t\t\t\t\t&imap, &nimap, 0);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tASSERT(nimap == 0 || nimap == 1);\n\t\tif (nimap && imap.br_startblock != HOLESTARTBLOCK) {\n\t\t\txfs_daddr_t\tblock;\n\n\t\t\tASSERT(imap.br_startblock != DELAYSTARTBLOCK);\n\t\t\tblock = imap.br_startblock;\n\t\t\tmod = do_div(block, mp->m_sb.sb_rextsize);\n\t\t\tif (mod)\n\t\t\t\tstartoffset_fsb += mp->m_sb.sb_rextsize - mod;\n\t\t}\n\t\tnimap = 1;\n\t\terror = xfs_bmapi_read(ip, endoffset_fsb - 1, 1,\n\t\t\t\t\t&imap, &nimap, 0);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tASSERT(nimap == 0 || nimap == 1);\n\t\tif (nimap && imap.br_startblock != HOLESTARTBLOCK) {\n\t\t\tASSERT(imap.br_startblock != DELAYSTARTBLOCK);\n\t\t\tmod++;\n\t\t\tif (mod && (mod != mp->m_sb.sb_rextsize))\n\t\t\t\tendoffset_fsb -= mod;\n\t\t}\n\t}\n\tif ((done = (endoffset_fsb <= startoffset_fsb)))\n\t\t/*\n\t\t * One contiguous piece to clear\n\t\t */\n\t\terror = xfs_zero_remaining_bytes(ip, offset, offset + len - 1);\n\telse {\n\t\t/*\n\t\t * Some full blocks, possibly two pieces to clear\n\t\t */\n\t\tif (offset < XFS_FSB_TO_B(mp, startoffset_fsb))\n\t\t\terror = xfs_zero_remaining_bytes(ip, offset,\n\t\t\t\tXFS_FSB_TO_B(mp, startoffset_fsb) - 1);\n\t\tif (!error &&\n\t\t    XFS_FSB_TO_B(mp, endoffset_fsb) < offset + len)\n\t\t\terror = xfs_zero_remaining_bytes(ip,\n\t\t\t\tXFS_FSB_TO_B(mp, endoffset_fsb),\n\t\t\t\toffset + len - 1);\n\t}\n\n\t/*\n\t * free file space until done or until there is an error\n\t */\n\tresblks = XFS_DIOSTRAT_SPACE_RES(mp, 0);\n\twhile (!error && !done) {\n\n\t\t/*\n\t\t * allocate and setup the transaction. Allow this\n\t\t * transaction to dip into the reserve blocks to ensure\n\t\t * the freeing of the space succeeds at ENOSPC.\n\t\t */\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_DIOSTRAT);\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_write, resblks, 0);\n\n\t\t/*\n\t\t * check for running out of space\n\t\t */\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * Free the transaction structure.\n\t\t\t */\n\t\t\tASSERT(error == -ENOSPC || XFS_FORCED_SHUTDOWN(mp));\n\t\t\txfs_trans_cancel(tp, 0);\n\t\t\tbreak;\n\t\t}\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\terror = xfs_trans_reserve_quota(tp, mp,\n\t\t\t\tip->i_udquot, ip->i_gdquot, ip->i_pdquot,\n\t\t\t\tresblks, 0, XFS_QMOPT_RES_REGBLKS);\n\t\tif (error)\n\t\t\tgoto error1;\n\n\t\txfs_trans_ijoin(tp, ip, 0);\n\n\t\t/*\n\t\t * issue the bunmapi() call to free the blocks\n\t\t */\n\t\txfs_bmap_init(&free_list, &firstfsb);\n\t\terror = xfs_bunmapi(tp, ip, startoffset_fsb,\n\t\t\t\t  endoffset_fsb - startoffset_fsb,\n\t\t\t\t  0, 2, &firstfsb, &free_list, &done);\n\t\tif (error) {\n\t\t\tgoto error0;\n\t\t}\n\n\t\t/*\n\t\t * complete the transaction\n\t\t */\n\t\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\t\tif (error) {\n\t\t\tgoto error0;\n\t\t}\n\n\t\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t}\n\n out:\n\treturn error;\n\n error0:\n\txfs_bmap_cancel(&free_list);\n error1:\n\txfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\tgoto out;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_free_file_space(\n\tstruct xfs_inode\t*ip,\n\txfs_off_t\t\toffset,\n\txfs_off_t\t\tlen)\n{\n\tint\t\t\tcommitted;\n\tint\t\t\tdone;\n\txfs_fileoff_t\t\tendoffset_fsb;\n\tint\t\t\terror;\n\txfs_fsblock_t\t\tfirstfsb;\n\txfs_bmap_free_t\t\tfree_list;\n\txfs_bmbt_irec_t\t\timap;\n\txfs_off_t\t\tioffset;\n\txfs_off_t\t\tiendoffset;\n\txfs_extlen_t\t\tmod=0;\n\txfs_mount_t\t\t*mp;\n\tint\t\t\tnimap;\n\tuint\t\t\tresblks;\n\txfs_off_t\t\trounding;\n\tint\t\t\trt;\n\txfs_fileoff_t\t\tstartoffset_fsb;\n\txfs_trans_t\t\t*tp;\n\n\tmp = ip->i_mount;\n\n\ttrace_xfs_free_file_space(ip);\n\n\terror = xfs_qm_dqattach(ip, 0);\n\tif (error)\n\t\treturn error;\n\n\terror = 0;\n\tif (len <= 0)\t/* if nothing being freed */\n\t\treturn error;\n\trt = XFS_IS_REALTIME_INODE(ip);\n\tstartoffset_fsb\t= XFS_B_TO_FSB(mp, offset);\n\tendoffset_fsb = XFS_B_TO_FSBT(mp, offset + len);\n\n\t/* wait for the completion of any pending DIOs */\n\tinode_dio_wait(VFS_I(ip));\n\n\trounding = max_t(xfs_off_t, 1 << mp->m_sb.sb_blocklog, PAGE_CACHE_SIZE);\n\tioffset = round_down(offset, rounding);\n\tiendoffset = round_up(offset + len, rounding) - 1;\n\terror = filemap_write_and_wait_range(VFS_I(ip)->i_mapping, ioffset,\n\t\t\t\t\t     iendoffset);\n\tif (error)\n\t\tgoto out;\n\ttruncate_pagecache_range(VFS_I(ip), ioffset, iendoffset);\n\n\t/*\n\t * Need to zero the stuff we're not freeing, on disk.\n\t * If it's a realtime file & can't use unwritten extents then we\n\t * actually need to zero the extent edges.  Otherwise xfs_bunmapi\n\t * will take care of it for us.\n\t */\n\tif (rt && !xfs_sb_version_hasextflgbit(&mp->m_sb)) {\n\t\tnimap = 1;\n\t\terror = xfs_bmapi_read(ip, startoffset_fsb, 1,\n\t\t\t\t\t&imap, &nimap, 0);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tASSERT(nimap == 0 || nimap == 1);\n\t\tif (nimap && imap.br_startblock != HOLESTARTBLOCK) {\n\t\t\txfs_daddr_t\tblock;\n\n\t\t\tASSERT(imap.br_startblock != DELAYSTARTBLOCK);\n\t\t\tblock = imap.br_startblock;\n\t\t\tmod = do_div(block, mp->m_sb.sb_rextsize);\n\t\t\tif (mod)\n\t\t\t\tstartoffset_fsb += mp->m_sb.sb_rextsize - mod;\n\t\t}\n\t\tnimap = 1;\n\t\terror = xfs_bmapi_read(ip, endoffset_fsb - 1, 1,\n\t\t\t\t\t&imap, &nimap, 0);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tASSERT(nimap == 0 || nimap == 1);\n\t\tif (nimap && imap.br_startblock != HOLESTARTBLOCK) {\n\t\t\tASSERT(imap.br_startblock != DELAYSTARTBLOCK);\n\t\t\tmod++;\n\t\t\tif (mod && (mod != mp->m_sb.sb_rextsize))\n\t\t\t\tendoffset_fsb -= mod;\n\t\t}\n\t}\n\tif ((done = (endoffset_fsb <= startoffset_fsb)))\n\t\t/*\n\t\t * One contiguous piece to clear\n\t\t */\n\t\terror = xfs_zero_remaining_bytes(ip, offset, offset + len - 1);\n\telse {\n\t\t/*\n\t\t * Some full blocks, possibly two pieces to clear\n\t\t */\n\t\tif (offset < XFS_FSB_TO_B(mp, startoffset_fsb))\n\t\t\terror = xfs_zero_remaining_bytes(ip, offset,\n\t\t\t\tXFS_FSB_TO_B(mp, startoffset_fsb) - 1);\n\t\tif (!error &&\n\t\t    XFS_FSB_TO_B(mp, endoffset_fsb) < offset + len)\n\t\t\terror = xfs_zero_remaining_bytes(ip,\n\t\t\t\tXFS_FSB_TO_B(mp, endoffset_fsb),\n\t\t\t\toffset + len - 1);\n\t}\n\n\t/*\n\t * free file space until done or until there is an error\n\t */\n\tresblks = XFS_DIOSTRAT_SPACE_RES(mp, 0);\n\twhile (!error && !done) {\n\n\t\t/*\n\t\t * allocate and setup the transaction. Allow this\n\t\t * transaction to dip into the reserve blocks to ensure\n\t\t * the freeing of the space succeeds at ENOSPC.\n\t\t */\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_DIOSTRAT);\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_write, resblks, 0);\n\n\t\t/*\n\t\t * check for running out of space\n\t\t */\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * Free the transaction structure.\n\t\t\t */\n\t\t\tASSERT(error == -ENOSPC || XFS_FORCED_SHUTDOWN(mp));\n\t\t\txfs_trans_cancel(tp, 0);\n\t\t\tbreak;\n\t\t}\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\terror = xfs_trans_reserve_quota(tp, mp,\n\t\t\t\tip->i_udquot, ip->i_gdquot, ip->i_pdquot,\n\t\t\t\tresblks, 0, XFS_QMOPT_RES_REGBLKS);\n\t\tif (error)\n\t\t\tgoto error1;\n\n\t\txfs_trans_ijoin(tp, ip, 0);\n\n\t\t/*\n\t\t * issue the bunmapi() call to free the blocks\n\t\t */\n\t\txfs_bmap_init(&free_list, &firstfsb);\n\t\terror = xfs_bunmapi(tp, ip, startoffset_fsb,\n\t\t\t\t  endoffset_fsb - startoffset_fsb,\n\t\t\t\t  0, 2, &firstfsb, &free_list, &done);\n\t\tif (error) {\n\t\t\tgoto error0;\n\t\t}\n\n\t\t/*\n\t\t * complete the transaction\n\t\t */\n\t\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\t\tif (error) {\n\t\t\tgoto error0;\n\t\t}\n\n\t\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t}\n\n out:\n\treturn error;\n\n error0:\n\txfs_bmap_cancel(&free_list);\n error1:\n\txfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_B_TO_FSB",
          "args": [
            "mp",
            "len"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_B_TO_FSB",
          "args": [
            "mp",
            "offset + len"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_collapse_file_space",
          "args": [
            "ip"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_isilocked(ip, XFS_IOLOCK_EXCL)"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_isilocked",
          "args": [
            "ip",
            "XFS_IOLOCK_EXCL"
          ],
          "line": 1407
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_isilocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "286-305",
          "snippet": "int\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_collapse_file_space(\n\tstruct xfs_inode\t*ip,\n\txfs_off_t\t\toffset,\n\txfs_off_t\t\tlen)\n{\n\tint\t\t\tdone = 0;\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\tstruct xfs_bmap_free\tfree_list;\n\txfs_fsblock_t\t\tfirst_block;\n\tint\t\t\tcommitted;\n\txfs_fileoff_t\t\tstart_fsb;\n\txfs_fileoff_t\t\tnext_fsb;\n\txfs_fileoff_t\t\tshift_fsb;\n\n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\n\ttrace_xfs_collapse_file_space(ip);\n\n\tnext_fsb = XFS_B_TO_FSB(mp, offset + len);\n\tshift_fsb = XFS_B_TO_FSB(mp, len);\n\n\terror = xfs_free_file_space(ip, offset, len);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Trim eofblocks to avoid shifting uninitialized post-eof preallocation\n\t * into the accessible region of the file.\n\t */\n\tif (xfs_can_free_eofblocks(ip, true)) {\n\t\terror = xfs_free_eofblocks(mp, ip, false);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * Writeback and invalidate cache for the remainder of the file as we're\n\t * about to shift down every extent from the collapse range to EOF. The\n\t * free of the collapse range above might have already done some of\n\t * this, but we shouldn't rely on it to do anything outside of the range\n\t * that was freed.\n\t */\n\terror = filemap_write_and_wait_range(VFS_I(ip)->i_mapping,\n\t\t\t\t\t     offset + len, -1);\n\tif (error)\n\t\treturn error;\n\terror = invalidate_inode_pages2_range(VFS_I(ip)->i_mapping,\n\t\t\t\t\t(offset + len) >> PAGE_CACHE_SHIFT, -1);\n\tif (error)\n\t\treturn error;\n\n\twhile (!error && !done) {\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_DIOSTRAT);\n\t\t/*\n\t\t * We would need to reserve permanent block for transaction.\n\t\t * This will come into picture when after shifting extent into\n\t\t * hole we found that adjacent extents can be merged which\n\t\t * may lead to freeing of a block during record update.\n\t\t */\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_write,\n\t\t\t\tXFS_DIOSTRAT_SPACE_RES(mp, 0), 0);\n\t\tif (error) {\n\t\t\txfs_trans_cancel(tp, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\terror = xfs_trans_reserve_quota(tp, mp, ip->i_udquot,\n\t\t\t\tip->i_gdquot, ip->i_pdquot,\n\t\t\t\tXFS_DIOSTRAT_SPACE_RES(mp, 0), 0,\n\t\t\t\tXFS_QMOPT_RES_REGBLKS);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\txfs_trans_ijoin(tp, ip, 0);\n\n\t\txfs_bmap_init(&free_list, &first_block);\n\n\t\t/*\n\t\t * We are using the write transaction in which max 2 bmbt\n\t\t * updates are allowed\n\t\t */\n\t\tstart_fsb = next_fsb;\n\t\terror = xfs_bmap_shift_extents(tp, ip, start_fsb, shift_fsb,\n\t\t\t\t&done, &next_fsb, &first_block, &free_list,\n\t\t\t\tXFS_BMAP_MAX_SHIFT_EXTENTS);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t}\n\n\treturn error;\n\nout:\n\txfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_zero_file_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
    "lines": "1342-1376",
    "snippet": "int\nxfs_zero_file_space(\n\tstruct xfs_inode\t*ip,\n\txfs_off_t\t\toffset,\n\txfs_off_t\t\tlen)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tuint\t\t\tblksize;\n\tint\t\t\terror;\n\n\ttrace_xfs_zero_file_space(ip);\n\n\tblksize = 1 << mp->m_sb.sb_blocklog;\n\n\t/*\n\t * Punch a hole and prealloc the range. We use hole punch rather than\n\t * unwritten extent conversion for two reasons:\n\t *\n\t * 1.) Hole punch handles partial block zeroing for us.\n\t *\n\t * 2.) If prealloc returns ENOSPC, the file range is still zero-valued\n\t * by virtue of the hole punch.\n\t */\n\terror = xfs_free_file_space(ip, offset, len);\n\tif (error)\n\t\tgoto out;\n\n\terror = xfs_alloc_file_space(ip, round_down(offset, blksize),\n\t\t\t\t     round_up(offset + len, blksize) -\n\t\t\t\t     round_down(offset, blksize),\n\t\t\t\t     XFS_BMAPI_PREALLOC);\nout:\n\treturn error;\n\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_alloc_file_space",
          "args": [
            "ip",
            "round_down(offset, blksize)",
            "round_up(offset + len, blksize) -\n\t\t\t\t     round_down(offset, blksize)",
            "XFS_BMAPI_PREALLOC"
          ],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_file_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "928-1083",
          "snippet": "int\nxfs_alloc_file_space(\n\tstruct xfs_inode\t*ip,\n\txfs_off_t\t\toffset,\n\txfs_off_t\t\tlen,\n\tint\t\t\talloc_type)\n{\n\txfs_mount_t\t\t*mp = ip->i_mount;\n\txfs_off_t\t\tcount;\n\txfs_filblks_t\t\tallocated_fsb;\n\txfs_filblks_t\t\tallocatesize_fsb;\n\txfs_extlen_t\t\textsz, temp;\n\txfs_fileoff_t\t\tstartoffset_fsb;\n\txfs_fsblock_t\t\tfirstfsb;\n\tint\t\t\tnimaps;\n\tint\t\t\tquota_flag;\n\tint\t\t\trt;\n\txfs_trans_t\t\t*tp;\n\txfs_bmbt_irec_t\t\timaps[1], *imapp;\n\txfs_bmap_free_t\t\tfree_list;\n\tuint\t\t\tqblocks, resblks, resrtextents;\n\tint\t\t\tcommitted;\n\tint\t\t\terror;\n\n\ttrace_xfs_alloc_file_space(ip);\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\terror = xfs_qm_dqattach(ip, 0);\n\tif (error)\n\t\treturn error;\n\n\tif (len <= 0)\n\t\treturn -EINVAL;\n\n\trt = XFS_IS_REALTIME_INODE(ip);\n\textsz = xfs_get_extsz_hint(ip);\n\n\tcount = len;\n\timapp = &imaps[0];\n\tnimaps = 1;\n\tstartoffset_fsb\t= XFS_B_TO_FSBT(mp, offset);\n\tallocatesize_fsb = XFS_B_TO_FSB(mp, count);\n\n\t/*\n\t * Allocate file space until done or until there is an error\n\t */\n\twhile (allocatesize_fsb && !error) {\n\t\txfs_fileoff_t\ts, e;\n\n\t\t/*\n\t\t * Determine space reservations for data/realtime.\n\t\t */\n\t\tif (unlikely(extsz)) {\n\t\t\ts = startoffset_fsb;\n\t\t\tdo_div(s, extsz);\n\t\t\ts *= extsz;\n\t\t\te = startoffset_fsb + allocatesize_fsb;\n\t\t\tif ((temp = do_mod(startoffset_fsb, extsz)))\n\t\t\t\te += temp;\n\t\t\tif ((temp = do_mod(e, extsz)))\n\t\t\t\te += extsz - temp;\n\t\t} else {\n\t\t\ts = 0;\n\t\t\te = allocatesize_fsb;\n\t\t}\n\n\t\t/*\n\t\t * The transaction reservation is limited to a 32-bit block\n\t\t * count, hence we need to limit the number of blocks we are\n\t\t * trying to reserve to avoid an overflow. We can't allocate\n\t\t * more than @nimaps extents, and an extent is limited on disk\n\t\t * to MAXEXTLEN (21 bits), so use that to enforce the limit.\n\t\t */\n\t\tresblks = min_t(xfs_fileoff_t, (e - s), (MAXEXTLEN * nimaps));\n\t\tif (unlikely(rt)) {\n\t\t\tresrtextents = qblocks = resblks;\n\t\t\tresrtextents /= mp->m_sb.sb_rextsize;\n\t\t\tresblks = XFS_DIOSTRAT_SPACE_RES(mp, 0);\n\t\t\tquota_flag = XFS_QMOPT_RES_RTBLKS;\n\t\t} else {\n\t\t\tresrtextents = 0;\n\t\t\tresblks = qblocks = XFS_DIOSTRAT_SPACE_RES(mp, resblks);\n\t\t\tquota_flag = XFS_QMOPT_RES_REGBLKS;\n\t\t}\n\n\t\t/*\n\t\t * Allocate and setup the transaction.\n\t\t */\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_DIOSTRAT);\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_write,\n\t\t\t\t\t  resblks, resrtextents);\n\t\t/*\n\t\t * Check for running out of space\n\t\t */\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * Free the transaction structure.\n\t\t\t */\n\t\t\tASSERT(error == -ENOSPC || XFS_FORCED_SHUTDOWN(mp));\n\t\t\txfs_trans_cancel(tp, 0);\n\t\t\tbreak;\n\t\t}\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\terror = xfs_trans_reserve_quota_nblks(tp, ip, qblocks,\n\t\t\t\t\t\t      0, quota_flag);\n\t\tif (error)\n\t\t\tgoto error1;\n\n\t\txfs_trans_ijoin(tp, ip, 0);\n\n\t\txfs_bmap_init(&free_list, &firstfsb);\n\t\terror = xfs_bmapi_write(tp, ip, startoffset_fsb,\n\t\t\t\t\tallocatesize_fsb, alloc_type, &firstfsb,\n\t\t\t\t\t0, imapp, &nimaps, &free_list);\n\t\tif (error) {\n\t\t\tgoto error0;\n\t\t}\n\n\t\t/*\n\t\t * Complete the transaction\n\t\t */\n\t\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\t\tif (error) {\n\t\t\tgoto error0;\n\t\t}\n\n\t\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\tif (error) {\n\t\t\tbreak;\n\t\t}\n\n\t\tallocated_fsb = imapp->br_blockcount;\n\n\t\tif (nimaps == 0) {\n\t\t\terror = -ENOSPC;\n\t\t\tbreak;\n\t\t}\n\n\t\tstartoffset_fsb += allocated_fsb;\n\t\tallocatesize_fsb -= allocated_fsb;\n\t}\n\n\treturn error;\n\nerror0:\t/* Cancel bmap, unlock inode, unreserve quota blocks, cancel trans */\n\txfs_bmap_cancel(&free_list);\n\txfs_trans_unreserve_quota_nblks(tp, ip, (long)qblocks, 0, quota_flag);\n\nerror1:\t/* Just cancel transaction */\n\txfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_alloc_file_space(\n\tstruct xfs_inode\t*ip,\n\txfs_off_t\t\toffset,\n\txfs_off_t\t\tlen,\n\tint\t\t\talloc_type)\n{\n\txfs_mount_t\t\t*mp = ip->i_mount;\n\txfs_off_t\t\tcount;\n\txfs_filblks_t\t\tallocated_fsb;\n\txfs_filblks_t\t\tallocatesize_fsb;\n\txfs_extlen_t\t\textsz, temp;\n\txfs_fileoff_t\t\tstartoffset_fsb;\n\txfs_fsblock_t\t\tfirstfsb;\n\tint\t\t\tnimaps;\n\tint\t\t\tquota_flag;\n\tint\t\t\trt;\n\txfs_trans_t\t\t*tp;\n\txfs_bmbt_irec_t\t\timaps[1], *imapp;\n\txfs_bmap_free_t\t\tfree_list;\n\tuint\t\t\tqblocks, resblks, resrtextents;\n\tint\t\t\tcommitted;\n\tint\t\t\terror;\n\n\ttrace_xfs_alloc_file_space(ip);\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\terror = xfs_qm_dqattach(ip, 0);\n\tif (error)\n\t\treturn error;\n\n\tif (len <= 0)\n\t\treturn -EINVAL;\n\n\trt = XFS_IS_REALTIME_INODE(ip);\n\textsz = xfs_get_extsz_hint(ip);\n\n\tcount = len;\n\timapp = &imaps[0];\n\tnimaps = 1;\n\tstartoffset_fsb\t= XFS_B_TO_FSBT(mp, offset);\n\tallocatesize_fsb = XFS_B_TO_FSB(mp, count);\n\n\t/*\n\t * Allocate file space until done or until there is an error\n\t */\n\twhile (allocatesize_fsb && !error) {\n\t\txfs_fileoff_t\ts, e;\n\n\t\t/*\n\t\t * Determine space reservations for data/realtime.\n\t\t */\n\t\tif (unlikely(extsz)) {\n\t\t\ts = startoffset_fsb;\n\t\t\tdo_div(s, extsz);\n\t\t\ts *= extsz;\n\t\t\te = startoffset_fsb + allocatesize_fsb;\n\t\t\tif ((temp = do_mod(startoffset_fsb, extsz)))\n\t\t\t\te += temp;\n\t\t\tif ((temp = do_mod(e, extsz)))\n\t\t\t\te += extsz - temp;\n\t\t} else {\n\t\t\ts = 0;\n\t\t\te = allocatesize_fsb;\n\t\t}\n\n\t\t/*\n\t\t * The transaction reservation is limited to a 32-bit block\n\t\t * count, hence we need to limit the number of blocks we are\n\t\t * trying to reserve to avoid an overflow. We can't allocate\n\t\t * more than @nimaps extents, and an extent is limited on disk\n\t\t * to MAXEXTLEN (21 bits), so use that to enforce the limit.\n\t\t */\n\t\tresblks = min_t(xfs_fileoff_t, (e - s), (MAXEXTLEN * nimaps));\n\t\tif (unlikely(rt)) {\n\t\t\tresrtextents = qblocks = resblks;\n\t\t\tresrtextents /= mp->m_sb.sb_rextsize;\n\t\t\tresblks = XFS_DIOSTRAT_SPACE_RES(mp, 0);\n\t\t\tquota_flag = XFS_QMOPT_RES_RTBLKS;\n\t\t} else {\n\t\t\tresrtextents = 0;\n\t\t\tresblks = qblocks = XFS_DIOSTRAT_SPACE_RES(mp, resblks);\n\t\t\tquota_flag = XFS_QMOPT_RES_REGBLKS;\n\t\t}\n\n\t\t/*\n\t\t * Allocate and setup the transaction.\n\t\t */\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_DIOSTRAT);\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_write,\n\t\t\t\t\t  resblks, resrtextents);\n\t\t/*\n\t\t * Check for running out of space\n\t\t */\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * Free the transaction structure.\n\t\t\t */\n\t\t\tASSERT(error == -ENOSPC || XFS_FORCED_SHUTDOWN(mp));\n\t\t\txfs_trans_cancel(tp, 0);\n\t\t\tbreak;\n\t\t}\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\terror = xfs_trans_reserve_quota_nblks(tp, ip, qblocks,\n\t\t\t\t\t\t      0, quota_flag);\n\t\tif (error)\n\t\t\tgoto error1;\n\n\t\txfs_trans_ijoin(tp, ip, 0);\n\n\t\txfs_bmap_init(&free_list, &firstfsb);\n\t\terror = xfs_bmapi_write(tp, ip, startoffset_fsb,\n\t\t\t\t\tallocatesize_fsb, alloc_type, &firstfsb,\n\t\t\t\t\t0, imapp, &nimaps, &free_list);\n\t\tif (error) {\n\t\t\tgoto error0;\n\t\t}\n\n\t\t/*\n\t\t * Complete the transaction\n\t\t */\n\t\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\t\tif (error) {\n\t\t\tgoto error0;\n\t\t}\n\n\t\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\tif (error) {\n\t\t\tbreak;\n\t\t}\n\n\t\tallocated_fsb = imapp->br_blockcount;\n\n\t\tif (nimaps == 0) {\n\t\t\terror = -ENOSPC;\n\t\t\tbreak;\n\t\t}\n\n\t\tstartoffset_fsb += allocated_fsb;\n\t\tallocatesize_fsb -= allocated_fsb;\n\t}\n\n\treturn error;\n\nerror0:\t/* Cancel bmap, unlock inode, unreserve quota blocks, cancel trans */\n\txfs_bmap_cancel(&free_list);\n\txfs_trans_unreserve_quota_nblks(tp, ip, (long)qblocks, 0, quota_flag);\n\nerror1:\t/* Just cancel transaction */\n\txfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "round_down",
          "args": [
            "offset",
            "blksize"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "offset + len",
            "blksize"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_down",
          "args": [
            "offset",
            "blksize"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_free_file_space",
          "args": [
            "ip",
            "offset",
            "len"
          ],
          "line": 1365
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_free_file_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "1165-1336",
          "snippet": "int\nxfs_free_file_space(\n\tstruct xfs_inode\t*ip,\n\txfs_off_t\t\toffset,\n\txfs_off_t\t\tlen)\n{\n\tint\t\t\tcommitted;\n\tint\t\t\tdone;\n\txfs_fileoff_t\t\tendoffset_fsb;\n\tint\t\t\terror;\n\txfs_fsblock_t\t\tfirstfsb;\n\txfs_bmap_free_t\t\tfree_list;\n\txfs_bmbt_irec_t\t\timap;\n\txfs_off_t\t\tioffset;\n\txfs_off_t\t\tiendoffset;\n\txfs_extlen_t\t\tmod=0;\n\txfs_mount_t\t\t*mp;\n\tint\t\t\tnimap;\n\tuint\t\t\tresblks;\n\txfs_off_t\t\trounding;\n\tint\t\t\trt;\n\txfs_fileoff_t\t\tstartoffset_fsb;\n\txfs_trans_t\t\t*tp;\n\n\tmp = ip->i_mount;\n\n\ttrace_xfs_free_file_space(ip);\n\n\terror = xfs_qm_dqattach(ip, 0);\n\tif (error)\n\t\treturn error;\n\n\terror = 0;\n\tif (len <= 0)\t/* if nothing being freed */\n\t\treturn error;\n\trt = XFS_IS_REALTIME_INODE(ip);\n\tstartoffset_fsb\t= XFS_B_TO_FSB(mp, offset);\n\tendoffset_fsb = XFS_B_TO_FSBT(mp, offset + len);\n\n\t/* wait for the completion of any pending DIOs */\n\tinode_dio_wait(VFS_I(ip));\n\n\trounding = max_t(xfs_off_t, 1 << mp->m_sb.sb_blocklog, PAGE_CACHE_SIZE);\n\tioffset = round_down(offset, rounding);\n\tiendoffset = round_up(offset + len, rounding) - 1;\n\terror = filemap_write_and_wait_range(VFS_I(ip)->i_mapping, ioffset,\n\t\t\t\t\t     iendoffset);\n\tif (error)\n\t\tgoto out;\n\ttruncate_pagecache_range(VFS_I(ip), ioffset, iendoffset);\n\n\t/*\n\t * Need to zero the stuff we're not freeing, on disk.\n\t * If it's a realtime file & can't use unwritten extents then we\n\t * actually need to zero the extent edges.  Otherwise xfs_bunmapi\n\t * will take care of it for us.\n\t */\n\tif (rt && !xfs_sb_version_hasextflgbit(&mp->m_sb)) {\n\t\tnimap = 1;\n\t\terror = xfs_bmapi_read(ip, startoffset_fsb, 1,\n\t\t\t\t\t&imap, &nimap, 0);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tASSERT(nimap == 0 || nimap == 1);\n\t\tif (nimap && imap.br_startblock != HOLESTARTBLOCK) {\n\t\t\txfs_daddr_t\tblock;\n\n\t\t\tASSERT(imap.br_startblock != DELAYSTARTBLOCK);\n\t\t\tblock = imap.br_startblock;\n\t\t\tmod = do_div(block, mp->m_sb.sb_rextsize);\n\t\t\tif (mod)\n\t\t\t\tstartoffset_fsb += mp->m_sb.sb_rextsize - mod;\n\t\t}\n\t\tnimap = 1;\n\t\terror = xfs_bmapi_read(ip, endoffset_fsb - 1, 1,\n\t\t\t\t\t&imap, &nimap, 0);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tASSERT(nimap == 0 || nimap == 1);\n\t\tif (nimap && imap.br_startblock != HOLESTARTBLOCK) {\n\t\t\tASSERT(imap.br_startblock != DELAYSTARTBLOCK);\n\t\t\tmod++;\n\t\t\tif (mod && (mod != mp->m_sb.sb_rextsize))\n\t\t\t\tendoffset_fsb -= mod;\n\t\t}\n\t}\n\tif ((done = (endoffset_fsb <= startoffset_fsb)))\n\t\t/*\n\t\t * One contiguous piece to clear\n\t\t */\n\t\terror = xfs_zero_remaining_bytes(ip, offset, offset + len - 1);\n\telse {\n\t\t/*\n\t\t * Some full blocks, possibly two pieces to clear\n\t\t */\n\t\tif (offset < XFS_FSB_TO_B(mp, startoffset_fsb))\n\t\t\terror = xfs_zero_remaining_bytes(ip, offset,\n\t\t\t\tXFS_FSB_TO_B(mp, startoffset_fsb) - 1);\n\t\tif (!error &&\n\t\t    XFS_FSB_TO_B(mp, endoffset_fsb) < offset + len)\n\t\t\terror = xfs_zero_remaining_bytes(ip,\n\t\t\t\tXFS_FSB_TO_B(mp, endoffset_fsb),\n\t\t\t\toffset + len - 1);\n\t}\n\n\t/*\n\t * free file space until done or until there is an error\n\t */\n\tresblks = XFS_DIOSTRAT_SPACE_RES(mp, 0);\n\twhile (!error && !done) {\n\n\t\t/*\n\t\t * allocate and setup the transaction. Allow this\n\t\t * transaction to dip into the reserve blocks to ensure\n\t\t * the freeing of the space succeeds at ENOSPC.\n\t\t */\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_DIOSTRAT);\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_write, resblks, 0);\n\n\t\t/*\n\t\t * check for running out of space\n\t\t */\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * Free the transaction structure.\n\t\t\t */\n\t\t\tASSERT(error == -ENOSPC || XFS_FORCED_SHUTDOWN(mp));\n\t\t\txfs_trans_cancel(tp, 0);\n\t\t\tbreak;\n\t\t}\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\terror = xfs_trans_reserve_quota(tp, mp,\n\t\t\t\tip->i_udquot, ip->i_gdquot, ip->i_pdquot,\n\t\t\t\tresblks, 0, XFS_QMOPT_RES_REGBLKS);\n\t\tif (error)\n\t\t\tgoto error1;\n\n\t\txfs_trans_ijoin(tp, ip, 0);\n\n\t\t/*\n\t\t * issue the bunmapi() call to free the blocks\n\t\t */\n\t\txfs_bmap_init(&free_list, &firstfsb);\n\t\terror = xfs_bunmapi(tp, ip, startoffset_fsb,\n\t\t\t\t  endoffset_fsb - startoffset_fsb,\n\t\t\t\t  0, 2, &firstfsb, &free_list, &done);\n\t\tif (error) {\n\t\t\tgoto error0;\n\t\t}\n\n\t\t/*\n\t\t * complete the transaction\n\t\t */\n\t\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\t\tif (error) {\n\t\t\tgoto error0;\n\t\t}\n\n\t\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t}\n\n out:\n\treturn error;\n\n error0:\n\txfs_bmap_cancel(&free_list);\n error1:\n\txfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\tgoto out;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_free_file_space(\n\tstruct xfs_inode\t*ip,\n\txfs_off_t\t\toffset,\n\txfs_off_t\t\tlen)\n{\n\tint\t\t\tcommitted;\n\tint\t\t\tdone;\n\txfs_fileoff_t\t\tendoffset_fsb;\n\tint\t\t\terror;\n\txfs_fsblock_t\t\tfirstfsb;\n\txfs_bmap_free_t\t\tfree_list;\n\txfs_bmbt_irec_t\t\timap;\n\txfs_off_t\t\tioffset;\n\txfs_off_t\t\tiendoffset;\n\txfs_extlen_t\t\tmod=0;\n\txfs_mount_t\t\t*mp;\n\tint\t\t\tnimap;\n\tuint\t\t\tresblks;\n\txfs_off_t\t\trounding;\n\tint\t\t\trt;\n\txfs_fileoff_t\t\tstartoffset_fsb;\n\txfs_trans_t\t\t*tp;\n\n\tmp = ip->i_mount;\n\n\ttrace_xfs_free_file_space(ip);\n\n\terror = xfs_qm_dqattach(ip, 0);\n\tif (error)\n\t\treturn error;\n\n\terror = 0;\n\tif (len <= 0)\t/* if nothing being freed */\n\t\treturn error;\n\trt = XFS_IS_REALTIME_INODE(ip);\n\tstartoffset_fsb\t= XFS_B_TO_FSB(mp, offset);\n\tendoffset_fsb = XFS_B_TO_FSBT(mp, offset + len);\n\n\t/* wait for the completion of any pending DIOs */\n\tinode_dio_wait(VFS_I(ip));\n\n\trounding = max_t(xfs_off_t, 1 << mp->m_sb.sb_blocklog, PAGE_CACHE_SIZE);\n\tioffset = round_down(offset, rounding);\n\tiendoffset = round_up(offset + len, rounding) - 1;\n\terror = filemap_write_and_wait_range(VFS_I(ip)->i_mapping, ioffset,\n\t\t\t\t\t     iendoffset);\n\tif (error)\n\t\tgoto out;\n\ttruncate_pagecache_range(VFS_I(ip), ioffset, iendoffset);\n\n\t/*\n\t * Need to zero the stuff we're not freeing, on disk.\n\t * If it's a realtime file & can't use unwritten extents then we\n\t * actually need to zero the extent edges.  Otherwise xfs_bunmapi\n\t * will take care of it for us.\n\t */\n\tif (rt && !xfs_sb_version_hasextflgbit(&mp->m_sb)) {\n\t\tnimap = 1;\n\t\terror = xfs_bmapi_read(ip, startoffset_fsb, 1,\n\t\t\t\t\t&imap, &nimap, 0);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tASSERT(nimap == 0 || nimap == 1);\n\t\tif (nimap && imap.br_startblock != HOLESTARTBLOCK) {\n\t\t\txfs_daddr_t\tblock;\n\n\t\t\tASSERT(imap.br_startblock != DELAYSTARTBLOCK);\n\t\t\tblock = imap.br_startblock;\n\t\t\tmod = do_div(block, mp->m_sb.sb_rextsize);\n\t\t\tif (mod)\n\t\t\t\tstartoffset_fsb += mp->m_sb.sb_rextsize - mod;\n\t\t}\n\t\tnimap = 1;\n\t\terror = xfs_bmapi_read(ip, endoffset_fsb - 1, 1,\n\t\t\t\t\t&imap, &nimap, 0);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tASSERT(nimap == 0 || nimap == 1);\n\t\tif (nimap && imap.br_startblock != HOLESTARTBLOCK) {\n\t\t\tASSERT(imap.br_startblock != DELAYSTARTBLOCK);\n\t\t\tmod++;\n\t\t\tif (mod && (mod != mp->m_sb.sb_rextsize))\n\t\t\t\tendoffset_fsb -= mod;\n\t\t}\n\t}\n\tif ((done = (endoffset_fsb <= startoffset_fsb)))\n\t\t/*\n\t\t * One contiguous piece to clear\n\t\t */\n\t\terror = xfs_zero_remaining_bytes(ip, offset, offset + len - 1);\n\telse {\n\t\t/*\n\t\t * Some full blocks, possibly two pieces to clear\n\t\t */\n\t\tif (offset < XFS_FSB_TO_B(mp, startoffset_fsb))\n\t\t\terror = xfs_zero_remaining_bytes(ip, offset,\n\t\t\t\tXFS_FSB_TO_B(mp, startoffset_fsb) - 1);\n\t\tif (!error &&\n\t\t    XFS_FSB_TO_B(mp, endoffset_fsb) < offset + len)\n\t\t\terror = xfs_zero_remaining_bytes(ip,\n\t\t\t\tXFS_FSB_TO_B(mp, endoffset_fsb),\n\t\t\t\toffset + len - 1);\n\t}\n\n\t/*\n\t * free file space until done or until there is an error\n\t */\n\tresblks = XFS_DIOSTRAT_SPACE_RES(mp, 0);\n\twhile (!error && !done) {\n\n\t\t/*\n\t\t * allocate and setup the transaction. Allow this\n\t\t * transaction to dip into the reserve blocks to ensure\n\t\t * the freeing of the space succeeds at ENOSPC.\n\t\t */\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_DIOSTRAT);\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_write, resblks, 0);\n\n\t\t/*\n\t\t * check for running out of space\n\t\t */\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * Free the transaction structure.\n\t\t\t */\n\t\t\tASSERT(error == -ENOSPC || XFS_FORCED_SHUTDOWN(mp));\n\t\t\txfs_trans_cancel(tp, 0);\n\t\t\tbreak;\n\t\t}\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\terror = xfs_trans_reserve_quota(tp, mp,\n\t\t\t\tip->i_udquot, ip->i_gdquot, ip->i_pdquot,\n\t\t\t\tresblks, 0, XFS_QMOPT_RES_REGBLKS);\n\t\tif (error)\n\t\t\tgoto error1;\n\n\t\txfs_trans_ijoin(tp, ip, 0);\n\n\t\t/*\n\t\t * issue the bunmapi() call to free the blocks\n\t\t */\n\t\txfs_bmap_init(&free_list, &firstfsb);\n\t\terror = xfs_bunmapi(tp, ip, startoffset_fsb,\n\t\t\t\t  endoffset_fsb - startoffset_fsb,\n\t\t\t\t  0, 2, &firstfsb, &free_list, &done);\n\t\tif (error) {\n\t\t\tgoto error0;\n\t\t}\n\n\t\t/*\n\t\t * complete the transaction\n\t\t */\n\t\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\t\tif (error) {\n\t\t\tgoto error0;\n\t\t}\n\n\t\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t}\n\n out:\n\treturn error;\n\n error0:\n\txfs_bmap_cancel(&free_list);\n error1:\n\txfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_zero_file_space",
          "args": [
            "ip"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_zero_file_space(\n\tstruct xfs_inode\t*ip,\n\txfs_off_t\t\toffset,\n\txfs_off_t\t\tlen)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tuint\t\t\tblksize;\n\tint\t\t\terror;\n\n\ttrace_xfs_zero_file_space(ip);\n\n\tblksize = 1 << mp->m_sb.sb_blocklog;\n\n\t/*\n\t * Punch a hole and prealloc the range. We use hole punch rather than\n\t * unwritten extent conversion for two reasons:\n\t *\n\t * 1.) Hole punch handles partial block zeroing for us.\n\t *\n\t * 2.) If prealloc returns ENOSPC, the file range is still zero-valued\n\t * by virtue of the hole punch.\n\t */\n\terror = xfs_free_file_space(ip, offset, len);\n\tif (error)\n\t\tgoto out;\n\n\terror = xfs_alloc_file_space(ip, round_down(offset, blksize),\n\t\t\t\t     round_up(offset + len, blksize) -\n\t\t\t\t     round_down(offset, blksize),\n\t\t\t\t     XFS_BMAPI_PREALLOC);\nout:\n\treturn error;\n\n}"
  },
  {
    "function_name": "xfs_free_file_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
    "lines": "1165-1336",
    "snippet": "int\nxfs_free_file_space(\n\tstruct xfs_inode\t*ip,\n\txfs_off_t\t\toffset,\n\txfs_off_t\t\tlen)\n{\n\tint\t\t\tcommitted;\n\tint\t\t\tdone;\n\txfs_fileoff_t\t\tendoffset_fsb;\n\tint\t\t\terror;\n\txfs_fsblock_t\t\tfirstfsb;\n\txfs_bmap_free_t\t\tfree_list;\n\txfs_bmbt_irec_t\t\timap;\n\txfs_off_t\t\tioffset;\n\txfs_off_t\t\tiendoffset;\n\txfs_extlen_t\t\tmod=0;\n\txfs_mount_t\t\t*mp;\n\tint\t\t\tnimap;\n\tuint\t\t\tresblks;\n\txfs_off_t\t\trounding;\n\tint\t\t\trt;\n\txfs_fileoff_t\t\tstartoffset_fsb;\n\txfs_trans_t\t\t*tp;\n\n\tmp = ip->i_mount;\n\n\ttrace_xfs_free_file_space(ip);\n\n\terror = xfs_qm_dqattach(ip, 0);\n\tif (error)\n\t\treturn error;\n\n\terror = 0;\n\tif (len <= 0)\t/* if nothing being freed */\n\t\treturn error;\n\trt = XFS_IS_REALTIME_INODE(ip);\n\tstartoffset_fsb\t= XFS_B_TO_FSB(mp, offset);\n\tendoffset_fsb = XFS_B_TO_FSBT(mp, offset + len);\n\n\t/* wait for the completion of any pending DIOs */\n\tinode_dio_wait(VFS_I(ip));\n\n\trounding = max_t(xfs_off_t, 1 << mp->m_sb.sb_blocklog, PAGE_CACHE_SIZE);\n\tioffset = round_down(offset, rounding);\n\tiendoffset = round_up(offset + len, rounding) - 1;\n\terror = filemap_write_and_wait_range(VFS_I(ip)->i_mapping, ioffset,\n\t\t\t\t\t     iendoffset);\n\tif (error)\n\t\tgoto out;\n\ttruncate_pagecache_range(VFS_I(ip), ioffset, iendoffset);\n\n\t/*\n\t * Need to zero the stuff we're not freeing, on disk.\n\t * If it's a realtime file & can't use unwritten extents then we\n\t * actually need to zero the extent edges.  Otherwise xfs_bunmapi\n\t * will take care of it for us.\n\t */\n\tif (rt && !xfs_sb_version_hasextflgbit(&mp->m_sb)) {\n\t\tnimap = 1;\n\t\terror = xfs_bmapi_read(ip, startoffset_fsb, 1,\n\t\t\t\t\t&imap, &nimap, 0);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tASSERT(nimap == 0 || nimap == 1);\n\t\tif (nimap && imap.br_startblock != HOLESTARTBLOCK) {\n\t\t\txfs_daddr_t\tblock;\n\n\t\t\tASSERT(imap.br_startblock != DELAYSTARTBLOCK);\n\t\t\tblock = imap.br_startblock;\n\t\t\tmod = do_div(block, mp->m_sb.sb_rextsize);\n\t\t\tif (mod)\n\t\t\t\tstartoffset_fsb += mp->m_sb.sb_rextsize - mod;\n\t\t}\n\t\tnimap = 1;\n\t\terror = xfs_bmapi_read(ip, endoffset_fsb - 1, 1,\n\t\t\t\t\t&imap, &nimap, 0);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tASSERT(nimap == 0 || nimap == 1);\n\t\tif (nimap && imap.br_startblock != HOLESTARTBLOCK) {\n\t\t\tASSERT(imap.br_startblock != DELAYSTARTBLOCK);\n\t\t\tmod++;\n\t\t\tif (mod && (mod != mp->m_sb.sb_rextsize))\n\t\t\t\tendoffset_fsb -= mod;\n\t\t}\n\t}\n\tif ((done = (endoffset_fsb <= startoffset_fsb)))\n\t\t/*\n\t\t * One contiguous piece to clear\n\t\t */\n\t\terror = xfs_zero_remaining_bytes(ip, offset, offset + len - 1);\n\telse {\n\t\t/*\n\t\t * Some full blocks, possibly two pieces to clear\n\t\t */\n\t\tif (offset < XFS_FSB_TO_B(mp, startoffset_fsb))\n\t\t\terror = xfs_zero_remaining_bytes(ip, offset,\n\t\t\t\tXFS_FSB_TO_B(mp, startoffset_fsb) - 1);\n\t\tif (!error &&\n\t\t    XFS_FSB_TO_B(mp, endoffset_fsb) < offset + len)\n\t\t\terror = xfs_zero_remaining_bytes(ip,\n\t\t\t\tXFS_FSB_TO_B(mp, endoffset_fsb),\n\t\t\t\toffset + len - 1);\n\t}\n\n\t/*\n\t * free file space until done or until there is an error\n\t */\n\tresblks = XFS_DIOSTRAT_SPACE_RES(mp, 0);\n\twhile (!error && !done) {\n\n\t\t/*\n\t\t * allocate and setup the transaction. Allow this\n\t\t * transaction to dip into the reserve blocks to ensure\n\t\t * the freeing of the space succeeds at ENOSPC.\n\t\t */\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_DIOSTRAT);\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_write, resblks, 0);\n\n\t\t/*\n\t\t * check for running out of space\n\t\t */\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * Free the transaction structure.\n\t\t\t */\n\t\t\tASSERT(error == -ENOSPC || XFS_FORCED_SHUTDOWN(mp));\n\t\t\txfs_trans_cancel(tp, 0);\n\t\t\tbreak;\n\t\t}\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\terror = xfs_trans_reserve_quota(tp, mp,\n\t\t\t\tip->i_udquot, ip->i_gdquot, ip->i_pdquot,\n\t\t\t\tresblks, 0, XFS_QMOPT_RES_REGBLKS);\n\t\tif (error)\n\t\t\tgoto error1;\n\n\t\txfs_trans_ijoin(tp, ip, 0);\n\n\t\t/*\n\t\t * issue the bunmapi() call to free the blocks\n\t\t */\n\t\txfs_bmap_init(&free_list, &firstfsb);\n\t\terror = xfs_bunmapi(tp, ip, startoffset_fsb,\n\t\t\t\t  endoffset_fsb - startoffset_fsb,\n\t\t\t\t  0, 2, &firstfsb, &free_list, &done);\n\t\tif (error) {\n\t\t\tgoto error0;\n\t\t}\n\n\t\t/*\n\t\t * complete the transaction\n\t\t */\n\t\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\t\tif (error) {\n\t\t\tgoto error0;\n\t\t}\n\n\t\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t}\n\n out:\n\treturn error;\n\n error0:\n\txfs_bmap_cancel(&free_list);\n error1:\n\txfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\tgoto out;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 1334
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_cancel",
          "args": [
            "tp",
            "XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT"
          ],
          "line": 1333
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "937-986",
          "snippet": "void\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_cancel",
          "args": [
            "&free_list"
          ],
          "line": 1331
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "658-673",
          "snippet": "void\nxfs_bmap_cancel(\n\txfs_bmap_free_t\t\t*flist)\t/* list of bmap_free_items */\n{\n\txfs_bmap_free_item_t\t*free;\t/* free list item */\n\txfs_bmap_free_item_t\t*next;\n\n\tif (flist->xbf_count == 0)\n\t\treturn;\n\tASSERT(flist->xbf_first != NULL);\n\tfor (free = flist->xbf_first; free; free = next) {\n\t\tnext = free->xbfi_next;\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\tASSERT(flist->xbf_count == 0);\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmap_cancel(\n\txfs_bmap_free_t\t\t*flist)\t/* list of bmap_free_items */\n{\n\txfs_bmap_free_item_t\t*free;\t/* free list item */\n\txfs_bmap_free_item_t\t*next;\n\n\tif (flist->xbf_count == 0)\n\t\treturn;\n\tASSERT(flist->xbf_first != NULL);\n\tfor (free = flist->xbf_first; free; free = next) {\n\t\tnext = free->xbfi_next;\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\tASSERT(flist->xbf_count == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_commit",
          "args": [
            "tp",
            "XFS_TRANS_RELEASE_LOG_RES"
          ],
          "line": 1323
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "845-927",
          "snippet": "int\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_finish",
          "args": [
            "&tp",
            "&free_list",
            "&committed"
          ],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "68-143",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_bmap_finish(\n\txfs_trans_t\t\t**tp,\t\t/* transaction pointer addr */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*committed)\t/* xact committed or not */\n{\n\txfs_efd_log_item_t\t*efd;\t\t/* extent free data */\n\txfs_efi_log_item_t\t*efi;\t\t/* extent free intention */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_bmap_free_item_t\t*free;\t\t/* free extent item */\n\tstruct xfs_trans_res\ttres;\t\t/* new log reservation */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount structure */\n\txfs_bmap_free_item_t\t*next;\t\t/* next item on free list */\n\txfs_trans_t\t\t*ntp;\t\t/* new transaction pointer */\n\n\tASSERT((*tp)->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tif (flist->xbf_count == 0) {\n\t\t*committed = 0;\n\t\treturn 0;\n\t}\n\tntp = *tp;\n\tefi = xfs_trans_get_efi(ntp, flist->xbf_count);\n\tfor (free = flist->xbf_first; free; free = free->xbfi_next)\n\t\txfs_trans_log_efi_extent(ntp, efi, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\n\ttres.tr_logres = ntp->t_log_res;\n\ttres.tr_logcount = ntp->t_log_count;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\tntp = xfs_trans_dup(*tp);\n\terror = xfs_trans_commit(*tp, 0);\n\t*tp = ntp;\n\t*committed = 1;\n\t/*\n\t * We have a new transaction, so we should return committed=1,\n\t * even though we're returning an error.\n\t */\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(ntp->t_ticket);\n\n\terror = xfs_trans_reserve(ntp, &tres, 0, 0);\n\tif (error)\n\t\treturn error;\n\tefd = xfs_trans_get_efd(ntp, efi, flist->xbf_count);\n\tfor (free = flist->xbf_first; free != NULL; free = next) {\n\t\tnext = free->xbfi_next;\n\t\tif ((error = xfs_free_extent(ntp, free->xbfi_startblock,\n\t\t\t\tfree->xbfi_blockcount))) {\n\t\t\t/*\n\t\t\t * The bmap free list will be cleaned up at a\n\t\t\t * higher level.  The EFI will be canceled when\n\t\t\t * this transaction is aborted.\n\t\t\t * Need to force shutdown here to make sure it\n\t\t\t * happens, since this transaction may not be\n\t\t\t * dirty yet.\n\t\t\t */\n\t\t\tmp = ntp->t_mountp;\n\t\t\tif (!XFS_FORCED_SHUTDOWN(mp))\n\t\t\t\txfs_force_shutdown(mp,\n\t\t\t\t\t\t   (error == -EFSCORRUPTED) ?\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE :\n\t\t\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\txfs_trans_log_efd_extent(ntp, efd, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error */\nxfs_bmap_finish(\n\txfs_trans_t\t\t**tp,\t\t/* transaction pointer addr */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*committed)\t/* xact committed or not */\n{\n\txfs_efd_log_item_t\t*efd;\t\t/* extent free data */\n\txfs_efi_log_item_t\t*efi;\t\t/* extent free intention */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_bmap_free_item_t\t*free;\t\t/* free extent item */\n\tstruct xfs_trans_res\ttres;\t\t/* new log reservation */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount structure */\n\txfs_bmap_free_item_t\t*next;\t\t/* next item on free list */\n\txfs_trans_t\t\t*ntp;\t\t/* new transaction pointer */\n\n\tASSERT((*tp)->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tif (flist->xbf_count == 0) {\n\t\t*committed = 0;\n\t\treturn 0;\n\t}\n\tntp = *tp;\n\tefi = xfs_trans_get_efi(ntp, flist->xbf_count);\n\tfor (free = flist->xbf_first; free; free = free->xbfi_next)\n\t\txfs_trans_log_efi_extent(ntp, efi, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\n\ttres.tr_logres = ntp->t_log_res;\n\ttres.tr_logcount = ntp->t_log_count;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\tntp = xfs_trans_dup(*tp);\n\terror = xfs_trans_commit(*tp, 0);\n\t*tp = ntp;\n\t*committed = 1;\n\t/*\n\t * We have a new transaction, so we should return committed=1,\n\t * even though we're returning an error.\n\t */\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(ntp->t_ticket);\n\n\terror = xfs_trans_reserve(ntp, &tres, 0, 0);\n\tif (error)\n\t\treturn error;\n\tefd = xfs_trans_get_efd(ntp, efi, flist->xbf_count);\n\tfor (free = flist->xbf_first; free != NULL; free = next) {\n\t\tnext = free->xbfi_next;\n\t\tif ((error = xfs_free_extent(ntp, free->xbfi_startblock,\n\t\t\t\tfree->xbfi_blockcount))) {\n\t\t\t/*\n\t\t\t * The bmap free list will be cleaned up at a\n\t\t\t * higher level.  The EFI will be canceled when\n\t\t\t * this transaction is aborted.\n\t\t\t * Need to force shutdown here to make sure it\n\t\t\t * happens, since this transaction may not be\n\t\t\t * dirty yet.\n\t\t\t */\n\t\t\tmp = ntp->t_mountp;\n\t\t\tif (!XFS_FORCED_SHUTDOWN(mp))\n\t\t\t\txfs_force_shutdown(mp,\n\t\t\t\t\t\t   (error == -EFSCORRUPTED) ?\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE :\n\t\t\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\txfs_trans_log_efd_extent(ntp, efd, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bunmapi",
          "args": [
            "tp",
            "ip",
            "startoffset_fsb",
            "endoffset_fsb - startoffset_fsb",
            "0",
            "2",
            "&firstfsb",
            "&free_list",
            "&done"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bunmapi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "5030-5403",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_bunmapi(\n\txfs_trans_t\t\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_inode\t*ip,\t\t/* incore inode */\n\txfs_fileoff_t\t\tbno,\t\t/* starting offset to unmap */\n\txfs_filblks_t\t\tlen,\t\t/* length to unmap in file */\n\tint\t\t\tflags,\t\t/* misc flags */\n\txfs_extnum_t\t\tnexts,\t\t/* number of extents max */\n\txfs_fsblock_t\t\t*firstblock,\t/* first allocated block\n\t\t\t\t\t\t   controls a.g. for allocs */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*done)\t\t/* set if not done yet */\n{\n\txfs_btree_cur_t\t\t*cur;\t\t/* bmap btree cursor */\n\txfs_bmbt_irec_t\t\tdel;\t\t/* extent being deleted */\n\tint\t\t\teof;\t\t/* is deleting at eof */\n\txfs_bmbt_rec_host_t\t*ep;\t\t/* extent record pointer */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_extnum_t\t\textno;\t\t/* extent number in list */\n\txfs_bmbt_irec_t\t\tgot;\t\t/* current extent record */\n\txfs_ifork_t\t\t*ifp;\t\t/* inode fork pointer */\n\tint\t\t\tisrt;\t\t/* freeing in rt area */\n\txfs_extnum_t\t\tlastx;\t\t/* last extent index used */\n\tint\t\t\tlogflags;\t/* transaction logging flags */\n\txfs_extlen_t\t\tmod;\t\t/* rt extent offset */\n\txfs_mount_t\t\t*mp;\t\t/* mount structure */\n\txfs_extnum_t\t\tnextents;\t/* number of file extents */\n\txfs_bmbt_irec_t\t\tprev;\t\t/* previous extent record */\n\txfs_fileoff_t\t\tstart;\t\t/* first file offset deleted */\n\tint\t\t\ttmp_logflags;\t/* partial logging flags */\n\tint\t\t\twasdel;\t\t/* was a delayed alloc extent */\n\tint\t\t\twhichfork;\t/* data or attribute fork */\n\txfs_fsblock_t\t\tsum;\n\n\ttrace_xfs_bunmap(ip, bno, len, flags, _RET_IP_);\n\n\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (unlikely(\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)) {\n\t\tXFS_ERROR_REPORT(\"xfs_bunmapi\", XFS_ERRLEVEL_LOW,\n\t\t\t\t ip->i_mount);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tmp = ip->i_mount;\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(len > 0);\n\tASSERT(nexts >= 0);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS) &&\n\t    (error = xfs_iread_extents(tp, ip, whichfork)))\n\t\treturn error;\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tif (nextents == 0) {\n\t\t*done = 1;\n\t\treturn 0;\n\t}\n\tXFS_STATS_INC(xs_blk_unmap);\n\tisrt = (whichfork == XFS_DATA_FORK) && XFS_IS_REALTIME_INODE(ip);\n\tstart = bno;\n\tbno = start + len - 1;\n\tep = xfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got,\n\t\t&prev);\n\n\t/*\n\t * Check to see if the given block number is past the end of the\n\t * file, back up to the last block if so...\n\t */\n\tif (eof) {\n\t\tep = xfs_iext_get_ext(ifp, --lastx);\n\t\txfs_bmbt_get_all(ep, &got);\n\t\tbno = got.br_startoff + got.br_blockcount - 1;\n\t}\n\tlogflags = 0;\n\tif (ifp->if_flags & XFS_IFBROOT) {\n\t\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE);\n\t\tcur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);\n\t\tcur->bc_private.b.firstblock = *firstblock;\n\t\tcur->bc_private.b.flist = flist;\n\t\tcur->bc_private.b.flags = 0;\n\t} else\n\t\tcur = NULL;\n\n\tif (isrt) {\n\t\t/*\n\t\t * Synchronize by locking the bitmap inode.\n\t\t */\n\t\txfs_ilock(mp->m_rbmip, XFS_ILOCK_EXCL);\n\t\txfs_trans_ijoin(tp, mp->m_rbmip, XFS_ILOCK_EXCL);\n\t}\n\n\textno = 0;\n\twhile (bno != (xfs_fileoff_t)-1 && bno >= start && lastx >= 0 &&\n\t       (nexts == 0 || extno < nexts)) {\n\t\t/*\n\t\t * Is the found extent after a hole in which bno lives?\n\t\t * Just back up to the previous extent, if so.\n\t\t */\n\t\tif (got.br_startoff > bno) {\n\t\t\tif (--lastx < 0)\n\t\t\t\tbreak;\n\t\t\tep = xfs_iext_get_ext(ifp, lastx);\n\t\t\txfs_bmbt_get_all(ep, &got);\n\t\t}\n\t\t/*\n\t\t * Is the last block of this extent before the range\n\t\t * we're supposed to delete?  If so, we're done.\n\t\t */\n\t\tbno = XFS_FILEOFF_MIN(bno,\n\t\t\tgot.br_startoff + got.br_blockcount - 1);\n\t\tif (bno < start)\n\t\t\tbreak;\n\t\t/*\n\t\t * Then deal with the (possibly delayed) allocated space\n\t\t * we found.\n\t\t */\n\t\tASSERT(ep != NULL);\n\t\tdel = got;\n\t\twasdel = isnullstartblock(del.br_startblock);\n\t\tif (got.br_startoff < start) {\n\t\t\tdel.br_startoff = start;\n\t\t\tdel.br_blockcount -= start - got.br_startoff;\n\t\t\tif (!wasdel)\n\t\t\t\tdel.br_startblock += start - got.br_startoff;\n\t\t}\n\t\tif (del.br_startoff + del.br_blockcount > bno + 1)\n\t\t\tdel.br_blockcount = bno + 1 - del.br_startoff;\n\t\tsum = del.br_startblock + del.br_blockcount;\n\t\tif (isrt &&\n\t\t    (mod = do_mod(sum, mp->m_sb.sb_rextsize))) {\n\t\t\t/*\n\t\t\t * Realtime extent not lined up at the end.\n\t\t\t * The extent could have been split into written\n\t\t\t * and unwritten pieces, or we could just be\n\t\t\t * unmapping part of it.  But we can't really\n\t\t\t * get rid of part of a realtime extent.\n\t\t\t */\n\t\t\tif (del.br_state == XFS_EXT_UNWRITTEN ||\n\t\t\t    !xfs_sb_version_hasextflgbit(&mp->m_sb)) {\n\t\t\t\t/*\n\t\t\t\t * This piece is unwritten, or we're not\n\t\t\t\t * using unwritten extents.  Skip over it.\n\t\t\t\t */\n\t\t\t\tASSERT(bno >= mod);\n\t\t\t\tbno -= mod > del.br_blockcount ?\n\t\t\t\t\tdel.br_blockcount : mod;\n\t\t\t\tif (bno < got.br_startoff) {\n\t\t\t\t\tif (--lastx >= 0)\n\t\t\t\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(\n\t\t\t\t\t\t\tifp, lastx), &got);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * It's written, turn it unwritten.\n\t\t\t * This is better than zeroing it.\n\t\t\t */\n\t\t\tASSERT(del.br_state == XFS_EXT_NORM);\n\t\t\tASSERT(xfs_trans_get_block_res(tp) > 0);\n\t\t\t/*\n\t\t\t * If this spans a realtime extent boundary,\n\t\t\t * chop it back to the start of the one we end at.\n\t\t\t */\n\t\t\tif (del.br_blockcount > mod) {\n\t\t\t\tdel.br_startoff += del.br_blockcount - mod;\n\t\t\t\tdel.br_startblock += del.br_blockcount - mod;\n\t\t\t\tdel.br_blockcount = mod;\n\t\t\t}\n\t\t\tdel.br_state = XFS_EXT_UNWRITTEN;\n\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp, ip,\n\t\t\t\t\t&lastx, &cur, &del, firstblock, flist,\n\t\t\t\t\t&logflags);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tgoto nodelete;\n\t\t}\n\t\tif (isrt && (mod = do_mod(del.br_startblock, mp->m_sb.sb_rextsize))) {\n\t\t\t/*\n\t\t\t * Realtime extent is lined up at the end but not\n\t\t\t * at the front.  We'll get rid of full extents if\n\t\t\t * we can.\n\t\t\t */\n\t\t\tmod = mp->m_sb.sb_rextsize - mod;\n\t\t\tif (del.br_blockcount > mod) {\n\t\t\t\tdel.br_blockcount -= mod;\n\t\t\t\tdel.br_startoff += mod;\n\t\t\t\tdel.br_startblock += mod;\n\t\t\t} else if ((del.br_startoff == start &&\n\t\t\t\t    (del.br_state == XFS_EXT_UNWRITTEN ||\n\t\t\t\t     xfs_trans_get_block_res(tp) == 0)) ||\n\t\t\t\t   !xfs_sb_version_hasextflgbit(&mp->m_sb)) {\n\t\t\t\t/*\n\t\t\t\t * Can't make it unwritten.  There isn't\n\t\t\t\t * a full extent here so just skip it.\n\t\t\t\t */\n\t\t\t\tASSERT(bno >= del.br_blockcount);\n\t\t\t\tbno -= del.br_blockcount;\n\t\t\t\tif (got.br_startoff > bno) {\n\t\t\t\t\tif (--lastx >= 0) {\n\t\t\t\t\t\tep = xfs_iext_get_ext(ifp,\n\t\t\t\t\t\t\t\t      lastx);\n\t\t\t\t\t\txfs_bmbt_get_all(ep, &got);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else if (del.br_state == XFS_EXT_UNWRITTEN) {\n\t\t\t\t/*\n\t\t\t\t * This one is already unwritten.\n\t\t\t\t * It must have a written left neighbor.\n\t\t\t\t * Unwrite the killed part of that one and\n\t\t\t\t * try again.\n\t\t\t\t */\n\t\t\t\tASSERT(lastx > 0);\n\t\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp,\n\t\t\t\t\t\tlastx - 1), &prev);\n\t\t\t\tASSERT(prev.br_state == XFS_EXT_NORM);\n\t\t\t\tASSERT(!isnullstartblock(prev.br_startblock));\n\t\t\t\tASSERT(del.br_startblock ==\n\t\t\t\t       prev.br_startblock + prev.br_blockcount);\n\t\t\t\tif (prev.br_startoff < start) {\n\t\t\t\t\tmod = start - prev.br_startoff;\n\t\t\t\t\tprev.br_blockcount -= mod;\n\t\t\t\t\tprev.br_startblock += mod;\n\t\t\t\t\tprev.br_startoff = start;\n\t\t\t\t}\n\t\t\t\tprev.br_state = XFS_EXT_UNWRITTEN;\n\t\t\t\tlastx--;\n\t\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp,\n\t\t\t\t\t\tip, &lastx, &cur, &prev,\n\t\t\t\t\t\tfirstblock, flist, &logflags);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tgoto nodelete;\n\t\t\t} else {\n\t\t\t\tASSERT(del.br_state == XFS_EXT_NORM);\n\t\t\t\tdel.br_state = XFS_EXT_UNWRITTEN;\n\t\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp,\n\t\t\t\t\t\tip, &lastx, &cur, &del,\n\t\t\t\t\t\tfirstblock, flist, &logflags);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tgoto nodelete;\n\t\t\t}\n\t\t}\n\t\tif (wasdel) {\n\t\t\tASSERT(startblockval(del.br_startblock) > 0);\n\t\t\t/* Update realtime/data freespace, unreserve quota */\n\t\t\tif (isrt) {\n\t\t\t\txfs_filblks_t rtexts;\n\n\t\t\t\trtexts = XFS_FSB_TO_B(mp, del.br_blockcount);\n\t\t\t\tdo_div(rtexts, mp->m_sb.sb_rextsize);\n\t\t\t\txfs_mod_incore_sb(mp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t\t(int64_t)rtexts, 0);\n\t\t\t\t(void)xfs_trans_reserve_quota_nblks(NULL,\n\t\t\t\t\tip, -((long)del.br_blockcount), 0,\n\t\t\t\t\tXFS_QMOPT_RES_RTBLKS);\n\t\t\t} else {\n\t\t\t\txfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t\t(int64_t)del.br_blockcount, 0);\n\t\t\t\t(void)xfs_trans_reserve_quota_nblks(NULL,\n\t\t\t\t\tip, -((long)del.br_blockcount), 0,\n\t\t\t\t\tXFS_QMOPT_RES_REGBLKS);\n\t\t\t}\n\t\t\tip->i_delayed_blks -= del.br_blockcount;\n\t\t\tif (cur)\n\t\t\t\tcur->bc_private.b.flags |=\n\t\t\t\t\tXFS_BTCUR_BPRV_WASDEL;\n\t\t} else if (cur)\n\t\t\tcur->bc_private.b.flags &= ~XFS_BTCUR_BPRV_WASDEL;\n\t\t/*\n\t\t * If it's the case where the directory code is running\n\t\t * with no block reservation, and the deleted block is in\n\t\t * the middle of its extent, and the resulting insert\n\t\t * of an extent would cause transformation to btree format,\n\t\t * then reject it.  The calling code will then swap\n\t\t * blocks around instead.\n\t\t * We have to do this now, rather than waiting for the\n\t\t * conversion to btree format, since the transaction\n\t\t * will be dirty.\n\t\t */\n\t\tif (!wasdel && xfs_trans_get_block_res(tp) == 0 &&\n\t\t    XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS &&\n\t\t    XFS_IFORK_NEXTENTS(ip, whichfork) >= /* Note the >= */\n\t\t\tXFS_IFORK_MAXEXT(ip, whichfork) &&\n\t\t    del.br_startoff > got.br_startoff &&\n\t\t    del.br_startoff + del.br_blockcount <\n\t\t    got.br_startoff + got.br_blockcount) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto error0;\n\t\t}\n\t\terror = xfs_bmap_del_extent(ip, tp, &lastx, flist, cur, &del,\n\t\t\t\t&tmp_logflags, whichfork);\n\t\tlogflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tbno = del.br_startoff - 1;\nnodelete:\n\t\t/*\n\t\t * If not done go on to the next (previous) record.\n\t\t */\n\t\tif (bno != (xfs_fileoff_t)-1 && bno >= start) {\n\t\t\tif (lastx >= 0) {\n\t\t\t\tep = xfs_iext_get_ext(ifp, lastx);\n\t\t\t\tif (xfs_bmbt_get_startoff(ep) > bno) {\n\t\t\t\t\tif (--lastx >= 0)\n\t\t\t\t\t\tep = xfs_iext_get_ext(ifp,\n\t\t\t\t\t\t\t\t      lastx);\n\t\t\t\t}\n\t\t\t\txfs_bmbt_get_all(ep, &got);\n\t\t\t}\n\t\t\textno++;\n\t\t}\n\t}\n\t*done = bno == (xfs_fileoff_t)-1 || bno < start || lastx < 0;\n\n\t/*\n\t * Convert to a btree if necessary.\n\t */\n\tif (xfs_bmap_needs_btree(ip, whichfork)) {\n\t\tASSERT(cur == NULL);\n\t\terror = xfs_bmap_extents_to_btree(tp, ip, firstblock, flist,\n\t\t\t&cur, 0, &tmp_logflags, whichfork);\n\t\tlogflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\t/*\n\t * transform from btree to extents, give it cur\n\t */\n\telse if (xfs_bmap_wants_extents(ip, whichfork)) {\n\t\tASSERT(cur != NULL);\n\t\terror = xfs_bmap_btree_to_extents(tp, ip, cur, &tmp_logflags,\n\t\t\twhichfork);\n\t\tlogflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\t/*\n\t * transform from extents to local?\n\t */\n\terror = 0;\nerror0:\n\t/*\n\t * Log everything.  Do this after conversion, there's no point in\n\t * logging the extent records if we've converted to btree format.\n\t */\n\tif ((logflags & xfs_ilog_fext(whichfork)) &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t\tlogflags &= ~xfs_ilog_fext(whichfork);\n\telse if ((logflags & xfs_ilog_fbroot(whichfork)) &&\n\t\t XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)\n\t\tlogflags &= ~xfs_ilog_fbroot(whichfork);\n\t/*\n\t * Log inode even in the error case, if the transaction\n\t * is dirty we'll need to shut down the filesystem.\n\t */\n\tif (logflags)\n\t\txfs_trans_log_inode(tp, ip, logflags);\n\tif (cur) {\n\t\tif (!error) {\n\t\t\t*firstblock = cur->bc_private.b.firstblock;\n\t\t\tcur->bc_private.b.allocated = 0;\n\t\t}\n\t\txfs_btree_del_cursor(cur,\n\t\t\terror ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error */\nxfs_bunmapi(\n\txfs_trans_t\t\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_inode\t*ip,\t\t/* incore inode */\n\txfs_fileoff_t\t\tbno,\t\t/* starting offset to unmap */\n\txfs_filblks_t\t\tlen,\t\t/* length to unmap in file */\n\tint\t\t\tflags,\t\t/* misc flags */\n\txfs_extnum_t\t\tnexts,\t\t/* number of extents max */\n\txfs_fsblock_t\t\t*firstblock,\t/* first allocated block\n\t\t\t\t\t\t   controls a.g. for allocs */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*done)\t\t/* set if not done yet */\n{\n\txfs_btree_cur_t\t\t*cur;\t\t/* bmap btree cursor */\n\txfs_bmbt_irec_t\t\tdel;\t\t/* extent being deleted */\n\tint\t\t\teof;\t\t/* is deleting at eof */\n\txfs_bmbt_rec_host_t\t*ep;\t\t/* extent record pointer */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_extnum_t\t\textno;\t\t/* extent number in list */\n\txfs_bmbt_irec_t\t\tgot;\t\t/* current extent record */\n\txfs_ifork_t\t\t*ifp;\t\t/* inode fork pointer */\n\tint\t\t\tisrt;\t\t/* freeing in rt area */\n\txfs_extnum_t\t\tlastx;\t\t/* last extent index used */\n\tint\t\t\tlogflags;\t/* transaction logging flags */\n\txfs_extlen_t\t\tmod;\t\t/* rt extent offset */\n\txfs_mount_t\t\t*mp;\t\t/* mount structure */\n\txfs_extnum_t\t\tnextents;\t/* number of file extents */\n\txfs_bmbt_irec_t\t\tprev;\t\t/* previous extent record */\n\txfs_fileoff_t\t\tstart;\t\t/* first file offset deleted */\n\tint\t\t\ttmp_logflags;\t/* partial logging flags */\n\tint\t\t\twasdel;\t\t/* was a delayed alloc extent */\n\tint\t\t\twhichfork;\t/* data or attribute fork */\n\txfs_fsblock_t\t\tsum;\n\n\ttrace_xfs_bunmap(ip, bno, len, flags, _RET_IP_);\n\n\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (unlikely(\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)) {\n\t\tXFS_ERROR_REPORT(\"xfs_bunmapi\", XFS_ERRLEVEL_LOW,\n\t\t\t\t ip->i_mount);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tmp = ip->i_mount;\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(len > 0);\n\tASSERT(nexts >= 0);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS) &&\n\t    (error = xfs_iread_extents(tp, ip, whichfork)))\n\t\treturn error;\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tif (nextents == 0) {\n\t\t*done = 1;\n\t\treturn 0;\n\t}\n\tXFS_STATS_INC(xs_blk_unmap);\n\tisrt = (whichfork == XFS_DATA_FORK) && XFS_IS_REALTIME_INODE(ip);\n\tstart = bno;\n\tbno = start + len - 1;\n\tep = xfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got,\n\t\t&prev);\n\n\t/*\n\t * Check to see if the given block number is past the end of the\n\t * file, back up to the last block if so...\n\t */\n\tif (eof) {\n\t\tep = xfs_iext_get_ext(ifp, --lastx);\n\t\txfs_bmbt_get_all(ep, &got);\n\t\tbno = got.br_startoff + got.br_blockcount - 1;\n\t}\n\tlogflags = 0;\n\tif (ifp->if_flags & XFS_IFBROOT) {\n\t\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE);\n\t\tcur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);\n\t\tcur->bc_private.b.firstblock = *firstblock;\n\t\tcur->bc_private.b.flist = flist;\n\t\tcur->bc_private.b.flags = 0;\n\t} else\n\t\tcur = NULL;\n\n\tif (isrt) {\n\t\t/*\n\t\t * Synchronize by locking the bitmap inode.\n\t\t */\n\t\txfs_ilock(mp->m_rbmip, XFS_ILOCK_EXCL);\n\t\txfs_trans_ijoin(tp, mp->m_rbmip, XFS_ILOCK_EXCL);\n\t}\n\n\textno = 0;\n\twhile (bno != (xfs_fileoff_t)-1 && bno >= start && lastx >= 0 &&\n\t       (nexts == 0 || extno < nexts)) {\n\t\t/*\n\t\t * Is the found extent after a hole in which bno lives?\n\t\t * Just back up to the previous extent, if so.\n\t\t */\n\t\tif (got.br_startoff > bno) {\n\t\t\tif (--lastx < 0)\n\t\t\t\tbreak;\n\t\t\tep = xfs_iext_get_ext(ifp, lastx);\n\t\t\txfs_bmbt_get_all(ep, &got);\n\t\t}\n\t\t/*\n\t\t * Is the last block of this extent before the range\n\t\t * we're supposed to delete?  If so, we're done.\n\t\t */\n\t\tbno = XFS_FILEOFF_MIN(bno,\n\t\t\tgot.br_startoff + got.br_blockcount - 1);\n\t\tif (bno < start)\n\t\t\tbreak;\n\t\t/*\n\t\t * Then deal with the (possibly delayed) allocated space\n\t\t * we found.\n\t\t */\n\t\tASSERT(ep != NULL);\n\t\tdel = got;\n\t\twasdel = isnullstartblock(del.br_startblock);\n\t\tif (got.br_startoff < start) {\n\t\t\tdel.br_startoff = start;\n\t\t\tdel.br_blockcount -= start - got.br_startoff;\n\t\t\tif (!wasdel)\n\t\t\t\tdel.br_startblock += start - got.br_startoff;\n\t\t}\n\t\tif (del.br_startoff + del.br_blockcount > bno + 1)\n\t\t\tdel.br_blockcount = bno + 1 - del.br_startoff;\n\t\tsum = del.br_startblock + del.br_blockcount;\n\t\tif (isrt &&\n\t\t    (mod = do_mod(sum, mp->m_sb.sb_rextsize))) {\n\t\t\t/*\n\t\t\t * Realtime extent not lined up at the end.\n\t\t\t * The extent could have been split into written\n\t\t\t * and unwritten pieces, or we could just be\n\t\t\t * unmapping part of it.  But we can't really\n\t\t\t * get rid of part of a realtime extent.\n\t\t\t */\n\t\t\tif (del.br_state == XFS_EXT_UNWRITTEN ||\n\t\t\t    !xfs_sb_version_hasextflgbit(&mp->m_sb)) {\n\t\t\t\t/*\n\t\t\t\t * This piece is unwritten, or we're not\n\t\t\t\t * using unwritten extents.  Skip over it.\n\t\t\t\t */\n\t\t\t\tASSERT(bno >= mod);\n\t\t\t\tbno -= mod > del.br_blockcount ?\n\t\t\t\t\tdel.br_blockcount : mod;\n\t\t\t\tif (bno < got.br_startoff) {\n\t\t\t\t\tif (--lastx >= 0)\n\t\t\t\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(\n\t\t\t\t\t\t\tifp, lastx), &got);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * It's written, turn it unwritten.\n\t\t\t * This is better than zeroing it.\n\t\t\t */\n\t\t\tASSERT(del.br_state == XFS_EXT_NORM);\n\t\t\tASSERT(xfs_trans_get_block_res(tp) > 0);\n\t\t\t/*\n\t\t\t * If this spans a realtime extent boundary,\n\t\t\t * chop it back to the start of the one we end at.\n\t\t\t */\n\t\t\tif (del.br_blockcount > mod) {\n\t\t\t\tdel.br_startoff += del.br_blockcount - mod;\n\t\t\t\tdel.br_startblock += del.br_blockcount - mod;\n\t\t\t\tdel.br_blockcount = mod;\n\t\t\t}\n\t\t\tdel.br_state = XFS_EXT_UNWRITTEN;\n\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp, ip,\n\t\t\t\t\t&lastx, &cur, &del, firstblock, flist,\n\t\t\t\t\t&logflags);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tgoto nodelete;\n\t\t}\n\t\tif (isrt && (mod = do_mod(del.br_startblock, mp->m_sb.sb_rextsize))) {\n\t\t\t/*\n\t\t\t * Realtime extent is lined up at the end but not\n\t\t\t * at the front.  We'll get rid of full extents if\n\t\t\t * we can.\n\t\t\t */\n\t\t\tmod = mp->m_sb.sb_rextsize - mod;\n\t\t\tif (del.br_blockcount > mod) {\n\t\t\t\tdel.br_blockcount -= mod;\n\t\t\t\tdel.br_startoff += mod;\n\t\t\t\tdel.br_startblock += mod;\n\t\t\t} else if ((del.br_startoff == start &&\n\t\t\t\t    (del.br_state == XFS_EXT_UNWRITTEN ||\n\t\t\t\t     xfs_trans_get_block_res(tp) == 0)) ||\n\t\t\t\t   !xfs_sb_version_hasextflgbit(&mp->m_sb)) {\n\t\t\t\t/*\n\t\t\t\t * Can't make it unwritten.  There isn't\n\t\t\t\t * a full extent here so just skip it.\n\t\t\t\t */\n\t\t\t\tASSERT(bno >= del.br_blockcount);\n\t\t\t\tbno -= del.br_blockcount;\n\t\t\t\tif (got.br_startoff > bno) {\n\t\t\t\t\tif (--lastx >= 0) {\n\t\t\t\t\t\tep = xfs_iext_get_ext(ifp,\n\t\t\t\t\t\t\t\t      lastx);\n\t\t\t\t\t\txfs_bmbt_get_all(ep, &got);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else if (del.br_state == XFS_EXT_UNWRITTEN) {\n\t\t\t\t/*\n\t\t\t\t * This one is already unwritten.\n\t\t\t\t * It must have a written left neighbor.\n\t\t\t\t * Unwrite the killed part of that one and\n\t\t\t\t * try again.\n\t\t\t\t */\n\t\t\t\tASSERT(lastx > 0);\n\t\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp,\n\t\t\t\t\t\tlastx - 1), &prev);\n\t\t\t\tASSERT(prev.br_state == XFS_EXT_NORM);\n\t\t\t\tASSERT(!isnullstartblock(prev.br_startblock));\n\t\t\t\tASSERT(del.br_startblock ==\n\t\t\t\t       prev.br_startblock + prev.br_blockcount);\n\t\t\t\tif (prev.br_startoff < start) {\n\t\t\t\t\tmod = start - prev.br_startoff;\n\t\t\t\t\tprev.br_blockcount -= mod;\n\t\t\t\t\tprev.br_startblock += mod;\n\t\t\t\t\tprev.br_startoff = start;\n\t\t\t\t}\n\t\t\t\tprev.br_state = XFS_EXT_UNWRITTEN;\n\t\t\t\tlastx--;\n\t\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp,\n\t\t\t\t\t\tip, &lastx, &cur, &prev,\n\t\t\t\t\t\tfirstblock, flist, &logflags);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tgoto nodelete;\n\t\t\t} else {\n\t\t\t\tASSERT(del.br_state == XFS_EXT_NORM);\n\t\t\t\tdel.br_state = XFS_EXT_UNWRITTEN;\n\t\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp,\n\t\t\t\t\t\tip, &lastx, &cur, &del,\n\t\t\t\t\t\tfirstblock, flist, &logflags);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tgoto nodelete;\n\t\t\t}\n\t\t}\n\t\tif (wasdel) {\n\t\t\tASSERT(startblockval(del.br_startblock) > 0);\n\t\t\t/* Update realtime/data freespace, unreserve quota */\n\t\t\tif (isrt) {\n\t\t\t\txfs_filblks_t rtexts;\n\n\t\t\t\trtexts = XFS_FSB_TO_B(mp, del.br_blockcount);\n\t\t\t\tdo_div(rtexts, mp->m_sb.sb_rextsize);\n\t\t\t\txfs_mod_incore_sb(mp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t\t(int64_t)rtexts, 0);\n\t\t\t\t(void)xfs_trans_reserve_quota_nblks(NULL,\n\t\t\t\t\tip, -((long)del.br_blockcount), 0,\n\t\t\t\t\tXFS_QMOPT_RES_RTBLKS);\n\t\t\t} else {\n\t\t\t\txfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t\t(int64_t)del.br_blockcount, 0);\n\t\t\t\t(void)xfs_trans_reserve_quota_nblks(NULL,\n\t\t\t\t\tip, -((long)del.br_blockcount), 0,\n\t\t\t\t\tXFS_QMOPT_RES_REGBLKS);\n\t\t\t}\n\t\t\tip->i_delayed_blks -= del.br_blockcount;\n\t\t\tif (cur)\n\t\t\t\tcur->bc_private.b.flags |=\n\t\t\t\t\tXFS_BTCUR_BPRV_WASDEL;\n\t\t} else if (cur)\n\t\t\tcur->bc_private.b.flags &= ~XFS_BTCUR_BPRV_WASDEL;\n\t\t/*\n\t\t * If it's the case where the directory code is running\n\t\t * with no block reservation, and the deleted block is in\n\t\t * the middle of its extent, and the resulting insert\n\t\t * of an extent would cause transformation to btree format,\n\t\t * then reject it.  The calling code will then swap\n\t\t * blocks around instead.\n\t\t * We have to do this now, rather than waiting for the\n\t\t * conversion to btree format, since the transaction\n\t\t * will be dirty.\n\t\t */\n\t\tif (!wasdel && xfs_trans_get_block_res(tp) == 0 &&\n\t\t    XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS &&\n\t\t    XFS_IFORK_NEXTENTS(ip, whichfork) >= /* Note the >= */\n\t\t\tXFS_IFORK_MAXEXT(ip, whichfork) &&\n\t\t    del.br_startoff > got.br_startoff &&\n\t\t    del.br_startoff + del.br_blockcount <\n\t\t    got.br_startoff + got.br_blockcount) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto error0;\n\t\t}\n\t\terror = xfs_bmap_del_extent(ip, tp, &lastx, flist, cur, &del,\n\t\t\t\t&tmp_logflags, whichfork);\n\t\tlogflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tbno = del.br_startoff - 1;\nnodelete:\n\t\t/*\n\t\t * If not done go on to the next (previous) record.\n\t\t */\n\t\tif (bno != (xfs_fileoff_t)-1 && bno >= start) {\n\t\t\tif (lastx >= 0) {\n\t\t\t\tep = xfs_iext_get_ext(ifp, lastx);\n\t\t\t\tif (xfs_bmbt_get_startoff(ep) > bno) {\n\t\t\t\t\tif (--lastx >= 0)\n\t\t\t\t\t\tep = xfs_iext_get_ext(ifp,\n\t\t\t\t\t\t\t\t      lastx);\n\t\t\t\t}\n\t\t\t\txfs_bmbt_get_all(ep, &got);\n\t\t\t}\n\t\t\textno++;\n\t\t}\n\t}\n\t*done = bno == (xfs_fileoff_t)-1 || bno < start || lastx < 0;\n\n\t/*\n\t * Convert to a btree if necessary.\n\t */\n\tif (xfs_bmap_needs_btree(ip, whichfork)) {\n\t\tASSERT(cur == NULL);\n\t\terror = xfs_bmap_extents_to_btree(tp, ip, firstblock, flist,\n\t\t\t&cur, 0, &tmp_logflags, whichfork);\n\t\tlogflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\t/*\n\t * transform from btree to extents, give it cur\n\t */\n\telse if (xfs_bmap_wants_extents(ip, whichfork)) {\n\t\tASSERT(cur != NULL);\n\t\terror = xfs_bmap_btree_to_extents(tp, ip, cur, &tmp_logflags,\n\t\t\twhichfork);\n\t\tlogflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\t/*\n\t * transform from extents to local?\n\t */\n\terror = 0;\nerror0:\n\t/*\n\t * Log everything.  Do this after conversion, there's no point in\n\t * logging the extent records if we've converted to btree format.\n\t */\n\tif ((logflags & xfs_ilog_fext(whichfork)) &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t\tlogflags &= ~xfs_ilog_fext(whichfork);\n\telse if ((logflags & xfs_ilog_fbroot(whichfork)) &&\n\t\t XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)\n\t\tlogflags &= ~xfs_ilog_fbroot(whichfork);\n\t/*\n\t * Log inode even in the error case, if the transaction\n\t * is dirty we'll need to shut down the filesystem.\n\t */\n\tif (logflags)\n\t\txfs_trans_log_inode(tp, ip, logflags);\n\tif (cur) {\n\t\tif (!error) {\n\t\t\t*firstblock = cur->bc_private.b.firstblock;\n\t\t\tcur->bc_private.b.allocated = 0;\n\t\t}\n\t\txfs_btree_del_cursor(cur,\n\t\t\terror ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_init",
          "args": [
            "&free_list",
            "&firstfsb"
          ],
          "line": 1307
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.h",
          "lines": "133-137",
          "snippet": "static inline void xfs_bmap_init(xfs_bmap_free_t *flp, xfs_fsblock_t *fbp)\n{\n\t((flp)->xbf_first = NULL, (flp)->xbf_count = 0, \\\n\t\t(flp)->xbf_low = 0, *(fbp) = NULLFSBLOCK);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_bmap_init(xfs_bmap_free_t *flp, xfs_fsblock_t *fbp)\n{\n\t((flp)->xbf_first = NULL, (flp)->xbf_count = 0, \\\n\t\t(flp)->xbf_low = 0, *(fbp) = NULLFSBLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ijoin",
          "args": [
            "tp",
            "ip",
            "0"
          ],
          "line": 1302
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ijoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "37-57",
          "snippet": "void\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve_quota",
          "args": [
            "tp",
            "mp",
            "ip->i_udquot",
            "ip->i_gdquot",
            "ip->i_pdquot",
            "resblks",
            "0",
            "XFS_QMOPT_RES_REGBLKS"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve_quota_bydquots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
          "lines": "740-794",
          "snippet": "int\nxfs_trans_reserve_quota_bydquots(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dquot\t*udqp,\n\tstruct xfs_dquot\t*gdqp,\n\tstruct xfs_dquot\t*pdqp,\n\tlong\t\t\tnblks,\n\tlong\t\t\tninos,\n\tuint\t\t\tflags)\n{\n\tint\t\terror;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) || !XFS_IS_QUOTA_ON(mp))\n\t\treturn 0;\n\n\tif (tp && tp->t_dqinfo == NULL)\n\t\txfs_trans_alloc_dqinfo(tp);\n\n\tASSERT(flags & XFS_QMOPT_RESBLK_MASK);\n\n\tif (udqp) {\n\t\terror = xfs_trans_dqresv(tp, mp, udqp, nblks, ninos,\n\t\t\t\t\t(flags & ~XFS_QMOPT_ENOSPC));\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (gdqp) {\n\t\terror = xfs_trans_dqresv(tp, mp, gdqp, nblks, ninos, flags);\n\t\tif (error)\n\t\t\tgoto unwind_usr;\n\t}\n\n\tif (pdqp) {\n\t\terror = xfs_trans_dqresv(tp, mp, pdqp, nblks, ninos, flags);\n\t\tif (error)\n\t\t\tgoto unwind_grp;\n\t}\n\n\t/*\n\t * Didn't change anything critical, so, no need to log\n\t */\n\treturn 0;\n\nunwind_grp:\n\tflags |= XFS_QMOPT_FORCE_RES;\n\tif (gdqp)\n\t\txfs_trans_dqresv(tp, mp, gdqp, -nblks, -ninos, flags);\nunwind_usr:\n\tflags |= XFS_QMOPT_FORCE_RES;\n\tif (udqp)\n\t\txfs_trans_dqresv(tp, mp, udqp, -nblks, -ninos, flags);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_trans_reserve_quota_bydquots(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dquot\t*udqp,\n\tstruct xfs_dquot\t*gdqp,\n\tstruct xfs_dquot\t*pdqp,\n\tlong\t\t\tnblks,\n\tlong\t\t\tninos,\n\tuint\t\t\tflags)\n{\n\tint\t\terror;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) || !XFS_IS_QUOTA_ON(mp))\n\t\treturn 0;\n\n\tif (tp && tp->t_dqinfo == NULL)\n\t\txfs_trans_alloc_dqinfo(tp);\n\n\tASSERT(flags & XFS_QMOPT_RESBLK_MASK);\n\n\tif (udqp) {\n\t\terror = xfs_trans_dqresv(tp, mp, udqp, nblks, ninos,\n\t\t\t\t\t(flags & ~XFS_QMOPT_ENOSPC));\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (gdqp) {\n\t\terror = xfs_trans_dqresv(tp, mp, gdqp, nblks, ninos, flags);\n\t\tif (error)\n\t\t\tgoto unwind_usr;\n\t}\n\n\tif (pdqp) {\n\t\terror = xfs_trans_dqresv(tp, mp, pdqp, nblks, ninos, flags);\n\t\tif (error)\n\t\t\tgoto unwind_grp;\n\t}\n\n\t/*\n\t * Didn't change anything critical, so, no need to log\n\t */\n\treturn 0;\n\nunwind_grp:\n\tflags |= XFS_QMOPT_FORCE_RES;\n\tif (gdqp)\n\t\txfs_trans_dqresv(tp, mp, gdqp, -nblks, -ninos, flags);\nunwind_usr:\n\tflags |= XFS_QMOPT_FORCE_RES;\n\tif (udqp)\n\t\txfs_trans_dqresv(tp, mp, udqp, -nblks, -ninos, flags);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 1295
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "error == -ENOSPC || XFS_FORCED_SHUTDOWN(mp)"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve",
          "args": [
            "tp",
            "&M_RES(mp)->tr_write",
            "resblks",
            "0"
          ],
          "line": 1282
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "168-279",
          "snippet": "int\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_alloc",
          "args": [
            "mp",
            "XFS_TRANS_DIOSTRAT"
          ],
          "line": 1281
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "57-68",
          "snippet": "xfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_DIOSTRAT_SPACE_RES",
          "args": [
            "mp",
            "0"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_zero_remaining_bytes",
          "args": [
            "ip",
            "XFS_FSB_TO_B(mp, endoffset_fsb)",
            "offset + len - 1"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_zero_remaining_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "1096-1163",
          "snippet": "STATIC int\nxfs_zero_remaining_bytes(\n\txfs_inode_t\t\t*ip,\n\txfs_off_t\t\tstartoff,\n\txfs_off_t\t\tendoff)\n{\n\txfs_bmbt_irec_t\t\timap;\n\txfs_fileoff_t\t\toffset_fsb;\n\txfs_off_t\t\tlastoffset;\n\txfs_off_t\t\toffset;\n\txfs_buf_t\t\t*bp;\n\txfs_mount_t\t\t*mp = ip->i_mount;\n\tint\t\t\tnimap;\n\tint\t\t\terror = 0;\n\n\t/*\n\t * Avoid doing I/O beyond eof - it's not necessary\n\t * since nothing can read beyond eof.  The space will\n\t * be zeroed when the file is extended anyway.\n\t */\n\tif (startoff >= XFS_ISIZE(ip))\n\t\treturn 0;\n\n\tif (endoff > XFS_ISIZE(ip))\n\t\tendoff = XFS_ISIZE(ip);\n\n\tfor (offset = startoff; offset <= endoff; offset = lastoffset + 1) {\n\t\tuint lock_mode;\n\n\t\toffset_fsb = XFS_B_TO_FSBT(mp, offset);\n\t\tnimap = 1;\n\n\t\tlock_mode = xfs_ilock_data_map_shared(ip);\n\t\terror = xfs_bmapi_read(ip, offset_fsb, 1, &imap, &nimap, 0);\n\t\txfs_iunlock(ip, lock_mode);\n\n\t\tif (error || nimap < 1)\n\t\t\tbreak;\n\t\tASSERT(imap.br_blockcount >= 1);\n\t\tASSERT(imap.br_startoff == offset_fsb);\n\t\tlastoffset = XFS_FSB_TO_B(mp, imap.br_startoff + 1) - 1;\n\t\tif (lastoffset > endoff)\n\t\t\tlastoffset = endoff;\n\t\tif (imap.br_startblock == HOLESTARTBLOCK)\n\t\t\tcontinue;\n\t\tASSERT(imap.br_startblock != DELAYSTARTBLOCK);\n\t\tif (imap.br_state == XFS_EXT_UNWRITTEN)\n\t\t\tcontinue;\n\n\t\terror = xfs_buf_read_uncached(XFS_IS_REALTIME_INODE(ip) ?\n\t\t\t\tmp->m_rtdev_targp : mp->m_ddev_targp,\n\t\t\t\txfs_fsb_to_db(ip, imap.br_startblock),\n\t\t\t\tBTOBB(mp->m_sb.sb_blocksize),\n\t\t\t\t0, &bp, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tmemset(bp->b_addr +\n\t\t\t\t(offset - XFS_FSB_TO_B(mp, imap.br_startoff)),\n\t\t       0, lastoffset - offset + 1);\n\n\t\terror = xfs_bwrite(bp);\n\t\txfs_buf_relse(bp);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_zero_remaining_bytes(\n\txfs_inode_t\t\t*ip,\n\txfs_off_t\t\tstartoff,\n\txfs_off_t\t\tendoff)\n{\n\txfs_bmbt_irec_t\t\timap;\n\txfs_fileoff_t\t\toffset_fsb;\n\txfs_off_t\t\tlastoffset;\n\txfs_off_t\t\toffset;\n\txfs_buf_t\t\t*bp;\n\txfs_mount_t\t\t*mp = ip->i_mount;\n\tint\t\t\tnimap;\n\tint\t\t\terror = 0;\n\n\t/*\n\t * Avoid doing I/O beyond eof - it's not necessary\n\t * since nothing can read beyond eof.  The space will\n\t * be zeroed when the file is extended anyway.\n\t */\n\tif (startoff >= XFS_ISIZE(ip))\n\t\treturn 0;\n\n\tif (endoff > XFS_ISIZE(ip))\n\t\tendoff = XFS_ISIZE(ip);\n\n\tfor (offset = startoff; offset <= endoff; offset = lastoffset + 1) {\n\t\tuint lock_mode;\n\n\t\toffset_fsb = XFS_B_TO_FSBT(mp, offset);\n\t\tnimap = 1;\n\n\t\tlock_mode = xfs_ilock_data_map_shared(ip);\n\t\terror = xfs_bmapi_read(ip, offset_fsb, 1, &imap, &nimap, 0);\n\t\txfs_iunlock(ip, lock_mode);\n\n\t\tif (error || nimap < 1)\n\t\t\tbreak;\n\t\tASSERT(imap.br_blockcount >= 1);\n\t\tASSERT(imap.br_startoff == offset_fsb);\n\t\tlastoffset = XFS_FSB_TO_B(mp, imap.br_startoff + 1) - 1;\n\t\tif (lastoffset > endoff)\n\t\t\tlastoffset = endoff;\n\t\tif (imap.br_startblock == HOLESTARTBLOCK)\n\t\t\tcontinue;\n\t\tASSERT(imap.br_startblock != DELAYSTARTBLOCK);\n\t\tif (imap.br_state == XFS_EXT_UNWRITTEN)\n\t\t\tcontinue;\n\n\t\terror = xfs_buf_read_uncached(XFS_IS_REALTIME_INODE(ip) ?\n\t\t\t\tmp->m_rtdev_targp : mp->m_ddev_targp,\n\t\t\t\txfs_fsb_to_db(ip, imap.br_startblock),\n\t\t\t\tBTOBB(mp->m_sb.sb_blocksize),\n\t\t\t\t0, &bp, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tmemset(bp->b_addr +\n\t\t\t\t(offset - XFS_FSB_TO_B(mp, imap.br_startoff)),\n\t\t       0, lastoffset - offset + 1);\n\n\t\terror = xfs_bwrite(bp);\n\t\txfs_buf_relse(bp);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_B",
          "args": [
            "mp",
            "endoffset_fsb"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_B",
          "args": [
            "mp",
            "endoffset_fsb"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_B",
          "args": [
            "mp",
            "startoffset_fsb"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_B",
          "args": [
            "mp",
            "startoffset_fsb"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "imap.br_startblock != DELAYSTARTBLOCK"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "nimap == 0 || nimap == 1"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmapi_read",
          "args": [
            "ip",
            "endoffset_fsb - 1",
            "1",
            "&imap",
            "&nimap",
            "0"
          ],
          "line": 1239
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmapi_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "4017-4103",
          "snippet": "int\nxfs_bmapi_read(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tstruct xfs_bmbt_irec\t*mval,\n\tint\t\t\t*nmap,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_bmbt_irec\tprev;\n\txfs_fileoff_t\t\tobno;\n\txfs_fileoff_t\t\tend;\n\txfs_extnum_t\t\tlastx;\n\tint\t\t\terror;\n\tint\t\t\teof;\n\tint\t\t\tn = 0;\n\tint\t\t\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(!(flags & ~(XFS_BMAPI_ATTRFORK|XFS_BMAPI_ENTIRE|\n\t\t\t   XFS_BMAPI_IGSTATE)));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED|XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_read\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_blk_mapr);\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(NULL, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got, &prev);\n\tend = bno + len;\n\tobno = bno;\n\n\twhile (bno < end && n < *nmap) {\n\t\t/* Reading past eof, act as though there's a hole up to end. */\n\t\tif (eof)\n\t\t\tgot.br_startoff = end;\n\t\tif (got.br_startoff > bno) {\n\t\t\t/* Reading in a hole.  */\n\t\t\tmval->br_startoff = bno;\n\t\t\tmval->br_startblock = HOLESTARTBLOCK;\n\t\t\tmval->br_blockcount =\n\t\t\t\tXFS_FILBLKS_MIN(len, got.br_startoff - bno);\n\t\t\tmval->br_state = XFS_EXT_NORM;\n\t\t\tbno += mval->br_blockcount;\n\t\t\tlen -= mval->br_blockcount;\n\t\t\tmval++;\n\t\t\tn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* set up the extent map to return. */\n\t\txfs_bmapi_trim_map(mval, &got, &bno, len, obno, end, n, flags);\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/* If we're done, stop now. */\n\t\tif (bno >= end || n >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tif (++lastx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t))\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx), &got);\n\t\telse\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmapi_read(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tstruct xfs_bmbt_irec\t*mval,\n\tint\t\t\t*nmap,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_bmbt_irec\tprev;\n\txfs_fileoff_t\t\tobno;\n\txfs_fileoff_t\t\tend;\n\txfs_extnum_t\t\tlastx;\n\tint\t\t\terror;\n\tint\t\t\teof;\n\tint\t\t\tn = 0;\n\tint\t\t\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(!(flags & ~(XFS_BMAPI_ATTRFORK|XFS_BMAPI_ENTIRE|\n\t\t\t   XFS_BMAPI_IGSTATE)));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED|XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_read\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_blk_mapr);\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(NULL, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got, &prev);\n\tend = bno + len;\n\tobno = bno;\n\n\twhile (bno < end && n < *nmap) {\n\t\t/* Reading past eof, act as though there's a hole up to end. */\n\t\tif (eof)\n\t\t\tgot.br_startoff = end;\n\t\tif (got.br_startoff > bno) {\n\t\t\t/* Reading in a hole.  */\n\t\t\tmval->br_startoff = bno;\n\t\t\tmval->br_startblock = HOLESTARTBLOCK;\n\t\t\tmval->br_blockcount =\n\t\t\t\tXFS_FILBLKS_MIN(len, got.br_startoff - bno);\n\t\t\tmval->br_state = XFS_EXT_NORM;\n\t\t\tbno += mval->br_blockcount;\n\t\t\tlen -= mval->br_blockcount;\n\t\t\tmval++;\n\t\t\tn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* set up the extent map to return. */\n\t\txfs_bmapi_trim_map(mval, &got, &bno, len, obno, end, n, flags);\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/* If we're done, stop now. */\n\t\tif (bno >= end || n >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tif (++lastx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t))\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx), &got);\n\t\telse\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "block",
            "mp->m_sb.sb_rextsize"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "imap.br_startblock != DELAYSTARTBLOCK"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "nimap == 0 || nimap == 1"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hasextflgbit",
          "args": [
            "&mp->m_sb"
          ],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hasextflgbit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "416-420",
          "snippet": "static inline bool xfs_sb_version_hasextflgbit(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t       (sbp->sb_versionnum & XFS_SB_VERSION_EXTFLGBIT);\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_EXTFLGBIT\t0x1000",
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_EXTFLGBIT\t0x1000\n#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline bool xfs_sb_version_hasextflgbit(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t       (sbp->sb_versionnum & XFS_SB_VERSION_EXTFLGBIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_pagecache_range",
          "args": [
            "VFS_I(ip)",
            "ioffset",
            "iendoffset"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "ip"
          ],
          "line": 1214
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "78-81",
          "snippet": "static inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait_range",
          "args": [
            "VFS_I(ip)->i_mapping",
            "ioffset",
            "iendoffset"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "offset + len",
            "rounding"
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_down",
          "args": [
            "offset",
            "rounding"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "xfs_off_t",
            "1 << mp->m_sb.sb_blocklog",
            "PAGE_CACHE_SIZE"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_dio_wait",
          "args": [
            "VFS_I(ip)"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "inode_dio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1941-1945",
          "snippet": "void inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_B_TO_FSBT",
          "args": [
            "mp",
            "offset + len"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_B_TO_FSB",
          "args": [
            "mp",
            "offset"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_REALTIME_INODE",
          "args": [
            "ip"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_qm_dqattach",
          "args": [
            "ip",
            "0"
          ],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqattach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
          "lines": "379-394",
          "snippet": "int\nxfs_qm_dqattach(\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tflags)\n{\n\tint\t\t\terror;\n\n\tif (!xfs_qm_need_dqattach(ip))\n\t\treturn 0;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\terror = xfs_qm_dqattach_locked(ip, flags);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_qm_dqattach(\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tflags)\n{\n\tint\t\t\terror;\n\n\tif (!xfs_qm_need_dqattach(ip))\n\t\treturn 0;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\terror = xfs_qm_dqattach_locked(ip, flags);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_free_file_space",
          "args": [
            "ip"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_free_file_space(\n\tstruct xfs_inode\t*ip,\n\txfs_off_t\t\toffset,\n\txfs_off_t\t\tlen)\n{\n\tint\t\t\tcommitted;\n\tint\t\t\tdone;\n\txfs_fileoff_t\t\tendoffset_fsb;\n\tint\t\t\terror;\n\txfs_fsblock_t\t\tfirstfsb;\n\txfs_bmap_free_t\t\tfree_list;\n\txfs_bmbt_irec_t\t\timap;\n\txfs_off_t\t\tioffset;\n\txfs_off_t\t\tiendoffset;\n\txfs_extlen_t\t\tmod=0;\n\txfs_mount_t\t\t*mp;\n\tint\t\t\tnimap;\n\tuint\t\t\tresblks;\n\txfs_off_t\t\trounding;\n\tint\t\t\trt;\n\txfs_fileoff_t\t\tstartoffset_fsb;\n\txfs_trans_t\t\t*tp;\n\n\tmp = ip->i_mount;\n\n\ttrace_xfs_free_file_space(ip);\n\n\terror = xfs_qm_dqattach(ip, 0);\n\tif (error)\n\t\treturn error;\n\n\terror = 0;\n\tif (len <= 0)\t/* if nothing being freed */\n\t\treturn error;\n\trt = XFS_IS_REALTIME_INODE(ip);\n\tstartoffset_fsb\t= XFS_B_TO_FSB(mp, offset);\n\tendoffset_fsb = XFS_B_TO_FSBT(mp, offset + len);\n\n\t/* wait for the completion of any pending DIOs */\n\tinode_dio_wait(VFS_I(ip));\n\n\trounding = max_t(xfs_off_t, 1 << mp->m_sb.sb_blocklog, PAGE_CACHE_SIZE);\n\tioffset = round_down(offset, rounding);\n\tiendoffset = round_up(offset + len, rounding) - 1;\n\terror = filemap_write_and_wait_range(VFS_I(ip)->i_mapping, ioffset,\n\t\t\t\t\t     iendoffset);\n\tif (error)\n\t\tgoto out;\n\ttruncate_pagecache_range(VFS_I(ip), ioffset, iendoffset);\n\n\t/*\n\t * Need to zero the stuff we're not freeing, on disk.\n\t * If it's a realtime file & can't use unwritten extents then we\n\t * actually need to zero the extent edges.  Otherwise xfs_bunmapi\n\t * will take care of it for us.\n\t */\n\tif (rt && !xfs_sb_version_hasextflgbit(&mp->m_sb)) {\n\t\tnimap = 1;\n\t\terror = xfs_bmapi_read(ip, startoffset_fsb, 1,\n\t\t\t\t\t&imap, &nimap, 0);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tASSERT(nimap == 0 || nimap == 1);\n\t\tif (nimap && imap.br_startblock != HOLESTARTBLOCK) {\n\t\t\txfs_daddr_t\tblock;\n\n\t\t\tASSERT(imap.br_startblock != DELAYSTARTBLOCK);\n\t\t\tblock = imap.br_startblock;\n\t\t\tmod = do_div(block, mp->m_sb.sb_rextsize);\n\t\t\tif (mod)\n\t\t\t\tstartoffset_fsb += mp->m_sb.sb_rextsize - mod;\n\t\t}\n\t\tnimap = 1;\n\t\terror = xfs_bmapi_read(ip, endoffset_fsb - 1, 1,\n\t\t\t\t\t&imap, &nimap, 0);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tASSERT(nimap == 0 || nimap == 1);\n\t\tif (nimap && imap.br_startblock != HOLESTARTBLOCK) {\n\t\t\tASSERT(imap.br_startblock != DELAYSTARTBLOCK);\n\t\t\tmod++;\n\t\t\tif (mod && (mod != mp->m_sb.sb_rextsize))\n\t\t\t\tendoffset_fsb -= mod;\n\t\t}\n\t}\n\tif ((done = (endoffset_fsb <= startoffset_fsb)))\n\t\t/*\n\t\t * One contiguous piece to clear\n\t\t */\n\t\terror = xfs_zero_remaining_bytes(ip, offset, offset + len - 1);\n\telse {\n\t\t/*\n\t\t * Some full blocks, possibly two pieces to clear\n\t\t */\n\t\tif (offset < XFS_FSB_TO_B(mp, startoffset_fsb))\n\t\t\terror = xfs_zero_remaining_bytes(ip, offset,\n\t\t\t\tXFS_FSB_TO_B(mp, startoffset_fsb) - 1);\n\t\tif (!error &&\n\t\t    XFS_FSB_TO_B(mp, endoffset_fsb) < offset + len)\n\t\t\terror = xfs_zero_remaining_bytes(ip,\n\t\t\t\tXFS_FSB_TO_B(mp, endoffset_fsb),\n\t\t\t\toffset + len - 1);\n\t}\n\n\t/*\n\t * free file space until done or until there is an error\n\t */\n\tresblks = XFS_DIOSTRAT_SPACE_RES(mp, 0);\n\twhile (!error && !done) {\n\n\t\t/*\n\t\t * allocate and setup the transaction. Allow this\n\t\t * transaction to dip into the reserve blocks to ensure\n\t\t * the freeing of the space succeeds at ENOSPC.\n\t\t */\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_DIOSTRAT);\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_write, resblks, 0);\n\n\t\t/*\n\t\t * check for running out of space\n\t\t */\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * Free the transaction structure.\n\t\t\t */\n\t\t\tASSERT(error == -ENOSPC || XFS_FORCED_SHUTDOWN(mp));\n\t\t\txfs_trans_cancel(tp, 0);\n\t\t\tbreak;\n\t\t}\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\terror = xfs_trans_reserve_quota(tp, mp,\n\t\t\t\tip->i_udquot, ip->i_gdquot, ip->i_pdquot,\n\t\t\t\tresblks, 0, XFS_QMOPT_RES_REGBLKS);\n\t\tif (error)\n\t\t\tgoto error1;\n\n\t\txfs_trans_ijoin(tp, ip, 0);\n\n\t\t/*\n\t\t * issue the bunmapi() call to free the blocks\n\t\t */\n\t\txfs_bmap_init(&free_list, &firstfsb);\n\t\terror = xfs_bunmapi(tp, ip, startoffset_fsb,\n\t\t\t\t  endoffset_fsb - startoffset_fsb,\n\t\t\t\t  0, 2, &firstfsb, &free_list, &done);\n\t\tif (error) {\n\t\t\tgoto error0;\n\t\t}\n\n\t\t/*\n\t\t * complete the transaction\n\t\t */\n\t\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\t\tif (error) {\n\t\t\tgoto error0;\n\t\t}\n\n\t\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t}\n\n out:\n\treturn error;\n\n error0:\n\txfs_bmap_cancel(&free_list);\n error1:\n\txfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\tgoto out;\n}"
  },
  {
    "function_name": "xfs_zero_remaining_bytes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
    "lines": "1096-1163",
    "snippet": "STATIC int\nxfs_zero_remaining_bytes(\n\txfs_inode_t\t\t*ip,\n\txfs_off_t\t\tstartoff,\n\txfs_off_t\t\tendoff)\n{\n\txfs_bmbt_irec_t\t\timap;\n\txfs_fileoff_t\t\toffset_fsb;\n\txfs_off_t\t\tlastoffset;\n\txfs_off_t\t\toffset;\n\txfs_buf_t\t\t*bp;\n\txfs_mount_t\t\t*mp = ip->i_mount;\n\tint\t\t\tnimap;\n\tint\t\t\terror = 0;\n\n\t/*\n\t * Avoid doing I/O beyond eof - it's not necessary\n\t * since nothing can read beyond eof.  The space will\n\t * be zeroed when the file is extended anyway.\n\t */\n\tif (startoff >= XFS_ISIZE(ip))\n\t\treturn 0;\n\n\tif (endoff > XFS_ISIZE(ip))\n\t\tendoff = XFS_ISIZE(ip);\n\n\tfor (offset = startoff; offset <= endoff; offset = lastoffset + 1) {\n\t\tuint lock_mode;\n\n\t\toffset_fsb = XFS_B_TO_FSBT(mp, offset);\n\t\tnimap = 1;\n\n\t\tlock_mode = xfs_ilock_data_map_shared(ip);\n\t\terror = xfs_bmapi_read(ip, offset_fsb, 1, &imap, &nimap, 0);\n\t\txfs_iunlock(ip, lock_mode);\n\n\t\tif (error || nimap < 1)\n\t\t\tbreak;\n\t\tASSERT(imap.br_blockcount >= 1);\n\t\tASSERT(imap.br_startoff == offset_fsb);\n\t\tlastoffset = XFS_FSB_TO_B(mp, imap.br_startoff + 1) - 1;\n\t\tif (lastoffset > endoff)\n\t\t\tlastoffset = endoff;\n\t\tif (imap.br_startblock == HOLESTARTBLOCK)\n\t\t\tcontinue;\n\t\tASSERT(imap.br_startblock != DELAYSTARTBLOCK);\n\t\tif (imap.br_state == XFS_EXT_UNWRITTEN)\n\t\t\tcontinue;\n\n\t\terror = xfs_buf_read_uncached(XFS_IS_REALTIME_INODE(ip) ?\n\t\t\t\tmp->m_rtdev_targp : mp->m_ddev_targp,\n\t\t\t\txfs_fsb_to_db(ip, imap.br_startblock),\n\t\t\t\tBTOBB(mp->m_sb.sb_blocksize),\n\t\t\t\t0, &bp, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tmemset(bp->b_addr +\n\t\t\t\t(offset - XFS_FSB_TO_B(mp, imap.br_startoff)),\n\t\t       0, lastoffset - offset + 1);\n\n\t\terror = xfs_bwrite(bp);\n\t\txfs_buf_relse(bp);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_relse",
          "args": [
            "bp"
          ],
          "line": 1158
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "361-365",
          "snippet": "static inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bwrite",
          "args": [
            "bp"
          ],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bwrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1077-1095",
          "snippet": "int\nxfs_bwrite(\n\tstruct xfs_buf\t\t*bp)\n{\n\tint\t\t\terror;\n\n\tASSERT(xfs_buf_islocked(bp));\n\n\tbp->b_flags |= XBF_WRITE;\n\tbp->b_flags &= ~(XBF_ASYNC | XBF_READ | _XBF_DELWRI_Q |\n\t\t\t XBF_WRITE_FAIL | XBF_DONE);\n\n\terror = xfs_buf_submit_wait(bp);\n\tif (error) {\n\t\txfs_force_shutdown(bp->b_target->bt_mount,\n\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nint\nxfs_bwrite(\n\tstruct xfs_buf\t\t*bp)\n{\n\tint\t\t\terror;\n\n\tASSERT(xfs_buf_islocked(bp));\n\n\tbp->b_flags |= XBF_WRITE;\n\tbp->b_flags &= ~(XBF_ASYNC | XBF_READ | _XBF_DELWRI_Q |\n\t\t\t XBF_WRITE_FAIL | XBF_DONE);\n\n\terror = xfs_buf_submit_wait(bp);\n\tif (error) {\n\t\txfs_force_shutdown(bp->b_target->bt_mount,\n\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bp->b_addr +\n\t\t\t\t(offset - XFS_FSB_TO_B(mp, imap.br_startoff))",
            "0",
            "lastoffset - offset + 1"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_B",
          "args": [
            "mp",
            "imap.br_startoff"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_read_uncached",
          "args": [
            "XFS_IS_REALTIME_INODE(ip) ?\n\t\t\t\tmp->m_rtdev_targp : mp->m_ddev_targp",
            "xfs_fsb_to_db(ip, imap.br_startblock)",
            "BTOBB(mp->m_sb.sb_blocksize)",
            "0",
            "&bp",
            "NULL"
          ],
          "line": 1145
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_read_uncached",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "689-722",
          "snippet": "int\nxfs_buf_read_uncached(\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tdaddr,\n\tsize_t\t\t\tnumblks,\n\tint\t\t\tflags,\n\tstruct xfs_buf\t\t**bpp,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\n\n\t*bpp = NULL;\n\n\tbp = xfs_buf_get_uncached(target, numblks, flags);\n\tif (!bp)\n\t\treturn -ENOMEM;\n\n\t/* set up the buffer for a read IO */\n\tASSERT(bp->b_map_count == 1);\n\tbp->b_bn = XFS_BUF_DADDR_NULL;  /* always null for uncached buffers */\n\tbp->b_maps[0].bm_bn = daddr;\n\tbp->b_flags |= XBF_READ;\n\tbp->b_ops = ops;\n\n\txfs_buf_submit_wait(bp);\n\tif (bp->b_error) {\n\t\tint\terror = bp->b_error;\n\t\txfs_buf_relse(bp);\n\t\treturn error;\n\t}\n\n\t*bpp = bp;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nint\nxfs_buf_read_uncached(\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tdaddr,\n\tsize_t\t\t\tnumblks,\n\tint\t\t\tflags,\n\tstruct xfs_buf\t\t**bpp,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\n\n\t*bpp = NULL;\n\n\tbp = xfs_buf_get_uncached(target, numblks, flags);\n\tif (!bp)\n\t\treturn -ENOMEM;\n\n\t/* set up the buffer for a read IO */\n\tASSERT(bp->b_map_count == 1);\n\tbp->b_bn = XFS_BUF_DADDR_NULL;  /* always null for uncached buffers */\n\tbp->b_maps[0].bm_bn = daddr;\n\tbp->b_flags |= XBF_READ;\n\tbp->b_ops = ops;\n\n\txfs_buf_submit_wait(bp);\n\tif (bp->b_error) {\n\t\tint\terror = bp->b_error;\n\t\txfs_buf_relse(bp);\n\t\treturn error;\n\t}\n\n\t*bpp = bp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTOBB",
          "args": [
            "mp->m_sb.sb_blocksize"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_fsb_to_db",
          "args": [
            "ip",
            "imap.br_startblock"
          ],
          "line": 1147
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_fsb_to_db",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "51-57",
          "snippet": "xfs_daddr_t\nxfs_fsb_to_db(struct xfs_inode *ip, xfs_fsblock_t fsb)\n{\n\treturn (XFS_IS_REALTIME_INODE(ip) ? \\\n\t\t (xfs_daddr_t)XFS_FSB_TO_BB((ip)->i_mount, (fsb)) : \\\n\t\t XFS_FSB_TO_DADDR((ip)->i_mount, (fsb)));\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_daddr_t\nxfs_fsb_to_db(struct xfs_inode *ip, xfs_fsblock_t fsb)\n{\n\treturn (XFS_IS_REALTIME_INODE(ip) ? \\\n\t\t (xfs_daddr_t)XFS_FSB_TO_BB((ip)->i_mount, (fsb)) : \\\n\t\t XFS_FSB_TO_DADDR((ip)->i_mount, (fsb)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IS_REALTIME_INODE",
          "args": [
            "ip"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "imap.br_startblock != DELAYSTARTBLOCK"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_B",
          "args": [
            "mp",
            "imap.br_startoff + 1"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "imap.br_startoff == offset_fsb"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "imap.br_blockcount >= 1"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "ip",
            "lock_mode"
          ],
          "line": 1130
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmapi_read",
          "args": [
            "ip",
            "offset_fsb",
            "1",
            "&imap",
            "&nimap",
            "0"
          ],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmapi_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "4017-4103",
          "snippet": "int\nxfs_bmapi_read(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tstruct xfs_bmbt_irec\t*mval,\n\tint\t\t\t*nmap,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_bmbt_irec\tprev;\n\txfs_fileoff_t\t\tobno;\n\txfs_fileoff_t\t\tend;\n\txfs_extnum_t\t\tlastx;\n\tint\t\t\terror;\n\tint\t\t\teof;\n\tint\t\t\tn = 0;\n\tint\t\t\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(!(flags & ~(XFS_BMAPI_ATTRFORK|XFS_BMAPI_ENTIRE|\n\t\t\t   XFS_BMAPI_IGSTATE)));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED|XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_read\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_blk_mapr);\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(NULL, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got, &prev);\n\tend = bno + len;\n\tobno = bno;\n\n\twhile (bno < end && n < *nmap) {\n\t\t/* Reading past eof, act as though there's a hole up to end. */\n\t\tif (eof)\n\t\t\tgot.br_startoff = end;\n\t\tif (got.br_startoff > bno) {\n\t\t\t/* Reading in a hole.  */\n\t\t\tmval->br_startoff = bno;\n\t\t\tmval->br_startblock = HOLESTARTBLOCK;\n\t\t\tmval->br_blockcount =\n\t\t\t\tXFS_FILBLKS_MIN(len, got.br_startoff - bno);\n\t\t\tmval->br_state = XFS_EXT_NORM;\n\t\t\tbno += mval->br_blockcount;\n\t\t\tlen -= mval->br_blockcount;\n\t\t\tmval++;\n\t\t\tn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* set up the extent map to return. */\n\t\txfs_bmapi_trim_map(mval, &got, &bno, len, obno, end, n, flags);\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/* If we're done, stop now. */\n\t\tif (bno >= end || n >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tif (++lastx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t))\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx), &got);\n\t\telse\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmapi_read(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tstruct xfs_bmbt_irec\t*mval,\n\tint\t\t\t*nmap,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_bmbt_irec\tprev;\n\txfs_fileoff_t\t\tobno;\n\txfs_fileoff_t\t\tend;\n\txfs_extnum_t\t\tlastx;\n\tint\t\t\terror;\n\tint\t\t\teof;\n\tint\t\t\tn = 0;\n\tint\t\t\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(!(flags & ~(XFS_BMAPI_ATTRFORK|XFS_BMAPI_ENTIRE|\n\t\t\t   XFS_BMAPI_IGSTATE)));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED|XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_read\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_blk_mapr);\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(NULL, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got, &prev);\n\tend = bno + len;\n\tobno = bno;\n\n\twhile (bno < end && n < *nmap) {\n\t\t/* Reading past eof, act as though there's a hole up to end. */\n\t\tif (eof)\n\t\t\tgot.br_startoff = end;\n\t\tif (got.br_startoff > bno) {\n\t\t\t/* Reading in a hole.  */\n\t\t\tmval->br_startoff = bno;\n\t\t\tmval->br_startblock = HOLESTARTBLOCK;\n\t\t\tmval->br_blockcount =\n\t\t\t\tXFS_FILBLKS_MIN(len, got.br_startoff - bno);\n\t\t\tmval->br_state = XFS_EXT_NORM;\n\t\t\tbno += mval->br_blockcount;\n\t\t\tlen -= mval->br_blockcount;\n\t\t\tmval++;\n\t\t\tn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* set up the extent map to return. */\n\t\txfs_bmapi_trim_map(mval, &got, &bno, len, obno, end, n, flags);\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/* If we're done, stop now. */\n\t\tif (bno >= end || n >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tif (++lastx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t))\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx), &got);\n\t\telse\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock_data_map_shared",
          "args": [
            "ip"
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_data_map_shared",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "93-104",
          "snippet": "uint\nxfs_ilock_data_map_shared(\n\tstruct xfs_inode\t*ip)\n{\n\tuint\t\t\tlock_mode = XFS_ILOCK_SHARED;\n\n\tif (ip->i_d.di_format == XFS_DINODE_FMT_BTREE &&\n\t    (ip->i_df.if_flags & XFS_IFEXTENTS) == 0)\n\t\tlock_mode = XFS_ILOCK_EXCL;\n\txfs_ilock(ip, lock_mode);\n\treturn lock_mode;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nuint\nxfs_ilock_data_map_shared(\n\tstruct xfs_inode\t*ip)\n{\n\tuint\t\t\tlock_mode = XFS_ILOCK_SHARED;\n\n\tif (ip->i_d.di_format == XFS_DINODE_FMT_BTREE &&\n\t    (ip->i_df.if_flags & XFS_IFEXTENTS) == 0)\n\t\tlock_mode = XFS_ILOCK_EXCL;\n\txfs_ilock(ip, lock_mode);\n\treturn lock_mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_B_TO_FSBT",
          "args": [
            "mp",
            "offset"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ISIZE",
          "args": [
            "ip"
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_zero_remaining_bytes(\n\txfs_inode_t\t\t*ip,\n\txfs_off_t\t\tstartoff,\n\txfs_off_t\t\tendoff)\n{\n\txfs_bmbt_irec_t\t\timap;\n\txfs_fileoff_t\t\toffset_fsb;\n\txfs_off_t\t\tlastoffset;\n\txfs_off_t\t\toffset;\n\txfs_buf_t\t\t*bp;\n\txfs_mount_t\t\t*mp = ip->i_mount;\n\tint\t\t\tnimap;\n\tint\t\t\terror = 0;\n\n\t/*\n\t * Avoid doing I/O beyond eof - it's not necessary\n\t * since nothing can read beyond eof.  The space will\n\t * be zeroed when the file is extended anyway.\n\t */\n\tif (startoff >= XFS_ISIZE(ip))\n\t\treturn 0;\n\n\tif (endoff > XFS_ISIZE(ip))\n\t\tendoff = XFS_ISIZE(ip);\n\n\tfor (offset = startoff; offset <= endoff; offset = lastoffset + 1) {\n\t\tuint lock_mode;\n\n\t\toffset_fsb = XFS_B_TO_FSBT(mp, offset);\n\t\tnimap = 1;\n\n\t\tlock_mode = xfs_ilock_data_map_shared(ip);\n\t\terror = xfs_bmapi_read(ip, offset_fsb, 1, &imap, &nimap, 0);\n\t\txfs_iunlock(ip, lock_mode);\n\n\t\tif (error || nimap < 1)\n\t\t\tbreak;\n\t\tASSERT(imap.br_blockcount >= 1);\n\t\tASSERT(imap.br_startoff == offset_fsb);\n\t\tlastoffset = XFS_FSB_TO_B(mp, imap.br_startoff + 1) - 1;\n\t\tif (lastoffset > endoff)\n\t\t\tlastoffset = endoff;\n\t\tif (imap.br_startblock == HOLESTARTBLOCK)\n\t\t\tcontinue;\n\t\tASSERT(imap.br_startblock != DELAYSTARTBLOCK);\n\t\tif (imap.br_state == XFS_EXT_UNWRITTEN)\n\t\t\tcontinue;\n\n\t\terror = xfs_buf_read_uncached(XFS_IS_REALTIME_INODE(ip) ?\n\t\t\t\tmp->m_rtdev_targp : mp->m_ddev_targp,\n\t\t\t\txfs_fsb_to_db(ip, imap.br_startblock),\n\t\t\t\tBTOBB(mp->m_sb.sb_blocksize),\n\t\t\t\t0, &bp, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tmemset(bp->b_addr +\n\t\t\t\t(offset - XFS_FSB_TO_B(mp, imap.br_startoff)),\n\t\t       0, lastoffset - offset + 1);\n\n\t\terror = xfs_bwrite(bp);\n\t\txfs_buf_relse(bp);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_alloc_file_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
    "lines": "928-1083",
    "snippet": "int\nxfs_alloc_file_space(\n\tstruct xfs_inode\t*ip,\n\txfs_off_t\t\toffset,\n\txfs_off_t\t\tlen,\n\tint\t\t\talloc_type)\n{\n\txfs_mount_t\t\t*mp = ip->i_mount;\n\txfs_off_t\t\tcount;\n\txfs_filblks_t\t\tallocated_fsb;\n\txfs_filblks_t\t\tallocatesize_fsb;\n\txfs_extlen_t\t\textsz, temp;\n\txfs_fileoff_t\t\tstartoffset_fsb;\n\txfs_fsblock_t\t\tfirstfsb;\n\tint\t\t\tnimaps;\n\tint\t\t\tquota_flag;\n\tint\t\t\trt;\n\txfs_trans_t\t\t*tp;\n\txfs_bmbt_irec_t\t\timaps[1], *imapp;\n\txfs_bmap_free_t\t\tfree_list;\n\tuint\t\t\tqblocks, resblks, resrtextents;\n\tint\t\t\tcommitted;\n\tint\t\t\terror;\n\n\ttrace_xfs_alloc_file_space(ip);\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\terror = xfs_qm_dqattach(ip, 0);\n\tif (error)\n\t\treturn error;\n\n\tif (len <= 0)\n\t\treturn -EINVAL;\n\n\trt = XFS_IS_REALTIME_INODE(ip);\n\textsz = xfs_get_extsz_hint(ip);\n\n\tcount = len;\n\timapp = &imaps[0];\n\tnimaps = 1;\n\tstartoffset_fsb\t= XFS_B_TO_FSBT(mp, offset);\n\tallocatesize_fsb = XFS_B_TO_FSB(mp, count);\n\n\t/*\n\t * Allocate file space until done or until there is an error\n\t */\n\twhile (allocatesize_fsb && !error) {\n\t\txfs_fileoff_t\ts, e;\n\n\t\t/*\n\t\t * Determine space reservations for data/realtime.\n\t\t */\n\t\tif (unlikely(extsz)) {\n\t\t\ts = startoffset_fsb;\n\t\t\tdo_div(s, extsz);\n\t\t\ts *= extsz;\n\t\t\te = startoffset_fsb + allocatesize_fsb;\n\t\t\tif ((temp = do_mod(startoffset_fsb, extsz)))\n\t\t\t\te += temp;\n\t\t\tif ((temp = do_mod(e, extsz)))\n\t\t\t\te += extsz - temp;\n\t\t} else {\n\t\t\ts = 0;\n\t\t\te = allocatesize_fsb;\n\t\t}\n\n\t\t/*\n\t\t * The transaction reservation is limited to a 32-bit block\n\t\t * count, hence we need to limit the number of blocks we are\n\t\t * trying to reserve to avoid an overflow. We can't allocate\n\t\t * more than @nimaps extents, and an extent is limited on disk\n\t\t * to MAXEXTLEN (21 bits), so use that to enforce the limit.\n\t\t */\n\t\tresblks = min_t(xfs_fileoff_t, (e - s), (MAXEXTLEN * nimaps));\n\t\tif (unlikely(rt)) {\n\t\t\tresrtextents = qblocks = resblks;\n\t\t\tresrtextents /= mp->m_sb.sb_rextsize;\n\t\t\tresblks = XFS_DIOSTRAT_SPACE_RES(mp, 0);\n\t\t\tquota_flag = XFS_QMOPT_RES_RTBLKS;\n\t\t} else {\n\t\t\tresrtextents = 0;\n\t\t\tresblks = qblocks = XFS_DIOSTRAT_SPACE_RES(mp, resblks);\n\t\t\tquota_flag = XFS_QMOPT_RES_REGBLKS;\n\t\t}\n\n\t\t/*\n\t\t * Allocate and setup the transaction.\n\t\t */\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_DIOSTRAT);\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_write,\n\t\t\t\t\t  resblks, resrtextents);\n\t\t/*\n\t\t * Check for running out of space\n\t\t */\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * Free the transaction structure.\n\t\t\t */\n\t\t\tASSERT(error == -ENOSPC || XFS_FORCED_SHUTDOWN(mp));\n\t\t\txfs_trans_cancel(tp, 0);\n\t\t\tbreak;\n\t\t}\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\terror = xfs_trans_reserve_quota_nblks(tp, ip, qblocks,\n\t\t\t\t\t\t      0, quota_flag);\n\t\tif (error)\n\t\t\tgoto error1;\n\n\t\txfs_trans_ijoin(tp, ip, 0);\n\n\t\txfs_bmap_init(&free_list, &firstfsb);\n\t\terror = xfs_bmapi_write(tp, ip, startoffset_fsb,\n\t\t\t\t\tallocatesize_fsb, alloc_type, &firstfsb,\n\t\t\t\t\t0, imapp, &nimaps, &free_list);\n\t\tif (error) {\n\t\t\tgoto error0;\n\t\t}\n\n\t\t/*\n\t\t * Complete the transaction\n\t\t */\n\t\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\t\tif (error) {\n\t\t\tgoto error0;\n\t\t}\n\n\t\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\tif (error) {\n\t\t\tbreak;\n\t\t}\n\n\t\tallocated_fsb = imapp->br_blockcount;\n\n\t\tif (nimaps == 0) {\n\t\t\terror = -ENOSPC;\n\t\t\tbreak;\n\t\t}\n\n\t\tstartoffset_fsb += allocated_fsb;\n\t\tallocatesize_fsb -= allocated_fsb;\n\t}\n\n\treturn error;\n\nerror0:\t/* Cancel bmap, unlock inode, unreserve quota blocks, cancel trans */\n\txfs_bmap_cancel(&free_list);\n\txfs_trans_unreserve_quota_nblks(tp, ip, (long)qblocks, 0, quota_flag);\n\nerror1:\t/* Just cancel transaction */\n\txfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_cancel",
          "args": [
            "tp",
            "XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "937-986",
          "snippet": "void\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_unreserve_quota_nblks",
          "args": [
            "tp",
            "ip",
            "(long)qblocks",
            "0",
            "quota_flag"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmap_cancel",
          "args": [
            "&free_list"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "658-673",
          "snippet": "void\nxfs_bmap_cancel(\n\txfs_bmap_free_t\t\t*flist)\t/* list of bmap_free_items */\n{\n\txfs_bmap_free_item_t\t*free;\t/* free list item */\n\txfs_bmap_free_item_t\t*next;\n\n\tif (flist->xbf_count == 0)\n\t\treturn;\n\tASSERT(flist->xbf_first != NULL);\n\tfor (free = flist->xbf_first; free; free = next) {\n\t\tnext = free->xbfi_next;\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\tASSERT(flist->xbf_count == 0);\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmap_cancel(\n\txfs_bmap_free_t\t\t*flist)\t/* list of bmap_free_items */\n{\n\txfs_bmap_free_item_t\t*free;\t/* free list item */\n\txfs_bmap_free_item_t\t*next;\n\n\tif (flist->xbf_count == 0)\n\t\treturn;\n\tASSERT(flist->xbf_first != NULL);\n\tfor (free = flist->xbf_first; free; free = next) {\n\t\tnext = free->xbfi_next;\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\tASSERT(flist->xbf_count == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_commit",
          "args": [
            "tp",
            "XFS_TRANS_RELEASE_LOG_RES"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "845-927",
          "snippet": "int\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_finish",
          "args": [
            "&tp",
            "&free_list",
            "&committed"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "68-143",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_bmap_finish(\n\txfs_trans_t\t\t**tp,\t\t/* transaction pointer addr */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*committed)\t/* xact committed or not */\n{\n\txfs_efd_log_item_t\t*efd;\t\t/* extent free data */\n\txfs_efi_log_item_t\t*efi;\t\t/* extent free intention */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_bmap_free_item_t\t*free;\t\t/* free extent item */\n\tstruct xfs_trans_res\ttres;\t\t/* new log reservation */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount structure */\n\txfs_bmap_free_item_t\t*next;\t\t/* next item on free list */\n\txfs_trans_t\t\t*ntp;\t\t/* new transaction pointer */\n\n\tASSERT((*tp)->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tif (flist->xbf_count == 0) {\n\t\t*committed = 0;\n\t\treturn 0;\n\t}\n\tntp = *tp;\n\tefi = xfs_trans_get_efi(ntp, flist->xbf_count);\n\tfor (free = flist->xbf_first; free; free = free->xbfi_next)\n\t\txfs_trans_log_efi_extent(ntp, efi, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\n\ttres.tr_logres = ntp->t_log_res;\n\ttres.tr_logcount = ntp->t_log_count;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\tntp = xfs_trans_dup(*tp);\n\terror = xfs_trans_commit(*tp, 0);\n\t*tp = ntp;\n\t*committed = 1;\n\t/*\n\t * We have a new transaction, so we should return committed=1,\n\t * even though we're returning an error.\n\t */\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(ntp->t_ticket);\n\n\terror = xfs_trans_reserve(ntp, &tres, 0, 0);\n\tif (error)\n\t\treturn error;\n\tefd = xfs_trans_get_efd(ntp, efi, flist->xbf_count);\n\tfor (free = flist->xbf_first; free != NULL; free = next) {\n\t\tnext = free->xbfi_next;\n\t\tif ((error = xfs_free_extent(ntp, free->xbfi_startblock,\n\t\t\t\tfree->xbfi_blockcount))) {\n\t\t\t/*\n\t\t\t * The bmap free list will be cleaned up at a\n\t\t\t * higher level.  The EFI will be canceled when\n\t\t\t * this transaction is aborted.\n\t\t\t * Need to force shutdown here to make sure it\n\t\t\t * happens, since this transaction may not be\n\t\t\t * dirty yet.\n\t\t\t */\n\t\t\tmp = ntp->t_mountp;\n\t\t\tif (!XFS_FORCED_SHUTDOWN(mp))\n\t\t\t\txfs_force_shutdown(mp,\n\t\t\t\t\t\t   (error == -EFSCORRUPTED) ?\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE :\n\t\t\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\txfs_trans_log_efd_extent(ntp, efd, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error */\nxfs_bmap_finish(\n\txfs_trans_t\t\t**tp,\t\t/* transaction pointer addr */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*committed)\t/* xact committed or not */\n{\n\txfs_efd_log_item_t\t*efd;\t\t/* extent free data */\n\txfs_efi_log_item_t\t*efi;\t\t/* extent free intention */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_bmap_free_item_t\t*free;\t\t/* free extent item */\n\tstruct xfs_trans_res\ttres;\t\t/* new log reservation */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount structure */\n\txfs_bmap_free_item_t\t*next;\t\t/* next item on free list */\n\txfs_trans_t\t\t*ntp;\t\t/* new transaction pointer */\n\n\tASSERT((*tp)->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tif (flist->xbf_count == 0) {\n\t\t*committed = 0;\n\t\treturn 0;\n\t}\n\tntp = *tp;\n\tefi = xfs_trans_get_efi(ntp, flist->xbf_count);\n\tfor (free = flist->xbf_first; free; free = free->xbfi_next)\n\t\txfs_trans_log_efi_extent(ntp, efi, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\n\ttres.tr_logres = ntp->t_log_res;\n\ttres.tr_logcount = ntp->t_log_count;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\tntp = xfs_trans_dup(*tp);\n\terror = xfs_trans_commit(*tp, 0);\n\t*tp = ntp;\n\t*committed = 1;\n\t/*\n\t * We have a new transaction, so we should return committed=1,\n\t * even though we're returning an error.\n\t */\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(ntp->t_ticket);\n\n\terror = xfs_trans_reserve(ntp, &tres, 0, 0);\n\tif (error)\n\t\treturn error;\n\tefd = xfs_trans_get_efd(ntp, efi, flist->xbf_count);\n\tfor (free = flist->xbf_first; free != NULL; free = next) {\n\t\tnext = free->xbfi_next;\n\t\tif ((error = xfs_free_extent(ntp, free->xbfi_startblock,\n\t\t\t\tfree->xbfi_blockcount))) {\n\t\t\t/*\n\t\t\t * The bmap free list will be cleaned up at a\n\t\t\t * higher level.  The EFI will be canceled when\n\t\t\t * this transaction is aborted.\n\t\t\t * Need to force shutdown here to make sure it\n\t\t\t * happens, since this transaction may not be\n\t\t\t * dirty yet.\n\t\t\t */\n\t\t\tmp = ntp->t_mountp;\n\t\t\tif (!XFS_FORCED_SHUTDOWN(mp))\n\t\t\t\txfs_force_shutdown(mp,\n\t\t\t\t\t\t   (error == -EFSCORRUPTED) ?\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE :\n\t\t\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\txfs_trans_log_efd_extent(ntp, efd, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmapi_write",
          "args": [
            "tp",
            "ip",
            "startoffset_fsb",
            "allocatesize_fsb",
            "alloc_type",
            "&firstfsb",
            "0",
            "imapp",
            "&nimaps",
            "&free_list"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmapi_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "4483-4700",
          "snippet": "int\nxfs_bmapi_write(\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_inode\t*ip,\t\t/* incore inode */\n\txfs_fileoff_t\t\tbno,\t\t/* starting file offs. mapped */\n\txfs_filblks_t\t\tlen,\t\t/* length to map in file */\n\tint\t\t\tflags,\t\t/* XFS_BMAPI_... */\n\txfs_fsblock_t\t\t*firstblock,\t/* first allocated block\n\t\t\t\t\t\t   controls a.g. for allocs */\n\txfs_extlen_t\t\ttotal,\t\t/* total blocks needed */\n\tstruct xfs_bmbt_irec\t*mval,\t\t/* output: map values */\n\tint\t\t\t*nmap,\t\t/* i/o: mval size/count */\n\tstruct xfs_bmap_free\t*flist)\t\t/* i/o: list extents to free */\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmalloca\tbma = { NULL };\t/* args for xfs_bmap_alloc */\n\txfs_fileoff_t\t\tend;\t\t/* end of mapped file region */\n\tint\t\t\teof;\t\t/* after the end of extents */\n\tint\t\t\terror;\t\t/* error return */\n\tint\t\t\tn;\t\t/* current extent index */\n\txfs_fileoff_t\t\tobno;\t\t/* old block number (offset) */\n\tint\t\t\twhichfork;\t/* data or attr fork */\n\tchar\t\t\tinhole;\t\t/* current location is hole in file */\n\tchar\t\t\twasdelay;\t/* old extent was delayed */\n\n#ifdef DEBUG\n\txfs_fileoff_t\t\torig_bno;\t/* original block number value */\n\tint\t\t\torig_flags;\t/* original flags arg value */\n\txfs_filblks_t\t\torig_len;\t/* original value of len arg */\n\tstruct xfs_bmbt_irec\t*orig_mval;\t/* original value of mval */\n\tint\t\t\torig_nmap;\t/* original value of *nmap */\n\n\torig_bno = bno;\n\torig_len = len;\n\torig_flags = flags;\n\torig_mval = mval;\n\torig_nmap = *nmap;\n#endif\n\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(*nmap <= XFS_BMAP_MAX_NMAP);\n\tASSERT(!(flags & XFS_BMAPI_IGSTATE));\n\tASSERT(tp != NULL);\n\tASSERT(len > 0);\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_LOCAL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_write\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tXFS_STATS_INC(xs_blk_mapw);\n\n\tif (*firstblock == NULLFSBLOCK) {\n\t\tif (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE)\n\t\t\tbma.minleft = be16_to_cpu(ifp->if_broot->bb_level) + 1;\n\t\telse\n\t\t\tbma.minleft = 1;\n\t} else {\n\t\tbma.minleft = 0;\n\t}\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(tp, ip, whichfork);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &bma.idx, &bma.got,\n\t\t\t\t&bma.prev);\n\tn = 0;\n\tend = bno + len;\n\tobno = bno;\n\n\tbma.tp = tp;\n\tbma.ip = ip;\n\tbma.total = total;\n\tbma.userdata = 0;\n\tbma.flist = flist;\n\tbma.firstblock = firstblock;\n\n\twhile (bno < end && n < *nmap) {\n\t\tinhole = eof || bma.got.br_startoff > bno;\n\t\twasdelay = !inhole && isnullstartblock(bma.got.br_startblock);\n\n\t\t/*\n\t\t * First, deal with the hole before the allocated space\n\t\t * that we found, if any.\n\t\t */\n\t\tif (inhole || wasdelay) {\n\t\t\tbma.eof = eof;\n\t\t\tbma.conv = !!(flags & XFS_BMAPI_CONVERT);\n\t\t\tbma.wasdel = wasdelay;\n\t\t\tbma.offset = bno;\n\t\t\tbma.flags = flags;\n\n\t\t\t/*\n\t\t\t * There's a 32/64 bit type mismatch between the\n\t\t\t * allocation length request (which can be 64 bits in\n\t\t\t * length) and the bma length request, which is\n\t\t\t * xfs_extlen_t and therefore 32 bits. Hence we have to\n\t\t\t * check for 32-bit overflows and handle them here.\n\t\t\t */\n\t\t\tif (len > (xfs_filblks_t)MAXEXTLEN)\n\t\t\t\tbma.length = MAXEXTLEN;\n\t\t\telse\n\t\t\t\tbma.length = len;\n\n\t\t\tASSERT(len > 0);\n\t\t\tASSERT(bma.length > 0);\n\t\t\terror = xfs_bmapi_allocate(&bma);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tif (bma.blkno == NULLFSBLOCK)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Deal with the allocated space we found.  */\n\t\txfs_bmapi_trim_map(mval, &bma.got, &bno, len, obno,\n\t\t\t\t\t\t\tend, n, flags);\n\n\t\t/* Execute unwritten extent conversion if necessary */\n\t\terror = xfs_bmapi_convert_unwritten(&bma, mval, len, flags);\n\t\tif (error == -EAGAIN)\n\t\t\tcontinue;\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\t/* update the extent map to return */\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/*\n\t\t * If we're done, stop now.  Stop when we've allocated\n\t\t * XFS_BMAP_MAX_NMAP extents no matter what.  Otherwise\n\t\t * the transaction may get too big.\n\t\t */\n\t\tif (bno >= end || n >= *nmap || bma.nallocs >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tbma.prev = bma.got;\n\t\tif (++bma.idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t)) {\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, bma.idx),\n\t\t\t\t\t &bma.got);\n\t\t} else\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\n\t/*\n\t * Transform from btree to extents, give it cur.\n\t */\n\tif (xfs_bmap_wants_extents(ip, whichfork)) {\n\t\tint\t\ttmp_logflags = 0;\n\n\t\tASSERT(bma.cur);\n\t\terror = xfs_bmap_btree_to_extents(tp, ip, bma.cur,\n\t\t\t&tmp_logflags, whichfork);\n\t\tbma.logflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE ||\n\t       XFS_IFORK_NEXTENTS(ip, whichfork) >\n\t\tXFS_IFORK_MAXEXT(ip, whichfork));\n\terror = 0;\nerror0:\n\t/*\n\t * Log everything.  Do this after conversion, there's no point in\n\t * logging the extent records if we've converted to btree format.\n\t */\n\tif ((bma.logflags & xfs_ilog_fext(whichfork)) &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t\tbma.logflags &= ~xfs_ilog_fext(whichfork);\n\telse if ((bma.logflags & xfs_ilog_fbroot(whichfork)) &&\n\t\t XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)\n\t\tbma.logflags &= ~xfs_ilog_fbroot(whichfork);\n\t/*\n\t * Log whatever the flags say, even if error.  Otherwise we might miss\n\t * detecting a case where the data is changed, there's an error,\n\t * and it's not logged so we don't shutdown when we should.\n\t */\n\tif (bma.logflags)\n\t\txfs_trans_log_inode(tp, ip, bma.logflags);\n\n\tif (bma.cur) {\n\t\tif (!error) {\n\t\t\tASSERT(*firstblock == NULLFSBLOCK ||\n\t\t\t       XFS_FSB_TO_AGNO(mp, *firstblock) ==\n\t\t\t       XFS_FSB_TO_AGNO(mp,\n\t\t\t\t       bma.cur->bc_private.b.firstblock) ||\n\t\t\t       (flist->xbf_low &&\n\t\t\t\tXFS_FSB_TO_AGNO(mp, *firstblock) <\n\t\t\t\tXFS_FSB_TO_AGNO(mp,\n\t\t\t\t\tbma.cur->bc_private.b.firstblock)));\n\t\t\t*firstblock = bma.cur->bc_private.b.firstblock;\n\t\t}\n\t\txfs_btree_del_cursor(bma.cur,\n\t\t\terror ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\n\t}\n\tif (!error)\n\t\txfs_bmap_validate_ret(orig_bno, orig_len, orig_flags, orig_mval,\n\t\t\torig_nmap, *nmap);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmapi_write(\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_inode\t*ip,\t\t/* incore inode */\n\txfs_fileoff_t\t\tbno,\t\t/* starting file offs. mapped */\n\txfs_filblks_t\t\tlen,\t\t/* length to map in file */\n\tint\t\t\tflags,\t\t/* XFS_BMAPI_... */\n\txfs_fsblock_t\t\t*firstblock,\t/* first allocated block\n\t\t\t\t\t\t   controls a.g. for allocs */\n\txfs_extlen_t\t\ttotal,\t\t/* total blocks needed */\n\tstruct xfs_bmbt_irec\t*mval,\t\t/* output: map values */\n\tint\t\t\t*nmap,\t\t/* i/o: mval size/count */\n\tstruct xfs_bmap_free\t*flist)\t\t/* i/o: list extents to free */\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmalloca\tbma = { NULL };\t/* args for xfs_bmap_alloc */\n\txfs_fileoff_t\t\tend;\t\t/* end of mapped file region */\n\tint\t\t\teof;\t\t/* after the end of extents */\n\tint\t\t\terror;\t\t/* error return */\n\tint\t\t\tn;\t\t/* current extent index */\n\txfs_fileoff_t\t\tobno;\t\t/* old block number (offset) */\n\tint\t\t\twhichfork;\t/* data or attr fork */\n\tchar\t\t\tinhole;\t\t/* current location is hole in file */\n\tchar\t\t\twasdelay;\t/* old extent was delayed */\n\n#ifdef DEBUG\n\txfs_fileoff_t\t\torig_bno;\t/* original block number value */\n\tint\t\t\torig_flags;\t/* original flags arg value */\n\txfs_filblks_t\t\torig_len;\t/* original value of len arg */\n\tstruct xfs_bmbt_irec\t*orig_mval;\t/* original value of mval */\n\tint\t\t\torig_nmap;\t/* original value of *nmap */\n\n\torig_bno = bno;\n\torig_len = len;\n\torig_flags = flags;\n\torig_mval = mval;\n\torig_nmap = *nmap;\n#endif\n\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(*nmap <= XFS_BMAP_MAX_NMAP);\n\tASSERT(!(flags & XFS_BMAPI_IGSTATE));\n\tASSERT(tp != NULL);\n\tASSERT(len > 0);\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_LOCAL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_write\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tXFS_STATS_INC(xs_blk_mapw);\n\n\tif (*firstblock == NULLFSBLOCK) {\n\t\tif (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE)\n\t\t\tbma.minleft = be16_to_cpu(ifp->if_broot->bb_level) + 1;\n\t\telse\n\t\t\tbma.minleft = 1;\n\t} else {\n\t\tbma.minleft = 0;\n\t}\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(tp, ip, whichfork);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &bma.idx, &bma.got,\n\t\t\t\t&bma.prev);\n\tn = 0;\n\tend = bno + len;\n\tobno = bno;\n\n\tbma.tp = tp;\n\tbma.ip = ip;\n\tbma.total = total;\n\tbma.userdata = 0;\n\tbma.flist = flist;\n\tbma.firstblock = firstblock;\n\n\twhile (bno < end && n < *nmap) {\n\t\tinhole = eof || bma.got.br_startoff > bno;\n\t\twasdelay = !inhole && isnullstartblock(bma.got.br_startblock);\n\n\t\t/*\n\t\t * First, deal with the hole before the allocated space\n\t\t * that we found, if any.\n\t\t */\n\t\tif (inhole || wasdelay) {\n\t\t\tbma.eof = eof;\n\t\t\tbma.conv = !!(flags & XFS_BMAPI_CONVERT);\n\t\t\tbma.wasdel = wasdelay;\n\t\t\tbma.offset = bno;\n\t\t\tbma.flags = flags;\n\n\t\t\t/*\n\t\t\t * There's a 32/64 bit type mismatch between the\n\t\t\t * allocation length request (which can be 64 bits in\n\t\t\t * length) and the bma length request, which is\n\t\t\t * xfs_extlen_t and therefore 32 bits. Hence we have to\n\t\t\t * check for 32-bit overflows and handle them here.\n\t\t\t */\n\t\t\tif (len > (xfs_filblks_t)MAXEXTLEN)\n\t\t\t\tbma.length = MAXEXTLEN;\n\t\t\telse\n\t\t\t\tbma.length = len;\n\n\t\t\tASSERT(len > 0);\n\t\t\tASSERT(bma.length > 0);\n\t\t\terror = xfs_bmapi_allocate(&bma);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tif (bma.blkno == NULLFSBLOCK)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Deal with the allocated space we found.  */\n\t\txfs_bmapi_trim_map(mval, &bma.got, &bno, len, obno,\n\t\t\t\t\t\t\tend, n, flags);\n\n\t\t/* Execute unwritten extent conversion if necessary */\n\t\terror = xfs_bmapi_convert_unwritten(&bma, mval, len, flags);\n\t\tif (error == -EAGAIN)\n\t\t\tcontinue;\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\t/* update the extent map to return */\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/*\n\t\t * If we're done, stop now.  Stop when we've allocated\n\t\t * XFS_BMAP_MAX_NMAP extents no matter what.  Otherwise\n\t\t * the transaction may get too big.\n\t\t */\n\t\tif (bno >= end || n >= *nmap || bma.nallocs >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tbma.prev = bma.got;\n\t\tif (++bma.idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t)) {\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, bma.idx),\n\t\t\t\t\t &bma.got);\n\t\t} else\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\n\t/*\n\t * Transform from btree to extents, give it cur.\n\t */\n\tif (xfs_bmap_wants_extents(ip, whichfork)) {\n\t\tint\t\ttmp_logflags = 0;\n\n\t\tASSERT(bma.cur);\n\t\terror = xfs_bmap_btree_to_extents(tp, ip, bma.cur,\n\t\t\t&tmp_logflags, whichfork);\n\t\tbma.logflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE ||\n\t       XFS_IFORK_NEXTENTS(ip, whichfork) >\n\t\tXFS_IFORK_MAXEXT(ip, whichfork));\n\terror = 0;\nerror0:\n\t/*\n\t * Log everything.  Do this after conversion, there's no point in\n\t * logging the extent records if we've converted to btree format.\n\t */\n\tif ((bma.logflags & xfs_ilog_fext(whichfork)) &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t\tbma.logflags &= ~xfs_ilog_fext(whichfork);\n\telse if ((bma.logflags & xfs_ilog_fbroot(whichfork)) &&\n\t\t XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)\n\t\tbma.logflags &= ~xfs_ilog_fbroot(whichfork);\n\t/*\n\t * Log whatever the flags say, even if error.  Otherwise we might miss\n\t * detecting a case where the data is changed, there's an error,\n\t * and it's not logged so we don't shutdown when we should.\n\t */\n\tif (bma.logflags)\n\t\txfs_trans_log_inode(tp, ip, bma.logflags);\n\n\tif (bma.cur) {\n\t\tif (!error) {\n\t\t\tASSERT(*firstblock == NULLFSBLOCK ||\n\t\t\t       XFS_FSB_TO_AGNO(mp, *firstblock) ==\n\t\t\t       XFS_FSB_TO_AGNO(mp,\n\t\t\t\t       bma.cur->bc_private.b.firstblock) ||\n\t\t\t       (flist->xbf_low &&\n\t\t\t\tXFS_FSB_TO_AGNO(mp, *firstblock) <\n\t\t\t\tXFS_FSB_TO_AGNO(mp,\n\t\t\t\t\tbma.cur->bc_private.b.firstblock)));\n\t\t\t*firstblock = bma.cur->bc_private.b.firstblock;\n\t\t}\n\t\txfs_btree_del_cursor(bma.cur,\n\t\t\terror ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\n\t}\n\tif (!error)\n\t\txfs_bmap_validate_ret(orig_bno, orig_len, orig_flags, orig_mval,\n\t\t\torig_nmap, *nmap);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_init",
          "args": [
            "&free_list",
            "&firstfsb"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.h",
          "lines": "133-137",
          "snippet": "static inline void xfs_bmap_init(xfs_bmap_free_t *flp, xfs_fsblock_t *fbp)\n{\n\t((flp)->xbf_first = NULL, (flp)->xbf_count = 0, \\\n\t\t(flp)->xbf_low = 0, *(fbp) = NULLFSBLOCK);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_bmap_init(xfs_bmap_free_t *flp, xfs_fsblock_t *fbp)\n{\n\t((flp)->xbf_first = NULL, (flp)->xbf_count = 0, \\\n\t\t(flp)->xbf_low = 0, *(fbp) = NULLFSBLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ijoin",
          "args": [
            "tp",
            "ip",
            "0"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ijoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "37-57",
          "snippet": "void\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve_quota_nblks",
          "args": [
            "tp",
            "ip",
            "qblocks",
            "0",
            "quota_flag"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve_quota_nblks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
          "lines": "802-832",
          "snippet": "int\nxfs_trans_reserve_quota_nblks(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tlong\t\t\tnblks,\n\tlong\t\t\tninos,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) || !XFS_IS_QUOTA_ON(mp))\n\t\treturn 0;\n\tif (XFS_IS_PQUOTA_ON(mp))\n\t\tflags |= XFS_QMOPT_ENOSPC;\n\n\tASSERT(!xfs_is_quota_inode(&mp->m_sb, ip->i_ino));\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT((flags & ~(XFS_QMOPT_FORCE_RES | XFS_QMOPT_ENOSPC)) ==\n\t\t\t\tXFS_TRANS_DQ_RES_RTBLKS ||\n\t       (flags & ~(XFS_QMOPT_FORCE_RES | XFS_QMOPT_ENOSPC)) ==\n\t\t\t\tXFS_TRANS_DQ_RES_BLKS);\n\n\t/*\n\t * Reserve nblks against these dquots, with trans as the mediator.\n\t */\n\treturn xfs_trans_reserve_quota_bydquots(tp, mp,\n\t\t\t\t\t\tip->i_udquot, ip->i_gdquot,\n\t\t\t\t\t\tip->i_pdquot,\n\t\t\t\t\t\tnblks, ninos, flags);\n}",
          "includes": [
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_trans_reserve_quota_nblks(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tlong\t\t\tnblks,\n\tlong\t\t\tninos,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) || !XFS_IS_QUOTA_ON(mp))\n\t\treturn 0;\n\tif (XFS_IS_PQUOTA_ON(mp))\n\t\tflags |= XFS_QMOPT_ENOSPC;\n\n\tASSERT(!xfs_is_quota_inode(&mp->m_sb, ip->i_ino));\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT((flags & ~(XFS_QMOPT_FORCE_RES | XFS_QMOPT_ENOSPC)) ==\n\t\t\t\tXFS_TRANS_DQ_RES_RTBLKS ||\n\t       (flags & ~(XFS_QMOPT_FORCE_RES | XFS_QMOPT_ENOSPC)) ==\n\t\t\t\tXFS_TRANS_DQ_RES_BLKS);\n\n\t/*\n\t * Reserve nblks against these dquots, with trans as the mediator.\n\t */\n\treturn xfs_trans_reserve_quota_bydquots(tp, mp,\n\t\t\t\t\t\tip->i_udquot, ip->i_gdquot,\n\t\t\t\t\t\tip->i_pdquot,\n\t\t\t\t\t\tnblks, ninos, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "error == -ENOSPC || XFS_FORCED_SHUTDOWN(mp)"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve",
          "args": [
            "tp",
            "&M_RES(mp)->tr_write",
            "resblks",
            "resrtextents"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "168-279",
          "snippet": "int\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_alloc",
          "args": [
            "mp",
            "XFS_TRANS_DIOSTRAT"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "57-68",
          "snippet": "xfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_DIOSTRAT_SPACE_RES",
          "args": [
            "mp",
            "resblks"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_DIOSTRAT_SPACE_RES",
          "args": [
            "mp",
            "0"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rt"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "xfs_fileoff_t",
            "(e - s)",
            "(MAXEXTLEN * nimaps)"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_mod",
          "args": [
            "e",
            "extsz"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_mod",
          "args": [
            "startoffset_fsb",
            "extsz"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "s",
            "extsz"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "extsz"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_B_TO_FSB",
          "args": [
            "mp",
            "count"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_B_TO_FSBT",
          "args": [
            "mp",
            "offset"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_get_extsz_hint",
          "args": [
            "ip"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_get_extsz_hint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "67-76",
          "snippet": "xfs_extlen_t\nxfs_get_extsz_hint(\n\tstruct xfs_inode\t*ip)\n{\n\tif ((ip->i_d.di_flags & XFS_DIFLAG_EXTSIZE) && ip->i_d.di_extsize)\n\t\treturn ip->i_d.di_extsize;\n\tif (XFS_IS_REALTIME_INODE(ip))\n\t\treturn ip->i_mount->m_sb.sb_rextsize;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_extlen_t\nxfs_get_extsz_hint(\n\tstruct xfs_inode\t*ip)\n{\n\tif ((ip->i_d.di_flags & XFS_DIFLAG_EXTSIZE) && ip->i_d.di_extsize)\n\t\treturn ip->i_d.di_extsize;\n\tif (XFS_IS_REALTIME_INODE(ip))\n\t\treturn ip->i_mount->m_sb.sb_rextsize;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IS_REALTIME_INODE",
          "args": [
            "ip"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_qm_dqattach",
          "args": [
            "ip",
            "0"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqattach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
          "lines": "379-394",
          "snippet": "int\nxfs_qm_dqattach(\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tflags)\n{\n\tint\t\t\terror;\n\n\tif (!xfs_qm_need_dqattach(ip))\n\t\treturn 0;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\terror = xfs_qm_dqattach_locked(ip, flags);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_qm_dqattach(\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tflags)\n{\n\tint\t\t\terror;\n\n\tif (!xfs_qm_need_dqattach(ip))\n\t\treturn 0;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\terror = xfs_qm_dqattach_locked(ip, flags);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_alloc_file_space",
          "args": [
            "ip"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_alloc_file_space(\n\tstruct xfs_inode\t*ip,\n\txfs_off_t\t\toffset,\n\txfs_off_t\t\tlen,\n\tint\t\t\talloc_type)\n{\n\txfs_mount_t\t\t*mp = ip->i_mount;\n\txfs_off_t\t\tcount;\n\txfs_filblks_t\t\tallocated_fsb;\n\txfs_filblks_t\t\tallocatesize_fsb;\n\txfs_extlen_t\t\textsz, temp;\n\txfs_fileoff_t\t\tstartoffset_fsb;\n\txfs_fsblock_t\t\tfirstfsb;\n\tint\t\t\tnimaps;\n\tint\t\t\tquota_flag;\n\tint\t\t\trt;\n\txfs_trans_t\t\t*tp;\n\txfs_bmbt_irec_t\t\timaps[1], *imapp;\n\txfs_bmap_free_t\t\tfree_list;\n\tuint\t\t\tqblocks, resblks, resrtextents;\n\tint\t\t\tcommitted;\n\tint\t\t\terror;\n\n\ttrace_xfs_alloc_file_space(ip);\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\terror = xfs_qm_dqattach(ip, 0);\n\tif (error)\n\t\treturn error;\n\n\tif (len <= 0)\n\t\treturn -EINVAL;\n\n\trt = XFS_IS_REALTIME_INODE(ip);\n\textsz = xfs_get_extsz_hint(ip);\n\n\tcount = len;\n\timapp = &imaps[0];\n\tnimaps = 1;\n\tstartoffset_fsb\t= XFS_B_TO_FSBT(mp, offset);\n\tallocatesize_fsb = XFS_B_TO_FSB(mp, count);\n\n\t/*\n\t * Allocate file space until done or until there is an error\n\t */\n\twhile (allocatesize_fsb && !error) {\n\t\txfs_fileoff_t\ts, e;\n\n\t\t/*\n\t\t * Determine space reservations for data/realtime.\n\t\t */\n\t\tif (unlikely(extsz)) {\n\t\t\ts = startoffset_fsb;\n\t\t\tdo_div(s, extsz);\n\t\t\ts *= extsz;\n\t\t\te = startoffset_fsb + allocatesize_fsb;\n\t\t\tif ((temp = do_mod(startoffset_fsb, extsz)))\n\t\t\t\te += temp;\n\t\t\tif ((temp = do_mod(e, extsz)))\n\t\t\t\te += extsz - temp;\n\t\t} else {\n\t\t\ts = 0;\n\t\t\te = allocatesize_fsb;\n\t\t}\n\n\t\t/*\n\t\t * The transaction reservation is limited to a 32-bit block\n\t\t * count, hence we need to limit the number of blocks we are\n\t\t * trying to reserve to avoid an overflow. We can't allocate\n\t\t * more than @nimaps extents, and an extent is limited on disk\n\t\t * to MAXEXTLEN (21 bits), so use that to enforce the limit.\n\t\t */\n\t\tresblks = min_t(xfs_fileoff_t, (e - s), (MAXEXTLEN * nimaps));\n\t\tif (unlikely(rt)) {\n\t\t\tresrtextents = qblocks = resblks;\n\t\t\tresrtextents /= mp->m_sb.sb_rextsize;\n\t\t\tresblks = XFS_DIOSTRAT_SPACE_RES(mp, 0);\n\t\t\tquota_flag = XFS_QMOPT_RES_RTBLKS;\n\t\t} else {\n\t\t\tresrtextents = 0;\n\t\t\tresblks = qblocks = XFS_DIOSTRAT_SPACE_RES(mp, resblks);\n\t\t\tquota_flag = XFS_QMOPT_RES_REGBLKS;\n\t\t}\n\n\t\t/*\n\t\t * Allocate and setup the transaction.\n\t\t */\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_DIOSTRAT);\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_write,\n\t\t\t\t\t  resblks, resrtextents);\n\t\t/*\n\t\t * Check for running out of space\n\t\t */\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * Free the transaction structure.\n\t\t\t */\n\t\t\tASSERT(error == -ENOSPC || XFS_FORCED_SHUTDOWN(mp));\n\t\t\txfs_trans_cancel(tp, 0);\n\t\t\tbreak;\n\t\t}\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\terror = xfs_trans_reserve_quota_nblks(tp, ip, qblocks,\n\t\t\t\t\t\t      0, quota_flag);\n\t\tif (error)\n\t\t\tgoto error1;\n\n\t\txfs_trans_ijoin(tp, ip, 0);\n\n\t\txfs_bmap_init(&free_list, &firstfsb);\n\t\terror = xfs_bmapi_write(tp, ip, startoffset_fsb,\n\t\t\t\t\tallocatesize_fsb, alloc_type, &firstfsb,\n\t\t\t\t\t0, imapp, &nimaps, &free_list);\n\t\tif (error) {\n\t\t\tgoto error0;\n\t\t}\n\n\t\t/*\n\t\t * Complete the transaction\n\t\t */\n\t\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\t\tif (error) {\n\t\t\tgoto error0;\n\t\t}\n\n\t\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\tif (error) {\n\t\t\tbreak;\n\t\t}\n\n\t\tallocated_fsb = imapp->br_blockcount;\n\n\t\tif (nimaps == 0) {\n\t\t\terror = -ENOSPC;\n\t\t\tbreak;\n\t\t}\n\n\t\tstartoffset_fsb += allocated_fsb;\n\t\tallocatesize_fsb -= allocated_fsb;\n\t}\n\n\treturn error;\n\nerror0:\t/* Cancel bmap, unlock inode, unreserve quota blocks, cancel trans */\n\txfs_bmap_cancel(&free_list);\n\txfs_trans_unreserve_quota_nblks(tp, ip, (long)qblocks, 0, quota_flag);\n\nerror1:\t/* Just cancel transaction */\n\txfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_free_eofblocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
    "lines": "833-926",
    "snippet": "int\nxfs_free_eofblocks(\n\txfs_mount_t\t*mp,\n\txfs_inode_t\t*ip,\n\tbool\t\tneed_iolock)\n{\n\txfs_trans_t\t*tp;\n\tint\t\terror;\n\txfs_fileoff_t\tend_fsb;\n\txfs_fileoff_t\tlast_fsb;\n\txfs_filblks_t\tmap_len;\n\tint\t\tnimaps;\n\txfs_bmbt_irec_t\timap;\n\n\t/*\n\t * Figure out if there are any blocks beyond the end\n\t * of the file.  If not, then there is nothing to do.\n\t */\n\tend_fsb = XFS_B_TO_FSB(mp, (xfs_ufsize_t)XFS_ISIZE(ip));\n\tlast_fsb = XFS_B_TO_FSB(mp, mp->m_super->s_maxbytes);\n\tif (last_fsb <= end_fsb)\n\t\treturn 0;\n\tmap_len = last_fsb - end_fsb;\n\n\tnimaps = 1;\n\txfs_ilock(ip, XFS_ILOCK_SHARED);\n\terror = xfs_bmapi_read(ip, end_fsb, map_len, &imap, &nimaps, 0);\n\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\n\tif (!error && (nimaps != 0) &&\n\t    (imap.br_startblock != HOLESTARTBLOCK ||\n\t     ip->i_delayed_blks)) {\n\t\t/*\n\t\t * Attach the dquots to the inode up front.\n\t\t */\n\t\terror = xfs_qm_dqattach(ip, 0);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/*\n\t\t * There are blocks after the end of file.\n\t\t * Free them up now by truncating the file to\n\t\t * its current size.\n\t\t */\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_INACTIVE);\n\n\t\tif (need_iolock) {\n\t\t\tif (!xfs_ilock_nowait(ip, XFS_IOLOCK_EXCL)) {\n\t\t\t\txfs_trans_cancel(tp, 0);\n\t\t\t\treturn -EAGAIN;\n\t\t\t}\n\t\t}\n\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\n\t\tif (error) {\n\t\t\tASSERT(XFS_FORCED_SHUTDOWN(mp));\n\t\t\txfs_trans_cancel(tp, 0);\n\t\t\tif (need_iolock)\n\t\t\t\txfs_iunlock(ip, XFS_IOLOCK_EXCL);\n\t\t\treturn error;\n\t\t}\n\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\txfs_trans_ijoin(tp, ip, 0);\n\n\t\t/*\n\t\t * Do not update the on-disk file size.  If we update the\n\t\t * on-disk file size and then the system crashes before the\n\t\t * contents of the file are flushed to disk then the files\n\t\t * may be full of holes (ie NULL files bug).\n\t\t */\n\t\terror = xfs_itruncate_extents(&tp, ip, XFS_DATA_FORK,\n\t\t\t\t\t      XFS_ISIZE(ip));\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * If we get an error at this point we simply don't\n\t\t\t * bother truncating the file.\n\t\t\t */\n\t\t\txfs_trans_cancel(tp,\n\t\t\t\t\t (XFS_TRANS_RELEASE_LOG_RES |\n\t\t\t\t\t  XFS_TRANS_ABORT));\n\t\t} else {\n\t\t\terror = xfs_trans_commit(tp,\n\t\t\t\t\t\tXFS_TRANS_RELEASE_LOG_RES);\n\t\t\tif (!error)\n\t\t\t\txfs_inode_clear_eofblocks_tag(ip);\n\t\t}\n\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\tif (need_iolock)\n\t\t\txfs_iunlock(ip, XFS_IOLOCK_EXCL);\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "ip",
            "XFS_IOLOCK_EXCL"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_inode_clear_eofblocks_tag",
          "args": [
            "ip"
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inode_clear_eofblocks_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "1390-1417",
          "snippet": "void\nxfs_inode_clear_eofblocks_tag(\n\txfs_inode_t\t*ip)\n{\n\tstruct xfs_mount *mp = ip->i_mount;\n\tstruct xfs_perag *pag;\n\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ip->i_ino));\n\tspin_lock(&pag->pag_ici_lock);\n\ttrace_xfs_inode_clear_eofblocks_tag(ip);\n\n\tradix_tree_tag_clear(&pag->pag_ici_root,\n\t\t\t     XFS_INO_TO_AGINO(ip->i_mount, ip->i_ino),\n\t\t\t     XFS_ICI_EOFBLOCKS_TAG);\n\tif (!radix_tree_tagged(&pag->pag_ici_root, XFS_ICI_EOFBLOCKS_TAG)) {\n\t\t/* clear the eofblocks tag from the perag radix tree */\n\t\tspin_lock(&ip->i_mount->m_perag_lock);\n\t\tradix_tree_tag_clear(&ip->i_mount->m_perag_tree,\n\t\t\t\t     XFS_INO_TO_AGNO(ip->i_mount, ip->i_ino),\n\t\t\t\t     XFS_ICI_EOFBLOCKS_TAG);\n\t\tspin_unlock(&ip->i_mount->m_perag_lock);\n\t\ttrace_xfs_perag_clear_eofblocks(ip->i_mount, pag->pag_agno,\n\t\t\t\t\t       -1, _RET_IP_);\n\t}\n\n\tspin_unlock(&pag->pag_ici_lock);\n\txfs_perag_put(pag);\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nvoid\nxfs_inode_clear_eofblocks_tag(\n\txfs_inode_t\t*ip)\n{\n\tstruct xfs_mount *mp = ip->i_mount;\n\tstruct xfs_perag *pag;\n\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ip->i_ino));\n\tspin_lock(&pag->pag_ici_lock);\n\ttrace_xfs_inode_clear_eofblocks_tag(ip);\n\n\tradix_tree_tag_clear(&pag->pag_ici_root,\n\t\t\t     XFS_INO_TO_AGINO(ip->i_mount, ip->i_ino),\n\t\t\t     XFS_ICI_EOFBLOCKS_TAG);\n\tif (!radix_tree_tagged(&pag->pag_ici_root, XFS_ICI_EOFBLOCKS_TAG)) {\n\t\t/* clear the eofblocks tag from the perag radix tree */\n\t\tspin_lock(&ip->i_mount->m_perag_lock);\n\t\tradix_tree_tag_clear(&ip->i_mount->m_perag_tree,\n\t\t\t\t     XFS_INO_TO_AGNO(ip->i_mount, ip->i_ino),\n\t\t\t\t     XFS_ICI_EOFBLOCKS_TAG);\n\t\tspin_unlock(&ip->i_mount->m_perag_lock);\n\t\ttrace_xfs_perag_clear_eofblocks(ip->i_mount, pag->pag_agno,\n\t\t\t\t\t       -1, _RET_IP_);\n\t}\n\n\tspin_unlock(&pag->pag_ici_lock);\n\txfs_perag_put(pag);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_commit",
          "args": [
            "tp",
            "XFS_TRANS_RELEASE_LOG_RES"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "845-927",
          "snippet": "int\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_cancel",
          "args": [
            "tp",
            "(XFS_TRANS_RELEASE_LOG_RES |\n\t\t\t\t\t  XFS_TRANS_ABORT)"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "937-986",
          "snippet": "void\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_itruncate_extents",
          "args": [
            "&tp",
            "ip",
            "XFS_DATA_FORK",
            "XFS_ISIZE(ip)"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_itruncate_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "1492-1605",
          "snippet": "int\nxfs_itruncate_extents(\n\tstruct xfs_trans\t**tpp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork,\n\txfs_fsize_t\t\tnew_size)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp = *tpp;\n\tstruct xfs_trans\t*ntp;\n\txfs_bmap_free_t\t\tfree_list;\n\txfs_fsblock_t\t\tfirst_block;\n\txfs_fileoff_t\t\tfirst_unmap_block;\n\txfs_fileoff_t\t\tlast_block;\n\txfs_filblks_t\t\tunmap_len;\n\tint\t\t\tcommitted;\n\tint\t\t\terror = 0;\n\tint\t\t\tdone = 0;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(!atomic_read(&VFS_I(ip)->i_count) ||\n\t       xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\tASSERT(new_size <= XFS_ISIZE(ip));\n\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(ip->i_itemp->ili_lock_flags == 0);\n\tASSERT(!XFS_NOT_DQATTACHED(mp, ip));\n\n\ttrace_xfs_itruncate_extents_start(ip, new_size);\n\n\t/*\n\t * Since it is possible for space to become allocated beyond\n\t * the end of the file (in a crash where the space is allocated\n\t * but the inode size is not yet updated), simply remove any\n\t * blocks which show up between the new EOF and the maximum\n\t * possible file size.  If the first block to be removed is\n\t * beyond the maximum file size (ie it is the same as last_block),\n\t * then there is nothing to do.\n\t */\n\tfirst_unmap_block = XFS_B_TO_FSB(mp, (xfs_ufsize_t)new_size);\n\tlast_block = XFS_B_TO_FSB(mp, mp->m_super->s_maxbytes);\n\tif (first_unmap_block == last_block)\n\t\treturn 0;\n\n\tASSERT(first_unmap_block < last_block);\n\tunmap_len = last_block - first_unmap_block + 1;\n\twhile (!done) {\n\t\txfs_bmap_init(&free_list, &first_block);\n\t\terror = xfs_bunmapi(tp, ip,\n\t\t\t\t    first_unmap_block, unmap_len,\n\t\t\t\t    xfs_bmapi_aflag(whichfork),\n\t\t\t\t    XFS_ITRUNC_MAX_EXTENTS,\n\t\t\t\t    &first_block, &free_list,\n\t\t\t\t    &done);\n\t\tif (error)\n\t\t\tgoto out_bmap_cancel;\n\n\t\t/*\n\t\t * Duplicate the transaction that has the permanent\n\t\t * reservation and commit the old transaction.\n\t\t */\n\t\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(tp, ip, 0);\n\t\tif (error)\n\t\t\tgoto out_bmap_cancel;\n\n\t\tif (committed) {\n\t\t\t/*\n\t\t\t * Mark the inode dirty so it will be logged and\n\t\t\t * moved forward in the log as part of every commit.\n\t\t\t */\n\t\t\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\t\t}\n\n\t\tntp = xfs_trans_dup(tp);\n\t\terror = xfs_trans_commit(tp, 0);\n\t\ttp = ntp;\n\n\t\txfs_trans_ijoin(tp, ip, 0);\n\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Transaction commit worked ok so we can drop the extra ticket\n\t\t * reference that we gained in xfs_trans_dup()\n\t\t */\n\t\txfs_log_ticket_put(tp->t_ticket);\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Always re-log the inode so that our permanent transaction can keep\n\t * on rolling it forward in the log.\n\t */\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\ttrace_xfs_itruncate_extents_end(ip, new_size);\n\nout:\n\t*tpp = tp;\n\treturn error;\nout_bmap_cancel:\n\t/*\n\t * If the bunmapi call encounters an error, return to the caller where\n\t * the transaction can be properly aborted.  We just need to make sure\n\t * we're not holding any resources that we were not when we came in.\n\t */\n\txfs_bmap_cancel(&free_list);\n\tgoto out;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [
            "#define\tXFS_ITRUNC_MAX_EXTENTS\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\n#define\tXFS_ITRUNC_MAX_EXTENTS\t2\n\nint\nxfs_itruncate_extents(\n\tstruct xfs_trans\t**tpp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork,\n\txfs_fsize_t\t\tnew_size)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp = *tpp;\n\tstruct xfs_trans\t*ntp;\n\txfs_bmap_free_t\t\tfree_list;\n\txfs_fsblock_t\t\tfirst_block;\n\txfs_fileoff_t\t\tfirst_unmap_block;\n\txfs_fileoff_t\t\tlast_block;\n\txfs_filblks_t\t\tunmap_len;\n\tint\t\t\tcommitted;\n\tint\t\t\terror = 0;\n\tint\t\t\tdone = 0;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(!atomic_read(&VFS_I(ip)->i_count) ||\n\t       xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\tASSERT(new_size <= XFS_ISIZE(ip));\n\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(ip->i_itemp->ili_lock_flags == 0);\n\tASSERT(!XFS_NOT_DQATTACHED(mp, ip));\n\n\ttrace_xfs_itruncate_extents_start(ip, new_size);\n\n\t/*\n\t * Since it is possible for space to become allocated beyond\n\t * the end of the file (in a crash where the space is allocated\n\t * but the inode size is not yet updated), simply remove any\n\t * blocks which show up between the new EOF and the maximum\n\t * possible file size.  If the first block to be removed is\n\t * beyond the maximum file size (ie it is the same as last_block),\n\t * then there is nothing to do.\n\t */\n\tfirst_unmap_block = XFS_B_TO_FSB(mp, (xfs_ufsize_t)new_size);\n\tlast_block = XFS_B_TO_FSB(mp, mp->m_super->s_maxbytes);\n\tif (first_unmap_block == last_block)\n\t\treturn 0;\n\n\tASSERT(first_unmap_block < last_block);\n\tunmap_len = last_block - first_unmap_block + 1;\n\twhile (!done) {\n\t\txfs_bmap_init(&free_list, &first_block);\n\t\terror = xfs_bunmapi(tp, ip,\n\t\t\t\t    first_unmap_block, unmap_len,\n\t\t\t\t    xfs_bmapi_aflag(whichfork),\n\t\t\t\t    XFS_ITRUNC_MAX_EXTENTS,\n\t\t\t\t    &first_block, &free_list,\n\t\t\t\t    &done);\n\t\tif (error)\n\t\t\tgoto out_bmap_cancel;\n\n\t\t/*\n\t\t * Duplicate the transaction that has the permanent\n\t\t * reservation and commit the old transaction.\n\t\t */\n\t\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(tp, ip, 0);\n\t\tif (error)\n\t\t\tgoto out_bmap_cancel;\n\n\t\tif (committed) {\n\t\t\t/*\n\t\t\t * Mark the inode dirty so it will be logged and\n\t\t\t * moved forward in the log as part of every commit.\n\t\t\t */\n\t\t\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\t\t}\n\n\t\tntp = xfs_trans_dup(tp);\n\t\terror = xfs_trans_commit(tp, 0);\n\t\ttp = ntp;\n\n\t\txfs_trans_ijoin(tp, ip, 0);\n\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Transaction commit worked ok so we can drop the extra ticket\n\t\t * reference that we gained in xfs_trans_dup()\n\t\t */\n\t\txfs_log_ticket_put(tp->t_ticket);\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Always re-log the inode so that our permanent transaction can keep\n\t * on rolling it forward in the log.\n\t */\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\ttrace_xfs_itruncate_extents_end(ip, new_size);\n\nout:\n\t*tpp = tp;\n\treturn error;\nout_bmap_cancel:\n\t/*\n\t * If the bunmapi call encounters an error, return to the caller where\n\t * the transaction can be properly aborted.  We just need to make sure\n\t * we're not holding any resources that we were not when we came in.\n\t */\n\txfs_bmap_cancel(&free_list);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_ISIZE",
          "args": [
            "ip"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ijoin",
          "args": [
            "tp",
            "ip",
            "0"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ijoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "37-57",
          "snippet": "void\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_FORCED_SHUTDOWN(mp)"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve",
          "args": [
            "tp",
            "&M_RES(mp)->tr_itruncate",
            "0",
            "0"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "168-279",
          "snippet": "int\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_ilock_nowait",
          "args": [
            "ip",
            "XFS_IOLOCK_EXCL"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_nowait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "180-221",
          "snippet": "int\nxfs_ilock_nowait(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\ttrace_xfs_ilock_nowait(ip, lock_flags, _RET_IP_);\n\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL) {\n\t\tif (!mrtryupdate(&ip->i_iolock))\n\t\t\tgoto out;\n\t} else if (lock_flags & XFS_IOLOCK_SHARED) {\n\t\tif (!mrtryaccess(&ip->i_iolock))\n\t\t\tgoto out;\n\t}\n\tif (lock_flags & XFS_ILOCK_EXCL) {\n\t\tif (!mrtryupdate(&ip->i_lock))\n\t\t\tgoto out_undo_iolock;\n\t} else if (lock_flags & XFS_ILOCK_SHARED) {\n\t\tif (!mrtryaccess(&ip->i_lock))\n\t\t\tgoto out_undo_iolock;\n\t}\n\treturn 1;\n\n out_undo_iolock:\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n out:\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_ilock_nowait(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\ttrace_xfs_ilock_nowait(ip, lock_flags, _RET_IP_);\n\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL) {\n\t\tif (!mrtryupdate(&ip->i_iolock))\n\t\t\tgoto out;\n\t} else if (lock_flags & XFS_IOLOCK_SHARED) {\n\t\tif (!mrtryaccess(&ip->i_iolock))\n\t\t\tgoto out;\n\t}\n\tif (lock_flags & XFS_ILOCK_EXCL) {\n\t\tif (!mrtryupdate(&ip->i_lock))\n\t\t\tgoto out_undo_iolock;\n\t} else if (lock_flags & XFS_ILOCK_SHARED) {\n\t\tif (!mrtryaccess(&ip->i_lock))\n\t\t\tgoto out_undo_iolock;\n\t}\n\treturn 1;\n\n out_undo_iolock:\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n out:\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_alloc",
          "args": [
            "mp",
            "XFS_TRANS_INACTIVE"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "57-68",
          "snippet": "xfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_qm_dqattach",
          "args": [
            "ip",
            "0"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqattach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
          "lines": "379-394",
          "snippet": "int\nxfs_qm_dqattach(\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tflags)\n{\n\tint\t\t\terror;\n\n\tif (!xfs_qm_need_dqattach(ip))\n\t\treturn 0;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\terror = xfs_qm_dqattach_locked(ip, flags);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_qm_dqattach(\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tflags)\n{\n\tint\t\t\terror;\n\n\tif (!xfs_qm_need_dqattach(ip))\n\t\treturn 0;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\terror = xfs_qm_dqattach_locked(ip, flags);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmapi_read",
          "args": [
            "ip",
            "end_fsb",
            "map_len",
            "&imap",
            "&nimaps",
            "0"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmapi_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "4017-4103",
          "snippet": "int\nxfs_bmapi_read(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tstruct xfs_bmbt_irec\t*mval,\n\tint\t\t\t*nmap,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_bmbt_irec\tprev;\n\txfs_fileoff_t\t\tobno;\n\txfs_fileoff_t\t\tend;\n\txfs_extnum_t\t\tlastx;\n\tint\t\t\terror;\n\tint\t\t\teof;\n\tint\t\t\tn = 0;\n\tint\t\t\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(!(flags & ~(XFS_BMAPI_ATTRFORK|XFS_BMAPI_ENTIRE|\n\t\t\t   XFS_BMAPI_IGSTATE)));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED|XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_read\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_blk_mapr);\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(NULL, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got, &prev);\n\tend = bno + len;\n\tobno = bno;\n\n\twhile (bno < end && n < *nmap) {\n\t\t/* Reading past eof, act as though there's a hole up to end. */\n\t\tif (eof)\n\t\t\tgot.br_startoff = end;\n\t\tif (got.br_startoff > bno) {\n\t\t\t/* Reading in a hole.  */\n\t\t\tmval->br_startoff = bno;\n\t\t\tmval->br_startblock = HOLESTARTBLOCK;\n\t\t\tmval->br_blockcount =\n\t\t\t\tXFS_FILBLKS_MIN(len, got.br_startoff - bno);\n\t\t\tmval->br_state = XFS_EXT_NORM;\n\t\t\tbno += mval->br_blockcount;\n\t\t\tlen -= mval->br_blockcount;\n\t\t\tmval++;\n\t\t\tn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* set up the extent map to return. */\n\t\txfs_bmapi_trim_map(mval, &got, &bno, len, obno, end, n, flags);\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/* If we're done, stop now. */\n\t\tif (bno >= end || n >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tif (++lastx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t))\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx), &got);\n\t\telse\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmapi_read(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tstruct xfs_bmbt_irec\t*mval,\n\tint\t\t\t*nmap,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_bmbt_irec\tprev;\n\txfs_fileoff_t\t\tobno;\n\txfs_fileoff_t\t\tend;\n\txfs_extnum_t\t\tlastx;\n\tint\t\t\terror;\n\tint\t\t\teof;\n\tint\t\t\tn = 0;\n\tint\t\t\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(!(flags & ~(XFS_BMAPI_ATTRFORK|XFS_BMAPI_ENTIRE|\n\t\t\t   XFS_BMAPI_IGSTATE)));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED|XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_read\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_blk_mapr);\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(NULL, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got, &prev);\n\tend = bno + len;\n\tobno = bno;\n\n\twhile (bno < end && n < *nmap) {\n\t\t/* Reading past eof, act as though there's a hole up to end. */\n\t\tif (eof)\n\t\t\tgot.br_startoff = end;\n\t\tif (got.br_startoff > bno) {\n\t\t\t/* Reading in a hole.  */\n\t\t\tmval->br_startoff = bno;\n\t\t\tmval->br_startblock = HOLESTARTBLOCK;\n\t\t\tmval->br_blockcount =\n\t\t\t\tXFS_FILBLKS_MIN(len, got.br_startoff - bno);\n\t\t\tmval->br_state = XFS_EXT_NORM;\n\t\t\tbno += mval->br_blockcount;\n\t\t\tlen -= mval->br_blockcount;\n\t\t\tmval++;\n\t\t\tn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* set up the extent map to return. */\n\t\txfs_bmapi_trim_map(mval, &got, &bno, len, obno, end, n, flags);\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/* If we're done, stop now. */\n\t\tif (bno >= end || n >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tif (++lastx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t))\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx), &got);\n\t\telse\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_B_TO_FSB",
          "args": [
            "mp",
            "mp->m_super->s_maxbytes"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_B_TO_FSB",
          "args": [
            "mp",
            "(xfs_ufsize_t)XFS_ISIZE(ip)"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_free_eofblocks(\n\txfs_mount_t\t*mp,\n\txfs_inode_t\t*ip,\n\tbool\t\tneed_iolock)\n{\n\txfs_trans_t\t*tp;\n\tint\t\terror;\n\txfs_fileoff_t\tend_fsb;\n\txfs_fileoff_t\tlast_fsb;\n\txfs_filblks_t\tmap_len;\n\tint\t\tnimaps;\n\txfs_bmbt_irec_t\timap;\n\n\t/*\n\t * Figure out if there are any blocks beyond the end\n\t * of the file.  If not, then there is nothing to do.\n\t */\n\tend_fsb = XFS_B_TO_FSB(mp, (xfs_ufsize_t)XFS_ISIZE(ip));\n\tlast_fsb = XFS_B_TO_FSB(mp, mp->m_super->s_maxbytes);\n\tif (last_fsb <= end_fsb)\n\t\treturn 0;\n\tmap_len = last_fsb - end_fsb;\n\n\tnimaps = 1;\n\txfs_ilock(ip, XFS_ILOCK_SHARED);\n\terror = xfs_bmapi_read(ip, end_fsb, map_len, &imap, &nimaps, 0);\n\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\n\tif (!error && (nimaps != 0) &&\n\t    (imap.br_startblock != HOLESTARTBLOCK ||\n\t     ip->i_delayed_blks)) {\n\t\t/*\n\t\t * Attach the dquots to the inode up front.\n\t\t */\n\t\terror = xfs_qm_dqattach(ip, 0);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/*\n\t\t * There are blocks after the end of file.\n\t\t * Free them up now by truncating the file to\n\t\t * its current size.\n\t\t */\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_INACTIVE);\n\n\t\tif (need_iolock) {\n\t\t\tif (!xfs_ilock_nowait(ip, XFS_IOLOCK_EXCL)) {\n\t\t\t\txfs_trans_cancel(tp, 0);\n\t\t\t\treturn -EAGAIN;\n\t\t\t}\n\t\t}\n\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\n\t\tif (error) {\n\t\t\tASSERT(XFS_FORCED_SHUTDOWN(mp));\n\t\t\txfs_trans_cancel(tp, 0);\n\t\t\tif (need_iolock)\n\t\t\t\txfs_iunlock(ip, XFS_IOLOCK_EXCL);\n\t\t\treturn error;\n\t\t}\n\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\txfs_trans_ijoin(tp, ip, 0);\n\n\t\t/*\n\t\t * Do not update the on-disk file size.  If we update the\n\t\t * on-disk file size and then the system crashes before the\n\t\t * contents of the file are flushed to disk then the files\n\t\t * may be full of holes (ie NULL files bug).\n\t\t */\n\t\terror = xfs_itruncate_extents(&tp, ip, XFS_DATA_FORK,\n\t\t\t\t\t      XFS_ISIZE(ip));\n\t\tif (error) {\n\t\t\t/*\n\t\t\t * If we get an error at this point we simply don't\n\t\t\t * bother truncating the file.\n\t\t\t */\n\t\t\txfs_trans_cancel(tp,\n\t\t\t\t\t (XFS_TRANS_RELEASE_LOG_RES |\n\t\t\t\t\t  XFS_TRANS_ABORT));\n\t\t} else {\n\t\t\terror = xfs_trans_commit(tp,\n\t\t\t\t\t\tXFS_TRANS_RELEASE_LOG_RES);\n\t\t\tif (!error)\n\t\t\t\txfs_inode_clear_eofblocks_tag(ip);\n\t\t}\n\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\tif (need_iolock)\n\t\t\txfs_iunlock(ip, XFS_IOLOCK_EXCL);\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_can_free_eofblocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
    "lines": "797-826",
    "snippet": "bool\nxfs_can_free_eofblocks(struct xfs_inode *ip, bool force)\n{\n\t/* prealloc/delalloc exists only on regular files */\n\tif (!S_ISREG(ip->i_d.di_mode))\n\t\treturn false;\n\n\t/*\n\t * Zero sized files with no cached pages and delalloc blocks will not\n\t * have speculative prealloc/delalloc blocks to remove.\n\t */\n\tif (VFS_I(ip)->i_size == 0 &&\n\t    VFS_I(ip)->i_mapping->nrpages == 0 &&\n\t    ip->i_delayed_blks == 0)\n\t\treturn false;\n\n\t/* If we haven't read in the extent list, then don't do it now. */\n\tif (!(ip->i_df.if_flags & XFS_IFEXTENTS))\n\t\treturn false;\n\n\t/*\n\t * Do not free real preallocated or append-only files unless the file\n\t * has delalloc blocks and we are forced to remove them.\n\t */\n\tif (ip->i_d.di_flags & (XFS_DIFLAG_PREALLOC | XFS_DIFLAG_APPEND))\n\t\tif (!force || ip->i_delayed_blks == 0)\n\t\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "ip"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "78-81",
          "snippet": "static inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "ip->i_d.di_mode"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nbool\nxfs_can_free_eofblocks(struct xfs_inode *ip, bool force)\n{\n\t/* prealloc/delalloc exists only on regular files */\n\tif (!S_ISREG(ip->i_d.di_mode))\n\t\treturn false;\n\n\t/*\n\t * Zero sized files with no cached pages and delalloc blocks will not\n\t * have speculative prealloc/delalloc blocks to remove.\n\t */\n\tif (VFS_I(ip)->i_size == 0 &&\n\t    VFS_I(ip)->i_mapping->nrpages == 0 &&\n\t    ip->i_delayed_blks == 0)\n\t\treturn false;\n\n\t/* If we haven't read in the extent list, then don't do it now. */\n\tif (!(ip->i_df.if_flags & XFS_IFEXTENTS))\n\t\treturn false;\n\n\t/*\n\t * Do not free real preallocated or append-only files unless the file\n\t * has delalloc blocks and we are forced to remove them.\n\t */\n\tif (ip->i_d.di_flags & (XFS_DIFLAG_PREALLOC | XFS_DIFLAG_APPEND))\n\t\tif (!force || ip->i_delayed_blks == 0)\n\t\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "xfs_bmap_punch_delalloc_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
    "lines": "725-790",
    "snippet": "int\nxfs_bmap_punch_delalloc_range(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tstart_fsb,\n\txfs_fileoff_t\t\tlength)\n{\n\txfs_fileoff_t\t\tremaining = length;\n\tint\t\t\terror = 0;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tdo {\n\t\tint\t\tdone;\n\t\txfs_bmbt_irec_t\timap;\n\t\tint\t\tnimaps = 1;\n\t\txfs_fsblock_t\tfirstblock;\n\t\txfs_bmap_free_t flist;\n\n\t\t/*\n\t\t * Map the range first and check that it is a delalloc extent\n\t\t * before trying to unmap the range. Otherwise we will be\n\t\t * trying to remove a real extent (which requires a\n\t\t * transaction) or a hole, which is probably a bad idea...\n\t\t */\n\t\terror = xfs_bmapi_read(ip, start_fsb, 1, &imap, &nimaps,\n\t\t\t\t       XFS_BMAPI_ENTIRE);\n\n\t\tif (error) {\n\t\t\t/* something screwed, just bail */\n\t\t\tif (!XFS_FORCED_SHUTDOWN(ip->i_mount)) {\n\t\t\t\txfs_alert(ip->i_mount,\n\t\t\t\"Failed delalloc mapping lookup ino %lld fsb %lld.\",\n\t\t\t\t\t\tip->i_ino, start_fsb);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (!nimaps) {\n\t\t\t/* nothing there */\n\t\t\tgoto next_block;\n\t\t}\n\t\tif (imap.br_startblock != DELAYSTARTBLOCK) {\n\t\t\t/* been converted, ignore */\n\t\t\tgoto next_block;\n\t\t}\n\t\tWARN_ON(imap.br_blockcount == 0);\n\n\t\t/*\n\t\t * Note: while we initialise the firstblock/flist pair, they\n\t\t * should never be used because blocks should never be\n\t\t * allocated or freed for a delalloc extent and hence we need\n\t\t * don't cancel or finish them after the xfs_bunmapi() call.\n\t\t */\n\t\txfs_bmap_init(&flist, &firstblock);\n\t\terror = xfs_bunmapi(NULL, ip, start_fsb, 1, 0, 1, &firstblock,\n\t\t\t\t\t&flist, &done);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tASSERT(!flist.xbf_count && !flist.xbf_first);\nnext_block:\n\t\tstart_fsb++;\n\t\tremaining--;\n\t} while(remaining > 0);\n\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!flist.xbf_count && !flist.xbf_first"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bunmapi",
          "args": [
            "NULL",
            "ip",
            "start_fsb",
            "1",
            "0",
            "1",
            "&firstblock",
            "&flist",
            "&done"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bunmapi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "5030-5403",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_bunmapi(\n\txfs_trans_t\t\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_inode\t*ip,\t\t/* incore inode */\n\txfs_fileoff_t\t\tbno,\t\t/* starting offset to unmap */\n\txfs_filblks_t\t\tlen,\t\t/* length to unmap in file */\n\tint\t\t\tflags,\t\t/* misc flags */\n\txfs_extnum_t\t\tnexts,\t\t/* number of extents max */\n\txfs_fsblock_t\t\t*firstblock,\t/* first allocated block\n\t\t\t\t\t\t   controls a.g. for allocs */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*done)\t\t/* set if not done yet */\n{\n\txfs_btree_cur_t\t\t*cur;\t\t/* bmap btree cursor */\n\txfs_bmbt_irec_t\t\tdel;\t\t/* extent being deleted */\n\tint\t\t\teof;\t\t/* is deleting at eof */\n\txfs_bmbt_rec_host_t\t*ep;\t\t/* extent record pointer */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_extnum_t\t\textno;\t\t/* extent number in list */\n\txfs_bmbt_irec_t\t\tgot;\t\t/* current extent record */\n\txfs_ifork_t\t\t*ifp;\t\t/* inode fork pointer */\n\tint\t\t\tisrt;\t\t/* freeing in rt area */\n\txfs_extnum_t\t\tlastx;\t\t/* last extent index used */\n\tint\t\t\tlogflags;\t/* transaction logging flags */\n\txfs_extlen_t\t\tmod;\t\t/* rt extent offset */\n\txfs_mount_t\t\t*mp;\t\t/* mount structure */\n\txfs_extnum_t\t\tnextents;\t/* number of file extents */\n\txfs_bmbt_irec_t\t\tprev;\t\t/* previous extent record */\n\txfs_fileoff_t\t\tstart;\t\t/* first file offset deleted */\n\tint\t\t\ttmp_logflags;\t/* partial logging flags */\n\tint\t\t\twasdel;\t\t/* was a delayed alloc extent */\n\tint\t\t\twhichfork;\t/* data or attribute fork */\n\txfs_fsblock_t\t\tsum;\n\n\ttrace_xfs_bunmap(ip, bno, len, flags, _RET_IP_);\n\n\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (unlikely(\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)) {\n\t\tXFS_ERROR_REPORT(\"xfs_bunmapi\", XFS_ERRLEVEL_LOW,\n\t\t\t\t ip->i_mount);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tmp = ip->i_mount;\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(len > 0);\n\tASSERT(nexts >= 0);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS) &&\n\t    (error = xfs_iread_extents(tp, ip, whichfork)))\n\t\treturn error;\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tif (nextents == 0) {\n\t\t*done = 1;\n\t\treturn 0;\n\t}\n\tXFS_STATS_INC(xs_blk_unmap);\n\tisrt = (whichfork == XFS_DATA_FORK) && XFS_IS_REALTIME_INODE(ip);\n\tstart = bno;\n\tbno = start + len - 1;\n\tep = xfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got,\n\t\t&prev);\n\n\t/*\n\t * Check to see if the given block number is past the end of the\n\t * file, back up to the last block if so...\n\t */\n\tif (eof) {\n\t\tep = xfs_iext_get_ext(ifp, --lastx);\n\t\txfs_bmbt_get_all(ep, &got);\n\t\tbno = got.br_startoff + got.br_blockcount - 1;\n\t}\n\tlogflags = 0;\n\tif (ifp->if_flags & XFS_IFBROOT) {\n\t\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE);\n\t\tcur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);\n\t\tcur->bc_private.b.firstblock = *firstblock;\n\t\tcur->bc_private.b.flist = flist;\n\t\tcur->bc_private.b.flags = 0;\n\t} else\n\t\tcur = NULL;\n\n\tif (isrt) {\n\t\t/*\n\t\t * Synchronize by locking the bitmap inode.\n\t\t */\n\t\txfs_ilock(mp->m_rbmip, XFS_ILOCK_EXCL);\n\t\txfs_trans_ijoin(tp, mp->m_rbmip, XFS_ILOCK_EXCL);\n\t}\n\n\textno = 0;\n\twhile (bno != (xfs_fileoff_t)-1 && bno >= start && lastx >= 0 &&\n\t       (nexts == 0 || extno < nexts)) {\n\t\t/*\n\t\t * Is the found extent after a hole in which bno lives?\n\t\t * Just back up to the previous extent, if so.\n\t\t */\n\t\tif (got.br_startoff > bno) {\n\t\t\tif (--lastx < 0)\n\t\t\t\tbreak;\n\t\t\tep = xfs_iext_get_ext(ifp, lastx);\n\t\t\txfs_bmbt_get_all(ep, &got);\n\t\t}\n\t\t/*\n\t\t * Is the last block of this extent before the range\n\t\t * we're supposed to delete?  If so, we're done.\n\t\t */\n\t\tbno = XFS_FILEOFF_MIN(bno,\n\t\t\tgot.br_startoff + got.br_blockcount - 1);\n\t\tif (bno < start)\n\t\t\tbreak;\n\t\t/*\n\t\t * Then deal with the (possibly delayed) allocated space\n\t\t * we found.\n\t\t */\n\t\tASSERT(ep != NULL);\n\t\tdel = got;\n\t\twasdel = isnullstartblock(del.br_startblock);\n\t\tif (got.br_startoff < start) {\n\t\t\tdel.br_startoff = start;\n\t\t\tdel.br_blockcount -= start - got.br_startoff;\n\t\t\tif (!wasdel)\n\t\t\t\tdel.br_startblock += start - got.br_startoff;\n\t\t}\n\t\tif (del.br_startoff + del.br_blockcount > bno + 1)\n\t\t\tdel.br_blockcount = bno + 1 - del.br_startoff;\n\t\tsum = del.br_startblock + del.br_blockcount;\n\t\tif (isrt &&\n\t\t    (mod = do_mod(sum, mp->m_sb.sb_rextsize))) {\n\t\t\t/*\n\t\t\t * Realtime extent not lined up at the end.\n\t\t\t * The extent could have been split into written\n\t\t\t * and unwritten pieces, or we could just be\n\t\t\t * unmapping part of it.  But we can't really\n\t\t\t * get rid of part of a realtime extent.\n\t\t\t */\n\t\t\tif (del.br_state == XFS_EXT_UNWRITTEN ||\n\t\t\t    !xfs_sb_version_hasextflgbit(&mp->m_sb)) {\n\t\t\t\t/*\n\t\t\t\t * This piece is unwritten, or we're not\n\t\t\t\t * using unwritten extents.  Skip over it.\n\t\t\t\t */\n\t\t\t\tASSERT(bno >= mod);\n\t\t\t\tbno -= mod > del.br_blockcount ?\n\t\t\t\t\tdel.br_blockcount : mod;\n\t\t\t\tif (bno < got.br_startoff) {\n\t\t\t\t\tif (--lastx >= 0)\n\t\t\t\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(\n\t\t\t\t\t\t\tifp, lastx), &got);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * It's written, turn it unwritten.\n\t\t\t * This is better than zeroing it.\n\t\t\t */\n\t\t\tASSERT(del.br_state == XFS_EXT_NORM);\n\t\t\tASSERT(xfs_trans_get_block_res(tp) > 0);\n\t\t\t/*\n\t\t\t * If this spans a realtime extent boundary,\n\t\t\t * chop it back to the start of the one we end at.\n\t\t\t */\n\t\t\tif (del.br_blockcount > mod) {\n\t\t\t\tdel.br_startoff += del.br_blockcount - mod;\n\t\t\t\tdel.br_startblock += del.br_blockcount - mod;\n\t\t\t\tdel.br_blockcount = mod;\n\t\t\t}\n\t\t\tdel.br_state = XFS_EXT_UNWRITTEN;\n\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp, ip,\n\t\t\t\t\t&lastx, &cur, &del, firstblock, flist,\n\t\t\t\t\t&logflags);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tgoto nodelete;\n\t\t}\n\t\tif (isrt && (mod = do_mod(del.br_startblock, mp->m_sb.sb_rextsize))) {\n\t\t\t/*\n\t\t\t * Realtime extent is lined up at the end but not\n\t\t\t * at the front.  We'll get rid of full extents if\n\t\t\t * we can.\n\t\t\t */\n\t\t\tmod = mp->m_sb.sb_rextsize - mod;\n\t\t\tif (del.br_blockcount > mod) {\n\t\t\t\tdel.br_blockcount -= mod;\n\t\t\t\tdel.br_startoff += mod;\n\t\t\t\tdel.br_startblock += mod;\n\t\t\t} else if ((del.br_startoff == start &&\n\t\t\t\t    (del.br_state == XFS_EXT_UNWRITTEN ||\n\t\t\t\t     xfs_trans_get_block_res(tp) == 0)) ||\n\t\t\t\t   !xfs_sb_version_hasextflgbit(&mp->m_sb)) {\n\t\t\t\t/*\n\t\t\t\t * Can't make it unwritten.  There isn't\n\t\t\t\t * a full extent here so just skip it.\n\t\t\t\t */\n\t\t\t\tASSERT(bno >= del.br_blockcount);\n\t\t\t\tbno -= del.br_blockcount;\n\t\t\t\tif (got.br_startoff > bno) {\n\t\t\t\t\tif (--lastx >= 0) {\n\t\t\t\t\t\tep = xfs_iext_get_ext(ifp,\n\t\t\t\t\t\t\t\t      lastx);\n\t\t\t\t\t\txfs_bmbt_get_all(ep, &got);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else if (del.br_state == XFS_EXT_UNWRITTEN) {\n\t\t\t\t/*\n\t\t\t\t * This one is already unwritten.\n\t\t\t\t * It must have a written left neighbor.\n\t\t\t\t * Unwrite the killed part of that one and\n\t\t\t\t * try again.\n\t\t\t\t */\n\t\t\t\tASSERT(lastx > 0);\n\t\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp,\n\t\t\t\t\t\tlastx - 1), &prev);\n\t\t\t\tASSERT(prev.br_state == XFS_EXT_NORM);\n\t\t\t\tASSERT(!isnullstartblock(prev.br_startblock));\n\t\t\t\tASSERT(del.br_startblock ==\n\t\t\t\t       prev.br_startblock + prev.br_blockcount);\n\t\t\t\tif (prev.br_startoff < start) {\n\t\t\t\t\tmod = start - prev.br_startoff;\n\t\t\t\t\tprev.br_blockcount -= mod;\n\t\t\t\t\tprev.br_startblock += mod;\n\t\t\t\t\tprev.br_startoff = start;\n\t\t\t\t}\n\t\t\t\tprev.br_state = XFS_EXT_UNWRITTEN;\n\t\t\t\tlastx--;\n\t\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp,\n\t\t\t\t\t\tip, &lastx, &cur, &prev,\n\t\t\t\t\t\tfirstblock, flist, &logflags);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tgoto nodelete;\n\t\t\t} else {\n\t\t\t\tASSERT(del.br_state == XFS_EXT_NORM);\n\t\t\t\tdel.br_state = XFS_EXT_UNWRITTEN;\n\t\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp,\n\t\t\t\t\t\tip, &lastx, &cur, &del,\n\t\t\t\t\t\tfirstblock, flist, &logflags);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tgoto nodelete;\n\t\t\t}\n\t\t}\n\t\tif (wasdel) {\n\t\t\tASSERT(startblockval(del.br_startblock) > 0);\n\t\t\t/* Update realtime/data freespace, unreserve quota */\n\t\t\tif (isrt) {\n\t\t\t\txfs_filblks_t rtexts;\n\n\t\t\t\trtexts = XFS_FSB_TO_B(mp, del.br_blockcount);\n\t\t\t\tdo_div(rtexts, mp->m_sb.sb_rextsize);\n\t\t\t\txfs_mod_incore_sb(mp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t\t(int64_t)rtexts, 0);\n\t\t\t\t(void)xfs_trans_reserve_quota_nblks(NULL,\n\t\t\t\t\tip, -((long)del.br_blockcount), 0,\n\t\t\t\t\tXFS_QMOPT_RES_RTBLKS);\n\t\t\t} else {\n\t\t\t\txfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t\t(int64_t)del.br_blockcount, 0);\n\t\t\t\t(void)xfs_trans_reserve_quota_nblks(NULL,\n\t\t\t\t\tip, -((long)del.br_blockcount), 0,\n\t\t\t\t\tXFS_QMOPT_RES_REGBLKS);\n\t\t\t}\n\t\t\tip->i_delayed_blks -= del.br_blockcount;\n\t\t\tif (cur)\n\t\t\t\tcur->bc_private.b.flags |=\n\t\t\t\t\tXFS_BTCUR_BPRV_WASDEL;\n\t\t} else if (cur)\n\t\t\tcur->bc_private.b.flags &= ~XFS_BTCUR_BPRV_WASDEL;\n\t\t/*\n\t\t * If it's the case where the directory code is running\n\t\t * with no block reservation, and the deleted block is in\n\t\t * the middle of its extent, and the resulting insert\n\t\t * of an extent would cause transformation to btree format,\n\t\t * then reject it.  The calling code will then swap\n\t\t * blocks around instead.\n\t\t * We have to do this now, rather than waiting for the\n\t\t * conversion to btree format, since the transaction\n\t\t * will be dirty.\n\t\t */\n\t\tif (!wasdel && xfs_trans_get_block_res(tp) == 0 &&\n\t\t    XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS &&\n\t\t    XFS_IFORK_NEXTENTS(ip, whichfork) >= /* Note the >= */\n\t\t\tXFS_IFORK_MAXEXT(ip, whichfork) &&\n\t\t    del.br_startoff > got.br_startoff &&\n\t\t    del.br_startoff + del.br_blockcount <\n\t\t    got.br_startoff + got.br_blockcount) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto error0;\n\t\t}\n\t\terror = xfs_bmap_del_extent(ip, tp, &lastx, flist, cur, &del,\n\t\t\t\t&tmp_logflags, whichfork);\n\t\tlogflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tbno = del.br_startoff - 1;\nnodelete:\n\t\t/*\n\t\t * If not done go on to the next (previous) record.\n\t\t */\n\t\tif (bno != (xfs_fileoff_t)-1 && bno >= start) {\n\t\t\tif (lastx >= 0) {\n\t\t\t\tep = xfs_iext_get_ext(ifp, lastx);\n\t\t\t\tif (xfs_bmbt_get_startoff(ep) > bno) {\n\t\t\t\t\tif (--lastx >= 0)\n\t\t\t\t\t\tep = xfs_iext_get_ext(ifp,\n\t\t\t\t\t\t\t\t      lastx);\n\t\t\t\t}\n\t\t\t\txfs_bmbt_get_all(ep, &got);\n\t\t\t}\n\t\t\textno++;\n\t\t}\n\t}\n\t*done = bno == (xfs_fileoff_t)-1 || bno < start || lastx < 0;\n\n\t/*\n\t * Convert to a btree if necessary.\n\t */\n\tif (xfs_bmap_needs_btree(ip, whichfork)) {\n\t\tASSERT(cur == NULL);\n\t\terror = xfs_bmap_extents_to_btree(tp, ip, firstblock, flist,\n\t\t\t&cur, 0, &tmp_logflags, whichfork);\n\t\tlogflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\t/*\n\t * transform from btree to extents, give it cur\n\t */\n\telse if (xfs_bmap_wants_extents(ip, whichfork)) {\n\t\tASSERT(cur != NULL);\n\t\terror = xfs_bmap_btree_to_extents(tp, ip, cur, &tmp_logflags,\n\t\t\twhichfork);\n\t\tlogflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\t/*\n\t * transform from extents to local?\n\t */\n\terror = 0;\nerror0:\n\t/*\n\t * Log everything.  Do this after conversion, there's no point in\n\t * logging the extent records if we've converted to btree format.\n\t */\n\tif ((logflags & xfs_ilog_fext(whichfork)) &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t\tlogflags &= ~xfs_ilog_fext(whichfork);\n\telse if ((logflags & xfs_ilog_fbroot(whichfork)) &&\n\t\t XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)\n\t\tlogflags &= ~xfs_ilog_fbroot(whichfork);\n\t/*\n\t * Log inode even in the error case, if the transaction\n\t * is dirty we'll need to shut down the filesystem.\n\t */\n\tif (logflags)\n\t\txfs_trans_log_inode(tp, ip, logflags);\n\tif (cur) {\n\t\tif (!error) {\n\t\t\t*firstblock = cur->bc_private.b.firstblock;\n\t\t\tcur->bc_private.b.allocated = 0;\n\t\t}\n\t\txfs_btree_del_cursor(cur,\n\t\t\terror ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error */\nxfs_bunmapi(\n\txfs_trans_t\t\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_inode\t*ip,\t\t/* incore inode */\n\txfs_fileoff_t\t\tbno,\t\t/* starting offset to unmap */\n\txfs_filblks_t\t\tlen,\t\t/* length to unmap in file */\n\tint\t\t\tflags,\t\t/* misc flags */\n\txfs_extnum_t\t\tnexts,\t\t/* number of extents max */\n\txfs_fsblock_t\t\t*firstblock,\t/* first allocated block\n\t\t\t\t\t\t   controls a.g. for allocs */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*done)\t\t/* set if not done yet */\n{\n\txfs_btree_cur_t\t\t*cur;\t\t/* bmap btree cursor */\n\txfs_bmbt_irec_t\t\tdel;\t\t/* extent being deleted */\n\tint\t\t\teof;\t\t/* is deleting at eof */\n\txfs_bmbt_rec_host_t\t*ep;\t\t/* extent record pointer */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_extnum_t\t\textno;\t\t/* extent number in list */\n\txfs_bmbt_irec_t\t\tgot;\t\t/* current extent record */\n\txfs_ifork_t\t\t*ifp;\t\t/* inode fork pointer */\n\tint\t\t\tisrt;\t\t/* freeing in rt area */\n\txfs_extnum_t\t\tlastx;\t\t/* last extent index used */\n\tint\t\t\tlogflags;\t/* transaction logging flags */\n\txfs_extlen_t\t\tmod;\t\t/* rt extent offset */\n\txfs_mount_t\t\t*mp;\t\t/* mount structure */\n\txfs_extnum_t\t\tnextents;\t/* number of file extents */\n\txfs_bmbt_irec_t\t\tprev;\t\t/* previous extent record */\n\txfs_fileoff_t\t\tstart;\t\t/* first file offset deleted */\n\tint\t\t\ttmp_logflags;\t/* partial logging flags */\n\tint\t\t\twasdel;\t\t/* was a delayed alloc extent */\n\tint\t\t\twhichfork;\t/* data or attribute fork */\n\txfs_fsblock_t\t\tsum;\n\n\ttrace_xfs_bunmap(ip, bno, len, flags, _RET_IP_);\n\n\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (unlikely(\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)) {\n\t\tXFS_ERROR_REPORT(\"xfs_bunmapi\", XFS_ERRLEVEL_LOW,\n\t\t\t\t ip->i_mount);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tmp = ip->i_mount;\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(len > 0);\n\tASSERT(nexts >= 0);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS) &&\n\t    (error = xfs_iread_extents(tp, ip, whichfork)))\n\t\treturn error;\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tif (nextents == 0) {\n\t\t*done = 1;\n\t\treturn 0;\n\t}\n\tXFS_STATS_INC(xs_blk_unmap);\n\tisrt = (whichfork == XFS_DATA_FORK) && XFS_IS_REALTIME_INODE(ip);\n\tstart = bno;\n\tbno = start + len - 1;\n\tep = xfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got,\n\t\t&prev);\n\n\t/*\n\t * Check to see if the given block number is past the end of the\n\t * file, back up to the last block if so...\n\t */\n\tif (eof) {\n\t\tep = xfs_iext_get_ext(ifp, --lastx);\n\t\txfs_bmbt_get_all(ep, &got);\n\t\tbno = got.br_startoff + got.br_blockcount - 1;\n\t}\n\tlogflags = 0;\n\tif (ifp->if_flags & XFS_IFBROOT) {\n\t\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE);\n\t\tcur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);\n\t\tcur->bc_private.b.firstblock = *firstblock;\n\t\tcur->bc_private.b.flist = flist;\n\t\tcur->bc_private.b.flags = 0;\n\t} else\n\t\tcur = NULL;\n\n\tif (isrt) {\n\t\t/*\n\t\t * Synchronize by locking the bitmap inode.\n\t\t */\n\t\txfs_ilock(mp->m_rbmip, XFS_ILOCK_EXCL);\n\t\txfs_trans_ijoin(tp, mp->m_rbmip, XFS_ILOCK_EXCL);\n\t}\n\n\textno = 0;\n\twhile (bno != (xfs_fileoff_t)-1 && bno >= start && lastx >= 0 &&\n\t       (nexts == 0 || extno < nexts)) {\n\t\t/*\n\t\t * Is the found extent after a hole in which bno lives?\n\t\t * Just back up to the previous extent, if so.\n\t\t */\n\t\tif (got.br_startoff > bno) {\n\t\t\tif (--lastx < 0)\n\t\t\t\tbreak;\n\t\t\tep = xfs_iext_get_ext(ifp, lastx);\n\t\t\txfs_bmbt_get_all(ep, &got);\n\t\t}\n\t\t/*\n\t\t * Is the last block of this extent before the range\n\t\t * we're supposed to delete?  If so, we're done.\n\t\t */\n\t\tbno = XFS_FILEOFF_MIN(bno,\n\t\t\tgot.br_startoff + got.br_blockcount - 1);\n\t\tif (bno < start)\n\t\t\tbreak;\n\t\t/*\n\t\t * Then deal with the (possibly delayed) allocated space\n\t\t * we found.\n\t\t */\n\t\tASSERT(ep != NULL);\n\t\tdel = got;\n\t\twasdel = isnullstartblock(del.br_startblock);\n\t\tif (got.br_startoff < start) {\n\t\t\tdel.br_startoff = start;\n\t\t\tdel.br_blockcount -= start - got.br_startoff;\n\t\t\tif (!wasdel)\n\t\t\t\tdel.br_startblock += start - got.br_startoff;\n\t\t}\n\t\tif (del.br_startoff + del.br_blockcount > bno + 1)\n\t\t\tdel.br_blockcount = bno + 1 - del.br_startoff;\n\t\tsum = del.br_startblock + del.br_blockcount;\n\t\tif (isrt &&\n\t\t    (mod = do_mod(sum, mp->m_sb.sb_rextsize))) {\n\t\t\t/*\n\t\t\t * Realtime extent not lined up at the end.\n\t\t\t * The extent could have been split into written\n\t\t\t * and unwritten pieces, or we could just be\n\t\t\t * unmapping part of it.  But we can't really\n\t\t\t * get rid of part of a realtime extent.\n\t\t\t */\n\t\t\tif (del.br_state == XFS_EXT_UNWRITTEN ||\n\t\t\t    !xfs_sb_version_hasextflgbit(&mp->m_sb)) {\n\t\t\t\t/*\n\t\t\t\t * This piece is unwritten, or we're not\n\t\t\t\t * using unwritten extents.  Skip over it.\n\t\t\t\t */\n\t\t\t\tASSERT(bno >= mod);\n\t\t\t\tbno -= mod > del.br_blockcount ?\n\t\t\t\t\tdel.br_blockcount : mod;\n\t\t\t\tif (bno < got.br_startoff) {\n\t\t\t\t\tif (--lastx >= 0)\n\t\t\t\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(\n\t\t\t\t\t\t\tifp, lastx), &got);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * It's written, turn it unwritten.\n\t\t\t * This is better than zeroing it.\n\t\t\t */\n\t\t\tASSERT(del.br_state == XFS_EXT_NORM);\n\t\t\tASSERT(xfs_trans_get_block_res(tp) > 0);\n\t\t\t/*\n\t\t\t * If this spans a realtime extent boundary,\n\t\t\t * chop it back to the start of the one we end at.\n\t\t\t */\n\t\t\tif (del.br_blockcount > mod) {\n\t\t\t\tdel.br_startoff += del.br_blockcount - mod;\n\t\t\t\tdel.br_startblock += del.br_blockcount - mod;\n\t\t\t\tdel.br_blockcount = mod;\n\t\t\t}\n\t\t\tdel.br_state = XFS_EXT_UNWRITTEN;\n\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp, ip,\n\t\t\t\t\t&lastx, &cur, &del, firstblock, flist,\n\t\t\t\t\t&logflags);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tgoto nodelete;\n\t\t}\n\t\tif (isrt && (mod = do_mod(del.br_startblock, mp->m_sb.sb_rextsize))) {\n\t\t\t/*\n\t\t\t * Realtime extent is lined up at the end but not\n\t\t\t * at the front.  We'll get rid of full extents if\n\t\t\t * we can.\n\t\t\t */\n\t\t\tmod = mp->m_sb.sb_rextsize - mod;\n\t\t\tif (del.br_blockcount > mod) {\n\t\t\t\tdel.br_blockcount -= mod;\n\t\t\t\tdel.br_startoff += mod;\n\t\t\t\tdel.br_startblock += mod;\n\t\t\t} else if ((del.br_startoff == start &&\n\t\t\t\t    (del.br_state == XFS_EXT_UNWRITTEN ||\n\t\t\t\t     xfs_trans_get_block_res(tp) == 0)) ||\n\t\t\t\t   !xfs_sb_version_hasextflgbit(&mp->m_sb)) {\n\t\t\t\t/*\n\t\t\t\t * Can't make it unwritten.  There isn't\n\t\t\t\t * a full extent here so just skip it.\n\t\t\t\t */\n\t\t\t\tASSERT(bno >= del.br_blockcount);\n\t\t\t\tbno -= del.br_blockcount;\n\t\t\t\tif (got.br_startoff > bno) {\n\t\t\t\t\tif (--lastx >= 0) {\n\t\t\t\t\t\tep = xfs_iext_get_ext(ifp,\n\t\t\t\t\t\t\t\t      lastx);\n\t\t\t\t\t\txfs_bmbt_get_all(ep, &got);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else if (del.br_state == XFS_EXT_UNWRITTEN) {\n\t\t\t\t/*\n\t\t\t\t * This one is already unwritten.\n\t\t\t\t * It must have a written left neighbor.\n\t\t\t\t * Unwrite the killed part of that one and\n\t\t\t\t * try again.\n\t\t\t\t */\n\t\t\t\tASSERT(lastx > 0);\n\t\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp,\n\t\t\t\t\t\tlastx - 1), &prev);\n\t\t\t\tASSERT(prev.br_state == XFS_EXT_NORM);\n\t\t\t\tASSERT(!isnullstartblock(prev.br_startblock));\n\t\t\t\tASSERT(del.br_startblock ==\n\t\t\t\t       prev.br_startblock + prev.br_blockcount);\n\t\t\t\tif (prev.br_startoff < start) {\n\t\t\t\t\tmod = start - prev.br_startoff;\n\t\t\t\t\tprev.br_blockcount -= mod;\n\t\t\t\t\tprev.br_startblock += mod;\n\t\t\t\t\tprev.br_startoff = start;\n\t\t\t\t}\n\t\t\t\tprev.br_state = XFS_EXT_UNWRITTEN;\n\t\t\t\tlastx--;\n\t\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp,\n\t\t\t\t\t\tip, &lastx, &cur, &prev,\n\t\t\t\t\t\tfirstblock, flist, &logflags);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tgoto nodelete;\n\t\t\t} else {\n\t\t\t\tASSERT(del.br_state == XFS_EXT_NORM);\n\t\t\t\tdel.br_state = XFS_EXT_UNWRITTEN;\n\t\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp,\n\t\t\t\t\t\tip, &lastx, &cur, &del,\n\t\t\t\t\t\tfirstblock, flist, &logflags);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tgoto nodelete;\n\t\t\t}\n\t\t}\n\t\tif (wasdel) {\n\t\t\tASSERT(startblockval(del.br_startblock) > 0);\n\t\t\t/* Update realtime/data freespace, unreserve quota */\n\t\t\tif (isrt) {\n\t\t\t\txfs_filblks_t rtexts;\n\n\t\t\t\trtexts = XFS_FSB_TO_B(mp, del.br_blockcount);\n\t\t\t\tdo_div(rtexts, mp->m_sb.sb_rextsize);\n\t\t\t\txfs_mod_incore_sb(mp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t\t(int64_t)rtexts, 0);\n\t\t\t\t(void)xfs_trans_reserve_quota_nblks(NULL,\n\t\t\t\t\tip, -((long)del.br_blockcount), 0,\n\t\t\t\t\tXFS_QMOPT_RES_RTBLKS);\n\t\t\t} else {\n\t\t\t\txfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t\t(int64_t)del.br_blockcount, 0);\n\t\t\t\t(void)xfs_trans_reserve_quota_nblks(NULL,\n\t\t\t\t\tip, -((long)del.br_blockcount), 0,\n\t\t\t\t\tXFS_QMOPT_RES_REGBLKS);\n\t\t\t}\n\t\t\tip->i_delayed_blks -= del.br_blockcount;\n\t\t\tif (cur)\n\t\t\t\tcur->bc_private.b.flags |=\n\t\t\t\t\tXFS_BTCUR_BPRV_WASDEL;\n\t\t} else if (cur)\n\t\t\tcur->bc_private.b.flags &= ~XFS_BTCUR_BPRV_WASDEL;\n\t\t/*\n\t\t * If it's the case where the directory code is running\n\t\t * with no block reservation, and the deleted block is in\n\t\t * the middle of its extent, and the resulting insert\n\t\t * of an extent would cause transformation to btree format,\n\t\t * then reject it.  The calling code will then swap\n\t\t * blocks around instead.\n\t\t * We have to do this now, rather than waiting for the\n\t\t * conversion to btree format, since the transaction\n\t\t * will be dirty.\n\t\t */\n\t\tif (!wasdel && xfs_trans_get_block_res(tp) == 0 &&\n\t\t    XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS &&\n\t\t    XFS_IFORK_NEXTENTS(ip, whichfork) >= /* Note the >= */\n\t\t\tXFS_IFORK_MAXEXT(ip, whichfork) &&\n\t\t    del.br_startoff > got.br_startoff &&\n\t\t    del.br_startoff + del.br_blockcount <\n\t\t    got.br_startoff + got.br_blockcount) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto error0;\n\t\t}\n\t\terror = xfs_bmap_del_extent(ip, tp, &lastx, flist, cur, &del,\n\t\t\t\t&tmp_logflags, whichfork);\n\t\tlogflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tbno = del.br_startoff - 1;\nnodelete:\n\t\t/*\n\t\t * If not done go on to the next (previous) record.\n\t\t */\n\t\tif (bno != (xfs_fileoff_t)-1 && bno >= start) {\n\t\t\tif (lastx >= 0) {\n\t\t\t\tep = xfs_iext_get_ext(ifp, lastx);\n\t\t\t\tif (xfs_bmbt_get_startoff(ep) > bno) {\n\t\t\t\t\tif (--lastx >= 0)\n\t\t\t\t\t\tep = xfs_iext_get_ext(ifp,\n\t\t\t\t\t\t\t\t      lastx);\n\t\t\t\t}\n\t\t\t\txfs_bmbt_get_all(ep, &got);\n\t\t\t}\n\t\t\textno++;\n\t\t}\n\t}\n\t*done = bno == (xfs_fileoff_t)-1 || bno < start || lastx < 0;\n\n\t/*\n\t * Convert to a btree if necessary.\n\t */\n\tif (xfs_bmap_needs_btree(ip, whichfork)) {\n\t\tASSERT(cur == NULL);\n\t\terror = xfs_bmap_extents_to_btree(tp, ip, firstblock, flist,\n\t\t\t&cur, 0, &tmp_logflags, whichfork);\n\t\tlogflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\t/*\n\t * transform from btree to extents, give it cur\n\t */\n\telse if (xfs_bmap_wants_extents(ip, whichfork)) {\n\t\tASSERT(cur != NULL);\n\t\terror = xfs_bmap_btree_to_extents(tp, ip, cur, &tmp_logflags,\n\t\t\twhichfork);\n\t\tlogflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\t/*\n\t * transform from extents to local?\n\t */\n\terror = 0;\nerror0:\n\t/*\n\t * Log everything.  Do this after conversion, there's no point in\n\t * logging the extent records if we've converted to btree format.\n\t */\n\tif ((logflags & xfs_ilog_fext(whichfork)) &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t\tlogflags &= ~xfs_ilog_fext(whichfork);\n\telse if ((logflags & xfs_ilog_fbroot(whichfork)) &&\n\t\t XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)\n\t\tlogflags &= ~xfs_ilog_fbroot(whichfork);\n\t/*\n\t * Log inode even in the error case, if the transaction\n\t * is dirty we'll need to shut down the filesystem.\n\t */\n\tif (logflags)\n\t\txfs_trans_log_inode(tp, ip, logflags);\n\tif (cur) {\n\t\tif (!error) {\n\t\t\t*firstblock = cur->bc_private.b.firstblock;\n\t\t\tcur->bc_private.b.allocated = 0;\n\t\t}\n\t\txfs_btree_del_cursor(cur,\n\t\t\terror ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_init",
          "args": [
            "&flist",
            "&firstblock"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.h",
          "lines": "133-137",
          "snippet": "static inline void xfs_bmap_init(xfs_bmap_free_t *flp, xfs_fsblock_t *fbp)\n{\n\t((flp)->xbf_first = NULL, (flp)->xbf_count = 0, \\\n\t\t(flp)->xbf_low = 0, *(fbp) = NULLFSBLOCK);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_bmap_init(xfs_bmap_free_t *flp, xfs_fsblock_t *fbp)\n{\n\t((flp)->xbf_first = NULL, (flp)->xbf_count = 0, \\\n\t\t(flp)->xbf_low = 0, *(fbp) = NULLFSBLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "imap.br_blockcount == 0"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alert",
          "args": [
            "ip->i_mount",
            "\"Failed delalloc mapping lookup ino %lld fsb %lld.\"",
            "ip->i_ino",
            "start_fsb"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alert_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_message.c",
          "lines": "67-91",
          "snippet": "void\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}",
          "includes": [
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "ip->i_mount"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmapi_read",
          "args": [
            "ip",
            "start_fsb",
            "1",
            "&imap",
            "&nimaps",
            "XFS_BMAPI_ENTIRE"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmapi_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "4017-4103",
          "snippet": "int\nxfs_bmapi_read(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tstruct xfs_bmbt_irec\t*mval,\n\tint\t\t\t*nmap,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_bmbt_irec\tprev;\n\txfs_fileoff_t\t\tobno;\n\txfs_fileoff_t\t\tend;\n\txfs_extnum_t\t\tlastx;\n\tint\t\t\terror;\n\tint\t\t\teof;\n\tint\t\t\tn = 0;\n\tint\t\t\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(!(flags & ~(XFS_BMAPI_ATTRFORK|XFS_BMAPI_ENTIRE|\n\t\t\t   XFS_BMAPI_IGSTATE)));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED|XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_read\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_blk_mapr);\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(NULL, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got, &prev);\n\tend = bno + len;\n\tobno = bno;\n\n\twhile (bno < end && n < *nmap) {\n\t\t/* Reading past eof, act as though there's a hole up to end. */\n\t\tif (eof)\n\t\t\tgot.br_startoff = end;\n\t\tif (got.br_startoff > bno) {\n\t\t\t/* Reading in a hole.  */\n\t\t\tmval->br_startoff = bno;\n\t\t\tmval->br_startblock = HOLESTARTBLOCK;\n\t\t\tmval->br_blockcount =\n\t\t\t\tXFS_FILBLKS_MIN(len, got.br_startoff - bno);\n\t\t\tmval->br_state = XFS_EXT_NORM;\n\t\t\tbno += mval->br_blockcount;\n\t\t\tlen -= mval->br_blockcount;\n\t\t\tmval++;\n\t\t\tn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* set up the extent map to return. */\n\t\txfs_bmapi_trim_map(mval, &got, &bno, len, obno, end, n, flags);\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/* If we're done, stop now. */\n\t\tif (bno >= end || n >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tif (++lastx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t))\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx), &got);\n\t\telse\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmapi_read(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tstruct xfs_bmbt_irec\t*mval,\n\tint\t\t\t*nmap,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_bmbt_irec\tprev;\n\txfs_fileoff_t\t\tobno;\n\txfs_fileoff_t\t\tend;\n\txfs_extnum_t\t\tlastx;\n\tint\t\t\terror;\n\tint\t\t\teof;\n\tint\t\t\tn = 0;\n\tint\t\t\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(!(flags & ~(XFS_BMAPI_ATTRFORK|XFS_BMAPI_ENTIRE|\n\t\t\t   XFS_BMAPI_IGSTATE)));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED|XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_read\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_blk_mapr);\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(NULL, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got, &prev);\n\tend = bno + len;\n\tobno = bno;\n\n\twhile (bno < end && n < *nmap) {\n\t\t/* Reading past eof, act as though there's a hole up to end. */\n\t\tif (eof)\n\t\t\tgot.br_startoff = end;\n\t\tif (got.br_startoff > bno) {\n\t\t\t/* Reading in a hole.  */\n\t\t\tmval->br_startoff = bno;\n\t\t\tmval->br_startblock = HOLESTARTBLOCK;\n\t\t\tmval->br_blockcount =\n\t\t\t\tXFS_FILBLKS_MIN(len, got.br_startoff - bno);\n\t\t\tmval->br_state = XFS_EXT_NORM;\n\t\t\tbno += mval->br_blockcount;\n\t\t\tlen -= mval->br_blockcount;\n\t\t\tmval++;\n\t\t\tn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* set up the extent map to return. */\n\t\txfs_bmapi_trim_map(mval, &got, &bno, len, obno, end, n, flags);\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/* If we're done, stop now. */\n\t\tif (bno >= end || n >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tif (++lastx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t))\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx), &got);\n\t\telse\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_isilocked(ip, XFS_ILOCK_EXCL)"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_isilocked",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_isilocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "286-305",
          "snippet": "int\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmap_punch_delalloc_range(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tstart_fsb,\n\txfs_fileoff_t\t\tlength)\n{\n\txfs_fileoff_t\t\tremaining = length;\n\tint\t\t\terror = 0;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tdo {\n\t\tint\t\tdone;\n\t\txfs_bmbt_irec_t\timap;\n\t\tint\t\tnimaps = 1;\n\t\txfs_fsblock_t\tfirstblock;\n\t\txfs_bmap_free_t flist;\n\n\t\t/*\n\t\t * Map the range first and check that it is a delalloc extent\n\t\t * before trying to unmap the range. Otherwise we will be\n\t\t * trying to remove a real extent (which requires a\n\t\t * transaction) or a hole, which is probably a bad idea...\n\t\t */\n\t\terror = xfs_bmapi_read(ip, start_fsb, 1, &imap, &nimaps,\n\t\t\t\t       XFS_BMAPI_ENTIRE);\n\n\t\tif (error) {\n\t\t\t/* something screwed, just bail */\n\t\t\tif (!XFS_FORCED_SHUTDOWN(ip->i_mount)) {\n\t\t\t\txfs_alert(ip->i_mount,\n\t\t\t\"Failed delalloc mapping lookup ino %lld fsb %lld.\",\n\t\t\t\t\t\tip->i_ino, start_fsb);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (!nimaps) {\n\t\t\t/* nothing there */\n\t\t\tgoto next_block;\n\t\t}\n\t\tif (imap.br_startblock != DELAYSTARTBLOCK) {\n\t\t\t/* been converted, ignore */\n\t\t\tgoto next_block;\n\t\t}\n\t\tWARN_ON(imap.br_blockcount == 0);\n\n\t\t/*\n\t\t * Note: while we initialise the firstblock/flist pair, they\n\t\t * should never be used because blocks should never be\n\t\t * allocated or freed for a delalloc extent and hence we need\n\t\t * don't cancel or finish them after the xfs_bunmapi() call.\n\t\t */\n\t\txfs_bmap_init(&flist, &firstblock);\n\t\terror = xfs_bunmapi(NULL, ip, start_fsb, 1, 0, 1, &firstblock,\n\t\t\t\t\t&flist, &done);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tASSERT(!flist.xbf_count && !flist.xbf_first);\nnext_block:\n\t\tstart_fsb++;\n\t\tremaining--;\n\t} while(remaining > 0);\n\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_getbmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
    "lines": "489-715",
    "snippet": "int\t\t\t\t\t\t/* error code */\nxfs_getbmap(\n\txfs_inode_t\t\t*ip,\n\tstruct getbmapx\t\t*bmv,\t\t/* user bmap structure */\n\txfs_bmap_format_t\tformatter,\t/* format to user */\n\tvoid\t\t\t*arg)\t\t/* formatter arg */\n{\n\t__int64_t\t\tbmvend;\t\t/* last block requested */\n\tint\t\t\terror = 0;\t/* return value */\n\t__int64_t\t\tfixlen;\t\t/* length for -1 case */\n\tint\t\t\ti;\t\t/* extent number */\n\tint\t\t\tlock;\t\t/* lock state */\n\txfs_bmbt_irec_t\t\t*map;\t\t/* buffer for user's data */\n\txfs_mount_t\t\t*mp;\t\t/* file system mount point */\n\tint\t\t\tnex;\t\t/* # of user extents can do */\n\tint\t\t\tnexleft;\t/* # of user extents left */\n\tint\t\t\tsubnex;\t\t/* # of bmapi's can do */\n\tint\t\t\tnmap;\t\t/* number of map entries */\n\tstruct getbmapx\t\t*out;\t\t/* output structure */\n\tint\t\t\twhichfork;\t/* data or attr fork */\n\tint\t\t\tprealloced;\t/* this is a file with\n\t\t\t\t\t\t * preallocated data space */\n\tint\t\t\tiflags;\t\t/* interface flags */\n\tint\t\t\tbmapi_flags;\t/* flags for xfs_bmapi */\n\tint\t\t\tcur_ext = 0;\n\n\tmp = ip->i_mount;\n\tiflags = bmv->bmv_iflags;\n\twhichfork = iflags & BMV_IF_ATTRFORK ? XFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tif (whichfork == XFS_ATTR_FORK) {\n\t\tif (XFS_IFORK_Q(ip)) {\n\t\t\tif (ip->i_d.di_aformat != XFS_DINODE_FMT_EXTENTS &&\n\t\t\t    ip->i_d.di_aformat != XFS_DINODE_FMT_BTREE &&\n\t\t\t    ip->i_d.di_aformat != XFS_DINODE_FMT_LOCAL)\n\t\t\t\treturn -EINVAL;\n\t\t} else if (unlikely(\n\t\t\t   ip->i_d.di_aformat != 0 &&\n\t\t\t   ip->i_d.di_aformat != XFS_DINODE_FMT_EXTENTS)) {\n\t\t\tXFS_ERROR_REPORT(\"xfs_getbmap\", XFS_ERRLEVEL_LOW,\n\t\t\t\t\t ip->i_mount);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\n\t\tprealloced = 0;\n\t\tfixlen = 1LL << 32;\n\t} else {\n\t\tif (ip->i_d.di_format != XFS_DINODE_FMT_EXTENTS &&\n\t\t    ip->i_d.di_format != XFS_DINODE_FMT_BTREE &&\n\t\t    ip->i_d.di_format != XFS_DINODE_FMT_LOCAL)\n\t\t\treturn -EINVAL;\n\n\t\tif (xfs_get_extsz_hint(ip) ||\n\t\t    ip->i_d.di_flags & (XFS_DIFLAG_PREALLOC|XFS_DIFLAG_APPEND)){\n\t\t\tprealloced = 1;\n\t\t\tfixlen = mp->m_super->s_maxbytes;\n\t\t} else {\n\t\t\tprealloced = 0;\n\t\t\tfixlen = XFS_ISIZE(ip);\n\t\t}\n\t}\n\n\tif (bmv->bmv_length == -1) {\n\t\tfixlen = XFS_FSB_TO_BB(mp, XFS_B_TO_FSB(mp, fixlen));\n\t\tbmv->bmv_length =\n\t\t\tmax_t(__int64_t, fixlen - bmv->bmv_offset, 0);\n\t} else if (bmv->bmv_length == 0) {\n\t\tbmv->bmv_entries = 0;\n\t\treturn 0;\n\t} else if (bmv->bmv_length < 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tnex = bmv->bmv_count - 1;\n\tif (nex <= 0)\n\t\treturn -EINVAL;\n\tbmvend = bmv->bmv_offset + bmv->bmv_length;\n\n\n\tif (bmv->bmv_count > ULONG_MAX / sizeof(struct getbmapx))\n\t\treturn -ENOMEM;\n\tout = kmem_zalloc_large(bmv->bmv_count * sizeof(struct getbmapx), 0);\n\tif (!out)\n\t\treturn -ENOMEM;\n\n\txfs_ilock(ip, XFS_IOLOCK_SHARED);\n\tif (whichfork == XFS_DATA_FORK) {\n\t\tif (!(iflags & BMV_IF_DELALLOC) &&\n\t\t    (ip->i_delayed_blks || XFS_ISIZE(ip) > ip->i_d.di_size)) {\n\t\t\terror = filemap_write_and_wait(VFS_I(ip)->i_mapping);\n\t\t\tif (error)\n\t\t\t\tgoto out_unlock_iolock;\n\n\t\t\t/*\n\t\t\t * Even after flushing the inode, there can still be\n\t\t\t * delalloc blocks on the inode beyond EOF due to\n\t\t\t * speculative preallocation.  These are not removed\n\t\t\t * until the release function is called or the inode\n\t\t\t * is inactivated.  Hence we cannot assert here that\n\t\t\t * ip->i_delayed_blks == 0.\n\t\t\t */\n\t\t}\n\n\t\tlock = xfs_ilock_data_map_shared(ip);\n\t} else {\n\t\tlock = xfs_ilock_attr_map_shared(ip);\n\t}\n\n\t/*\n\t * Don't let nex be bigger than the number of extents\n\t * we can have assuming alternating holes and real extents.\n\t */\n\tif (nex > XFS_IFORK_NEXTENTS(ip, whichfork) * 2 + 1)\n\t\tnex = XFS_IFORK_NEXTENTS(ip, whichfork) * 2 + 1;\n\n\tbmapi_flags = xfs_bmapi_aflag(whichfork);\n\tif (!(iflags & BMV_IF_PREALLOC))\n\t\tbmapi_flags |= XFS_BMAPI_IGSTATE;\n\n\t/*\n\t * Allocate enough space to handle \"subnex\" maps at a time.\n\t */\n\terror = -ENOMEM;\n\tsubnex = 16;\n\tmap = kmem_alloc(subnex * sizeof(*map), KM_MAYFAIL | KM_NOFS);\n\tif (!map)\n\t\tgoto out_unlock_ilock;\n\n\tbmv->bmv_entries = 0;\n\n\tif (XFS_IFORK_NEXTENTS(ip, whichfork) == 0 &&\n\t    (whichfork == XFS_ATTR_FORK || !(iflags & BMV_IF_DELALLOC))) {\n\t\terror = 0;\n\t\tgoto out_free_map;\n\t}\n\n\tnexleft = nex;\n\n\tdo {\n\t\tnmap = (nexleft > subnex) ? subnex : nexleft;\n\t\terror = xfs_bmapi_read(ip, XFS_BB_TO_FSBT(mp, bmv->bmv_offset),\n\t\t\t\t       XFS_BB_TO_FSB(mp, bmv->bmv_length),\n\t\t\t\t       map, &nmap, bmapi_flags);\n\t\tif (error)\n\t\t\tgoto out_free_map;\n\t\tASSERT(nmap <= subnex);\n\n\t\tfor (i = 0; i < nmap && nexleft && bmv->bmv_length; i++) {\n\t\t\tout[cur_ext].bmv_oflags = 0;\n\t\t\tif (map[i].br_state == XFS_EXT_UNWRITTEN)\n\t\t\t\tout[cur_ext].bmv_oflags |= BMV_OF_PREALLOC;\n\t\t\telse if (map[i].br_startblock == DELAYSTARTBLOCK)\n\t\t\t\tout[cur_ext].bmv_oflags |= BMV_OF_DELALLOC;\n\t\t\tout[cur_ext].bmv_offset =\n\t\t\t\tXFS_FSB_TO_BB(mp, map[i].br_startoff);\n\t\t\tout[cur_ext].bmv_length =\n\t\t\t\tXFS_FSB_TO_BB(mp, map[i].br_blockcount);\n\t\t\tout[cur_ext].bmv_unused1 = 0;\n\t\t\tout[cur_ext].bmv_unused2 = 0;\n\n\t\t\t/*\n\t\t\t * delayed allocation extents that start beyond EOF can\n\t\t\t * occur due to speculative EOF allocation when the\n\t\t\t * delalloc extent is larger than the largest freespace\n\t\t\t * extent at conversion time. These extents cannot be\n\t\t\t * converted by data writeback, so can exist here even\n\t\t\t * if we are not supposed to be finding delalloc\n\t\t\t * extents.\n\t\t\t */\n\t\t\tif (map[i].br_startblock == DELAYSTARTBLOCK &&\n\t\t\t    map[i].br_startoff <= XFS_B_TO_FSB(mp, XFS_ISIZE(ip)))\n\t\t\t\tASSERT((iflags & BMV_IF_DELALLOC) != 0);\n\n                        if (map[i].br_startblock == HOLESTARTBLOCK &&\n\t\t\t    whichfork == XFS_ATTR_FORK) {\n\t\t\t\t/* came to the end of attribute fork */\n\t\t\t\tout[cur_ext].bmv_oflags |= BMV_OF_LAST;\n\t\t\t\tgoto out_free_map;\n\t\t\t}\n\n\t\t\tif (!xfs_getbmapx_fix_eof_hole(ip, &out[cur_ext],\n\t\t\t\t\tprealloced, bmvend,\n\t\t\t\t\tmap[i].br_startblock))\n\t\t\t\tgoto out_free_map;\n\n\t\t\tbmv->bmv_offset =\n\t\t\t\tout[cur_ext].bmv_offset +\n\t\t\t\tout[cur_ext].bmv_length;\n\t\t\tbmv->bmv_length =\n\t\t\t\tmax_t(__int64_t, 0, bmvend - bmv->bmv_offset);\n\n\t\t\t/*\n\t\t\t * In case we don't want to return the hole,\n\t\t\t * don't increase cur_ext so that we can reuse\n\t\t\t * it in the next loop.\n\t\t\t */\n\t\t\tif ((iflags & BMV_IF_NO_HOLES) &&\n\t\t\t    map[i].br_startblock == HOLESTARTBLOCK) {\n\t\t\t\tmemset(&out[cur_ext], 0, sizeof(out[cur_ext]));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnexleft--;\n\t\t\tbmv->bmv_entries++;\n\t\t\tcur_ext++;\n\t\t}\n\t} while (nmap && nexleft && bmv->bmv_length);\n\n out_free_map:\n\tkmem_free(map);\n out_unlock_ilock:\n\txfs_iunlock(ip, lock);\n out_unlock_iolock:\n\txfs_iunlock(ip, XFS_IOLOCK_SHARED);\n\n\tfor (i = 0; i < cur_ext; i++) {\n\t\tint full = 0;\t/* user array is full */\n\n\t\t/* format results & advance arg */\n\t\terror = formatter(&arg, &out[i], &full);\n\t\tif (error || full)\n\t\t\tbreak;\n\t}\n\n\tkmem_free(out);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "out"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "formatter",
          "args": [
            "&arg",
            "&out[i]",
            "&full"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "ip",
            "XFS_IOLOCK_SHARED"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&out[cur_ext]",
            "0",
            "sizeof(out[cur_ext])"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "__int64_t",
            "0",
            "bmvend - bmv->bmv_offset"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_getbmapx_fix_eof_hole",
          "args": [
            "ip",
            "&out[cur_ext]",
            "prealloced",
            "bmvend",
            "map[i].br_startblock"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_getbmapx_fix_eof_hole",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "441-480",
          "snippet": "STATIC int\nxfs_getbmapx_fix_eof_hole(\n\txfs_inode_t\t\t*ip,\t\t/* xfs incore inode pointer */\n\tstruct getbmapx\t\t*out,\t\t/* output structure */\n\tint\t\t\tprealloced,\t/* this is a file with\n\t\t\t\t\t\t * preallocated data space */\n\t__int64_t\t\tend,\t\t/* last block requested */\n\txfs_fsblock_t\t\tstartblock)\n{\n\t__int64_t\t\tfixlen;\n\txfs_mount_t\t\t*mp;\t\t/* file system mount point */\n\txfs_ifork_t\t\t*ifp;\t\t/* inode fork pointer */\n\txfs_extnum_t\t\tlastx;\t\t/* last extent pointer */\n\txfs_fileoff_t\t\tfileblock;\n\n\tif (startblock == HOLESTARTBLOCK) {\n\t\tmp = ip->i_mount;\n\t\tout->bmv_block = -1;\n\t\tfixlen = XFS_FSB_TO_BB(mp, XFS_B_TO_FSB(mp, XFS_ISIZE(ip)));\n\t\tfixlen -= out->bmv_offset;\n\t\tif (prealloced && out->bmv_offset + out->bmv_length == end) {\n\t\t\t/* Came to hole at EOF. Trim it. */\n\t\t\tif (fixlen <= 0)\n\t\t\t\treturn 0;\n\t\t\tout->bmv_length = fixlen;\n\t\t}\n\t} else {\n\t\tif (startblock == DELAYSTARTBLOCK)\n\t\t\tout->bmv_block = -2;\n\t\telse\n\t\t\tout->bmv_block = xfs_fsb_to_db(ip, startblock);\n\t\tfileblock = XFS_BB_TO_FSB(ip->i_mount, out->bmv_offset);\n\t\tifp = XFS_IFORK_PTR(ip, XFS_DATA_FORK);\n\t\tif (xfs_iext_bno_to_ext(ifp, fileblock, &lastx) &&\n\t\t   (lastx == (ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t))-1))\n\t\t\tout->bmv_oflags |= BMV_OF_LAST;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_getbmapx_fix_eof_hole(\n\txfs_inode_t\t\t*ip,\t\t/* xfs incore inode pointer */\n\tstruct getbmapx\t\t*out,\t\t/* output structure */\n\tint\t\t\tprealloced,\t/* this is a file with\n\t\t\t\t\t\t * preallocated data space */\n\t__int64_t\t\tend,\t\t/* last block requested */\n\txfs_fsblock_t\t\tstartblock)\n{\n\t__int64_t\t\tfixlen;\n\txfs_mount_t\t\t*mp;\t\t/* file system mount point */\n\txfs_ifork_t\t\t*ifp;\t\t/* inode fork pointer */\n\txfs_extnum_t\t\tlastx;\t\t/* last extent pointer */\n\txfs_fileoff_t\t\tfileblock;\n\n\tif (startblock == HOLESTARTBLOCK) {\n\t\tmp = ip->i_mount;\n\t\tout->bmv_block = -1;\n\t\tfixlen = XFS_FSB_TO_BB(mp, XFS_B_TO_FSB(mp, XFS_ISIZE(ip)));\n\t\tfixlen -= out->bmv_offset;\n\t\tif (prealloced && out->bmv_offset + out->bmv_length == end) {\n\t\t\t/* Came to hole at EOF. Trim it. */\n\t\t\tif (fixlen <= 0)\n\t\t\t\treturn 0;\n\t\t\tout->bmv_length = fixlen;\n\t\t}\n\t} else {\n\t\tif (startblock == DELAYSTARTBLOCK)\n\t\t\tout->bmv_block = -2;\n\t\telse\n\t\t\tout->bmv_block = xfs_fsb_to_db(ip, startblock);\n\t\tfileblock = XFS_BB_TO_FSB(ip->i_mount, out->bmv_offset);\n\t\tifp = XFS_IFORK_PTR(ip, XFS_DATA_FORK);\n\t\tif (xfs_iext_bno_to_ext(ifp, fileblock, &lastx) &&\n\t\t   (lastx == (ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t))-1))\n\t\t\tout->bmv_oflags |= BMV_OF_LAST;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(iflags & BMV_IF_DELALLOC) != 0"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_B_TO_FSB",
          "args": [
            "mp",
            "XFS_ISIZE(ip)"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ISIZE",
          "args": [
            "ip"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_BB",
          "args": [
            "mp",
            "map[i].br_blockcount"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_BB",
          "args": [
            "mp",
            "map[i].br_startoff"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "nmap <= subnex"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmapi_read",
          "args": [
            "ip",
            "XFS_BB_TO_FSBT(mp, bmv->bmv_offset)",
            "XFS_BB_TO_FSB(mp, bmv->bmv_length)",
            "map",
            "&nmap",
            "bmapi_flags"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmapi_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "4017-4103",
          "snippet": "int\nxfs_bmapi_read(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tstruct xfs_bmbt_irec\t*mval,\n\tint\t\t\t*nmap,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_bmbt_irec\tprev;\n\txfs_fileoff_t\t\tobno;\n\txfs_fileoff_t\t\tend;\n\txfs_extnum_t\t\tlastx;\n\tint\t\t\terror;\n\tint\t\t\teof;\n\tint\t\t\tn = 0;\n\tint\t\t\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(!(flags & ~(XFS_BMAPI_ATTRFORK|XFS_BMAPI_ENTIRE|\n\t\t\t   XFS_BMAPI_IGSTATE)));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED|XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_read\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_blk_mapr);\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(NULL, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got, &prev);\n\tend = bno + len;\n\tobno = bno;\n\n\twhile (bno < end && n < *nmap) {\n\t\t/* Reading past eof, act as though there's a hole up to end. */\n\t\tif (eof)\n\t\t\tgot.br_startoff = end;\n\t\tif (got.br_startoff > bno) {\n\t\t\t/* Reading in a hole.  */\n\t\t\tmval->br_startoff = bno;\n\t\t\tmval->br_startblock = HOLESTARTBLOCK;\n\t\t\tmval->br_blockcount =\n\t\t\t\tXFS_FILBLKS_MIN(len, got.br_startoff - bno);\n\t\t\tmval->br_state = XFS_EXT_NORM;\n\t\t\tbno += mval->br_blockcount;\n\t\t\tlen -= mval->br_blockcount;\n\t\t\tmval++;\n\t\t\tn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* set up the extent map to return. */\n\t\txfs_bmapi_trim_map(mval, &got, &bno, len, obno, end, n, flags);\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/* If we're done, stop now. */\n\t\tif (bno >= end || n >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tif (++lastx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t))\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx), &got);\n\t\telse\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmapi_read(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tstruct xfs_bmbt_irec\t*mval,\n\tint\t\t\t*nmap,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_bmbt_irec\tprev;\n\txfs_fileoff_t\t\tobno;\n\txfs_fileoff_t\t\tend;\n\txfs_extnum_t\t\tlastx;\n\tint\t\t\terror;\n\tint\t\t\teof;\n\tint\t\t\tn = 0;\n\tint\t\t\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(!(flags & ~(XFS_BMAPI_ATTRFORK|XFS_BMAPI_ENTIRE|\n\t\t\t   XFS_BMAPI_IGSTATE)));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED|XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_read\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_blk_mapr);\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(NULL, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got, &prev);\n\tend = bno + len;\n\tobno = bno;\n\n\twhile (bno < end && n < *nmap) {\n\t\t/* Reading past eof, act as though there's a hole up to end. */\n\t\tif (eof)\n\t\t\tgot.br_startoff = end;\n\t\tif (got.br_startoff > bno) {\n\t\t\t/* Reading in a hole.  */\n\t\t\tmval->br_startoff = bno;\n\t\t\tmval->br_startblock = HOLESTARTBLOCK;\n\t\t\tmval->br_blockcount =\n\t\t\t\tXFS_FILBLKS_MIN(len, got.br_startoff - bno);\n\t\t\tmval->br_state = XFS_EXT_NORM;\n\t\t\tbno += mval->br_blockcount;\n\t\t\tlen -= mval->br_blockcount;\n\t\t\tmval++;\n\t\t\tn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* set up the extent map to return. */\n\t\txfs_bmapi_trim_map(mval, &got, &bno, len, obno, end, n, flags);\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/* If we're done, stop now. */\n\t\tif (bno >= end || n >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tif (++lastx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t))\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx), &got);\n\t\telse\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BB_TO_FSB",
          "args": [
            "mp",
            "bmv->bmv_length"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BB_TO_FSBT",
          "args": [
            "mp",
            "bmv->bmv_offset"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_NEXTENTS",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_alloc",
          "args": [
            "subnex * sizeof(*map)",
            "KM_MAYFAIL | KM_NOFS"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "45-62",
          "snippet": "void *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmapi_aflag",
          "args": [
            "whichfork"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmapi_aflag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.h",
          "lines": "122-125",
          "snippet": "static inline int xfs_bmapi_aflag(int w)\n{\n\treturn (w == XFS_ATTR_FORK ? XFS_BMAPI_ATTRFORK : 0);\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_BMAPI_ATTRFORK\t0x004\t/* use attribute fork not data */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_BMAPI_ATTRFORK\t0x004\t/* use attribute fork not data */\n\nstatic inline int xfs_bmapi_aflag(int w)\n{\n\treturn (w == XFS_ATTR_FORK ? XFS_BMAPI_ATTRFORK : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_NEXTENTS",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_NEXTENTS",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_ilock_attr_map_shared",
          "args": [
            "ip"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_attr_map_shared",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "106-117",
          "snippet": "uint\nxfs_ilock_attr_map_shared(\n\tstruct xfs_inode\t*ip)\n{\n\tuint\t\t\tlock_mode = XFS_ILOCK_SHARED;\n\n\tif (ip->i_d.di_aformat == XFS_DINODE_FMT_BTREE &&\n\t    (ip->i_afp->if_flags & XFS_IFEXTENTS) == 0)\n\t\tlock_mode = XFS_ILOCK_EXCL;\n\txfs_ilock(ip, lock_mode);\n\treturn lock_mode;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nuint\nxfs_ilock_attr_map_shared(\n\tstruct xfs_inode\t*ip)\n{\n\tuint\t\t\tlock_mode = XFS_ILOCK_SHARED;\n\n\tif (ip->i_d.di_aformat == XFS_DINODE_FMT_BTREE &&\n\t    (ip->i_afp->if_flags & XFS_IFEXTENTS) == 0)\n\t\tlock_mode = XFS_ILOCK_EXCL;\n\txfs_ilock(ip, lock_mode);\n\treturn lock_mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock_data_map_shared",
          "args": [
            "ip"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_data_map_shared",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "93-104",
          "snippet": "uint\nxfs_ilock_data_map_shared(\n\tstruct xfs_inode\t*ip)\n{\n\tuint\t\t\tlock_mode = XFS_ILOCK_SHARED;\n\n\tif (ip->i_d.di_format == XFS_DINODE_FMT_BTREE &&\n\t    (ip->i_df.if_flags & XFS_IFEXTENTS) == 0)\n\t\tlock_mode = XFS_ILOCK_EXCL;\n\txfs_ilock(ip, lock_mode);\n\treturn lock_mode;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nuint\nxfs_ilock_data_map_shared(\n\tstruct xfs_inode\t*ip)\n{\n\tuint\t\t\tlock_mode = XFS_ILOCK_SHARED;\n\n\tif (ip->i_d.di_format == XFS_DINODE_FMT_BTREE &&\n\t    (ip->i_df.if_flags & XFS_IFEXTENTS) == 0)\n\t\tlock_mode = XFS_ILOCK_EXCL;\n\txfs_ilock(ip, lock_mode);\n\treturn lock_mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait",
          "args": [
            "VFS_I(ip)->i_mapping"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "ip"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "78-81",
          "snippet": "static inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "ip",
            "XFS_IOLOCK_SHARED"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_zalloc_large",
          "args": [
            "bmv->bmv_count * sizeof(struct getbmapx)",
            "0"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zalloc_large",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "64-92",
          "snippet": "void *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "__int64_t",
            "fixlen - bmv->bmv_offset",
            "0"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_BB",
          "args": [
            "mp",
            "XFS_B_TO_FSB(mp, fixlen)"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_B_TO_FSB",
          "args": [
            "mp",
            "fixlen"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_get_extsz_hint",
          "args": [
            "ip"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_get_extsz_hint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "67-76",
          "snippet": "xfs_extlen_t\nxfs_get_extsz_hint(\n\tstruct xfs_inode\t*ip)\n{\n\tif ((ip->i_d.di_flags & XFS_DIFLAG_EXTSIZE) && ip->i_d.di_extsize)\n\t\treturn ip->i_d.di_extsize;\n\tif (XFS_IS_REALTIME_INODE(ip))\n\t\treturn ip->i_mount->m_sb.sb_rextsize;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_extlen_t\nxfs_get_extsz_hint(\n\tstruct xfs_inode\t*ip)\n{\n\tif ((ip->i_d.di_flags & XFS_DIFLAG_EXTSIZE) && ip->i_d.di_extsize)\n\t\treturn ip->i_d.di_extsize;\n\tif (XFS_IS_REALTIME_INODE(ip))\n\t\treturn ip->i_mount->m_sb.sb_rextsize;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_ERROR_REPORT",
          "args": [
            "\"xfs_getbmap\"",
            "XFS_ERRLEVEL_LOW",
            "ip->i_mount"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ip->i_d.di_aformat != 0 &&\n\t\t\t   ip->i_d.di_aformat != XFS_DINODE_FMT_EXTENTS"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_Q",
          "args": [
            "ip"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error code */\nxfs_getbmap(\n\txfs_inode_t\t\t*ip,\n\tstruct getbmapx\t\t*bmv,\t\t/* user bmap structure */\n\txfs_bmap_format_t\tformatter,\t/* format to user */\n\tvoid\t\t\t*arg)\t\t/* formatter arg */\n{\n\t__int64_t\t\tbmvend;\t\t/* last block requested */\n\tint\t\t\terror = 0;\t/* return value */\n\t__int64_t\t\tfixlen;\t\t/* length for -1 case */\n\tint\t\t\ti;\t\t/* extent number */\n\tint\t\t\tlock;\t\t/* lock state */\n\txfs_bmbt_irec_t\t\t*map;\t\t/* buffer for user's data */\n\txfs_mount_t\t\t*mp;\t\t/* file system mount point */\n\tint\t\t\tnex;\t\t/* # of user extents can do */\n\tint\t\t\tnexleft;\t/* # of user extents left */\n\tint\t\t\tsubnex;\t\t/* # of bmapi's can do */\n\tint\t\t\tnmap;\t\t/* number of map entries */\n\tstruct getbmapx\t\t*out;\t\t/* output structure */\n\tint\t\t\twhichfork;\t/* data or attr fork */\n\tint\t\t\tprealloced;\t/* this is a file with\n\t\t\t\t\t\t * preallocated data space */\n\tint\t\t\tiflags;\t\t/* interface flags */\n\tint\t\t\tbmapi_flags;\t/* flags for xfs_bmapi */\n\tint\t\t\tcur_ext = 0;\n\n\tmp = ip->i_mount;\n\tiflags = bmv->bmv_iflags;\n\twhichfork = iflags & BMV_IF_ATTRFORK ? XFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tif (whichfork == XFS_ATTR_FORK) {\n\t\tif (XFS_IFORK_Q(ip)) {\n\t\t\tif (ip->i_d.di_aformat != XFS_DINODE_FMT_EXTENTS &&\n\t\t\t    ip->i_d.di_aformat != XFS_DINODE_FMT_BTREE &&\n\t\t\t    ip->i_d.di_aformat != XFS_DINODE_FMT_LOCAL)\n\t\t\t\treturn -EINVAL;\n\t\t} else if (unlikely(\n\t\t\t   ip->i_d.di_aformat != 0 &&\n\t\t\t   ip->i_d.di_aformat != XFS_DINODE_FMT_EXTENTS)) {\n\t\t\tXFS_ERROR_REPORT(\"xfs_getbmap\", XFS_ERRLEVEL_LOW,\n\t\t\t\t\t ip->i_mount);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\n\t\tprealloced = 0;\n\t\tfixlen = 1LL << 32;\n\t} else {\n\t\tif (ip->i_d.di_format != XFS_DINODE_FMT_EXTENTS &&\n\t\t    ip->i_d.di_format != XFS_DINODE_FMT_BTREE &&\n\t\t    ip->i_d.di_format != XFS_DINODE_FMT_LOCAL)\n\t\t\treturn -EINVAL;\n\n\t\tif (xfs_get_extsz_hint(ip) ||\n\t\t    ip->i_d.di_flags & (XFS_DIFLAG_PREALLOC|XFS_DIFLAG_APPEND)){\n\t\t\tprealloced = 1;\n\t\t\tfixlen = mp->m_super->s_maxbytes;\n\t\t} else {\n\t\t\tprealloced = 0;\n\t\t\tfixlen = XFS_ISIZE(ip);\n\t\t}\n\t}\n\n\tif (bmv->bmv_length == -1) {\n\t\tfixlen = XFS_FSB_TO_BB(mp, XFS_B_TO_FSB(mp, fixlen));\n\t\tbmv->bmv_length =\n\t\t\tmax_t(__int64_t, fixlen - bmv->bmv_offset, 0);\n\t} else if (bmv->bmv_length == 0) {\n\t\tbmv->bmv_entries = 0;\n\t\treturn 0;\n\t} else if (bmv->bmv_length < 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tnex = bmv->bmv_count - 1;\n\tif (nex <= 0)\n\t\treturn -EINVAL;\n\tbmvend = bmv->bmv_offset + bmv->bmv_length;\n\n\n\tif (bmv->bmv_count > ULONG_MAX / sizeof(struct getbmapx))\n\t\treturn -ENOMEM;\n\tout = kmem_zalloc_large(bmv->bmv_count * sizeof(struct getbmapx), 0);\n\tif (!out)\n\t\treturn -ENOMEM;\n\n\txfs_ilock(ip, XFS_IOLOCK_SHARED);\n\tif (whichfork == XFS_DATA_FORK) {\n\t\tif (!(iflags & BMV_IF_DELALLOC) &&\n\t\t    (ip->i_delayed_blks || XFS_ISIZE(ip) > ip->i_d.di_size)) {\n\t\t\terror = filemap_write_and_wait(VFS_I(ip)->i_mapping);\n\t\t\tif (error)\n\t\t\t\tgoto out_unlock_iolock;\n\n\t\t\t/*\n\t\t\t * Even after flushing the inode, there can still be\n\t\t\t * delalloc blocks on the inode beyond EOF due to\n\t\t\t * speculative preallocation.  These are not removed\n\t\t\t * until the release function is called or the inode\n\t\t\t * is inactivated.  Hence we cannot assert here that\n\t\t\t * ip->i_delayed_blks == 0.\n\t\t\t */\n\t\t}\n\n\t\tlock = xfs_ilock_data_map_shared(ip);\n\t} else {\n\t\tlock = xfs_ilock_attr_map_shared(ip);\n\t}\n\n\t/*\n\t * Don't let nex be bigger than the number of extents\n\t * we can have assuming alternating holes and real extents.\n\t */\n\tif (nex > XFS_IFORK_NEXTENTS(ip, whichfork) * 2 + 1)\n\t\tnex = XFS_IFORK_NEXTENTS(ip, whichfork) * 2 + 1;\n\n\tbmapi_flags = xfs_bmapi_aflag(whichfork);\n\tif (!(iflags & BMV_IF_PREALLOC))\n\t\tbmapi_flags |= XFS_BMAPI_IGSTATE;\n\n\t/*\n\t * Allocate enough space to handle \"subnex\" maps at a time.\n\t */\n\terror = -ENOMEM;\n\tsubnex = 16;\n\tmap = kmem_alloc(subnex * sizeof(*map), KM_MAYFAIL | KM_NOFS);\n\tif (!map)\n\t\tgoto out_unlock_ilock;\n\n\tbmv->bmv_entries = 0;\n\n\tif (XFS_IFORK_NEXTENTS(ip, whichfork) == 0 &&\n\t    (whichfork == XFS_ATTR_FORK || !(iflags & BMV_IF_DELALLOC))) {\n\t\terror = 0;\n\t\tgoto out_free_map;\n\t}\n\n\tnexleft = nex;\n\n\tdo {\n\t\tnmap = (nexleft > subnex) ? subnex : nexleft;\n\t\terror = xfs_bmapi_read(ip, XFS_BB_TO_FSBT(mp, bmv->bmv_offset),\n\t\t\t\t       XFS_BB_TO_FSB(mp, bmv->bmv_length),\n\t\t\t\t       map, &nmap, bmapi_flags);\n\t\tif (error)\n\t\t\tgoto out_free_map;\n\t\tASSERT(nmap <= subnex);\n\n\t\tfor (i = 0; i < nmap && nexleft && bmv->bmv_length; i++) {\n\t\t\tout[cur_ext].bmv_oflags = 0;\n\t\t\tif (map[i].br_state == XFS_EXT_UNWRITTEN)\n\t\t\t\tout[cur_ext].bmv_oflags |= BMV_OF_PREALLOC;\n\t\t\telse if (map[i].br_startblock == DELAYSTARTBLOCK)\n\t\t\t\tout[cur_ext].bmv_oflags |= BMV_OF_DELALLOC;\n\t\t\tout[cur_ext].bmv_offset =\n\t\t\t\tXFS_FSB_TO_BB(mp, map[i].br_startoff);\n\t\t\tout[cur_ext].bmv_length =\n\t\t\t\tXFS_FSB_TO_BB(mp, map[i].br_blockcount);\n\t\t\tout[cur_ext].bmv_unused1 = 0;\n\t\t\tout[cur_ext].bmv_unused2 = 0;\n\n\t\t\t/*\n\t\t\t * delayed allocation extents that start beyond EOF can\n\t\t\t * occur due to speculative EOF allocation when the\n\t\t\t * delalloc extent is larger than the largest freespace\n\t\t\t * extent at conversion time. These extents cannot be\n\t\t\t * converted by data writeback, so can exist here even\n\t\t\t * if we are not supposed to be finding delalloc\n\t\t\t * extents.\n\t\t\t */\n\t\t\tif (map[i].br_startblock == DELAYSTARTBLOCK &&\n\t\t\t    map[i].br_startoff <= XFS_B_TO_FSB(mp, XFS_ISIZE(ip)))\n\t\t\t\tASSERT((iflags & BMV_IF_DELALLOC) != 0);\n\n                        if (map[i].br_startblock == HOLESTARTBLOCK &&\n\t\t\t    whichfork == XFS_ATTR_FORK) {\n\t\t\t\t/* came to the end of attribute fork */\n\t\t\t\tout[cur_ext].bmv_oflags |= BMV_OF_LAST;\n\t\t\t\tgoto out_free_map;\n\t\t\t}\n\n\t\t\tif (!xfs_getbmapx_fix_eof_hole(ip, &out[cur_ext],\n\t\t\t\t\tprealloced, bmvend,\n\t\t\t\t\tmap[i].br_startblock))\n\t\t\t\tgoto out_free_map;\n\n\t\t\tbmv->bmv_offset =\n\t\t\t\tout[cur_ext].bmv_offset +\n\t\t\t\tout[cur_ext].bmv_length;\n\t\t\tbmv->bmv_length =\n\t\t\t\tmax_t(__int64_t, 0, bmvend - bmv->bmv_offset);\n\n\t\t\t/*\n\t\t\t * In case we don't want to return the hole,\n\t\t\t * don't increase cur_ext so that we can reuse\n\t\t\t * it in the next loop.\n\t\t\t */\n\t\t\tif ((iflags & BMV_IF_NO_HOLES) &&\n\t\t\t    map[i].br_startblock == HOLESTARTBLOCK) {\n\t\t\t\tmemset(&out[cur_ext], 0, sizeof(out[cur_ext]));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnexleft--;\n\t\t\tbmv->bmv_entries++;\n\t\t\tcur_ext++;\n\t\t}\n\t} while (nmap && nexleft && bmv->bmv_length);\n\n out_free_map:\n\tkmem_free(map);\n out_unlock_ilock:\n\txfs_iunlock(ip, lock);\n out_unlock_iolock:\n\txfs_iunlock(ip, XFS_IOLOCK_SHARED);\n\n\tfor (i = 0; i < cur_ext; i++) {\n\t\tint full = 0;\t/* user array is full */\n\n\t\t/* format results & advance arg */\n\t\terror = formatter(&arg, &out[i], &full);\n\t\tif (error || full)\n\t\t\tbreak;\n\t}\n\n\tkmem_free(out);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_getbmapx_fix_eof_hole",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
    "lines": "441-480",
    "snippet": "STATIC int\nxfs_getbmapx_fix_eof_hole(\n\txfs_inode_t\t\t*ip,\t\t/* xfs incore inode pointer */\n\tstruct getbmapx\t\t*out,\t\t/* output structure */\n\tint\t\t\tprealloced,\t/* this is a file with\n\t\t\t\t\t\t * preallocated data space */\n\t__int64_t\t\tend,\t\t/* last block requested */\n\txfs_fsblock_t\t\tstartblock)\n{\n\t__int64_t\t\tfixlen;\n\txfs_mount_t\t\t*mp;\t\t/* file system mount point */\n\txfs_ifork_t\t\t*ifp;\t\t/* inode fork pointer */\n\txfs_extnum_t\t\tlastx;\t\t/* last extent pointer */\n\txfs_fileoff_t\t\tfileblock;\n\n\tif (startblock == HOLESTARTBLOCK) {\n\t\tmp = ip->i_mount;\n\t\tout->bmv_block = -1;\n\t\tfixlen = XFS_FSB_TO_BB(mp, XFS_B_TO_FSB(mp, XFS_ISIZE(ip)));\n\t\tfixlen -= out->bmv_offset;\n\t\tif (prealloced && out->bmv_offset + out->bmv_length == end) {\n\t\t\t/* Came to hole at EOF. Trim it. */\n\t\t\tif (fixlen <= 0)\n\t\t\t\treturn 0;\n\t\t\tout->bmv_length = fixlen;\n\t\t}\n\t} else {\n\t\tif (startblock == DELAYSTARTBLOCK)\n\t\t\tout->bmv_block = -2;\n\t\telse\n\t\t\tout->bmv_block = xfs_fsb_to_db(ip, startblock);\n\t\tfileblock = XFS_BB_TO_FSB(ip->i_mount, out->bmv_offset);\n\t\tifp = XFS_IFORK_PTR(ip, XFS_DATA_FORK);\n\t\tif (xfs_iext_bno_to_ext(ifp, fileblock, &lastx) &&\n\t\t   (lastx == (ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t))-1))\n\t\t\tout->bmv_oflags |= BMV_OF_LAST;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_iext_bno_to_ext",
          "args": [
            "ifp",
            "fileblock",
            "&lastx"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_bno_to_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "1528-1592",
          "snippet": "xfs_bmbt_rec_host_t *\t\t\t/* pointer to found extent record */\nxfs_iext_bno_to_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_fileoff_t\tbno,\t\t/* block number to search for */\n\txfs_extnum_t\t*idxp)\t\t/* index of target extent */\n{\n\txfs_bmbt_rec_host_t *base;\t/* pointer to first extent */\n\txfs_filblks_t\tblockcount = 0;\t/* number of blocks in extent */\n\txfs_bmbt_rec_host_t *ep = NULL;\t/* pointer to target extent */\n\txfs_ext_irec_t\t*erp = NULL;\t/* indirection array pointer */\n\tint\t\thigh;\t\t/* upper boundary in search */\n\txfs_extnum_t\tidx = 0;\t/* index of target extent */\n\tint\t\tlow;\t\t/* lower boundary in search */\n\txfs_extnum_t\tnextents;\t/* number of file extents */\n\txfs_fileoff_t\tstartoff = 0;\t/* start offset of extent */\n\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tif (nextents == 0) {\n\t\t*idxp = 0;\n\t\treturn NULL;\n\t}\n\tlow = 0;\n\tif (ifp->if_flags & XFS_IFEXTIREC) {\n\t\t/* Find target extent list */\n\t\tint\terp_idx = 0;\n\t\terp = xfs_iext_bno_to_irec(ifp, bno, &erp_idx);\n\t\tbase = erp->er_extbuf;\n\t\thigh = erp->er_extcount - 1;\n\t} else {\n\t\tbase = ifp->if_u1.if_extents;\n\t\thigh = nextents - 1;\n\t}\n\t/* Binary search extent records */\n\twhile (low <= high) {\n\t\tidx = (low + high) >> 1;\n\t\tep = base + idx;\n\t\tstartoff = xfs_bmbt_get_startoff(ep);\n\t\tblockcount = xfs_bmbt_get_blockcount(ep);\n\t\tif (bno < startoff) {\n\t\t\thigh = idx - 1;\n\t\t} else if (bno >= startoff + blockcount) {\n\t\t\tlow = idx + 1;\n\t\t} else {\n\t\t\t/* Convert back to file-based extent index */\n\t\t\tif (ifp->if_flags & XFS_IFEXTIREC) {\n\t\t\t\tidx += erp->er_extoff;\n\t\t\t}\n\t\t\t*idxp = idx;\n\t\t\treturn ep;\n\t\t}\n\t}\n\t/* Convert back to file-based extent index */\n\tif (ifp->if_flags & XFS_IFEXTIREC) {\n\t\tidx += erp->er_extoff;\n\t}\n\tif (bno >= startoff + blockcount) {\n\t\tif (++idx == nextents) {\n\t\t\tep = NULL;\n\t\t} else {\n\t\t\tep = xfs_iext_get_ext(ifp, idx);\n\t\t}\n\t}\n\t*idxp = idx;\n\treturn ep;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_bmbt_rec_host_t *\t\t\t/* pointer to found extent record */\nxfs_iext_bno_to_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_fileoff_t\tbno,\t\t/* block number to search for */\n\txfs_extnum_t\t*idxp)\t\t/* index of target extent */\n{\n\txfs_bmbt_rec_host_t *base;\t/* pointer to first extent */\n\txfs_filblks_t\tblockcount = 0;\t/* number of blocks in extent */\n\txfs_bmbt_rec_host_t *ep = NULL;\t/* pointer to target extent */\n\txfs_ext_irec_t\t*erp = NULL;\t/* indirection array pointer */\n\tint\t\thigh;\t\t/* upper boundary in search */\n\txfs_extnum_t\tidx = 0;\t/* index of target extent */\n\tint\t\tlow;\t\t/* lower boundary in search */\n\txfs_extnum_t\tnextents;\t/* number of file extents */\n\txfs_fileoff_t\tstartoff = 0;\t/* start offset of extent */\n\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tif (nextents == 0) {\n\t\t*idxp = 0;\n\t\treturn NULL;\n\t}\n\tlow = 0;\n\tif (ifp->if_flags & XFS_IFEXTIREC) {\n\t\t/* Find target extent list */\n\t\tint\terp_idx = 0;\n\t\terp = xfs_iext_bno_to_irec(ifp, bno, &erp_idx);\n\t\tbase = erp->er_extbuf;\n\t\thigh = erp->er_extcount - 1;\n\t} else {\n\t\tbase = ifp->if_u1.if_extents;\n\t\thigh = nextents - 1;\n\t}\n\t/* Binary search extent records */\n\twhile (low <= high) {\n\t\tidx = (low + high) >> 1;\n\t\tep = base + idx;\n\t\tstartoff = xfs_bmbt_get_startoff(ep);\n\t\tblockcount = xfs_bmbt_get_blockcount(ep);\n\t\tif (bno < startoff) {\n\t\t\thigh = idx - 1;\n\t\t} else if (bno >= startoff + blockcount) {\n\t\t\tlow = idx + 1;\n\t\t} else {\n\t\t\t/* Convert back to file-based extent index */\n\t\t\tif (ifp->if_flags & XFS_IFEXTIREC) {\n\t\t\t\tidx += erp->er_extoff;\n\t\t\t}\n\t\t\t*idxp = idx;\n\t\t\treturn ep;\n\t\t}\n\t}\n\t/* Convert back to file-based extent index */\n\tif (ifp->if_flags & XFS_IFEXTIREC) {\n\t\tidx += erp->er_extoff;\n\t}\n\tif (bno >= startoff + blockcount) {\n\t\tif (++idx == nextents) {\n\t\t\tep = NULL;\n\t\t} else {\n\t\t\tep = xfs_iext_get_ext(ifp, idx);\n\t\t}\n\t}\n\t*idxp = idx;\n\treturn ep;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_PTR",
          "args": [
            "ip",
            "XFS_DATA_FORK"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BB_TO_FSB",
          "args": [
            "ip->i_mount",
            "out->bmv_offset"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_fsb_to_db",
          "args": [
            "ip",
            "startblock"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_fsb_to_db",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "51-57",
          "snippet": "xfs_daddr_t\nxfs_fsb_to_db(struct xfs_inode *ip, xfs_fsblock_t fsb)\n{\n\treturn (XFS_IS_REALTIME_INODE(ip) ? \\\n\t\t (xfs_daddr_t)XFS_FSB_TO_BB((ip)->i_mount, (fsb)) : \\\n\t\t XFS_FSB_TO_DADDR((ip)->i_mount, (fsb)));\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_daddr_t\nxfs_fsb_to_db(struct xfs_inode *ip, xfs_fsblock_t fsb)\n{\n\treturn (XFS_IS_REALTIME_INODE(ip) ? \\\n\t\t (xfs_daddr_t)XFS_FSB_TO_BB((ip)->i_mount, (fsb)) : \\\n\t\t XFS_FSB_TO_DADDR((ip)->i_mount, (fsb)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_BB",
          "args": [
            "mp",
            "XFS_B_TO_FSB(mp, XFS_ISIZE(ip))"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_B_TO_FSB",
          "args": [
            "mp",
            "XFS_ISIZE(ip)"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ISIZE",
          "args": [
            "ip"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_getbmapx_fix_eof_hole(\n\txfs_inode_t\t\t*ip,\t\t/* xfs incore inode pointer */\n\tstruct getbmapx\t\t*out,\t\t/* output structure */\n\tint\t\t\tprealloced,\t/* this is a file with\n\t\t\t\t\t\t * preallocated data space */\n\t__int64_t\t\tend,\t\t/* last block requested */\n\txfs_fsblock_t\t\tstartblock)\n{\n\t__int64_t\t\tfixlen;\n\txfs_mount_t\t\t*mp;\t\t/* file system mount point */\n\txfs_ifork_t\t\t*ifp;\t\t/* inode fork pointer */\n\txfs_extnum_t\t\tlastx;\t\t/* last extent pointer */\n\txfs_fileoff_t\t\tfileblock;\n\n\tif (startblock == HOLESTARTBLOCK) {\n\t\tmp = ip->i_mount;\n\t\tout->bmv_block = -1;\n\t\tfixlen = XFS_FSB_TO_BB(mp, XFS_B_TO_FSB(mp, XFS_ISIZE(ip)));\n\t\tfixlen -= out->bmv_offset;\n\t\tif (prealloced && out->bmv_offset + out->bmv_length == end) {\n\t\t\t/* Came to hole at EOF. Trim it. */\n\t\t\tif (fixlen <= 0)\n\t\t\t\treturn 0;\n\t\t\tout->bmv_length = fixlen;\n\t\t}\n\t} else {\n\t\tif (startblock == DELAYSTARTBLOCK)\n\t\t\tout->bmv_block = -2;\n\t\telse\n\t\t\tout->bmv_block = xfs_fsb_to_db(ip, startblock);\n\t\tfileblock = XFS_BB_TO_FSB(ip->i_mount, out->bmv_offset);\n\t\tifp = XFS_IFORK_PTR(ip, XFS_DATA_FORK);\n\t\tif (xfs_iext_bno_to_ext(ifp, fileblock, &lastx) &&\n\t\t   (lastx == (ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t))-1))\n\t\t\tout->bmv_oflags |= BMV_OF_LAST;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "xfs_bmap_count_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
    "lines": "393-436",
    "snippet": "int\t\t\t\t\t\t/* error */\nxfs_bmap_count_blocks(\n\txfs_trans_t\t\t*tp,\t\t/* transaction pointer */\n\txfs_inode_t\t\t*ip,\t\t/* incore inode */\n\tint\t\t\twhichfork,\t/* data or attr fork */\n\tint\t\t\t*count)\t\t/* out: count of blocks */\n{\n\tstruct xfs_btree_block\t*block;\t/* current btree block */\n\txfs_fsblock_t\t\tbno;\t/* block # of \"block\" */\n\txfs_ifork_t\t\t*ifp;\t/* fork structure */\n\tint\t\t\tlevel;\t/* btree level, for checking */\n\txfs_mount_t\t\t*mp;\t/* file system mount structure */\n\t__be64\t\t\t*pp;\t/* pointer to block address */\n\n\tbno = NULLFSBLOCK;\n\tmp = ip->i_mount;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif ( XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS ) {\n\t\txfs_bmap_count_leaves(ifp, 0,\n\t\t\tifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t),\n\t\t\tcount);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Root level must use BMAP_BROOT_PTR_ADDR macro to get ptr out.\n\t */\n\tblock = ifp->if_broot;\n\tlevel = be16_to_cpu(block->bb_level);\n\tASSERT(level > 0);\n\tpp = XFS_BMAP_BROOT_PTR_ADDR(mp, block, 1, ifp->if_broot_bytes);\n\tbno = be64_to_cpu(*pp);\n\tASSERT(bno != NULLFSBLOCK);\n\tASSERT(XFS_FSB_TO_AGNO(mp, bno) < mp->m_sb.sb_agcount);\n\tASSERT(XFS_FSB_TO_AGBNO(mp, bno) < mp->m_sb.sb_agblocks);\n\n\tif (unlikely(xfs_bmap_count_tree(mp, tp, ifp, bno, level, count) < 0)) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmap_count_blocks(2)\", XFS_ERRLEVEL_LOW,\n\t\t\t\t mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_ERROR_REPORT",
          "args": [
            "\"xfs_bmap_count_blocks(2)\"",
            "XFS_ERRLEVEL_LOW",
            "mp"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "xfs_bmap_count_tree(mp, tp, ifp, bno, level, count) < 0"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmap_count_tree",
          "args": [
            "mp",
            "tp",
            "ifp",
            "bno",
            "level",
            "count"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_count_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "317-388",
          "snippet": "STATIC int                                     /* error */\nxfs_bmap_count_tree(\n\txfs_mount_t     *mp,            /* file system mount point */\n\txfs_trans_t     *tp,            /* transaction pointer */\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_fsblock_t   blockno,\t/* file system block number */\n\tint             levelin,\t/* level in btree */\n\tint\t\t*count)\t\t/* Count of blocks */\n{\n\tint\t\t\terror;\n\txfs_buf_t\t\t*bp, *nbp;\n\tint\t\t\tlevel = levelin;\n\t__be64\t\t\t*pp;\n\txfs_fsblock_t           bno = blockno;\n\txfs_fsblock_t\t\tnextbno;\n\tstruct xfs_btree_block\t*block, *nextblock;\n\tint\t\t\tnumrecs;\n\n\terror = xfs_btree_read_bufl(mp, tp, bno, 0, &bp, XFS_BMAP_BTREE_REF,\n\t\t\t\t\t\t&xfs_bmbt_buf_ops);\n\tif (error)\n\t\treturn error;\n\t*count += 1;\n\tblock = XFS_BUF_TO_BLOCK(bp);\n\n\tif (--level) {\n\t\t/* Not at node above leaves, count this level of nodes */\n\t\tnextbno = be64_to_cpu(block->bb_u.l.bb_rightsib);\n\t\twhile (nextbno != NULLFSBLOCK) {\n\t\t\terror = xfs_btree_read_bufl(mp, tp, nextbno, 0, &nbp,\n\t\t\t\t\t\tXFS_BMAP_BTREE_REF,\n\t\t\t\t\t\t&xfs_bmbt_buf_ops);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\t*count += 1;\n\t\t\tnextblock = XFS_BUF_TO_BLOCK(nbp);\n\t\t\tnextbno = be64_to_cpu(nextblock->bb_u.l.bb_rightsib);\n\t\t\txfs_trans_brelse(tp, nbp);\n\t\t}\n\n\t\t/* Dive to the next level */\n\t\tpp = XFS_BMBT_PTR_ADDR(mp, block, 1, mp->m_bmap_dmxr[1]);\n\t\tbno = be64_to_cpu(*pp);\n\t\tif (unlikely((error =\n\t\t     xfs_bmap_count_tree(mp, tp, ifp, bno, level, count)) < 0)) {\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\tXFS_ERROR_REPORT(\"xfs_bmap_count_tree(1)\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\txfs_trans_brelse(tp, bp);\n\t} else {\n\t\t/* count all level 1 nodes and their leaves */\n\t\tfor (;;) {\n\t\t\tnextbno = be64_to_cpu(block->bb_u.l.bb_rightsib);\n\t\t\tnumrecs = be16_to_cpu(block->bb_numrecs);\n\t\t\txfs_bmap_disk_count_leaves(mp, block, numrecs, count);\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\tif (nextbno == NULLFSBLOCK)\n\t\t\t\tbreak;\n\t\t\tbno = nextbno;\n\t\t\terror = xfs_btree_read_bufl(mp, tp, bno, 0, &bp,\n\t\t\t\t\t\tXFS_BMAP_BTREE_REF,\n\t\t\t\t\t\t&xfs_bmbt_buf_ops);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\t*count += 1;\n\t\t\tblock = XFS_BUF_TO_BLOCK(bp);\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int                                     /* error */\nxfs_bmap_count_tree(\n\txfs_mount_t     *mp,            /* file system mount point */\n\txfs_trans_t     *tp,            /* transaction pointer */\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_fsblock_t   blockno,\t/* file system block number */\n\tint             levelin,\t/* level in btree */\n\tint\t\t*count)\t\t/* Count of blocks */\n{\n\tint\t\t\terror;\n\txfs_buf_t\t\t*bp, *nbp;\n\tint\t\t\tlevel = levelin;\n\t__be64\t\t\t*pp;\n\txfs_fsblock_t           bno = blockno;\n\txfs_fsblock_t\t\tnextbno;\n\tstruct xfs_btree_block\t*block, *nextblock;\n\tint\t\t\tnumrecs;\n\n\terror = xfs_btree_read_bufl(mp, tp, bno, 0, &bp, XFS_BMAP_BTREE_REF,\n\t\t\t\t\t\t&xfs_bmbt_buf_ops);\n\tif (error)\n\t\treturn error;\n\t*count += 1;\n\tblock = XFS_BUF_TO_BLOCK(bp);\n\n\tif (--level) {\n\t\t/* Not at node above leaves, count this level of nodes */\n\t\tnextbno = be64_to_cpu(block->bb_u.l.bb_rightsib);\n\t\twhile (nextbno != NULLFSBLOCK) {\n\t\t\terror = xfs_btree_read_bufl(mp, tp, nextbno, 0, &nbp,\n\t\t\t\t\t\tXFS_BMAP_BTREE_REF,\n\t\t\t\t\t\t&xfs_bmbt_buf_ops);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\t*count += 1;\n\t\t\tnextblock = XFS_BUF_TO_BLOCK(nbp);\n\t\t\tnextbno = be64_to_cpu(nextblock->bb_u.l.bb_rightsib);\n\t\t\txfs_trans_brelse(tp, nbp);\n\t\t}\n\n\t\t/* Dive to the next level */\n\t\tpp = XFS_BMBT_PTR_ADDR(mp, block, 1, mp->m_bmap_dmxr[1]);\n\t\tbno = be64_to_cpu(*pp);\n\t\tif (unlikely((error =\n\t\t     xfs_bmap_count_tree(mp, tp, ifp, bno, level, count)) < 0)) {\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\tXFS_ERROR_REPORT(\"xfs_bmap_count_tree(1)\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\txfs_trans_brelse(tp, bp);\n\t} else {\n\t\t/* count all level 1 nodes and their leaves */\n\t\tfor (;;) {\n\t\t\tnextbno = be64_to_cpu(block->bb_u.l.bb_rightsib);\n\t\t\tnumrecs = be16_to_cpu(block->bb_numrecs);\n\t\t\txfs_bmap_disk_count_leaves(mp, block, numrecs, count);\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\tif (nextbno == NULLFSBLOCK)\n\t\t\t\tbreak;\n\t\t\tbno = nextbno;\n\t\t\terror = xfs_btree_read_bufl(mp, tp, bno, 0, &bp,\n\t\t\t\t\t\tXFS_BMAP_BTREE_REF,\n\t\t\t\t\t\t&xfs_bmbt_buf_ops);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\t*count += 1;\n\t\t\tblock = XFS_BUF_TO_BLOCK(bp);\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_FSB_TO_AGBNO(mp, bno) < mp->m_sb.sb_agblocks"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_AGBNO",
          "args": [
            "mp",
            "bno"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_FSB_TO_AGNO(mp, bno) < mp->m_sb.sb_agcount"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_AGNO",
          "args": [
            "mp",
            "bno"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bno != NULLFSBLOCK"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "*pp"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BMAP_BROOT_PTR_ADDR",
          "args": [
            "mp",
            "block",
            "1",
            "ifp->if_broot_bytes"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "level > 0"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "block->bb_level"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmap_count_leaves",
          "args": [
            "ifp",
            "0",
            "ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t)",
            "count"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_count_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "278-291",
          "snippet": "STATIC void\nxfs_bmap_count_leaves(\n\txfs_ifork_t\t\t*ifp,\n\txfs_extnum_t\t\tidx,\n\tint\t\t\tnumrecs,\n\tint\t\t\t*count)\n{\n\tint\t\tb;\n\n\tfor (b = 0; b < numrecs; b++) {\n\t\txfs_bmbt_rec_host_t *frp = xfs_iext_get_ext(ifp, idx + b);\n\t\t*count += xfs_bmbt_get_blockcount(frp);\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_bmap_count_leaves(\n\txfs_ifork_t\t\t*ifp,\n\txfs_extnum_t\t\tidx,\n\tint\t\t\tnumrecs,\n\tint\t\t\t*count)\n{\n\tint\t\tb;\n\n\tfor (b = 0; b < numrecs; b++) {\n\t\txfs_bmbt_rec_host_t *frp = xfs_iext_get_ext(ifp, idx + b);\n\t\t*count += xfs_bmbt_get_blockcount(frp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_FORMAT",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_PTR",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error */\nxfs_bmap_count_blocks(\n\txfs_trans_t\t\t*tp,\t\t/* transaction pointer */\n\txfs_inode_t\t\t*ip,\t\t/* incore inode */\n\tint\t\t\twhichfork,\t/* data or attr fork */\n\tint\t\t\t*count)\t\t/* out: count of blocks */\n{\n\tstruct xfs_btree_block\t*block;\t/* current btree block */\n\txfs_fsblock_t\t\tbno;\t/* block # of \"block\" */\n\txfs_ifork_t\t\t*ifp;\t/* fork structure */\n\tint\t\t\tlevel;\t/* btree level, for checking */\n\txfs_mount_t\t\t*mp;\t/* file system mount structure */\n\t__be64\t\t\t*pp;\t/* pointer to block address */\n\n\tbno = NULLFSBLOCK;\n\tmp = ip->i_mount;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif ( XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS ) {\n\t\txfs_bmap_count_leaves(ifp, 0,\n\t\t\tifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t),\n\t\t\tcount);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Root level must use BMAP_BROOT_PTR_ADDR macro to get ptr out.\n\t */\n\tblock = ifp->if_broot;\n\tlevel = be16_to_cpu(block->bb_level);\n\tASSERT(level > 0);\n\tpp = XFS_BMAP_BROOT_PTR_ADDR(mp, block, 1, ifp->if_broot_bytes);\n\tbno = be64_to_cpu(*pp);\n\tASSERT(bno != NULLFSBLOCK);\n\tASSERT(XFS_FSB_TO_AGNO(mp, bno) < mp->m_sb.sb_agcount);\n\tASSERT(XFS_FSB_TO_AGBNO(mp, bno) < mp->m_sb.sb_agblocks);\n\n\tif (unlikely(xfs_bmap_count_tree(mp, tp, ifp, bno, level, count) < 0)) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmap_count_blocks(2)\", XFS_ERRLEVEL_LOW,\n\t\t\t\t mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_bmap_count_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
    "lines": "317-388",
    "snippet": "STATIC int                                     /* error */\nxfs_bmap_count_tree(\n\txfs_mount_t     *mp,            /* file system mount point */\n\txfs_trans_t     *tp,            /* transaction pointer */\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_fsblock_t   blockno,\t/* file system block number */\n\tint             levelin,\t/* level in btree */\n\tint\t\t*count)\t\t/* Count of blocks */\n{\n\tint\t\t\terror;\n\txfs_buf_t\t\t*bp, *nbp;\n\tint\t\t\tlevel = levelin;\n\t__be64\t\t\t*pp;\n\txfs_fsblock_t           bno = blockno;\n\txfs_fsblock_t\t\tnextbno;\n\tstruct xfs_btree_block\t*block, *nextblock;\n\tint\t\t\tnumrecs;\n\n\terror = xfs_btree_read_bufl(mp, tp, bno, 0, &bp, XFS_BMAP_BTREE_REF,\n\t\t\t\t\t\t&xfs_bmbt_buf_ops);\n\tif (error)\n\t\treturn error;\n\t*count += 1;\n\tblock = XFS_BUF_TO_BLOCK(bp);\n\n\tif (--level) {\n\t\t/* Not at node above leaves, count this level of nodes */\n\t\tnextbno = be64_to_cpu(block->bb_u.l.bb_rightsib);\n\t\twhile (nextbno != NULLFSBLOCK) {\n\t\t\terror = xfs_btree_read_bufl(mp, tp, nextbno, 0, &nbp,\n\t\t\t\t\t\tXFS_BMAP_BTREE_REF,\n\t\t\t\t\t\t&xfs_bmbt_buf_ops);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\t*count += 1;\n\t\t\tnextblock = XFS_BUF_TO_BLOCK(nbp);\n\t\t\tnextbno = be64_to_cpu(nextblock->bb_u.l.bb_rightsib);\n\t\t\txfs_trans_brelse(tp, nbp);\n\t\t}\n\n\t\t/* Dive to the next level */\n\t\tpp = XFS_BMBT_PTR_ADDR(mp, block, 1, mp->m_bmap_dmxr[1]);\n\t\tbno = be64_to_cpu(*pp);\n\t\tif (unlikely((error =\n\t\t     xfs_bmap_count_tree(mp, tp, ifp, bno, level, count)) < 0)) {\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\tXFS_ERROR_REPORT(\"xfs_bmap_count_tree(1)\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\txfs_trans_brelse(tp, bp);\n\t} else {\n\t\t/* count all level 1 nodes and their leaves */\n\t\tfor (;;) {\n\t\t\tnextbno = be64_to_cpu(block->bb_u.l.bb_rightsib);\n\t\t\tnumrecs = be16_to_cpu(block->bb_numrecs);\n\t\t\txfs_bmap_disk_count_leaves(mp, block, numrecs, count);\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\tif (nextbno == NULLFSBLOCK)\n\t\t\t\tbreak;\n\t\t\tbno = nextbno;\n\t\t\terror = xfs_btree_read_bufl(mp, tp, bno, 0, &bp,\n\t\t\t\t\t\tXFS_BMAP_BTREE_REF,\n\t\t\t\t\t\t&xfs_bmbt_buf_ops);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\t*count += 1;\n\t\t\tblock = XFS_BUF_TO_BLOCK(bp);\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_BUF_TO_BLOCK",
          "args": [
            "bp"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_read_bufl",
          "args": [
            "mp",
            "tp",
            "bno",
            "0",
            "&bp",
            "XFS_BMAP_BTREE_REF",
            "&xfs_bmbt_buf_ops"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_read_bufl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "699-723",
          "snippet": "int\nxfs_btree_read_bufl(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\txfs_fsblock_t\t\tfsbno,\t\t/* file system block number */\n\tuint\t\t\tlock,\t\t/* lock flags for read_buf */\n\tstruct xfs_buf\t\t**bpp,\t\t/* buffer for fsbno */\n\tint\t\t\trefval,\t\t/* ref count value for buffer */\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\t\t/* return value */\n\txfs_daddr_t\t\td;\t\t/* real disk block address */\n\tint\t\t\terror;\n\n\tASSERT(fsbno != NULLFSBLOCK);\n\td = XFS_FSB_TO_DADDR(mp, fsbno);\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp, d,\n\t\t\t\t   mp->m_bsize, lock, &bp, ops);\n\tif (error)\n\t\treturn error;\n\tif (bp)\n\t\txfs_buf_set_ref(bp, refval);\n\t*bpp = bp;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nint\nxfs_btree_read_bufl(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\txfs_fsblock_t\t\tfsbno,\t\t/* file system block number */\n\tuint\t\t\tlock,\t\t/* lock flags for read_buf */\n\tstruct xfs_buf\t\t**bpp,\t\t/* buffer for fsbno */\n\tint\t\t\trefval,\t\t/* ref count value for buffer */\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\t\t/* return value */\n\txfs_daddr_t\t\td;\t\t/* real disk block address */\n\tint\t\t\terror;\n\n\tASSERT(fsbno != NULLFSBLOCK);\n\td = XFS_FSB_TO_DADDR(mp, fsbno);\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp, d,\n\t\t\t\t   mp->m_bsize, lock, &bp, ops);\n\tif (error)\n\t\treturn error;\n\tif (bp)\n\t\txfs_buf_set_ref(bp, refval);\n\t*bpp = bp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "tp",
            "bp"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_disk_count_leaves",
          "args": [
            "mp",
            "block",
            "numrecs",
            "count"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_disk_count_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "297-311",
          "snippet": "STATIC void\nxfs_bmap_disk_count_leaves(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_btree_block\t*block,\n\tint\t\t\tnumrecs,\n\tint\t\t\t*count)\n{\n\tint\t\tb;\n\txfs_bmbt_rec_t\t*frp;\n\n\tfor (b = 1; b <= numrecs; b++) {\n\t\tfrp = XFS_BMBT_REC_ADDR(mp, block, b);\n\t\t*count += xfs_bmbt_disk_get_blockcount(frp);\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_bmap_disk_count_leaves(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_btree_block\t*block,\n\tint\t\t\tnumrecs,\n\tint\t\t\t*count)\n{\n\tint\t\tb;\n\txfs_bmbt_rec_t\t*frp;\n\n\tfor (b = 1; b <= numrecs; b++) {\n\t\tfrp = XFS_BMBT_REC_ADDR(mp, block, b);\n\t\t*count += xfs_bmbt_disk_get_blockcount(frp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "block->bb_numrecs"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "block->bb_u.l.bb_rightsib"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ERROR_REPORT",
          "args": [
            "\"xfs_bmap_count_tree(1)\"",
            "XFS_ERRLEVEL_LOW",
            "mp"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(error =\n\t\t     xfs_bmap_count_tree(mp, tp, ifp, bno, level, count)) < 0"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmap_count_tree",
          "args": [
            "mp",
            "tp",
            "ifp",
            "bno",
            "level",
            "count"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_count_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "317-388",
          "snippet": "STATIC int                                     /* error */\nxfs_bmap_count_tree(\n\txfs_mount_t     *mp,            /* file system mount point */\n\txfs_trans_t     *tp,            /* transaction pointer */\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_fsblock_t   blockno,\t/* file system block number */\n\tint             levelin,\t/* level in btree */\n\tint\t\t*count)\t\t/* Count of blocks */\n{\n\tint\t\t\terror;\n\txfs_buf_t\t\t*bp, *nbp;\n\tint\t\t\tlevel = levelin;\n\t__be64\t\t\t*pp;\n\txfs_fsblock_t           bno = blockno;\n\txfs_fsblock_t\t\tnextbno;\n\tstruct xfs_btree_block\t*block, *nextblock;\n\tint\t\t\tnumrecs;\n\n\terror = xfs_btree_read_bufl(mp, tp, bno, 0, &bp, XFS_BMAP_BTREE_REF,\n\t\t\t\t\t\t&xfs_bmbt_buf_ops);\n\tif (error)\n\t\treturn error;\n\t*count += 1;\n\tblock = XFS_BUF_TO_BLOCK(bp);\n\n\tif (--level) {\n\t\t/* Not at node above leaves, count this level of nodes */\n\t\tnextbno = be64_to_cpu(block->bb_u.l.bb_rightsib);\n\t\twhile (nextbno != NULLFSBLOCK) {\n\t\t\terror = xfs_btree_read_bufl(mp, tp, nextbno, 0, &nbp,\n\t\t\t\t\t\tXFS_BMAP_BTREE_REF,\n\t\t\t\t\t\t&xfs_bmbt_buf_ops);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\t*count += 1;\n\t\t\tnextblock = XFS_BUF_TO_BLOCK(nbp);\n\t\t\tnextbno = be64_to_cpu(nextblock->bb_u.l.bb_rightsib);\n\t\t\txfs_trans_brelse(tp, nbp);\n\t\t}\n\n\t\t/* Dive to the next level */\n\t\tpp = XFS_BMBT_PTR_ADDR(mp, block, 1, mp->m_bmap_dmxr[1]);\n\t\tbno = be64_to_cpu(*pp);\n\t\tif (unlikely((error =\n\t\t     xfs_bmap_count_tree(mp, tp, ifp, bno, level, count)) < 0)) {\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\tXFS_ERROR_REPORT(\"xfs_bmap_count_tree(1)\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\txfs_trans_brelse(tp, bp);\n\t} else {\n\t\t/* count all level 1 nodes and their leaves */\n\t\tfor (;;) {\n\t\t\tnextbno = be64_to_cpu(block->bb_u.l.bb_rightsib);\n\t\t\tnumrecs = be16_to_cpu(block->bb_numrecs);\n\t\t\txfs_bmap_disk_count_leaves(mp, block, numrecs, count);\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\tif (nextbno == NULLFSBLOCK)\n\t\t\t\tbreak;\n\t\t\tbno = nextbno;\n\t\t\terror = xfs_btree_read_bufl(mp, tp, bno, 0, &bp,\n\t\t\t\t\t\tXFS_BMAP_BTREE_REF,\n\t\t\t\t\t\t&xfs_bmbt_buf_ops);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\t*count += 1;\n\t\t\tblock = XFS_BUF_TO_BLOCK(bp);\n\t\t}\n\t}\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "*pp"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BMBT_PTR_ADDR",
          "args": [
            "mp",
            "block",
            "1",
            "mp->m_bmap_dmxr[1]"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "nextblock->bb_u.l.bb_rightsib"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_BLOCK",
          "args": [
            "nbp"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "block->bb_u.l.bb_rightsib"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_BLOCK",
          "args": [
            "bp"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int                                     /* error */\nxfs_bmap_count_tree(\n\txfs_mount_t     *mp,            /* file system mount point */\n\txfs_trans_t     *tp,            /* transaction pointer */\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_fsblock_t   blockno,\t/* file system block number */\n\tint             levelin,\t/* level in btree */\n\tint\t\t*count)\t\t/* Count of blocks */\n{\n\tint\t\t\terror;\n\txfs_buf_t\t\t*bp, *nbp;\n\tint\t\t\tlevel = levelin;\n\t__be64\t\t\t*pp;\n\txfs_fsblock_t           bno = blockno;\n\txfs_fsblock_t\t\tnextbno;\n\tstruct xfs_btree_block\t*block, *nextblock;\n\tint\t\t\tnumrecs;\n\n\terror = xfs_btree_read_bufl(mp, tp, bno, 0, &bp, XFS_BMAP_BTREE_REF,\n\t\t\t\t\t\t&xfs_bmbt_buf_ops);\n\tif (error)\n\t\treturn error;\n\t*count += 1;\n\tblock = XFS_BUF_TO_BLOCK(bp);\n\n\tif (--level) {\n\t\t/* Not at node above leaves, count this level of nodes */\n\t\tnextbno = be64_to_cpu(block->bb_u.l.bb_rightsib);\n\t\twhile (nextbno != NULLFSBLOCK) {\n\t\t\terror = xfs_btree_read_bufl(mp, tp, nextbno, 0, &nbp,\n\t\t\t\t\t\tXFS_BMAP_BTREE_REF,\n\t\t\t\t\t\t&xfs_bmbt_buf_ops);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\t*count += 1;\n\t\t\tnextblock = XFS_BUF_TO_BLOCK(nbp);\n\t\t\tnextbno = be64_to_cpu(nextblock->bb_u.l.bb_rightsib);\n\t\t\txfs_trans_brelse(tp, nbp);\n\t\t}\n\n\t\t/* Dive to the next level */\n\t\tpp = XFS_BMBT_PTR_ADDR(mp, block, 1, mp->m_bmap_dmxr[1]);\n\t\tbno = be64_to_cpu(*pp);\n\t\tif (unlikely((error =\n\t\t     xfs_bmap_count_tree(mp, tp, ifp, bno, level, count)) < 0)) {\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\tXFS_ERROR_REPORT(\"xfs_bmap_count_tree(1)\",\n\t\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\txfs_trans_brelse(tp, bp);\n\t} else {\n\t\t/* count all level 1 nodes and their leaves */\n\t\tfor (;;) {\n\t\t\tnextbno = be64_to_cpu(block->bb_u.l.bb_rightsib);\n\t\t\tnumrecs = be16_to_cpu(block->bb_numrecs);\n\t\t\txfs_bmap_disk_count_leaves(mp, block, numrecs, count);\n\t\t\txfs_trans_brelse(tp, bp);\n\t\t\tif (nextbno == NULLFSBLOCK)\n\t\t\t\tbreak;\n\t\t\tbno = nextbno;\n\t\t\terror = xfs_btree_read_bufl(mp, tp, bno, 0, &bp,\n\t\t\t\t\t\tXFS_BMAP_BTREE_REF,\n\t\t\t\t\t\t&xfs_bmbt_buf_ops);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\t*count += 1;\n\t\t\tblock = XFS_BUF_TO_BLOCK(bp);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_bmap_disk_count_leaves",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
    "lines": "297-311",
    "snippet": "STATIC void\nxfs_bmap_disk_count_leaves(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_btree_block\t*block,\n\tint\t\t\tnumrecs,\n\tint\t\t\t*count)\n{\n\tint\t\tb;\n\txfs_bmbt_rec_t\t*frp;\n\n\tfor (b = 1; b <= numrecs; b++) {\n\t\tfrp = XFS_BMBT_REC_ADDR(mp, block, b);\n\t\t*count += xfs_bmbt_disk_get_blockcount(frp);\n\t}\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_bmbt_disk_get_blockcount",
          "args": [
            "frp"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_disk_get_blockcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "177-182",
          "snippet": "xfs_filblks_t\nxfs_bmbt_disk_get_blockcount(\n\txfs_bmbt_rec_t\t*r)\n{\n\treturn (xfs_filblks_t)(be64_to_cpu(r->l1) & xfs_mask64lo(21));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_filblks_t\nxfs_bmbt_disk_get_blockcount(\n\txfs_bmbt_rec_t\t*r)\n{\n\treturn (xfs_filblks_t)(be64_to_cpu(r->l1) & xfs_mask64lo(21));\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BMBT_REC_ADDR",
          "args": [
            "mp",
            "block",
            "b"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_bmap_disk_count_leaves(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_btree_block\t*block,\n\tint\t\t\tnumrecs,\n\tint\t\t\t*count)\n{\n\tint\t\tb;\n\txfs_bmbt_rec_t\t*frp;\n\n\tfor (b = 1; b <= numrecs; b++) {\n\t\tfrp = XFS_BMBT_REC_ADDR(mp, block, b);\n\t\t*count += xfs_bmbt_disk_get_blockcount(frp);\n\t}\n}"
  },
  {
    "function_name": "xfs_bmap_count_leaves",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
    "lines": "278-291",
    "snippet": "STATIC void\nxfs_bmap_count_leaves(\n\txfs_ifork_t\t\t*ifp,\n\txfs_extnum_t\t\tidx,\n\tint\t\t\tnumrecs,\n\tint\t\t\t*count)\n{\n\tint\t\tb;\n\n\tfor (b = 0; b < numrecs; b++) {\n\t\txfs_bmbt_rec_host_t *frp = xfs_iext_get_ext(ifp, idx + b);\n\t\t*count += xfs_bmbt_get_blockcount(frp);\n\t}\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_bmbt_get_blockcount",
          "args": [
            "frp"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_get_blockcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "134-139",
          "snippet": "xfs_filblks_t\nxfs_bmbt_get_blockcount(\n\txfs_bmbt_rec_host_t\t*r)\n{\n\treturn (xfs_filblks_t)(r->l1 & xfs_mask64lo(21));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_filblks_t\nxfs_bmbt_get_blockcount(\n\txfs_bmbt_rec_host_t\t*r)\n{\n\treturn (xfs_filblks_t)(r->l1 & xfs_mask64lo(21));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iext_get_ext",
          "args": [
            "ifp",
            "idx + b"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_get_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "881-903",
          "snippet": "xfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_bmap_count_leaves(\n\txfs_ifork_t\t\t*ifp,\n\txfs_extnum_t\t\tidx,\n\tint\t\t\tnumrecs,\n\tint\t\t\t*count)\n{\n\tint\t\tb;\n\n\tfor (b = 0; b < numrecs; b++) {\n\t\txfs_bmbt_rec_host_t *frp = xfs_iext_get_ext(ifp, idx + b);\n\t\t*count += xfs_bmbt_get_blockcount(frp);\n\t}\n}"
  },
  {
    "function_name": "xfs_bmap_eof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
    "lines": "253-269",
    "snippet": "int\nxfs_bmap_eof(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tendoff,\n\tint\t\t\twhichfork,\n\tint\t\t\t*eof)\n{\n\tstruct xfs_bmbt_irec\trec;\n\tint\t\t\terror;\n\n\terror = xfs_bmap_last_extent(NULL, ip, whichfork, &rec, eof);\n\tif (error || *eof)\n\t\treturn error;\n\n\t*eof = endoff >= rec.br_startoff + rec.br_blockcount;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_bmap_last_extent",
          "args": [
            "NULL",
            "ip",
            "whichfork",
            "&rec",
            "eof"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_last_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "1598-1625",
          "snippet": "int\nxfs_bmap_last_extent(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork,\n\tstruct xfs_bmbt_irec\t*rec,\n\tint\t\t\t*is_empty)\n{\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(ip, whichfork);\n\tint\t\t\terror;\n\tint\t\t\tnextents;\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(tp, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tnextents = ifp->if_bytes / sizeof(xfs_bmbt_rec_t);\n\tif (nextents == 0) {\n\t\t*is_empty = 1;\n\t\treturn 0;\n\t}\n\n\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, nextents - 1), rec);\n\t*is_empty = 0;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmap_last_extent(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork,\n\tstruct xfs_bmbt_irec\t*rec,\n\tint\t\t\t*is_empty)\n{\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(ip, whichfork);\n\tint\t\t\terror;\n\tint\t\t\tnextents;\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(tp, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tnextents = ifp->if_bytes / sizeof(xfs_bmbt_rec_t);\n\tif (nextents == 0) {\n\t\t*is_empty = 1;\n\t\treturn 0;\n\t}\n\n\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, nextents - 1), rec);\n\t*is_empty = 0;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmap_eof(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tendoff,\n\tint\t\t\twhichfork,\n\tint\t\t\t*eof)\n{\n\tstruct xfs_bmbt_irec\trec;\n\tint\t\t\terror;\n\n\terror = xfs_bmap_last_extent(NULL, ip, whichfork, &rec, eof);\n\tif (error || *eof)\n\t\treturn error;\n\n\t*eof = endoff >= rec.br_startoff + rec.br_blockcount;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_bmap_rtalloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
    "lines": "145-246",
    "snippet": "int\nxfs_bmap_rtalloc(\n\tstruct xfs_bmalloca\t*ap)\t/* bmap alloc argument struct */\n{\n\txfs_alloctype_t\tatype = 0;\t/* type for allocation routines */\n\tint\t\terror;\t\t/* error return value */\n\txfs_mount_t\t*mp;\t\t/* mount point structure */\n\txfs_extlen_t\tprod = 0;\t/* product factor for allocators */\n\txfs_extlen_t\tralen = 0;\t/* realtime allocation length */\n\txfs_extlen_t\talign;\t\t/* minimum allocation alignment */\n\txfs_rtblock_t\trtb;\n\n\tmp = ap->ip->i_mount;\n\talign = xfs_get_extsz_hint(ap->ip);\n\tprod = align / mp->m_sb.sb_rextsize;\n\terror = xfs_bmap_extsize_align(mp, &ap->got, &ap->prev,\n\t\t\t\t\talign, 1, ap->eof, 0,\n\t\t\t\t\tap->conv, &ap->offset, &ap->length);\n\tif (error)\n\t\treturn error;\n\tASSERT(ap->length);\n\tASSERT(ap->length % mp->m_sb.sb_rextsize == 0);\n\n\t/*\n\t * If the offset & length are not perfectly aligned\n\t * then kill prod, it will just get us in trouble.\n\t */\n\tif (do_mod(ap->offset, align) || ap->length % align)\n\t\tprod = 1;\n\t/*\n\t * Set ralen to be the actual requested length in rtextents.\n\t */\n\tralen = ap->length / mp->m_sb.sb_rextsize;\n\t/*\n\t * If the old value was close enough to MAXEXTLEN that\n\t * we rounded up to it, cut it back so it's valid again.\n\t * Note that if it's a really large request (bigger than\n\t * MAXEXTLEN), we don't hear about that number, and can't\n\t * adjust the starting point to match it.\n\t */\n\tif (ralen * mp->m_sb.sb_rextsize >= MAXEXTLEN)\n\t\tralen = MAXEXTLEN / mp->m_sb.sb_rextsize;\n\n\t/*\n\t * Lock out other modifications to the RT bitmap inode.\n\t */\n\txfs_ilock(mp->m_rbmip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(ap->tp, mp->m_rbmip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * If it's an allocation to an empty file at offset 0,\n\t * pick an extent that will space things out in the rt area.\n\t */\n\tif (ap->eof && ap->offset == 0) {\n\t\txfs_rtblock_t uninitialized_var(rtx); /* realtime extent no */\n\n\t\terror = xfs_rtpick_extent(mp, ap->tp, ralen, &rtx);\n\t\tif (error)\n\t\t\treturn error;\n\t\tap->blkno = rtx * mp->m_sb.sb_rextsize;\n\t} else {\n\t\tap->blkno = 0;\n\t}\n\n\txfs_bmap_adjacent(ap);\n\n\t/*\n\t * Realtime allocation, done through xfs_rtallocate_extent.\n\t */\n\tatype = ap->blkno == 0 ?  XFS_ALLOCTYPE_ANY_AG : XFS_ALLOCTYPE_NEAR_BNO;\n\tdo_div(ap->blkno, mp->m_sb.sb_rextsize);\n\trtb = ap->blkno;\n\tap->length = ralen;\n\tif ((error = xfs_rtallocate_extent(ap->tp, ap->blkno, 1, ap->length,\n\t\t\t\t&ralen, atype, ap->wasdel, prod, &rtb)))\n\t\treturn error;\n\tif (rtb == NULLFSBLOCK && prod > 1 &&\n\t    (error = xfs_rtallocate_extent(ap->tp, ap->blkno, 1,\n\t\t\t\t\t   ap->length, &ralen, atype,\n\t\t\t\t\t   ap->wasdel, 1, &rtb)))\n\t\treturn error;\n\tap->blkno = rtb;\n\tif (ap->blkno != NULLFSBLOCK) {\n\t\tap->blkno *= mp->m_sb.sb_rextsize;\n\t\tralen *= mp->m_sb.sb_rextsize;\n\t\tap->length = ralen;\n\t\tap->ip->i_d.di_nblocks += ralen;\n\t\txfs_trans_log_inode(ap->tp, ap->ip, XFS_ILOG_CORE);\n\t\tif (ap->wasdel)\n\t\t\tap->ip->i_delayed_blks -= ralen;\n\t\t/*\n\t\t * Adjust the disk quota also. This was reserved\n\t\t * earlier.\n\t\t */\n\t\txfs_trans_mod_dquot_byino(ap->tp, ap->ip,\n\t\t\tap->wasdel ? XFS_TRANS_DQ_DELRTBCOUNT :\n\t\t\t\t\tXFS_TRANS_DQ_RTBCOUNT, (long) ralen);\n\t} else {\n\t\tap->length = 0;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_mod_dquot_byino",
          "args": [
            "ap->tp",
            "ap->ip",
            "ap->wasdel ? XFS_TRANS_DQ_DELRTBCOUNT :\n\t\t\t\t\tXFS_TRANS_DQ_RTBCOUNT",
            "(long) ralen"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_mod_dquot_byino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
          "lines": "141-164",
          "snippet": "void\nxfs_trans_mod_dquot_byino(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tfield,\n\tlong\t\tdelta)\n{\n\txfs_mount_t\t*mp = tp->t_mountp;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) ||\n\t    !XFS_IS_QUOTA_ON(mp) ||\n\t    xfs_is_quota_inode(&mp->m_sb, ip->i_ino))\n\t\treturn;\n\n\tif (tp->t_dqinfo == NULL)\n\t\txfs_trans_alloc_dqinfo(tp);\n\n\tif (XFS_IS_UQUOTA_ON(mp) && ip->i_udquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_udquot, field, delta);\n\tif (XFS_IS_GQUOTA_ON(mp) && ip->i_gdquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_gdquot, field, delta);\n\tif (XFS_IS_PQUOTA_ON(mp) && ip->i_pdquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_pdquot, field, delta);\n}",
          "includes": [
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);\n\nvoid\nxfs_trans_mod_dquot_byino(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tfield,\n\tlong\t\tdelta)\n{\n\txfs_mount_t\t*mp = tp->t_mountp;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) ||\n\t    !XFS_IS_QUOTA_ON(mp) ||\n\t    xfs_is_quota_inode(&mp->m_sb, ip->i_ino))\n\t\treturn;\n\n\tif (tp->t_dqinfo == NULL)\n\t\txfs_trans_alloc_dqinfo(tp);\n\n\tif (XFS_IS_UQUOTA_ON(mp) && ip->i_udquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_udquot, field, delta);\n\tif (XFS_IS_GQUOTA_ON(mp) && ip->i_gdquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_gdquot, field, delta);\n\tif (XFS_IS_PQUOTA_ON(mp) && ip->i_pdquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_pdquot, field, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "ap->tp",
            "ap->ip",
            "XFS_ILOG_CORE"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_rtallocate_extent",
          "args": [
            "ap->tp",
            "ap->blkno",
            "1",
            "ap->length",
            "&ralen",
            "atype",
            "ap->wasdel",
            "1",
            "&rtb"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rtallocate_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_rtalloc.c",
          "lines": "1097-1172",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_rtallocate_extent(\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tbno,\t\t/* starting block number to allocate */\n\txfs_extlen_t\tminlen,\t\t/* minimum length to allocate */\n\txfs_extlen_t\tmaxlen,\t\t/* maximum length to allocate */\n\txfs_extlen_t\t*len,\t\t/* out: actual length allocated */\n\txfs_alloctype_t\ttype,\t\t/* allocation type XFS_ALLOCTYPE... */\n\tint\t\twasdel,\t\t/* was a delayed allocation extent */\n\txfs_extlen_t\tprod,\t\t/* extent product factor */\n\txfs_rtblock_t\t*rtblock)\t/* out: start block allocated */\n{\n\txfs_mount_t\t*mp = tp->t_mountp;\n\tint\t\terror;\t\t/* error value */\n\txfs_rtblock_t\tr;\t\t/* result allocated block */\n\txfs_fsblock_t\tsb;\t\t/* summary file block number */\n\txfs_buf_t\t*sumbp;\t\t/* summary file block buffer */\n\n\tASSERT(xfs_isilocked(mp->m_rbmip, XFS_ILOCK_EXCL));\n\tASSERT(minlen > 0 && minlen <= maxlen);\n\n\t/*\n\t * If prod is set then figure out what to do to minlen and maxlen.\n\t */\n\tif (prod > 1) {\n\t\txfs_extlen_t\ti;\n\n\t\tif ((i = maxlen % prod))\n\t\t\tmaxlen -= i;\n\t\tif ((i = minlen % prod))\n\t\t\tminlen += prod - i;\n\t\tif (maxlen < minlen) {\n\t\t\t*rtblock = NULLRTBLOCK;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tsumbp = NULL;\n\t/*\n\t * Allocate by size, or near another block, or exactly at some block.\n\t */\n\tswitch (type) {\n\tcase XFS_ALLOCTYPE_ANY_AG:\n\t\terror = xfs_rtallocate_extent_size(mp, tp, minlen, maxlen, len,\n\t\t\t\t&sumbp,\t&sb, prod, &r);\n\t\tbreak;\n\tcase XFS_ALLOCTYPE_NEAR_BNO:\n\t\terror = xfs_rtallocate_extent_near(mp, tp, bno, minlen, maxlen,\n\t\t\t\tlen, &sumbp, &sb, prod, &r);\n\t\tbreak;\n\tcase XFS_ALLOCTYPE_THIS_BNO:\n\t\terror = xfs_rtallocate_extent_exact(mp, tp, bno, minlen, maxlen,\n\t\t\t\tlen, &sumbp, &sb, prod, &r);\n\t\tbreak;\n\tdefault:\n\t\terror = -EIO;\n\t\tASSERT(0);\n\t}\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * If it worked, update the superblock.\n\t */\n\tif (r != NULLRTBLOCK) {\n\t\tlong\tslen = (long)*len;\n\n\t\tASSERT(*len >= minlen && *len <= maxlen);\n\t\tif (wasdel)\n\t\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_RES_FREXTENTS, -slen);\n\t\telse\n\t\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_FREXTENTS, -slen);\n\t}\n\t*rtblock = r;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_rtallocate_extent(\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tbno,\t\t/* starting block number to allocate */\n\txfs_extlen_t\tminlen,\t\t/* minimum length to allocate */\n\txfs_extlen_t\tmaxlen,\t\t/* maximum length to allocate */\n\txfs_extlen_t\t*len,\t\t/* out: actual length allocated */\n\txfs_alloctype_t\ttype,\t\t/* allocation type XFS_ALLOCTYPE... */\n\tint\t\twasdel,\t\t/* was a delayed allocation extent */\n\txfs_extlen_t\tprod,\t\t/* extent product factor */\n\txfs_rtblock_t\t*rtblock)\t/* out: start block allocated */\n{\n\txfs_mount_t\t*mp = tp->t_mountp;\n\tint\t\terror;\t\t/* error value */\n\txfs_rtblock_t\tr;\t\t/* result allocated block */\n\txfs_fsblock_t\tsb;\t\t/* summary file block number */\n\txfs_buf_t\t*sumbp;\t\t/* summary file block buffer */\n\n\tASSERT(xfs_isilocked(mp->m_rbmip, XFS_ILOCK_EXCL));\n\tASSERT(minlen > 0 && minlen <= maxlen);\n\n\t/*\n\t * If prod is set then figure out what to do to minlen and maxlen.\n\t */\n\tif (prod > 1) {\n\t\txfs_extlen_t\ti;\n\n\t\tif ((i = maxlen % prod))\n\t\t\tmaxlen -= i;\n\t\tif ((i = minlen % prod))\n\t\t\tminlen += prod - i;\n\t\tif (maxlen < minlen) {\n\t\t\t*rtblock = NULLRTBLOCK;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tsumbp = NULL;\n\t/*\n\t * Allocate by size, or near another block, or exactly at some block.\n\t */\n\tswitch (type) {\n\tcase XFS_ALLOCTYPE_ANY_AG:\n\t\terror = xfs_rtallocate_extent_size(mp, tp, minlen, maxlen, len,\n\t\t\t\t&sumbp,\t&sb, prod, &r);\n\t\tbreak;\n\tcase XFS_ALLOCTYPE_NEAR_BNO:\n\t\terror = xfs_rtallocate_extent_near(mp, tp, bno, minlen, maxlen,\n\t\t\t\tlen, &sumbp, &sb, prod, &r);\n\t\tbreak;\n\tcase XFS_ALLOCTYPE_THIS_BNO:\n\t\terror = xfs_rtallocate_extent_exact(mp, tp, bno, minlen, maxlen,\n\t\t\t\tlen, &sumbp, &sb, prod, &r);\n\t\tbreak;\n\tdefault:\n\t\terror = -EIO;\n\t\tASSERT(0);\n\t}\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * If it worked, update the superblock.\n\t */\n\tif (r != NULLRTBLOCK) {\n\t\tlong\tslen = (long)*len;\n\n\t\tASSERT(*len >= minlen && *len <= maxlen);\n\t\tif (wasdel)\n\t\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_RES_FREXTENTS, -slen);\n\t\telse\n\t\t\txfs_trans_mod_sb(tp, XFS_TRANS_SB_FREXTENTS, -slen);\n\t}\n\t*rtblock = r;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "ap->blkno",
            "mp->m_sb.sb_rextsize"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmap_adjacent",
          "args": [
            "ap"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_adjacent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "3366-3512",
          "snippet": "void\nxfs_bmap_adjacent(\n\tstruct xfs_bmalloca\t*ap)\t/* bmap alloc argument struct */\n{\n\txfs_fsblock_t\tadjust;\t\t/* adjustment to block numbers */\n\txfs_agnumber_t\tfb_agno;\t/* ag number of ap->firstblock */\n\txfs_mount_t\t*mp;\t\t/* mount point structure */\n\tint\t\tnullfb;\t\t/* true if ap->firstblock isn't set */\n\tint\t\trt;\t\t/* true if inode is realtime */\n\n#define\tISVALID(x,y)\t\\\n\t(rt ? \\\n\t\t(x) < mp->m_sb.sb_rblocks : \\\n\t\tXFS_FSB_TO_AGNO(mp, x) == XFS_FSB_TO_AGNO(mp, y) && \\\n\t\tXFS_FSB_TO_AGNO(mp, x) < mp->m_sb.sb_agcount && \\\n\t\tXFS_FSB_TO_AGBNO(mp, x) < mp->m_sb.sb_agblocks)\n\n\tmp = ap->ip->i_mount;\n\tnullfb = *ap->firstblock == NULLFSBLOCK;\n\trt = XFS_IS_REALTIME_INODE(ap->ip) && ap->userdata;\n\tfb_agno = nullfb ? NULLAGNUMBER : XFS_FSB_TO_AGNO(mp, *ap->firstblock);\n\t/*\n\t * If allocating at eof, and there's a previous real block,\n\t * try to use its last block as our starting point.\n\t */\n\tif (ap->eof && ap->prev.br_startoff != NULLFILEOFF &&\n\t    !isnullstartblock(ap->prev.br_startblock) &&\n\t    ISVALID(ap->prev.br_startblock + ap->prev.br_blockcount,\n\t\t    ap->prev.br_startblock)) {\n\t\tap->blkno = ap->prev.br_startblock + ap->prev.br_blockcount;\n\t\t/*\n\t\t * Adjust for the gap between prevp and us.\n\t\t */\n\t\tadjust = ap->offset -\n\t\t\t(ap->prev.br_startoff + ap->prev.br_blockcount);\n\t\tif (adjust &&\n\t\t    ISVALID(ap->blkno + adjust, ap->prev.br_startblock))\n\t\t\tap->blkno += adjust;\n\t}\n\t/*\n\t * If not at eof, then compare the two neighbor blocks.\n\t * Figure out whether either one gives us a good starting point,\n\t * and pick the better one.\n\t */\n\telse if (!ap->eof) {\n\t\txfs_fsblock_t\tgotbno;\t\t/* right side block number */\n\t\txfs_fsblock_t\tgotdiff=0;\t/* right side difference */\n\t\txfs_fsblock_t\tprevbno;\t/* left side block number */\n\t\txfs_fsblock_t\tprevdiff=0;\t/* left side difference */\n\n\t\t/*\n\t\t * If there's a previous (left) block, select a requested\n\t\t * start block based on it.\n\t\t */\n\t\tif (ap->prev.br_startoff != NULLFILEOFF &&\n\t\t    !isnullstartblock(ap->prev.br_startblock) &&\n\t\t    (prevbno = ap->prev.br_startblock +\n\t\t\t       ap->prev.br_blockcount) &&\n\t\t    ISVALID(prevbno, ap->prev.br_startblock)) {\n\t\t\t/*\n\t\t\t * Calculate gap to end of previous block.\n\t\t\t */\n\t\t\tadjust = prevdiff = ap->offset -\n\t\t\t\t(ap->prev.br_startoff +\n\t\t\t\t ap->prev.br_blockcount);\n\t\t\t/*\n\t\t\t * Figure the startblock based on the previous block's\n\t\t\t * end and the gap size.\n\t\t\t * Heuristic!\n\t\t\t * If the gap is large relative to the piece we're\n\t\t\t * allocating, or using it gives us an invalid block\n\t\t\t * number, then just use the end of the previous block.\n\t\t\t */\n\t\t\tif (prevdiff <= XFS_ALLOC_GAP_UNITS * ap->length &&\n\t\t\t    ISVALID(prevbno + prevdiff,\n\t\t\t\t    ap->prev.br_startblock))\n\t\t\t\tprevbno += adjust;\n\t\t\telse\n\t\t\t\tprevdiff += adjust;\n\t\t\t/*\n\t\t\t * If the firstblock forbids it, can't use it,\n\t\t\t * must use default.\n\t\t\t */\n\t\t\tif (!rt && !nullfb &&\n\t\t\t    XFS_FSB_TO_AGNO(mp, prevbno) != fb_agno)\n\t\t\t\tprevbno = NULLFSBLOCK;\n\t\t}\n\t\t/*\n\t\t * No previous block or can't follow it, just default.\n\t\t */\n\t\telse\n\t\t\tprevbno = NULLFSBLOCK;\n\t\t/*\n\t\t * If there's a following (right) block, select a requested\n\t\t * start block based on it.\n\t\t */\n\t\tif (!isnullstartblock(ap->got.br_startblock)) {\n\t\t\t/*\n\t\t\t * Calculate gap to start of next block.\n\t\t\t */\n\t\t\tadjust = gotdiff = ap->got.br_startoff - ap->offset;\n\t\t\t/*\n\t\t\t * Figure the startblock based on the next block's\n\t\t\t * start and the gap size.\n\t\t\t */\n\t\t\tgotbno = ap->got.br_startblock;\n\t\t\t/*\n\t\t\t * Heuristic!\n\t\t\t * If the gap is large relative to the piece we're\n\t\t\t * allocating, or using it gives us an invalid block\n\t\t\t * number, then just use the start of the next block\n\t\t\t * offset by our length.\n\t\t\t */\n\t\t\tif (gotdiff <= XFS_ALLOC_GAP_UNITS * ap->length &&\n\t\t\t    ISVALID(gotbno - gotdiff, gotbno))\n\t\t\t\tgotbno -= adjust;\n\t\t\telse if (ISVALID(gotbno - ap->length, gotbno)) {\n\t\t\t\tgotbno -= ap->length;\n\t\t\t\tgotdiff += adjust - ap->length;\n\t\t\t} else\n\t\t\t\tgotdiff += adjust;\n\t\t\t/*\n\t\t\t * If the firstblock forbids it, can't use it,\n\t\t\t * must use default.\n\t\t\t */\n\t\t\tif (!rt && !nullfb &&\n\t\t\t    XFS_FSB_TO_AGNO(mp, gotbno) != fb_agno)\n\t\t\t\tgotbno = NULLFSBLOCK;\n\t\t}\n\t\t/*\n\t\t * No next block, just default.\n\t\t */\n\t\telse\n\t\t\tgotbno = NULLFSBLOCK;\n\t\t/*\n\t\t * If both valid, pick the better one, else the only good\n\t\t * one, else ap->blkno is already set (to 0 or the inode block).\n\t\t */\n\t\tif (prevbno != NULLFSBLOCK && gotbno != NULLFSBLOCK)\n\t\t\tap->blkno = prevdiff <= gotdiff ? prevbno : gotbno;\n\t\telse if (prevbno != NULLFSBLOCK)\n\t\t\tap->blkno = prevbno;\n\t\telse if (gotbno != NULLFSBLOCK)\n\t\t\tap->blkno = gotbno;\n\t}\n#undef ISVALID\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [
            "#define XFS_ALLOC_GAP_UNITS\t4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\n#define XFS_ALLOC_GAP_UNITS\t4\n\nvoid\nxfs_bmap_adjacent(\n\tstruct xfs_bmalloca\t*ap)\t/* bmap alloc argument struct */\n{\n\txfs_fsblock_t\tadjust;\t\t/* adjustment to block numbers */\n\txfs_agnumber_t\tfb_agno;\t/* ag number of ap->firstblock */\n\txfs_mount_t\t*mp;\t\t/* mount point structure */\n\tint\t\tnullfb;\t\t/* true if ap->firstblock isn't set */\n\tint\t\trt;\t\t/* true if inode is realtime */\n\n#define\tISVALID(x,y)\t\\\n\t(rt ? \\\n\t\t(x) < mp->m_sb.sb_rblocks : \\\n\t\tXFS_FSB_TO_AGNO(mp, x) == XFS_FSB_TO_AGNO(mp, y) && \\\n\t\tXFS_FSB_TO_AGNO(mp, x) < mp->m_sb.sb_agcount && \\\n\t\tXFS_FSB_TO_AGBNO(mp, x) < mp->m_sb.sb_agblocks)\n\n\tmp = ap->ip->i_mount;\n\tnullfb = *ap->firstblock == NULLFSBLOCK;\n\trt = XFS_IS_REALTIME_INODE(ap->ip) && ap->userdata;\n\tfb_agno = nullfb ? NULLAGNUMBER : XFS_FSB_TO_AGNO(mp, *ap->firstblock);\n\t/*\n\t * If allocating at eof, and there's a previous real block,\n\t * try to use its last block as our starting point.\n\t */\n\tif (ap->eof && ap->prev.br_startoff != NULLFILEOFF &&\n\t    !isnullstartblock(ap->prev.br_startblock) &&\n\t    ISVALID(ap->prev.br_startblock + ap->prev.br_blockcount,\n\t\t    ap->prev.br_startblock)) {\n\t\tap->blkno = ap->prev.br_startblock + ap->prev.br_blockcount;\n\t\t/*\n\t\t * Adjust for the gap between prevp and us.\n\t\t */\n\t\tadjust = ap->offset -\n\t\t\t(ap->prev.br_startoff + ap->prev.br_blockcount);\n\t\tif (adjust &&\n\t\t    ISVALID(ap->blkno + adjust, ap->prev.br_startblock))\n\t\t\tap->blkno += adjust;\n\t}\n\t/*\n\t * If not at eof, then compare the two neighbor blocks.\n\t * Figure out whether either one gives us a good starting point,\n\t * and pick the better one.\n\t */\n\telse if (!ap->eof) {\n\t\txfs_fsblock_t\tgotbno;\t\t/* right side block number */\n\t\txfs_fsblock_t\tgotdiff=0;\t/* right side difference */\n\t\txfs_fsblock_t\tprevbno;\t/* left side block number */\n\t\txfs_fsblock_t\tprevdiff=0;\t/* left side difference */\n\n\t\t/*\n\t\t * If there's a previous (left) block, select a requested\n\t\t * start block based on it.\n\t\t */\n\t\tif (ap->prev.br_startoff != NULLFILEOFF &&\n\t\t    !isnullstartblock(ap->prev.br_startblock) &&\n\t\t    (prevbno = ap->prev.br_startblock +\n\t\t\t       ap->prev.br_blockcount) &&\n\t\t    ISVALID(prevbno, ap->prev.br_startblock)) {\n\t\t\t/*\n\t\t\t * Calculate gap to end of previous block.\n\t\t\t */\n\t\t\tadjust = prevdiff = ap->offset -\n\t\t\t\t(ap->prev.br_startoff +\n\t\t\t\t ap->prev.br_blockcount);\n\t\t\t/*\n\t\t\t * Figure the startblock based on the previous block's\n\t\t\t * end and the gap size.\n\t\t\t * Heuristic!\n\t\t\t * If the gap is large relative to the piece we're\n\t\t\t * allocating, or using it gives us an invalid block\n\t\t\t * number, then just use the end of the previous block.\n\t\t\t */\n\t\t\tif (prevdiff <= XFS_ALLOC_GAP_UNITS * ap->length &&\n\t\t\t    ISVALID(prevbno + prevdiff,\n\t\t\t\t    ap->prev.br_startblock))\n\t\t\t\tprevbno += adjust;\n\t\t\telse\n\t\t\t\tprevdiff += adjust;\n\t\t\t/*\n\t\t\t * If the firstblock forbids it, can't use it,\n\t\t\t * must use default.\n\t\t\t */\n\t\t\tif (!rt && !nullfb &&\n\t\t\t    XFS_FSB_TO_AGNO(mp, prevbno) != fb_agno)\n\t\t\t\tprevbno = NULLFSBLOCK;\n\t\t}\n\t\t/*\n\t\t * No previous block or can't follow it, just default.\n\t\t */\n\t\telse\n\t\t\tprevbno = NULLFSBLOCK;\n\t\t/*\n\t\t * If there's a following (right) block, select a requested\n\t\t * start block based on it.\n\t\t */\n\t\tif (!isnullstartblock(ap->got.br_startblock)) {\n\t\t\t/*\n\t\t\t * Calculate gap to start of next block.\n\t\t\t */\n\t\t\tadjust = gotdiff = ap->got.br_startoff - ap->offset;\n\t\t\t/*\n\t\t\t * Figure the startblock based on the next block's\n\t\t\t * start and the gap size.\n\t\t\t */\n\t\t\tgotbno = ap->got.br_startblock;\n\t\t\t/*\n\t\t\t * Heuristic!\n\t\t\t * If the gap is large relative to the piece we're\n\t\t\t * allocating, or using it gives us an invalid block\n\t\t\t * number, then just use the start of the next block\n\t\t\t * offset by our length.\n\t\t\t */\n\t\t\tif (gotdiff <= XFS_ALLOC_GAP_UNITS * ap->length &&\n\t\t\t    ISVALID(gotbno - gotdiff, gotbno))\n\t\t\t\tgotbno -= adjust;\n\t\t\telse if (ISVALID(gotbno - ap->length, gotbno)) {\n\t\t\t\tgotbno -= ap->length;\n\t\t\t\tgotdiff += adjust - ap->length;\n\t\t\t} else\n\t\t\t\tgotdiff += adjust;\n\t\t\t/*\n\t\t\t * If the firstblock forbids it, can't use it,\n\t\t\t * must use default.\n\t\t\t */\n\t\t\tif (!rt && !nullfb &&\n\t\t\t    XFS_FSB_TO_AGNO(mp, gotbno) != fb_agno)\n\t\t\t\tgotbno = NULLFSBLOCK;\n\t\t}\n\t\t/*\n\t\t * No next block, just default.\n\t\t */\n\t\telse\n\t\t\tgotbno = NULLFSBLOCK;\n\t\t/*\n\t\t * If both valid, pick the better one, else the only good\n\t\t * one, else ap->blkno is already set (to 0 or the inode block).\n\t\t */\n\t\tif (prevbno != NULLFSBLOCK && gotbno != NULLFSBLOCK)\n\t\t\tap->blkno = prevdiff <= gotdiff ? prevbno : gotbno;\n\t\telse if (prevbno != NULLFSBLOCK)\n\t\t\tap->blkno = prevbno;\n\t\telse if (gotbno != NULLFSBLOCK)\n\t\t\tap->blkno = gotbno;\n\t}\n#undef ISVALID\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_rtpick_extent",
          "args": [
            "mp",
            "ap->tp",
            "ralen",
            "&rtx"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rtpick_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_rtalloc.c",
          "lines": "1266-1302",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_rtpick_extent(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_extlen_t\tlen,\t\t/* allocation length (rtextents) */\n\txfs_rtblock_t\t*pick)\t\t/* result rt extent */\n{\n\txfs_rtblock_t\tb;\t\t/* result block */\n\tint\t\tlog2;\t\t/* log of sequence number */\n\t__uint64_t\tresid;\t\t/* residual after log removed */\n\t__uint64_t\tseq;\t\t/* sequence number of file creation */\n\t__uint64_t\t*seqp;\t\t/* pointer to seqno in inode */\n\n\tASSERT(xfs_isilocked(mp->m_rbmip, XFS_ILOCK_EXCL));\n\n\tseqp = (__uint64_t *)&mp->m_rbmip->i_d.di_atime;\n\tif (!(mp->m_rbmip->i_d.di_flags & XFS_DIFLAG_NEWRTBM)) {\n\t\tmp->m_rbmip->i_d.di_flags |= XFS_DIFLAG_NEWRTBM;\n\t\t*seqp = 0;\n\t}\n\tseq = *seqp;\n\tif ((log2 = xfs_highbit64(seq)) == -1)\n\t\tb = 0;\n\telse {\n\t\tresid = seq - (1ULL << log2);\n\t\tb = (mp->m_sb.sb_rextents * ((resid << 1) + 1ULL)) >>\n\t\t    (log2 + 1);\n\t\tif (b >= mp->m_sb.sb_rextents)\n\t\t\tb = do_mod(b, mp->m_sb.sb_rextents);\n\t\tif (b + len > mp->m_sb.sb_rextents)\n\t\t\tb = mp->m_sb.sb_rextents - len;\n\t}\n\t*seqp = seq + 1;\n\txfs_trans_log_inode(tp, mp->m_rbmip, XFS_ILOG_CORE);\n\t*pick = b;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_rtpick_extent(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_extlen_t\tlen,\t\t/* allocation length (rtextents) */\n\txfs_rtblock_t\t*pick)\t\t/* result rt extent */\n{\n\txfs_rtblock_t\tb;\t\t/* result block */\n\tint\t\tlog2;\t\t/* log of sequence number */\n\t__uint64_t\tresid;\t\t/* residual after log removed */\n\t__uint64_t\tseq;\t\t/* sequence number of file creation */\n\t__uint64_t\t*seqp;\t\t/* pointer to seqno in inode */\n\n\tASSERT(xfs_isilocked(mp->m_rbmip, XFS_ILOCK_EXCL));\n\n\tseqp = (__uint64_t *)&mp->m_rbmip->i_d.di_atime;\n\tif (!(mp->m_rbmip->i_d.di_flags & XFS_DIFLAG_NEWRTBM)) {\n\t\tmp->m_rbmip->i_d.di_flags |= XFS_DIFLAG_NEWRTBM;\n\t\t*seqp = 0;\n\t}\n\tseq = *seqp;\n\tif ((log2 = xfs_highbit64(seq)) == -1)\n\t\tb = 0;\n\telse {\n\t\tresid = seq - (1ULL << log2);\n\t\tb = (mp->m_sb.sb_rextents * ((resid << 1) + 1ULL)) >>\n\t\t    (log2 + 1);\n\t\tif (b >= mp->m_sb.sb_rextents)\n\t\t\tb = do_mod(b, mp->m_sb.sb_rextents);\n\t\tif (b + len > mp->m_sb.sb_rextents)\n\t\t\tb = mp->m_sb.sb_rextents - len;\n\t}\n\t*seqp = seq + 1;\n\txfs_trans_log_inode(tp, mp->m_rbmip, XFS_ILOG_CORE);\n\t*pick = b;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ijoin",
          "args": [
            "ap->tp",
            "mp->m_rbmip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ijoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "37-57",
          "snippet": "void\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "mp->m_rbmip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_mod",
          "args": [
            "ap->offset",
            "align"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ap->length % mp->m_sb.sb_rextsize == 0"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ap->length"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmap_extsize_align",
          "args": [
            "mp",
            "&ap->got",
            "&ap->prev",
            "align",
            "1",
            "ap->eof",
            "0",
            "ap->conv",
            "&ap->offset",
            "&ap->length"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_extsize_align",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "3204-3362",
          "snippet": "int\nxfs_bmap_extsize_align(\n\txfs_mount_t\t*mp,\n\txfs_bmbt_irec_t\t*gotp,\t\t/* next extent pointer */\n\txfs_bmbt_irec_t\t*prevp,\t\t/* previous extent pointer */\n\txfs_extlen_t\textsz,\t\t/* align to this extent size */\n\tint\t\trt,\t\t/* is this a realtime inode? */\n\tint\t\teof,\t\t/* is extent at end-of-file? */\n\tint\t\tdelay,\t\t/* creating delalloc extent? */\n\tint\t\tconvert,\t/* overwriting unwritten extent? */\n\txfs_fileoff_t\t*offp,\t\t/* in/out: aligned offset */\n\txfs_extlen_t\t*lenp)\t\t/* in/out: aligned length */\n{\n\txfs_fileoff_t\torig_off;\t/* original offset */\n\txfs_extlen_t\torig_alen;\t/* original length */\n\txfs_fileoff_t\torig_end;\t/* original off+len */\n\txfs_fileoff_t\tnexto;\t\t/* next file offset */\n\txfs_fileoff_t\tprevo;\t\t/* previous file offset */\n\txfs_fileoff_t\talign_off;\t/* temp for offset */\n\txfs_extlen_t\talign_alen;\t/* temp for length */\n\txfs_extlen_t\ttemp;\t\t/* temp for calculations */\n\n\tif (convert)\n\t\treturn 0;\n\n\torig_off = align_off = *offp;\n\torig_alen = align_alen = *lenp;\n\torig_end = orig_off + orig_alen;\n\n\t/*\n\t * If this request overlaps an existing extent, then don't\n\t * attempt to perform any additional alignment.\n\t */\n\tif (!delay && !eof &&\n\t    (orig_off >= gotp->br_startoff) &&\n\t    (orig_end <= gotp->br_startoff + gotp->br_blockcount)) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the file offset is unaligned vs. the extent size\n\t * we need to align it.  This will be possible unless\n\t * the file was previously written with a kernel that didn't\n\t * perform this alignment, or if a truncate shot us in the\n\t * foot.\n\t */\n\ttemp = do_mod(orig_off, extsz);\n\tif (temp) {\n\t\talign_alen += temp;\n\t\talign_off -= temp;\n\t}\n\t/*\n\t * Same adjustment for the end of the requested area.\n\t */\n\tif ((temp = (align_alen % extsz))) {\n\t\talign_alen += extsz - temp;\n\t}\n\t/*\n\t * If the previous block overlaps with this proposed allocation\n\t * then move the start forward without adjusting the length.\n\t */\n\tif (prevp->br_startoff != NULLFILEOFF) {\n\t\tif (prevp->br_startblock == HOLESTARTBLOCK)\n\t\t\tprevo = prevp->br_startoff;\n\t\telse\n\t\t\tprevo = prevp->br_startoff + prevp->br_blockcount;\n\t} else\n\t\tprevo = 0;\n\tif (align_off != orig_off && align_off < prevo)\n\t\talign_off = prevo;\n\t/*\n\t * If the next block overlaps with this proposed allocation\n\t * then move the start back without adjusting the length,\n\t * but not before offset 0.\n\t * This may of course make the start overlap previous block,\n\t * and if we hit the offset 0 limit then the next block\n\t * can still overlap too.\n\t */\n\tif (!eof && gotp->br_startoff != NULLFILEOFF) {\n\t\tif ((delay && gotp->br_startblock == HOLESTARTBLOCK) ||\n\t\t    (!delay && gotp->br_startblock == DELAYSTARTBLOCK))\n\t\t\tnexto = gotp->br_startoff + gotp->br_blockcount;\n\t\telse\n\t\t\tnexto = gotp->br_startoff;\n\t} else\n\t\tnexto = NULLFILEOFF;\n\tif (!eof &&\n\t    align_off + align_alen != orig_end &&\n\t    align_off + align_alen > nexto)\n\t\talign_off = nexto > align_alen ? nexto - align_alen : 0;\n\t/*\n\t * If we're now overlapping the next or previous extent that\n\t * means we can't fit an extsz piece in this hole.  Just move\n\t * the start forward to the first valid spot and set\n\t * the length so we hit the end.\n\t */\n\tif (align_off != orig_off && align_off < prevo)\n\t\talign_off = prevo;\n\tif (align_off + align_alen != orig_end &&\n\t    align_off + align_alen > nexto &&\n\t    nexto != NULLFILEOFF) {\n\t\tASSERT(nexto > prevo);\n\t\talign_alen = nexto - align_off;\n\t}\n\n\t/*\n\t * If realtime, and the result isn't a multiple of the realtime\n\t * extent size we need to remove blocks until it is.\n\t */\n\tif (rt && (temp = (align_alen % mp->m_sb.sb_rextsize))) {\n\t\t/*\n\t\t * We're not covering the original request, or\n\t\t * we won't be able to once we fix the length.\n\t\t */\n\t\tif (orig_off < align_off ||\n\t\t    orig_end > align_off + align_alen ||\n\t\t    align_alen - temp < orig_alen)\n\t\t\treturn -EINVAL;\n\t\t/*\n\t\t * Try to fix it by moving the start up.\n\t\t */\n\t\tif (align_off + temp <= orig_off) {\n\t\t\talign_alen -= temp;\n\t\t\talign_off += temp;\n\t\t}\n\t\t/*\n\t\t * Try to fix it by moving the end in.\n\t\t */\n\t\telse if (align_off + align_alen - temp >= orig_end)\n\t\t\talign_alen -= temp;\n\t\t/*\n\t\t * Set the start to the minimum then trim the length.\n\t\t */\n\t\telse {\n\t\t\talign_alen -= orig_off - align_off;\n\t\t\talign_off = orig_off;\n\t\t\talign_alen -= align_alen % mp->m_sb.sb_rextsize;\n\t\t}\n\t\t/*\n\t\t * Result doesn't cover the request, fail it.\n\t\t */\n\t\tif (orig_off < align_off || orig_end > align_off + align_alen)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tASSERT(orig_off >= align_off);\n\t\tASSERT(orig_end <= align_off + align_alen);\n\t}\n\n#ifdef DEBUG\n\tif (!eof && gotp->br_startoff != NULLFILEOFF)\n\t\tASSERT(align_off + align_alen <= gotp->br_startoff);\n\tif (prevp->br_startoff != NULLFILEOFF)\n\t\tASSERT(align_off >= prevp->br_startoff + prevp->br_blockcount);\n#endif\n\n\t*lenp = align_alen;\n\t*offp = align_off;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmap_extsize_align(\n\txfs_mount_t\t*mp,\n\txfs_bmbt_irec_t\t*gotp,\t\t/* next extent pointer */\n\txfs_bmbt_irec_t\t*prevp,\t\t/* previous extent pointer */\n\txfs_extlen_t\textsz,\t\t/* align to this extent size */\n\tint\t\trt,\t\t/* is this a realtime inode? */\n\tint\t\teof,\t\t/* is extent at end-of-file? */\n\tint\t\tdelay,\t\t/* creating delalloc extent? */\n\tint\t\tconvert,\t/* overwriting unwritten extent? */\n\txfs_fileoff_t\t*offp,\t\t/* in/out: aligned offset */\n\txfs_extlen_t\t*lenp)\t\t/* in/out: aligned length */\n{\n\txfs_fileoff_t\torig_off;\t/* original offset */\n\txfs_extlen_t\torig_alen;\t/* original length */\n\txfs_fileoff_t\torig_end;\t/* original off+len */\n\txfs_fileoff_t\tnexto;\t\t/* next file offset */\n\txfs_fileoff_t\tprevo;\t\t/* previous file offset */\n\txfs_fileoff_t\talign_off;\t/* temp for offset */\n\txfs_extlen_t\talign_alen;\t/* temp for length */\n\txfs_extlen_t\ttemp;\t\t/* temp for calculations */\n\n\tif (convert)\n\t\treturn 0;\n\n\torig_off = align_off = *offp;\n\torig_alen = align_alen = *lenp;\n\torig_end = orig_off + orig_alen;\n\n\t/*\n\t * If this request overlaps an existing extent, then don't\n\t * attempt to perform any additional alignment.\n\t */\n\tif (!delay && !eof &&\n\t    (orig_off >= gotp->br_startoff) &&\n\t    (orig_end <= gotp->br_startoff + gotp->br_blockcount)) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the file offset is unaligned vs. the extent size\n\t * we need to align it.  This will be possible unless\n\t * the file was previously written with a kernel that didn't\n\t * perform this alignment, or if a truncate shot us in the\n\t * foot.\n\t */\n\ttemp = do_mod(orig_off, extsz);\n\tif (temp) {\n\t\talign_alen += temp;\n\t\talign_off -= temp;\n\t}\n\t/*\n\t * Same adjustment for the end of the requested area.\n\t */\n\tif ((temp = (align_alen % extsz))) {\n\t\talign_alen += extsz - temp;\n\t}\n\t/*\n\t * If the previous block overlaps with this proposed allocation\n\t * then move the start forward without adjusting the length.\n\t */\n\tif (prevp->br_startoff != NULLFILEOFF) {\n\t\tif (prevp->br_startblock == HOLESTARTBLOCK)\n\t\t\tprevo = prevp->br_startoff;\n\t\telse\n\t\t\tprevo = prevp->br_startoff + prevp->br_blockcount;\n\t} else\n\t\tprevo = 0;\n\tif (align_off != orig_off && align_off < prevo)\n\t\talign_off = prevo;\n\t/*\n\t * If the next block overlaps with this proposed allocation\n\t * then move the start back without adjusting the length,\n\t * but not before offset 0.\n\t * This may of course make the start overlap previous block,\n\t * and if we hit the offset 0 limit then the next block\n\t * can still overlap too.\n\t */\n\tif (!eof && gotp->br_startoff != NULLFILEOFF) {\n\t\tif ((delay && gotp->br_startblock == HOLESTARTBLOCK) ||\n\t\t    (!delay && gotp->br_startblock == DELAYSTARTBLOCK))\n\t\t\tnexto = gotp->br_startoff + gotp->br_blockcount;\n\t\telse\n\t\t\tnexto = gotp->br_startoff;\n\t} else\n\t\tnexto = NULLFILEOFF;\n\tif (!eof &&\n\t    align_off + align_alen != orig_end &&\n\t    align_off + align_alen > nexto)\n\t\talign_off = nexto > align_alen ? nexto - align_alen : 0;\n\t/*\n\t * If we're now overlapping the next or previous extent that\n\t * means we can't fit an extsz piece in this hole.  Just move\n\t * the start forward to the first valid spot and set\n\t * the length so we hit the end.\n\t */\n\tif (align_off != orig_off && align_off < prevo)\n\t\talign_off = prevo;\n\tif (align_off + align_alen != orig_end &&\n\t    align_off + align_alen > nexto &&\n\t    nexto != NULLFILEOFF) {\n\t\tASSERT(nexto > prevo);\n\t\talign_alen = nexto - align_off;\n\t}\n\n\t/*\n\t * If realtime, and the result isn't a multiple of the realtime\n\t * extent size we need to remove blocks until it is.\n\t */\n\tif (rt && (temp = (align_alen % mp->m_sb.sb_rextsize))) {\n\t\t/*\n\t\t * We're not covering the original request, or\n\t\t * we won't be able to once we fix the length.\n\t\t */\n\t\tif (orig_off < align_off ||\n\t\t    orig_end > align_off + align_alen ||\n\t\t    align_alen - temp < orig_alen)\n\t\t\treturn -EINVAL;\n\t\t/*\n\t\t * Try to fix it by moving the start up.\n\t\t */\n\t\tif (align_off + temp <= orig_off) {\n\t\t\talign_alen -= temp;\n\t\t\talign_off += temp;\n\t\t}\n\t\t/*\n\t\t * Try to fix it by moving the end in.\n\t\t */\n\t\telse if (align_off + align_alen - temp >= orig_end)\n\t\t\talign_alen -= temp;\n\t\t/*\n\t\t * Set the start to the minimum then trim the length.\n\t\t */\n\t\telse {\n\t\t\talign_alen -= orig_off - align_off;\n\t\t\talign_off = orig_off;\n\t\t\talign_alen -= align_alen % mp->m_sb.sb_rextsize;\n\t\t}\n\t\t/*\n\t\t * Result doesn't cover the request, fail it.\n\t\t */\n\t\tif (orig_off < align_off || orig_end > align_off + align_alen)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tASSERT(orig_off >= align_off);\n\t\tASSERT(orig_end <= align_off + align_alen);\n\t}\n\n#ifdef DEBUG\n\tif (!eof && gotp->br_startoff != NULLFILEOFF)\n\t\tASSERT(align_off + align_alen <= gotp->br_startoff);\n\tif (prevp->br_startoff != NULLFILEOFF)\n\t\tASSERT(align_off >= prevp->br_startoff + prevp->br_blockcount);\n#endif\n\n\t*lenp = align_alen;\n\t*offp = align_off;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_get_extsz_hint",
          "args": [
            "ap->ip"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_get_extsz_hint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "67-76",
          "snippet": "xfs_extlen_t\nxfs_get_extsz_hint(\n\tstruct xfs_inode\t*ip)\n{\n\tif ((ip->i_d.di_flags & XFS_DIFLAG_EXTSIZE) && ip->i_d.di_extsize)\n\t\treturn ip->i_d.di_extsize;\n\tif (XFS_IS_REALTIME_INODE(ip))\n\t\treturn ip->i_mount->m_sb.sb_rextsize;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_extlen_t\nxfs_get_extsz_hint(\n\tstruct xfs_inode\t*ip)\n{\n\tif ((ip->i_d.di_flags & XFS_DIFLAG_EXTSIZE) && ip->i_d.di_extsize)\n\t\treturn ip->i_d.di_extsize;\n\tif (XFS_IS_REALTIME_INODE(ip))\n\t\treturn ip->i_mount->m_sb.sb_rextsize;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmap_rtalloc(\n\tstruct xfs_bmalloca\t*ap)\t/* bmap alloc argument struct */\n{\n\txfs_alloctype_t\tatype = 0;\t/* type for allocation routines */\n\tint\t\terror;\t\t/* error return value */\n\txfs_mount_t\t*mp;\t\t/* mount point structure */\n\txfs_extlen_t\tprod = 0;\t/* product factor for allocators */\n\txfs_extlen_t\tralen = 0;\t/* realtime allocation length */\n\txfs_extlen_t\talign;\t\t/* minimum allocation alignment */\n\txfs_rtblock_t\trtb;\n\n\tmp = ap->ip->i_mount;\n\talign = xfs_get_extsz_hint(ap->ip);\n\tprod = align / mp->m_sb.sb_rextsize;\n\terror = xfs_bmap_extsize_align(mp, &ap->got, &ap->prev,\n\t\t\t\t\talign, 1, ap->eof, 0,\n\t\t\t\t\tap->conv, &ap->offset, &ap->length);\n\tif (error)\n\t\treturn error;\n\tASSERT(ap->length);\n\tASSERT(ap->length % mp->m_sb.sb_rextsize == 0);\n\n\t/*\n\t * If the offset & length are not perfectly aligned\n\t * then kill prod, it will just get us in trouble.\n\t */\n\tif (do_mod(ap->offset, align) || ap->length % align)\n\t\tprod = 1;\n\t/*\n\t * Set ralen to be the actual requested length in rtextents.\n\t */\n\tralen = ap->length / mp->m_sb.sb_rextsize;\n\t/*\n\t * If the old value was close enough to MAXEXTLEN that\n\t * we rounded up to it, cut it back so it's valid again.\n\t * Note that if it's a really large request (bigger than\n\t * MAXEXTLEN), we don't hear about that number, and can't\n\t * adjust the starting point to match it.\n\t */\n\tif (ralen * mp->m_sb.sb_rextsize >= MAXEXTLEN)\n\t\tralen = MAXEXTLEN / mp->m_sb.sb_rextsize;\n\n\t/*\n\t * Lock out other modifications to the RT bitmap inode.\n\t */\n\txfs_ilock(mp->m_rbmip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(ap->tp, mp->m_rbmip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * If it's an allocation to an empty file at offset 0,\n\t * pick an extent that will space things out in the rt area.\n\t */\n\tif (ap->eof && ap->offset == 0) {\n\t\txfs_rtblock_t uninitialized_var(rtx); /* realtime extent no */\n\n\t\terror = xfs_rtpick_extent(mp, ap->tp, ralen, &rtx);\n\t\tif (error)\n\t\t\treturn error;\n\t\tap->blkno = rtx * mp->m_sb.sb_rextsize;\n\t} else {\n\t\tap->blkno = 0;\n\t}\n\n\txfs_bmap_adjacent(ap);\n\n\t/*\n\t * Realtime allocation, done through xfs_rtallocate_extent.\n\t */\n\tatype = ap->blkno == 0 ?  XFS_ALLOCTYPE_ANY_AG : XFS_ALLOCTYPE_NEAR_BNO;\n\tdo_div(ap->blkno, mp->m_sb.sb_rextsize);\n\trtb = ap->blkno;\n\tap->length = ralen;\n\tif ((error = xfs_rtallocate_extent(ap->tp, ap->blkno, 1, ap->length,\n\t\t\t\t&ralen, atype, ap->wasdel, prod, &rtb)))\n\t\treturn error;\n\tif (rtb == NULLFSBLOCK && prod > 1 &&\n\t    (error = xfs_rtallocate_extent(ap->tp, ap->blkno, 1,\n\t\t\t\t\t   ap->length, &ralen, atype,\n\t\t\t\t\t   ap->wasdel, 1, &rtb)))\n\t\treturn error;\n\tap->blkno = rtb;\n\tif (ap->blkno != NULLFSBLOCK) {\n\t\tap->blkno *= mp->m_sb.sb_rextsize;\n\t\tralen *= mp->m_sb.sb_rextsize;\n\t\tap->length = ralen;\n\t\tap->ip->i_d.di_nblocks += ralen;\n\t\txfs_trans_log_inode(ap->tp, ap->ip, XFS_ILOG_CORE);\n\t\tif (ap->wasdel)\n\t\t\tap->ip->i_delayed_blks -= ralen;\n\t\t/*\n\t\t * Adjust the disk quota also. This was reserved\n\t\t * earlier.\n\t\t */\n\t\txfs_trans_mod_dquot_byino(ap->tp, ap->ip,\n\t\t\tap->wasdel ? XFS_TRANS_DQ_DELRTBCOUNT :\n\t\t\t\t\tXFS_TRANS_DQ_RTBCOUNT, (long) ralen);\n\t} else {\n\t\tap->length = 0;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_bmap_finish",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
    "lines": "68-143",
    "snippet": "int\t\t\t\t\t\t/* error */\nxfs_bmap_finish(\n\txfs_trans_t\t\t**tp,\t\t/* transaction pointer addr */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*committed)\t/* xact committed or not */\n{\n\txfs_efd_log_item_t\t*efd;\t\t/* extent free data */\n\txfs_efi_log_item_t\t*efi;\t\t/* extent free intention */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_bmap_free_item_t\t*free;\t\t/* free extent item */\n\tstruct xfs_trans_res\ttres;\t\t/* new log reservation */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount structure */\n\txfs_bmap_free_item_t\t*next;\t\t/* next item on free list */\n\txfs_trans_t\t\t*ntp;\t\t/* new transaction pointer */\n\n\tASSERT((*tp)->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tif (flist->xbf_count == 0) {\n\t\t*committed = 0;\n\t\treturn 0;\n\t}\n\tntp = *tp;\n\tefi = xfs_trans_get_efi(ntp, flist->xbf_count);\n\tfor (free = flist->xbf_first; free; free = free->xbfi_next)\n\t\txfs_trans_log_efi_extent(ntp, efi, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\n\ttres.tr_logres = ntp->t_log_res;\n\ttres.tr_logcount = ntp->t_log_count;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\tntp = xfs_trans_dup(*tp);\n\terror = xfs_trans_commit(*tp, 0);\n\t*tp = ntp;\n\t*committed = 1;\n\t/*\n\t * We have a new transaction, so we should return committed=1,\n\t * even though we're returning an error.\n\t */\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(ntp->t_ticket);\n\n\terror = xfs_trans_reserve(ntp, &tres, 0, 0);\n\tif (error)\n\t\treturn error;\n\tefd = xfs_trans_get_efd(ntp, efi, flist->xbf_count);\n\tfor (free = flist->xbf_first; free != NULL; free = next) {\n\t\tnext = free->xbfi_next;\n\t\tif ((error = xfs_free_extent(ntp, free->xbfi_startblock,\n\t\t\t\tfree->xbfi_blockcount))) {\n\t\t\t/*\n\t\t\t * The bmap free list will be cleaned up at a\n\t\t\t * higher level.  The EFI will be canceled when\n\t\t\t * this transaction is aborted.\n\t\t\t * Need to force shutdown here to make sure it\n\t\t\t * happens, since this transaction may not be\n\t\t\t * dirty yet.\n\t\t\t */\n\t\t\tmp = ntp->t_mountp;\n\t\t\tif (!XFS_FORCED_SHUTDOWN(mp))\n\t\t\t\txfs_force_shutdown(mp,\n\t\t\t\t\t\t   (error == -EFSCORRUPTED) ?\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE :\n\t\t\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\txfs_trans_log_efd_extent(ntp, efd, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_bmap_del_free",
          "args": [
            "flist",
            "NULL",
            "free"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_del_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "641-653",
          "snippet": "void\nxfs_bmap_del_free(\n\txfs_bmap_free_t\t\t*flist,\t/* free item list header */\n\txfs_bmap_free_item_t\t*prev,\t/* previous item on list, if any */\n\txfs_bmap_free_item_t\t*free)\t/* list item to be freed */\n{\n\tif (prev)\n\t\tprev->xbfi_next = free->xbfi_next;\n\telse\n\t\tflist->xbf_first = free->xbfi_next;\n\tflist->xbf_count--;\n\tkmem_zone_free(xfs_bmap_free_item_zone, free);\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t\t*xfs_bmap_free_item_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t\t*xfs_bmap_free_item_zone;\n\nvoid\nxfs_bmap_del_free(\n\txfs_bmap_free_t\t\t*flist,\t/* free item list header */\n\txfs_bmap_free_item_t\t*prev,\t/* previous item on list, if any */\n\txfs_bmap_free_item_t\t*free)\t/* list item to be freed */\n{\n\tif (prev)\n\t\tprev->xbfi_next = free->xbfi_next;\n\telse\n\t\tflist->xbf_first = free->xbfi_next;\n\tflist->xbf_count--;\n\tkmem_zone_free(xfs_bmap_free_item_zone, free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_efd_extent",
          "args": [
            "ntp",
            "efd",
            "free->xbfi_startblock",
            "free->xbfi_blockcount"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_efd_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_extfree.c",
          "lines": "115-133",
          "snippet": "void\nxfs_trans_log_efd_extent(xfs_trans_t\t\t*tp,\n\t\t\t xfs_efd_log_item_t\t*efdp,\n\t\t\t xfs_fsblock_t\t\tstart_block,\n\t\t\t xfs_extlen_t\t\text_len)\n{\n\tuint\t\t\tnext_extent;\n\txfs_extent_t\t\t*extp;\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tefdp->efd_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\tnext_extent = efdp->efd_next_extent;\n\tASSERT(next_extent < efdp->efd_format.efd_nextents);\n\textp = &(efdp->efd_format.efd_extents[next_extent]);\n\textp->ext_start = start_block;\n\textp->ext_len = ext_len;\n\tefdp->efd_next_extent++;\n}",
          "includes": [
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_extfree_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_efd_extent(xfs_trans_t\t\t*tp,\n\t\t\t xfs_efd_log_item_t\t*efdp,\n\t\t\t xfs_fsblock_t\t\tstart_block,\n\t\t\t xfs_extlen_t\t\text_len)\n{\n\tuint\t\t\tnext_extent;\n\txfs_extent_t\t\t*extp;\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tefdp->efd_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\tnext_extent = efdp->efd_next_extent;\n\tASSERT(next_extent < efdp->efd_format.efd_nextents);\n\textp = &(efdp->efd_format.efd_extents[next_extent]);\n\textp->ext_start = start_block;\n\textp->ext_len = ext_len;\n\tefdp->efd_next_extent++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_force_shutdown",
          "args": [
            "mp",
            "(error == -EFSCORRUPTED) ?\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE :\n\t\t\t\t\t\t   SHUTDOWN_META_IO_ERROR"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_free_extent",
          "args": [
            "ntp",
            "free->xbfi_startblock",
            "free->xbfi_blockcount"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_free_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "2587-2633",
          "snippet": "int\t\t\t\t/* error */\nxfs_free_extent(\n\txfs_trans_t\t*tp,\t/* transaction pointer */\n\txfs_fsblock_t\tbno,\t/* starting block number of extent */\n\txfs_extlen_t\tlen)\t/* length of extent */\n{\n\txfs_alloc_arg_t\targs;\n\tint\t\terror;\n\n\tASSERT(len != 0);\n\tmemset(&args, 0, sizeof(xfs_alloc_arg_t));\n\targs.tp = tp;\n\targs.mp = tp->t_mountp;\n\n\t/*\n\t * validate that the block number is legal - the enables us to detect\n\t * and handle a silent filesystem corruption rather than crashing.\n\t */\n\targs.agno = XFS_FSB_TO_AGNO(args.mp, bno);\n\tif (args.agno >= args.mp->m_sb.sb_agcount)\n\t\treturn -EFSCORRUPTED;\n\n\targs.agbno = XFS_FSB_TO_AGBNO(args.mp, bno);\n\tif (args.agbno >= args.mp->m_sb.sb_agblocks)\n\t\treturn -EFSCORRUPTED;\n\n\targs.pag = xfs_perag_get(args.mp, args.agno);\n\tASSERT(args.pag);\n\n\terror = xfs_alloc_fix_freelist(&args, XFS_ALLOC_FLAG_FREEING);\n\tif (error)\n\t\tgoto error0;\n\n\t/* validate the extent size is legal now we have the agf locked */\n\tif (args.agbno + len >\n\t\t\tbe32_to_cpu(XFS_BUF_TO_AGF(args.agbp)->agf_length)) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\n\terror = xfs_free_ag_extent(tp, args.agbp, args.agno, args.agbno, len, 0);\n\tif (!error)\n\t\txfs_extent_busy_insert(tp, args.agno, args.agbno, len, 0);\nerror0:\n\txfs_perag_put(args.pag);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nint\t\t\t\t/* error */\nxfs_free_extent(\n\txfs_trans_t\t*tp,\t/* transaction pointer */\n\txfs_fsblock_t\tbno,\t/* starting block number of extent */\n\txfs_extlen_t\tlen)\t/* length of extent */\n{\n\txfs_alloc_arg_t\targs;\n\tint\t\terror;\n\n\tASSERT(len != 0);\n\tmemset(&args, 0, sizeof(xfs_alloc_arg_t));\n\targs.tp = tp;\n\targs.mp = tp->t_mountp;\n\n\t/*\n\t * validate that the block number is legal - the enables us to detect\n\t * and handle a silent filesystem corruption rather than crashing.\n\t */\n\targs.agno = XFS_FSB_TO_AGNO(args.mp, bno);\n\tif (args.agno >= args.mp->m_sb.sb_agcount)\n\t\treturn -EFSCORRUPTED;\n\n\targs.agbno = XFS_FSB_TO_AGBNO(args.mp, bno);\n\tif (args.agbno >= args.mp->m_sb.sb_agblocks)\n\t\treturn -EFSCORRUPTED;\n\n\targs.pag = xfs_perag_get(args.mp, args.agno);\n\tASSERT(args.pag);\n\n\terror = xfs_alloc_fix_freelist(&args, XFS_ALLOC_FLAG_FREEING);\n\tif (error)\n\t\tgoto error0;\n\n\t/* validate the extent size is legal now we have the agf locked */\n\tif (args.agbno + len >\n\t\t\tbe32_to_cpu(XFS_BUF_TO_AGF(args.agbp)->agf_length)) {\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\n\terror = xfs_free_ag_extent(tp, args.agbp, args.agno, args.agbno, len, 0);\n\tif (!error)\n\t\txfs_extent_busy_insert(tp, args.agno, args.agbno, len, 0);\nerror0:\n\txfs_perag_put(args.pag);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_get_efd",
          "args": [
            "ntp",
            "efi",
            "flist->xbf_count"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_get_efd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_extfree.c",
          "lines": "90-108",
          "snippet": "xfs_efd_log_item_t *\nxfs_trans_get_efd(xfs_trans_t\t\t*tp,\n\t\t  xfs_efi_log_item_t\t*efip,\n\t\t  uint\t\t\tnextents)\n{\n\txfs_efd_log_item_t\t*efdp;\n\n\tASSERT(tp != NULL);\n\tASSERT(nextents > 0);\n\n\tefdp = xfs_efd_init(tp->t_mountp, efip, nextents);\n\tASSERT(efdp != NULL);\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &efdp->efd_item);\n\treturn efdp;\n}",
          "includes": [
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_extfree_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_efd_log_item_t *\nxfs_trans_get_efd(xfs_trans_t\t\t*tp,\n\t\t  xfs_efi_log_item_t\t*efip,\n\t\t  uint\t\t\tnextents)\n{\n\txfs_efd_log_item_t\t*efdp;\n\n\tASSERT(tp != NULL);\n\tASSERT(nextents > 0);\n\n\tefdp = xfs_efd_init(tp->t_mountp, efip, nextents);\n\tASSERT(efdp != NULL);\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &efdp->efd_item);\n\treturn efdp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve",
          "args": [
            "ntp",
            "&tres",
            "0",
            "0"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "168-279",
          "snippet": "int\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_log_ticket_put",
          "args": [
            "ntp->t_ticket"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_ticket_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3496-3503",
          "snippet": "void\nxfs_log_ticket_put(\n\txlog_ticket_t\t*ticket)\n{\n\tASSERT(atomic_read(&ticket->t_ref) > 0);\n\tif (atomic_dec_and_test(&ticket->t_ref))\n\t\tkmem_zone_free(xfs_log_ticket_zone, ticket);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_log_ticket_zone;",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_log_ticket_zone;\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\n\nvoid\nxfs_log_ticket_put(\n\txlog_ticket_t\t*ticket)\n{\n\tASSERT(atomic_read(&ticket->t_ref) > 0);\n\tif (atomic_dec_and_test(&ticket->t_ref))\n\t\tkmem_zone_free(xfs_log_ticket_zone, ticket);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_commit",
          "args": [
            "*tp",
            "0"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "845-927",
          "snippet": "int\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_dup",
          "args": [
            "*tp"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_dup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "116-152",
          "snippet": "xfs_trans_t *\nxfs_trans_dup(\n\txfs_trans_t\t*tp)\n{\n\txfs_trans_t\t*ntp;\n\n\tntp = kmem_zone_zalloc(xfs_trans_zone, KM_SLEEP);\n\n\t/*\n\t * Initialize the new transaction structure.\n\t */\n\tntp->t_magic = XFS_TRANS_HEADER_MAGIC;\n\tntp->t_type = tp->t_type;\n\tntp->t_mountp = tp->t_mountp;\n\tINIT_LIST_HEAD(&ntp->t_items);\n\tINIT_LIST_HEAD(&ntp->t_busy);\n\n\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tASSERT(tp->t_ticket != NULL);\n\n\tntp->t_flags = XFS_TRANS_PERM_LOG_RES |\n\t\t       (tp->t_flags & XFS_TRANS_RESERVE) |\n\t\t       (tp->t_flags & XFS_TRANS_FREEZE_PROT);\n\t/* We gave our writer reference to the new transaction */\n\ttp->t_flags &= ~XFS_TRANS_FREEZE_PROT;\n\tntp->t_ticket = xfs_log_ticket_get(tp->t_ticket);\n\tntp->t_blk_res = tp->t_blk_res - tp->t_blk_res_used;\n\ttp->t_blk_res = tp->t_blk_res_used;\n\tntp->t_rtx_res = tp->t_rtx_res - tp->t_rtx_res_used;\n\ttp->t_rtx_res = tp->t_rtx_res_used;\n\tntp->t_pflags = tp->t_pflags;\n\n\txfs_trans_dup_dqinfo(tp, ntp);\n\n\tatomic_inc(&tp->t_mountp->m_active_trans);\n\treturn ntp;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_trans_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_trans_zone;\n\nxfs_trans_t *\nxfs_trans_dup(\n\txfs_trans_t\t*tp)\n{\n\txfs_trans_t\t*ntp;\n\n\tntp = kmem_zone_zalloc(xfs_trans_zone, KM_SLEEP);\n\n\t/*\n\t * Initialize the new transaction structure.\n\t */\n\tntp->t_magic = XFS_TRANS_HEADER_MAGIC;\n\tntp->t_type = tp->t_type;\n\tntp->t_mountp = tp->t_mountp;\n\tINIT_LIST_HEAD(&ntp->t_items);\n\tINIT_LIST_HEAD(&ntp->t_busy);\n\n\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tASSERT(tp->t_ticket != NULL);\n\n\tntp->t_flags = XFS_TRANS_PERM_LOG_RES |\n\t\t       (tp->t_flags & XFS_TRANS_RESERVE) |\n\t\t       (tp->t_flags & XFS_TRANS_FREEZE_PROT);\n\t/* We gave our writer reference to the new transaction */\n\ttp->t_flags &= ~XFS_TRANS_FREEZE_PROT;\n\tntp->t_ticket = xfs_log_ticket_get(tp->t_ticket);\n\tntp->t_blk_res = tp->t_blk_res - tp->t_blk_res_used;\n\ttp->t_blk_res = tp->t_blk_res_used;\n\tntp->t_rtx_res = tp->t_rtx_res - tp->t_rtx_res_used;\n\ttp->t_rtx_res = tp->t_rtx_res_used;\n\tntp->t_pflags = tp->t_pflags;\n\n\txfs_trans_dup_dqinfo(tp, ntp);\n\n\tatomic_inc(&tp->t_mountp->m_active_trans);\n\treturn ntp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_efi_extent",
          "args": [
            "ntp",
            "efi",
            "free->xbfi_startblock",
            "free->xbfi_blockcount"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_efi_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_extfree.c",
          "lines": "59-81",
          "snippet": "void\nxfs_trans_log_efi_extent(xfs_trans_t\t\t*tp,\n\t\t\t xfs_efi_log_item_t\t*efip,\n\t\t\t xfs_fsblock_t\t\tstart_block,\n\t\t\t xfs_extlen_t\t\text_len)\n{\n\tuint\t\t\tnext_extent;\n\txfs_extent_t\t\t*extp;\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tefip->efi_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * atomic_inc_return gives us the value after the increment;\n\t * we want to use it as an array index so we need to subtract 1 from\n\t * it.\n\t */\n\tnext_extent = atomic_inc_return(&efip->efi_next_extent) - 1;\n\tASSERT(next_extent < efip->efi_format.efi_nextents);\n\textp = &(efip->efi_format.efi_extents[next_extent]);\n\textp->ext_start = start_block;\n\textp->ext_len = ext_len;\n}",
          "includes": [
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_extfree_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_efi_extent(xfs_trans_t\t\t*tp,\n\t\t\t xfs_efi_log_item_t\t*efip,\n\t\t\t xfs_fsblock_t\t\tstart_block,\n\t\t\t xfs_extlen_t\t\text_len)\n{\n\tuint\t\t\tnext_extent;\n\txfs_extent_t\t\t*extp;\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tefip->efi_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * atomic_inc_return gives us the value after the increment;\n\t * we want to use it as an array index so we need to subtract 1 from\n\t * it.\n\t */\n\tnext_extent = atomic_inc_return(&efip->efi_next_extent) - 1;\n\tASSERT(next_extent < efip->efi_format.efi_nextents);\n\textp = &(efip->efi_format.efi_extents[next_extent]);\n\textp->ext_start = start_block;\n\textp->ext_len = ext_len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_get_efi",
          "args": [
            "ntp",
            "flist->xbf_count"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_get_efi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_extfree.c",
          "lines": "35-52",
          "snippet": "xfs_efi_log_item_t *\nxfs_trans_get_efi(xfs_trans_t\t*tp,\n\t\t  uint\t\tnextents)\n{\n\txfs_efi_log_item_t\t*efip;\n\n\tASSERT(tp != NULL);\n\tASSERT(nextents > 0);\n\n\tefip = xfs_efi_init(tp->t_mountp, nextents);\n\tASSERT(efip != NULL);\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &efip->efi_item);\n\treturn efip;\n}",
          "includes": [
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_extfree_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_efi_log_item_t *\nxfs_trans_get_efi(xfs_trans_t\t*tp,\n\t\t  uint\t\tnextents)\n{\n\txfs_efi_log_item_t\t*efip;\n\n\tASSERT(tp != NULL);\n\tASSERT(nextents > 0);\n\n\tefip = xfs_efi_init(tp->t_mountp, nextents);\n\tASSERT(efip != NULL);\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &efip->efi_item);\n\treturn efip;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(*tp)->t_flags & XFS_TRANS_PERM_LOG_RES"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error */\nxfs_bmap_finish(\n\txfs_trans_t\t\t**tp,\t\t/* transaction pointer addr */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*committed)\t/* xact committed or not */\n{\n\txfs_efd_log_item_t\t*efd;\t\t/* extent free data */\n\txfs_efi_log_item_t\t*efi;\t\t/* extent free intention */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_bmap_free_item_t\t*free;\t\t/* free extent item */\n\tstruct xfs_trans_res\ttres;\t\t/* new log reservation */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount structure */\n\txfs_bmap_free_item_t\t*next;\t\t/* next item on free list */\n\txfs_trans_t\t\t*ntp;\t\t/* new transaction pointer */\n\n\tASSERT((*tp)->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tif (flist->xbf_count == 0) {\n\t\t*committed = 0;\n\t\treturn 0;\n\t}\n\tntp = *tp;\n\tefi = xfs_trans_get_efi(ntp, flist->xbf_count);\n\tfor (free = flist->xbf_first; free; free = free->xbfi_next)\n\t\txfs_trans_log_efi_extent(ntp, efi, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\n\ttres.tr_logres = ntp->t_log_res;\n\ttres.tr_logcount = ntp->t_log_count;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\tntp = xfs_trans_dup(*tp);\n\terror = xfs_trans_commit(*tp, 0);\n\t*tp = ntp;\n\t*committed = 1;\n\t/*\n\t * We have a new transaction, so we should return committed=1,\n\t * even though we're returning an error.\n\t */\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(ntp->t_ticket);\n\n\terror = xfs_trans_reserve(ntp, &tres, 0, 0);\n\tif (error)\n\t\treturn error;\n\tefd = xfs_trans_get_efd(ntp, efi, flist->xbf_count);\n\tfor (free = flist->xbf_first; free != NULL; free = next) {\n\t\tnext = free->xbfi_next;\n\t\tif ((error = xfs_free_extent(ntp, free->xbfi_startblock,\n\t\t\t\tfree->xbfi_blockcount))) {\n\t\t\t/*\n\t\t\t * The bmap free list will be cleaned up at a\n\t\t\t * higher level.  The EFI will be canceled when\n\t\t\t * this transaction is aborted.\n\t\t\t * Need to force shutdown here to make sure it\n\t\t\t * happens, since this transaction may not be\n\t\t\t * dirty yet.\n\t\t\t */\n\t\t\tmp = ntp->t_mountp;\n\t\t\tif (!XFS_FORCED_SHUTDOWN(mp))\n\t\t\t\txfs_force_shutdown(mp,\n\t\t\t\t\t\t   (error == -EFSCORRUPTED) ?\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE :\n\t\t\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\txfs_trans_log_efd_extent(ntp, efd, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_fsb_to_db",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
    "lines": "51-57",
    "snippet": "xfs_daddr_t\nxfs_fsb_to_db(struct xfs_inode *ip, xfs_fsblock_t fsb)\n{\n\treturn (XFS_IS_REALTIME_INODE(ip) ? \\\n\t\t (xfs_daddr_t)XFS_FSB_TO_BB((ip)->i_mount, (fsb)) : \\\n\t\t XFS_FSB_TO_DADDR((ip)->i_mount, (fsb)));\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_FSB_TO_DADDR",
          "args": [
            "(ip)->i_mount",
            "(fsb)"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_BB",
          "args": [
            "(ip)->i_mount",
            "(fsb)"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_REALTIME_INODE",
          "args": [
            "ip"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_daddr_t\nxfs_fsb_to_db(struct xfs_inode *ip, xfs_fsblock_t fsb)\n{\n\treturn (XFS_IS_REALTIME_INODE(ip) ? \\\n\t\t (xfs_daddr_t)XFS_FSB_TO_BB((ip)->i_mount, (fsb)) : \\\n\t\t XFS_FSB_TO_DADDR((ip)->i_mount, (fsb)));\n}"
  }
]