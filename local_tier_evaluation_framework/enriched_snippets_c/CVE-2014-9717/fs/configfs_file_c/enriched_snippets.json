[
  {
    "function_name": "configfs_create_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/file.c",
    "lines": "322-335",
    "snippet": "int configfs_create_file(struct config_item * item, const struct configfs_attribute * attr)\n{\n\tstruct dentry *dir = item->ci_dentry;\n\tstruct configfs_dirent *parent_sd = dir->d_fsdata;\n\tumode_t mode = (attr->ca_mode & S_IALLUGO) | S_IFREG;\n\tint error = 0;\n\n\tmutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_NORMAL);\n\terror = configfs_make_dirent(parent_sd, NULL, (void *) attr, mode,\n\t\t\t\t     CONFIGFS_ITEM_ATTR);\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\n\treturn error;\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dir->d_inode->i_mutex"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "configfs_make_dirent",
          "args": [
            "parent_sd",
            "NULL",
            "(void *) attr",
            "mode",
            "CONFIGFS_ITEM_ATTR"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_make_dirent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "225-241",
          "snippet": "int configfs_make_dirent(struct configfs_dirent * parent_sd,\n\t\t\t struct dentry * dentry, void * element,\n\t\t\t umode_t mode, int type)\n{\n\tstruct configfs_dirent * sd;\n\n\tsd = configfs_new_dirent(parent_sd, element, type);\n\tif (IS_ERR(sd))\n\t\treturn PTR_ERR(sd);\n\n\tsd->s_mode = mode;\n\tsd->s_dentry = dentry;\n\tif (dentry)\n\t\tdentry->d_fsdata = configfs_get(sd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\n\nint configfs_make_dirent(struct configfs_dirent * parent_sd,\n\t\t\t struct dentry * dentry, void * element,\n\t\t\t umode_t mode, int type)\n{\n\tstruct configfs_dirent * sd;\n\n\tsd = configfs_new_dirent(parent_sd, element, type);\n\tif (IS_ERR(sd))\n\t\treturn PTR_ERR(sd);\n\n\tsd->s_mode = mode;\n\tsd->s_dentry = dentry;\n\tif (dentry)\n\t\tdentry->d_fsdata = configfs_get(sd);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&dir->d_inode->i_mutex",
            "I_MUTEX_NORMAL"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <asm/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nint configfs_create_file(struct config_item * item, const struct configfs_attribute * attr)\n{\n\tstruct dentry *dir = item->ci_dentry;\n\tstruct configfs_dirent *parent_sd = dir->d_fsdata;\n\tumode_t mode = (attr->ca_mode & S_IALLUGO) | S_IFREG;\n\tint error = 0;\n\n\tmutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_NORMAL);\n\terror = configfs_make_dirent(parent_sd, NULL, (void *) attr, mode,\n\t\t\t\t     CONFIGFS_ITEM_ATTR);\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\n\treturn error;\n}"
  },
  {
    "function_name": "configfs_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/file.c",
    "lines": "287-306",
    "snippet": "static int configfs_release(struct inode * inode, struct file * filp)\n{\n\tstruct config_item * item = to_item(filp->f_path.dentry->d_parent);\n\tstruct configfs_attribute * attr = to_attr(filp->f_path.dentry);\n\tstruct module * owner = attr->ca_owner;\n\tstruct configfs_buffer * buffer = filp->private_data;\n\n\tif (item)\n\t\tconfig_item_put(item);\n\t/* After this point, attr should not be accessed. */\n\tmodule_put(owner);\n\n\tif (buffer) {\n\t\tif (buffer->page)\n\t\t\tfree_page((unsigned long)buffer->page);\n\t\tmutex_destroy(&buffer->mutex);\n\t\tkfree(buffer);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buffer"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_destroy",
          "args": [
            "&buffer->mutex"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long)buffer->page"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_buf_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "238-246",
          "snippet": "STATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "owner"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config_item_put",
          "args": [
            "item"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "config_item_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/item.c",
          "lines": "171-175",
          "snippet": "void config_item_put(struct config_item *item)\n{\n\tif (item)\n\t\tkref_put(&item->ci_kref, config_item_release);\n}",
          "includes": [
            "#include <linux/configfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/module.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/module.h>\n#include <linux/string.h>\n\nvoid config_item_put(struct config_item *item)\n{\n\tif (item)\n\t\tkref_put(&item->ci_kref, config_item_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_attr",
          "args": [
            "filp->f_path.dentry"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "to_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/configfs_internal.h",
          "lines": "116-120",
          "snippet": "static inline struct configfs_attribute * to_attr(struct dentry * dentry)\n{\n\tstruct configfs_dirent * sd = dentry->d_fsdata;\n\treturn ((struct configfs_attribute *) sd->s_element);\n}",
          "includes": [
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int configfs_create_file(struct config_item *, const struct configfs_attribute *);",
            "extern int configfs_dirent_is_ready(struct configfs_dirent *);",
            "extern const unsigned char * configfs_get_name(struct configfs_dirent *sd);",
            "extern int configfs_unlink(struct inode *dir, struct dentry *dentry);",
            "extern int configfs_create_link(struct configfs_symlink *sl,\n\t\t\t\tstruct dentry *parent,\n\t\t\t\tstruct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n\nextern int configfs_create_file(struct config_item *, const struct configfs_attribute *);\nextern int configfs_dirent_is_ready(struct configfs_dirent *);\nextern const unsigned char * configfs_get_name(struct configfs_dirent *sd);\nextern int configfs_unlink(struct inode *dir, struct dentry *dentry);\nextern int configfs_create_link(struct configfs_symlink *sl,\n\t\t\t\tstruct dentry *parent,\n\t\t\t\tstruct dentry *dentry);\n\nstatic inline struct configfs_attribute * to_attr(struct dentry * dentry)\n{\n\tstruct configfs_dirent * sd = dentry->d_fsdata;\n\treturn ((struct configfs_attribute *) sd->s_element);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_item",
          "args": [
            "filp->f_path.dentry->d_parent"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "to_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/configfs_internal.h",
          "lines": "110-114",
          "snippet": "static inline struct config_item * to_item(struct dentry * dentry)\n{\n\tstruct configfs_dirent * sd = dentry->d_fsdata;\n\treturn ((struct config_item *) sd->s_element);\n}",
          "includes": [
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int configfs_dirent_is_ready(struct configfs_dirent *);",
            "extern const unsigned char * configfs_get_name(struct configfs_dirent *sd);",
            "extern int configfs_unlink(struct inode *dir, struct dentry *dentry);",
            "extern int configfs_create_link(struct configfs_symlink *sl,\n\t\t\t\tstruct dentry *parent,\n\t\t\t\tstruct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n\nextern int configfs_dirent_is_ready(struct configfs_dirent *);\nextern const unsigned char * configfs_get_name(struct configfs_dirent *sd);\nextern int configfs_unlink(struct inode *dir, struct dentry *dentry);\nextern int configfs_create_link(struct configfs_symlink *sl,\n\t\t\t\tstruct dentry *parent,\n\t\t\t\tstruct dentry *dentry);\n\nstatic inline struct config_item * to_item(struct dentry * dentry)\n{\n\tstruct configfs_dirent * sd = dentry->d_fsdata;\n\treturn ((struct config_item *) sd->s_element);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <asm/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int configfs_release(struct inode * inode, struct file * filp)\n{\n\tstruct config_item * item = to_item(filp->f_path.dentry->d_parent);\n\tstruct configfs_attribute * attr = to_attr(filp->f_path.dentry);\n\tstruct module * owner = attr->ca_owner;\n\tstruct configfs_buffer * buffer = filp->private_data;\n\n\tif (item)\n\t\tconfig_item_put(item);\n\t/* After this point, attr should not be accessed. */\n\tmodule_put(owner);\n\n\tif (buffer) {\n\t\tif (buffer->page)\n\t\t\tfree_page((unsigned long)buffer->page);\n\t\tmutex_destroy(&buffer->mutex);\n\t\tkfree(buffer);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "configfs_open_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/file.c",
    "lines": "282-285",
    "snippet": "static int configfs_open_file(struct inode * inode, struct file * filp)\n{\n\treturn check_perm(inode,filp);\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_perm",
          "args": [
            "inode",
            "filp"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "check_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/file.c",
          "lines": "213-280",
          "snippet": "static int check_perm(struct inode * inode, struct file * file)\n{\n\tstruct config_item *item = configfs_get_config_item(file->f_path.dentry->d_parent);\n\tstruct configfs_attribute * attr = to_attr(file->f_path.dentry);\n\tstruct configfs_buffer * buffer;\n\tstruct configfs_item_operations * ops = NULL;\n\tint error = 0;\n\n\tif (!item || !attr)\n\t\tgoto Einval;\n\n\t/* Grab the module reference for this attribute if we have one */\n\tif (!try_module_get(attr->ca_owner)) {\n\t\terror = -ENODEV;\n\t\tgoto Done;\n\t}\n\n\tif (item->ci_type)\n\t\tops = item->ci_type->ct_item_ops;\n\telse\n\t\tgoto Eaccess;\n\n\t/* File needs write support.\n\t * The inode's perms must say it's ok,\n\t * and we must have a store method.\n\t */\n\tif (file->f_mode & FMODE_WRITE) {\n\n\t\tif (!(inode->i_mode & S_IWUGO) || !ops->store_attribute)\n\t\t\tgoto Eaccess;\n\n\t}\n\n\t/* File needs read support.\n\t * The inode's perms must say it's ok, and we there\n\t * must be a show method for it.\n\t */\n\tif (file->f_mode & FMODE_READ) {\n\t\tif (!(inode->i_mode & S_IRUGO) || !ops->show_attribute)\n\t\t\tgoto Eaccess;\n\t}\n\n\t/* No error? Great, allocate a buffer for the file, and store it\n\t * it in file->private_data for easy access.\n\t */\n\tbuffer = kzalloc(sizeof(struct configfs_buffer),GFP_KERNEL);\n\tif (!buffer) {\n\t\terror = -ENOMEM;\n\t\tgoto Enomem;\n\t}\n\tmutex_init(&buffer->mutex);\n\tbuffer->needs_read_fill = 1;\n\tbuffer->ops = ops;\n\tfile->private_data = buffer;\n\tgoto Done;\n\n Einval:\n\terror = -EINVAL;\n\tgoto Done;\n Eaccess:\n\terror = -EACCES;\n Enomem:\n\tmodule_put(attr->ca_owner);\n Done:\n\tif (error && item)\n\t\tconfig_item_put(item);\n\treturn error;\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <asm/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int check_perm(struct inode * inode, struct file * file)\n{\n\tstruct config_item *item = configfs_get_config_item(file->f_path.dentry->d_parent);\n\tstruct configfs_attribute * attr = to_attr(file->f_path.dentry);\n\tstruct configfs_buffer * buffer;\n\tstruct configfs_item_operations * ops = NULL;\n\tint error = 0;\n\n\tif (!item || !attr)\n\t\tgoto Einval;\n\n\t/* Grab the module reference for this attribute if we have one */\n\tif (!try_module_get(attr->ca_owner)) {\n\t\terror = -ENODEV;\n\t\tgoto Done;\n\t}\n\n\tif (item->ci_type)\n\t\tops = item->ci_type->ct_item_ops;\n\telse\n\t\tgoto Eaccess;\n\n\t/* File needs write support.\n\t * The inode's perms must say it's ok,\n\t * and we must have a store method.\n\t */\n\tif (file->f_mode & FMODE_WRITE) {\n\n\t\tif (!(inode->i_mode & S_IWUGO) || !ops->store_attribute)\n\t\t\tgoto Eaccess;\n\n\t}\n\n\t/* File needs read support.\n\t * The inode's perms must say it's ok, and we there\n\t * must be a show method for it.\n\t */\n\tif (file->f_mode & FMODE_READ) {\n\t\tif (!(inode->i_mode & S_IRUGO) || !ops->show_attribute)\n\t\t\tgoto Eaccess;\n\t}\n\n\t/* No error? Great, allocate a buffer for the file, and store it\n\t * it in file->private_data for easy access.\n\t */\n\tbuffer = kzalloc(sizeof(struct configfs_buffer),GFP_KERNEL);\n\tif (!buffer) {\n\t\terror = -ENOMEM;\n\t\tgoto Enomem;\n\t}\n\tmutex_init(&buffer->mutex);\n\tbuffer->needs_read_fill = 1;\n\tbuffer->ops = ops;\n\tfile->private_data = buffer;\n\tgoto Done;\n\n Einval:\n\terror = -EINVAL;\n\tgoto Done;\n Eaccess:\n\terror = -EACCES;\n Enomem:\n\tmodule_put(attr->ca_owner);\n Done:\n\tif (error && item)\n\t\tconfig_item_put(item);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <asm/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int configfs_open_file(struct inode * inode, struct file * filp)\n{\n\treturn check_perm(inode,filp);\n}"
  },
  {
    "function_name": "check_perm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/file.c",
    "lines": "213-280",
    "snippet": "static int check_perm(struct inode * inode, struct file * file)\n{\n\tstruct config_item *item = configfs_get_config_item(file->f_path.dentry->d_parent);\n\tstruct configfs_attribute * attr = to_attr(file->f_path.dentry);\n\tstruct configfs_buffer * buffer;\n\tstruct configfs_item_operations * ops = NULL;\n\tint error = 0;\n\n\tif (!item || !attr)\n\t\tgoto Einval;\n\n\t/* Grab the module reference for this attribute if we have one */\n\tif (!try_module_get(attr->ca_owner)) {\n\t\terror = -ENODEV;\n\t\tgoto Done;\n\t}\n\n\tif (item->ci_type)\n\t\tops = item->ci_type->ct_item_ops;\n\telse\n\t\tgoto Eaccess;\n\n\t/* File needs write support.\n\t * The inode's perms must say it's ok,\n\t * and we must have a store method.\n\t */\n\tif (file->f_mode & FMODE_WRITE) {\n\n\t\tif (!(inode->i_mode & S_IWUGO) || !ops->store_attribute)\n\t\t\tgoto Eaccess;\n\n\t}\n\n\t/* File needs read support.\n\t * The inode's perms must say it's ok, and we there\n\t * must be a show method for it.\n\t */\n\tif (file->f_mode & FMODE_READ) {\n\t\tif (!(inode->i_mode & S_IRUGO) || !ops->show_attribute)\n\t\t\tgoto Eaccess;\n\t}\n\n\t/* No error? Great, allocate a buffer for the file, and store it\n\t * it in file->private_data for easy access.\n\t */\n\tbuffer = kzalloc(sizeof(struct configfs_buffer),GFP_KERNEL);\n\tif (!buffer) {\n\t\terror = -ENOMEM;\n\t\tgoto Enomem;\n\t}\n\tmutex_init(&buffer->mutex);\n\tbuffer->needs_read_fill = 1;\n\tbuffer->ops = ops;\n\tfile->private_data = buffer;\n\tgoto Done;\n\n Einval:\n\terror = -EINVAL;\n\tgoto Done;\n Eaccess:\n\terror = -EACCES;\n Enomem:\n\tmodule_put(attr->ca_owner);\n Done:\n\tif (error && item)\n\t\tconfig_item_put(item);\n\treturn error;\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "config_item_put",
          "args": [
            "item"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "config_item_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/item.c",
          "lines": "171-175",
          "snippet": "void config_item_put(struct config_item *item)\n{\n\tif (item)\n\t\tkref_put(&item->ci_kref, config_item_release);\n}",
          "includes": [
            "#include <linux/configfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/module.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/module.h>\n#include <linux/string.h>\n\nvoid config_item_put(struct config_item *item)\n{\n\tif (item)\n\t\tkref_put(&item->ci_kref, config_item_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "attr->ca_owner"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&buffer->mutex"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct configfs_buffer)",
            "GFP_KERNEL"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_module_get",
          "args": [
            "attr->ca_owner"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_attr",
          "args": [
            "file->f_path.dentry"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "to_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/configfs_internal.h",
          "lines": "116-120",
          "snippet": "static inline struct configfs_attribute * to_attr(struct dentry * dentry)\n{\n\tstruct configfs_dirent * sd = dentry->d_fsdata;\n\treturn ((struct configfs_attribute *) sd->s_element);\n}",
          "includes": [
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int configfs_create_file(struct config_item *, const struct configfs_attribute *);",
            "extern int configfs_dirent_is_ready(struct configfs_dirent *);",
            "extern const unsigned char * configfs_get_name(struct configfs_dirent *sd);",
            "extern int configfs_unlink(struct inode *dir, struct dentry *dentry);",
            "extern int configfs_create_link(struct configfs_symlink *sl,\n\t\t\t\tstruct dentry *parent,\n\t\t\t\tstruct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n\nextern int configfs_create_file(struct config_item *, const struct configfs_attribute *);\nextern int configfs_dirent_is_ready(struct configfs_dirent *);\nextern const unsigned char * configfs_get_name(struct configfs_dirent *sd);\nextern int configfs_unlink(struct inode *dir, struct dentry *dentry);\nextern int configfs_create_link(struct configfs_symlink *sl,\n\t\t\t\tstruct dentry *parent,\n\t\t\t\tstruct dentry *dentry);\n\nstatic inline struct configfs_attribute * to_attr(struct dentry * dentry)\n{\n\tstruct configfs_dirent * sd = dentry->d_fsdata;\n\treturn ((struct configfs_attribute *) sd->s_element);\n}"
        }
      },
      {
        "call_info": {
          "callee": "configfs_get_config_item",
          "args": [
            "file->f_path.dentry->d_parent"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_get_config_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/configfs_internal.h",
          "lines": "122-138",
          "snippet": "static inline struct config_item *configfs_get_config_item(struct dentry *dentry)\n{\n\tstruct config_item * item = NULL;\n\n\tspin_lock(&dentry->d_lock);\n\tif (!d_unhashed(dentry)) {\n\t\tstruct configfs_dirent * sd = dentry->d_fsdata;\n\t\tif (sd->s_type & CONFIGFS_ITEM_LINK) {\n\t\t\tstruct configfs_symlink * sl = sd->s_element;\n\t\t\titem = config_item_get(sl->sl_target);\n\t\t} else\n\t\t\titem = config_item_get(sd->s_element);\n\t}\n\tspin_unlock(&dentry->d_lock);\n\n\treturn item;\n}",
          "includes": [
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define CONFIGFS_ITEM_LINK\t0x0020"
          ],
          "globals_used": [
            "extern int configfs_is_root(struct config_item *item);",
            "extern int configfs_dirent_is_ready(struct configfs_dirent *);",
            "extern const unsigned char * configfs_get_name(struct configfs_dirent *sd);",
            "extern int configfs_unlink(struct inode *dir, struct dentry *dentry);",
            "extern int configfs_create_link(struct configfs_symlink *sl,\n\t\t\t\tstruct dentry *parent,\n\t\t\t\tstruct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n\n#define CONFIGFS_ITEM_LINK\t0x0020\n\nextern int configfs_is_root(struct config_item *item);\nextern int configfs_dirent_is_ready(struct configfs_dirent *);\nextern const unsigned char * configfs_get_name(struct configfs_dirent *sd);\nextern int configfs_unlink(struct inode *dir, struct dentry *dentry);\nextern int configfs_create_link(struct configfs_symlink *sl,\n\t\t\t\tstruct dentry *parent,\n\t\t\t\tstruct dentry *dentry);\n\nstatic inline struct config_item *configfs_get_config_item(struct dentry *dentry)\n{\n\tstruct config_item * item = NULL;\n\n\tspin_lock(&dentry->d_lock);\n\tif (!d_unhashed(dentry)) {\n\t\tstruct configfs_dirent * sd = dentry->d_fsdata;\n\t\tif (sd->s_type & CONFIGFS_ITEM_LINK) {\n\t\t\tstruct configfs_symlink * sl = sd->s_element;\n\t\t\titem = config_item_get(sl->sl_target);\n\t\t} else\n\t\t\titem = config_item_get(sd->s_element);\n\t}\n\tspin_unlock(&dentry->d_lock);\n\n\treturn item;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <asm/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int check_perm(struct inode * inode, struct file * file)\n{\n\tstruct config_item *item = configfs_get_config_item(file->f_path.dentry->d_parent);\n\tstruct configfs_attribute * attr = to_attr(file->f_path.dentry);\n\tstruct configfs_buffer * buffer;\n\tstruct configfs_item_operations * ops = NULL;\n\tint error = 0;\n\n\tif (!item || !attr)\n\t\tgoto Einval;\n\n\t/* Grab the module reference for this attribute if we have one */\n\tif (!try_module_get(attr->ca_owner)) {\n\t\terror = -ENODEV;\n\t\tgoto Done;\n\t}\n\n\tif (item->ci_type)\n\t\tops = item->ci_type->ct_item_ops;\n\telse\n\t\tgoto Eaccess;\n\n\t/* File needs write support.\n\t * The inode's perms must say it's ok,\n\t * and we must have a store method.\n\t */\n\tif (file->f_mode & FMODE_WRITE) {\n\n\t\tif (!(inode->i_mode & S_IWUGO) || !ops->store_attribute)\n\t\t\tgoto Eaccess;\n\n\t}\n\n\t/* File needs read support.\n\t * The inode's perms must say it's ok, and we there\n\t * must be a show method for it.\n\t */\n\tif (file->f_mode & FMODE_READ) {\n\t\tif (!(inode->i_mode & S_IRUGO) || !ops->show_attribute)\n\t\t\tgoto Eaccess;\n\t}\n\n\t/* No error? Great, allocate a buffer for the file, and store it\n\t * it in file->private_data for easy access.\n\t */\n\tbuffer = kzalloc(sizeof(struct configfs_buffer),GFP_KERNEL);\n\tif (!buffer) {\n\t\terror = -ENOMEM;\n\t\tgoto Enomem;\n\t}\n\tmutex_init(&buffer->mutex);\n\tbuffer->needs_read_fill = 1;\n\tbuffer->ops = ops;\n\tfile->private_data = buffer;\n\tgoto Done;\n\n Einval:\n\terror = -EINVAL;\n\tgoto Done;\n Eaccess:\n\terror = -EACCES;\n Enomem:\n\tmodule_put(attr->ca_owner);\n Done:\n\tif (error && item)\n\t\tconfig_item_put(item);\n\treturn error;\n}"
  },
  {
    "function_name": "configfs_write_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/file.c",
    "lines": "197-211",
    "snippet": "static ssize_t\nconfigfs_write_file(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct configfs_buffer * buffer = file->private_data;\n\tssize_t len;\n\n\tmutex_lock(&buffer->mutex);\n\tlen = fill_write_buffer(buffer, buf, count);\n\tif (len > 0)\n\t\tlen = flush_write_buffer(file->f_path.dentry, buffer, len);\n\tif (len > 0)\n\t\t*ppos += len;\n\tmutex_unlock(&buffer->mutex);\n\treturn len;\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&buffer->mutex"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_write_buffer",
          "args": [
            "file->f_path.dentry",
            "buffer",
            "len"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "flush_write_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/file.c",
          "lines": "169-177",
          "snippet": "static int\nflush_write_buffer(struct dentry * dentry, struct configfs_buffer * buffer, size_t count)\n{\n\tstruct configfs_attribute * attr = to_attr(dentry);\n\tstruct config_item * item = to_item(dentry->d_parent);\n\tstruct configfs_item_operations * ops = buffer->ops;\n\n\treturn ops->store_attribute(item,attr,buffer->page,count);\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <asm/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int\nflush_write_buffer(struct dentry * dentry, struct configfs_buffer * buffer, size_t count)\n{\n\tstruct configfs_attribute * attr = to_attr(dentry);\n\tstruct config_item * item = to_item(dentry->d_parent);\n\tstruct configfs_item_operations * ops = buffer->ops;\n\n\treturn ops->store_attribute(item,attr,buffer->page,count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_write_buffer",
          "args": [
            "buffer",
            "buf",
            "count"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "fill_write_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/file.c",
          "lines": "137-155",
          "snippet": "static int\nfill_write_buffer(struct configfs_buffer * buffer, const char __user * buf, size_t count)\n{\n\tint error;\n\n\tif (!buffer->page)\n\t\tbuffer->page = (char *)__get_free_pages(GFP_KERNEL, 0);\n\tif (!buffer->page)\n\t\treturn -ENOMEM;\n\n\tif (count >= SIMPLE_ATTR_SIZE)\n\t\tcount = SIMPLE_ATTR_SIZE - 1;\n\terror = copy_from_user(buffer->page,buf,count);\n\tbuffer->needs_read_fill = 1;\n\t/* if buf is assumed to contain a string, terminate it by \\0,\n\t * so e.g. sscanf() can scan the string easily */\n\tbuffer->page[count] = 0;\n\treturn error ? -EFAULT : count;\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define SIMPLE_ATTR_SIZE 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <asm/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\n#define SIMPLE_ATTR_SIZE 4096\n\nstatic int\nfill_write_buffer(struct configfs_buffer * buffer, const char __user * buf, size_t count)\n{\n\tint error;\n\n\tif (!buffer->page)\n\t\tbuffer->page = (char *)__get_free_pages(GFP_KERNEL, 0);\n\tif (!buffer->page)\n\t\treturn -ENOMEM;\n\n\tif (count >= SIMPLE_ATTR_SIZE)\n\t\tcount = SIMPLE_ATTR_SIZE - 1;\n\terror = copy_from_user(buffer->page,buf,count);\n\tbuffer->needs_read_fill = 1;\n\t/* if buf is assumed to contain a string, terminate it by \\0,\n\t * so e.g. sscanf() can scan the string easily */\n\tbuffer->page[count] = 0;\n\treturn error ? -EFAULT : count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&buffer->mutex"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <asm/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic ssize_t\nconfigfs_write_file(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct configfs_buffer * buffer = file->private_data;\n\tssize_t len;\n\n\tmutex_lock(&buffer->mutex);\n\tlen = fill_write_buffer(buffer, buf, count);\n\tif (len > 0)\n\t\tlen = flush_write_buffer(file->f_path.dentry, buffer, len);\n\tif (len > 0)\n\t\t*ppos += len;\n\tmutex_unlock(&buffer->mutex);\n\treturn len;\n}"
  },
  {
    "function_name": "flush_write_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/file.c",
    "lines": "169-177",
    "snippet": "static int\nflush_write_buffer(struct dentry * dentry, struct configfs_buffer * buffer, size_t count)\n{\n\tstruct configfs_attribute * attr = to_attr(dentry);\n\tstruct config_item * item = to_item(dentry->d_parent);\n\tstruct configfs_item_operations * ops = buffer->ops;\n\n\treturn ops->store_attribute(item,attr,buffer->page,count);\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ops->store_attribute",
          "args": [
            "item",
            "attr",
            "buffer->page",
            "count"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_item",
          "args": [
            "dentry->d_parent"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "to_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/configfs_internal.h",
          "lines": "110-114",
          "snippet": "static inline struct config_item * to_item(struct dentry * dentry)\n{\n\tstruct configfs_dirent * sd = dentry->d_fsdata;\n\treturn ((struct config_item *) sd->s_element);\n}",
          "includes": [
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int configfs_dirent_is_ready(struct configfs_dirent *);",
            "extern const unsigned char * configfs_get_name(struct configfs_dirent *sd);",
            "extern int configfs_unlink(struct inode *dir, struct dentry *dentry);",
            "extern int configfs_create_link(struct configfs_symlink *sl,\n\t\t\t\tstruct dentry *parent,\n\t\t\t\tstruct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n\nextern int configfs_dirent_is_ready(struct configfs_dirent *);\nextern const unsigned char * configfs_get_name(struct configfs_dirent *sd);\nextern int configfs_unlink(struct inode *dir, struct dentry *dentry);\nextern int configfs_create_link(struct configfs_symlink *sl,\n\t\t\t\tstruct dentry *parent,\n\t\t\t\tstruct dentry *dentry);\n\nstatic inline struct config_item * to_item(struct dentry * dentry)\n{\n\tstruct configfs_dirent * sd = dentry->d_fsdata;\n\treturn ((struct config_item *) sd->s_element);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_attr",
          "args": [
            "dentry"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "to_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/configfs_internal.h",
          "lines": "116-120",
          "snippet": "static inline struct configfs_attribute * to_attr(struct dentry * dentry)\n{\n\tstruct configfs_dirent * sd = dentry->d_fsdata;\n\treturn ((struct configfs_attribute *) sd->s_element);\n}",
          "includes": [
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int configfs_create_file(struct config_item *, const struct configfs_attribute *);",
            "extern int configfs_dirent_is_ready(struct configfs_dirent *);",
            "extern const unsigned char * configfs_get_name(struct configfs_dirent *sd);",
            "extern int configfs_unlink(struct inode *dir, struct dentry *dentry);",
            "extern int configfs_create_link(struct configfs_symlink *sl,\n\t\t\t\tstruct dentry *parent,\n\t\t\t\tstruct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n\nextern int configfs_create_file(struct config_item *, const struct configfs_attribute *);\nextern int configfs_dirent_is_ready(struct configfs_dirent *);\nextern const unsigned char * configfs_get_name(struct configfs_dirent *sd);\nextern int configfs_unlink(struct inode *dir, struct dentry *dentry);\nextern int configfs_create_link(struct configfs_symlink *sl,\n\t\t\t\tstruct dentry *parent,\n\t\t\t\tstruct dentry *dentry);\n\nstatic inline struct configfs_attribute * to_attr(struct dentry * dentry)\n{\n\tstruct configfs_dirent * sd = dentry->d_fsdata;\n\treturn ((struct configfs_attribute *) sd->s_element);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <asm/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int\nflush_write_buffer(struct dentry * dentry, struct configfs_buffer * buffer, size_t count)\n{\n\tstruct configfs_attribute * attr = to_attr(dentry);\n\tstruct config_item * item = to_item(dentry->d_parent);\n\tstruct configfs_item_operations * ops = buffer->ops;\n\n\treturn ops->store_attribute(item,attr,buffer->page,count);\n}"
  },
  {
    "function_name": "fill_write_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/file.c",
    "lines": "137-155",
    "snippet": "static int\nfill_write_buffer(struct configfs_buffer * buffer, const char __user * buf, size_t count)\n{\n\tint error;\n\n\tif (!buffer->page)\n\t\tbuffer->page = (char *)__get_free_pages(GFP_KERNEL, 0);\n\tif (!buffer->page)\n\t\treturn -ENOMEM;\n\n\tif (count >= SIMPLE_ATTR_SIZE)\n\t\tcount = SIMPLE_ATTR_SIZE - 1;\n\terror = copy_from_user(buffer->page,buf,count);\n\tbuffer->needs_read_fill = 1;\n\t/* if buf is assumed to contain a string, terminate it by \\0,\n\t * so e.g. sscanf() can scan the string easily */\n\tbuffer->page[count] = 0;\n\treturn error ? -EFAULT : count;\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define SIMPLE_ATTR_SIZE 4096"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "buffer->page",
            "buf",
            "count"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_free_pages",
          "args": [
            "GFP_KERNEL",
            "0"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <asm/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\n#define SIMPLE_ATTR_SIZE 4096\n\nstatic int\nfill_write_buffer(struct configfs_buffer * buffer, const char __user * buf, size_t count)\n{\n\tint error;\n\n\tif (!buffer->page)\n\t\tbuffer->page = (char *)__get_free_pages(GFP_KERNEL, 0);\n\tif (!buffer->page)\n\t\treturn -ENOMEM;\n\n\tif (count >= SIMPLE_ATTR_SIZE)\n\t\tcount = SIMPLE_ATTR_SIZE - 1;\n\terror = copy_from_user(buffer->page,buf,count);\n\tbuffer->needs_read_fill = 1;\n\t/* if buf is assumed to contain a string, terminate it by \\0,\n\t * so e.g. sscanf() can scan the string easily */\n\tbuffer->page[count] = 0;\n\treturn error ? -EFAULT : count;\n}"
  },
  {
    "function_name": "configfs_read_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/file.c",
    "lines": "106-124",
    "snippet": "static ssize_t\nconfigfs_read_file(struct file *file, char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct configfs_buffer * buffer = file->private_data;\n\tssize_t retval = 0;\n\n\tmutex_lock(&buffer->mutex);\n\tif (buffer->needs_read_fill) {\n\t\tif ((retval = fill_read_buffer(file->f_path.dentry,buffer)))\n\t\t\tgoto out;\n\t}\n\tpr_debug(\"%s: count = %zd, ppos = %lld, buf = %s\\n\",\n\t\t __func__, count, *ppos, buffer->page);\n\tretval = simple_read_from_buffer(buf, count, ppos, buffer->page,\n\t\t\t\t\t buffer->count);\nout:\n\tmutex_unlock(&buffer->mutex);\n\treturn retval;\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&buffer->mutex"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "count",
            "ppos",
            "buffer->page",
            "buffer->count"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "simple_read_from_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "590-608",
          "snippet": "ssize_t simple_read_from_buffer(void __user *to, size_t count, loff_t *ppos,\n\t\t\t\tconst void *from, size_t available)\n{\n\tloff_t pos = *ppos;\n\tsize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available || !count)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tret = copy_to_user(to, from + pos, count);\n\tif (ret == count)\n\t\treturn -EFAULT;\n\tcount -= ret;\n\t*ppos = pos + count;\n\treturn count;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nssize_t simple_read_from_buffer(void __user *to, size_t count, loff_t *ppos,\n\t\t\t\tconst void *from, size_t available)\n{\n\tloff_t pos = *ppos;\n\tsize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available || !count)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tret = copy_to_user(to, from + pos, count);\n\tif (ret == count)\n\t\treturn -EFAULT;\n\tcount -= ret;\n\t*ppos = pos + count;\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: count = %zd, ppos = %lld, buf = %s\\n\"",
            "__func__",
            "count",
            "*ppos",
            "buffer->page"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill_read_buffer",
          "args": [
            "file->f_path.dentry",
            "buffer"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "fill_read_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/file.c",
          "lines": "64-85",
          "snippet": "static int fill_read_buffer(struct dentry * dentry, struct configfs_buffer * buffer)\n{\n\tstruct configfs_attribute * attr = to_attr(dentry);\n\tstruct config_item * item = to_item(dentry->d_parent);\n\tstruct configfs_item_operations * ops = buffer->ops;\n\tint ret = 0;\n\tssize_t count;\n\n\tif (!buffer->page)\n\t\tbuffer->page = (char *) get_zeroed_page(GFP_KERNEL);\n\tif (!buffer->page)\n\t\treturn -ENOMEM;\n\n\tcount = ops->show_attribute(item,attr,buffer->page);\n\tbuffer->needs_read_fill = 0;\n\tBUG_ON(count > (ssize_t)SIMPLE_ATTR_SIZE);\n\tif (count >= 0)\n\t\tbuffer->count = count;\n\telse\n\t\tret = count;\n\treturn ret;\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define SIMPLE_ATTR_SIZE 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <asm/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\n#define SIMPLE_ATTR_SIZE 4096\n\nstatic int fill_read_buffer(struct dentry * dentry, struct configfs_buffer * buffer)\n{\n\tstruct configfs_attribute * attr = to_attr(dentry);\n\tstruct config_item * item = to_item(dentry->d_parent);\n\tstruct configfs_item_operations * ops = buffer->ops;\n\tint ret = 0;\n\tssize_t count;\n\n\tif (!buffer->page)\n\t\tbuffer->page = (char *) get_zeroed_page(GFP_KERNEL);\n\tif (!buffer->page)\n\t\treturn -ENOMEM;\n\n\tcount = ops->show_attribute(item,attr,buffer->page);\n\tbuffer->needs_read_fill = 0;\n\tBUG_ON(count > (ssize_t)SIMPLE_ATTR_SIZE);\n\tif (count >= 0)\n\t\tbuffer->count = count;\n\telse\n\t\tret = count;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&buffer->mutex"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <asm/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic ssize_t\nconfigfs_read_file(struct file *file, char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct configfs_buffer * buffer = file->private_data;\n\tssize_t retval = 0;\n\n\tmutex_lock(&buffer->mutex);\n\tif (buffer->needs_read_fill) {\n\t\tif ((retval = fill_read_buffer(file->f_path.dentry,buffer)))\n\t\t\tgoto out;\n\t}\n\tpr_debug(\"%s: count = %zd, ppos = %lld, buf = %s\\n\",\n\t\t __func__, count, *ppos, buffer->page);\n\tretval = simple_read_from_buffer(buf, count, ppos, buffer->page,\n\t\t\t\t\t buffer->count);\nout:\n\tmutex_unlock(&buffer->mutex);\n\treturn retval;\n}"
  },
  {
    "function_name": "fill_read_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/file.c",
    "lines": "64-85",
    "snippet": "static int fill_read_buffer(struct dentry * dentry, struct configfs_buffer * buffer)\n{\n\tstruct configfs_attribute * attr = to_attr(dentry);\n\tstruct config_item * item = to_item(dentry->d_parent);\n\tstruct configfs_item_operations * ops = buffer->ops;\n\tint ret = 0;\n\tssize_t count;\n\n\tif (!buffer->page)\n\t\tbuffer->page = (char *) get_zeroed_page(GFP_KERNEL);\n\tif (!buffer->page)\n\t\treturn -ENOMEM;\n\n\tcount = ops->show_attribute(item,attr,buffer->page);\n\tbuffer->needs_read_fill = 0;\n\tBUG_ON(count > (ssize_t)SIMPLE_ATTR_SIZE);\n\tif (count >= 0)\n\t\tbuffer->count = count;\n\telse\n\t\tret = count;\n\treturn ret;\n}",
    "includes": [
      "#include \"configfs_internal.h\"",
      "#include <linux/configfs.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define SIMPLE_ATTR_SIZE 4096"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "count > (ssize_t)SIMPLE_ATTR_SIZE"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->show_attribute",
          "args": [
            "item",
            "attr",
            "buffer->page"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_zeroed_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_item",
          "args": [
            "dentry->d_parent"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "to_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/configfs_internal.h",
          "lines": "110-114",
          "snippet": "static inline struct config_item * to_item(struct dentry * dentry)\n{\n\tstruct configfs_dirent * sd = dentry->d_fsdata;\n\treturn ((struct config_item *) sd->s_element);\n}",
          "includes": [
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int configfs_dirent_is_ready(struct configfs_dirent *);",
            "extern const unsigned char * configfs_get_name(struct configfs_dirent *sd);",
            "extern int configfs_unlink(struct inode *dir, struct dentry *dentry);",
            "extern int configfs_create_link(struct configfs_symlink *sl,\n\t\t\t\tstruct dentry *parent,\n\t\t\t\tstruct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n\nextern int configfs_dirent_is_ready(struct configfs_dirent *);\nextern const unsigned char * configfs_get_name(struct configfs_dirent *sd);\nextern int configfs_unlink(struct inode *dir, struct dentry *dentry);\nextern int configfs_create_link(struct configfs_symlink *sl,\n\t\t\t\tstruct dentry *parent,\n\t\t\t\tstruct dentry *dentry);\n\nstatic inline struct config_item * to_item(struct dentry * dentry)\n{\n\tstruct configfs_dirent * sd = dentry->d_fsdata;\n\treturn ((struct config_item *) sd->s_element);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_attr",
          "args": [
            "dentry"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "to_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/configfs_internal.h",
          "lines": "116-120",
          "snippet": "static inline struct configfs_attribute * to_attr(struct dentry * dentry)\n{\n\tstruct configfs_dirent * sd = dentry->d_fsdata;\n\treturn ((struct configfs_attribute *) sd->s_element);\n}",
          "includes": [
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int configfs_create_file(struct config_item *, const struct configfs_attribute *);",
            "extern int configfs_dirent_is_ready(struct configfs_dirent *);",
            "extern const unsigned char * configfs_get_name(struct configfs_dirent *sd);",
            "extern int configfs_unlink(struct inode *dir, struct dentry *dentry);",
            "extern int configfs_create_link(struct configfs_symlink *sl,\n\t\t\t\tstruct dentry *parent,\n\t\t\t\tstruct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n\nextern int configfs_create_file(struct config_item *, const struct configfs_attribute *);\nextern int configfs_dirent_is_ready(struct configfs_dirent *);\nextern const unsigned char * configfs_get_name(struct configfs_dirent *sd);\nextern int configfs_unlink(struct inode *dir, struct dentry *dentry);\nextern int configfs_create_link(struct configfs_symlink *sl,\n\t\t\t\tstruct dentry *parent,\n\t\t\t\tstruct dentry *dentry);\n\nstatic inline struct configfs_attribute * to_attr(struct dentry * dentry)\n{\n\tstruct configfs_dirent * sd = dentry->d_fsdata;\n\treturn ((struct configfs_attribute *) sd->s_element);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <asm/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\n#define SIMPLE_ATTR_SIZE 4096\n\nstatic int fill_read_buffer(struct dentry * dentry, struct configfs_buffer * buffer)\n{\n\tstruct configfs_attribute * attr = to_attr(dentry);\n\tstruct config_item * item = to_item(dentry->d_parent);\n\tstruct configfs_item_operations * ops = buffer->ops;\n\tint ret = 0;\n\tssize_t count;\n\n\tif (!buffer->page)\n\t\tbuffer->page = (char *) get_zeroed_page(GFP_KERNEL);\n\tif (!buffer->page)\n\t\treturn -ENOMEM;\n\n\tcount = ops->show_attribute(item,attr,buffer->page);\n\tbuffer->needs_read_fill = 0;\n\tBUG_ON(count > (ssize_t)SIMPLE_ATTR_SIZE);\n\tif (count >= 0)\n\t\tbuffer->count = count;\n\telse\n\t\tret = count;\n\treturn ret;\n}"
  }
]