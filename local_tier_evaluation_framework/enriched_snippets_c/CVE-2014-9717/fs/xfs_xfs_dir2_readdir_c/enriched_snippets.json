[
  {
    "function_name": "xfs_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dir2_readdir.c",
    "lines": "647-681",
    "snippet": "int\nxfs_readdir(\n\tstruct xfs_inode\t*dp,\n\tstruct dir_context\t*ctx,\n\tsize_t\t\t\tbufsize)\n{\n\tstruct xfs_da_args\targs = { NULL };\n\tint\t\t\trval;\n\tint\t\t\tv;\n\tuint\t\t\tlock_mode;\n\n\ttrace_xfs_readdir(dp);\n\n\tif (XFS_FORCED_SHUTDOWN(dp->i_mount))\n\t\treturn -EIO;\n\n\tASSERT(S_ISDIR(dp->i_d.di_mode));\n\tXFS_STATS_INC(xs_dir_getdents);\n\n\targs.dp = dp;\n\targs.geo = dp->i_mount->m_dir_geo;\n\n\tlock_mode = xfs_ilock_data_map_shared(dp);\n\tif (dp->i_d.di_format == XFS_DINODE_FMT_LOCAL)\n\t\trval = xfs_dir2_sf_getdents(&args, ctx);\n\telse if ((rval = xfs_dir2_isblock(&args, &v)))\n\t\t;\n\telse if (v)\n\t\trval = xfs_dir2_block_getdents(&args, ctx);\n\telse\n\t\trval = xfs_dir2_leaf_getdents(&args, ctx, bufsize);\n\txfs_iunlock(dp, lock_mode);\n\n\treturn rval;\n}",
    "includes": [
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "dp",
            "lock_mode"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leaf_getdents",
          "args": [
            "&args",
            "ctx",
            "bufsize"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leaf_getdents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dir2_readdir.c",
          "lines": "469-642",
          "snippet": "STATIC int\nxfs_dir2_leaf_getdents(\n\tstruct xfs_da_args\t*args,\n\tstruct dir_context\t*ctx,\n\tsize_t\t\t\tbufsize)\n{\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_buf\t\t*bp = NULL;\t/* data block buffer */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry */\n\tint\t\t\terror = 0;\t/* error return value */\n\tint\t\t\tlength;\t\t/* temporary length value */\n\tint\t\t\tbyteoff;\t/* offset in current block */\n\txfs_dir2_off_t\t\tcuroff;\t\t/* current overall offset */\n\txfs_dir2_off_t\t\tnewoff;\t\t/* new curoff after new blk */\n\tchar\t\t\t*ptr = NULL;\t/* pointer to current data */\n\tstruct xfs_dir2_leaf_map_info *map_info;\n\tstruct xfs_da_geometry\t*geo = args->geo;\n\n\t/*\n\t * If the offset is at or past the largest allowed value,\n\t * give up right away.\n\t */\n\tif (ctx->pos >= XFS_DIR2_MAX_DATAPTR)\n\t\treturn 0;\n\n\t/*\n\t * Set up to bmap a number of blocks based on the caller's\n\t * buffer size, the directory block size, and the filesystem\n\t * block size.\n\t */\n\tlength = howmany(bufsize + geo->blksize, (1 << geo->fsblog));\n\tmap_info = kmem_zalloc(offsetof(struct xfs_dir2_leaf_map_info, map) +\n\t\t\t\t(length * sizeof(struct xfs_bmbt_irec)),\n\t\t\t       KM_SLEEP | KM_NOFS);\n\tmap_info->map_size = length;\n\n\t/*\n\t * Inside the loop we keep the main offset value as a byte offset\n\t * in the directory file.\n\t */\n\tcuroff = xfs_dir2_dataptr_to_byte(ctx->pos);\n\n\t/*\n\t * Force this conversion through db so we truncate the offset\n\t * down to get the start of the data block.\n\t */\n\tmap_info->map_off = xfs_dir2_db_to_da(geo,\n\t\t\t\t\t      xfs_dir2_byte_to_db(geo, curoff));\n\n\t/*\n\t * Loop over directory entries until we reach the end offset.\n\t * Get more blocks and readahead as necessary.\n\t */\n\twhile (curoff < XFS_DIR2_LEAF_OFFSET) {\n\t\t__uint8_t filetype;\n\n\t\t/*\n\t\t * If we have no buffer, or we're off the end of the\n\t\t * current buffer, need to get another one.\n\t\t */\n\t\tif (!bp || ptr >= (char *)bp->b_addr + geo->blksize) {\n\n\t\t\terror = xfs_dir2_leaf_readbuf(args, bufsize, map_info,\n\t\t\t\t\t\t      &curoff, &bp);\n\t\t\tif (error || !map_info->map_valid)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * Having done a read, we need to set a new offset.\n\t\t\t */\n\t\t\tnewoff = xfs_dir2_db_off_to_byte(geo,\n\t\t\t\t\t\t\t map_info->curdb, 0);\n\t\t\t/*\n\t\t\t * Start of the current block.\n\t\t\t */\n\t\t\tif (curoff < newoff)\n\t\t\t\tcuroff = newoff;\n\t\t\t/*\n\t\t\t * Make sure we're in the right block.\n\t\t\t */\n\t\t\telse if (curoff > newoff)\n\t\t\t\tASSERT(xfs_dir2_byte_to_db(geo, curoff) ==\n\t\t\t\t       map_info->curdb);\n\t\t\thdr = bp->b_addr;\n\t\t\txfs_dir3_data_check(dp, bp);\n\t\t\t/*\n\t\t\t * Find our position in the block.\n\t\t\t */\n\t\t\tptr = (char *)dp->d_ops->data_entry_p(hdr);\n\t\t\tbyteoff = xfs_dir2_byte_to_off(geo, curoff);\n\t\t\t/*\n\t\t\t * Skip past the header.\n\t\t\t */\n\t\t\tif (byteoff == 0)\n\t\t\t\tcuroff += dp->d_ops->data_entry_offset;\n\t\t\t/*\n\t\t\t * Skip past entries until we reach our offset.\n\t\t\t */\n\t\t\telse {\n\t\t\t\twhile ((char *)ptr - (char *)hdr < byteoff) {\n\t\t\t\t\tdup = (xfs_dir2_data_unused_t *)ptr;\n\n\t\t\t\t\tif (be16_to_cpu(dup->freetag)\n\t\t\t\t\t\t  == XFS_DIR2_DATA_FREE_TAG) {\n\n\t\t\t\t\t\tlength = be16_to_cpu(dup->length);\n\t\t\t\t\t\tptr += length;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdep = (xfs_dir2_data_entry_t *)ptr;\n\t\t\t\t\tlength =\n\t\t\t\t\t   dp->d_ops->data_entsize(dep->namelen);\n\t\t\t\t\tptr += length;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Now set our real offset.\n\t\t\t\t */\n\t\t\t\tcuroff =\n\t\t\t\t\txfs_dir2_db_off_to_byte(geo,\n\t\t\t\t\t    xfs_dir2_byte_to_db(geo, curoff),\n\t\t\t\t\t    (char *)ptr - (char *)hdr);\n\t\t\t\tif (ptr >= (char *)hdr + geo->blksize) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * We have a pointer to an entry.\n\t\t * Is it a live one?\n\t\t */\n\t\tdup = (xfs_dir2_data_unused_t *)ptr;\n\t\t/*\n\t\t * No, it's unused, skip over it.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tlength = be16_to_cpu(dup->length);\n\t\t\tptr += length;\n\t\t\tcuroff += length;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdep = (xfs_dir2_data_entry_t *)ptr;\n\t\tlength = dp->d_ops->data_entsize(dep->namelen);\n\t\tfiletype = dp->d_ops->data_get_ftype(dep);\n\n\t\tctx->pos = xfs_dir2_byte_to_dataptr(curoff) & 0x7fffffff;\n\t\tif (!dir_emit(ctx, (char *)dep->name, dep->namelen,\n\t\t\t    be64_to_cpu(dep->inumber),\n\t\t\t    xfs_dir3_get_dtype(dp->i_mount, filetype)))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Advance to next entry in the block.\n\t\t */\n\t\tptr += length;\n\t\tcuroff += length;\n\t\t/* bufsize may have just been a guess; don't go negative */\n\t\tbufsize = bufsize > length ? bufsize - length : 0;\n\t}\n\n\t/*\n\t * All done.  Set output offset value to current offset.\n\t */\n\tif (curoff > xfs_dir2_dataptr_to_byte(XFS_DIR2_MAX_DATAPTR))\n\t\tctx->pos = XFS_DIR2_MAX_DATAPTR & 0x7fffffff;\n\telse\n\t\tctx->pos = xfs_dir2_byte_to_dataptr(curoff) & 0x7fffffff;\n\tkmem_free(map_info);\n\tif (bp)\n\t\txfs_trans_brelse(NULL, bp);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_dir2_leaf_getdents(\n\tstruct xfs_da_args\t*args,\n\tstruct dir_context\t*ctx,\n\tsize_t\t\t\tbufsize)\n{\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_buf\t\t*bp = NULL;\t/* data block buffer */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry */\n\tint\t\t\terror = 0;\t/* error return value */\n\tint\t\t\tlength;\t\t/* temporary length value */\n\tint\t\t\tbyteoff;\t/* offset in current block */\n\txfs_dir2_off_t\t\tcuroff;\t\t/* current overall offset */\n\txfs_dir2_off_t\t\tnewoff;\t\t/* new curoff after new blk */\n\tchar\t\t\t*ptr = NULL;\t/* pointer to current data */\n\tstruct xfs_dir2_leaf_map_info *map_info;\n\tstruct xfs_da_geometry\t*geo = args->geo;\n\n\t/*\n\t * If the offset is at or past the largest allowed value,\n\t * give up right away.\n\t */\n\tif (ctx->pos >= XFS_DIR2_MAX_DATAPTR)\n\t\treturn 0;\n\n\t/*\n\t * Set up to bmap a number of blocks based on the caller's\n\t * buffer size, the directory block size, and the filesystem\n\t * block size.\n\t */\n\tlength = howmany(bufsize + geo->blksize, (1 << geo->fsblog));\n\tmap_info = kmem_zalloc(offsetof(struct xfs_dir2_leaf_map_info, map) +\n\t\t\t\t(length * sizeof(struct xfs_bmbt_irec)),\n\t\t\t       KM_SLEEP | KM_NOFS);\n\tmap_info->map_size = length;\n\n\t/*\n\t * Inside the loop we keep the main offset value as a byte offset\n\t * in the directory file.\n\t */\n\tcuroff = xfs_dir2_dataptr_to_byte(ctx->pos);\n\n\t/*\n\t * Force this conversion through db so we truncate the offset\n\t * down to get the start of the data block.\n\t */\n\tmap_info->map_off = xfs_dir2_db_to_da(geo,\n\t\t\t\t\t      xfs_dir2_byte_to_db(geo, curoff));\n\n\t/*\n\t * Loop over directory entries until we reach the end offset.\n\t * Get more blocks and readahead as necessary.\n\t */\n\twhile (curoff < XFS_DIR2_LEAF_OFFSET) {\n\t\t__uint8_t filetype;\n\n\t\t/*\n\t\t * If we have no buffer, or we're off the end of the\n\t\t * current buffer, need to get another one.\n\t\t */\n\t\tif (!bp || ptr >= (char *)bp->b_addr + geo->blksize) {\n\n\t\t\terror = xfs_dir2_leaf_readbuf(args, bufsize, map_info,\n\t\t\t\t\t\t      &curoff, &bp);\n\t\t\tif (error || !map_info->map_valid)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * Having done a read, we need to set a new offset.\n\t\t\t */\n\t\t\tnewoff = xfs_dir2_db_off_to_byte(geo,\n\t\t\t\t\t\t\t map_info->curdb, 0);\n\t\t\t/*\n\t\t\t * Start of the current block.\n\t\t\t */\n\t\t\tif (curoff < newoff)\n\t\t\t\tcuroff = newoff;\n\t\t\t/*\n\t\t\t * Make sure we're in the right block.\n\t\t\t */\n\t\t\telse if (curoff > newoff)\n\t\t\t\tASSERT(xfs_dir2_byte_to_db(geo, curoff) ==\n\t\t\t\t       map_info->curdb);\n\t\t\thdr = bp->b_addr;\n\t\t\txfs_dir3_data_check(dp, bp);\n\t\t\t/*\n\t\t\t * Find our position in the block.\n\t\t\t */\n\t\t\tptr = (char *)dp->d_ops->data_entry_p(hdr);\n\t\t\tbyteoff = xfs_dir2_byte_to_off(geo, curoff);\n\t\t\t/*\n\t\t\t * Skip past the header.\n\t\t\t */\n\t\t\tif (byteoff == 0)\n\t\t\t\tcuroff += dp->d_ops->data_entry_offset;\n\t\t\t/*\n\t\t\t * Skip past entries until we reach our offset.\n\t\t\t */\n\t\t\telse {\n\t\t\t\twhile ((char *)ptr - (char *)hdr < byteoff) {\n\t\t\t\t\tdup = (xfs_dir2_data_unused_t *)ptr;\n\n\t\t\t\t\tif (be16_to_cpu(dup->freetag)\n\t\t\t\t\t\t  == XFS_DIR2_DATA_FREE_TAG) {\n\n\t\t\t\t\t\tlength = be16_to_cpu(dup->length);\n\t\t\t\t\t\tptr += length;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdep = (xfs_dir2_data_entry_t *)ptr;\n\t\t\t\t\tlength =\n\t\t\t\t\t   dp->d_ops->data_entsize(dep->namelen);\n\t\t\t\t\tptr += length;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Now set our real offset.\n\t\t\t\t */\n\t\t\t\tcuroff =\n\t\t\t\t\txfs_dir2_db_off_to_byte(geo,\n\t\t\t\t\t    xfs_dir2_byte_to_db(geo, curoff),\n\t\t\t\t\t    (char *)ptr - (char *)hdr);\n\t\t\t\tif (ptr >= (char *)hdr + geo->blksize) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * We have a pointer to an entry.\n\t\t * Is it a live one?\n\t\t */\n\t\tdup = (xfs_dir2_data_unused_t *)ptr;\n\t\t/*\n\t\t * No, it's unused, skip over it.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tlength = be16_to_cpu(dup->length);\n\t\t\tptr += length;\n\t\t\tcuroff += length;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdep = (xfs_dir2_data_entry_t *)ptr;\n\t\tlength = dp->d_ops->data_entsize(dep->namelen);\n\t\tfiletype = dp->d_ops->data_get_ftype(dep);\n\n\t\tctx->pos = xfs_dir2_byte_to_dataptr(curoff) & 0x7fffffff;\n\t\tif (!dir_emit(ctx, (char *)dep->name, dep->namelen,\n\t\t\t    be64_to_cpu(dep->inumber),\n\t\t\t    xfs_dir3_get_dtype(dp->i_mount, filetype)))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Advance to next entry in the block.\n\t\t */\n\t\tptr += length;\n\t\tcuroff += length;\n\t\t/* bufsize may have just been a guess; don't go negative */\n\t\tbufsize = bufsize > length ? bufsize - length : 0;\n\t}\n\n\t/*\n\t * All done.  Set output offset value to current offset.\n\t */\n\tif (curoff > xfs_dir2_dataptr_to_byte(XFS_DIR2_MAX_DATAPTR))\n\t\tctx->pos = XFS_DIR2_MAX_DATAPTR & 0x7fffffff;\n\telse\n\t\tctx->pos = xfs_dir2_byte_to_dataptr(curoff) & 0x7fffffff;\n\tkmem_free(map_info);\n\tif (bp)\n\t\txfs_trans_brelse(NULL, bp);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_getdents",
          "args": [
            "&args",
            "ctx"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_getdents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dir2_readdir.c",
          "lines": "157-251",
          "snippet": "STATIC int\nxfs_dir2_block_getdents(\n\tstruct xfs_da_args\t*args,\n\tstruct dir_context\t*ctx)\n{\n\tstruct xfs_inode\t*dp = args->dp;\t/* incore directory inode */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\tstruct xfs_buf\t\t*bp;\t\t/* buffer for block */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* block data entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* block unused entry */\n\tchar\t\t\t*endptr;\t/* end of the data entries */\n\tint\t\t\terror;\t\t/* error return value */\n\tchar\t\t\t*ptr;\t\t/* current data entry */\n\tint\t\t\twantoff;\t/* starting block offset */\n\txfs_off_t\t\tcook;\n\tstruct xfs_da_geometry\t*geo = args->geo;\n\n\t/*\n\t * If the block number in the offset is out of range, we're done.\n\t */\n\tif (xfs_dir2_dataptr_to_db(geo, ctx->pos) > geo->datablk)\n\t\treturn 0;\n\n\terror = xfs_dir3_block_read(NULL, dp, &bp);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Extract the byte offset we start at from the seek pointer.\n\t * We'll skip entries before this.\n\t */\n\twantoff = xfs_dir2_dataptr_to_off(geo, ctx->pos);\n\thdr = bp->b_addr;\n\txfs_dir3_data_check(dp, bp);\n\t/*\n\t * Set up values for the loop.\n\t */\n\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\tptr = (char *)dp->d_ops->data_entry_p(hdr);\n\tendptr = (char *)xfs_dir2_block_leaf_p(btp);\n\n\t/*\n\t * Loop over the data portion of the block.\n\t * Each object is a real entry (dep) or an unused one (dup).\n\t */\n\twhile (ptr < endptr) {\n\t\t__uint8_t filetype;\n\n\t\tdup = (xfs_dir2_data_unused_t *)ptr;\n\t\t/*\n\t\t * Unused, skip it.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tptr += be16_to_cpu(dup->length);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdep = (xfs_dir2_data_entry_t *)ptr;\n\n\t\t/*\n\t\t * Bump pointer for the next iteration.\n\t\t */\n\t\tptr += dp->d_ops->data_entsize(dep->namelen);\n\t\t/*\n\t\t * The entry is before the desired starting point, skip it.\n\t\t */\n\t\tif ((char *)dep - (char *)hdr < wantoff)\n\t\t\tcontinue;\n\n\t\tcook = xfs_dir2_db_off_to_dataptr(geo, geo->datablk,\n\t\t\t\t\t    (char *)dep - (char *)hdr);\n\n\t\tctx->pos = cook & 0x7fffffff;\n\t\tfiletype = dp->d_ops->data_get_ftype(dep);\n\t\t/*\n\t\t * If it didn't fit, set the final offset to here & return.\n\t\t */\n\t\tif (!dir_emit(ctx, (char *)dep->name, dep->namelen,\n\t\t\t    be64_to_cpu(dep->inumber),\n\t\t\t    xfs_dir3_get_dtype(dp->i_mount, filetype))) {\n\t\t\txfs_trans_brelse(NULL, bp);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Reached the end of the block.\n\t * Set the offset to a non-existent block 1 and return.\n\t */\n\tctx->pos = xfs_dir2_db_off_to_dataptr(geo, geo->datablk + 1, 0) &\n\t\t\t\t\t\t\t\t0x7fffffff;\n\txfs_trans_brelse(NULL, bp);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_dir2_block_getdents(\n\tstruct xfs_da_args\t*args,\n\tstruct dir_context\t*ctx)\n{\n\tstruct xfs_inode\t*dp = args->dp;\t/* incore directory inode */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\tstruct xfs_buf\t\t*bp;\t\t/* buffer for block */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* block data entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* block unused entry */\n\tchar\t\t\t*endptr;\t/* end of the data entries */\n\tint\t\t\terror;\t\t/* error return value */\n\tchar\t\t\t*ptr;\t\t/* current data entry */\n\tint\t\t\twantoff;\t/* starting block offset */\n\txfs_off_t\t\tcook;\n\tstruct xfs_da_geometry\t*geo = args->geo;\n\n\t/*\n\t * If the block number in the offset is out of range, we're done.\n\t */\n\tif (xfs_dir2_dataptr_to_db(geo, ctx->pos) > geo->datablk)\n\t\treturn 0;\n\n\terror = xfs_dir3_block_read(NULL, dp, &bp);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Extract the byte offset we start at from the seek pointer.\n\t * We'll skip entries before this.\n\t */\n\twantoff = xfs_dir2_dataptr_to_off(geo, ctx->pos);\n\thdr = bp->b_addr;\n\txfs_dir3_data_check(dp, bp);\n\t/*\n\t * Set up values for the loop.\n\t */\n\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\tptr = (char *)dp->d_ops->data_entry_p(hdr);\n\tendptr = (char *)xfs_dir2_block_leaf_p(btp);\n\n\t/*\n\t * Loop over the data portion of the block.\n\t * Each object is a real entry (dep) or an unused one (dup).\n\t */\n\twhile (ptr < endptr) {\n\t\t__uint8_t filetype;\n\n\t\tdup = (xfs_dir2_data_unused_t *)ptr;\n\t\t/*\n\t\t * Unused, skip it.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tptr += be16_to_cpu(dup->length);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdep = (xfs_dir2_data_entry_t *)ptr;\n\n\t\t/*\n\t\t * Bump pointer for the next iteration.\n\t\t */\n\t\tptr += dp->d_ops->data_entsize(dep->namelen);\n\t\t/*\n\t\t * The entry is before the desired starting point, skip it.\n\t\t */\n\t\tif ((char *)dep - (char *)hdr < wantoff)\n\t\t\tcontinue;\n\n\t\tcook = xfs_dir2_db_off_to_dataptr(geo, geo->datablk,\n\t\t\t\t\t    (char *)dep - (char *)hdr);\n\n\t\tctx->pos = cook & 0x7fffffff;\n\t\tfiletype = dp->d_ops->data_get_ftype(dep);\n\t\t/*\n\t\t * If it didn't fit, set the final offset to here & return.\n\t\t */\n\t\tif (!dir_emit(ctx, (char *)dep->name, dep->namelen,\n\t\t\t    be64_to_cpu(dep->inumber),\n\t\t\t    xfs_dir3_get_dtype(dp->i_mount, filetype))) {\n\t\t\txfs_trans_brelse(NULL, bp);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Reached the end of the block.\n\t * Set the offset to a non-existent block 1 and return.\n\t */\n\tctx->pos = xfs_dir2_db_off_to_dataptr(geo, geo->datablk + 1, 0) &\n\t\t\t\t\t\t\t\t0x7fffffff;\n\txfs_trans_brelse(NULL, bp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_isblock",
          "args": [
            "&args",
            "&v"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_isblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
          "lines": "619-633",
          "snippet": "int\nxfs_dir2_isblock(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\t*vp)\t/* out: 1 is block, 0 is not block */\n{\n\txfs_fileoff_t\t\tlast;\t/* last file offset */\n\tint\t\t\trval;\n\n\tif ((rval = xfs_bmap_last_offset(args->dp, &last, XFS_DATA_FORK)))\n\t\treturn rval;\n\trval = XFS_FSB_TO_B(args->dp->i_mount, last) == args->geo->blksize;\n\tASSERT(rval == 0 || args->dp->i_d.di_size == args->geo->blksize);\n\t*vp = rval;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir2_isblock(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\t*vp)\t/* out: 1 is block, 0 is not block */\n{\n\txfs_fileoff_t\t\tlast;\t/* last file offset */\n\tint\t\t\trval;\n\n\tif ((rval = xfs_bmap_last_offset(args->dp, &last, XFS_DATA_FORK)))\n\t\treturn rval;\n\trval = XFS_FSB_TO_B(args->dp->i_mount, last) == args->geo->blksize;\n\tASSERT(rval == 0 || args->dp->i_d.di_size == args->geo->blksize);\n\t*vp = rval;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_sf_getdents",
          "args": [
            "&args",
            "ctx"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_getdents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dir2_readdir.c",
          "lines": "58-152",
          "snippet": "STATIC int\nxfs_dir2_sf_getdents(\n\tstruct xfs_da_args\t*args,\n\tstruct dir_context\t*ctx)\n{\n\tint\t\t\ti;\t\t/* shortform entry number */\n\tstruct xfs_inode\t*dp = args->dp;\t/* incore directory inode */\n\txfs_dir2_dataptr_t\toff;\t\t/* current entry's offset */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* shortform directory entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform structure */\n\txfs_dir2_dataptr_t\tdot_offset;\n\txfs_dir2_dataptr_t\tdotdot_offset;\n\txfs_ino_t\t\tino;\n\tstruct xfs_da_geometry\t*geo = args->geo;\n\n\tASSERT(dp->i_df.if_flags & XFS_IFINLINE);\n\t/*\n\t * Give up if the directory is way too short.\n\t */\n\tif (dp->i_d.di_size < offsetof(xfs_dir2_sf_hdr_t, parent)) {\n\t\tASSERT(XFS_FORCED_SHUTDOWN(dp->i_mount));\n\t\treturn -EIO;\n\t}\n\n\tASSERT(dp->i_df.if_bytes == dp->i_d.di_size);\n\tASSERT(dp->i_df.if_u1.if_data != NULL);\n\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\n\tASSERT(dp->i_d.di_size >= xfs_dir2_sf_hdr_size(sfp->i8count));\n\n\t/*\n\t * If the block number in the offset is out of range, we're done.\n\t */\n\tif (xfs_dir2_dataptr_to_db(geo, ctx->pos) > geo->datablk)\n\t\treturn 0;\n\n\t/*\n\t * Precalculate offsets for . and .. as we will always need them.\n\t *\n\t * XXX(hch): the second argument is sometimes 0 and sometimes\n\t * geo->datablk\n\t */\n\tdot_offset = xfs_dir2_db_off_to_dataptr(geo, geo->datablk,\n\t\t\t\t\t\tdp->d_ops->data_dot_offset);\n\tdotdot_offset = xfs_dir2_db_off_to_dataptr(geo, geo->datablk,\n\t\t\t\t\t\tdp->d_ops->data_dotdot_offset);\n\n\t/*\n\t * Put . entry unless we're starting past it.\n\t */\n\tif (ctx->pos <= dot_offset) {\n\t\tctx->pos = dot_offset & 0x7fffffff;\n\t\tif (!dir_emit(ctx, \".\", 1, dp->i_ino, DT_DIR))\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * Put .. entry unless we're starting past it.\n\t */\n\tif (ctx->pos <= dotdot_offset) {\n\t\tino = dp->d_ops->sf_get_parent_ino(sfp);\n\t\tctx->pos = dotdot_offset & 0x7fffffff;\n\t\tif (!dir_emit(ctx, \"..\", 2, ino, DT_DIR))\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * Loop while there are more entries and put'ing works.\n\t */\n\tsfep = xfs_dir2_sf_firstentry(sfp);\n\tfor (i = 0; i < sfp->count; i++) {\n\t\t__uint8_t filetype;\n\n\t\toff = xfs_dir2_db_off_to_dataptr(geo, geo->datablk,\n\t\t\t\txfs_dir2_sf_get_offset(sfep));\n\n\t\tif (ctx->pos > off) {\n\t\t\tsfep = dp->d_ops->sf_nextentry(sfp, sfep);\n\t\t\tcontinue;\n\t\t}\n\n\t\tino = dp->d_ops->sf_get_ino(sfp, sfep);\n\t\tfiletype = dp->d_ops->sf_get_ftype(sfep);\n\t\tctx->pos = off & 0x7fffffff;\n\t\tif (!dir_emit(ctx, (char *)sfep->name, sfep->namelen, ino,\n\t\t\t    xfs_dir3_get_dtype(dp->i_mount, filetype)))\n\t\t\treturn 0;\n\t\tsfep = dp->d_ops->sf_nextentry(sfp, sfep);\n\t}\n\n\tctx->pos = xfs_dir2_db_off_to_dataptr(geo, geo->datablk + 1, 0) &\n\t\t\t\t\t\t\t\t0x7fffffff;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_dir2_sf_getdents(\n\tstruct xfs_da_args\t*args,\n\tstruct dir_context\t*ctx)\n{\n\tint\t\t\ti;\t\t/* shortform entry number */\n\tstruct xfs_inode\t*dp = args->dp;\t/* incore directory inode */\n\txfs_dir2_dataptr_t\toff;\t\t/* current entry's offset */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* shortform directory entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform structure */\n\txfs_dir2_dataptr_t\tdot_offset;\n\txfs_dir2_dataptr_t\tdotdot_offset;\n\txfs_ino_t\t\tino;\n\tstruct xfs_da_geometry\t*geo = args->geo;\n\n\tASSERT(dp->i_df.if_flags & XFS_IFINLINE);\n\t/*\n\t * Give up if the directory is way too short.\n\t */\n\tif (dp->i_d.di_size < offsetof(xfs_dir2_sf_hdr_t, parent)) {\n\t\tASSERT(XFS_FORCED_SHUTDOWN(dp->i_mount));\n\t\treturn -EIO;\n\t}\n\n\tASSERT(dp->i_df.if_bytes == dp->i_d.di_size);\n\tASSERT(dp->i_df.if_u1.if_data != NULL);\n\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\n\tASSERT(dp->i_d.di_size >= xfs_dir2_sf_hdr_size(sfp->i8count));\n\n\t/*\n\t * If the block number in the offset is out of range, we're done.\n\t */\n\tif (xfs_dir2_dataptr_to_db(geo, ctx->pos) > geo->datablk)\n\t\treturn 0;\n\n\t/*\n\t * Precalculate offsets for . and .. as we will always need them.\n\t *\n\t * XXX(hch): the second argument is sometimes 0 and sometimes\n\t * geo->datablk\n\t */\n\tdot_offset = xfs_dir2_db_off_to_dataptr(geo, geo->datablk,\n\t\t\t\t\t\tdp->d_ops->data_dot_offset);\n\tdotdot_offset = xfs_dir2_db_off_to_dataptr(geo, geo->datablk,\n\t\t\t\t\t\tdp->d_ops->data_dotdot_offset);\n\n\t/*\n\t * Put . entry unless we're starting past it.\n\t */\n\tif (ctx->pos <= dot_offset) {\n\t\tctx->pos = dot_offset & 0x7fffffff;\n\t\tif (!dir_emit(ctx, \".\", 1, dp->i_ino, DT_DIR))\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * Put .. entry unless we're starting past it.\n\t */\n\tif (ctx->pos <= dotdot_offset) {\n\t\tino = dp->d_ops->sf_get_parent_ino(sfp);\n\t\tctx->pos = dotdot_offset & 0x7fffffff;\n\t\tif (!dir_emit(ctx, \"..\", 2, ino, DT_DIR))\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * Loop while there are more entries and put'ing works.\n\t */\n\tsfep = xfs_dir2_sf_firstentry(sfp);\n\tfor (i = 0; i < sfp->count; i++) {\n\t\t__uint8_t filetype;\n\n\t\toff = xfs_dir2_db_off_to_dataptr(geo, geo->datablk,\n\t\t\t\txfs_dir2_sf_get_offset(sfep));\n\n\t\tif (ctx->pos > off) {\n\t\t\tsfep = dp->d_ops->sf_nextentry(sfp, sfep);\n\t\t\tcontinue;\n\t\t}\n\n\t\tino = dp->d_ops->sf_get_ino(sfp, sfep);\n\t\tfiletype = dp->d_ops->sf_get_ftype(sfep);\n\t\tctx->pos = off & 0x7fffffff;\n\t\tif (!dir_emit(ctx, (char *)sfep->name, sfep->namelen, ino,\n\t\t\t    xfs_dir3_get_dtype(dp->i_mount, filetype)))\n\t\t\treturn 0;\n\t\tsfep = dp->d_ops->sf_nextentry(sfp, sfep);\n\t}\n\n\tctx->pos = xfs_dir2_db_off_to_dataptr(geo, geo->datablk + 1, 0) &\n\t\t\t\t\t\t\t\t0x7fffffff;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock_data_map_shared",
          "args": [
            "dp"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_data_map_shared",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "93-104",
          "snippet": "uint\nxfs_ilock_data_map_shared(\n\tstruct xfs_inode\t*ip)\n{\n\tuint\t\t\tlock_mode = XFS_ILOCK_SHARED;\n\n\tif (ip->i_d.di_format == XFS_DINODE_FMT_BTREE &&\n\t    (ip->i_df.if_flags & XFS_IFEXTENTS) == 0)\n\t\tlock_mode = XFS_ILOCK_EXCL;\n\txfs_ilock(ip, lock_mode);\n\treturn lock_mode;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nuint\nxfs_ilock_data_map_shared(\n\tstruct xfs_inode\t*ip)\n{\n\tuint\t\t\tlock_mode = XFS_ILOCK_SHARED;\n\n\tif (ip->i_d.di_format == XFS_DINODE_FMT_BTREE &&\n\t    (ip->i_df.if_flags & XFS_IFEXTENTS) == 0)\n\t\tlock_mode = XFS_ILOCK_EXCL;\n\txfs_ilock(ip, lock_mode);\n\treturn lock_mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_dir_getdents"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "S_ISDIR(dp->i_d.di_mode)"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "dp->i_d.di_mode"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "dp->i_mount"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_readdir",
          "args": [
            "dp"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_readdir(\n\tstruct xfs_inode\t*dp,\n\tstruct dir_context\t*ctx,\n\tsize_t\t\t\tbufsize)\n{\n\tstruct xfs_da_args\targs = { NULL };\n\tint\t\t\trval;\n\tint\t\t\tv;\n\tuint\t\t\tlock_mode;\n\n\ttrace_xfs_readdir(dp);\n\n\tif (XFS_FORCED_SHUTDOWN(dp->i_mount))\n\t\treturn -EIO;\n\n\tASSERT(S_ISDIR(dp->i_d.di_mode));\n\tXFS_STATS_INC(xs_dir_getdents);\n\n\targs.dp = dp;\n\targs.geo = dp->i_mount->m_dir_geo;\n\n\tlock_mode = xfs_ilock_data_map_shared(dp);\n\tif (dp->i_d.di_format == XFS_DINODE_FMT_LOCAL)\n\t\trval = xfs_dir2_sf_getdents(&args, ctx);\n\telse if ((rval = xfs_dir2_isblock(&args, &v)))\n\t\t;\n\telse if (v)\n\t\trval = xfs_dir2_block_getdents(&args, ctx);\n\telse\n\t\trval = xfs_dir2_leaf_getdents(&args, ctx, bufsize);\n\txfs_iunlock(dp, lock_mode);\n\n\treturn rval;\n}"
  },
  {
    "function_name": "xfs_dir2_leaf_getdents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dir2_readdir.c",
    "lines": "469-642",
    "snippet": "STATIC int\nxfs_dir2_leaf_getdents(\n\tstruct xfs_da_args\t*args,\n\tstruct dir_context\t*ctx,\n\tsize_t\t\t\tbufsize)\n{\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_buf\t\t*bp = NULL;\t/* data block buffer */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry */\n\tint\t\t\terror = 0;\t/* error return value */\n\tint\t\t\tlength;\t\t/* temporary length value */\n\tint\t\t\tbyteoff;\t/* offset in current block */\n\txfs_dir2_off_t\t\tcuroff;\t\t/* current overall offset */\n\txfs_dir2_off_t\t\tnewoff;\t\t/* new curoff after new blk */\n\tchar\t\t\t*ptr = NULL;\t/* pointer to current data */\n\tstruct xfs_dir2_leaf_map_info *map_info;\n\tstruct xfs_da_geometry\t*geo = args->geo;\n\n\t/*\n\t * If the offset is at or past the largest allowed value,\n\t * give up right away.\n\t */\n\tif (ctx->pos >= XFS_DIR2_MAX_DATAPTR)\n\t\treturn 0;\n\n\t/*\n\t * Set up to bmap a number of blocks based on the caller's\n\t * buffer size, the directory block size, and the filesystem\n\t * block size.\n\t */\n\tlength = howmany(bufsize + geo->blksize, (1 << geo->fsblog));\n\tmap_info = kmem_zalloc(offsetof(struct xfs_dir2_leaf_map_info, map) +\n\t\t\t\t(length * sizeof(struct xfs_bmbt_irec)),\n\t\t\t       KM_SLEEP | KM_NOFS);\n\tmap_info->map_size = length;\n\n\t/*\n\t * Inside the loop we keep the main offset value as a byte offset\n\t * in the directory file.\n\t */\n\tcuroff = xfs_dir2_dataptr_to_byte(ctx->pos);\n\n\t/*\n\t * Force this conversion through db so we truncate the offset\n\t * down to get the start of the data block.\n\t */\n\tmap_info->map_off = xfs_dir2_db_to_da(geo,\n\t\t\t\t\t      xfs_dir2_byte_to_db(geo, curoff));\n\n\t/*\n\t * Loop over directory entries until we reach the end offset.\n\t * Get more blocks and readahead as necessary.\n\t */\n\twhile (curoff < XFS_DIR2_LEAF_OFFSET) {\n\t\t__uint8_t filetype;\n\n\t\t/*\n\t\t * If we have no buffer, or we're off the end of the\n\t\t * current buffer, need to get another one.\n\t\t */\n\t\tif (!bp || ptr >= (char *)bp->b_addr + geo->blksize) {\n\n\t\t\terror = xfs_dir2_leaf_readbuf(args, bufsize, map_info,\n\t\t\t\t\t\t      &curoff, &bp);\n\t\t\tif (error || !map_info->map_valid)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * Having done a read, we need to set a new offset.\n\t\t\t */\n\t\t\tnewoff = xfs_dir2_db_off_to_byte(geo,\n\t\t\t\t\t\t\t map_info->curdb, 0);\n\t\t\t/*\n\t\t\t * Start of the current block.\n\t\t\t */\n\t\t\tif (curoff < newoff)\n\t\t\t\tcuroff = newoff;\n\t\t\t/*\n\t\t\t * Make sure we're in the right block.\n\t\t\t */\n\t\t\telse if (curoff > newoff)\n\t\t\t\tASSERT(xfs_dir2_byte_to_db(geo, curoff) ==\n\t\t\t\t       map_info->curdb);\n\t\t\thdr = bp->b_addr;\n\t\t\txfs_dir3_data_check(dp, bp);\n\t\t\t/*\n\t\t\t * Find our position in the block.\n\t\t\t */\n\t\t\tptr = (char *)dp->d_ops->data_entry_p(hdr);\n\t\t\tbyteoff = xfs_dir2_byte_to_off(geo, curoff);\n\t\t\t/*\n\t\t\t * Skip past the header.\n\t\t\t */\n\t\t\tif (byteoff == 0)\n\t\t\t\tcuroff += dp->d_ops->data_entry_offset;\n\t\t\t/*\n\t\t\t * Skip past entries until we reach our offset.\n\t\t\t */\n\t\t\telse {\n\t\t\t\twhile ((char *)ptr - (char *)hdr < byteoff) {\n\t\t\t\t\tdup = (xfs_dir2_data_unused_t *)ptr;\n\n\t\t\t\t\tif (be16_to_cpu(dup->freetag)\n\t\t\t\t\t\t  == XFS_DIR2_DATA_FREE_TAG) {\n\n\t\t\t\t\t\tlength = be16_to_cpu(dup->length);\n\t\t\t\t\t\tptr += length;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdep = (xfs_dir2_data_entry_t *)ptr;\n\t\t\t\t\tlength =\n\t\t\t\t\t   dp->d_ops->data_entsize(dep->namelen);\n\t\t\t\t\tptr += length;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Now set our real offset.\n\t\t\t\t */\n\t\t\t\tcuroff =\n\t\t\t\t\txfs_dir2_db_off_to_byte(geo,\n\t\t\t\t\t    xfs_dir2_byte_to_db(geo, curoff),\n\t\t\t\t\t    (char *)ptr - (char *)hdr);\n\t\t\t\tif (ptr >= (char *)hdr + geo->blksize) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * We have a pointer to an entry.\n\t\t * Is it a live one?\n\t\t */\n\t\tdup = (xfs_dir2_data_unused_t *)ptr;\n\t\t/*\n\t\t * No, it's unused, skip over it.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tlength = be16_to_cpu(dup->length);\n\t\t\tptr += length;\n\t\t\tcuroff += length;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdep = (xfs_dir2_data_entry_t *)ptr;\n\t\tlength = dp->d_ops->data_entsize(dep->namelen);\n\t\tfiletype = dp->d_ops->data_get_ftype(dep);\n\n\t\tctx->pos = xfs_dir2_byte_to_dataptr(curoff) & 0x7fffffff;\n\t\tif (!dir_emit(ctx, (char *)dep->name, dep->namelen,\n\t\t\t    be64_to_cpu(dep->inumber),\n\t\t\t    xfs_dir3_get_dtype(dp->i_mount, filetype)))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Advance to next entry in the block.\n\t\t */\n\t\tptr += length;\n\t\tcuroff += length;\n\t\t/* bufsize may have just been a guess; don't go negative */\n\t\tbufsize = bufsize > length ? bufsize - length : 0;\n\t}\n\n\t/*\n\t * All done.  Set output offset value to current offset.\n\t */\n\tif (curoff > xfs_dir2_dataptr_to_byte(XFS_DIR2_MAX_DATAPTR))\n\t\tctx->pos = XFS_DIR2_MAX_DATAPTR & 0x7fffffff;\n\telse\n\t\tctx->pos = xfs_dir2_byte_to_dataptr(curoff) & 0x7fffffff;\n\tkmem_free(map_info);\n\tif (bp)\n\t\txfs_trans_brelse(NULL, bp);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "NULL",
            "bp"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "map_info"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_byte_to_dataptr",
          "args": [
            "curoff"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_byte_to_dataptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "204-208",
          "snippet": "static inline xfs_dir2_dataptr_t\nxfs_dir2_byte_to_dataptr(xfs_dir2_off_t by)\n{\n\treturn (xfs_dir2_dataptr_t)(by >> XFS_DIR2_DATA_ALIGN_LOG);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_dataptr_t\nxfs_dir2_byte_to_dataptr(xfs_dir2_off_t by)\n{\n\treturn (xfs_dir2_dataptr_t)(by >> XFS_DIR2_DATA_ALIGN_LOG);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_dataptr_to_byte",
          "args": [
            "XFS_DIR2_MAX_DATAPTR"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_dataptr_to_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "195-199",
          "snippet": "static inline xfs_dir2_off_t\nxfs_dir2_dataptr_to_byte(xfs_dir2_dataptr_t dp)\n{\n\treturn (xfs_dir2_off_t)dp << XFS_DIR2_DATA_ALIGN_LOG;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_off_t\nxfs_dir2_dataptr_to_byte(xfs_dir2_dataptr_t dp)\n{\n\treturn (xfs_dir2_off_t)dp << XFS_DIR2_DATA_ALIGN_LOG;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "(char *)dep->name",
            "dep->namelen",
            "be64_to_cpu(dep->inumber)",
            "xfs_dir3_get_dtype(dp->i_mount, filetype)"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_get_dtype",
          "args": [
            "dp->i_mount",
            "filetype"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_get_dtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dir2_readdir.c",
          "lines": "44-56",
          "snippet": "static unsigned char\nxfs_dir3_get_dtype(\n\tstruct xfs_mount\t*mp,\n\t__uint8_t\t\tfiletype)\n{\n\tif (!xfs_sb_version_hasftype(&mp->m_sb))\n\t\treturn DT_UNKNOWN;\n\n\tif (filetype >= XFS_DIR3_FT_MAX)\n\t\treturn DT_UNKNOWN;\n\n\treturn xfs_dir3_filetype_table[filetype];\n}",
          "includes": [
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned char xfs_dir3_filetype_table[] = {\n\tDT_UNKNOWN, DT_REG, DT_DIR, DT_CHR, DT_BLK,\n\tDT_FIFO, DT_SOCK, DT_LNK, DT_WHT,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic unsigned char xfs_dir3_filetype_table[] = {\n\tDT_UNKNOWN, DT_REG, DT_DIR, DT_CHR, DT_BLK,\n\tDT_FIFO, DT_SOCK, DT_LNK, DT_WHT,\n};\n\nstatic unsigned char\nxfs_dir3_get_dtype(\n\tstruct xfs_mount\t*mp,\n\t__uint8_t\t\tfiletype)\n{\n\tif (!xfs_sb_version_hasftype(&mp->m_sb))\n\t\treturn DT_UNKNOWN;\n\n\tif (filetype >= XFS_DIR3_FT_MAX)\n\t\treturn DT_UNKNOWN;\n\n\treturn xfs_dir3_filetype_table[filetype];\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dep->inumber"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_get_ftype",
          "args": [
            "dep"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_entsize",
          "args": [
            "dep->namelen"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dup->length"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dup->freetag"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_db_off_to_byte",
          "args": [
            "geo",
            "xfs_dir2_byte_to_db(geo, curoff)",
            "(char *)ptr - (char *)hdr"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_db_off_to_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "249-254",
          "snippet": "static inline xfs_dir2_off_t\nxfs_dir2_db_off_to_byte(struct xfs_da_geometry *geo, xfs_dir2_db_t db,\n\t\t\txfs_dir2_data_aoff_t o)\n{\n\treturn ((xfs_dir2_off_t)db << geo->blklog) + o;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_off_t\nxfs_dir2_db_off_to_byte(struct xfs_da_geometry *geo, xfs_dir2_db_t db,\n\t\t\txfs_dir2_data_aoff_t o)\n{\n\treturn ((xfs_dir2_off_t)db << geo->blklog) + o;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_byte_to_db",
          "args": [
            "geo",
            "curoff"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_byte_to_db",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "213-217",
          "snippet": "static inline xfs_dir2_db_t\nxfs_dir2_byte_to_db(struct xfs_da_geometry *geo, xfs_dir2_off_t by)\n{\n\treturn (xfs_dir2_db_t)(by >> geo->blklog);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_db_t\nxfs_dir2_byte_to_db(struct xfs_da_geometry *geo, xfs_dir2_off_t by)\n{\n\treturn (xfs_dir2_db_t)(by >> geo->blklog);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_entsize",
          "args": [
            "dep->namelen"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dup->length"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dup->freetag"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_byte_to_off",
          "args": [
            "geo",
            "curoff"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_byte_to_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "231-235",
          "snippet": "static inline xfs_dir2_data_aoff_t\nxfs_dir2_byte_to_off(struct xfs_da_geometry *geo, xfs_dir2_off_t by)\n{\n\treturn (xfs_dir2_data_aoff_t)(by & (geo->blksize - 1));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_data_aoff_t\nxfs_dir2_byte_to_off(struct xfs_da_geometry *geo, xfs_dir2_off_t by)\n{\n\treturn (xfs_dir2_data_aoff_t)(by & (geo->blksize - 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_entry_p",
          "args": [
            "hdr"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_data_check",
          "args": [
            "dp",
            "bp"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "__xfs_dir3_data_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "40-210",
          "snippet": "int\n__xfs_dir3_data_check(\n\tstruct xfs_inode\t*dp,\t\t/* incore inode pointer */\n\tstruct xfs_buf\t\t*bp)\t\t/* data block's buffer */\n{\n\txfs_dir2_dataptr_t\taddr;\t\t/* addr for leaf lookup */\n\txfs_dir2_data_free_t\t*bf;\t\t/* bestfree table */\n\txfs_dir2_block_tail_t\t*btp=NULL;\t/* block tail */\n\tint\t\t\tcount;\t\t/* count of entries found */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry */\n\tchar\t\t\t*endp;\t\t/* end of useful data */\n\tint\t\t\tfreeseen;\t/* mask of bestfrees seen */\n\txfs_dahash_t\t\thash;\t\t/* hash of current name */\n\tint\t\t\ti;\t\t/* leaf index */\n\tint\t\t\tlastfree;\t/* last entry was unused */\n\txfs_dir2_leaf_entry_t\t*lep=NULL;\t/* block leaf entries */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tchar\t\t\t*p;\t\t/* current data position */\n\tint\t\t\tstale;\t\t/* count of stale leaves */\n\tstruct xfs_name\t\tname;\n\tconst struct xfs_dir_ops *ops;\n\tstruct xfs_da_geometry\t*geo;\n\n\tmp = bp->b_target->bt_mount;\n\tgeo = mp->m_dir_geo;\n\n\t/*\n\t * We can be passed a null dp here from a verifier, so we need to go the\n\t * hard way to get them.\n\t */\n\tops = xfs_dir_get_ops(mp, dp);\n\n\thdr = bp->b_addr;\n\tp = (char *)ops->data_entry_p(hdr);\n\n\tswitch (hdr->magic) {\n\tcase cpu_to_be32(XFS_DIR3_BLOCK_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_BLOCK_MAGIC):\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tlep = xfs_dir2_block_leaf_p(btp);\n\t\tendp = (char *)lep;\n\n\t\t/*\n\t\t * The number of leaf entries is limited by the size of the\n\t\t * block and the amount of space used by the data entries.\n\t\t * We don't know how much space is used by the data entries yet,\n\t\t * so just ensure that the count falls somewhere inside the\n\t\t * block right now.\n\t\t */\n\t\tXFS_WANT_CORRUPTED_RETURN(be32_to_cpu(btp->count) <\n\t\t\t((char *)btp - p) / sizeof(struct xfs_dir2_leaf_entry));\n\t\tbreak;\n\tcase cpu_to_be32(XFS_DIR3_DATA_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_DATA_MAGIC):\n\t\tendp = (char *)hdr + geo->blksize;\n\t\tbreak;\n\tdefault:\n\t\tXFS_ERROR_REPORT(\"Bad Magic\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/*\n\t * Account for zero bestfree entries.\n\t */\n\tbf = ops->data_bestfree_p(hdr);\n\tcount = lastfree = freeseen = 0;\n\tif (!bf[0].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[0].offset);\n\t\tfreeseen |= 1 << 0;\n\t}\n\tif (!bf[1].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[1].offset);\n\t\tfreeseen |= 1 << 1;\n\t}\n\tif (!bf[2].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[2].offset);\n\t\tfreeseen |= 1 << 2;\n\t}\n\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[0].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[1].length));\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[1].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t/*\n\t * Loop over the data/unused entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's unused, look for the space in the bestfree table.\n\t\t * If we find it, account for that, else make sure it\n\t\t * doesn't need to be there.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tXFS_WANT_CORRUPTED_RETURN(lastfree == 0);\n\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tbe16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)) ==\n\t\t\t\t\t       (char *)dup - (char *)hdr);\n\t\t\tdfp = xfs_dir2_data_freefind(hdr, bf, dup);\n\t\t\tif (dfp) {\n\t\t\t\ti = (int)(dfp - bf);\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\t(freeseen & (1 << i)) == 0);\n\t\t\t\tfreeseen |= 1 << i;\n\t\t\t} else {\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe16_to_cpu(dup->length) <=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t\t\t}\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t\tlastfree = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * It's a real entry.  Validate the fields.\n\t\t * If this is a block directory then make sure it's\n\t\t * in the leaf section of the block.\n\t\t * The linear search is crude but this is DEBUG code.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\tXFS_WANT_CORRUPTED_RETURN(dep->namelen != 0);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t!xfs_dir_ino_validate(mp, be64_to_cpu(dep->inumber)));\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\tbe16_to_cpu(*ops->data_entry_tag_p(dep)) ==\n\t\t\t\t\t       (char *)dep - (char *)hdr);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tops->data_get_ftype(dep) < XFS_DIR3_FT_MAX);\n\t\tcount++;\n\t\tlastfree = 0;\n\t\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\t\taddr = xfs_dir2_db_off_to_dataptr(geo, geo->datablk,\n\t\t\t\t\t\t(xfs_dir2_data_aoff_t)\n\t\t\t\t\t\t((char *)dep - (char *)hdr));\n\t\t\tname.name = dep->name;\n\t\t\tname.len = dep->namelen;\n\t\t\thash = mp->m_dirnameops->hashname(&name);\n\t\t\tfor (i = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\t\tif (be32_to_cpu(lep[i].address) == addr &&\n\t\t\t\t    be32_to_cpu(lep[i].hashval) == hash)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tXFS_WANT_CORRUPTED_RETURN(i < be32_to_cpu(btp->count));\n\t\t}\n\t\tp += ops->data_entsize(dep->namelen);\n\t}\n\t/*\n\t * Need to have seen all the entries and all the bestfree slots.\n\t */\n\tXFS_WANT_CORRUPTED_RETURN(freeseen == 7);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tfor (i = stale = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\tif (lep[i].address ==\n\t\t\t    cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\t\tstale++;\n\t\t\tif (i > 0)\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe32_to_cpu(lep[i].hashval) >=\n\t\t\t\t\t\tbe32_to_cpu(lep[i - 1].hashval));\n\t\t}\n\t\tXFS_WANT_CORRUPTED_RETURN(count ==\n\t\t\tbe32_to_cpu(btp->count) - be32_to_cpu(btp->stale));\n\t\tXFS_WANT_CORRUPTED_RETURN(stale == be32_to_cpu(btp->stale));\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\n__xfs_dir3_data_check(\n\tstruct xfs_inode\t*dp,\t\t/* incore inode pointer */\n\tstruct xfs_buf\t\t*bp)\t\t/* data block's buffer */\n{\n\txfs_dir2_dataptr_t\taddr;\t\t/* addr for leaf lookup */\n\txfs_dir2_data_free_t\t*bf;\t\t/* bestfree table */\n\txfs_dir2_block_tail_t\t*btp=NULL;\t/* block tail */\n\tint\t\t\tcount;\t\t/* count of entries found */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry */\n\tchar\t\t\t*endp;\t\t/* end of useful data */\n\tint\t\t\tfreeseen;\t/* mask of bestfrees seen */\n\txfs_dahash_t\t\thash;\t\t/* hash of current name */\n\tint\t\t\ti;\t\t/* leaf index */\n\tint\t\t\tlastfree;\t/* last entry was unused */\n\txfs_dir2_leaf_entry_t\t*lep=NULL;\t/* block leaf entries */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tchar\t\t\t*p;\t\t/* current data position */\n\tint\t\t\tstale;\t\t/* count of stale leaves */\n\tstruct xfs_name\t\tname;\n\tconst struct xfs_dir_ops *ops;\n\tstruct xfs_da_geometry\t*geo;\n\n\tmp = bp->b_target->bt_mount;\n\tgeo = mp->m_dir_geo;\n\n\t/*\n\t * We can be passed a null dp here from a verifier, so we need to go the\n\t * hard way to get them.\n\t */\n\tops = xfs_dir_get_ops(mp, dp);\n\n\thdr = bp->b_addr;\n\tp = (char *)ops->data_entry_p(hdr);\n\n\tswitch (hdr->magic) {\n\tcase cpu_to_be32(XFS_DIR3_BLOCK_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_BLOCK_MAGIC):\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tlep = xfs_dir2_block_leaf_p(btp);\n\t\tendp = (char *)lep;\n\n\t\t/*\n\t\t * The number of leaf entries is limited by the size of the\n\t\t * block and the amount of space used by the data entries.\n\t\t * We don't know how much space is used by the data entries yet,\n\t\t * so just ensure that the count falls somewhere inside the\n\t\t * block right now.\n\t\t */\n\t\tXFS_WANT_CORRUPTED_RETURN(be32_to_cpu(btp->count) <\n\t\t\t((char *)btp - p) / sizeof(struct xfs_dir2_leaf_entry));\n\t\tbreak;\n\tcase cpu_to_be32(XFS_DIR3_DATA_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_DATA_MAGIC):\n\t\tendp = (char *)hdr + geo->blksize;\n\t\tbreak;\n\tdefault:\n\t\tXFS_ERROR_REPORT(\"Bad Magic\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/*\n\t * Account for zero bestfree entries.\n\t */\n\tbf = ops->data_bestfree_p(hdr);\n\tcount = lastfree = freeseen = 0;\n\tif (!bf[0].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[0].offset);\n\t\tfreeseen |= 1 << 0;\n\t}\n\tif (!bf[1].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[1].offset);\n\t\tfreeseen |= 1 << 1;\n\t}\n\tif (!bf[2].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[2].offset);\n\t\tfreeseen |= 1 << 2;\n\t}\n\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[0].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[1].length));\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[1].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t/*\n\t * Loop over the data/unused entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's unused, look for the space in the bestfree table.\n\t\t * If we find it, account for that, else make sure it\n\t\t * doesn't need to be there.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tXFS_WANT_CORRUPTED_RETURN(lastfree == 0);\n\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tbe16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)) ==\n\t\t\t\t\t       (char *)dup - (char *)hdr);\n\t\t\tdfp = xfs_dir2_data_freefind(hdr, bf, dup);\n\t\t\tif (dfp) {\n\t\t\t\ti = (int)(dfp - bf);\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\t(freeseen & (1 << i)) == 0);\n\t\t\t\tfreeseen |= 1 << i;\n\t\t\t} else {\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe16_to_cpu(dup->length) <=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t\t\t}\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t\tlastfree = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * It's a real entry.  Validate the fields.\n\t\t * If this is a block directory then make sure it's\n\t\t * in the leaf section of the block.\n\t\t * The linear search is crude but this is DEBUG code.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\tXFS_WANT_CORRUPTED_RETURN(dep->namelen != 0);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t!xfs_dir_ino_validate(mp, be64_to_cpu(dep->inumber)));\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\tbe16_to_cpu(*ops->data_entry_tag_p(dep)) ==\n\t\t\t\t\t       (char *)dep - (char *)hdr);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tops->data_get_ftype(dep) < XFS_DIR3_FT_MAX);\n\t\tcount++;\n\t\tlastfree = 0;\n\t\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\t\taddr = xfs_dir2_db_off_to_dataptr(geo, geo->datablk,\n\t\t\t\t\t\t(xfs_dir2_data_aoff_t)\n\t\t\t\t\t\t((char *)dep - (char *)hdr));\n\t\t\tname.name = dep->name;\n\t\t\tname.len = dep->namelen;\n\t\t\thash = mp->m_dirnameops->hashname(&name);\n\t\t\tfor (i = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\t\tif (be32_to_cpu(lep[i].address) == addr &&\n\t\t\t\t    be32_to_cpu(lep[i].hashval) == hash)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tXFS_WANT_CORRUPTED_RETURN(i < be32_to_cpu(btp->count));\n\t\t}\n\t\tp += ops->data_entsize(dep->namelen);\n\t}\n\t/*\n\t * Need to have seen all the entries and all the bestfree slots.\n\t */\n\tXFS_WANT_CORRUPTED_RETURN(freeseen == 7);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tfor (i = stale = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\tif (lep[i].address ==\n\t\t\t    cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\t\tstale++;\n\t\t\tif (i > 0)\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe32_to_cpu(lep[i].hashval) >=\n\t\t\t\t\t\tbe32_to_cpu(lep[i - 1].hashval));\n\t\t}\n\t\tXFS_WANT_CORRUPTED_RETURN(count ==\n\t\t\tbe32_to_cpu(btp->count) - be32_to_cpu(btp->stale));\n\t\tXFS_WANT_CORRUPTED_RETURN(stale == be32_to_cpu(btp->stale));\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_dir2_byte_to_db(geo, curoff) ==\n\t\t\t\t       map_info->curdb"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leaf_readbuf",
          "args": [
            "args",
            "bufsize",
            "map_info",
            "&curoff",
            "&bp"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leaf_readbuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dir2_readdir.c",
          "lines": "267-463",
          "snippet": "STATIC int\nxfs_dir2_leaf_readbuf(\n\tstruct xfs_da_args\t*args,\n\tsize_t\t\t\tbufsize,\n\tstruct xfs_dir2_leaf_map_info *mip,\n\txfs_dir2_off_t\t\t*curoff,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_buf\t\t*bp = *bpp;\n\tstruct xfs_bmbt_irec\t*map = mip->map;\n\tstruct blk_plug\t\tplug;\n\tint\t\t\terror = 0;\n\tint\t\t\tlength;\n\tint\t\t\ti;\n\tint\t\t\tj;\n\tstruct xfs_da_geometry\t*geo = args->geo;\n\n\t/*\n\t * If we have a buffer, we need to release it and\n\t * take it out of the mapping.\n\t */\n\n\tif (bp) {\n\t\txfs_trans_brelse(NULL, bp);\n\t\tbp = NULL;\n\t\tmip->map_blocks -= geo->fsbcount;\n\t\t/*\n\t\t * Loop to get rid of the extents for the\n\t\t * directory block.\n\t\t */\n\t\tfor (i = geo->fsbcount; i > 0; ) {\n\t\t\tj = min_t(int, map->br_blockcount, i);\n\t\t\tmap->br_blockcount -= j;\n\t\t\tmap->br_startblock += j;\n\t\t\tmap->br_startoff += j;\n\t\t\t/*\n\t\t\t * If mapping is done, pitch it from\n\t\t\t * the table.\n\t\t\t */\n\t\t\tif (!map->br_blockcount && --mip->map_valid)\n\t\t\t\tmemmove(&map[0], &map[1],\n\t\t\t\t\tsizeof(map[0]) * mip->map_valid);\n\t\t\ti -= j;\n\t\t}\n\t}\n\n\t/*\n\t * Recalculate the readahead blocks wanted.\n\t */\n\tmip->ra_want = howmany(bufsize + geo->blksize, (1 << geo->fsblog)) - 1;\n\tASSERT(mip->ra_want >= 0);\n\n\t/*\n\t * If we don't have as many as we want, and we haven't\n\t * run out of data blocks, get some more mappings.\n\t */\n\tif (1 + mip->ra_want > mip->map_blocks &&\n\t    mip->map_off < xfs_dir2_byte_to_da(geo, XFS_DIR2_LEAF_OFFSET)) {\n\t\t/*\n\t\t * Get more bmaps, fill in after the ones\n\t\t * we already have in the table.\n\t\t */\n\t\tmip->nmap = mip->map_size - mip->map_valid;\n\t\terror = xfs_bmapi_read(dp, mip->map_off,\n\t\t\t\txfs_dir2_byte_to_da(geo, XFS_DIR2_LEAF_OFFSET) -\n\t\t\t\t\t\t\t\tmip->map_off,\n\t\t\t\t&map[mip->map_valid], &mip->nmap, 0);\n\n\t\t/*\n\t\t * Don't know if we should ignore this or try to return an\n\t\t * error.  The trouble with returning errors is that readdir\n\t\t * will just stop without actually passing the error through.\n\t\t */\n\t\tif (error)\n\t\t\tgoto out;\t/* XXX */\n\n\t\t/*\n\t\t * If we got all the mappings we asked for, set the final map\n\t\t * offset based on the last bmap value received.  Otherwise,\n\t\t * we've reached the end.\n\t\t */\n\t\tif (mip->nmap == mip->map_size - mip->map_valid) {\n\t\t\ti = mip->map_valid + mip->nmap - 1;\n\t\t\tmip->map_off = map[i].br_startoff + map[i].br_blockcount;\n\t\t} else\n\t\t\tmip->map_off = xfs_dir2_byte_to_da(geo,\n\t\t\t\t\t\t\tXFS_DIR2_LEAF_OFFSET);\n\n\t\t/*\n\t\t * Look for holes in the mapping, and eliminate them.  Count up\n\t\t * the valid blocks.\n\t\t */\n\t\tfor (i = mip->map_valid; i < mip->map_valid + mip->nmap; ) {\n\t\t\tif (map[i].br_startblock == HOLESTARTBLOCK) {\n\t\t\t\tmip->nmap--;\n\t\t\t\tlength = mip->map_valid + mip->nmap - i;\n\t\t\t\tif (length)\n\t\t\t\t\tmemmove(&map[i], &map[i + 1],\n\t\t\t\t\t\tsizeof(map[i]) * length);\n\t\t\t} else {\n\t\t\t\tmip->map_blocks += map[i].br_blockcount;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tmip->map_valid += mip->nmap;\n\t}\n\n\t/*\n\t * No valid mappings, so no more data blocks.\n\t */\n\tif (!mip->map_valid) {\n\t\t*curoff = xfs_dir2_da_to_byte(geo, mip->map_off);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Read the directory block starting at the first mapping.\n\t */\n\tmip->curdb = xfs_dir2_da_to_db(geo, map->br_startoff);\n\terror = xfs_dir3_data_read(NULL, dp, map->br_startoff,\n\t\t\tmap->br_blockcount >= geo->fsbcount ?\n\t\t\t    XFS_FSB_TO_DADDR(dp->i_mount, map->br_startblock) :\n\t\t\t    -1, &bp);\n\t/*\n\t * Should just skip over the data block instead of giving up.\n\t */\n\tif (error)\n\t\tgoto out;\t/* XXX */\n\n\t/*\n\t * Adjust the current amount of read-ahead: we just read a block that\n\t * was previously ra.\n\t */\n\tif (mip->ra_current)\n\t\tmip->ra_current -= geo->fsbcount;\n\n\t/*\n\t * Do we need more readahead?\n\t */\n\tblk_start_plug(&plug);\n\tfor (mip->ra_index = mip->ra_offset = i = 0;\n\t     mip->ra_want > mip->ra_current && i < mip->map_blocks;\n\t     i += geo->fsbcount) {\n\t\tASSERT(mip->ra_index < mip->map_valid);\n\t\t/*\n\t\t * Read-ahead a contiguous directory block.\n\t\t */\n\t\tif (i > mip->ra_current &&\n\t\t    map[mip->ra_index].br_blockcount >= geo->fsbcount) {\n\t\t\txfs_dir3_data_readahead(dp,\n\t\t\t\tmap[mip->ra_index].br_startoff + mip->ra_offset,\n\t\t\t\tXFS_FSB_TO_DADDR(dp->i_mount,\n\t\t\t\t\tmap[mip->ra_index].br_startblock +\n\t\t\t\t\t\t\tmip->ra_offset));\n\t\t\tmip->ra_current = i;\n\t\t}\n\n\t\t/*\n\t\t * Read-ahead a non-contiguous directory block.  This doesn't\n\t\t * use our mapping, but this is a very rare case.\n\t\t */\n\t\telse if (i > mip->ra_current) {\n\t\t\txfs_dir3_data_readahead(dp,\n\t\t\t\t\tmap[mip->ra_index].br_startoff +\n\t\t\t\t\t\t\tmip->ra_offset, -1);\n\t\t\tmip->ra_current = i;\n\t\t}\n\n\t\t/*\n\t\t * Advance offset through the mapping table.\n\t\t */\n\t\tfor (j = 0; j < geo->fsbcount; j += length ) {\n\t\t\t/*\n\t\t\t * The rest of this extent but not more than a dir\n\t\t\t * block.\n\t\t\t */\n\t\t\tlength = min_t(int, geo->fsbcount,\n\t\t\t\t\tmap[mip->ra_index].br_blockcount -\n\t\t\t\t\t\t\tmip->ra_offset);\n\t\t\tmip->ra_offset += length;\n\n\t\t\t/*\n\t\t\t * Advance to the next mapping if this one is used up.\n\t\t\t */\n\t\t\tif (mip->ra_offset == map[mip->ra_index].br_blockcount) {\n\t\t\t\tmip->ra_offset = 0;\n\t\t\t\tmip->ra_index++;\n\t\t\t}\n\t\t}\n\t}\n\tblk_finish_plug(&plug);\n\nout:\n\t*bpp = bp;\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_dir2_leaf_readbuf(\n\tstruct xfs_da_args\t*args,\n\tsize_t\t\t\tbufsize,\n\tstruct xfs_dir2_leaf_map_info *mip,\n\txfs_dir2_off_t\t\t*curoff,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_buf\t\t*bp = *bpp;\n\tstruct xfs_bmbt_irec\t*map = mip->map;\n\tstruct blk_plug\t\tplug;\n\tint\t\t\terror = 0;\n\tint\t\t\tlength;\n\tint\t\t\ti;\n\tint\t\t\tj;\n\tstruct xfs_da_geometry\t*geo = args->geo;\n\n\t/*\n\t * If we have a buffer, we need to release it and\n\t * take it out of the mapping.\n\t */\n\n\tif (bp) {\n\t\txfs_trans_brelse(NULL, bp);\n\t\tbp = NULL;\n\t\tmip->map_blocks -= geo->fsbcount;\n\t\t/*\n\t\t * Loop to get rid of the extents for the\n\t\t * directory block.\n\t\t */\n\t\tfor (i = geo->fsbcount; i > 0; ) {\n\t\t\tj = min_t(int, map->br_blockcount, i);\n\t\t\tmap->br_blockcount -= j;\n\t\t\tmap->br_startblock += j;\n\t\t\tmap->br_startoff += j;\n\t\t\t/*\n\t\t\t * If mapping is done, pitch it from\n\t\t\t * the table.\n\t\t\t */\n\t\t\tif (!map->br_blockcount && --mip->map_valid)\n\t\t\t\tmemmove(&map[0], &map[1],\n\t\t\t\t\tsizeof(map[0]) * mip->map_valid);\n\t\t\ti -= j;\n\t\t}\n\t}\n\n\t/*\n\t * Recalculate the readahead blocks wanted.\n\t */\n\tmip->ra_want = howmany(bufsize + geo->blksize, (1 << geo->fsblog)) - 1;\n\tASSERT(mip->ra_want >= 0);\n\n\t/*\n\t * If we don't have as many as we want, and we haven't\n\t * run out of data blocks, get some more mappings.\n\t */\n\tif (1 + mip->ra_want > mip->map_blocks &&\n\t    mip->map_off < xfs_dir2_byte_to_da(geo, XFS_DIR2_LEAF_OFFSET)) {\n\t\t/*\n\t\t * Get more bmaps, fill in after the ones\n\t\t * we already have in the table.\n\t\t */\n\t\tmip->nmap = mip->map_size - mip->map_valid;\n\t\terror = xfs_bmapi_read(dp, mip->map_off,\n\t\t\t\txfs_dir2_byte_to_da(geo, XFS_DIR2_LEAF_OFFSET) -\n\t\t\t\t\t\t\t\tmip->map_off,\n\t\t\t\t&map[mip->map_valid], &mip->nmap, 0);\n\n\t\t/*\n\t\t * Don't know if we should ignore this or try to return an\n\t\t * error.  The trouble with returning errors is that readdir\n\t\t * will just stop without actually passing the error through.\n\t\t */\n\t\tif (error)\n\t\t\tgoto out;\t/* XXX */\n\n\t\t/*\n\t\t * If we got all the mappings we asked for, set the final map\n\t\t * offset based on the last bmap value received.  Otherwise,\n\t\t * we've reached the end.\n\t\t */\n\t\tif (mip->nmap == mip->map_size - mip->map_valid) {\n\t\t\ti = mip->map_valid + mip->nmap - 1;\n\t\t\tmip->map_off = map[i].br_startoff + map[i].br_blockcount;\n\t\t} else\n\t\t\tmip->map_off = xfs_dir2_byte_to_da(geo,\n\t\t\t\t\t\t\tXFS_DIR2_LEAF_OFFSET);\n\n\t\t/*\n\t\t * Look for holes in the mapping, and eliminate them.  Count up\n\t\t * the valid blocks.\n\t\t */\n\t\tfor (i = mip->map_valid; i < mip->map_valid + mip->nmap; ) {\n\t\t\tif (map[i].br_startblock == HOLESTARTBLOCK) {\n\t\t\t\tmip->nmap--;\n\t\t\t\tlength = mip->map_valid + mip->nmap - i;\n\t\t\t\tif (length)\n\t\t\t\t\tmemmove(&map[i], &map[i + 1],\n\t\t\t\t\t\tsizeof(map[i]) * length);\n\t\t\t} else {\n\t\t\t\tmip->map_blocks += map[i].br_blockcount;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tmip->map_valid += mip->nmap;\n\t}\n\n\t/*\n\t * No valid mappings, so no more data blocks.\n\t */\n\tif (!mip->map_valid) {\n\t\t*curoff = xfs_dir2_da_to_byte(geo, mip->map_off);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Read the directory block starting at the first mapping.\n\t */\n\tmip->curdb = xfs_dir2_da_to_db(geo, map->br_startoff);\n\terror = xfs_dir3_data_read(NULL, dp, map->br_startoff,\n\t\t\tmap->br_blockcount >= geo->fsbcount ?\n\t\t\t    XFS_FSB_TO_DADDR(dp->i_mount, map->br_startblock) :\n\t\t\t    -1, &bp);\n\t/*\n\t * Should just skip over the data block instead of giving up.\n\t */\n\tif (error)\n\t\tgoto out;\t/* XXX */\n\n\t/*\n\t * Adjust the current amount of read-ahead: we just read a block that\n\t * was previously ra.\n\t */\n\tif (mip->ra_current)\n\t\tmip->ra_current -= geo->fsbcount;\n\n\t/*\n\t * Do we need more readahead?\n\t */\n\tblk_start_plug(&plug);\n\tfor (mip->ra_index = mip->ra_offset = i = 0;\n\t     mip->ra_want > mip->ra_current && i < mip->map_blocks;\n\t     i += geo->fsbcount) {\n\t\tASSERT(mip->ra_index < mip->map_valid);\n\t\t/*\n\t\t * Read-ahead a contiguous directory block.\n\t\t */\n\t\tif (i > mip->ra_current &&\n\t\t    map[mip->ra_index].br_blockcount >= geo->fsbcount) {\n\t\t\txfs_dir3_data_readahead(dp,\n\t\t\t\tmap[mip->ra_index].br_startoff + mip->ra_offset,\n\t\t\t\tXFS_FSB_TO_DADDR(dp->i_mount,\n\t\t\t\t\tmap[mip->ra_index].br_startblock +\n\t\t\t\t\t\t\tmip->ra_offset));\n\t\t\tmip->ra_current = i;\n\t\t}\n\n\t\t/*\n\t\t * Read-ahead a non-contiguous directory block.  This doesn't\n\t\t * use our mapping, but this is a very rare case.\n\t\t */\n\t\telse if (i > mip->ra_current) {\n\t\t\txfs_dir3_data_readahead(dp,\n\t\t\t\t\tmap[mip->ra_index].br_startoff +\n\t\t\t\t\t\t\tmip->ra_offset, -1);\n\t\t\tmip->ra_current = i;\n\t\t}\n\n\t\t/*\n\t\t * Advance offset through the mapping table.\n\t\t */\n\t\tfor (j = 0; j < geo->fsbcount; j += length ) {\n\t\t\t/*\n\t\t\t * The rest of this extent but not more than a dir\n\t\t\t * block.\n\t\t\t */\n\t\t\tlength = min_t(int, geo->fsbcount,\n\t\t\t\t\tmap[mip->ra_index].br_blockcount -\n\t\t\t\t\t\t\tmip->ra_offset);\n\t\t\tmip->ra_offset += length;\n\n\t\t\t/*\n\t\t\t * Advance to the next mapping if this one is used up.\n\t\t\t */\n\t\t\tif (mip->ra_offset == map[mip->ra_index].br_blockcount) {\n\t\t\t\tmip->ra_offset = 0;\n\t\t\t\tmip->ra_index++;\n\t\t\t}\n\t\t}\n\t}\n\tblk_finish_plug(&plug);\n\nout:\n\t*bpp = bp;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_db_to_da",
          "args": [
            "geo",
            "xfs_dir2_byte_to_db(geo, curoff)"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_db_to_da",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "259-263",
          "snippet": "static inline xfs_dablk_t\nxfs_dir2_db_to_da(struct xfs_da_geometry *geo, xfs_dir2_db_t db)\n{\n\treturn (xfs_dablk_t)(db << (geo->blklog - geo->fsblog));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dablk_t\nxfs_dir2_db_to_da(struct xfs_da_geometry *geo, xfs_dir2_db_t db)\n{\n\treturn (xfs_dablk_t)(db << (geo->blklog - geo->fsblog));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_zalloc",
          "args": [
            "offsetof(struct xfs_dir2_leaf_map_info, map) +\n\t\t\t\t(length * sizeof(struct xfs_bmbt_irec))",
            "KM_SLEEP | KM_NOFS"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zalloc_large",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "64-92",
          "snippet": "void *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "howmany",
          "args": [
            "bufsize + geo->blksize",
            "(1 << geo->fsblog)"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "howmany_64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "340-345",
          "snippet": "static inline __uint64_t howmany_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline __uint64_t howmany_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_dir2_leaf_getdents(\n\tstruct xfs_da_args\t*args,\n\tstruct dir_context\t*ctx,\n\tsize_t\t\t\tbufsize)\n{\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_buf\t\t*bp = NULL;\t/* data block buffer */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry */\n\tint\t\t\terror = 0;\t/* error return value */\n\tint\t\t\tlength;\t\t/* temporary length value */\n\tint\t\t\tbyteoff;\t/* offset in current block */\n\txfs_dir2_off_t\t\tcuroff;\t\t/* current overall offset */\n\txfs_dir2_off_t\t\tnewoff;\t\t/* new curoff after new blk */\n\tchar\t\t\t*ptr = NULL;\t/* pointer to current data */\n\tstruct xfs_dir2_leaf_map_info *map_info;\n\tstruct xfs_da_geometry\t*geo = args->geo;\n\n\t/*\n\t * If the offset is at or past the largest allowed value,\n\t * give up right away.\n\t */\n\tif (ctx->pos >= XFS_DIR2_MAX_DATAPTR)\n\t\treturn 0;\n\n\t/*\n\t * Set up to bmap a number of blocks based on the caller's\n\t * buffer size, the directory block size, and the filesystem\n\t * block size.\n\t */\n\tlength = howmany(bufsize + geo->blksize, (1 << geo->fsblog));\n\tmap_info = kmem_zalloc(offsetof(struct xfs_dir2_leaf_map_info, map) +\n\t\t\t\t(length * sizeof(struct xfs_bmbt_irec)),\n\t\t\t       KM_SLEEP | KM_NOFS);\n\tmap_info->map_size = length;\n\n\t/*\n\t * Inside the loop we keep the main offset value as a byte offset\n\t * in the directory file.\n\t */\n\tcuroff = xfs_dir2_dataptr_to_byte(ctx->pos);\n\n\t/*\n\t * Force this conversion through db so we truncate the offset\n\t * down to get the start of the data block.\n\t */\n\tmap_info->map_off = xfs_dir2_db_to_da(geo,\n\t\t\t\t\t      xfs_dir2_byte_to_db(geo, curoff));\n\n\t/*\n\t * Loop over directory entries until we reach the end offset.\n\t * Get more blocks and readahead as necessary.\n\t */\n\twhile (curoff < XFS_DIR2_LEAF_OFFSET) {\n\t\t__uint8_t filetype;\n\n\t\t/*\n\t\t * If we have no buffer, or we're off the end of the\n\t\t * current buffer, need to get another one.\n\t\t */\n\t\tif (!bp || ptr >= (char *)bp->b_addr + geo->blksize) {\n\n\t\t\terror = xfs_dir2_leaf_readbuf(args, bufsize, map_info,\n\t\t\t\t\t\t      &curoff, &bp);\n\t\t\tif (error || !map_info->map_valid)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * Having done a read, we need to set a new offset.\n\t\t\t */\n\t\t\tnewoff = xfs_dir2_db_off_to_byte(geo,\n\t\t\t\t\t\t\t map_info->curdb, 0);\n\t\t\t/*\n\t\t\t * Start of the current block.\n\t\t\t */\n\t\t\tif (curoff < newoff)\n\t\t\t\tcuroff = newoff;\n\t\t\t/*\n\t\t\t * Make sure we're in the right block.\n\t\t\t */\n\t\t\telse if (curoff > newoff)\n\t\t\t\tASSERT(xfs_dir2_byte_to_db(geo, curoff) ==\n\t\t\t\t       map_info->curdb);\n\t\t\thdr = bp->b_addr;\n\t\t\txfs_dir3_data_check(dp, bp);\n\t\t\t/*\n\t\t\t * Find our position in the block.\n\t\t\t */\n\t\t\tptr = (char *)dp->d_ops->data_entry_p(hdr);\n\t\t\tbyteoff = xfs_dir2_byte_to_off(geo, curoff);\n\t\t\t/*\n\t\t\t * Skip past the header.\n\t\t\t */\n\t\t\tif (byteoff == 0)\n\t\t\t\tcuroff += dp->d_ops->data_entry_offset;\n\t\t\t/*\n\t\t\t * Skip past entries until we reach our offset.\n\t\t\t */\n\t\t\telse {\n\t\t\t\twhile ((char *)ptr - (char *)hdr < byteoff) {\n\t\t\t\t\tdup = (xfs_dir2_data_unused_t *)ptr;\n\n\t\t\t\t\tif (be16_to_cpu(dup->freetag)\n\t\t\t\t\t\t  == XFS_DIR2_DATA_FREE_TAG) {\n\n\t\t\t\t\t\tlength = be16_to_cpu(dup->length);\n\t\t\t\t\t\tptr += length;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdep = (xfs_dir2_data_entry_t *)ptr;\n\t\t\t\t\tlength =\n\t\t\t\t\t   dp->d_ops->data_entsize(dep->namelen);\n\t\t\t\t\tptr += length;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Now set our real offset.\n\t\t\t\t */\n\t\t\t\tcuroff =\n\t\t\t\t\txfs_dir2_db_off_to_byte(geo,\n\t\t\t\t\t    xfs_dir2_byte_to_db(geo, curoff),\n\t\t\t\t\t    (char *)ptr - (char *)hdr);\n\t\t\t\tif (ptr >= (char *)hdr + geo->blksize) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * We have a pointer to an entry.\n\t\t * Is it a live one?\n\t\t */\n\t\tdup = (xfs_dir2_data_unused_t *)ptr;\n\t\t/*\n\t\t * No, it's unused, skip over it.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tlength = be16_to_cpu(dup->length);\n\t\t\tptr += length;\n\t\t\tcuroff += length;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdep = (xfs_dir2_data_entry_t *)ptr;\n\t\tlength = dp->d_ops->data_entsize(dep->namelen);\n\t\tfiletype = dp->d_ops->data_get_ftype(dep);\n\n\t\tctx->pos = xfs_dir2_byte_to_dataptr(curoff) & 0x7fffffff;\n\t\tif (!dir_emit(ctx, (char *)dep->name, dep->namelen,\n\t\t\t    be64_to_cpu(dep->inumber),\n\t\t\t    xfs_dir3_get_dtype(dp->i_mount, filetype)))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Advance to next entry in the block.\n\t\t */\n\t\tptr += length;\n\t\tcuroff += length;\n\t\t/* bufsize may have just been a guess; don't go negative */\n\t\tbufsize = bufsize > length ? bufsize - length : 0;\n\t}\n\n\t/*\n\t * All done.  Set output offset value to current offset.\n\t */\n\tif (curoff > xfs_dir2_dataptr_to_byte(XFS_DIR2_MAX_DATAPTR))\n\t\tctx->pos = XFS_DIR2_MAX_DATAPTR & 0x7fffffff;\n\telse\n\t\tctx->pos = xfs_dir2_byte_to_dataptr(curoff) & 0x7fffffff;\n\tkmem_free(map_info);\n\tif (bp)\n\t\txfs_trans_brelse(NULL, bp);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_dir2_leaf_readbuf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dir2_readdir.c",
    "lines": "267-463",
    "snippet": "STATIC int\nxfs_dir2_leaf_readbuf(\n\tstruct xfs_da_args\t*args,\n\tsize_t\t\t\tbufsize,\n\tstruct xfs_dir2_leaf_map_info *mip,\n\txfs_dir2_off_t\t\t*curoff,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_buf\t\t*bp = *bpp;\n\tstruct xfs_bmbt_irec\t*map = mip->map;\n\tstruct blk_plug\t\tplug;\n\tint\t\t\terror = 0;\n\tint\t\t\tlength;\n\tint\t\t\ti;\n\tint\t\t\tj;\n\tstruct xfs_da_geometry\t*geo = args->geo;\n\n\t/*\n\t * If we have a buffer, we need to release it and\n\t * take it out of the mapping.\n\t */\n\n\tif (bp) {\n\t\txfs_trans_brelse(NULL, bp);\n\t\tbp = NULL;\n\t\tmip->map_blocks -= geo->fsbcount;\n\t\t/*\n\t\t * Loop to get rid of the extents for the\n\t\t * directory block.\n\t\t */\n\t\tfor (i = geo->fsbcount; i > 0; ) {\n\t\t\tj = min_t(int, map->br_blockcount, i);\n\t\t\tmap->br_blockcount -= j;\n\t\t\tmap->br_startblock += j;\n\t\t\tmap->br_startoff += j;\n\t\t\t/*\n\t\t\t * If mapping is done, pitch it from\n\t\t\t * the table.\n\t\t\t */\n\t\t\tif (!map->br_blockcount && --mip->map_valid)\n\t\t\t\tmemmove(&map[0], &map[1],\n\t\t\t\t\tsizeof(map[0]) * mip->map_valid);\n\t\t\ti -= j;\n\t\t}\n\t}\n\n\t/*\n\t * Recalculate the readahead blocks wanted.\n\t */\n\tmip->ra_want = howmany(bufsize + geo->blksize, (1 << geo->fsblog)) - 1;\n\tASSERT(mip->ra_want >= 0);\n\n\t/*\n\t * If we don't have as many as we want, and we haven't\n\t * run out of data blocks, get some more mappings.\n\t */\n\tif (1 + mip->ra_want > mip->map_blocks &&\n\t    mip->map_off < xfs_dir2_byte_to_da(geo, XFS_DIR2_LEAF_OFFSET)) {\n\t\t/*\n\t\t * Get more bmaps, fill in after the ones\n\t\t * we already have in the table.\n\t\t */\n\t\tmip->nmap = mip->map_size - mip->map_valid;\n\t\terror = xfs_bmapi_read(dp, mip->map_off,\n\t\t\t\txfs_dir2_byte_to_da(geo, XFS_DIR2_LEAF_OFFSET) -\n\t\t\t\t\t\t\t\tmip->map_off,\n\t\t\t\t&map[mip->map_valid], &mip->nmap, 0);\n\n\t\t/*\n\t\t * Don't know if we should ignore this or try to return an\n\t\t * error.  The trouble with returning errors is that readdir\n\t\t * will just stop without actually passing the error through.\n\t\t */\n\t\tif (error)\n\t\t\tgoto out;\t/* XXX */\n\n\t\t/*\n\t\t * If we got all the mappings we asked for, set the final map\n\t\t * offset based on the last bmap value received.  Otherwise,\n\t\t * we've reached the end.\n\t\t */\n\t\tif (mip->nmap == mip->map_size - mip->map_valid) {\n\t\t\ti = mip->map_valid + mip->nmap - 1;\n\t\t\tmip->map_off = map[i].br_startoff + map[i].br_blockcount;\n\t\t} else\n\t\t\tmip->map_off = xfs_dir2_byte_to_da(geo,\n\t\t\t\t\t\t\tXFS_DIR2_LEAF_OFFSET);\n\n\t\t/*\n\t\t * Look for holes in the mapping, and eliminate them.  Count up\n\t\t * the valid blocks.\n\t\t */\n\t\tfor (i = mip->map_valid; i < mip->map_valid + mip->nmap; ) {\n\t\t\tif (map[i].br_startblock == HOLESTARTBLOCK) {\n\t\t\t\tmip->nmap--;\n\t\t\t\tlength = mip->map_valid + mip->nmap - i;\n\t\t\t\tif (length)\n\t\t\t\t\tmemmove(&map[i], &map[i + 1],\n\t\t\t\t\t\tsizeof(map[i]) * length);\n\t\t\t} else {\n\t\t\t\tmip->map_blocks += map[i].br_blockcount;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tmip->map_valid += mip->nmap;\n\t}\n\n\t/*\n\t * No valid mappings, so no more data blocks.\n\t */\n\tif (!mip->map_valid) {\n\t\t*curoff = xfs_dir2_da_to_byte(geo, mip->map_off);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Read the directory block starting at the first mapping.\n\t */\n\tmip->curdb = xfs_dir2_da_to_db(geo, map->br_startoff);\n\terror = xfs_dir3_data_read(NULL, dp, map->br_startoff,\n\t\t\tmap->br_blockcount >= geo->fsbcount ?\n\t\t\t    XFS_FSB_TO_DADDR(dp->i_mount, map->br_startblock) :\n\t\t\t    -1, &bp);\n\t/*\n\t * Should just skip over the data block instead of giving up.\n\t */\n\tif (error)\n\t\tgoto out;\t/* XXX */\n\n\t/*\n\t * Adjust the current amount of read-ahead: we just read a block that\n\t * was previously ra.\n\t */\n\tif (mip->ra_current)\n\t\tmip->ra_current -= geo->fsbcount;\n\n\t/*\n\t * Do we need more readahead?\n\t */\n\tblk_start_plug(&plug);\n\tfor (mip->ra_index = mip->ra_offset = i = 0;\n\t     mip->ra_want > mip->ra_current && i < mip->map_blocks;\n\t     i += geo->fsbcount) {\n\t\tASSERT(mip->ra_index < mip->map_valid);\n\t\t/*\n\t\t * Read-ahead a contiguous directory block.\n\t\t */\n\t\tif (i > mip->ra_current &&\n\t\t    map[mip->ra_index].br_blockcount >= geo->fsbcount) {\n\t\t\txfs_dir3_data_readahead(dp,\n\t\t\t\tmap[mip->ra_index].br_startoff + mip->ra_offset,\n\t\t\t\tXFS_FSB_TO_DADDR(dp->i_mount,\n\t\t\t\t\tmap[mip->ra_index].br_startblock +\n\t\t\t\t\t\t\tmip->ra_offset));\n\t\t\tmip->ra_current = i;\n\t\t}\n\n\t\t/*\n\t\t * Read-ahead a non-contiguous directory block.  This doesn't\n\t\t * use our mapping, but this is a very rare case.\n\t\t */\n\t\telse if (i > mip->ra_current) {\n\t\t\txfs_dir3_data_readahead(dp,\n\t\t\t\t\tmap[mip->ra_index].br_startoff +\n\t\t\t\t\t\t\tmip->ra_offset, -1);\n\t\t\tmip->ra_current = i;\n\t\t}\n\n\t\t/*\n\t\t * Advance offset through the mapping table.\n\t\t */\n\t\tfor (j = 0; j < geo->fsbcount; j += length ) {\n\t\t\t/*\n\t\t\t * The rest of this extent but not more than a dir\n\t\t\t * block.\n\t\t\t */\n\t\t\tlength = min_t(int, geo->fsbcount,\n\t\t\t\t\tmap[mip->ra_index].br_blockcount -\n\t\t\t\t\t\t\tmip->ra_offset);\n\t\t\tmip->ra_offset += length;\n\n\t\t\t/*\n\t\t\t * Advance to the next mapping if this one is used up.\n\t\t\t */\n\t\t\tif (mip->ra_offset == map[mip->ra_index].br_blockcount) {\n\t\t\t\tmip->ra_offset = 0;\n\t\t\t\tmip->ra_index++;\n\t\t\t}\n\t\t}\n\t}\n\tblk_finish_plug(&plug);\n\nout:\n\t*bpp = bp;\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_finish_plug",
          "args": [
            "&plug"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "geo->fsbcount",
            "map[mip->ra_index].br_blockcount -\n\t\t\t\t\t\t\tmip->ra_offset"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_data_readahead",
          "args": [
            "dp",
            "map[mip->ra_index].br_startoff +\n\t\t\t\t\t\t\tmip->ra_offset",
            "-1"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_data_readahead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "330-338",
          "snippet": "int\nxfs_dir3_data_readahead(\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmapped_bno)\n{\n\treturn xfs_da_reada_buf(dp, bno, mapped_bno,\n\t\t\t\tXFS_DATA_FORK, &xfs_dir3_data_reada_buf_ops);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct xfs_buf_ops xfs_dir3_data_reada_buf_ops = {\n\t.verify_read = xfs_dir3_data_reada_verify,\n\t.verify_write = xfs_dir3_data_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic const struct xfs_buf_ops xfs_dir3_data_reada_buf_ops = {\n\t.verify_read = xfs_dir3_data_reada_verify,\n\t.verify_write = xfs_dir3_data_write_verify,\n};\n\nint\nxfs_dir3_data_readahead(\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmapped_bno)\n{\n\treturn xfs_da_reada_buf(dp, bno, mapped_bno,\n\t\t\t\tXFS_DATA_FORK, &xfs_dir3_data_reada_buf_ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_DADDR",
          "args": [
            "dp->i_mount",
            "map[mip->ra_index].br_startblock +\n\t\t\t\t\t\t\tmip->ra_offset"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "mip->ra_index < mip->map_valid"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_start_plug",
          "args": [
            "&plug"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_data_read",
          "args": [
            "NULL",
            "dp",
            "map->br_startoff",
            "map->br_blockcount >= geo->fsbcount ?\n\t\t\t    XFS_FSB_TO_DADDR(dp->i_mount, map->br_startblock) :\n\t\t\t    -1",
            "&bp"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_data_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "313-328",
          "snippet": "int\nxfs_dir3_data_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmapped_bno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mapped_bno, bpp,\n\t\t\t\tXFS_DATA_FORK, &xfs_dir3_data_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_DIR_DATA_BUF);\n\treturn err;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_dir3_data_buf_ops = {\n\t.verify_read = xfs_dir3_data_read_verify,\n\t.verify_write = xfs_dir3_data_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_dir3_data_buf_ops = {\n\t.verify_read = xfs_dir3_data_read_verify,\n\t.verify_write = xfs_dir3_data_write_verify,\n};\n\nint\nxfs_dir3_data_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmapped_bno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mapped_bno, bpp,\n\t\t\t\tXFS_DATA_FORK, &xfs_dir3_data_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_DIR_DATA_BUF);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_DADDR",
          "args": [
            "dp->i_mount",
            "map->br_startblock"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_da_to_db",
          "args": [
            "geo",
            "map->br_startoff"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_da_to_db",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "287-291",
          "snippet": "static inline xfs_dir2_db_t\nxfs_dir2_da_to_db(struct xfs_da_geometry *geo, xfs_dablk_t da)\n{\n\treturn (xfs_dir2_db_t)(da >> (geo->blklog - geo->fsblog));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_db_t\nxfs_dir2_da_to_db(struct xfs_da_geometry *geo, xfs_dablk_t da)\n{\n\treturn (xfs_dir2_db_t)(da >> (geo->blklog - geo->fsblog));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_da_to_byte",
          "args": [
            "geo",
            "mip->map_off"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_da_to_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "296-300",
          "snippet": "static inline xfs_dir2_off_t\nxfs_dir2_da_to_byte(struct xfs_da_geometry *geo, xfs_dablk_t da)\n{\n\treturn xfs_dir2_db_off_to_byte(geo, xfs_dir2_da_to_db(geo, da), 0);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_off_t\nxfs_dir2_da_to_byte(struct xfs_da_geometry *geo, xfs_dablk_t da)\n{\n\treturn xfs_dir2_db_off_to_byte(geo, xfs_dir2_da_to_db(geo, da), 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&map[i]",
            "&map[i + 1]",
            "sizeof(map[i]) * length"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_byte_to_da",
          "args": [
            "geo",
            "XFS_DIR2_LEAF_OFFSET"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_byte_to_da",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "268-272",
          "snippet": "static inline xfs_dablk_t\nxfs_dir2_byte_to_da(struct xfs_da_geometry *geo, xfs_dir2_off_t by)\n{\n\treturn xfs_dir2_db_to_da(geo, xfs_dir2_byte_to_db(geo, by));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dablk_t\nxfs_dir2_byte_to_da(struct xfs_da_geometry *geo, xfs_dir2_off_t by)\n{\n\treturn xfs_dir2_db_to_da(geo, xfs_dir2_byte_to_db(geo, by));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmapi_read",
          "args": [
            "dp",
            "mip->map_off",
            "xfs_dir2_byte_to_da(geo, XFS_DIR2_LEAF_OFFSET) -\n\t\t\t\t\t\t\t\tmip->map_off",
            "&map[mip->map_valid]",
            "&mip->nmap",
            "0"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmapi_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "4017-4103",
          "snippet": "int\nxfs_bmapi_read(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tstruct xfs_bmbt_irec\t*mval,\n\tint\t\t\t*nmap,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_bmbt_irec\tprev;\n\txfs_fileoff_t\t\tobno;\n\txfs_fileoff_t\t\tend;\n\txfs_extnum_t\t\tlastx;\n\tint\t\t\terror;\n\tint\t\t\teof;\n\tint\t\t\tn = 0;\n\tint\t\t\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(!(flags & ~(XFS_BMAPI_ATTRFORK|XFS_BMAPI_ENTIRE|\n\t\t\t   XFS_BMAPI_IGSTATE)));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED|XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_read\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_blk_mapr);\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(NULL, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got, &prev);\n\tend = bno + len;\n\tobno = bno;\n\n\twhile (bno < end && n < *nmap) {\n\t\t/* Reading past eof, act as though there's a hole up to end. */\n\t\tif (eof)\n\t\t\tgot.br_startoff = end;\n\t\tif (got.br_startoff > bno) {\n\t\t\t/* Reading in a hole.  */\n\t\t\tmval->br_startoff = bno;\n\t\t\tmval->br_startblock = HOLESTARTBLOCK;\n\t\t\tmval->br_blockcount =\n\t\t\t\tXFS_FILBLKS_MIN(len, got.br_startoff - bno);\n\t\t\tmval->br_state = XFS_EXT_NORM;\n\t\t\tbno += mval->br_blockcount;\n\t\t\tlen -= mval->br_blockcount;\n\t\t\tmval++;\n\t\t\tn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* set up the extent map to return. */\n\t\txfs_bmapi_trim_map(mval, &got, &bno, len, obno, end, n, flags);\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/* If we're done, stop now. */\n\t\tif (bno >= end || n >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tif (++lastx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t))\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx), &got);\n\t\telse\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmapi_read(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tstruct xfs_bmbt_irec\t*mval,\n\tint\t\t\t*nmap,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_bmbt_irec\tprev;\n\txfs_fileoff_t\t\tobno;\n\txfs_fileoff_t\t\tend;\n\txfs_extnum_t\t\tlastx;\n\tint\t\t\terror;\n\tint\t\t\teof;\n\tint\t\t\tn = 0;\n\tint\t\t\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(!(flags & ~(XFS_BMAPI_ATTRFORK|XFS_BMAPI_ENTIRE|\n\t\t\t   XFS_BMAPI_IGSTATE)));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED|XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_read\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_blk_mapr);\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(NULL, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got, &prev);\n\tend = bno + len;\n\tobno = bno;\n\n\twhile (bno < end && n < *nmap) {\n\t\t/* Reading past eof, act as though there's a hole up to end. */\n\t\tif (eof)\n\t\t\tgot.br_startoff = end;\n\t\tif (got.br_startoff > bno) {\n\t\t\t/* Reading in a hole.  */\n\t\t\tmval->br_startoff = bno;\n\t\t\tmval->br_startblock = HOLESTARTBLOCK;\n\t\t\tmval->br_blockcount =\n\t\t\t\tXFS_FILBLKS_MIN(len, got.br_startoff - bno);\n\t\t\tmval->br_state = XFS_EXT_NORM;\n\t\t\tbno += mval->br_blockcount;\n\t\t\tlen -= mval->br_blockcount;\n\t\t\tmval++;\n\t\t\tn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* set up the extent map to return. */\n\t\txfs_bmapi_trim_map(mval, &got, &bno, len, obno, end, n, flags);\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/* If we're done, stop now. */\n\t\tif (bno >= end || n >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tif (++lastx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t))\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx), &got);\n\t\telse\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "mip->ra_want >= 0"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "howmany",
          "args": [
            "bufsize + geo->blksize",
            "(1 << geo->fsblog)"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "howmany_64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "340-345",
          "snippet": "static inline __uint64_t howmany_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline __uint64_t howmany_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&map[0]",
            "&map[1]",
            "sizeof(map[0]) * mip->map_valid"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "map->br_blockcount",
            "i"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "NULL",
            "bp"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_dir2_leaf_readbuf(\n\tstruct xfs_da_args\t*args,\n\tsize_t\t\t\tbufsize,\n\tstruct xfs_dir2_leaf_map_info *mip,\n\txfs_dir2_off_t\t\t*curoff,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_buf\t\t*bp = *bpp;\n\tstruct xfs_bmbt_irec\t*map = mip->map;\n\tstruct blk_plug\t\tplug;\n\tint\t\t\terror = 0;\n\tint\t\t\tlength;\n\tint\t\t\ti;\n\tint\t\t\tj;\n\tstruct xfs_da_geometry\t*geo = args->geo;\n\n\t/*\n\t * If we have a buffer, we need to release it and\n\t * take it out of the mapping.\n\t */\n\n\tif (bp) {\n\t\txfs_trans_brelse(NULL, bp);\n\t\tbp = NULL;\n\t\tmip->map_blocks -= geo->fsbcount;\n\t\t/*\n\t\t * Loop to get rid of the extents for the\n\t\t * directory block.\n\t\t */\n\t\tfor (i = geo->fsbcount; i > 0; ) {\n\t\t\tj = min_t(int, map->br_blockcount, i);\n\t\t\tmap->br_blockcount -= j;\n\t\t\tmap->br_startblock += j;\n\t\t\tmap->br_startoff += j;\n\t\t\t/*\n\t\t\t * If mapping is done, pitch it from\n\t\t\t * the table.\n\t\t\t */\n\t\t\tif (!map->br_blockcount && --mip->map_valid)\n\t\t\t\tmemmove(&map[0], &map[1],\n\t\t\t\t\tsizeof(map[0]) * mip->map_valid);\n\t\t\ti -= j;\n\t\t}\n\t}\n\n\t/*\n\t * Recalculate the readahead blocks wanted.\n\t */\n\tmip->ra_want = howmany(bufsize + geo->blksize, (1 << geo->fsblog)) - 1;\n\tASSERT(mip->ra_want >= 0);\n\n\t/*\n\t * If we don't have as many as we want, and we haven't\n\t * run out of data blocks, get some more mappings.\n\t */\n\tif (1 + mip->ra_want > mip->map_blocks &&\n\t    mip->map_off < xfs_dir2_byte_to_da(geo, XFS_DIR2_LEAF_OFFSET)) {\n\t\t/*\n\t\t * Get more bmaps, fill in after the ones\n\t\t * we already have in the table.\n\t\t */\n\t\tmip->nmap = mip->map_size - mip->map_valid;\n\t\terror = xfs_bmapi_read(dp, mip->map_off,\n\t\t\t\txfs_dir2_byte_to_da(geo, XFS_DIR2_LEAF_OFFSET) -\n\t\t\t\t\t\t\t\tmip->map_off,\n\t\t\t\t&map[mip->map_valid], &mip->nmap, 0);\n\n\t\t/*\n\t\t * Don't know if we should ignore this or try to return an\n\t\t * error.  The trouble with returning errors is that readdir\n\t\t * will just stop without actually passing the error through.\n\t\t */\n\t\tif (error)\n\t\t\tgoto out;\t/* XXX */\n\n\t\t/*\n\t\t * If we got all the mappings we asked for, set the final map\n\t\t * offset based on the last bmap value received.  Otherwise,\n\t\t * we've reached the end.\n\t\t */\n\t\tif (mip->nmap == mip->map_size - mip->map_valid) {\n\t\t\ti = mip->map_valid + mip->nmap - 1;\n\t\t\tmip->map_off = map[i].br_startoff + map[i].br_blockcount;\n\t\t} else\n\t\t\tmip->map_off = xfs_dir2_byte_to_da(geo,\n\t\t\t\t\t\t\tXFS_DIR2_LEAF_OFFSET);\n\n\t\t/*\n\t\t * Look for holes in the mapping, and eliminate them.  Count up\n\t\t * the valid blocks.\n\t\t */\n\t\tfor (i = mip->map_valid; i < mip->map_valid + mip->nmap; ) {\n\t\t\tif (map[i].br_startblock == HOLESTARTBLOCK) {\n\t\t\t\tmip->nmap--;\n\t\t\t\tlength = mip->map_valid + mip->nmap - i;\n\t\t\t\tif (length)\n\t\t\t\t\tmemmove(&map[i], &map[i + 1],\n\t\t\t\t\t\tsizeof(map[i]) * length);\n\t\t\t} else {\n\t\t\t\tmip->map_blocks += map[i].br_blockcount;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tmip->map_valid += mip->nmap;\n\t}\n\n\t/*\n\t * No valid mappings, so no more data blocks.\n\t */\n\tif (!mip->map_valid) {\n\t\t*curoff = xfs_dir2_da_to_byte(geo, mip->map_off);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Read the directory block starting at the first mapping.\n\t */\n\tmip->curdb = xfs_dir2_da_to_db(geo, map->br_startoff);\n\terror = xfs_dir3_data_read(NULL, dp, map->br_startoff,\n\t\t\tmap->br_blockcount >= geo->fsbcount ?\n\t\t\t    XFS_FSB_TO_DADDR(dp->i_mount, map->br_startblock) :\n\t\t\t    -1, &bp);\n\t/*\n\t * Should just skip over the data block instead of giving up.\n\t */\n\tif (error)\n\t\tgoto out;\t/* XXX */\n\n\t/*\n\t * Adjust the current amount of read-ahead: we just read a block that\n\t * was previously ra.\n\t */\n\tif (mip->ra_current)\n\t\tmip->ra_current -= geo->fsbcount;\n\n\t/*\n\t * Do we need more readahead?\n\t */\n\tblk_start_plug(&plug);\n\tfor (mip->ra_index = mip->ra_offset = i = 0;\n\t     mip->ra_want > mip->ra_current && i < mip->map_blocks;\n\t     i += geo->fsbcount) {\n\t\tASSERT(mip->ra_index < mip->map_valid);\n\t\t/*\n\t\t * Read-ahead a contiguous directory block.\n\t\t */\n\t\tif (i > mip->ra_current &&\n\t\t    map[mip->ra_index].br_blockcount >= geo->fsbcount) {\n\t\t\txfs_dir3_data_readahead(dp,\n\t\t\t\tmap[mip->ra_index].br_startoff + mip->ra_offset,\n\t\t\t\tXFS_FSB_TO_DADDR(dp->i_mount,\n\t\t\t\t\tmap[mip->ra_index].br_startblock +\n\t\t\t\t\t\t\tmip->ra_offset));\n\t\t\tmip->ra_current = i;\n\t\t}\n\n\t\t/*\n\t\t * Read-ahead a non-contiguous directory block.  This doesn't\n\t\t * use our mapping, but this is a very rare case.\n\t\t */\n\t\telse if (i > mip->ra_current) {\n\t\t\txfs_dir3_data_readahead(dp,\n\t\t\t\t\tmap[mip->ra_index].br_startoff +\n\t\t\t\t\t\t\tmip->ra_offset, -1);\n\t\t\tmip->ra_current = i;\n\t\t}\n\n\t\t/*\n\t\t * Advance offset through the mapping table.\n\t\t */\n\t\tfor (j = 0; j < geo->fsbcount; j += length ) {\n\t\t\t/*\n\t\t\t * The rest of this extent but not more than a dir\n\t\t\t * block.\n\t\t\t */\n\t\t\tlength = min_t(int, geo->fsbcount,\n\t\t\t\t\tmap[mip->ra_index].br_blockcount -\n\t\t\t\t\t\t\tmip->ra_offset);\n\t\t\tmip->ra_offset += length;\n\n\t\t\t/*\n\t\t\t * Advance to the next mapping if this one is used up.\n\t\t\t */\n\t\t\tif (mip->ra_offset == map[mip->ra_index].br_blockcount) {\n\t\t\t\tmip->ra_offset = 0;\n\t\t\t\tmip->ra_index++;\n\t\t\t}\n\t\t}\n\t}\n\tblk_finish_plug(&plug);\n\nout:\n\t*bpp = bp;\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_dir2_block_getdents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dir2_readdir.c",
    "lines": "157-251",
    "snippet": "STATIC int\nxfs_dir2_block_getdents(\n\tstruct xfs_da_args\t*args,\n\tstruct dir_context\t*ctx)\n{\n\tstruct xfs_inode\t*dp = args->dp;\t/* incore directory inode */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\tstruct xfs_buf\t\t*bp;\t\t/* buffer for block */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* block data entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* block unused entry */\n\tchar\t\t\t*endptr;\t/* end of the data entries */\n\tint\t\t\terror;\t\t/* error return value */\n\tchar\t\t\t*ptr;\t\t/* current data entry */\n\tint\t\t\twantoff;\t/* starting block offset */\n\txfs_off_t\t\tcook;\n\tstruct xfs_da_geometry\t*geo = args->geo;\n\n\t/*\n\t * If the block number in the offset is out of range, we're done.\n\t */\n\tif (xfs_dir2_dataptr_to_db(geo, ctx->pos) > geo->datablk)\n\t\treturn 0;\n\n\terror = xfs_dir3_block_read(NULL, dp, &bp);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Extract the byte offset we start at from the seek pointer.\n\t * We'll skip entries before this.\n\t */\n\twantoff = xfs_dir2_dataptr_to_off(geo, ctx->pos);\n\thdr = bp->b_addr;\n\txfs_dir3_data_check(dp, bp);\n\t/*\n\t * Set up values for the loop.\n\t */\n\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\tptr = (char *)dp->d_ops->data_entry_p(hdr);\n\tendptr = (char *)xfs_dir2_block_leaf_p(btp);\n\n\t/*\n\t * Loop over the data portion of the block.\n\t * Each object is a real entry (dep) or an unused one (dup).\n\t */\n\twhile (ptr < endptr) {\n\t\t__uint8_t filetype;\n\n\t\tdup = (xfs_dir2_data_unused_t *)ptr;\n\t\t/*\n\t\t * Unused, skip it.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tptr += be16_to_cpu(dup->length);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdep = (xfs_dir2_data_entry_t *)ptr;\n\n\t\t/*\n\t\t * Bump pointer for the next iteration.\n\t\t */\n\t\tptr += dp->d_ops->data_entsize(dep->namelen);\n\t\t/*\n\t\t * The entry is before the desired starting point, skip it.\n\t\t */\n\t\tif ((char *)dep - (char *)hdr < wantoff)\n\t\t\tcontinue;\n\n\t\tcook = xfs_dir2_db_off_to_dataptr(geo, geo->datablk,\n\t\t\t\t\t    (char *)dep - (char *)hdr);\n\n\t\tctx->pos = cook & 0x7fffffff;\n\t\tfiletype = dp->d_ops->data_get_ftype(dep);\n\t\t/*\n\t\t * If it didn't fit, set the final offset to here & return.\n\t\t */\n\t\tif (!dir_emit(ctx, (char *)dep->name, dep->namelen,\n\t\t\t    be64_to_cpu(dep->inumber),\n\t\t\t    xfs_dir3_get_dtype(dp->i_mount, filetype))) {\n\t\t\txfs_trans_brelse(NULL, bp);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Reached the end of the block.\n\t * Set the offset to a non-existent block 1 and return.\n\t */\n\tctx->pos = xfs_dir2_db_off_to_dataptr(geo, geo->datablk + 1, 0) &\n\t\t\t\t\t\t\t\t0x7fffffff;\n\txfs_trans_brelse(NULL, bp);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "NULL",
            "bp"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_db_off_to_dataptr",
          "args": [
            "geo",
            "geo->datablk + 1",
            "0"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_db_off_to_dataptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "277-282",
          "snippet": "static inline xfs_dir2_dataptr_t\nxfs_dir2_db_off_to_dataptr(struct xfs_da_geometry *geo, xfs_dir2_db_t db,\n\t\t\t   xfs_dir2_data_aoff_t o)\n{\n\treturn xfs_dir2_byte_to_dataptr(xfs_dir2_db_off_to_byte(geo, db, o));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_dataptr_t\nxfs_dir2_db_off_to_dataptr(struct xfs_da_geometry *geo, xfs_dir2_db_t db,\n\t\t\t   xfs_dir2_data_aoff_t o)\n{\n\treturn xfs_dir2_byte_to_dataptr(xfs_dir2_db_off_to_byte(geo, db, o));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "(char *)dep->name",
            "dep->namelen",
            "be64_to_cpu(dep->inumber)",
            "xfs_dir3_get_dtype(dp->i_mount, filetype)"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_get_dtype",
          "args": [
            "dp->i_mount",
            "filetype"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_get_dtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dir2_readdir.c",
          "lines": "44-56",
          "snippet": "static unsigned char\nxfs_dir3_get_dtype(\n\tstruct xfs_mount\t*mp,\n\t__uint8_t\t\tfiletype)\n{\n\tif (!xfs_sb_version_hasftype(&mp->m_sb))\n\t\treturn DT_UNKNOWN;\n\n\tif (filetype >= XFS_DIR3_FT_MAX)\n\t\treturn DT_UNKNOWN;\n\n\treturn xfs_dir3_filetype_table[filetype];\n}",
          "includes": [
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned char xfs_dir3_filetype_table[] = {\n\tDT_UNKNOWN, DT_REG, DT_DIR, DT_CHR, DT_BLK,\n\tDT_FIFO, DT_SOCK, DT_LNK, DT_WHT,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic unsigned char xfs_dir3_filetype_table[] = {\n\tDT_UNKNOWN, DT_REG, DT_DIR, DT_CHR, DT_BLK,\n\tDT_FIFO, DT_SOCK, DT_LNK, DT_WHT,\n};\n\nstatic unsigned char\nxfs_dir3_get_dtype(\n\tstruct xfs_mount\t*mp,\n\t__uint8_t\t\tfiletype)\n{\n\tif (!xfs_sb_version_hasftype(&mp->m_sb))\n\t\treturn DT_UNKNOWN;\n\n\tif (filetype >= XFS_DIR3_FT_MAX)\n\t\treturn DT_UNKNOWN;\n\n\treturn xfs_dir3_filetype_table[filetype];\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dep->inumber"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_get_ftype",
          "args": [
            "dep"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_entsize",
          "args": [
            "dep->namelen"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dup->length"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dup->freetag"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_leaf_p",
          "args": [
            "btp"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_leaf_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "601-605",
          "snippet": "static inline struct xfs_dir2_leaf_entry *\nxfs_dir2_block_leaf_p(struct xfs_dir2_block_tail *btp)\n{\n\treturn ((struct xfs_dir2_leaf_entry *)btp) - be32_to_cpu(btp->count);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_leaf_entry *\nxfs_dir2_block_leaf_p(struct xfs_dir2_block_tail *btp)\n{\n\treturn ((struct xfs_dir2_leaf_entry *)btp) - be32_to_cpu(btp->count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_entry_p",
          "args": [
            "hdr"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_block_tail_p",
          "args": [
            "geo",
            "hdr"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_block_tail_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "305-310",
          "snippet": "static inline struct xfs_dir2_block_tail *\nxfs_dir2_block_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_data_hdr *hdr)\n{\n\treturn ((struct xfs_dir2_block_tail *)\n\t\t((char *)hdr + geo->blksize)) - 1;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_block_tail *\nxfs_dir2_block_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_data_hdr *hdr)\n{\n\treturn ((struct xfs_dir2_block_tail *)\n\t\t((char *)hdr + geo->blksize)) - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir3_data_check",
          "args": [
            "dp",
            "bp"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "__xfs_dir3_data_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "40-210",
          "snippet": "int\n__xfs_dir3_data_check(\n\tstruct xfs_inode\t*dp,\t\t/* incore inode pointer */\n\tstruct xfs_buf\t\t*bp)\t\t/* data block's buffer */\n{\n\txfs_dir2_dataptr_t\taddr;\t\t/* addr for leaf lookup */\n\txfs_dir2_data_free_t\t*bf;\t\t/* bestfree table */\n\txfs_dir2_block_tail_t\t*btp=NULL;\t/* block tail */\n\tint\t\t\tcount;\t\t/* count of entries found */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry */\n\tchar\t\t\t*endp;\t\t/* end of useful data */\n\tint\t\t\tfreeseen;\t/* mask of bestfrees seen */\n\txfs_dahash_t\t\thash;\t\t/* hash of current name */\n\tint\t\t\ti;\t\t/* leaf index */\n\tint\t\t\tlastfree;\t/* last entry was unused */\n\txfs_dir2_leaf_entry_t\t*lep=NULL;\t/* block leaf entries */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tchar\t\t\t*p;\t\t/* current data position */\n\tint\t\t\tstale;\t\t/* count of stale leaves */\n\tstruct xfs_name\t\tname;\n\tconst struct xfs_dir_ops *ops;\n\tstruct xfs_da_geometry\t*geo;\n\n\tmp = bp->b_target->bt_mount;\n\tgeo = mp->m_dir_geo;\n\n\t/*\n\t * We can be passed a null dp here from a verifier, so we need to go the\n\t * hard way to get them.\n\t */\n\tops = xfs_dir_get_ops(mp, dp);\n\n\thdr = bp->b_addr;\n\tp = (char *)ops->data_entry_p(hdr);\n\n\tswitch (hdr->magic) {\n\tcase cpu_to_be32(XFS_DIR3_BLOCK_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_BLOCK_MAGIC):\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tlep = xfs_dir2_block_leaf_p(btp);\n\t\tendp = (char *)lep;\n\n\t\t/*\n\t\t * The number of leaf entries is limited by the size of the\n\t\t * block and the amount of space used by the data entries.\n\t\t * We don't know how much space is used by the data entries yet,\n\t\t * so just ensure that the count falls somewhere inside the\n\t\t * block right now.\n\t\t */\n\t\tXFS_WANT_CORRUPTED_RETURN(be32_to_cpu(btp->count) <\n\t\t\t((char *)btp - p) / sizeof(struct xfs_dir2_leaf_entry));\n\t\tbreak;\n\tcase cpu_to_be32(XFS_DIR3_DATA_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_DATA_MAGIC):\n\t\tendp = (char *)hdr + geo->blksize;\n\t\tbreak;\n\tdefault:\n\t\tXFS_ERROR_REPORT(\"Bad Magic\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/*\n\t * Account for zero bestfree entries.\n\t */\n\tbf = ops->data_bestfree_p(hdr);\n\tcount = lastfree = freeseen = 0;\n\tif (!bf[0].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[0].offset);\n\t\tfreeseen |= 1 << 0;\n\t}\n\tif (!bf[1].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[1].offset);\n\t\tfreeseen |= 1 << 1;\n\t}\n\tif (!bf[2].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[2].offset);\n\t\tfreeseen |= 1 << 2;\n\t}\n\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[0].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[1].length));\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[1].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t/*\n\t * Loop over the data/unused entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's unused, look for the space in the bestfree table.\n\t\t * If we find it, account for that, else make sure it\n\t\t * doesn't need to be there.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tXFS_WANT_CORRUPTED_RETURN(lastfree == 0);\n\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tbe16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)) ==\n\t\t\t\t\t       (char *)dup - (char *)hdr);\n\t\t\tdfp = xfs_dir2_data_freefind(hdr, bf, dup);\n\t\t\tif (dfp) {\n\t\t\t\ti = (int)(dfp - bf);\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\t(freeseen & (1 << i)) == 0);\n\t\t\t\tfreeseen |= 1 << i;\n\t\t\t} else {\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe16_to_cpu(dup->length) <=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t\t\t}\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t\tlastfree = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * It's a real entry.  Validate the fields.\n\t\t * If this is a block directory then make sure it's\n\t\t * in the leaf section of the block.\n\t\t * The linear search is crude but this is DEBUG code.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\tXFS_WANT_CORRUPTED_RETURN(dep->namelen != 0);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t!xfs_dir_ino_validate(mp, be64_to_cpu(dep->inumber)));\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\tbe16_to_cpu(*ops->data_entry_tag_p(dep)) ==\n\t\t\t\t\t       (char *)dep - (char *)hdr);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tops->data_get_ftype(dep) < XFS_DIR3_FT_MAX);\n\t\tcount++;\n\t\tlastfree = 0;\n\t\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\t\taddr = xfs_dir2_db_off_to_dataptr(geo, geo->datablk,\n\t\t\t\t\t\t(xfs_dir2_data_aoff_t)\n\t\t\t\t\t\t((char *)dep - (char *)hdr));\n\t\t\tname.name = dep->name;\n\t\t\tname.len = dep->namelen;\n\t\t\thash = mp->m_dirnameops->hashname(&name);\n\t\t\tfor (i = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\t\tif (be32_to_cpu(lep[i].address) == addr &&\n\t\t\t\t    be32_to_cpu(lep[i].hashval) == hash)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tXFS_WANT_CORRUPTED_RETURN(i < be32_to_cpu(btp->count));\n\t\t}\n\t\tp += ops->data_entsize(dep->namelen);\n\t}\n\t/*\n\t * Need to have seen all the entries and all the bestfree slots.\n\t */\n\tXFS_WANT_CORRUPTED_RETURN(freeseen == 7);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tfor (i = stale = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\tif (lep[i].address ==\n\t\t\t    cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\t\tstale++;\n\t\t\tif (i > 0)\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe32_to_cpu(lep[i].hashval) >=\n\t\t\t\t\t\tbe32_to_cpu(lep[i - 1].hashval));\n\t\t}\n\t\tXFS_WANT_CORRUPTED_RETURN(count ==\n\t\t\tbe32_to_cpu(btp->count) - be32_to_cpu(btp->stale));\n\t\tXFS_WANT_CORRUPTED_RETURN(stale == be32_to_cpu(btp->stale));\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\n__xfs_dir3_data_check(\n\tstruct xfs_inode\t*dp,\t\t/* incore inode pointer */\n\tstruct xfs_buf\t\t*bp)\t\t/* data block's buffer */\n{\n\txfs_dir2_dataptr_t\taddr;\t\t/* addr for leaf lookup */\n\txfs_dir2_data_free_t\t*bf;\t\t/* bestfree table */\n\txfs_dir2_block_tail_t\t*btp=NULL;\t/* block tail */\n\tint\t\t\tcount;\t\t/* count of entries found */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry */\n\tchar\t\t\t*endp;\t\t/* end of useful data */\n\tint\t\t\tfreeseen;\t/* mask of bestfrees seen */\n\txfs_dahash_t\t\thash;\t\t/* hash of current name */\n\tint\t\t\ti;\t\t/* leaf index */\n\tint\t\t\tlastfree;\t/* last entry was unused */\n\txfs_dir2_leaf_entry_t\t*lep=NULL;\t/* block leaf entries */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tchar\t\t\t*p;\t\t/* current data position */\n\tint\t\t\tstale;\t\t/* count of stale leaves */\n\tstruct xfs_name\t\tname;\n\tconst struct xfs_dir_ops *ops;\n\tstruct xfs_da_geometry\t*geo;\n\n\tmp = bp->b_target->bt_mount;\n\tgeo = mp->m_dir_geo;\n\n\t/*\n\t * We can be passed a null dp here from a verifier, so we need to go the\n\t * hard way to get them.\n\t */\n\tops = xfs_dir_get_ops(mp, dp);\n\n\thdr = bp->b_addr;\n\tp = (char *)ops->data_entry_p(hdr);\n\n\tswitch (hdr->magic) {\n\tcase cpu_to_be32(XFS_DIR3_BLOCK_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_BLOCK_MAGIC):\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tlep = xfs_dir2_block_leaf_p(btp);\n\t\tendp = (char *)lep;\n\n\t\t/*\n\t\t * The number of leaf entries is limited by the size of the\n\t\t * block and the amount of space used by the data entries.\n\t\t * We don't know how much space is used by the data entries yet,\n\t\t * so just ensure that the count falls somewhere inside the\n\t\t * block right now.\n\t\t */\n\t\tXFS_WANT_CORRUPTED_RETURN(be32_to_cpu(btp->count) <\n\t\t\t((char *)btp - p) / sizeof(struct xfs_dir2_leaf_entry));\n\t\tbreak;\n\tcase cpu_to_be32(XFS_DIR3_DATA_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_DATA_MAGIC):\n\t\tendp = (char *)hdr + geo->blksize;\n\t\tbreak;\n\tdefault:\n\t\tXFS_ERROR_REPORT(\"Bad Magic\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/*\n\t * Account for zero bestfree entries.\n\t */\n\tbf = ops->data_bestfree_p(hdr);\n\tcount = lastfree = freeseen = 0;\n\tif (!bf[0].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[0].offset);\n\t\tfreeseen |= 1 << 0;\n\t}\n\tif (!bf[1].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[1].offset);\n\t\tfreeseen |= 1 << 1;\n\t}\n\tif (!bf[2].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[2].offset);\n\t\tfreeseen |= 1 << 2;\n\t}\n\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[0].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[1].length));\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[1].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t/*\n\t * Loop over the data/unused entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's unused, look for the space in the bestfree table.\n\t\t * If we find it, account for that, else make sure it\n\t\t * doesn't need to be there.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tXFS_WANT_CORRUPTED_RETURN(lastfree == 0);\n\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tbe16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)) ==\n\t\t\t\t\t       (char *)dup - (char *)hdr);\n\t\t\tdfp = xfs_dir2_data_freefind(hdr, bf, dup);\n\t\t\tif (dfp) {\n\t\t\t\ti = (int)(dfp - bf);\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\t(freeseen & (1 << i)) == 0);\n\t\t\t\tfreeseen |= 1 << i;\n\t\t\t} else {\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe16_to_cpu(dup->length) <=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t\t\t}\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t\tlastfree = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * It's a real entry.  Validate the fields.\n\t\t * If this is a block directory then make sure it's\n\t\t * in the leaf section of the block.\n\t\t * The linear search is crude but this is DEBUG code.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\tXFS_WANT_CORRUPTED_RETURN(dep->namelen != 0);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t!xfs_dir_ino_validate(mp, be64_to_cpu(dep->inumber)));\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\tbe16_to_cpu(*ops->data_entry_tag_p(dep)) ==\n\t\t\t\t\t       (char *)dep - (char *)hdr);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tops->data_get_ftype(dep) < XFS_DIR3_FT_MAX);\n\t\tcount++;\n\t\tlastfree = 0;\n\t\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\t\taddr = xfs_dir2_db_off_to_dataptr(geo, geo->datablk,\n\t\t\t\t\t\t(xfs_dir2_data_aoff_t)\n\t\t\t\t\t\t((char *)dep - (char *)hdr));\n\t\t\tname.name = dep->name;\n\t\t\tname.len = dep->namelen;\n\t\t\thash = mp->m_dirnameops->hashname(&name);\n\t\t\tfor (i = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\t\tif (be32_to_cpu(lep[i].address) == addr &&\n\t\t\t\t    be32_to_cpu(lep[i].hashval) == hash)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tXFS_WANT_CORRUPTED_RETURN(i < be32_to_cpu(btp->count));\n\t\t}\n\t\tp += ops->data_entsize(dep->namelen);\n\t}\n\t/*\n\t * Need to have seen all the entries and all the bestfree slots.\n\t */\n\tXFS_WANT_CORRUPTED_RETURN(freeseen == 7);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tfor (i = stale = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\tif (lep[i].address ==\n\t\t\t    cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\t\tstale++;\n\t\t\tif (i > 0)\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe32_to_cpu(lep[i].hashval) >=\n\t\t\t\t\t\tbe32_to_cpu(lep[i - 1].hashval));\n\t\t}\n\t\tXFS_WANT_CORRUPTED_RETURN(count ==\n\t\t\tbe32_to_cpu(btp->count) - be32_to_cpu(btp->stale));\n\t\tXFS_WANT_CORRUPTED_RETURN(stale == be32_to_cpu(btp->stale));\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_dataptr_to_off",
          "args": [
            "geo",
            "ctx->pos"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_dataptr_to_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "240-244",
          "snippet": "static inline xfs_dir2_data_aoff_t\nxfs_dir2_dataptr_to_off(struct xfs_da_geometry *geo, xfs_dir2_dataptr_t dp)\n{\n\treturn xfs_dir2_byte_to_off(geo, xfs_dir2_dataptr_to_byte(dp));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_data_aoff_t\nxfs_dir2_dataptr_to_off(struct xfs_da_geometry *geo, xfs_dir2_dataptr_t dp)\n{\n\treturn xfs_dir2_byte_to_off(geo, xfs_dir2_dataptr_to_byte(dp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir3_block_read",
          "args": [
            "NULL",
            "dp",
            "&bp"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_block_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_block.c",
          "lines": "127-141",
          "snippet": "int\nxfs_dir3_block_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, mp->m_dir_geo->datablk, -1, bpp,\n\t\t\t\tXFS_DATA_FORK, &xfs_dir3_block_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_DIR_BLOCK_BUF);\n\treturn err;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_dir3_block_buf_ops = {\n\t.verify_read = xfs_dir3_block_read_verify,\n\t.verify_write = xfs_dir3_block_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_dir3_block_buf_ops = {\n\t.verify_read = xfs_dir3_block_read_verify,\n\t.verify_write = xfs_dir3_block_write_verify,\n};\n\nint\nxfs_dir3_block_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, mp->m_dir_geo->datablk, -1, bpp,\n\t\t\t\tXFS_DATA_FORK, &xfs_dir3_block_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_DIR_BLOCK_BUF);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_dataptr_to_db",
          "args": [
            "geo",
            "ctx->pos"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_dataptr_to_db",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "222-226",
          "snippet": "static inline xfs_dir2_db_t\nxfs_dir2_dataptr_to_db(struct xfs_da_geometry *geo, xfs_dir2_dataptr_t dp)\n{\n\treturn xfs_dir2_byte_to_db(geo, xfs_dir2_dataptr_to_byte(dp));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_db_t\nxfs_dir2_dataptr_to_db(struct xfs_da_geometry *geo, xfs_dir2_dataptr_t dp)\n{\n\treturn xfs_dir2_byte_to_db(geo, xfs_dir2_dataptr_to_byte(dp));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_dir2_block_getdents(\n\tstruct xfs_da_args\t*args,\n\tstruct dir_context\t*ctx)\n{\n\tstruct xfs_inode\t*dp = args->dp;\t/* incore directory inode */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\tstruct xfs_buf\t\t*bp;\t\t/* buffer for block */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* block data entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* block unused entry */\n\tchar\t\t\t*endptr;\t/* end of the data entries */\n\tint\t\t\terror;\t\t/* error return value */\n\tchar\t\t\t*ptr;\t\t/* current data entry */\n\tint\t\t\twantoff;\t/* starting block offset */\n\txfs_off_t\t\tcook;\n\tstruct xfs_da_geometry\t*geo = args->geo;\n\n\t/*\n\t * If the block number in the offset is out of range, we're done.\n\t */\n\tif (xfs_dir2_dataptr_to_db(geo, ctx->pos) > geo->datablk)\n\t\treturn 0;\n\n\terror = xfs_dir3_block_read(NULL, dp, &bp);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Extract the byte offset we start at from the seek pointer.\n\t * We'll skip entries before this.\n\t */\n\twantoff = xfs_dir2_dataptr_to_off(geo, ctx->pos);\n\thdr = bp->b_addr;\n\txfs_dir3_data_check(dp, bp);\n\t/*\n\t * Set up values for the loop.\n\t */\n\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\tptr = (char *)dp->d_ops->data_entry_p(hdr);\n\tendptr = (char *)xfs_dir2_block_leaf_p(btp);\n\n\t/*\n\t * Loop over the data portion of the block.\n\t * Each object is a real entry (dep) or an unused one (dup).\n\t */\n\twhile (ptr < endptr) {\n\t\t__uint8_t filetype;\n\n\t\tdup = (xfs_dir2_data_unused_t *)ptr;\n\t\t/*\n\t\t * Unused, skip it.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tptr += be16_to_cpu(dup->length);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdep = (xfs_dir2_data_entry_t *)ptr;\n\n\t\t/*\n\t\t * Bump pointer for the next iteration.\n\t\t */\n\t\tptr += dp->d_ops->data_entsize(dep->namelen);\n\t\t/*\n\t\t * The entry is before the desired starting point, skip it.\n\t\t */\n\t\tif ((char *)dep - (char *)hdr < wantoff)\n\t\t\tcontinue;\n\n\t\tcook = xfs_dir2_db_off_to_dataptr(geo, geo->datablk,\n\t\t\t\t\t    (char *)dep - (char *)hdr);\n\n\t\tctx->pos = cook & 0x7fffffff;\n\t\tfiletype = dp->d_ops->data_get_ftype(dep);\n\t\t/*\n\t\t * If it didn't fit, set the final offset to here & return.\n\t\t */\n\t\tif (!dir_emit(ctx, (char *)dep->name, dep->namelen,\n\t\t\t    be64_to_cpu(dep->inumber),\n\t\t\t    xfs_dir3_get_dtype(dp->i_mount, filetype))) {\n\t\t\txfs_trans_brelse(NULL, bp);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Reached the end of the block.\n\t * Set the offset to a non-existent block 1 and return.\n\t */\n\tctx->pos = xfs_dir2_db_off_to_dataptr(geo, geo->datablk + 1, 0) &\n\t\t\t\t\t\t\t\t0x7fffffff;\n\txfs_trans_brelse(NULL, bp);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_dir2_sf_getdents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dir2_readdir.c",
    "lines": "58-152",
    "snippet": "STATIC int\nxfs_dir2_sf_getdents(\n\tstruct xfs_da_args\t*args,\n\tstruct dir_context\t*ctx)\n{\n\tint\t\t\ti;\t\t/* shortform entry number */\n\tstruct xfs_inode\t*dp = args->dp;\t/* incore directory inode */\n\txfs_dir2_dataptr_t\toff;\t\t/* current entry's offset */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* shortform directory entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform structure */\n\txfs_dir2_dataptr_t\tdot_offset;\n\txfs_dir2_dataptr_t\tdotdot_offset;\n\txfs_ino_t\t\tino;\n\tstruct xfs_da_geometry\t*geo = args->geo;\n\n\tASSERT(dp->i_df.if_flags & XFS_IFINLINE);\n\t/*\n\t * Give up if the directory is way too short.\n\t */\n\tif (dp->i_d.di_size < offsetof(xfs_dir2_sf_hdr_t, parent)) {\n\t\tASSERT(XFS_FORCED_SHUTDOWN(dp->i_mount));\n\t\treturn -EIO;\n\t}\n\n\tASSERT(dp->i_df.if_bytes == dp->i_d.di_size);\n\tASSERT(dp->i_df.if_u1.if_data != NULL);\n\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\n\tASSERT(dp->i_d.di_size >= xfs_dir2_sf_hdr_size(sfp->i8count));\n\n\t/*\n\t * If the block number in the offset is out of range, we're done.\n\t */\n\tif (xfs_dir2_dataptr_to_db(geo, ctx->pos) > geo->datablk)\n\t\treturn 0;\n\n\t/*\n\t * Precalculate offsets for . and .. as we will always need them.\n\t *\n\t * XXX(hch): the second argument is sometimes 0 and sometimes\n\t * geo->datablk\n\t */\n\tdot_offset = xfs_dir2_db_off_to_dataptr(geo, geo->datablk,\n\t\t\t\t\t\tdp->d_ops->data_dot_offset);\n\tdotdot_offset = xfs_dir2_db_off_to_dataptr(geo, geo->datablk,\n\t\t\t\t\t\tdp->d_ops->data_dotdot_offset);\n\n\t/*\n\t * Put . entry unless we're starting past it.\n\t */\n\tif (ctx->pos <= dot_offset) {\n\t\tctx->pos = dot_offset & 0x7fffffff;\n\t\tif (!dir_emit(ctx, \".\", 1, dp->i_ino, DT_DIR))\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * Put .. entry unless we're starting past it.\n\t */\n\tif (ctx->pos <= dotdot_offset) {\n\t\tino = dp->d_ops->sf_get_parent_ino(sfp);\n\t\tctx->pos = dotdot_offset & 0x7fffffff;\n\t\tif (!dir_emit(ctx, \"..\", 2, ino, DT_DIR))\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * Loop while there are more entries and put'ing works.\n\t */\n\tsfep = xfs_dir2_sf_firstentry(sfp);\n\tfor (i = 0; i < sfp->count; i++) {\n\t\t__uint8_t filetype;\n\n\t\toff = xfs_dir2_db_off_to_dataptr(geo, geo->datablk,\n\t\t\t\txfs_dir2_sf_get_offset(sfep));\n\n\t\tif (ctx->pos > off) {\n\t\t\tsfep = dp->d_ops->sf_nextentry(sfp, sfep);\n\t\t\tcontinue;\n\t\t}\n\n\t\tino = dp->d_ops->sf_get_ino(sfp, sfep);\n\t\tfiletype = dp->d_ops->sf_get_ftype(sfep);\n\t\tctx->pos = off & 0x7fffffff;\n\t\tif (!dir_emit(ctx, (char *)sfep->name, sfep->namelen, ino,\n\t\t\t    xfs_dir3_get_dtype(dp->i_mount, filetype)))\n\t\t\treturn 0;\n\t\tsfep = dp->d_ops->sf_nextentry(sfp, sfep);\n\t}\n\n\tctx->pos = xfs_dir2_db_off_to_dataptr(geo, geo->datablk + 1, 0) &\n\t\t\t\t\t\t\t\t0x7fffffff;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_dir2_db_off_to_dataptr",
          "args": [
            "geo",
            "geo->datablk + 1",
            "0"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_db_off_to_dataptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "277-282",
          "snippet": "static inline xfs_dir2_dataptr_t\nxfs_dir2_db_off_to_dataptr(struct xfs_da_geometry *geo, xfs_dir2_db_t db,\n\t\t\t   xfs_dir2_data_aoff_t o)\n{\n\treturn xfs_dir2_byte_to_dataptr(xfs_dir2_db_off_to_byte(geo, db, o));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_dataptr_t\nxfs_dir2_db_off_to_dataptr(struct xfs_da_geometry *geo, xfs_dir2_db_t db,\n\t\t\t   xfs_dir2_data_aoff_t o)\n{\n\treturn xfs_dir2_byte_to_dataptr(xfs_dir2_db_off_to_byte(geo, db, o));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_nextentry",
          "args": [
            "sfp",
            "sfep"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "(char *)sfep->name",
            "sfep->namelen",
            "ino",
            "xfs_dir3_get_dtype(dp->i_mount, filetype)"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_get_dtype",
          "args": [
            "dp->i_mount",
            "filetype"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_get_dtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dir2_readdir.c",
          "lines": "44-56",
          "snippet": "static unsigned char\nxfs_dir3_get_dtype(\n\tstruct xfs_mount\t*mp,\n\t__uint8_t\t\tfiletype)\n{\n\tif (!xfs_sb_version_hasftype(&mp->m_sb))\n\t\treturn DT_UNKNOWN;\n\n\tif (filetype >= XFS_DIR3_FT_MAX)\n\t\treturn DT_UNKNOWN;\n\n\treturn xfs_dir3_filetype_table[filetype];\n}",
          "includes": [
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned char xfs_dir3_filetype_table[] = {\n\tDT_UNKNOWN, DT_REG, DT_DIR, DT_CHR, DT_BLK,\n\tDT_FIFO, DT_SOCK, DT_LNK, DT_WHT,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic unsigned char xfs_dir3_filetype_table[] = {\n\tDT_UNKNOWN, DT_REG, DT_DIR, DT_CHR, DT_BLK,\n\tDT_FIFO, DT_SOCK, DT_LNK, DT_WHT,\n};\n\nstatic unsigned char\nxfs_dir3_get_dtype(\n\tstruct xfs_mount\t*mp,\n\t__uint8_t\t\tfiletype)\n{\n\tif (!xfs_sb_version_hasftype(&mp->m_sb))\n\t\treturn DT_UNKNOWN;\n\n\tif (filetype >= XFS_DIR3_FT_MAX)\n\t\treturn DT_UNKNOWN;\n\n\treturn xfs_dir3_filetype_table[filetype];\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_get_ftype",
          "args": [
            "sfep"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_get_ino",
          "args": [
            "sfp",
            "sfep"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_nextentry",
          "args": [
            "sfp",
            "sfep"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_sf_get_offset",
          "args": [
            "sfep"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_get_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "272-276",
          "snippet": "static inline xfs_dir2_data_aoff_t\nxfs_dir2_sf_get_offset(xfs_dir2_sf_entry_t *sfep)\n{\n\treturn get_unaligned_be16(&sfep->offset.i);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_data_aoff_t\nxfs_dir2_sf_get_offset(xfs_dir2_sf_entry_t *sfep)\n{\n\treturn get_unaligned_be16(&sfep->offset.i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_sf_firstentry",
          "args": [
            "sfp"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_firstentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "284-289",
          "snippet": "static inline struct xfs_dir2_sf_entry *\nxfs_dir2_sf_firstentry(struct xfs_dir2_sf_hdr *hdr)\n{\n\treturn (struct xfs_dir2_sf_entry *)\n\t\t((char *)hdr + xfs_dir2_sf_hdr_size(hdr->i8count));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_sf_entry *\nxfs_dir2_sf_firstentry(struct xfs_dir2_sf_hdr *hdr)\n{\n\treturn (struct xfs_dir2_sf_entry *)\n\t\t((char *)hdr + xfs_dir2_sf_hdr_size(hdr->i8count));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "\"..\"",
            "2",
            "ino",
            "DT_DIR"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->sf_get_parent_ino",
          "args": [
            "sfp"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "\".\"",
            "1",
            "dp->i_ino",
            "DT_DIR"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_dataptr_to_db",
          "args": [
            "geo",
            "ctx->pos"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_dataptr_to_db",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "222-226",
          "snippet": "static inline xfs_dir2_db_t\nxfs_dir2_dataptr_to_db(struct xfs_da_geometry *geo, xfs_dir2_dataptr_t dp)\n{\n\treturn xfs_dir2_byte_to_db(geo, xfs_dir2_dataptr_to_byte(dp));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_db_t\nxfs_dir2_dataptr_to_db(struct xfs_da_geometry *geo, xfs_dir2_dataptr_t dp)\n{\n\treturn xfs_dir2_byte_to_db(geo, xfs_dir2_dataptr_to_byte(dp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dp->i_d.di_size >= xfs_dir2_sf_hdr_size(sfp->i8count)"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_sf_hdr_size",
          "args": [
            "sfp->i8count"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_hdr_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "265-270",
          "snippet": "static inline int xfs_dir2_sf_hdr_size(int i8count)\n{\n\treturn sizeof(struct xfs_dir2_sf_hdr) -\n\t\t(i8count == 0) *\n\t\t(sizeof(xfs_dir2_ino8_t) - sizeof(xfs_dir2_ino4_t));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int xfs_dir2_sf_hdr_size(int i8count)\n{\n\treturn sizeof(struct xfs_dir2_sf_hdr) -\n\t\t(i8count == 0) *\n\t\t(sizeof(xfs_dir2_ino8_t) - sizeof(xfs_dir2_ino4_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dp->i_df.if_u1.if_data != NULL"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dp->i_df.if_bytes == dp->i_d.di_size"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_FORCED_SHUTDOWN(dp->i_mount)"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "dp->i_mount"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dp->i_df.if_flags & XFS_IFINLINE"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_dir2_sf_getdents(\n\tstruct xfs_da_args\t*args,\n\tstruct dir_context\t*ctx)\n{\n\tint\t\t\ti;\t\t/* shortform entry number */\n\tstruct xfs_inode\t*dp = args->dp;\t/* incore directory inode */\n\txfs_dir2_dataptr_t\toff;\t\t/* current entry's offset */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* shortform directory entry */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform structure */\n\txfs_dir2_dataptr_t\tdot_offset;\n\txfs_dir2_dataptr_t\tdotdot_offset;\n\txfs_ino_t\t\tino;\n\tstruct xfs_da_geometry\t*geo = args->geo;\n\n\tASSERT(dp->i_df.if_flags & XFS_IFINLINE);\n\t/*\n\t * Give up if the directory is way too short.\n\t */\n\tif (dp->i_d.di_size < offsetof(xfs_dir2_sf_hdr_t, parent)) {\n\t\tASSERT(XFS_FORCED_SHUTDOWN(dp->i_mount));\n\t\treturn -EIO;\n\t}\n\n\tASSERT(dp->i_df.if_bytes == dp->i_d.di_size);\n\tASSERT(dp->i_df.if_u1.if_data != NULL);\n\n\tsfp = (xfs_dir2_sf_hdr_t *)dp->i_df.if_u1.if_data;\n\n\tASSERT(dp->i_d.di_size >= xfs_dir2_sf_hdr_size(sfp->i8count));\n\n\t/*\n\t * If the block number in the offset is out of range, we're done.\n\t */\n\tif (xfs_dir2_dataptr_to_db(geo, ctx->pos) > geo->datablk)\n\t\treturn 0;\n\n\t/*\n\t * Precalculate offsets for . and .. as we will always need them.\n\t *\n\t * XXX(hch): the second argument is sometimes 0 and sometimes\n\t * geo->datablk\n\t */\n\tdot_offset = xfs_dir2_db_off_to_dataptr(geo, geo->datablk,\n\t\t\t\t\t\tdp->d_ops->data_dot_offset);\n\tdotdot_offset = xfs_dir2_db_off_to_dataptr(geo, geo->datablk,\n\t\t\t\t\t\tdp->d_ops->data_dotdot_offset);\n\n\t/*\n\t * Put . entry unless we're starting past it.\n\t */\n\tif (ctx->pos <= dot_offset) {\n\t\tctx->pos = dot_offset & 0x7fffffff;\n\t\tif (!dir_emit(ctx, \".\", 1, dp->i_ino, DT_DIR))\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * Put .. entry unless we're starting past it.\n\t */\n\tif (ctx->pos <= dotdot_offset) {\n\t\tino = dp->d_ops->sf_get_parent_ino(sfp);\n\t\tctx->pos = dotdot_offset & 0x7fffffff;\n\t\tif (!dir_emit(ctx, \"..\", 2, ino, DT_DIR))\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * Loop while there are more entries and put'ing works.\n\t */\n\tsfep = xfs_dir2_sf_firstentry(sfp);\n\tfor (i = 0; i < sfp->count; i++) {\n\t\t__uint8_t filetype;\n\n\t\toff = xfs_dir2_db_off_to_dataptr(geo, geo->datablk,\n\t\t\t\txfs_dir2_sf_get_offset(sfep));\n\n\t\tif (ctx->pos > off) {\n\t\t\tsfep = dp->d_ops->sf_nextentry(sfp, sfep);\n\t\t\tcontinue;\n\t\t}\n\n\t\tino = dp->d_ops->sf_get_ino(sfp, sfep);\n\t\tfiletype = dp->d_ops->sf_get_ftype(sfep);\n\t\tctx->pos = off & 0x7fffffff;\n\t\tif (!dir_emit(ctx, (char *)sfep->name, sfep->namelen, ino,\n\t\t\t    xfs_dir3_get_dtype(dp->i_mount, filetype)))\n\t\t\treturn 0;\n\t\tsfep = dp->d_ops->sf_nextentry(sfp, sfep);\n\t}\n\n\tctx->pos = xfs_dir2_db_off_to_dataptr(geo, geo->datablk + 1, 0) &\n\t\t\t\t\t\t\t\t0x7fffffff;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_dir3_get_dtype",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dir2_readdir.c",
    "lines": "44-56",
    "snippet": "static unsigned char\nxfs_dir3_get_dtype(\n\tstruct xfs_mount\t*mp,\n\t__uint8_t\t\tfiletype)\n{\n\tif (!xfs_sb_version_hasftype(&mp->m_sb))\n\t\treturn DT_UNKNOWN;\n\n\tif (filetype >= XFS_DIR3_FT_MAX)\n\t\treturn DT_UNKNOWN;\n\n\treturn xfs_dir3_filetype_table[filetype];\n}",
    "includes": [
      "#include \"xfs_trans.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned char xfs_dir3_filetype_table[] = {\n\tDT_UNKNOWN, DT_REG, DT_DIR, DT_CHR, DT_BLK,\n\tDT_FIFO, DT_SOCK, DT_LNK, DT_WHT,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_sb_version_hasftype",
          "args": [
            "&mp->m_sb"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hasftype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "557-563",
          "snippet": "static inline int xfs_sb_version_hasftype(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 &&\n\t\txfs_sb_has_incompat_feature(sbp, XFS_SB_FEAT_INCOMPAT_FTYPE)) ||\n\t       (xfs_sb_version_hasmorebits(sbp) &&\n\t\t (sbp->sb_features2 & XFS_SB_VERSION2_FTYPE));\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_SB_FEAT_INCOMPAT_FTYPE\t(1 << 0)\t/* filetype in dirent */",
            "#define XFS_SB_VERSION2_FTYPE\t\t0x00000200\t/* inode type in dir */",
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_SB_FEAT_INCOMPAT_FTYPE\t(1 << 0)\t/* filetype in dirent */\n#define XFS_SB_VERSION2_FTYPE\t\t0x00000200\t/* inode type in dir */\n#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hasftype(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 &&\n\t\txfs_sb_has_incompat_feature(sbp, XFS_SB_FEAT_INCOMPAT_FTYPE)) ||\n\t       (xfs_sb_version_hasmorebits(sbp) &&\n\t\t (sbp->sb_features2 & XFS_SB_VERSION2_FTYPE));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic unsigned char xfs_dir3_filetype_table[] = {\n\tDT_UNKNOWN, DT_REG, DT_DIR, DT_CHR, DT_BLK,\n\tDT_FIFO, DT_SOCK, DT_LNK, DT_WHT,\n};\n\nstatic unsigned char\nxfs_dir3_get_dtype(\n\tstruct xfs_mount\t*mp,\n\t__uint8_t\t\tfiletype)\n{\n\tif (!xfs_sb_version_hasftype(&mp->m_sb))\n\t\treturn DT_UNKNOWN;\n\n\tif (filetype >= XFS_DIR3_FT_MAX)\n\t\treturn DT_UNKNOWN;\n\n\treturn xfs_dir3_filetype_table[filetype];\n}"
  }
]