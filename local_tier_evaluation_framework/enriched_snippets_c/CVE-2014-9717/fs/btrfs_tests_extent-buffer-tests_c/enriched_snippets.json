[
  {
    "function_name": "btrfs_test_extent_buffer_operations",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/extent-buffer-tests.c",
    "lines": "225-229",
    "snippet": "int btrfs_test_extent_buffer_operations(void)\n{\n\ttest_msg(\"Running extent buffer operation tests\");\n\treturn test_btrfs_split_item();\n}",
    "includes": [
      "#include \"../disk-io.h\"",
      "#include \"../extent_io.h\"",
      "#include \"../ctree.h\"",
      "#include \"btrfs-tests.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_btrfs_split_item",
          "args": [],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "test_btrfs_split_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/extent-buffer-tests.c",
          "lines": "25-223",
          "snippet": "static int test_btrfs_split_item(void)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_root *root;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_item *item;\n\tchar *value = \"mary had a little lamb\";\n\tchar *split1 = \"mary had a little\";\n\tchar *split2 = \" lamb\";\n\tchar *split3 = \"mary\";\n\tchar *split4 = \" had a little\";\n\tchar buf[32];\n\tstruct btrfs_key key;\n\tu32 value_len = strlen(value);\n\tint ret = 0;\n\n\ttest_msg(\"Running btrfs_split_item tests\\n\");\n\n\troot = btrfs_alloc_dummy_root();\n\tif (IS_ERR(root)) {\n\t\ttest_msg(\"Could not allocate root\\n\");\n\t\treturn PTR_ERR(root);\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\ttest_msg(\"Could not allocate path\\n\");\n\t\tkfree(root);\n\t\treturn -ENOMEM;\n\t}\n\n\tpath->nodes[0] = eb = alloc_dummy_extent_buffer(NULL, 4096);\n\tif (!eb) {\n\t\ttest_msg(\"Could not allocate dummy buffer\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tpath->slots[0] = 0;\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_EXTENT_CSUM_KEY;\n\tkey.offset = 0;\n\n\tsetup_items_for_insert(root, path, &key, &value_len, value_len,\n\t\t\t       value_len + sizeof(struct btrfs_item), 1);\n\titem = btrfs_item_nr(0);\n\twrite_extent_buffer(eb, value, btrfs_item_ptr_offset(eb, 0),\n\t\t\t    value_len);\n\n\tkey.offset = 3;\n\n\t/*\n\t * Passing NULL trans here should be safe because we have plenty of\n\t * space in this leaf to split the item without having to split the\n\t * leaf.\n\t */\n\tret = btrfs_split_item(NULL, root, path, &key, 17);\n\tif (ret) {\n\t\ttest_msg(\"Split item failed %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Read the first slot, it should have the original key and contain only\n\t * 'mary had a little'\n\t */\n\tbtrfs_item_key_to_cpu(eb, &key, 0);\n\tif (key.objectid != 0 || key.type != BTRFS_EXTENT_CSUM_KEY ||\n\t    key.offset != 0) {\n\t\ttest_msg(\"Invalid key at slot 0\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\titem = btrfs_item_nr(0);\n\tif (btrfs_item_size(eb, item) != strlen(split1)) {\n\t\ttest_msg(\"Invalid len in the first split\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tread_extent_buffer(eb, buf, btrfs_item_ptr_offset(eb, 0),\n\t\t\t   strlen(split1));\n\tif (memcmp(buf, split1, strlen(split1))) {\n\t\ttest_msg(\"Data in the buffer doesn't match what it should \"\n\t\t\t \"in the first split have='%.*s' want '%s'\\n\",\n\t\t\t (int)strlen(split1), buf, split1);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tbtrfs_item_key_to_cpu(eb, &key, 1);\n\tif (key.objectid != 0 || key.type != BTRFS_EXTENT_CSUM_KEY ||\n\t    key.offset != 3) {\n\t\ttest_msg(\"Invalid key at slot 1\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\titem = btrfs_item_nr(1);\n\tif (btrfs_item_size(eb, item) != strlen(split2)) {\n\t\ttest_msg(\"Invalid len in the second split\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tread_extent_buffer(eb, buf, btrfs_item_ptr_offset(eb, 1),\n\t\t\t   strlen(split2));\n\tif (memcmp(buf, split2, strlen(split2))) {\n\t\ttest_msg(\"Data in the buffer doesn't match what it should \"\n\t\t\t \"in the second split\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tkey.offset = 1;\n\t/* Do it again so we test memmoving the other items in the leaf */\n\tret = btrfs_split_item(NULL, root, path, &key, 4);\n\tif (ret) {\n\t\ttest_msg(\"Second split item failed %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tbtrfs_item_key_to_cpu(eb, &key, 0);\n\tif (key.objectid != 0 || key.type != BTRFS_EXTENT_CSUM_KEY ||\n\t    key.offset != 0) {\n\t\ttest_msg(\"Invalid key at slot 0\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\titem = btrfs_item_nr(0);\n\tif (btrfs_item_size(eb, item) != strlen(split3)) {\n\t\ttest_msg(\"Invalid len in the first split\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tread_extent_buffer(eb, buf, btrfs_item_ptr_offset(eb, 0),\n\t\t\t   strlen(split3));\n\tif (memcmp(buf, split3, strlen(split3))) {\n\t\ttest_msg(\"Data in the buffer doesn't match what it should \"\n\t\t\t \"in the third split\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tbtrfs_item_key_to_cpu(eb, &key, 1);\n\tif (key.objectid != 0 || key.type != BTRFS_EXTENT_CSUM_KEY ||\n\t    key.offset != 1) {\n\t\ttest_msg(\"Invalid key at slot 1\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\titem = btrfs_item_nr(1);\n\tif (btrfs_item_size(eb, item) != strlen(split4)) {\n\t\ttest_msg(\"Invalid len in the second split\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tread_extent_buffer(eb, buf, btrfs_item_ptr_offset(eb, 1),\n\t\t\t   strlen(split4));\n\tif (memcmp(buf, split4, strlen(split4))) {\n\t\ttest_msg(\"Data in the buffer doesn't match what it should \"\n\t\t\t \"in the fourth split\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tbtrfs_item_key_to_cpu(eb, &key, 2);\n\tif (key.objectid != 0 || key.type != BTRFS_EXTENT_CSUM_KEY ||\n\t    key.offset != 3) {\n\t\ttest_msg(\"Invalid key at slot 2\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\titem = btrfs_item_nr(2);\n\tif (btrfs_item_size(eb, item) != strlen(split2)) {\n\t\ttest_msg(\"Invalid len in the second split\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tread_extent_buffer(eb, buf, btrfs_item_ptr_offset(eb, 2),\n\t\t\t   strlen(split2));\n\tif (memcmp(buf, split2, strlen(split2))) {\n\t\ttest_msg(\"Data in the buffer doesn't match what it should \"\n\t\t\t \"in the last chunk\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\nout:\n\tbtrfs_free_path(path);\n\tkfree(root);\n\treturn ret;\n}",
          "includes": [
            "#include \"../disk-io.h\"",
            "#include \"../extent_io.h\"",
            "#include \"../ctree.h\"",
            "#include \"btrfs-tests.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../disk-io.h\"\n#include \"../extent_io.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n#include <linux/slab.h>\n\nstatic int test_btrfs_split_item(void)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_root *root;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_item *item;\n\tchar *value = \"mary had a little lamb\";\n\tchar *split1 = \"mary had a little\";\n\tchar *split2 = \" lamb\";\n\tchar *split3 = \"mary\";\n\tchar *split4 = \" had a little\";\n\tchar buf[32];\n\tstruct btrfs_key key;\n\tu32 value_len = strlen(value);\n\tint ret = 0;\n\n\ttest_msg(\"Running btrfs_split_item tests\\n\");\n\n\troot = btrfs_alloc_dummy_root();\n\tif (IS_ERR(root)) {\n\t\ttest_msg(\"Could not allocate root\\n\");\n\t\treturn PTR_ERR(root);\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\ttest_msg(\"Could not allocate path\\n\");\n\t\tkfree(root);\n\t\treturn -ENOMEM;\n\t}\n\n\tpath->nodes[0] = eb = alloc_dummy_extent_buffer(NULL, 4096);\n\tif (!eb) {\n\t\ttest_msg(\"Could not allocate dummy buffer\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tpath->slots[0] = 0;\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_EXTENT_CSUM_KEY;\n\tkey.offset = 0;\n\n\tsetup_items_for_insert(root, path, &key, &value_len, value_len,\n\t\t\t       value_len + sizeof(struct btrfs_item), 1);\n\titem = btrfs_item_nr(0);\n\twrite_extent_buffer(eb, value, btrfs_item_ptr_offset(eb, 0),\n\t\t\t    value_len);\n\n\tkey.offset = 3;\n\n\t/*\n\t * Passing NULL trans here should be safe because we have plenty of\n\t * space in this leaf to split the item without having to split the\n\t * leaf.\n\t */\n\tret = btrfs_split_item(NULL, root, path, &key, 17);\n\tif (ret) {\n\t\ttest_msg(\"Split item failed %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Read the first slot, it should have the original key and contain only\n\t * 'mary had a little'\n\t */\n\tbtrfs_item_key_to_cpu(eb, &key, 0);\n\tif (key.objectid != 0 || key.type != BTRFS_EXTENT_CSUM_KEY ||\n\t    key.offset != 0) {\n\t\ttest_msg(\"Invalid key at slot 0\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\titem = btrfs_item_nr(0);\n\tif (btrfs_item_size(eb, item) != strlen(split1)) {\n\t\ttest_msg(\"Invalid len in the first split\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tread_extent_buffer(eb, buf, btrfs_item_ptr_offset(eb, 0),\n\t\t\t   strlen(split1));\n\tif (memcmp(buf, split1, strlen(split1))) {\n\t\ttest_msg(\"Data in the buffer doesn't match what it should \"\n\t\t\t \"in the first split have='%.*s' want '%s'\\n\",\n\t\t\t (int)strlen(split1), buf, split1);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tbtrfs_item_key_to_cpu(eb, &key, 1);\n\tif (key.objectid != 0 || key.type != BTRFS_EXTENT_CSUM_KEY ||\n\t    key.offset != 3) {\n\t\ttest_msg(\"Invalid key at slot 1\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\titem = btrfs_item_nr(1);\n\tif (btrfs_item_size(eb, item) != strlen(split2)) {\n\t\ttest_msg(\"Invalid len in the second split\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tread_extent_buffer(eb, buf, btrfs_item_ptr_offset(eb, 1),\n\t\t\t   strlen(split2));\n\tif (memcmp(buf, split2, strlen(split2))) {\n\t\ttest_msg(\"Data in the buffer doesn't match what it should \"\n\t\t\t \"in the second split\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tkey.offset = 1;\n\t/* Do it again so we test memmoving the other items in the leaf */\n\tret = btrfs_split_item(NULL, root, path, &key, 4);\n\tif (ret) {\n\t\ttest_msg(\"Second split item failed %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tbtrfs_item_key_to_cpu(eb, &key, 0);\n\tif (key.objectid != 0 || key.type != BTRFS_EXTENT_CSUM_KEY ||\n\t    key.offset != 0) {\n\t\ttest_msg(\"Invalid key at slot 0\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\titem = btrfs_item_nr(0);\n\tif (btrfs_item_size(eb, item) != strlen(split3)) {\n\t\ttest_msg(\"Invalid len in the first split\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tread_extent_buffer(eb, buf, btrfs_item_ptr_offset(eb, 0),\n\t\t\t   strlen(split3));\n\tif (memcmp(buf, split3, strlen(split3))) {\n\t\ttest_msg(\"Data in the buffer doesn't match what it should \"\n\t\t\t \"in the third split\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tbtrfs_item_key_to_cpu(eb, &key, 1);\n\tif (key.objectid != 0 || key.type != BTRFS_EXTENT_CSUM_KEY ||\n\t    key.offset != 1) {\n\t\ttest_msg(\"Invalid key at slot 1\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\titem = btrfs_item_nr(1);\n\tif (btrfs_item_size(eb, item) != strlen(split4)) {\n\t\ttest_msg(\"Invalid len in the second split\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tread_extent_buffer(eb, buf, btrfs_item_ptr_offset(eb, 1),\n\t\t\t   strlen(split4));\n\tif (memcmp(buf, split4, strlen(split4))) {\n\t\ttest_msg(\"Data in the buffer doesn't match what it should \"\n\t\t\t \"in the fourth split\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tbtrfs_item_key_to_cpu(eb, &key, 2);\n\tif (key.objectid != 0 || key.type != BTRFS_EXTENT_CSUM_KEY ||\n\t    key.offset != 3) {\n\t\ttest_msg(\"Invalid key at slot 2\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\titem = btrfs_item_nr(2);\n\tif (btrfs_item_size(eb, item) != strlen(split2)) {\n\t\ttest_msg(\"Invalid len in the second split\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tread_extent_buffer(eb, buf, btrfs_item_ptr_offset(eb, 2),\n\t\t\t   strlen(split2));\n\tif (memcmp(buf, split2, strlen(split2))) {\n\t\ttest_msg(\"Data in the buffer doesn't match what it should \"\n\t\t\t \"in the last chunk\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\nout:\n\tbtrfs_free_path(path);\n\tkfree(root);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Running extent buffer operation tests\""
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../disk-io.h\"\n#include \"../extent_io.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n#include <linux/slab.h>\n\nint btrfs_test_extent_buffer_operations(void)\n{\n\ttest_msg(\"Running extent buffer operation tests\");\n\treturn test_btrfs_split_item();\n}"
  },
  {
    "function_name": "test_btrfs_split_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/extent-buffer-tests.c",
    "lines": "25-223",
    "snippet": "static int test_btrfs_split_item(void)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_root *root;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_item *item;\n\tchar *value = \"mary had a little lamb\";\n\tchar *split1 = \"mary had a little\";\n\tchar *split2 = \" lamb\";\n\tchar *split3 = \"mary\";\n\tchar *split4 = \" had a little\";\n\tchar buf[32];\n\tstruct btrfs_key key;\n\tu32 value_len = strlen(value);\n\tint ret = 0;\n\n\ttest_msg(\"Running btrfs_split_item tests\\n\");\n\n\troot = btrfs_alloc_dummy_root();\n\tif (IS_ERR(root)) {\n\t\ttest_msg(\"Could not allocate root\\n\");\n\t\treturn PTR_ERR(root);\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\ttest_msg(\"Could not allocate path\\n\");\n\t\tkfree(root);\n\t\treturn -ENOMEM;\n\t}\n\n\tpath->nodes[0] = eb = alloc_dummy_extent_buffer(NULL, 4096);\n\tif (!eb) {\n\t\ttest_msg(\"Could not allocate dummy buffer\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tpath->slots[0] = 0;\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_EXTENT_CSUM_KEY;\n\tkey.offset = 0;\n\n\tsetup_items_for_insert(root, path, &key, &value_len, value_len,\n\t\t\t       value_len + sizeof(struct btrfs_item), 1);\n\titem = btrfs_item_nr(0);\n\twrite_extent_buffer(eb, value, btrfs_item_ptr_offset(eb, 0),\n\t\t\t    value_len);\n\n\tkey.offset = 3;\n\n\t/*\n\t * Passing NULL trans here should be safe because we have plenty of\n\t * space in this leaf to split the item without having to split the\n\t * leaf.\n\t */\n\tret = btrfs_split_item(NULL, root, path, &key, 17);\n\tif (ret) {\n\t\ttest_msg(\"Split item failed %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Read the first slot, it should have the original key and contain only\n\t * 'mary had a little'\n\t */\n\tbtrfs_item_key_to_cpu(eb, &key, 0);\n\tif (key.objectid != 0 || key.type != BTRFS_EXTENT_CSUM_KEY ||\n\t    key.offset != 0) {\n\t\ttest_msg(\"Invalid key at slot 0\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\titem = btrfs_item_nr(0);\n\tif (btrfs_item_size(eb, item) != strlen(split1)) {\n\t\ttest_msg(\"Invalid len in the first split\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tread_extent_buffer(eb, buf, btrfs_item_ptr_offset(eb, 0),\n\t\t\t   strlen(split1));\n\tif (memcmp(buf, split1, strlen(split1))) {\n\t\ttest_msg(\"Data in the buffer doesn't match what it should \"\n\t\t\t \"in the first split have='%.*s' want '%s'\\n\",\n\t\t\t (int)strlen(split1), buf, split1);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tbtrfs_item_key_to_cpu(eb, &key, 1);\n\tif (key.objectid != 0 || key.type != BTRFS_EXTENT_CSUM_KEY ||\n\t    key.offset != 3) {\n\t\ttest_msg(\"Invalid key at slot 1\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\titem = btrfs_item_nr(1);\n\tif (btrfs_item_size(eb, item) != strlen(split2)) {\n\t\ttest_msg(\"Invalid len in the second split\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tread_extent_buffer(eb, buf, btrfs_item_ptr_offset(eb, 1),\n\t\t\t   strlen(split2));\n\tif (memcmp(buf, split2, strlen(split2))) {\n\t\ttest_msg(\"Data in the buffer doesn't match what it should \"\n\t\t\t \"in the second split\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tkey.offset = 1;\n\t/* Do it again so we test memmoving the other items in the leaf */\n\tret = btrfs_split_item(NULL, root, path, &key, 4);\n\tif (ret) {\n\t\ttest_msg(\"Second split item failed %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tbtrfs_item_key_to_cpu(eb, &key, 0);\n\tif (key.objectid != 0 || key.type != BTRFS_EXTENT_CSUM_KEY ||\n\t    key.offset != 0) {\n\t\ttest_msg(\"Invalid key at slot 0\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\titem = btrfs_item_nr(0);\n\tif (btrfs_item_size(eb, item) != strlen(split3)) {\n\t\ttest_msg(\"Invalid len in the first split\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tread_extent_buffer(eb, buf, btrfs_item_ptr_offset(eb, 0),\n\t\t\t   strlen(split3));\n\tif (memcmp(buf, split3, strlen(split3))) {\n\t\ttest_msg(\"Data in the buffer doesn't match what it should \"\n\t\t\t \"in the third split\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tbtrfs_item_key_to_cpu(eb, &key, 1);\n\tif (key.objectid != 0 || key.type != BTRFS_EXTENT_CSUM_KEY ||\n\t    key.offset != 1) {\n\t\ttest_msg(\"Invalid key at slot 1\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\titem = btrfs_item_nr(1);\n\tif (btrfs_item_size(eb, item) != strlen(split4)) {\n\t\ttest_msg(\"Invalid len in the second split\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tread_extent_buffer(eb, buf, btrfs_item_ptr_offset(eb, 1),\n\t\t\t   strlen(split4));\n\tif (memcmp(buf, split4, strlen(split4))) {\n\t\ttest_msg(\"Data in the buffer doesn't match what it should \"\n\t\t\t \"in the fourth split\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tbtrfs_item_key_to_cpu(eb, &key, 2);\n\tif (key.objectid != 0 || key.type != BTRFS_EXTENT_CSUM_KEY ||\n\t    key.offset != 3) {\n\t\ttest_msg(\"Invalid key at slot 2\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\titem = btrfs_item_nr(2);\n\tif (btrfs_item_size(eb, item) != strlen(split2)) {\n\t\ttest_msg(\"Invalid len in the second split\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tread_extent_buffer(eb, buf, btrfs_item_ptr_offset(eb, 2),\n\t\t\t   strlen(split2));\n\tif (memcmp(buf, split2, strlen(split2))) {\n\t\ttest_msg(\"Data in the buffer doesn't match what it should \"\n\t\t\t \"in the last chunk\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\nout:\n\tbtrfs_free_path(path);\n\tkfree(root);\n\treturn ret;\n}",
    "includes": [
      "#include \"../disk-io.h\"",
      "#include \"../extent_io.h\"",
      "#include \"../ctree.h\"",
      "#include \"btrfs-tests.h\"",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "root"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Data in the buffer doesn't match what it should \"\n\t\t\t \"in the last chunk\\n\""
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "buf",
            "split2",
            "strlen(split2)"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "split2"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_extent_buffer",
          "args": [
            "eb",
            "buf",
            "btrfs_item_ptr_offset(eb, 2)",
            "strlen(split2)"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "btree_read_extent_buffer_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "442-497",
          "snippet": "static int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr_offset",
          "args": [
            "eb",
            "2"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Invalid len in the second split\\n\""
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_size",
          "args": [
            "eb",
            "item"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_nr",
          "args": [
            "2"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2628-2631",
          "snippet": "static inline struct btrfs_item *btrfs_item_nr(int nr)\n{\n\treturn (struct btrfs_item *)btrfs_item_nr_offset(nr);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline struct btrfs_item *btrfs_item_nr(int nr)\n{\n\treturn (struct btrfs_item *)btrfs_item_nr_offset(nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Invalid key at slot 2\\n\""
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "eb",
            "&key",
            "2"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Data in the buffer doesn't match what it should \"\n\t\t\t \"in the fourth split\\n\""
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "buf",
            "split4",
            "strlen(split4)"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr_offset",
          "args": [
            "eb",
            "1"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Invalid len in the second split\\n\""
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Invalid key at slot 1\\n\""
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Data in the buffer doesn't match what it should \"\n\t\t\t \"in the third split\""
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "buf",
            "split3",
            "strlen(split3)"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr_offset",
          "args": [
            "eb",
            "0"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Invalid len in the first split\\n\""
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Invalid key at slot 0\\n\""
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Second split item failed %d\\n\"",
            "ret"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_split_item",
          "args": [
            "NULL",
            "root",
            "path",
            "&key",
            "4"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_split_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "4477-4491",
          "snippet": "int btrfs_split_item(struct btrfs_trans_handle *trans,\n\t\t     struct btrfs_root *root,\n\t\t     struct btrfs_path *path,\n\t\t     struct btrfs_key *new_key,\n\t\t     unsigned long split_offset)\n{\n\tint ret;\n\tret = setup_leaf_for_split(trans, root, path,\n\t\t\t\t   sizeof(struct btrfs_item));\n\tif (ret)\n\t\treturn ret;\n\n\tret = split_item(trans, root, path, new_key, split_offset);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_split_item(struct btrfs_trans_handle *trans,\n\t\t     struct btrfs_root *root,\n\t\t     struct btrfs_path *path,\n\t\t     struct btrfs_key *new_key,\n\t\t     unsigned long split_offset)\n{\n\tint ret;\n\tret = setup_leaf_for_split(trans, root, path,\n\t\t\t\t   sizeof(struct btrfs_item));\n\tif (ret)\n\t\treturn ret;\n\n\tret = split_item(trans, root, path, new_key, split_offset);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Data in the buffer doesn't match what it should \"\n\t\t\t \"in the second split\\n\""
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "buf",
            "split2",
            "strlen(split2)"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr_offset",
          "args": [
            "eb",
            "1"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Invalid len in the second split\\n\""
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Invalid key at slot 1\\n\""
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Data in the buffer doesn't match what it should \"\n\t\t\t \"in the first split have='%.*s' want '%s'\\n\"",
            "(int)strlen(split1)",
            "buf",
            "split1"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "buf",
            "split1",
            "strlen(split1)"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr_offset",
          "args": [
            "eb",
            "0"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Invalid len in the first split\\n\""
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Invalid key at slot 0\\n\""
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Split item failed %d\\n\"",
            "ret"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_extent_buffer",
          "args": [
            "eb",
            "value",
            "btrfs_item_ptr_offset(eb, 0)",
            "value_len"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "write_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5356-5385",
          "snippet": "void write_extent_buffer(struct extent_buffer *eb, const void *srcv,\n\t\t\t unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *src = (char *)srcv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemcpy(kaddr + offset, src, cur);\n\n\t\tsrc += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid write_extent_buffer(struct extent_buffer *eb, const void *srcv,\n\t\t\t unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *src = (char *)srcv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemcpy(kaddr + offset, src, cur);\n\n\t\tsrc += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr_offset",
          "args": [
            "eb",
            "0"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_items_for_insert",
          "args": [
            "root",
            "path",
            "&key",
            "&value_len",
            "value_len",
            "value_len + sizeof(struct btrfs_item)",
            "1"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "setup_items_for_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "4704-4789",
          "snippet": "void setup_items_for_insert(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t    struct btrfs_key *cpu_key, u32 *data_size,\n\t\t\t    u32 total_data, u32 total_size, int nr)\n{\n\tstruct btrfs_item *item;\n\tint i;\n\tu32 nritems;\n\tunsigned int data_end;\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *leaf;\n\tint slot;\n\tstruct btrfs_map_token token;\n\n\tif (path->slots[0] == 0) {\n\t\tbtrfs_cpu_key_to_disk(&disk_key, cpu_key);\n\t\tfixup_low_keys(root, path, &disk_key, 1);\n\t}\n\tbtrfs_unlock_up_safe(path, 1);\n\n\tbtrfs_init_map_token(&token);\n\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\n\tnritems = btrfs_header_nritems(leaf);\n\tdata_end = leaf_data_end(root, leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < total_size) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tbtrfs_crit(root->fs_info, \"not enough freespace need %u have %d\",\n\t\t       total_size, btrfs_leaf_free_space(root, leaf));\n\t\tBUG();\n\t}\n\n\tif (slot != nritems) {\n\t\tunsigned int old_data = btrfs_item_end_nr(leaf, slot);\n\n\t\tif (old_data < data_end) {\n\t\t\tbtrfs_print_leaf(root, leaf);\n\t\t\tbtrfs_crit(root->fs_info, \"slot %d old_data %d data_end %d\",\n\t\t\t       slot, old_data, data_end);\n\t\t\tBUG_ON(1);\n\t\t}\n\t\t/*\n\t\t * item0..itemN ... dataN.offset..dataN.size .. data0.size\n\t\t */\n\t\t/* first correct the data pointers */\n\t\tfor (i = slot; i < nritems; i++) {\n\t\t\tu32 ioff;\n\n\t\t\titem = btrfs_item_nr( i);\n\t\t\tioff = btrfs_token_item_offset(leaf, item, &token);\n\t\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t\t    ioff - total_data, &token);\n\t\t}\n\t\t/* shift the items */\n\t\tmemmove_extent_buffer(leaf, btrfs_item_nr_offset(slot + nr),\n\t\t\t      btrfs_item_nr_offset(slot),\n\t\t\t      (nritems - slot) * sizeof(struct btrfs_item));\n\n\t\t/* shift the data */\n\t\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t\t      data_end - total_data, btrfs_leaf_data(leaf) +\n\t\t\t      data_end, old_data - data_end);\n\t\tdata_end = old_data;\n\t}\n\n\t/* setup the item for the new data */\n\tfor (i = 0; i < nr; i++) {\n\t\tbtrfs_cpu_key_to_disk(&disk_key, cpu_key + i);\n\t\tbtrfs_set_item_key(leaf, &disk_key, slot + i);\n\t\titem = btrfs_item_nr(slot + i);\n\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t    data_end - data_size[i], &token);\n\t\tdata_end -= data_size[i];\n\t\tbtrfs_set_token_item_size(leaf, item, data_size[i], &token);\n\t}\n\n\tbtrfs_set_header_nritems(leaf, nritems + nr);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < 0) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nvoid setup_items_for_insert(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t    struct btrfs_key *cpu_key, u32 *data_size,\n\t\t\t    u32 total_data, u32 total_size, int nr)\n{\n\tstruct btrfs_item *item;\n\tint i;\n\tu32 nritems;\n\tunsigned int data_end;\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *leaf;\n\tint slot;\n\tstruct btrfs_map_token token;\n\n\tif (path->slots[0] == 0) {\n\t\tbtrfs_cpu_key_to_disk(&disk_key, cpu_key);\n\t\tfixup_low_keys(root, path, &disk_key, 1);\n\t}\n\tbtrfs_unlock_up_safe(path, 1);\n\n\tbtrfs_init_map_token(&token);\n\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\n\tnritems = btrfs_header_nritems(leaf);\n\tdata_end = leaf_data_end(root, leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < total_size) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tbtrfs_crit(root->fs_info, \"not enough freespace need %u have %d\",\n\t\t       total_size, btrfs_leaf_free_space(root, leaf));\n\t\tBUG();\n\t}\n\n\tif (slot != nritems) {\n\t\tunsigned int old_data = btrfs_item_end_nr(leaf, slot);\n\n\t\tif (old_data < data_end) {\n\t\t\tbtrfs_print_leaf(root, leaf);\n\t\t\tbtrfs_crit(root->fs_info, \"slot %d old_data %d data_end %d\",\n\t\t\t       slot, old_data, data_end);\n\t\t\tBUG_ON(1);\n\t\t}\n\t\t/*\n\t\t * item0..itemN ... dataN.offset..dataN.size .. data0.size\n\t\t */\n\t\t/* first correct the data pointers */\n\t\tfor (i = slot; i < nritems; i++) {\n\t\t\tu32 ioff;\n\n\t\t\titem = btrfs_item_nr( i);\n\t\t\tioff = btrfs_token_item_offset(leaf, item, &token);\n\t\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t\t    ioff - total_data, &token);\n\t\t}\n\t\t/* shift the items */\n\t\tmemmove_extent_buffer(leaf, btrfs_item_nr_offset(slot + nr),\n\t\t\t      btrfs_item_nr_offset(slot),\n\t\t\t      (nritems - slot) * sizeof(struct btrfs_item));\n\n\t\t/* shift the data */\n\t\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t\t      data_end - total_data, btrfs_leaf_data(leaf) +\n\t\t\t      data_end, old_data - data_end);\n\t\tdata_end = old_data;\n\t}\n\n\t/* setup the item for the new data */\n\tfor (i = 0; i < nr; i++) {\n\t\tbtrfs_cpu_key_to_disk(&disk_key, cpu_key + i);\n\t\tbtrfs_set_item_key(leaf, &disk_key, slot + i);\n\t\titem = btrfs_item_nr(slot + i);\n\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t    data_end - data_size[i], &token);\n\t\tdata_end -= data_size[i];\n\t\tbtrfs_set_token_item_size(leaf, item, data_size[i], &token);\n\t}\n\n\tbtrfs_set_header_nritems(leaf, nritems + nr);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < 0) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Could not allocate dummy buffer\\n\""
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_dummy_extent_buffer",
          "args": [
            "NULL",
            "4096"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_dummy_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "4672-4710",
          "snippet": "struct extent_buffer *alloc_dummy_extent_buffer(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tu64 start)\n{\n\tstruct extent_buffer *eb;\n\tunsigned long len;\n\tunsigned long num_pages;\n\tunsigned long i;\n\n\tif (!fs_info) {\n\t\t/*\n\t\t * Called only from tests that don't always have a fs_info\n\t\t * available, but we know that nodesize is 4096\n\t\t */\n\t\tlen = 4096;\n\t} else {\n\t\tlen = fs_info->tree_root->nodesize;\n\t}\n\tnum_pages = num_extent_pages(0, len);\n\n\teb = __alloc_extent_buffer(fs_info, start, len);\n\tif (!eb)\n\t\treturn NULL;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\teb->pages[i] = alloc_page(GFP_NOFS);\n\t\tif (!eb->pages[i])\n\t\t\tgoto err;\n\t}\n\tset_extent_buffer_uptodate(eb);\n\tbtrfs_set_header_nritems(eb, 0);\n\tset_bit(EXTENT_BUFFER_DUMMY, &eb->bflags);\n\n\treturn eb;\nerr:\n\tfor (; i > 0; i--)\n\t\t__free_page(eb->pages[i - 1]);\n\t__free_extent_buffer(eb);\n\treturn NULL;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstruct extent_buffer *alloc_dummy_extent_buffer(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tu64 start)\n{\n\tstruct extent_buffer *eb;\n\tunsigned long len;\n\tunsigned long num_pages;\n\tunsigned long i;\n\n\tif (!fs_info) {\n\t\t/*\n\t\t * Called only from tests that don't always have a fs_info\n\t\t * available, but we know that nodesize is 4096\n\t\t */\n\t\tlen = 4096;\n\t} else {\n\t\tlen = fs_info->tree_root->nodesize;\n\t}\n\tnum_pages = num_extent_pages(0, len);\n\n\teb = __alloc_extent_buffer(fs_info, start, len);\n\tif (!eb)\n\t\treturn NULL;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\teb->pages[i] = alloc_page(GFP_NOFS);\n\t\tif (!eb->pages[i])\n\t\t\tgoto err;\n\t}\n\tset_extent_buffer_uptodate(eb);\n\tbtrfs_set_header_nritems(eb, 0);\n\tset_bit(EXTENT_BUFFER_DUMMY, &eb->bflags);\n\n\treturn eb;\nerr:\n\tfor (; i > 0; i--)\n\t\t__free_page(eb->pages[i - 1]);\n\t__free_extent_buffer(eb);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "root"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Could not allocate path\\n\""
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "root"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Could not allocate root\\n\""
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "root"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_dummy_root",
          "args": [],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_dummy_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1298-1310",
          "snippet": "struct btrfs_root *btrfs_alloc_dummy_root(void)\n{\n\tstruct btrfs_root *root;\n\n\troot = btrfs_alloc_root(NULL);\n\tif (!root)\n\t\treturn ERR_PTR(-ENOMEM);\n\t__setup_root(4096, 4096, 4096, root, NULL, 1);\n\tset_bit(BTRFS_ROOT_DUMMY_ROOT, &root->state);\n\troot->alloc_bytenr = 0;\n\n\treturn root;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstruct btrfs_root *btrfs_alloc_dummy_root(void)\n{\n\tstruct btrfs_root *root;\n\n\troot = btrfs_alloc_root(NULL);\n\tif (!root)\n\t\treturn ERR_PTR(-ENOMEM);\n\t__setup_root(4096, 4096, 4096, root, NULL, 1);\n\tset_bit(BTRFS_ROOT_DUMMY_ROOT, &root->state);\n\troot->alloc_bytenr = 0;\n\n\treturn root;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Running btrfs_split_item tests\\n\""
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../disk-io.h\"\n#include \"../extent_io.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n#include <linux/slab.h>\n\nstatic int test_btrfs_split_item(void)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_root *root;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_item *item;\n\tchar *value = \"mary had a little lamb\";\n\tchar *split1 = \"mary had a little\";\n\tchar *split2 = \" lamb\";\n\tchar *split3 = \"mary\";\n\tchar *split4 = \" had a little\";\n\tchar buf[32];\n\tstruct btrfs_key key;\n\tu32 value_len = strlen(value);\n\tint ret = 0;\n\n\ttest_msg(\"Running btrfs_split_item tests\\n\");\n\n\troot = btrfs_alloc_dummy_root();\n\tif (IS_ERR(root)) {\n\t\ttest_msg(\"Could not allocate root\\n\");\n\t\treturn PTR_ERR(root);\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\ttest_msg(\"Could not allocate path\\n\");\n\t\tkfree(root);\n\t\treturn -ENOMEM;\n\t}\n\n\tpath->nodes[0] = eb = alloc_dummy_extent_buffer(NULL, 4096);\n\tif (!eb) {\n\t\ttest_msg(\"Could not allocate dummy buffer\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tpath->slots[0] = 0;\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_EXTENT_CSUM_KEY;\n\tkey.offset = 0;\n\n\tsetup_items_for_insert(root, path, &key, &value_len, value_len,\n\t\t\t       value_len + sizeof(struct btrfs_item), 1);\n\titem = btrfs_item_nr(0);\n\twrite_extent_buffer(eb, value, btrfs_item_ptr_offset(eb, 0),\n\t\t\t    value_len);\n\n\tkey.offset = 3;\n\n\t/*\n\t * Passing NULL trans here should be safe because we have plenty of\n\t * space in this leaf to split the item without having to split the\n\t * leaf.\n\t */\n\tret = btrfs_split_item(NULL, root, path, &key, 17);\n\tif (ret) {\n\t\ttest_msg(\"Split item failed %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Read the first slot, it should have the original key and contain only\n\t * 'mary had a little'\n\t */\n\tbtrfs_item_key_to_cpu(eb, &key, 0);\n\tif (key.objectid != 0 || key.type != BTRFS_EXTENT_CSUM_KEY ||\n\t    key.offset != 0) {\n\t\ttest_msg(\"Invalid key at slot 0\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\titem = btrfs_item_nr(0);\n\tif (btrfs_item_size(eb, item) != strlen(split1)) {\n\t\ttest_msg(\"Invalid len in the first split\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tread_extent_buffer(eb, buf, btrfs_item_ptr_offset(eb, 0),\n\t\t\t   strlen(split1));\n\tif (memcmp(buf, split1, strlen(split1))) {\n\t\ttest_msg(\"Data in the buffer doesn't match what it should \"\n\t\t\t \"in the first split have='%.*s' want '%s'\\n\",\n\t\t\t (int)strlen(split1), buf, split1);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tbtrfs_item_key_to_cpu(eb, &key, 1);\n\tif (key.objectid != 0 || key.type != BTRFS_EXTENT_CSUM_KEY ||\n\t    key.offset != 3) {\n\t\ttest_msg(\"Invalid key at slot 1\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\titem = btrfs_item_nr(1);\n\tif (btrfs_item_size(eb, item) != strlen(split2)) {\n\t\ttest_msg(\"Invalid len in the second split\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tread_extent_buffer(eb, buf, btrfs_item_ptr_offset(eb, 1),\n\t\t\t   strlen(split2));\n\tif (memcmp(buf, split2, strlen(split2))) {\n\t\ttest_msg(\"Data in the buffer doesn't match what it should \"\n\t\t\t \"in the second split\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tkey.offset = 1;\n\t/* Do it again so we test memmoving the other items in the leaf */\n\tret = btrfs_split_item(NULL, root, path, &key, 4);\n\tif (ret) {\n\t\ttest_msg(\"Second split item failed %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tbtrfs_item_key_to_cpu(eb, &key, 0);\n\tif (key.objectid != 0 || key.type != BTRFS_EXTENT_CSUM_KEY ||\n\t    key.offset != 0) {\n\t\ttest_msg(\"Invalid key at slot 0\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\titem = btrfs_item_nr(0);\n\tif (btrfs_item_size(eb, item) != strlen(split3)) {\n\t\ttest_msg(\"Invalid len in the first split\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tread_extent_buffer(eb, buf, btrfs_item_ptr_offset(eb, 0),\n\t\t\t   strlen(split3));\n\tif (memcmp(buf, split3, strlen(split3))) {\n\t\ttest_msg(\"Data in the buffer doesn't match what it should \"\n\t\t\t \"in the third split\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tbtrfs_item_key_to_cpu(eb, &key, 1);\n\tif (key.objectid != 0 || key.type != BTRFS_EXTENT_CSUM_KEY ||\n\t    key.offset != 1) {\n\t\ttest_msg(\"Invalid key at slot 1\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\titem = btrfs_item_nr(1);\n\tif (btrfs_item_size(eb, item) != strlen(split4)) {\n\t\ttest_msg(\"Invalid len in the second split\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tread_extent_buffer(eb, buf, btrfs_item_ptr_offset(eb, 1),\n\t\t\t   strlen(split4));\n\tif (memcmp(buf, split4, strlen(split4))) {\n\t\ttest_msg(\"Data in the buffer doesn't match what it should \"\n\t\t\t \"in the fourth split\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tbtrfs_item_key_to_cpu(eb, &key, 2);\n\tif (key.objectid != 0 || key.type != BTRFS_EXTENT_CSUM_KEY ||\n\t    key.offset != 3) {\n\t\ttest_msg(\"Invalid key at slot 2\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\titem = btrfs_item_nr(2);\n\tif (btrfs_item_size(eb, item) != strlen(split2)) {\n\t\ttest_msg(\"Invalid len in the second split\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tread_extent_buffer(eb, buf, btrfs_item_ptr_offset(eb, 2),\n\t\t\t   strlen(split2));\n\tif (memcmp(buf, split2, strlen(split2))) {\n\t\ttest_msg(\"Data in the buffer doesn't match what it should \"\n\t\t\t \"in the last chunk\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\nout:\n\tbtrfs_free_path(path);\n\tkfree(root);\n\treturn ret;\n}"
  }
]