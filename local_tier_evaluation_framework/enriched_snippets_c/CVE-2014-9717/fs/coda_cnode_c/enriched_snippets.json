[
  {
    "function_name": "coda_cnode_makectl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cnode.c",
    "lines": "156-167",
    "snippet": "struct inode *coda_cnode_makectl(struct super_block *sb)\n{\n\tstruct inode *inode = new_inode(sb);\n\tif (inode) {\n\t\tinode->i_ino = CTL_INO;\n\t\tinode->i_op = &coda_ioctl_inode_operations;\n\t\tinode->i_fop = &coda_ioctl_operations;\n\t\tinode->i_mode = 0444;\n\t\treturn inode;\n\t}\n\treturn ERR_PTR(-ENOMEM);\n}",
    "includes": [
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "sb"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\nstruct inode *coda_cnode_makectl(struct super_block *sb)\n{\n\tstruct inode *inode = new_inode(sb);\n\tif (inode) {\n\t\tinode->i_ino = CTL_INO;\n\t\tinode->i_op = &coda_ioctl_inode_operations;\n\t\tinode->i_fop = &coda_ioctl_operations;\n\t\tinode->i_mode = 0444;\n\t\treturn inode;\n\t}\n\treturn ERR_PTR(-ENOMEM);\n}"
  },
  {
    "function_name": "coda_fid_to_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cnode.c",
    "lines": "134-153",
    "snippet": "struct inode *coda_fid_to_inode(struct CodaFid *fid, struct super_block *sb) \n{\n\tstruct inode *inode;\n\tunsigned long hash = coda_f2i(fid);\n\n\tif ( !sb ) {\n\t\tpr_warn(\"%s: no sb!\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tinode = ilookup5(sb, hash, coda_test_inode, fid);\n\tif ( !inode )\n\t\treturn NULL;\n\n\t/* we should never see newly created inodes because we intentionally\n\t * fail in the initialization callback */\n\tBUG_ON(inode->i_state & I_NEW);\n\n\treturn inode;\n}",
    "includes": [
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "inode->i_state & I_NEW"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilookup5",
          "args": [
            "sb",
            "hash",
            "coda_test_inode",
            "fid"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "ilookup5",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1239-1247",
          "snippet": "struct inode *ilookup5(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct inode *inode = ilookup5_nowait(sb, hashval, test, data);\n\n\tif (inode)\n\t\twait_on_inode(inode);\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *ilookup5(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct inode *inode = ilookup5_nowait(sb, hashval, test, data);\n\n\tif (inode)\n\t\twait_on_inode(inode);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: no sb!\\n\"",
            "__func__"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "coda_f2i",
          "args": [
            "fid"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\nstruct inode *coda_fid_to_inode(struct CodaFid *fid, struct super_block *sb) \n{\n\tstruct inode *inode;\n\tunsigned long hash = coda_f2i(fid);\n\n\tif ( !sb ) {\n\t\tpr_warn(\"%s: no sb!\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tinode = ilookup5(sb, hash, coda_test_inode, fid);\n\tif ( !inode )\n\t\treturn NULL;\n\n\t/* we should never see newly created inodes because we intentionally\n\t * fail in the initialization callback */\n\tBUG_ON(inode->i_state & I_NEW);\n\n\treturn inode;\n}"
  },
  {
    "function_name": "coda_replace_fid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cnode.c",
    "lines": "117-131",
    "snippet": "void coda_replace_fid(struct inode *inode, struct CodaFid *oldfid, \n\t\t      struct CodaFid *newfid)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\tunsigned long hash = coda_f2i(newfid);\n\t\n\tBUG_ON(!coda_fideq(&cii->c_fid, oldfid));\n\n\t/* replace fid and rehash inode */\n\t/* XXX we probably need to hold some lock here! */\n\tremove_inode_hash(inode);\n\tcii->c_fid = *newfid;\n\tinode->i_ino = hash;\n\t__insert_inode_hash(inode, hash);\n}",
    "includes": [
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__insert_inode_hash",
          "args": [
            "inode",
            "hash"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "__insert_inode_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "460-469",
          "snippet": "void __insert_inode_hash(struct inode *inode, unsigned long hashval)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(inode->i_sb, hashval);\n\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_add_head(&inode->i_hash, b);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid __insert_inode_hash(struct inode *inode, unsigned long hashval)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(inode->i_sb, hashval);\n\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_add_head(&inode->i_hash, b);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_inode_hash",
          "args": [
            "inode"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "__remove_inode_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "478-485",
          "snippet": "void __remove_inode_hash(struct inode *inode)\n{\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_del_init(&inode->i_hash);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid __remove_inode_hash(struct inode *inode)\n{\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_del_init(&inode->i_hash);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!coda_fideq(&cii->c_fid, oldfid)"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "coda_fideq",
          "args": [
            "&cii->c_fid",
            "oldfid"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "coda_fideq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cnode.c",
          "lines": "13-16",
          "snippet": "static inline int coda_fideq(struct CodaFid *fid1, struct CodaFid *fid2)\n{\n\treturn memcmp(fid1, fid2, sizeof(*fid1)) == 0;\n}",
          "includes": [
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\nstatic inline int coda_fideq(struct CodaFid *fid1, struct CodaFid *fid2)\n{\n\treturn memcmp(fid1, fid2, sizeof(*fid1)) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_f2i",
          "args": [
            "newfid"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ITOC",
          "args": [
            "inode"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "ITOC",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/coda_linux.h",
          "lines": "80-83",
          "snippet": "static inline struct coda_inode_info *ITOC(struct inode *inode)\n{\n\treturn list_entry(inode, struct coda_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"coda_fs_i.h\"",
            "#include <linux/fs.h>",
            "#include <linux/types.h>",
            "#include <linux/wait.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_fs_i.h\"\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic inline struct coda_inode_info *ITOC(struct inode *inode)\n{\n\treturn list_entry(inode, struct coda_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\nvoid coda_replace_fid(struct inode *inode, struct CodaFid *oldfid, \n\t\t      struct CodaFid *newfid)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\tunsigned long hash = coda_f2i(newfid);\n\t\n\tBUG_ON(!coda_fideq(&cii->c_fid, oldfid));\n\n\t/* replace fid and rehash inode */\n\t/* XXX we probably need to hold some lock here! */\n\tremove_inode_hash(inode);\n\tcii->c_fid = *newfid;\n\tinode->i_ino = hash;\n\t__insert_inode_hash(inode, hash);\n}"
  },
  {
    "function_name": "coda_cnode_make",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cnode.c",
    "lines": "91-106",
    "snippet": "struct inode *coda_cnode_make(struct CodaFid *fid, struct super_block *sb)\n{\n        struct coda_vattr attr;\n\tstruct inode *inode;\n        int error;\n        \n\t/* We get inode numbers from Venus -- see venus source */\n\terror = venus_getattr(sb, fid, &attr);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\tinode = coda_iget(sb, fid, &attr);\n\tif (IS_ERR(inode))\n\t\tpr_warn(\"%s: coda_iget failed\\n\", __func__);\n\treturn inode;\n}",
    "includes": [
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: coda_iget failed\\n\"",
            "__func__"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "coda_iget",
          "args": [
            "sb",
            "fid",
            "&attr"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "coda_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cnode.c",
          "lines": "59-83",
          "snippet": "struct inode * coda_iget(struct super_block * sb, struct CodaFid * fid,\n\t\t\t struct coda_vattr * attr)\n{\n\tstruct inode *inode;\n\tstruct coda_inode_info *cii;\n\tunsigned long hash = coda_f2i(fid);\n\n\tinode = iget5_locked(sb, hash, coda_test_inode, coda_set_inode, fid);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\tcii = ITOC(inode);\n\t\t/* we still need to set i_ino for things like stat(2) */\n\t\tinode->i_ino = hash;\n\t\t/* inode is locked and unique, no need to grab cii->c_lock */\n\t\tcii->c_mapcount = 0;\n\t\tunlock_new_inode(inode);\n\t}\n\n\t/* always replace the attributes, type might have changed */\n\tcoda_fill_inode(inode, attr);\n\treturn inode;\n}",
          "includes": [
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\nstruct inode * coda_iget(struct super_block * sb, struct CodaFid * fid,\n\t\t\t struct coda_vattr * attr)\n{\n\tstruct inode *inode;\n\tstruct coda_inode_info *cii;\n\tunsigned long hash = coda_f2i(fid);\n\n\tinode = iget5_locked(sb, hash, coda_test_inode, coda_set_inode, fid);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\tcii = ITOC(inode);\n\t\t/* we still need to set i_ino for things like stat(2) */\n\t\tinode->i_ino = hash;\n\t\t/* inode is locked and unique, no need to grab cii->c_lock */\n\t\tcii->c_mapcount = 0;\n\t\tunlock_new_inode(inode);\n\t}\n\n\t/* always replace the attributes, type might have changed */\n\tcoda_fill_inode(inode, attr);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "venus_getattr",
          "args": [
            "sb",
            "fid",
            "&attr"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "venus_getattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
          "lines": "91-108",
          "snippet": "int venus_getattr(struct super_block *sb, struct CodaFid *fid, \n\t\t     struct coda_vattr *attr) \n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n\n        insize = SIZE(getattr); \n\tUPARG(CODA_GETATTR);\n        inp->coda_getattr.VFid = *fid;\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\tif (!error)\n\t\t*attr = outp->coda_getattr.attr;\n\n\tCODA_FREE(inp, insize);\n        return error;\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/vfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nint venus_getattr(struct super_block *sb, struct CodaFid *fid, \n\t\t     struct coda_vattr *attr) \n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n\n        insize = SIZE(getattr); \n\tUPARG(CODA_GETATTR);\n        inp->coda_getattr.VFid = *fid;\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\tif (!error)\n\t\t*attr = outp->coda_getattr.attr;\n\n\tCODA_FREE(inp, insize);\n        return error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\nstruct inode *coda_cnode_make(struct CodaFid *fid, struct super_block *sb)\n{\n        struct coda_vattr attr;\n\tstruct inode *inode;\n        int error;\n        \n\t/* We get inode numbers from Venus -- see venus source */\n\terror = venus_getattr(sb, fid, &attr);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\tinode = coda_iget(sb, fid, &attr);\n\tif (IS_ERR(inode))\n\t\tpr_warn(\"%s: coda_iget failed\\n\", __func__);\n\treturn inode;\n}"
  },
  {
    "function_name": "coda_iget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cnode.c",
    "lines": "59-83",
    "snippet": "struct inode * coda_iget(struct super_block * sb, struct CodaFid * fid,\n\t\t\t struct coda_vattr * attr)\n{\n\tstruct inode *inode;\n\tstruct coda_inode_info *cii;\n\tunsigned long hash = coda_f2i(fid);\n\n\tinode = iget5_locked(sb, hash, coda_test_inode, coda_set_inode, fid);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\tcii = ITOC(inode);\n\t\t/* we still need to set i_ino for things like stat(2) */\n\t\tinode->i_ino = hash;\n\t\t/* inode is locked and unique, no need to grab cii->c_lock */\n\t\tcii->c_mapcount = 0;\n\t\tunlock_new_inode(inode);\n\t}\n\n\t/* always replace the attributes, type might have changed */\n\tcoda_fill_inode(inode, attr);\n\treturn inode;\n}",
    "includes": [
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "coda_fill_inode",
          "args": [
            "inode",
            "attr"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "coda_fill_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cnode.c",
          "lines": "26-42",
          "snippet": "static void coda_fill_inode(struct inode *inode, struct coda_vattr *attr)\n{\n        coda_vattr_to_iattr(inode, attr);\n\n        if (S_ISREG(inode->i_mode)) {\n                inode->i_op = &coda_file_inode_operations;\n                inode->i_fop = &coda_file_operations;\n        } else if (S_ISDIR(inode->i_mode)) {\n                inode->i_op = &coda_dir_inode_operations;\n                inode->i_fop = &coda_dir_operations;\n        } else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &coda_symlink_inode_operations;\n\t\tinode->i_data.a_ops = &coda_symlink_aops;\n\t\tinode->i_mapping = &inode->i_data;\n\t} else\n                init_special_inode(inode, inode->i_mode, huge_decode_dev(attr->va_rdev));\n}",
          "includes": [
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations coda_symlink_inode_operations = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= page_follow_link_light,\n\t.put_link\t= page_put_link,\n\t.setattr\t= coda_setattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\nstatic const struct inode_operations coda_symlink_inode_operations = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= page_follow_link_light,\n\t.put_link\t= page_put_link,\n\t.setattr\t= coda_setattr,\n};\n\nstatic void coda_fill_inode(struct inode *inode, struct coda_vattr *attr)\n{\n        coda_vattr_to_iattr(inode, attr);\n\n        if (S_ISREG(inode->i_mode)) {\n                inode->i_op = &coda_file_inode_operations;\n                inode->i_fop = &coda_file_operations;\n        } else if (S_ISDIR(inode->i_mode)) {\n                inode->i_op = &coda_dir_inode_operations;\n                inode->i_fop = &coda_dir_operations;\n        } else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &coda_symlink_inode_operations;\n\t\tinode->i_data.a_ops = &coda_symlink_aops;\n\t\tinode->i_mapping = &inode->i_data;\n\t} else\n                init_special_inode(inode, inode->i_mode, huge_decode_dev(attr->va_rdev));\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ITOC",
          "args": [
            "inode"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "ITOC",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/coda_linux.h",
          "lines": "80-83",
          "snippet": "static inline struct coda_inode_info *ITOC(struct inode *inode)\n{\n\treturn list_entry(inode, struct coda_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"coda_fs_i.h\"",
            "#include <linux/fs.h>",
            "#include <linux/types.h>",
            "#include <linux/wait.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_fs_i.h\"\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic inline struct coda_inode_info *ITOC(struct inode *inode)\n{\n\treturn list_entry(inode, struct coda_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget5_locked",
          "args": [
            "sb",
            "hash",
            "coda_test_inode",
            "coda_set_inode",
            "fid"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "iget5_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "991-1047",
          "snippet": "struct inode *iget5_locked(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode(sb, head, test, data);\n\t\tif (!old) {\n\t\t\tif (set(inode, data))\n\t\t\t\tgoto set_failed;\n\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n\nset_failed:\n\tspin_unlock(&inode_hash_lock);\n\tdestroy_inode(inode);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *iget5_locked(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode(sb, head, test, data);\n\t\tif (!old) {\n\t\t\tif (set(inode, data))\n\t\t\t\tgoto set_failed;\n\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n\nset_failed:\n\tspin_unlock(&inode_hash_lock);\n\tdestroy_inode(inode);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_f2i",
          "args": [
            "fid"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\nstruct inode * coda_iget(struct super_block * sb, struct CodaFid * fid,\n\t\t\t struct coda_vattr * attr)\n{\n\tstruct inode *inode;\n\tstruct coda_inode_info *cii;\n\tunsigned long hash = coda_f2i(fid);\n\n\tinode = iget5_locked(sb, hash, coda_test_inode, coda_set_inode, fid);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\tcii = ITOC(inode);\n\t\t/* we still need to set i_ino for things like stat(2) */\n\t\tinode->i_ino = hash;\n\t\t/* inode is locked and unique, no need to grab cii->c_lock */\n\t\tcii->c_mapcount = 0;\n\t\tunlock_new_inode(inode);\n\t}\n\n\t/* always replace the attributes, type might have changed */\n\tcoda_fill_inode(inode, attr);\n\treturn inode;\n}"
  },
  {
    "function_name": "coda_set_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cnode.c",
    "lines": "51-57",
    "snippet": "static int coda_set_inode(struct inode *inode, void *data)\n{\n\tstruct CodaFid *fid = (struct CodaFid *)data;\n\tstruct coda_inode_info *cii = ITOC(inode);\n\tcii->c_fid = *fid;\n\treturn 0;\n}",
    "includes": [
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ITOC",
          "args": [
            "inode"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "ITOC",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/coda_linux.h",
          "lines": "80-83",
          "snippet": "static inline struct coda_inode_info *ITOC(struct inode *inode)\n{\n\treturn list_entry(inode, struct coda_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"coda_fs_i.h\"",
            "#include <linux/fs.h>",
            "#include <linux/types.h>",
            "#include <linux/wait.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_fs_i.h\"\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic inline struct coda_inode_info *ITOC(struct inode *inode)\n{\n\treturn list_entry(inode, struct coda_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\nstatic int coda_set_inode(struct inode *inode, void *data)\n{\n\tstruct CodaFid *fid = (struct CodaFid *)data;\n\tstruct coda_inode_info *cii = ITOC(inode);\n\tcii->c_fid = *fid;\n\treturn 0;\n}"
  },
  {
    "function_name": "coda_test_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cnode.c",
    "lines": "44-49",
    "snippet": "static int coda_test_inode(struct inode *inode, void *data)\n{\n\tstruct CodaFid *fid = (struct CodaFid *)data;\n\tstruct coda_inode_info *cii = ITOC(inode);\n\treturn coda_fideq(&cii->c_fid, fid);\n}",
    "includes": [
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "coda_fideq",
          "args": [
            "&cii->c_fid",
            "fid"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "coda_fideq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cnode.c",
          "lines": "13-16",
          "snippet": "static inline int coda_fideq(struct CodaFid *fid1, struct CodaFid *fid2)\n{\n\treturn memcmp(fid1, fid2, sizeof(*fid1)) == 0;\n}",
          "includes": [
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\nstatic inline int coda_fideq(struct CodaFid *fid1, struct CodaFid *fid2)\n{\n\treturn memcmp(fid1, fid2, sizeof(*fid1)) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ITOC",
          "args": [
            "inode"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "ITOC",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/coda_linux.h",
          "lines": "80-83",
          "snippet": "static inline struct coda_inode_info *ITOC(struct inode *inode)\n{\n\treturn list_entry(inode, struct coda_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"coda_fs_i.h\"",
            "#include <linux/fs.h>",
            "#include <linux/types.h>",
            "#include <linux/wait.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_fs_i.h\"\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic inline struct coda_inode_info *ITOC(struct inode *inode)\n{\n\treturn list_entry(inode, struct coda_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\nstatic int coda_test_inode(struct inode *inode, void *data)\n{\n\tstruct CodaFid *fid = (struct CodaFid *)data;\n\tstruct coda_inode_info *cii = ITOC(inode);\n\treturn coda_fideq(&cii->c_fid, fid);\n}"
  },
  {
    "function_name": "coda_fill_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cnode.c",
    "lines": "26-42",
    "snippet": "static void coda_fill_inode(struct inode *inode, struct coda_vattr *attr)\n{\n        coda_vattr_to_iattr(inode, attr);\n\n        if (S_ISREG(inode->i_mode)) {\n                inode->i_op = &coda_file_inode_operations;\n                inode->i_fop = &coda_file_operations;\n        } else if (S_ISDIR(inode->i_mode)) {\n                inode->i_op = &coda_dir_inode_operations;\n                inode->i_fop = &coda_dir_operations;\n        } else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &coda_symlink_inode_operations;\n\t\tinode->i_data.a_ops = &coda_symlink_aops;\n\t\tinode->i_mapping = &inode->i_data;\n\t} else\n                init_special_inode(inode, inode->i_mode, huge_decode_dev(attr->va_rdev));\n}",
    "includes": [
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct inode_operations coda_symlink_inode_operations = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= page_follow_link_light,\n\t.put_link\t= page_put_link,\n\t.setattr\t= coda_setattr,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_special_inode",
          "args": [
            "inode",
            "inode->i_mode",
            "huge_decode_dev(attr->va_rdev)"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "init_special_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1854-1871",
          "snippet": "void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_decode_dev",
          "args": [
            "attr->va_rdev"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "coda_vattr_to_iattr",
          "args": [
            "inode",
            "attr"
          ],
          "line": 28
        },
        "resolved": true,
        "details": {
          "function_name": "coda_vattr_to_iattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/coda_linux.c",
          "lines": "70-112",
          "snippet": "void coda_vattr_to_iattr(struct inode *inode, struct coda_vattr *attr)\n{\n        int inode_type;\n        /* inode's i_flags, i_ino are set by iget \n           XXX: is this all we need ??\n           */\n        switch (attr->va_type) {\n        case C_VNON:\n                inode_type  = 0;\n                break;\n        case C_VREG:\n                inode_type = S_IFREG;\n                break;\n        case C_VDIR:\n                inode_type = S_IFDIR;\n                break;\n        case C_VLNK:\n                inode_type = S_IFLNK;\n                break;\n        default:\n                inode_type = 0;\n        }\n\tinode->i_mode |= inode_type;\n\n\tif (attr->va_mode != (u_short) -1)\n\t        inode->i_mode = attr->va_mode | inode_type;\n        if (attr->va_uid != -1) \n\t        inode->i_uid = make_kuid(&init_user_ns, (uid_t) attr->va_uid);\n        if (attr->va_gid != -1)\n\t        inode->i_gid = make_kgid(&init_user_ns, (gid_t) attr->va_gid);\n\tif (attr->va_nlink != -1)\n\t\tset_nlink(inode, attr->va_nlink);\n\tif (attr->va_size != -1)\n\t        inode->i_size = attr->va_size;\n\tif (attr->va_size != -1)\n\t\tinode->i_blocks = (attr->va_size + 511) >> 9;\n\tif (attr->va_atime.tv_sec != -1) \n\t        inode->i_atime = attr->va_atime;\n\tif (attr->va_mtime.tv_sec != -1)\n\t        inode->i_mtime = attr->va_mtime;\n        if (attr->va_ctime.tv_sec != -1)\n\t        inode->i_ctime = attr->va_ctime;\n}",
          "includes": [
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid coda_vattr_to_iattr(struct inode *inode, struct coda_vattr *attr)\n{\n        int inode_type;\n        /* inode's i_flags, i_ino are set by iget \n           XXX: is this all we need ??\n           */\n        switch (attr->va_type) {\n        case C_VNON:\n                inode_type  = 0;\n                break;\n        case C_VREG:\n                inode_type = S_IFREG;\n                break;\n        case C_VDIR:\n                inode_type = S_IFDIR;\n                break;\n        case C_VLNK:\n                inode_type = S_IFLNK;\n                break;\n        default:\n                inode_type = 0;\n        }\n\tinode->i_mode |= inode_type;\n\n\tif (attr->va_mode != (u_short) -1)\n\t        inode->i_mode = attr->va_mode | inode_type;\n        if (attr->va_uid != -1) \n\t        inode->i_uid = make_kuid(&init_user_ns, (uid_t) attr->va_uid);\n        if (attr->va_gid != -1)\n\t        inode->i_gid = make_kgid(&init_user_ns, (gid_t) attr->va_gid);\n\tif (attr->va_nlink != -1)\n\t\tset_nlink(inode, attr->va_nlink);\n\tif (attr->va_size != -1)\n\t        inode->i_size = attr->va_size;\n\tif (attr->va_size != -1)\n\t\tinode->i_blocks = (attr->va_size + 511) >> 9;\n\tif (attr->va_atime.tv_sec != -1) \n\t        inode->i_atime = attr->va_atime;\n\tif (attr->va_mtime.tv_sec != -1)\n\t        inode->i_mtime = attr->va_mtime;\n        if (attr->va_ctime.tv_sec != -1)\n\t        inode->i_ctime = attr->va_ctime;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\nstatic const struct inode_operations coda_symlink_inode_operations = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= page_follow_link_light,\n\t.put_link\t= page_put_link,\n\t.setattr\t= coda_setattr,\n};\n\nstatic void coda_fill_inode(struct inode *inode, struct coda_vattr *attr)\n{\n        coda_vattr_to_iattr(inode, attr);\n\n        if (S_ISREG(inode->i_mode)) {\n                inode->i_op = &coda_file_inode_operations;\n                inode->i_fop = &coda_file_operations;\n        } else if (S_ISDIR(inode->i_mode)) {\n                inode->i_op = &coda_dir_inode_operations;\n                inode->i_fop = &coda_dir_operations;\n        } else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &coda_symlink_inode_operations;\n\t\tinode->i_data.a_ops = &coda_symlink_aops;\n\t\tinode->i_mapping = &inode->i_data;\n\t} else\n                init_special_inode(inode, inode->i_mode, huge_decode_dev(attr->va_rdev));\n}"
  },
  {
    "function_name": "coda_fideq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cnode.c",
    "lines": "13-16",
    "snippet": "static inline int coda_fideq(struct CodaFid *fid1, struct CodaFid *fid2)\n{\n\treturn memcmp(fid1, fid2, sizeof(*fid1)) == 0;\n}",
    "includes": [
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "fid1",
            "fid2",
            "sizeof(*fid1)"
          ],
          "line": 15
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\nstatic inline int coda_fideq(struct CodaFid *fid1, struct CodaFid *fid2)\n{\n\treturn memcmp(fid1, fid2, sizeof(*fid1)) == 0;\n}"
  }
]