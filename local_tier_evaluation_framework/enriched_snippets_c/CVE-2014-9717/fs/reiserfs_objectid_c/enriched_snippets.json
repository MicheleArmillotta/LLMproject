[
  {
    "function_name": "reiserfs_convert_objectid_map_v1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/objectid.c",
    "lines": "179-217",
    "snippet": "int reiserfs_convert_objectid_map_v1(struct super_block *s)\n{\n\tstruct reiserfs_super_block *disk_sb = SB_DISK_SUPER_BLOCK(s);\n\tint cur_size = sb_oid_cursize(disk_sb);\n\tint new_size = (s->s_blocksize - SB_SIZE) / sizeof(__u32) / 2 * 2;\n\tint old_max = sb_oid_maxsize(disk_sb);\n\tstruct reiserfs_super_block_v1 *disk_sb_v1;\n\t__le32 *objectid_map, *new_objectid_map;\n\tint i;\n\n\tdisk_sb_v1 =\n\t    (struct reiserfs_super_block_v1 *)(SB_BUFFER_WITH_SB(s)->b_data);\n\tobjectid_map = (__le32 *) (disk_sb_v1 + 1);\n\tnew_objectid_map = (__le32 *) (disk_sb + 1);\n\n\tif (cur_size > new_size) {\n\t\t/*\n\t\t * mark everyone used that was listed as free at\n\t\t * the end of the objectid map\n\t\t */\n\t\tobjectid_map[new_size - 1] = objectid_map[cur_size - 1];\n\t\tset_sb_oid_cursize(disk_sb, new_size);\n\t}\n\t/* move the smaller objectid map past the end of the new super */\n\tfor (i = new_size - 1; i >= 0; i--) {\n\t\tobjectid_map[i + (old_max - new_size)] = objectid_map[i];\n\t}\n\n\t/* set the max size so we don't overflow later */\n\tset_sb_oid_maxsize(disk_sb, new_size);\n\n\t/* Zero out label and generate random UUID */\n\tmemset(disk_sb->s_label, 0, sizeof(disk_sb->s_label));\n\tgenerate_random_uuid(disk_sb->s_uuid);\n\n\t/* finally, zero out the unused chunk of the new super */\n\tmemset(disk_sb->s_unused, 0, sizeof(disk_sb->s_unused));\n\treturn 0;\n}",
    "includes": [
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/random.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "disk_sb->s_unused",
            "0",
            "sizeof(disk_sb->s_unused)"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generate_random_uuid",
          "args": [
            "disk_sb->s_uuid"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "disk_sb->s_label",
            "0",
            "sizeof(disk_sb->s_label)"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_sb_oid_maxsize",
          "args": [
            "disk_sb",
            "new_size"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_sb_oid_cursize",
          "args": [
            "disk_sb",
            "new_size"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_BUFFER_WITH_SB",
          "args": [
            "s"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_oid_maxsize",
          "args": [
            "disk_sb"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_oid_cursize",
          "args": [
            "disk_sb"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_DISK_SUPER_BLOCK",
          "args": [
            "s"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/random.h>\n#include <linux/string.h>\n\nint reiserfs_convert_objectid_map_v1(struct super_block *s)\n{\n\tstruct reiserfs_super_block *disk_sb = SB_DISK_SUPER_BLOCK(s);\n\tint cur_size = sb_oid_cursize(disk_sb);\n\tint new_size = (s->s_blocksize - SB_SIZE) / sizeof(__u32) / 2 * 2;\n\tint old_max = sb_oid_maxsize(disk_sb);\n\tstruct reiserfs_super_block_v1 *disk_sb_v1;\n\t__le32 *objectid_map, *new_objectid_map;\n\tint i;\n\n\tdisk_sb_v1 =\n\t    (struct reiserfs_super_block_v1 *)(SB_BUFFER_WITH_SB(s)->b_data);\n\tobjectid_map = (__le32 *) (disk_sb_v1 + 1);\n\tnew_objectid_map = (__le32 *) (disk_sb + 1);\n\n\tif (cur_size > new_size) {\n\t\t/*\n\t\t * mark everyone used that was listed as free at\n\t\t * the end of the objectid map\n\t\t */\n\t\tobjectid_map[new_size - 1] = objectid_map[cur_size - 1];\n\t\tset_sb_oid_cursize(disk_sb, new_size);\n\t}\n\t/* move the smaller objectid map past the end of the new super */\n\tfor (i = new_size - 1; i >= 0; i--) {\n\t\tobjectid_map[i + (old_max - new_size)] = objectid_map[i];\n\t}\n\n\t/* set the max size so we don't overflow later */\n\tset_sb_oid_maxsize(disk_sb, new_size);\n\n\t/* Zero out label and generate random UUID */\n\tmemset(disk_sb->s_label, 0, sizeof(disk_sb->s_label));\n\tgenerate_random_uuid(disk_sb->s_uuid);\n\n\t/* finally, zero out the unused chunk of the new super */\n\tmemset(disk_sb->s_unused, 0, sizeof(disk_sb->s_unused));\n\treturn 0;\n}"
  },
  {
    "function_name": "reiserfs_release_objectid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/objectid.c",
    "lines": "97-177",
    "snippet": "void reiserfs_release_objectid(struct reiserfs_transaction_handle *th,\n\t\t\t       __u32 objectid_to_release)\n{\n\tstruct super_block *s = th->t_super;\n\tstruct reiserfs_super_block *rs = SB_DISK_SUPER_BLOCK(s);\n\t__le32 *map = objectid_map(s, rs);\n\tint i = 0;\n\n\tBUG_ON(!th->t_trans_id);\n\t/*return; */\n\tcheck_objectid_map(s, map);\n\n\treiserfs_prepare_for_journal(s, SB_BUFFER_WITH_SB(s), 1);\n\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(s));\n\n\t/*\n\t * start at the beginning of the objectid map (i = 0) and go to\n\t * the end of it (i = disk_sb->s_oid_cursize).  Linear search is\n\t * what we use, though it is possible that binary search would be\n\t * more efficient after performing lots of deletions (which is\n\t * when oids is large.)  We only check even i's.\n\t */\n\twhile (i < sb_oid_cursize(rs)) {\n\t\tif (objectid_to_release == le32_to_cpu(map[i])) {\n\t\t\t/* This incrementation unallocates the objectid. */\n\t\t\tle32_add_cpu(&map[i], 1);\n\n\t\t\t/*\n\t\t\t * Did we unallocate the last member of an\n\t\t\t * odd sequence, and can shrink oids?\n\t\t\t */\n\t\t\tif (map[i] == map[i + 1]) {\n\t\t\t\t/* shrink objectid map */\n\t\t\t\tmemmove(map + i, map + i + 2,\n\t\t\t\t\t(sb_oid_cursize(rs) - i -\n\t\t\t\t\t 2) * sizeof(__u32));\n\t\t\t\tset_sb_oid_cursize(rs, sb_oid_cursize(rs) - 2);\n\n\t\t\t\tRFALSE(sb_oid_cursize(rs) < 2 ||\n\t\t\t\t       sb_oid_cursize(rs) > sb_oid_maxsize(rs),\n\t\t\t\t       \"vs-15005: objectid map corrupted cur_size == %d (max == %d)\",\n\t\t\t\t       sb_oid_cursize(rs), sb_oid_maxsize(rs));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (objectid_to_release > le32_to_cpu(map[i]) &&\n\t\t    objectid_to_release < le32_to_cpu(map[i + 1])) {\n\t\t\t/* size of objectid map is not changed */\n\t\t\tif (objectid_to_release + 1 == le32_to_cpu(map[i + 1])) {\n\t\t\t\tle32_add_cpu(&map[i + 1], -1);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * JDM comparing two little-endian values for\n\t\t\t * equality -- safe\n\t\t\t */\n\t\t\t/*\n\t\t\t * objectid map must be expanded, but\n\t\t\t * there is no space\n\t\t\t */\n\t\t\tif (sb_oid_cursize(rs) == sb_oid_maxsize(rs)) {\n\t\t\t\tPROC_INFO_INC(s, leaked_oid);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/* expand the objectid map */\n\t\t\tmemmove(map + i + 3, map + i + 1,\n\t\t\t\t(sb_oid_cursize(rs) - i - 1) * sizeof(__u32));\n\t\t\tmap[i + 1] = cpu_to_le32(objectid_to_release);\n\t\t\tmap[i + 2] = cpu_to_le32(objectid_to_release + 1);\n\t\t\tset_sb_oid_cursize(rs, sb_oid_cursize(rs) + 2);\n\t\t\treturn;\n\t\t}\n\t\ti += 2;\n\t}\n\n\treiserfs_error(s, \"vs-15011\", \"tried to free free object id (%lu)\",\n\t\t       (long unsigned)objectid_to_release);\n}",
    "includes": [
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/random.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_error",
          "args": [
            "s",
            "\"vs-15011\"",
            "\"tried to free free object id (%lu)\"",
            "(long unsigned)objectid_to_release"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "374-397",
          "snippet": "void __reiserfs_error(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n\tBUG_ON(sb == NULL);\n\n\tif (reiserfs_error_panic(sb))\n\t\t__reiserfs_panic(sb, id, function, error_buf);\n\n\tif (id && id[0])\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s %s: %s\\n\",\n\t\t       sb->s_id, id, function, error_buf);\n\telse\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s: %s\\n\",\n\t\t       sb->s_id, function, error_buf);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\treiserfs_info(sb, \"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\treiserfs_abort_journal(sb, -EIO);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_error(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n\tBUG_ON(sb == NULL);\n\n\tif (reiserfs_error_panic(sb))\n\t\t__reiserfs_panic(sb, id, function, error_buf);\n\n\tif (id && id[0])\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s %s: %s\\n\",\n\t\t       sb->s_id, id, function, error_buf);\n\telse\n\t\tprintk(KERN_CRIT \"REISERFS error (device %s): %s: %s\\n\",\n\t\t       sb->s_id, function, error_buf);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\treiserfs_info(sb, \"Remounting filesystem read-only\\n\");\n\tsb->s_flags |= MS_RDONLY;\n\treiserfs_abort_journal(sb, -EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_sb_oid_cursize",
          "args": [
            "rs",
            "sb_oid_cursize(rs) + 2"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_oid_cursize",
          "args": [
            "rs"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "objectid_to_release + 1"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "objectid_to_release"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "map + i + 3",
            "map + i + 1",
            "(sb_oid_cursize(rs) - i - 1) * sizeof(__u32)"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_oid_cursize",
          "args": [
            "rs"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROC_INFO_INC",
          "args": [
            "s",
            "leaked_oid"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_oid_maxsize",
          "args": [
            "rs"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_oid_cursize",
          "args": [
            "rs"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&map[i + 1]",
            "-1"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "map[i + 1]"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RFALSE",
          "args": [
            "sb_oid_cursize(rs) < 2 ||\n\t\t\t\t       sb_oid_cursize(rs) > sb_oid_maxsize(rs)",
            "\"vs-15005: objectid map corrupted cur_size == %d (max == %d)\"",
            "sb_oid_cursize(rs)",
            "sb_oid_maxsize(rs)"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_oid_maxsize",
          "args": [
            "rs"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_oid_cursize",
          "args": [
            "rs"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_oid_maxsize",
          "args": [
            "rs"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_oid_cursize",
          "args": [
            "rs"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_oid_cursize",
          "args": [
            "rs"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_sb_oid_cursize",
          "args": [
            "rs",
            "sb_oid_cursize(rs) - 2"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_oid_cursize",
          "args": [
            "rs"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "map + i",
            "map + i + 2",
            "(sb_oid_cursize(rs) - i -\n\t\t\t\t\t 2) * sizeof(__u32)"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_oid_cursize",
          "args": [
            "rs"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&map[i]",
            "1"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_oid_cursize",
          "args": [
            "rs"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_mark_dirty",
          "args": [
            "th",
            "SB_BUFFER_WITH_SB(s)"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "journal_mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3274-3379",
          "snippet": "int journal_mark_dirty(struct reiserfs_transaction_handle *th,\n\t\t       struct buffer_head *bh)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tint count_already_incd = 0;\n\tint prepared = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tPROC_INFO_INC(sb, journal.mark_dirty);\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tprepared = test_clear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n\t/* already in this transaction, we are done */\n\tif (buffer_journaled(bh)) {\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_already);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * this must be turned into a panic instead of a warning.  We can't\n\t * allow a dirty or journal_dirty or locked buffer to be logged, as\n\t * some changes could get to disk too early.  NOT GOOD.\n\t */\n\tif (!prepared || buffer_dirty(bh)) {\n\t\treiserfs_warning(sb, \"journal-1777\",\n\t\t\t\t \"buffer %llu bad state \"\n\t\t\t\t \"%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t prepared ? ' ' : '!',\n\t\t\t\t buffer_locked(bh) ? ' ' : '!',\n\t\t\t\t buffer_dirty(bh) ? ' ' : '!',\n\t\t\t\t buffer_journal_dirty(bh) ? ' ' : '!');\n\t}\n\n\tif (atomic_read(&journal->j_wcount) <= 0) {\n\t\treiserfs_warning(sb, \"journal-1409\",\n\t\t\t\t \"returning because j_wcount was %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t\treturn 1;\n\t}\n\t/*\n\t * this error means I've screwed up, and we've overflowed\n\t * the transaction.  Nothing can be done here, except make the\n\t * FS readonly or panic.\n\t */\n\tif (journal->j_len >= journal->j_trans_max) {\n\t\treiserfs_panic(th->t_super, \"journal-1413\",\n\t\t\t       \"j_len (%lu) is too big\",\n\t\t\t       journal->j_len);\n\t}\n\n\tif (buffer_journal_dirty(bh)) {\n\t\tcount_already_incd = 1;\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_notjournal);\n\t\tclear_buffer_journal_dirty(bh);\n\t}\n\n\tif (journal->j_len > journal->j_len_alloc) {\n\t\tjournal->j_len_alloc = journal->j_len + JOURNAL_PER_BALANCE_CNT;\n\t}\n\n\tset_buffer_journaled(bh);\n\n\t/* now put this guy on the end */\n\tif (!cn) {\n\t\tcn = get_cnode(sb);\n\t\tif (!cn) {\n\t\t\treiserfs_panic(sb, \"journal-4\", \"get_cnode failed!\");\n\t\t}\n\n\t\tif (th->t_blocks_logged == th->t_blocks_allocated) {\n\t\t\tth->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT;\n\t\t\tjournal->j_len_alloc += JOURNAL_PER_BALANCE_CNT;\n\t\t}\n\t\tth->t_blocks_logged++;\n\t\tjournal->j_len++;\n\n\t\tcn->bh = bh;\n\t\tcn->blocknr = bh->b_blocknr;\n\t\tcn->sb = sb;\n\t\tcn->jlist = NULL;\n\t\tinsert_journal_hash(journal->j_hash_table, cn);\n\t\tif (!count_already_incd) {\n\t\t\tget_bh(bh);\n\t\t}\n\t}\n\tcn->next = NULL;\n\tcn->prev = journal->j_last;\n\tcn->bh = bh;\n\tif (journal->j_last) {\n\t\tjournal->j_last->next = cn;\n\t\tjournal->j_last = cn;\n\t} else {\n\t\tjournal->j_first = cn;\n\t\tjournal->j_last = cn;\n\t}\n\treiserfs_schedule_old_flush(sb);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_mark_dirty(struct reiserfs_transaction_handle *th,\n\t\t       struct buffer_head *bh)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tint count_already_incd = 0;\n\tint prepared = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tPROC_INFO_INC(sb, journal.mark_dirty);\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tprepared = test_clear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n\t/* already in this transaction, we are done */\n\tif (buffer_journaled(bh)) {\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_already);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * this must be turned into a panic instead of a warning.  We can't\n\t * allow a dirty or journal_dirty or locked buffer to be logged, as\n\t * some changes could get to disk too early.  NOT GOOD.\n\t */\n\tif (!prepared || buffer_dirty(bh)) {\n\t\treiserfs_warning(sb, \"journal-1777\",\n\t\t\t\t \"buffer %llu bad state \"\n\t\t\t\t \"%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t prepared ? ' ' : '!',\n\t\t\t\t buffer_locked(bh) ? ' ' : '!',\n\t\t\t\t buffer_dirty(bh) ? ' ' : '!',\n\t\t\t\t buffer_journal_dirty(bh) ? ' ' : '!');\n\t}\n\n\tif (atomic_read(&journal->j_wcount) <= 0) {\n\t\treiserfs_warning(sb, \"journal-1409\",\n\t\t\t\t \"returning because j_wcount was %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t\treturn 1;\n\t}\n\t/*\n\t * this error means I've screwed up, and we've overflowed\n\t * the transaction.  Nothing can be done here, except make the\n\t * FS readonly or panic.\n\t */\n\tif (journal->j_len >= journal->j_trans_max) {\n\t\treiserfs_panic(th->t_super, \"journal-1413\",\n\t\t\t       \"j_len (%lu) is too big\",\n\t\t\t       journal->j_len);\n\t}\n\n\tif (buffer_journal_dirty(bh)) {\n\t\tcount_already_incd = 1;\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_notjournal);\n\t\tclear_buffer_journal_dirty(bh);\n\t}\n\n\tif (journal->j_len > journal->j_len_alloc) {\n\t\tjournal->j_len_alloc = journal->j_len + JOURNAL_PER_BALANCE_CNT;\n\t}\n\n\tset_buffer_journaled(bh);\n\n\t/* now put this guy on the end */\n\tif (!cn) {\n\t\tcn = get_cnode(sb);\n\t\tif (!cn) {\n\t\t\treiserfs_panic(sb, \"journal-4\", \"get_cnode failed!\");\n\t\t}\n\n\t\tif (th->t_blocks_logged == th->t_blocks_allocated) {\n\t\t\tth->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT;\n\t\t\tjournal->j_len_alloc += JOURNAL_PER_BALANCE_CNT;\n\t\t}\n\t\tth->t_blocks_logged++;\n\t\tjournal->j_len++;\n\n\t\tcn->bh = bh;\n\t\tcn->blocknr = bh->b_blocknr;\n\t\tcn->sb = sb;\n\t\tcn->jlist = NULL;\n\t\tinsert_journal_hash(journal->j_hash_table, cn);\n\t\tif (!count_already_incd) {\n\t\t\tget_bh(bh);\n\t\t}\n\t}\n\tcn->next = NULL;\n\tcn->prev = journal->j_last;\n\tcn->bh = bh;\n\tif (journal->j_last) {\n\t\tjournal->j_last->next = cn;\n\t\tjournal->j_last = cn;\n\t} else {\n\t\tjournal->j_first = cn;\n\t\tjournal->j_last = cn;\n\t}\n\treiserfs_schedule_old_flush(sb);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_BUFFER_WITH_SB",
          "args": [
            "s"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_prepare_for_journal",
          "args": [
            "s",
            "SB_BUFFER_WITH_SB(s)",
            "1"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_prepare_for_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3951-3968",
          "snippet": "int reiserfs_prepare_for_journal(struct super_block *sb,\n\t\t\t\t struct buffer_head *bh, int wait)\n{\n\tPROC_INFO_INC(sb, journal.prepare);\n\n\tif (!trylock_buffer(bh)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\tlock_buffer(bh);\n\t}\n\tset_buffer_journal_prepared(bh);\n\tif (test_clear_buffer_dirty(bh) && buffer_journal_dirty(bh)) {\n\t\tclear_buffer_journal_test(bh);\n\t\tset_buffer_journal_restore_dirty(bh);\n\t}\n\tunlock_buffer(bh);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint reiserfs_prepare_for_journal(struct super_block *sb,\n\t\t\t\t struct buffer_head *bh, int wait)\n{\n\tPROC_INFO_INC(sb, journal.prepare);\n\n\tif (!trylock_buffer(bh)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\tlock_buffer(bh);\n\t}\n\tset_buffer_journal_prepared(bh);\n\tif (test_clear_buffer_dirty(bh) && buffer_journal_dirty(bh)) {\n\t\tclear_buffer_journal_test(bh);\n\t\tset_buffer_journal_restore_dirty(bh);\n\t}\n\tunlock_buffer(bh);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_BUFFER_WITH_SB",
          "args": [
            "s"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_objectid_map",
          "args": [
            "s",
            "map"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "check_objectid_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/objectid.c",
          "lines": "27-29",
          "snippet": "static void check_objectid_map(struct super_block *s, __le32 * map)\n{;\n}",
          "includes": [
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/random.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/random.h>\n#include <linux/string.h>\n\nstatic void check_objectid_map(struct super_block *s, __le32 * map)\n{;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!th->t_trans_id"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_DISK_SUPER_BLOCK",
          "args": [
            "s"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/random.h>\n#include <linux/string.h>\n\nvoid reiserfs_release_objectid(struct reiserfs_transaction_handle *th,\n\t\t\t       __u32 objectid_to_release)\n{\n\tstruct super_block *s = th->t_super;\n\tstruct reiserfs_super_block *rs = SB_DISK_SUPER_BLOCK(s);\n\t__le32 *map = objectid_map(s, rs);\n\tint i = 0;\n\n\tBUG_ON(!th->t_trans_id);\n\t/*return; */\n\tcheck_objectid_map(s, map);\n\n\treiserfs_prepare_for_journal(s, SB_BUFFER_WITH_SB(s), 1);\n\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(s));\n\n\t/*\n\t * start at the beginning of the objectid map (i = 0) and go to\n\t * the end of it (i = disk_sb->s_oid_cursize).  Linear search is\n\t * what we use, though it is possible that binary search would be\n\t * more efficient after performing lots of deletions (which is\n\t * when oids is large.)  We only check even i's.\n\t */\n\twhile (i < sb_oid_cursize(rs)) {\n\t\tif (objectid_to_release == le32_to_cpu(map[i])) {\n\t\t\t/* This incrementation unallocates the objectid. */\n\t\t\tle32_add_cpu(&map[i], 1);\n\n\t\t\t/*\n\t\t\t * Did we unallocate the last member of an\n\t\t\t * odd sequence, and can shrink oids?\n\t\t\t */\n\t\t\tif (map[i] == map[i + 1]) {\n\t\t\t\t/* shrink objectid map */\n\t\t\t\tmemmove(map + i, map + i + 2,\n\t\t\t\t\t(sb_oid_cursize(rs) - i -\n\t\t\t\t\t 2) * sizeof(__u32));\n\t\t\t\tset_sb_oid_cursize(rs, sb_oid_cursize(rs) - 2);\n\n\t\t\t\tRFALSE(sb_oid_cursize(rs) < 2 ||\n\t\t\t\t       sb_oid_cursize(rs) > sb_oid_maxsize(rs),\n\t\t\t\t       \"vs-15005: objectid map corrupted cur_size == %d (max == %d)\",\n\t\t\t\t       sb_oid_cursize(rs), sb_oid_maxsize(rs));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (objectid_to_release > le32_to_cpu(map[i]) &&\n\t\t    objectid_to_release < le32_to_cpu(map[i + 1])) {\n\t\t\t/* size of objectid map is not changed */\n\t\t\tif (objectid_to_release + 1 == le32_to_cpu(map[i + 1])) {\n\t\t\t\tle32_add_cpu(&map[i + 1], -1);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * JDM comparing two little-endian values for\n\t\t\t * equality -- safe\n\t\t\t */\n\t\t\t/*\n\t\t\t * objectid map must be expanded, but\n\t\t\t * there is no space\n\t\t\t */\n\t\t\tif (sb_oid_cursize(rs) == sb_oid_maxsize(rs)) {\n\t\t\t\tPROC_INFO_INC(s, leaked_oid);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/* expand the objectid map */\n\t\t\tmemmove(map + i + 3, map + i + 1,\n\t\t\t\t(sb_oid_cursize(rs) - i - 1) * sizeof(__u32));\n\t\t\tmap[i + 1] = cpu_to_le32(objectid_to_release);\n\t\t\tmap[i + 2] = cpu_to_le32(objectid_to_release + 1);\n\t\t\tset_sb_oid_cursize(rs, sb_oid_cursize(rs) + 2);\n\t\t\treturn;\n\t\t}\n\t\ti += 2;\n\t}\n\n\treiserfs_error(s, \"vs-15011\", \"tried to free free object id (%lu)\",\n\t\t       (long unsigned)objectid_to_release);\n}"
  },
  {
    "function_name": "reiserfs_get_unused_objectid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/objectid.c",
    "lines": "49-94",
    "snippet": "__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *s = th->t_super;\n\tstruct reiserfs_super_block *rs = SB_DISK_SUPER_BLOCK(s);\n\t__le32 *map = objectid_map(s, rs);\n\t__u32 unused_objectid;\n\n\tBUG_ON(!th->t_trans_id);\n\n\tcheck_objectid_map(s, map);\n\n\treiserfs_prepare_for_journal(s, SB_BUFFER_WITH_SB(s), 1);\n\t/* comment needed -Hans */\n\tunused_objectid = le32_to_cpu(map[1]);\n\tif (unused_objectid == U32_MAX) {\n\t\treiserfs_warning(s, \"reiserfs-15100\", \"no more object ids\");\n\t\treiserfs_restore_prepared_buffer(s, SB_BUFFER_WITH_SB(s));\n\t\treturn 0;\n\t}\n\n\t/*\n\t * This incrementation allocates the first unused objectid. That\n\t * is to say, the first entry on the objectid map is the first\n\t * unused objectid, and by incrementing it we use it.  See below\n\t * where we check to see if we eliminated a sequence of unused\n\t * objectids....\n\t */\n\tmap[1] = cpu_to_le32(unused_objectid + 1);\n\n\t/*\n\t * Now we check to see if we eliminated the last remaining member of\n\t * the first even sequence (and can eliminate the sequence by\n\t * eliminating its last objectid from oids), and can collapse the\n\t * first two odd sequences into one sequence.  If so, then the net\n\t * result is to eliminate a pair of objectids from oids.  We do this\n\t * by shifting the entire map to the left.\n\t */\n\tif (sb_oid_cursize(rs) > 2 && map[1] == map[2]) {\n\t\tmemmove(map + 1, map + 3,\n\t\t\t(sb_oid_cursize(rs) - 3) * sizeof(__u32));\n\t\tset_sb_oid_cursize(rs, sb_oid_cursize(rs) - 2);\n\t}\n\n\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(s));\n\treturn unused_objectid;\n}",
    "includes": [
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/random.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_mark_dirty",
          "args": [
            "th",
            "SB_BUFFER_WITH_SB(s)"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "journal_mark_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3274-3379",
          "snippet": "int journal_mark_dirty(struct reiserfs_transaction_handle *th,\n\t\t       struct buffer_head *bh)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tint count_already_incd = 0;\n\tint prepared = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tPROC_INFO_INC(sb, journal.mark_dirty);\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tprepared = test_clear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n\t/* already in this transaction, we are done */\n\tif (buffer_journaled(bh)) {\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_already);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * this must be turned into a panic instead of a warning.  We can't\n\t * allow a dirty or journal_dirty or locked buffer to be logged, as\n\t * some changes could get to disk too early.  NOT GOOD.\n\t */\n\tif (!prepared || buffer_dirty(bh)) {\n\t\treiserfs_warning(sb, \"journal-1777\",\n\t\t\t\t \"buffer %llu bad state \"\n\t\t\t\t \"%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t prepared ? ' ' : '!',\n\t\t\t\t buffer_locked(bh) ? ' ' : '!',\n\t\t\t\t buffer_dirty(bh) ? ' ' : '!',\n\t\t\t\t buffer_journal_dirty(bh) ? ' ' : '!');\n\t}\n\n\tif (atomic_read(&journal->j_wcount) <= 0) {\n\t\treiserfs_warning(sb, \"journal-1409\",\n\t\t\t\t \"returning because j_wcount was %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t\treturn 1;\n\t}\n\t/*\n\t * this error means I've screwed up, and we've overflowed\n\t * the transaction.  Nothing can be done here, except make the\n\t * FS readonly or panic.\n\t */\n\tif (journal->j_len >= journal->j_trans_max) {\n\t\treiserfs_panic(th->t_super, \"journal-1413\",\n\t\t\t       \"j_len (%lu) is too big\",\n\t\t\t       journal->j_len);\n\t}\n\n\tif (buffer_journal_dirty(bh)) {\n\t\tcount_already_incd = 1;\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_notjournal);\n\t\tclear_buffer_journal_dirty(bh);\n\t}\n\n\tif (journal->j_len > journal->j_len_alloc) {\n\t\tjournal->j_len_alloc = journal->j_len + JOURNAL_PER_BALANCE_CNT;\n\t}\n\n\tset_buffer_journaled(bh);\n\n\t/* now put this guy on the end */\n\tif (!cn) {\n\t\tcn = get_cnode(sb);\n\t\tif (!cn) {\n\t\t\treiserfs_panic(sb, \"journal-4\", \"get_cnode failed!\");\n\t\t}\n\n\t\tif (th->t_blocks_logged == th->t_blocks_allocated) {\n\t\t\tth->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT;\n\t\t\tjournal->j_len_alloc += JOURNAL_PER_BALANCE_CNT;\n\t\t}\n\t\tth->t_blocks_logged++;\n\t\tjournal->j_len++;\n\n\t\tcn->bh = bh;\n\t\tcn->blocknr = bh->b_blocknr;\n\t\tcn->sb = sb;\n\t\tcn->jlist = NULL;\n\t\tinsert_journal_hash(journal->j_hash_table, cn);\n\t\tif (!count_already_incd) {\n\t\t\tget_bh(bh);\n\t\t}\n\t}\n\tcn->next = NULL;\n\tcn->prev = journal->j_last;\n\tcn->bh = bh;\n\tif (journal->j_last) {\n\t\tjournal->j_last->next = cn;\n\t\tjournal->j_last = cn;\n\t} else {\n\t\tjournal->j_first = cn;\n\t\tjournal->j_last = cn;\n\t}\n\treiserfs_schedule_old_flush(sb);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint journal_mark_dirty(struct reiserfs_transaction_handle *th,\n\t\t       struct buffer_head *bh)\n{\n\tstruct super_block *sb = th->t_super;\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tstruct reiserfs_journal_cnode *cn = NULL;\n\tint count_already_incd = 0;\n\tint prepared = 0;\n\tBUG_ON(!th->t_trans_id);\n\n\tPROC_INFO_INC(sb, journal.mark_dirty);\n\tif (th->t_trans_id != journal->j_trans_id) {\n\t\treiserfs_panic(th->t_super, \"journal-1577\",\n\t\t\t       \"handle trans id %ld != current trans id %ld\",\n\t\t\t       th->t_trans_id, journal->j_trans_id);\n\t}\n\n\tprepared = test_clear_buffer_journal_prepared(bh);\n\tclear_buffer_journal_restore_dirty(bh);\n\t/* already in this transaction, we are done */\n\tif (buffer_journaled(bh)) {\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_already);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * this must be turned into a panic instead of a warning.  We can't\n\t * allow a dirty or journal_dirty or locked buffer to be logged, as\n\t * some changes could get to disk too early.  NOT GOOD.\n\t */\n\tif (!prepared || buffer_dirty(bh)) {\n\t\treiserfs_warning(sb, \"journal-1777\",\n\t\t\t\t \"buffer %llu bad state \"\n\t\t\t\t \"%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\",\n\t\t\t\t (unsigned long long)bh->b_blocknr,\n\t\t\t\t prepared ? ' ' : '!',\n\t\t\t\t buffer_locked(bh) ? ' ' : '!',\n\t\t\t\t buffer_dirty(bh) ? ' ' : '!',\n\t\t\t\t buffer_journal_dirty(bh) ? ' ' : '!');\n\t}\n\n\tif (atomic_read(&journal->j_wcount) <= 0) {\n\t\treiserfs_warning(sb, \"journal-1409\",\n\t\t\t\t \"returning because j_wcount was %d\",\n\t\t\t\t atomic_read(&journal->j_wcount));\n\t\treturn 1;\n\t}\n\t/*\n\t * this error means I've screwed up, and we've overflowed\n\t * the transaction.  Nothing can be done here, except make the\n\t * FS readonly or panic.\n\t */\n\tif (journal->j_len >= journal->j_trans_max) {\n\t\treiserfs_panic(th->t_super, \"journal-1413\",\n\t\t\t       \"j_len (%lu) is too big\",\n\t\t\t       journal->j_len);\n\t}\n\n\tif (buffer_journal_dirty(bh)) {\n\t\tcount_already_incd = 1;\n\t\tPROC_INFO_INC(sb, journal.mark_dirty_notjournal);\n\t\tclear_buffer_journal_dirty(bh);\n\t}\n\n\tif (journal->j_len > journal->j_len_alloc) {\n\t\tjournal->j_len_alloc = journal->j_len + JOURNAL_PER_BALANCE_CNT;\n\t}\n\n\tset_buffer_journaled(bh);\n\n\t/* now put this guy on the end */\n\tif (!cn) {\n\t\tcn = get_cnode(sb);\n\t\tif (!cn) {\n\t\t\treiserfs_panic(sb, \"journal-4\", \"get_cnode failed!\");\n\t\t}\n\n\t\tif (th->t_blocks_logged == th->t_blocks_allocated) {\n\t\t\tth->t_blocks_allocated += JOURNAL_PER_BALANCE_CNT;\n\t\t\tjournal->j_len_alloc += JOURNAL_PER_BALANCE_CNT;\n\t\t}\n\t\tth->t_blocks_logged++;\n\t\tjournal->j_len++;\n\n\t\tcn->bh = bh;\n\t\tcn->blocknr = bh->b_blocknr;\n\t\tcn->sb = sb;\n\t\tcn->jlist = NULL;\n\t\tinsert_journal_hash(journal->j_hash_table, cn);\n\t\tif (!count_already_incd) {\n\t\t\tget_bh(bh);\n\t\t}\n\t}\n\tcn->next = NULL;\n\tcn->prev = journal->j_last;\n\tcn->bh = bh;\n\tif (journal->j_last) {\n\t\tjournal->j_last->next = cn;\n\t\tjournal->j_last = cn;\n\t} else {\n\t\tjournal->j_first = cn;\n\t\tjournal->j_last = cn;\n\t}\n\treiserfs_schedule_old_flush(sb);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_BUFFER_WITH_SB",
          "args": [
            "s"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_sb_oid_cursize",
          "args": [
            "rs",
            "sb_oid_cursize(rs) - 2"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_oid_cursize",
          "args": [
            "rs"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "map + 1",
            "map + 3",
            "(sb_oid_cursize(rs) - 3) * sizeof(__u32)"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_oid_cursize",
          "args": [
            "rs"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_oid_cursize",
          "args": [
            "rs"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "unused_objectid + 1"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_restore_prepared_buffer",
          "args": [
            "s",
            "SB_BUFFER_WITH_SB(s)"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_restore_prepared_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3920-3942",
          "snippet": "void reiserfs_restore_prepared_buffer(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tPROC_INFO_INC(sb, journal.restore_prepared);\n\tif (!bh) {\n\t\treturn;\n\t}\n\tif (test_clear_buffer_journal_restore_dirty(bh) &&\n\t    buffer_journal_dirty(bh)) {\n\t\tstruct reiserfs_journal_cnode *cn;\n\t\treiserfs_write_lock(sb);\n\t\tcn = get_journal_hash_dev(sb,\n\t\t\t\t\t  journal->j_list_hash_table,\n\t\t\t\t\t  bh->b_blocknr);\n\t\tif (cn && can_dirty(cn)) {\n\t\t\tset_buffer_journal_test(bh);\n\t\t\tmark_buffer_dirty(bh);\n\t\t}\n\t\treiserfs_write_unlock(sb);\n\t}\n\tclear_buffer_journal_prepared(bh);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int can_dirty(struct reiserfs_journal_cnode *cn);",
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int can_dirty(struct reiserfs_journal_cnode *cn);\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nvoid reiserfs_restore_prepared_buffer(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh)\n{\n\tstruct reiserfs_journal *journal = SB_JOURNAL(sb);\n\tPROC_INFO_INC(sb, journal.restore_prepared);\n\tif (!bh) {\n\t\treturn;\n\t}\n\tif (test_clear_buffer_journal_restore_dirty(bh) &&\n\t    buffer_journal_dirty(bh)) {\n\t\tstruct reiserfs_journal_cnode *cn;\n\t\treiserfs_write_lock(sb);\n\t\tcn = get_journal_hash_dev(sb,\n\t\t\t\t\t  journal->j_list_hash_table,\n\t\t\t\t\t  bh->b_blocknr);\n\t\tif (cn && can_dirty(cn)) {\n\t\t\tset_buffer_journal_test(bh);\n\t\t\tmark_buffer_dirty(bh);\n\t\t}\n\t\treiserfs_write_unlock(sb);\n\t}\n\tclear_buffer_journal_prepared(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_BUFFER_WITH_SB",
          "args": [
            "s"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_warning",
          "args": [
            "s",
            "\"reiserfs-15100\"",
            "\"no more object ids\""
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "map[1]"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_prepare_for_journal",
          "args": [
            "s",
            "SB_BUFFER_WITH_SB(s)",
            "1"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_prepare_for_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/journal.c",
          "lines": "3951-3968",
          "snippet": "int reiserfs_prepare_for_journal(struct super_block *sb,\n\t\t\t\t struct buffer_head *bh, int wait)\n{\n\tPROC_INFO_INC(sb, journal.prepare);\n\n\tif (!trylock_buffer(bh)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\tlock_buffer(bh);\n\t}\n\tset_buffer_journal_prepared(bh);\n\tif (test_clear_buffer_dirty(bh) && buffer_journal_dirty(bh)) {\n\t\tclear_buffer_journal_test(bh);\n\t\tset_buffer_journal_restore_dirty(bh);\n\t}\n\tunlock_buffer(bh);\n\treturn 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);",
            "static void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include \"reiserfs.h\"\n#include <linux/vmalloc.h>\n#include <linux/semaphore.h>\n#include <linux/time.h>\n\nstatic int journal_join(struct reiserfs_transaction_handle *th,\n\t\t\tstruct super_block *sb);\nstatic void release_journal_dev(struct super_block *super,\n\t\t\t       struct reiserfs_journal *journal);\n\nint reiserfs_prepare_for_journal(struct super_block *sb,\n\t\t\t\t struct buffer_head *bh, int wait)\n{\n\tPROC_INFO_INC(sb, journal.prepare);\n\n\tif (!trylock_buffer(bh)) {\n\t\tif (!wait)\n\t\t\treturn 0;\n\t\tlock_buffer(bh);\n\t}\n\tset_buffer_journal_prepared(bh);\n\tif (test_clear_buffer_dirty(bh) && buffer_journal_dirty(bh)) {\n\t\tclear_buffer_journal_test(bh);\n\t\tset_buffer_journal_restore_dirty(bh);\n\t}\n\tunlock_buffer(bh);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SB_BUFFER_WITH_SB",
          "args": [
            "s"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_objectid_map",
          "args": [
            "s",
            "map"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "check_objectid_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/objectid.c",
          "lines": "27-29",
          "snippet": "static void check_objectid_map(struct super_block *s, __le32 * map)\n{;\n}",
          "includes": [
            "#include \"reiserfs.h\"",
            "#include <linux/time.h>",
            "#include <linux/random.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/random.h>\n#include <linux/string.h>\n\nstatic void check_objectid_map(struct super_block *s, __le32 * map)\n{;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!th->t_trans_id"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SB_DISK_SUPER_BLOCK",
          "args": [
            "s"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/random.h>\n#include <linux/string.h>\n\n__u32 reiserfs_get_unused_objectid(struct reiserfs_transaction_handle *th)\n{\n\tstruct super_block *s = th->t_super;\n\tstruct reiserfs_super_block *rs = SB_DISK_SUPER_BLOCK(s);\n\t__le32 *map = objectid_map(s, rs);\n\t__u32 unused_objectid;\n\n\tBUG_ON(!th->t_trans_id);\n\n\tcheck_objectid_map(s, map);\n\n\treiserfs_prepare_for_journal(s, SB_BUFFER_WITH_SB(s), 1);\n\t/* comment needed -Hans */\n\tunused_objectid = le32_to_cpu(map[1]);\n\tif (unused_objectid == U32_MAX) {\n\t\treiserfs_warning(s, \"reiserfs-15100\", \"no more object ids\");\n\t\treiserfs_restore_prepared_buffer(s, SB_BUFFER_WITH_SB(s));\n\t\treturn 0;\n\t}\n\n\t/*\n\t * This incrementation allocates the first unused objectid. That\n\t * is to say, the first entry on the objectid map is the first\n\t * unused objectid, and by incrementing it we use it.  See below\n\t * where we check to see if we eliminated a sequence of unused\n\t * objectids....\n\t */\n\tmap[1] = cpu_to_le32(unused_objectid + 1);\n\n\t/*\n\t * Now we check to see if we eliminated the last remaining member of\n\t * the first even sequence (and can eliminate the sequence by\n\t * eliminating its last objectid from oids), and can collapse the\n\t * first two odd sequences into one sequence.  If so, then the net\n\t * result is to eliminate a pair of objectids from oids.  We do this\n\t * by shifting the entire map to the left.\n\t */\n\tif (sb_oid_cursize(rs) > 2 && map[1] == map[2]) {\n\t\tmemmove(map + 1, map + 3,\n\t\t\t(sb_oid_cursize(rs) - 3) * sizeof(__u32));\n\t\tset_sb_oid_cursize(rs, sb_oid_cursize(rs) - 2);\n\t}\n\n\tjournal_mark_dirty(th, SB_BUFFER_WITH_SB(s));\n\treturn unused_objectid;\n}"
  },
  {
    "function_name": "check_objectid_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/objectid.c",
    "lines": "27-29",
    "snippet": "static void check_objectid_map(struct super_block *s, __le32 * map)\n{;\n}",
    "includes": [
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/random.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/random.h>\n#include <linux/string.h>\n\nstatic void check_objectid_map(struct super_block *s, __le32 * map)\n{;\n}"
  },
  {
    "function_name": "check_objectid_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/objectid.c",
    "lines": "17-24",
    "snippet": "static void check_objectid_map(struct super_block *s, __le32 * map)\n{\n\tif (le32_to_cpu(map[0]) != 1)\n\t\treiserfs_panic(s, \"vs-15010\", \"map corrupted: %lx\",\n\t\t\t       (long unsigned int)le32_to_cpu(map[0]));\n\n\t/* FIXME: add something else here */\n}",
    "includes": [
      "#include \"reiserfs.h\"",
      "#include <linux/time.h>",
      "#include <linux/random.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_panic",
          "args": [
            "s",
            "\"vs-15010\"",
            "\"map corrupted: %lx\"",
            "(long unsigned int)le32_to_cpu(map[0])"
          ],
          "line": 20
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "356-372",
          "snippet": "void __reiserfs_panic(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tdump_stack();\n#endif\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS panic (device %s): %s%s%s: %s\\n\",\n\t\t      sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t      function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS panic: %s%s%s: %s\\n\",\n\t\t      id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n\tBUG();\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid __reiserfs_panic(struct super_block *sb, const char *id,\n\t\t      const char *function, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\n#ifdef CONFIG_REISERFS_CHECK\n\tdump_stack();\n#endif\n\tif (sb)\n\t\tprintk(KERN_WARNING \"REISERFS panic (device %s): %s%s%s: %s\\n\",\n\t\t      sb->s_id, id ? id : \"\", id ? \" \" : \"\",\n\t\t      function, error_buf);\n\telse\n\t\tprintk(KERN_WARNING \"REISERFS panic: %s%s%s: %s\\n\",\n\t\t      id ? id : \"\", id ? \" \" : \"\", function, error_buf);\n\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "map[0]"
          ],
          "line": 21
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"reiserfs.h\"\n#include <linux/time.h>\n#include <linux/random.h>\n#include <linux/string.h>\n\nstatic void check_objectid_map(struct super_block *s, __le32 * map)\n{\n\tif (le32_to_cpu(map[0]) != 1)\n\t\treiserfs_panic(s, \"vs-15010\", \"map corrupted: %lx\",\n\t\t\t       (long unsigned int)le32_to_cpu(map[0]));\n\n\t/* FIXME: add something else here */\n}"
  }
]