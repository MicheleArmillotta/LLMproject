[
  {
    "function_name": "ext4_init_security",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr_security.c",
    "lines": "69-75",
    "snippet": "int\next4_init_security(handle_t *handle, struct inode *inode, struct inode *dir,\n\t\t   const struct qstr *qstr)\n{\n\treturn security_inode_init_security(inode, dir, qstr,\n\t\t\t\t\t    &ext4_initxattrs, handle);\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_inode_init_security",
          "args": [
            "inode",
            "dir",
            "qstr",
            "&ext4_initxattrs",
            "handle"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n\nint\next4_init_security(handle_t *handle, struct inode *inode, struct inode *dir,\n\t\t   const struct qstr *qstr)\n{\n\treturn security_inode_init_security(inode, dir, qstr,\n\t\t\t\t\t    &ext4_initxattrs, handle);\n}"
  },
  {
    "function_name": "ext4_initxattrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr_security.c",
    "lines": "50-67",
    "snippet": "static int\next4_initxattrs(struct inode *inode, const struct xattr *xattr_array,\n\t\tvoid *fs_info)\n{\n\tconst struct xattr *xattr;\n\thandle_t *handle = fs_info;\n\tint err = 0;\n\n\tfor (xattr = xattr_array; xattr->name != NULL; xattr++) {\n\t\terr = ext4_xattr_set_handle(handle, inode,\n\t\t\t\t\t    EXT4_XATTR_INDEX_SECURITY,\n\t\t\t\t\t    xattr->name, xattr->value,\n\t\t\t\t\t    xattr->value_len, 0);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_xattr_set_handle",
          "args": [
            "handle",
            "inode",
            "EXT4_XATTR_INDEX_SECURITY",
            "xattr->name",
            "xattr->value",
            "xattr->value_len",
            "0"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_set_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "1085-1191",
          "snippet": "int\next4_xattr_set_handle(handle_t *handle, struct inode *inode, int name_index,\n\t\t      const char *name, const void *value, size_t value_len,\n\t\t      int flags)\n{\n\tstruct ext4_xattr_info i = {\n\t\t.name_index = name_index,\n\t\t.name = name,\n\t\t.value = value,\n\t\t.value_len = value_len,\n\n\t};\n\tstruct ext4_xattr_ibody_find is = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tstruct ext4_xattr_block_find bs = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tunsigned long no_expand;\n\tint error;\n\n\tif (!name)\n\t\treturn -EINVAL;\n\tif (strlen(name) > 255)\n\t\treturn -ERANGE;\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\tno_expand = ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND);\n\text4_set_inode_state(inode, EXT4_STATE_NO_EXPAND);\n\n\terror = ext4_reserve_inode_write(handle, inode, &is.iloc);\n\tif (error)\n\t\tgoto cleanup;\n\n\tif (ext4_test_inode_state(inode, EXT4_STATE_NEW)) {\n\t\tstruct ext4_inode *raw_inode = ext4_raw_inode(&is.iloc);\n\t\tmemset(raw_inode, 0, EXT4_SB(inode->i_sb)->s_inode_size);\n\t\text4_clear_inode_state(inode, EXT4_STATE_NEW);\n\t}\n\n\terror = ext4_xattr_ibody_find(inode, &i, &is);\n\tif (error)\n\t\tgoto cleanup;\n\tif (is.s.not_found)\n\t\terror = ext4_xattr_block_find(inode, &i, &bs);\n\tif (error)\n\t\tgoto cleanup;\n\tif (is.s.not_found && bs.s.not_found) {\n\t\terror = -ENODATA;\n\t\tif (flags & XATTR_REPLACE)\n\t\t\tgoto cleanup;\n\t\terror = 0;\n\t\tif (!value)\n\t\t\tgoto cleanup;\n\t} else {\n\t\terror = -EEXIST;\n\t\tif (flags & XATTR_CREATE)\n\t\t\tgoto cleanup;\n\t}\n\tif (!value) {\n\t\tif (!is.s.not_found)\n\t\t\terror = ext4_xattr_ibody_set(handle, inode, &i, &is);\n\t\telse if (!bs.s.not_found)\n\t\t\terror = ext4_xattr_block_set(handle, inode, &i, &bs);\n\t} else {\n\t\terror = ext4_xattr_ibody_set(handle, inode, &i, &is);\n\t\tif (!error && !bs.s.not_found) {\n\t\t\ti.value = NULL;\n\t\t\terror = ext4_xattr_block_set(handle, inode, &i, &bs);\n\t\t} else if (error == -ENOSPC) {\n\t\t\tif (EXT4_I(inode)->i_file_acl && !bs.s.base) {\n\t\t\t\terror = ext4_xattr_block_find(inode, &i, &bs);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\terror = ext4_xattr_block_set(handle, inode, &i, &bs);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t\tif (!is.s.not_found) {\n\t\t\t\ti.value = NULL;\n\t\t\t\terror = ext4_xattr_ibody_set(handle, inode, &i,\n\t\t\t\t\t\t\t     &is);\n\t\t\t}\n\t\t}\n\t}\n\tif (!error) {\n\t\text4_xattr_update_super_block(handle, inode->i_sb);\n\t\tinode->i_ctime = ext4_current_time(inode);\n\t\tif (!value)\n\t\t\text4_clear_inode_state(inode, EXT4_STATE_NO_EXPAND);\n\t\terror = ext4_mark_iloc_dirty(handle, inode, &is.iloc);\n\t\t/*\n\t\t * The bh is consumed by ext4_mark_iloc_dirty, even with\n\t\t * error != 0.\n\t\t */\n\t\tis.iloc.bh = NULL;\n\t\tif (IS_SYNC(inode))\n\t\t\text4_handle_sync(handle);\n\t}\n\ncleanup:\n\tbrelse(is.iloc.bh);\n\tbrelse(bs.bh);\n\tif (no_expand == 0)\n\t\text4_clear_inode_state(inode, EXT4_STATE_NO_EXPAND);\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\treturn error;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nint\next4_xattr_set_handle(handle_t *handle, struct inode *inode, int name_index,\n\t\t      const char *name, const void *value, size_t value_len,\n\t\t      int flags)\n{\n\tstruct ext4_xattr_info i = {\n\t\t.name_index = name_index,\n\t\t.name = name,\n\t\t.value = value,\n\t\t.value_len = value_len,\n\n\t};\n\tstruct ext4_xattr_ibody_find is = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tstruct ext4_xattr_block_find bs = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tunsigned long no_expand;\n\tint error;\n\n\tif (!name)\n\t\treturn -EINVAL;\n\tif (strlen(name) > 255)\n\t\treturn -ERANGE;\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\tno_expand = ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND);\n\text4_set_inode_state(inode, EXT4_STATE_NO_EXPAND);\n\n\terror = ext4_reserve_inode_write(handle, inode, &is.iloc);\n\tif (error)\n\t\tgoto cleanup;\n\n\tif (ext4_test_inode_state(inode, EXT4_STATE_NEW)) {\n\t\tstruct ext4_inode *raw_inode = ext4_raw_inode(&is.iloc);\n\t\tmemset(raw_inode, 0, EXT4_SB(inode->i_sb)->s_inode_size);\n\t\text4_clear_inode_state(inode, EXT4_STATE_NEW);\n\t}\n\n\terror = ext4_xattr_ibody_find(inode, &i, &is);\n\tif (error)\n\t\tgoto cleanup;\n\tif (is.s.not_found)\n\t\terror = ext4_xattr_block_find(inode, &i, &bs);\n\tif (error)\n\t\tgoto cleanup;\n\tif (is.s.not_found && bs.s.not_found) {\n\t\terror = -ENODATA;\n\t\tif (flags & XATTR_REPLACE)\n\t\t\tgoto cleanup;\n\t\terror = 0;\n\t\tif (!value)\n\t\t\tgoto cleanup;\n\t} else {\n\t\terror = -EEXIST;\n\t\tif (flags & XATTR_CREATE)\n\t\t\tgoto cleanup;\n\t}\n\tif (!value) {\n\t\tif (!is.s.not_found)\n\t\t\terror = ext4_xattr_ibody_set(handle, inode, &i, &is);\n\t\telse if (!bs.s.not_found)\n\t\t\terror = ext4_xattr_block_set(handle, inode, &i, &bs);\n\t} else {\n\t\terror = ext4_xattr_ibody_set(handle, inode, &i, &is);\n\t\tif (!error && !bs.s.not_found) {\n\t\t\ti.value = NULL;\n\t\t\terror = ext4_xattr_block_set(handle, inode, &i, &bs);\n\t\t} else if (error == -ENOSPC) {\n\t\t\tif (EXT4_I(inode)->i_file_acl && !bs.s.base) {\n\t\t\t\terror = ext4_xattr_block_find(inode, &i, &bs);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\terror = ext4_xattr_block_set(handle, inode, &i, &bs);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t\tif (!is.s.not_found) {\n\t\t\t\ti.value = NULL;\n\t\t\t\terror = ext4_xattr_ibody_set(handle, inode, &i,\n\t\t\t\t\t\t\t     &is);\n\t\t\t}\n\t\t}\n\t}\n\tif (!error) {\n\t\text4_xattr_update_super_block(handle, inode->i_sb);\n\t\tinode->i_ctime = ext4_current_time(inode);\n\t\tif (!value)\n\t\t\text4_clear_inode_state(inode, EXT4_STATE_NO_EXPAND);\n\t\terror = ext4_mark_iloc_dirty(handle, inode, &is.iloc);\n\t\t/*\n\t\t * The bh is consumed by ext4_mark_iloc_dirty, even with\n\t\t * error != 0.\n\t\t */\n\t\tis.iloc.bh = NULL;\n\t\tif (IS_SYNC(inode))\n\t\t\text4_handle_sync(handle);\n\t}\n\ncleanup:\n\tbrelse(is.iloc.bh);\n\tbrelse(bs.bh);\n\tif (no_expand == 0)\n\t\text4_clear_inode_state(inode, EXT4_STATE_NO_EXPAND);\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n\nstatic int\next4_initxattrs(struct inode *inode, const struct xattr *xattr_array,\n\t\tvoid *fs_info)\n{\n\tconst struct xattr *xattr;\n\thandle_t *handle = fs_info;\n\tint err = 0;\n\n\tfor (xattr = xattr_array; xattr->name != NULL; xattr++) {\n\t\terr = ext4_xattr_set_handle(handle, inode,\n\t\t\t\t\t    EXT4_XATTR_INDEX_SECURITY,\n\t\t\t\t\t    xattr->name, xattr->value,\n\t\t\t\t\t    xattr->value_len, 0);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "ext4_xattr_security_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr_security.c",
    "lines": "40-48",
    "snippet": "static int\next4_xattr_security_set(struct dentry *dentry, const char *name,\n\t\tconst void *value, size_t size, int flags, int type)\n{\n\tif (strcmp(name, \"\") == 0)\n\t\treturn -EINVAL;\n\treturn ext4_xattr_set(dentry->d_inode, EXT4_XATTR_INDEX_SECURITY,\n\t\t\t      name, value, size, flags);\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_xattr_set",
          "args": [
            "dentry->d_inode",
            "EXT4_XATTR_INDEX_SECURITY",
            "name",
            "value",
            "size",
            "flags"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "1201-1227",
          "snippet": "int\next4_xattr_set(struct inode *inode, int name_index, const char *name,\n\t       const void *value, size_t value_len, int flags)\n{\n\thandle_t *handle;\n\tint error, retries = 0;\n\tint credits = ext4_jbd2_credits_xattr(inode);\n\nretry:\n\thandle = ext4_journal_start(inode, EXT4_HT_XATTR, credits);\n\tif (IS_ERR(handle)) {\n\t\terror = PTR_ERR(handle);\n\t} else {\n\t\tint error2;\n\n\t\terror = ext4_xattr_set_handle(handle, inode, name_index, name,\n\t\t\t\t\t      value, value_len, flags);\n\t\terror2 = ext4_journal_stop(handle);\n\t\tif (error == -ENOSPC &&\n\t\t    ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\t\tgoto retry;\n\t\tif (error == 0)\n\t\t\terror = error2;\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nint\next4_xattr_set(struct inode *inode, int name_index, const char *name,\n\t       const void *value, size_t value_len, int flags)\n{\n\thandle_t *handle;\n\tint error, retries = 0;\n\tint credits = ext4_jbd2_credits_xattr(inode);\n\nretry:\n\thandle = ext4_journal_start(inode, EXT4_HT_XATTR, credits);\n\tif (IS_ERR(handle)) {\n\t\terror = PTR_ERR(handle);\n\t} else {\n\t\tint error2;\n\n\t\terror = ext4_xattr_set_handle(handle, inode, name_index, name,\n\t\t\t\t\t      value, value_len, flags);\n\t\terror2 = ext4_journal_stop(handle);\n\t\tif (error == -ENOSPC &&\n\t\t    ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\t\tgoto retry;\n\t\tif (error == 0)\n\t\t\terror = error2;\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"\""
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n\nstatic int\next4_xattr_security_set(struct dentry *dentry, const char *name,\n\t\tconst void *value, size_t size, int flags, int type)\n{\n\tif (strcmp(name, \"\") == 0)\n\t\treturn -EINVAL;\n\treturn ext4_xattr_set(dentry->d_inode, EXT4_XATTR_INDEX_SECURITY,\n\t\t\t      name, value, size, flags);\n}"
  },
  {
    "function_name": "ext4_xattr_security_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr_security.c",
    "lines": "30-38",
    "snippet": "static int\next4_xattr_security_get(struct dentry *dentry, const char *name,\n\t\t       void *buffer, size_t size, int type)\n{\n\tif (strcmp(name, \"\") == 0)\n\t\treturn -EINVAL;\n\treturn ext4_xattr_get(dentry->d_inode, EXT4_XATTR_INDEX_SECURITY,\n\t\t\t      name, buffer, size);\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_xattr_get",
          "args": [
            "dentry->d_inode",
            "EXT4_XATTR_INDEX_SECURITY",
            "name",
            "buffer",
            "size"
          ],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "379-396",
          "snippet": "int\next4_xattr_get(struct inode *inode, int name_index, const char *name,\n\t       void *buffer, size_t buffer_size)\n{\n\tint error;\n\n\tif (strlen(name) > 255)\n\t\treturn -ERANGE;\n\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\terror = ext4_xattr_ibody_get(inode, name_index, name, buffer,\n\t\t\t\t     buffer_size);\n\tif (error == -ENODATA)\n\t\terror = ext4_xattr_block_get(inode, name_index, name, buffer,\n\t\t\t\t\t     buffer_size);\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\treturn error;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic int ext4_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);\n\nint\next4_xattr_get(struct inode *inode, int name_index, const char *name,\n\t       void *buffer, size_t buffer_size)\n{\n\tint error;\n\n\tif (strlen(name) > 255)\n\t\treturn -ERANGE;\n\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\terror = ext4_xattr_ibody_get(inode, name_index, name, buffer,\n\t\t\t\t     buffer_size);\n\tif (error == -ENODATA)\n\t\terror = ext4_xattr_block_get(inode, name_index, name, buffer,\n\t\t\t\t\t     buffer_size);\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"\""
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n\nstatic int\next4_xattr_security_get(struct dentry *dentry, const char *name,\n\t\t       void *buffer, size_t size, int type)\n{\n\tif (strcmp(name, \"\") == 0)\n\t\treturn -EINVAL;\n\treturn ext4_xattr_get(dentry->d_inode, EXT4_XATTR_INDEX_SECURITY,\n\t\t\t      name, buffer, size);\n}"
  },
  {
    "function_name": "ext4_xattr_security_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr_security.c",
    "lines": "14-28",
    "snippet": "static size_t\next4_xattr_security_list(struct dentry *dentry, char *list, size_t list_size,\n\t\tconst char *name, size_t name_len, int type)\n{\n\tconst size_t prefix_len = sizeof(XATTR_SECURITY_PREFIX)-1;\n\tconst size_t total_len = prefix_len + name_len + 1;\n\n\n\tif (list && total_len <= list_size) {\n\t\tmemcpy(list, XATTR_SECURITY_PREFIX, prefix_len);\n\t\tmemcpy(list+prefix_len, name, name_len);\n\t\tlist[prefix_len + name_len] = '\\0';\n\t}\n\treturn total_len;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "list+prefix_len",
            "name",
            "name_len"
          ],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "list",
            "XATTR_SECURITY_PREFIX",
            "prefix_len"
          ],
          "line": 23
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n\nstatic size_t\next4_xattr_security_list(struct dentry *dentry, char *list, size_t list_size,\n\t\tconst char *name, size_t name_len, int type)\n{\n\tconst size_t prefix_len = sizeof(XATTR_SECURITY_PREFIX)-1;\n\tconst size_t total_len = prefix_len + name_len + 1;\n\n\n\tif (list && total_len <= list_size) {\n\t\tmemcpy(list, XATTR_SECURITY_PREFIX, prefix_len);\n\t\tmemcpy(list+prefix_len, name, name_len);\n\t\tlist[prefix_len + name_len] = '\\0';\n\t}\n\treturn total_len;\n}"
  }
]