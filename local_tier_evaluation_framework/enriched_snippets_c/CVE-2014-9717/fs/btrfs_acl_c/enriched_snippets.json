[
  {
    "function_name": "btrfs_init_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/acl.c",
    "lines": "136-166",
    "snippet": "int btrfs_init_acl(struct btrfs_trans_handle *trans,\n\t\t   struct inode *inode, struct inode *dir)\n{\n\tstruct posix_acl *default_acl, *acl;\n\tint ret = 0;\n\n\t/* this happens with subvols */\n\tif (!dir)\n\t\treturn 0;\n\n\tret = posix_acl_create(dir, &inode->i_mode, &default_acl, &acl);\n\tif (ret)\n\t\treturn ret;\n\n\tif (default_acl) {\n\t\tret = __btrfs_set_acl(trans, inode, default_acl,\n\t\t\t\t      ACL_TYPE_DEFAULT);\n\t\tposix_acl_release(default_acl);\n\t}\n\n\tif (acl) {\n\t\tif (!ret)\n\t\t\tret = __btrfs_set_acl(trans, inode, acl,\n\t\t\t\t\t      ACL_TYPE_ACCESS);\n\t\tposix_acl_release(acl);\n\t}\n\n\tif (!default_acl && !acl)\n\t\tcache_no_acl(inode);\n\treturn ret;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cache_no_acl",
          "args": [
            "inode"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "acl"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__btrfs_set_acl",
          "args": [
            "trans",
            "inode",
            "acl",
            "ACL_TYPE_ACCESS"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_set_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/acl.c",
          "lines": "75-124",
          "snippet": "static int __btrfs_set_acl(struct btrfs_trans_handle *trans,\n\t\t\t struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint ret, size = 0;\n\tconst char *name;\n\tchar *value = NULL;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = POSIX_ACL_XATTR_ACCESS;\n\t\tif (acl) {\n\t\t\tret = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (ret == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EINVAL : 0;\n\t\tname = POSIX_ACL_XATTR_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_NOFS);\n\t\tif (!value) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = __btrfs_setxattr(trans, inode, name, value, size, 0);\nout:\n\tkfree(value);\n\n\tif (!ret)\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/posix_acl.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nstatic int __btrfs_set_acl(struct btrfs_trans_handle *trans,\n\t\t\t struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint ret, size = 0;\n\tconst char *name;\n\tchar *value = NULL;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = POSIX_ACL_XATTR_ACCESS;\n\t\tif (acl) {\n\t\t\tret = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (ret == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EINVAL : 0;\n\t\tname = POSIX_ACL_XATTR_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_NOFS);\n\t\tif (!value) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = __btrfs_setxattr(trans, inode, name, value, size, 0);\nout:\n\tkfree(value);\n\n\tif (!ret)\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "default_acl"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_create",
          "args": [
            "dir",
            "&inode->i_mode",
            "&default_acl",
            "&acl"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "545-598",
          "snippet": "int\nposix_acl_create(struct inode *dir, umode_t *mode,\n\t\tstruct posix_acl **default_acl, struct posix_acl **acl)\n{\n\tstruct posix_acl *p;\n\tint ret;\n\n\tif (S_ISLNK(*mode) || !IS_POSIXACL(dir))\n\t\tgoto no_acl;\n\n\tp = get_acl(dir, ACL_TYPE_DEFAULT);\n\tif (IS_ERR(p)) {\n\t\tif (p == ERR_PTR(-EOPNOTSUPP))\n\t\t\tgoto apply_umask;\n\t\treturn PTR_ERR(p);\n\t}\n\n\tif (!p)\n\t\tgoto apply_umask;\n\n\t*acl = posix_acl_clone(p, GFP_NOFS);\n\tif (!*acl)\n\t\tgoto no_mem;\n\n\tret = posix_acl_create_masq(*acl, mode);\n\tif (ret < 0)\n\t\tgoto no_mem_clone;\n\n\tif (ret == 0) {\n\t\tposix_acl_release(*acl);\n\t\t*acl = NULL;\n\t}\n\n\tif (!S_ISDIR(*mode)) {\n\t\tposix_acl_release(p);\n\t\t*default_acl = NULL;\n\t} else {\n\t\t*default_acl = p;\n\t}\n\treturn 0;\n\napply_umask:\n\t*mode &= ~current_umask();\nno_acl:\n\t*default_acl = NULL;\n\t*acl = NULL;\n\treturn 0;\n\nno_mem_clone:\n\tposix_acl_release(*acl);\nno_mem:\n\tposix_acl_release(p);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nposix_acl_create(struct inode *dir, umode_t *mode,\n\t\tstruct posix_acl **default_acl, struct posix_acl **acl)\n{\n\tstruct posix_acl *p;\n\tint ret;\n\n\tif (S_ISLNK(*mode) || !IS_POSIXACL(dir))\n\t\tgoto no_acl;\n\n\tp = get_acl(dir, ACL_TYPE_DEFAULT);\n\tif (IS_ERR(p)) {\n\t\tif (p == ERR_PTR(-EOPNOTSUPP))\n\t\t\tgoto apply_umask;\n\t\treturn PTR_ERR(p);\n\t}\n\n\tif (!p)\n\t\tgoto apply_umask;\n\n\t*acl = posix_acl_clone(p, GFP_NOFS);\n\tif (!*acl)\n\t\tgoto no_mem;\n\n\tret = posix_acl_create_masq(*acl, mode);\n\tif (ret < 0)\n\t\tgoto no_mem_clone;\n\n\tif (ret == 0) {\n\t\tposix_acl_release(*acl);\n\t\t*acl = NULL;\n\t}\n\n\tif (!S_ISDIR(*mode)) {\n\t\tposix_acl_release(p);\n\t\t*default_acl = NULL;\n\t} else {\n\t\t*default_acl = p;\n\t}\n\treturn 0;\n\napply_umask:\n\t*mode &= ~current_umask();\nno_acl:\n\t*default_acl = NULL;\n\t*acl = NULL;\n\treturn 0;\n\nno_mem_clone:\n\tposix_acl_release(*acl);\nno_mem:\n\tposix_acl_release(p);\n\treturn -ENOMEM;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/posix_acl.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nint btrfs_init_acl(struct btrfs_trans_handle *trans,\n\t\t   struct inode *inode, struct inode *dir)\n{\n\tstruct posix_acl *default_acl, *acl;\n\tint ret = 0;\n\n\t/* this happens with subvols */\n\tif (!dir)\n\t\treturn 0;\n\n\tret = posix_acl_create(dir, &inode->i_mode, &default_acl, &acl);\n\tif (ret)\n\t\treturn ret;\n\n\tif (default_acl) {\n\t\tret = __btrfs_set_acl(trans, inode, default_acl,\n\t\t\t\t      ACL_TYPE_DEFAULT);\n\t\tposix_acl_release(default_acl);\n\t}\n\n\tif (acl) {\n\t\tif (!ret)\n\t\t\tret = __btrfs_set_acl(trans, inode, acl,\n\t\t\t\t\t      ACL_TYPE_ACCESS);\n\t\tposix_acl_release(acl);\n\t}\n\n\tif (!default_acl && !acl)\n\t\tcache_no_acl(inode);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_set_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/acl.c",
    "lines": "126-129",
    "snippet": "int btrfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\treturn __btrfs_set_acl(NULL, inode, acl, type);\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__btrfs_set_acl",
          "args": [
            "NULL",
            "inode",
            "acl",
            "type"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_set_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/acl.c",
          "lines": "75-124",
          "snippet": "static int __btrfs_set_acl(struct btrfs_trans_handle *trans,\n\t\t\t struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint ret, size = 0;\n\tconst char *name;\n\tchar *value = NULL;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = POSIX_ACL_XATTR_ACCESS;\n\t\tif (acl) {\n\t\t\tret = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (ret == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EINVAL : 0;\n\t\tname = POSIX_ACL_XATTR_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_NOFS);\n\t\tif (!value) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = __btrfs_setxattr(trans, inode, name, value, size, 0);\nout:\n\tkfree(value);\n\n\tif (!ret)\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/posix_acl.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nstatic int __btrfs_set_acl(struct btrfs_trans_handle *trans,\n\t\t\t struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint ret, size = 0;\n\tconst char *name;\n\tchar *value = NULL;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = POSIX_ACL_XATTR_ACCESS;\n\t\tif (acl) {\n\t\t\tret = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (ret == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EINVAL : 0;\n\t\tname = POSIX_ACL_XATTR_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_NOFS);\n\t\tif (!value) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = __btrfs_setxattr(trans, inode, name, value, size, 0);\nout:\n\tkfree(value);\n\n\tif (!ret)\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/posix_acl.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nint btrfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\treturn __btrfs_set_acl(NULL, inode, acl, type);\n}"
  },
  {
    "function_name": "__btrfs_set_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/acl.c",
    "lines": "75-124",
    "snippet": "static int __btrfs_set_acl(struct btrfs_trans_handle *trans,\n\t\t\t struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint ret, size = 0;\n\tconst char *name;\n\tchar *value = NULL;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = POSIX_ACL_XATTR_ACCESS;\n\t\tif (acl) {\n\t\t\tret = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (ret == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EINVAL : 0;\n\t\tname = POSIX_ACL_XATTR_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_NOFS);\n\t\tif (!value) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = __btrfs_setxattr(trans, inode, name, value, size, 0);\nout:\n\tkfree(value);\n\n\tif (!ret)\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_cached_acl",
          "args": [
            "inode",
            "type",
            "acl"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_set_cached_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/acl.c",
          "lines": "32-41",
          "snippet": "static inline void ceph_set_cached_acl(struct inode *inode,\n\t\t\t\t\tint type, struct posix_acl *acl)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (__ceph_caps_issued_mask(ci, CEPH_CAP_XATTR_SHARED, 0))\n\t\tset_cached_acl(inode, type, acl);\n\tspin_unlock(&ci->i_ceph_lock);\n}",
          "includes": [
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/posix_acl.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline void ceph_set_cached_acl(struct inode *inode,\n\t\t\t\t\tint type, struct posix_acl *acl)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (__ceph_caps_issued_mask(ci, CEPH_CAP_XATTR_SHARED, 0))\n\t\tset_cached_acl(inode, type, acl);\n\tspin_unlock(&ci->i_ceph_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "value"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__btrfs_setxattr",
          "args": [
            "trans",
            "inode",
            "name",
            "value",
            "size",
            "0"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_setxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/xattr.c",
          "lines": "233-259",
          "snippet": "int __btrfs_setxattr(struct btrfs_trans_handle *trans,\n\t\t     struct inode *inode, const char *name,\n\t\t     const void *value, size_t size, int flags)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tint ret;\n\n\tif (trans)\n\t\treturn do_setxattr(trans, inode, name, value, size, flags);\n\n\ttrans = btrfs_start_transaction(root, 2);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\n\tret = do_setxattr(trans, inode, name, value, size, flags);\n\tif (ret)\n\t\tgoto out;\n\n\tinode_inc_iversion(inode);\n\tinode->i_ctime = CURRENT_TIME;\n\tset_bit(BTRFS_INODE_COPY_EVERYTHING, &BTRFS_I(inode)->runtime_flags);\n\tret = btrfs_update_inode(trans, root, inode);\n\tBUG_ON(ret);\nout:\n\tbtrfs_end_transaction(trans, root);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"props.h\"",
            "#include \"disk-io.h\"",
            "#include \"xattr.h\"",
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"props.h\"\n#include \"disk-io.h\"\n#include \"xattr.h\"\n#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/rwsem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nint __btrfs_setxattr(struct btrfs_trans_handle *trans,\n\t\t     struct inode *inode, const char *name,\n\t\t     const void *value, size_t size, int flags)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tint ret;\n\n\tif (trans)\n\t\treturn do_setxattr(trans, inode, name, value, size, flags);\n\n\ttrans = btrfs_start_transaction(root, 2);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\n\tret = do_setxattr(trans, inode, name, value, size, flags);\n\tif (ret)\n\t\tgoto out;\n\n\tinode_inc_iversion(inode);\n\tinode->i_ctime = CURRENT_TIME;\n\tset_bit(BTRFS_INODE_COPY_EVERYTHING, &BTRFS_I(inode)->runtime_flags);\n\tret = btrfs_update_inode(trans, root, inode);\n\tBUG_ON(ret);\nout:\n\tbtrfs_end_transaction(trans, root);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_to_xattr",
          "args": [
            "&init_user_ns",
            "acl",
            "value",
            "size"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_to_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "731-767",
          "snippet": "int\nposix_acl_to_xattr(struct user_namespace *user_ns, const struct posix_acl *acl,\n\t\t   void *buffer, size_t size)\n{\n\tposix_acl_xattr_header *ext_acl = (posix_acl_xattr_header *)buffer;\n\tposix_acl_xattr_entry *ext_entry;\n\tint real_size, n;\n\n\treal_size = posix_acl_xattr_size(acl->a_count);\n\tif (!buffer)\n\t\treturn real_size;\n\tif (real_size > size)\n\t\treturn -ERANGE;\n\n\text_entry = ext_acl->a_entries;\n\text_acl->a_version = cpu_to_le32(POSIX_ACL_XATTR_VERSION);\n\n\tfor (n=0; n < acl->a_count; n++, ext_entry++) {\n\t\tconst struct posix_acl_entry *acl_e = &acl->a_entries[n];\n\t\text_entry->e_tag  = cpu_to_le16(acl_e->e_tag);\n\t\text_entry->e_perm = cpu_to_le16(acl_e->e_perm);\n\t\tswitch(acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\text_entry->e_id =\n\t\t\t\tcpu_to_le32(from_kuid(user_ns, acl_e->e_uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\text_entry->e_id =\n\t\t\t\tcpu_to_le32(from_kgid(user_ns, acl_e->e_gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\text_entry->e_id = cpu_to_le32(ACL_UNDEFINED_ID);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn real_size;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nposix_acl_to_xattr(struct user_namespace *user_ns, const struct posix_acl *acl,\n\t\t   void *buffer, size_t size)\n{\n\tposix_acl_xattr_header *ext_acl = (posix_acl_xattr_header *)buffer;\n\tposix_acl_xattr_entry *ext_entry;\n\tint real_size, n;\n\n\treal_size = posix_acl_xattr_size(acl->a_count);\n\tif (!buffer)\n\t\treturn real_size;\n\tif (real_size > size)\n\t\treturn -ERANGE;\n\n\text_entry = ext_acl->a_entries;\n\text_acl->a_version = cpu_to_le32(POSIX_ACL_XATTR_VERSION);\n\n\tfor (n=0; n < acl->a_count; n++, ext_entry++) {\n\t\tconst struct posix_acl_entry *acl_e = &acl->a_entries[n];\n\t\text_entry->e_tag  = cpu_to_le16(acl_e->e_tag);\n\t\text_entry->e_perm = cpu_to_le16(acl_e->e_perm);\n\t\tswitch(acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\text_entry->e_id =\n\t\t\t\tcpu_to_le32(from_kuid(user_ns, acl_e->e_uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\text_entry->e_id =\n\t\t\t\tcpu_to_le32(from_kgid(user_ns, acl_e->e_gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\text_entry->e_id = cpu_to_le32(ACL_UNDEFINED_ID);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn real_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "size",
            "GFP_NOFS"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_xattr_size",
          "args": [
            "acl->a_count"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_equiv_mode",
          "args": [
            "acl",
            "&inode->i_mode"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_equiv_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "242-282",
          "snippet": "int\nposix_acl_equiv_mode(const struct posix_acl *acl, umode_t *mode_p)\n{\n\tconst struct posix_acl_entry *pa, *pe;\n\tumode_t mode = 0;\n\tint not_equiv = 0;\n\n\t/*\n\t * A null ACL can always be presented as mode bits.\n\t */\n\tif (!acl)\n\t\treturn 0;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch (pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 6;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 3;\n\t\t\t\tbreak;\n\t\t\tcase ACL_OTHER:\n\t\t\t\tmode |= pa->e_perm & S_IRWXO;\n\t\t\t\tbreak;\n\t\t\tcase ACL_MASK:\n\t\t\t\tmode = (mode & ~S_IRWXG) |\n\t\t\t\t       ((pa->e_perm & S_IRWXO) << 3);\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n        if (mode_p)\n                *mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nposix_acl_equiv_mode(const struct posix_acl *acl, umode_t *mode_p)\n{\n\tconst struct posix_acl_entry *pa, *pe;\n\tumode_t mode = 0;\n\tint not_equiv = 0;\n\n\t/*\n\t * A null ACL can always be presented as mode bits.\n\t */\n\tif (!acl)\n\t\treturn 0;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch (pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 6;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 3;\n\t\t\t\tbreak;\n\t\t\tcase ACL_OTHER:\n\t\t\t\tmode |= pa->e_perm & S_IRWXO;\n\t\t\t\tbreak;\n\t\t\tcase ACL_MASK:\n\t\t\t\tmode = (mode & ~S_IRWXG) |\n\t\t\t\t       ((pa->e_perm & S_IRWXO) << 3);\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n        if (mode_p)\n                *mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/posix_acl.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nstatic int __btrfs_set_acl(struct btrfs_trans_handle *trans,\n\t\t\t struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint ret, size = 0;\n\tconst char *name;\n\tchar *value = NULL;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = POSIX_ACL_XATTR_ACCESS;\n\t\tif (acl) {\n\t\t\tret = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (ret == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EINVAL : 0;\n\t\tname = POSIX_ACL_XATTR_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_NOFS);\n\t\tif (!value) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = __btrfs_setxattr(trans, inode, name, value, size, 0);\nout:\n\tkfree(value);\n\n\tif (!ret)\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_get_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/acl.c",
    "lines": "31-70",
    "snippet": "struct posix_acl *btrfs_get_acl(struct inode *inode, int type)\n{\n\tint size;\n\tconst char *name;\n\tchar *value = NULL;\n\tstruct posix_acl *acl;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = POSIX_ACL_XATTR_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = POSIX_ACL_XATTR_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tsize = __btrfs_getxattr(inode, name, \"\", 0);\n\tif (size > 0) {\n\t\tvalue = kzalloc(size, GFP_NOFS);\n\t\tif (!value)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tsize = __btrfs_getxattr(inode, name, value, size);\n\t}\n\tif (size > 0) {\n\t\tacl = posix_acl_from_xattr(&init_user_ns, value, size);\n\t} else if (size == -ENOENT || size == -ENODATA || size == 0) {\n\t\t/* FIXME, who returns -ENOENT?  I think nobody */\n\t\tacl = NULL;\n\t} else {\n\t\tacl = ERR_PTR(-EIO);\n\t}\n\tkfree(value);\n\n\tif (!IS_ERR(acl))\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn acl;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_cached_acl",
          "args": [
            "inode",
            "type",
            "acl"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_set_cached_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/acl.c",
          "lines": "32-41",
          "snippet": "static inline void ceph_set_cached_acl(struct inode *inode,\n\t\t\t\t\tint type, struct posix_acl *acl)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (__ceph_caps_issued_mask(ci, CEPH_CAP_XATTR_SHARED, 0))\n\t\tset_cached_acl(inode, type, acl);\n\tspin_unlock(&ci->i_ceph_lock);\n}",
          "includes": [
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/posix_acl.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline void ceph_set_cached_acl(struct inode *inode,\n\t\t\t\t\tint type, struct posix_acl *acl)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (__ceph_caps_issued_mask(ci, CEPH_CAP_XATTR_SHARED, 0))\n\t\tset_cached_acl(inode, type, acl);\n\tspin_unlock(&ci->i_ceph_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "acl"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "value"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_from_xattr",
          "args": [
            "&init_user_ns",
            "value",
            "size"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_from_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "662-725",
          "snippet": "struct posix_acl *\nposix_acl_from_xattr(struct user_namespace *user_ns,\n\t\t     const void *value, size_t size)\n{\n\tposix_acl_xattr_header *header = (posix_acl_xattr_header *)value;\n\tposix_acl_xattr_entry *entry = (posix_acl_xattr_entry *)(header+1), *end;\n\tint count;\n\tstruct posix_acl *acl;\n\tstruct posix_acl_entry *acl_e;\n\n\tif (!value)\n\t\treturn NULL;\n\tif (size < sizeof(posix_acl_xattr_header))\n\t\t return ERR_PTR(-EINVAL);\n\tif (header->a_version != cpu_to_le32(POSIX_ACL_XATTR_VERSION))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tcount = posix_acl_xattr_count(size);\n\tif (count < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (count == 0)\n\t\treturn NULL;\n\t\n\tacl = posix_acl_alloc(count, GFP_NOFS);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tacl_e = acl->a_entries;\n\t\n\tfor (end = entry + count; entry != end; acl_e++, entry++) {\n\t\tacl_e->e_tag  = le16_to_cpu(entry->e_tag);\n\t\tacl_e->e_perm = le16_to_cpu(entry->e_perm);\n\n\t\tswitch(acl_e->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\tcase ACL_MASK:\n\t\t\tcase ACL_OTHER:\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\t\tacl_e->e_uid =\n\t\t\t\t\tmake_kuid(user_ns,\n\t\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\t\tif (!uid_valid(acl_e->e_uid))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP:\n\t\t\t\tacl_e->e_gid =\n\t\t\t\t\tmake_kgid(user_ns,\n\t\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\t\tif (!gid_valid(acl_e->e_gid))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct posix_acl *\nposix_acl_from_xattr(struct user_namespace *user_ns,\n\t\t     const void *value, size_t size)\n{\n\tposix_acl_xattr_header *header = (posix_acl_xattr_header *)value;\n\tposix_acl_xattr_entry *entry = (posix_acl_xattr_entry *)(header+1), *end;\n\tint count;\n\tstruct posix_acl *acl;\n\tstruct posix_acl_entry *acl_e;\n\n\tif (!value)\n\t\treturn NULL;\n\tif (size < sizeof(posix_acl_xattr_header))\n\t\t return ERR_PTR(-EINVAL);\n\tif (header->a_version != cpu_to_le32(POSIX_ACL_XATTR_VERSION))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tcount = posix_acl_xattr_count(size);\n\tif (count < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (count == 0)\n\t\treturn NULL;\n\t\n\tacl = posix_acl_alloc(count, GFP_NOFS);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tacl_e = acl->a_entries;\n\t\n\tfor (end = entry + count; entry != end; acl_e++, entry++) {\n\t\tacl_e->e_tag  = le16_to_cpu(entry->e_tag);\n\t\tacl_e->e_perm = le16_to_cpu(entry->e_perm);\n\n\t\tswitch(acl_e->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\tcase ACL_MASK:\n\t\t\tcase ACL_OTHER:\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\t\tacl_e->e_uid =\n\t\t\t\t\tmake_kuid(user_ns,\n\t\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\t\tif (!uid_valid(acl_e->e_uid))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP:\n\t\t\t\tacl_e->e_gid =\n\t\t\t\t\tmake_kgid(user_ns,\n\t\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\t\tif (!gid_valid(acl_e->e_gid))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btrfs_getxattr",
          "args": [
            "inode",
            "name",
            "value",
            "size"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_getxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/xattr.c",
          "lines": "35-89",
          "snippet": "ssize_t __btrfs_getxattr(struct inode *inode, const char *name,\n\t\t\t\tvoid *buffer, size_t size)\n{\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tint ret = 0;\n\tunsigned long data_ptr;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\t/* lookup the xattr by name */\n\tdi = btrfs_lookup_xattr(NULL, root, path, btrfs_ino(inode), name,\n\t\t\t\tstrlen(name), 0);\n\tif (!di) {\n\t\tret = -ENODATA;\n\t\tgoto out;\n\t} else if (IS_ERR(di)) {\n\t\tret = PTR_ERR(di);\n\t\tgoto out;\n\t}\n\n\tleaf = path->nodes[0];\n\t/* if size is 0, that means we want the size of the attr */\n\tif (!size) {\n\t\tret = btrfs_dir_data_len(leaf, di);\n\t\tgoto out;\n\t}\n\n\t/* now get the data out of our dir_item */\n\tif (btrfs_dir_data_len(leaf, di) > size) {\n\t\tret = -ERANGE;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The way things are packed into the leaf is like this\n\t * |struct btrfs_dir_item|name|data|\n\t * where name is the xattr name, so security.foo, and data is the\n\t * content of the xattr.  data_ptr points to the location in memory\n\t * where the data starts in the in memory leaf\n\t */\n\tdata_ptr = (unsigned long)((char *)(di + 1) +\n\t\t\t\t   btrfs_dir_name_len(leaf, di));\n\tread_extent_buffer(leaf, buffer, data_ptr,\n\t\t\t   btrfs_dir_data_len(leaf, di));\n\tret = btrfs_dir_data_len(leaf, di);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"props.h\"",
            "#include \"disk-io.h\"",
            "#include \"xattr.h\"",
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/xattr.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"props.h\"\n#include \"disk-io.h\"\n#include \"xattr.h\"\n#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/xattr.h>\n#include <linux/rwsem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nssize_t __btrfs_getxattr(struct inode *inode, const char *name,\n\t\t\t\tvoid *buffer, size_t size)\n{\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tint ret = 0;\n\tunsigned long data_ptr;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\t/* lookup the xattr by name */\n\tdi = btrfs_lookup_xattr(NULL, root, path, btrfs_ino(inode), name,\n\t\t\t\tstrlen(name), 0);\n\tif (!di) {\n\t\tret = -ENODATA;\n\t\tgoto out;\n\t} else if (IS_ERR(di)) {\n\t\tret = PTR_ERR(di);\n\t\tgoto out;\n\t}\n\n\tleaf = path->nodes[0];\n\t/* if size is 0, that means we want the size of the attr */\n\tif (!size) {\n\t\tret = btrfs_dir_data_len(leaf, di);\n\t\tgoto out;\n\t}\n\n\t/* now get the data out of our dir_item */\n\tif (btrfs_dir_data_len(leaf, di) > size) {\n\t\tret = -ERANGE;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * The way things are packed into the leaf is like this\n\t * |struct btrfs_dir_item|name|data|\n\t * where name is the xattr name, so security.foo, and data is the\n\t * content of the xattr.  data_ptr points to the location in memory\n\t * where the data starts in the in memory leaf\n\t */\n\tdata_ptr = (unsigned long)((char *)(di + 1) +\n\t\t\t\t   btrfs_dir_name_len(leaf, di));\n\tread_extent_buffer(leaf, buffer, data_ptr,\n\t\t\t   btrfs_dir_data_len(leaf, di));\n\tret = btrfs_dir_data_len(leaf, di);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "size",
            "GFP_NOFS"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/posix_acl.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nstruct posix_acl *btrfs_get_acl(struct inode *inode, int type)\n{\n\tint size;\n\tconst char *name;\n\tchar *value = NULL;\n\tstruct posix_acl *acl;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = POSIX_ACL_XATTR_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = POSIX_ACL_XATTR_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tsize = __btrfs_getxattr(inode, name, \"\", 0);\n\tif (size > 0) {\n\t\tvalue = kzalloc(size, GFP_NOFS);\n\t\tif (!value)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tsize = __btrfs_getxattr(inode, name, value, size);\n\t}\n\tif (size > 0) {\n\t\tacl = posix_acl_from_xattr(&init_user_ns, value, size);\n\t} else if (size == -ENOENT || size == -ENODATA || size == 0) {\n\t\t/* FIXME, who returns -ENOENT?  I think nobody */\n\t\tacl = NULL;\n\t} else {\n\t\tacl = ERR_PTR(-EIO);\n\t}\n\tkfree(value);\n\n\tif (!IS_ERR(acl))\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn acl;\n}"
  }
]