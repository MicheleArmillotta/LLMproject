[
  {
    "function_name": "ceph_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/ioctl.c",
    "lines": "271-295",
    "snippet": "long ceph_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tdout(\"ioctl file %p cmd %u arg %lu\\n\", file, cmd, arg);\n\tswitch (cmd) {\n\tcase CEPH_IOC_GET_LAYOUT:\n\t\treturn ceph_ioctl_get_layout(file, (void __user *)arg);\n\n\tcase CEPH_IOC_SET_LAYOUT:\n\t\treturn ceph_ioctl_set_layout(file, (void __user *)arg);\n\n\tcase CEPH_IOC_SET_LAYOUT_POLICY:\n\t\treturn ceph_ioctl_set_layout_policy(file, (void __user *)arg);\n\n\tcase CEPH_IOC_GET_DATALOC:\n\t\treturn ceph_ioctl_get_dataloc(file, (void __user *)arg);\n\n\tcase CEPH_IOC_LAZYIO:\n\t\treturn ceph_ioctl_lazyio(file);\n\n\tcase CEPH_IOC_SYNCIO:\n\t\treturn ceph_ioctl_syncio(file);\n\t}\n\n\treturn -ENOTTY;\n}",
    "includes": [
      "#include \"ioctl.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/in.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_ioctl_syncio",
          "args": [
            "file"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_ioctl_syncio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/ioctl.c",
          "lines": "263-269",
          "snippet": "static long ceph_ioctl_syncio(struct file *file)\n{\n\tstruct ceph_file_info *fi = file->private_data;\n\n\tfi->flags |= CEPH_F_SYNC;\n\treturn 0;\n}",
          "includes": [
            "#include \"ioctl.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/in.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ioctl.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/in.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic long ceph_ioctl_syncio(struct file *file)\n{\n\tstruct ceph_file_info *fi = file->private_data;\n\n\tfi->flags |= CEPH_F_SYNC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_ioctl_lazyio",
          "args": [
            "file"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_ioctl_lazyio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/ioctl.c",
          "lines": "242-261",
          "snippet": "static long ceph_ioctl_lazyio(struct file *file)\n{\n\tstruct ceph_file_info *fi = file->private_data;\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tif ((fi->fmode & CEPH_FILE_MODE_LAZY) == 0) {\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tci->i_nr_by_mode[fi->fmode]--;\n\t\tfi->fmode |= CEPH_FILE_MODE_LAZY;\n\t\tci->i_nr_by_mode[fi->fmode]++;\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tdout(\"ioctl_layzio: file %p marked lazy\\n\", file);\n\n\t\tceph_check_caps(ci, 0, NULL);\n\t} else {\n\t\tdout(\"ioctl_layzio: file %p already lazy\\n\", file);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ioctl.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/in.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ioctl.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/in.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic long ceph_ioctl_lazyio(struct file *file)\n{\n\tstruct ceph_file_info *fi = file->private_data;\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tif ((fi->fmode & CEPH_FILE_MODE_LAZY) == 0) {\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tci->i_nr_by_mode[fi->fmode]--;\n\t\tfi->fmode |= CEPH_FILE_MODE_LAZY;\n\t\tci->i_nr_by_mode[fi->fmode]++;\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tdout(\"ioctl_layzio: file %p marked lazy\\n\", file);\n\n\t\tceph_check_caps(ci, 0, NULL);\n\t} else {\n\t\tdout(\"ioctl_layzio: file %p already lazy\\n\", file);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_ioctl_get_dataloc",
          "args": [
            "file",
            "(void __user *)arg"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_ioctl_get_dataloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/ioctl.c",
          "lines": "178-240",
          "snippet": "static long ceph_ioctl_get_dataloc(struct file *file, void __user *arg)\n{\n\tstruct ceph_ioctl_dataloc dl;\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_osd_client *osdc =\n\t\t&ceph_sb_to_client(inode->i_sb)->client->osdc;\n\tstruct ceph_object_locator oloc;\n\tstruct ceph_object_id oid;\n\tu64 len = 1, olen;\n\tu64 tmp;\n\tstruct ceph_pg pgid;\n\tint r;\n\n\t/* copy and validate */\n\tif (copy_from_user(&dl, arg, sizeof(dl)))\n\t\treturn -EFAULT;\n\n\tdown_read(&osdc->map_sem);\n\tr = ceph_calc_file_object_mapping(&ci->i_layout, dl.file_offset, len,\n\t\t\t\t\t  &dl.object_no, &dl.object_offset,\n\t\t\t\t\t  &olen);\n\tif (r < 0) {\n\t\tup_read(&osdc->map_sem);\n\t\treturn -EIO;\n\t}\n\tdl.file_offset -= dl.object_offset;\n\tdl.object_size = ceph_file_layout_object_size(ci->i_layout);\n\tdl.block_size = ceph_file_layout_su(ci->i_layout);\n\n\t/* block_offset = object_offset % block_size */\n\ttmp = dl.object_offset;\n\tdl.block_offset = do_div(tmp, dl.block_size);\n\n\tsnprintf(dl.object_name, sizeof(dl.object_name), \"%llx.%08llx\",\n\t\t ceph_ino(inode), dl.object_no);\n\n\toloc.pool = ceph_file_layout_pg_pool(ci->i_layout);\n\tceph_oid_set_name(&oid, dl.object_name);\n\n\tr = ceph_oloc_oid_to_pg(osdc->osdmap, &oloc, &oid, &pgid);\n\tif (r < 0) {\n\t\tup_read(&osdc->map_sem);\n\t\treturn r;\n\t}\n\n\tdl.osd = ceph_calc_pg_primary(osdc->osdmap, pgid);\n\tif (dl.osd >= 0) {\n\t\tstruct ceph_entity_addr *a =\n\t\t\tceph_osd_addr(osdc->osdmap, dl.osd);\n\t\tif (a)\n\t\t\tmemcpy(&dl.osd_addr, &a->in_addr, sizeof(dl.osd_addr));\n\t} else {\n\t\tmemset(&dl.osd_addr, 0, sizeof(dl.osd_addr));\n\t}\n\tup_read(&osdc->map_sem);\n\n\t/* send result back to user */\n\tif (copy_to_user(arg, &dl, sizeof(dl)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ioctl.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/in.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ioctl.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/in.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic long ceph_ioctl_get_dataloc(struct file *file, void __user *arg)\n{\n\tstruct ceph_ioctl_dataloc dl;\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_osd_client *osdc =\n\t\t&ceph_sb_to_client(inode->i_sb)->client->osdc;\n\tstruct ceph_object_locator oloc;\n\tstruct ceph_object_id oid;\n\tu64 len = 1, olen;\n\tu64 tmp;\n\tstruct ceph_pg pgid;\n\tint r;\n\n\t/* copy and validate */\n\tif (copy_from_user(&dl, arg, sizeof(dl)))\n\t\treturn -EFAULT;\n\n\tdown_read(&osdc->map_sem);\n\tr = ceph_calc_file_object_mapping(&ci->i_layout, dl.file_offset, len,\n\t\t\t\t\t  &dl.object_no, &dl.object_offset,\n\t\t\t\t\t  &olen);\n\tif (r < 0) {\n\t\tup_read(&osdc->map_sem);\n\t\treturn -EIO;\n\t}\n\tdl.file_offset -= dl.object_offset;\n\tdl.object_size = ceph_file_layout_object_size(ci->i_layout);\n\tdl.block_size = ceph_file_layout_su(ci->i_layout);\n\n\t/* block_offset = object_offset % block_size */\n\ttmp = dl.object_offset;\n\tdl.block_offset = do_div(tmp, dl.block_size);\n\n\tsnprintf(dl.object_name, sizeof(dl.object_name), \"%llx.%08llx\",\n\t\t ceph_ino(inode), dl.object_no);\n\n\toloc.pool = ceph_file_layout_pg_pool(ci->i_layout);\n\tceph_oid_set_name(&oid, dl.object_name);\n\n\tr = ceph_oloc_oid_to_pg(osdc->osdmap, &oloc, &oid, &pgid);\n\tif (r < 0) {\n\t\tup_read(&osdc->map_sem);\n\t\treturn r;\n\t}\n\n\tdl.osd = ceph_calc_pg_primary(osdc->osdmap, pgid);\n\tif (dl.osd >= 0) {\n\t\tstruct ceph_entity_addr *a =\n\t\t\tceph_osd_addr(osdc->osdmap, dl.osd);\n\t\tif (a)\n\t\t\tmemcpy(&dl.osd_addr, &a->in_addr, sizeof(dl.osd_addr));\n\t} else {\n\t\tmemset(&dl.osd_addr, 0, sizeof(dl.osd_addr));\n\t}\n\tup_read(&osdc->map_sem);\n\n\t/* send result back to user */\n\tif (copy_to_user(arg, &dl, sizeof(dl)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_ioctl_set_layout_policy",
          "args": [
            "file",
            "(void __user *)arg"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_ioctl_set_layout_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/ioctl.c",
          "lines": "135-172",
          "snippet": "static long ceph_ioctl_set_layout_policy (struct file *file, void __user *arg)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_mds_request *req;\n\tstruct ceph_ioctl_layout l;\n\tint err;\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;\n\n\t/* copy and validate */\n\tif (copy_from_user(&l, arg, sizeof(l)))\n\t\treturn -EFAULT;\n\n\terr = __validate_layout(mdsc, &l);\n\tif (err)\n\t\treturn err;\n\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_SETDIRLAYOUT,\n\t\t\t\t       USE_AUTH_MDS);\n\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\treq->r_inode = inode;\n\tihold(inode);\n\treq->r_num_caps = 1;\n\n\treq->r_args.setlayout.layout.fl_stripe_unit =\n\t\t\tcpu_to_le32(l.stripe_unit);\n\treq->r_args.setlayout.layout.fl_stripe_count =\n\t\t\tcpu_to_le32(l.stripe_count);\n\treq->r_args.setlayout.layout.fl_object_size =\n\t\t\tcpu_to_le32(l.object_size);\n\treq->r_args.setlayout.layout.fl_pg_pool =\n\t\t\tcpu_to_le32(l.data_pool);\n\n\terr = ceph_mdsc_do_request(mdsc, inode, req);\n\tceph_mdsc_put_request(req);\n\treturn err;\n}",
          "includes": [
            "#include \"ioctl.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/in.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ioctl.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/in.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic long ceph_ioctl_set_layout_policy (struct file *file, void __user *arg)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_mds_request *req;\n\tstruct ceph_ioctl_layout l;\n\tint err;\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;\n\n\t/* copy and validate */\n\tif (copy_from_user(&l, arg, sizeof(l)))\n\t\treturn -EFAULT;\n\n\terr = __validate_layout(mdsc, &l);\n\tif (err)\n\t\treturn err;\n\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_SETDIRLAYOUT,\n\t\t\t\t       USE_AUTH_MDS);\n\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\treq->r_inode = inode;\n\tihold(inode);\n\treq->r_num_caps = 1;\n\n\treq->r_args.setlayout.layout.fl_stripe_unit =\n\t\t\tcpu_to_le32(l.stripe_unit);\n\treq->r_args.setlayout.layout.fl_stripe_count =\n\t\t\tcpu_to_le32(l.stripe_count);\n\treq->r_args.setlayout.layout.fl_object_size =\n\t\t\tcpu_to_le32(l.object_size);\n\treq->r_args.setlayout.layout.fl_pg_pool =\n\t\t\tcpu_to_le32(l.data_pool);\n\n\terr = ceph_mdsc_do_request(mdsc, inode, req);\n\tceph_mdsc_put_request(req);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_ioctl_get_layout",
          "args": [
            "file",
            "(void __user *)arg"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_ioctl_get_layout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/ioctl.c",
          "lines": "16-34",
          "snippet": "static long ceph_ioctl_get_layout(struct file *file, void __user *arg)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(file_inode(file));\n\tstruct ceph_ioctl_layout l;\n\tint err;\n\n\terr = ceph_do_getattr(file_inode(file), CEPH_STAT_CAP_LAYOUT, false);\n\tif (!err) {\n\t\tl.stripe_unit = ceph_file_layout_su(ci->i_layout);\n\t\tl.stripe_count = ceph_file_layout_stripe_count(ci->i_layout);\n\t\tl.object_size = ceph_file_layout_object_size(ci->i_layout);\n\t\tl.data_pool = le32_to_cpu(ci->i_layout.fl_pg_pool);\n\t\tl.preferred_osd = (s32)-1;\n\t\tif (copy_to_user(arg, &l, sizeof(l)))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include \"ioctl.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/in.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ioctl.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/in.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic long ceph_ioctl_get_layout(struct file *file, void __user *arg)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(file_inode(file));\n\tstruct ceph_ioctl_layout l;\n\tint err;\n\n\terr = ceph_do_getattr(file_inode(file), CEPH_STAT_CAP_LAYOUT, false);\n\tif (!err) {\n\t\tl.stripe_unit = ceph_file_layout_su(ci->i_layout);\n\t\tl.stripe_count = ceph_file_layout_stripe_count(ci->i_layout);\n\t\tl.object_size = ceph_file_layout_object_size(ci->i_layout);\n\t\tl.data_pool = le32_to_cpu(ci->i_layout.fl_pg_pool);\n\t\tl.preferred_osd = (s32)-1;\n\t\tif (copy_to_user(arg, &l, sizeof(l)))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"ioctl file %p cmd %u arg %lu\\n\"",
            "file",
            "cmd",
            "arg"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ioctl.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/in.h>\n#include <linux/ceph/ceph_debug.h>\n\nlong ceph_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tdout(\"ioctl file %p cmd %u arg %lu\\n\", file, cmd, arg);\n\tswitch (cmd) {\n\tcase CEPH_IOC_GET_LAYOUT:\n\t\treturn ceph_ioctl_get_layout(file, (void __user *)arg);\n\n\tcase CEPH_IOC_SET_LAYOUT:\n\t\treturn ceph_ioctl_set_layout(file, (void __user *)arg);\n\n\tcase CEPH_IOC_SET_LAYOUT_POLICY:\n\t\treturn ceph_ioctl_set_layout_policy(file, (void __user *)arg);\n\n\tcase CEPH_IOC_GET_DATALOC:\n\t\treturn ceph_ioctl_get_dataloc(file, (void __user *)arg);\n\n\tcase CEPH_IOC_LAZYIO:\n\t\treturn ceph_ioctl_lazyio(file);\n\n\tcase CEPH_IOC_SYNCIO:\n\t\treturn ceph_ioctl_syncio(file);\n\t}\n\n\treturn -ENOTTY;\n}"
  },
  {
    "function_name": "ceph_ioctl_syncio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/ioctl.c",
    "lines": "263-269",
    "snippet": "static long ceph_ioctl_syncio(struct file *file)\n{\n\tstruct ceph_file_info *fi = file->private_data;\n\n\tfi->flags |= CEPH_F_SYNC;\n\treturn 0;\n}",
    "includes": [
      "#include \"ioctl.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/in.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ioctl.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/in.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic long ceph_ioctl_syncio(struct file *file)\n{\n\tstruct ceph_file_info *fi = file->private_data;\n\n\tfi->flags |= CEPH_F_SYNC;\n\treturn 0;\n}"
  },
  {
    "function_name": "ceph_ioctl_lazyio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/ioctl.c",
    "lines": "242-261",
    "snippet": "static long ceph_ioctl_lazyio(struct file *file)\n{\n\tstruct ceph_file_info *fi = file->private_data;\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tif ((fi->fmode & CEPH_FILE_MODE_LAZY) == 0) {\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tci->i_nr_by_mode[fi->fmode]--;\n\t\tfi->fmode |= CEPH_FILE_MODE_LAZY;\n\t\tci->i_nr_by_mode[fi->fmode]++;\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tdout(\"ioctl_layzio: file %p marked lazy\\n\", file);\n\n\t\tceph_check_caps(ci, 0, NULL);\n\t} else {\n\t\tdout(\"ioctl_layzio: file %p already lazy\\n\", file);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ioctl.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/in.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"ioctl_layzio: file %p already lazy\\n\"",
            "file"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_check_caps",
          "args": [
            "ci",
            "0",
            "NULL"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_check_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "1504-1751",
          "snippet": "void ceph_check_caps(struct ceph_inode_info *ci, int flags,\n\t\t     struct ceph_mds_session *session)\n{\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(&ci->vfs_inode);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct inode *inode = &ci->vfs_inode;\n\tstruct ceph_cap *cap;\n\tint file_wanted, used, cap_used;\n\tint took_snap_rwsem = 0;             /* true if mdsc->snap_rwsem held */\n\tint issued, implemented, want, retain, revoking, flushing = 0;\n\tint mds = -1;   /* keep track of how far we've gone through i_caps list\n\t\t\t   to avoid an infinite loop on retry */\n\tstruct rb_node *p;\n\tint tried_invalidate = 0;\n\tint delayed = 0, sent = 0, force_requeue = 0, num;\n\tint queue_invalidate = 0;\n\tint is_delayed = flags & CHECK_CAPS_NODELAY;\n\n\t/* if we are unmounting, flush any unused caps immediately. */\n\tif (mdsc->stopping)\n\t\tis_delayed = 1;\n\n\tspin_lock(&ci->i_ceph_lock);\n\n\tif (ci->i_ceph_flags & CEPH_I_FLUSH)\n\t\tflags |= CHECK_CAPS_FLUSH;\n\n\t/* flush snaps first time around only */\n\tif (!list_empty(&ci->i_cap_snaps))\n\t\t__ceph_flush_snaps(ci, &session, 0);\n\tgoto retry_locked;\nretry:\n\tspin_lock(&ci->i_ceph_lock);\nretry_locked:\n\tfile_wanted = __ceph_caps_file_wanted(ci);\n\tused = __ceph_caps_used(ci);\n\twant = file_wanted | used;\n\tissued = __ceph_caps_issued(ci, &implemented);\n\trevoking = implemented & ~issued;\n\n\tretain = want | CEPH_CAP_PIN;\n\tif (!mdsc->stopping && inode->i_nlink > 0) {\n\t\tif (want) {\n\t\t\tretain |= CEPH_CAP_ANY;       /* be greedy */\n\t\t} else {\n\t\t\tretain |= CEPH_CAP_ANY_SHARED;\n\t\t\t/*\n\t\t\t * keep RD only if we didn't have the file open RW,\n\t\t\t * because then the mds would revoke it anyway to\n\t\t\t * journal max_size=0.\n\t\t\t */\n\t\t\tif (ci->i_max_size == 0)\n\t\t\t\tretain |= CEPH_CAP_ANY_RD;\n\t\t}\n\t}\n\n\tdout(\"check_caps %p file_want %s used %s dirty %s flushing %s\"\n\t     \" issued %s revoking %s retain %s %s%s%s\\n\", inode,\n\t     ceph_cap_string(file_wanted),\n\t     ceph_cap_string(used), ceph_cap_string(ci->i_dirty_caps),\n\t     ceph_cap_string(ci->i_flushing_caps),\n\t     ceph_cap_string(issued), ceph_cap_string(revoking),\n\t     ceph_cap_string(retain),\n\t     (flags & CHECK_CAPS_AUTHONLY) ? \" AUTHONLY\" : \"\",\n\t     (flags & CHECK_CAPS_NODELAY) ? \" NODELAY\" : \"\",\n\t     (flags & CHECK_CAPS_FLUSH) ? \" FLUSH\" : \"\");\n\n\t/*\n\t * If we no longer need to hold onto old our caps, and we may\n\t * have cached pages, but don't want them, then try to invalidate.\n\t * If we fail, it's because pages are locked.... try again later.\n\t */\n\tif ((!is_delayed || mdsc->stopping) &&\n\t    ci->i_wrbuffer_ref == 0 &&               /* no dirty pages... */\n\t    inode->i_data.nrpages &&                 /* have cached pages */\n\t    (file_wanted == 0 ||                     /* no open files */\n\t     (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t  CEPH_CAP_FILE_LAZYIO))) && /*  or revoking cache */\n\t    !tried_invalidate) {\n\t\tdout(\"check_caps trying to invalidate on %p\\n\", inode);\n\t\tif (try_nonblocking_invalidate(inode) < 0) {\n\t\t\tif (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t\t\tCEPH_CAP_FILE_LAZYIO)) {\n\t\t\t\tdout(\"check_caps queuing invalidate\\n\");\n\t\t\t\tqueue_invalidate = 1;\n\t\t\t\tci->i_rdcache_revoking = ci->i_rdcache_gen;\n\t\t\t} else {\n\t\t\t\tdout(\"check_caps failed to invalidate pages\\n\");\n\t\t\t\t/* we failed to invalidate pages.  check these\n\t\t\t\t   caps again later. */\n\t\t\t\tforce_requeue = 1;\n\t\t\t\t__cap_set_timeouts(mdsc, ci);\n\t\t\t}\n\t\t}\n\t\ttried_invalidate = 1;\n\t\tgoto retry_locked;\n\t}\n\n\tnum = 0;\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tnum++;\n\n\t\t/* avoid looping forever */\n\t\tif (mds >= cap->mds ||\n\t\t    ((flags & CHECK_CAPS_AUTHONLY) && cap != ci->i_auth_cap))\n\t\t\tcontinue;\n\n\t\t/* NOTE: no side-effects allowed, until we take s_mutex */\n\n\t\tcap_used = used;\n\t\tif (ci->i_auth_cap && cap != ci->i_auth_cap)\n\t\t\tcap_used &= ~ci->i_auth_cap->issued;\n\n\t\trevoking = cap->implemented & ~cap->issued;\n\t\tdout(\" mds%d cap %p used %s issued %s implemented %s revoking %s\\n\",\n\t\t     cap->mds, cap, ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(cap_used),\n\t\t     ceph_cap_string(cap->implemented),\n\t\t     ceph_cap_string(revoking));\n\n\t\tif (cap == ci->i_auth_cap &&\n\t\t    (cap->issued & CEPH_CAP_FILE_WR)) {\n\t\t\t/* request larger max_size from MDS? */\n\t\t\tif (ci->i_wanted_max_size > ci->i_max_size &&\n\t\t\t    ci->i_wanted_max_size > ci->i_requested_max_size) {\n\t\t\t\tdout(\"requesting new max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\n\t\t\t/* approaching file_max? */\n\t\t\tif ((inode->i_size << 1) >= ci->i_max_size &&\n\t\t\t    (ci->i_reported_size << 1) < ci->i_max_size) {\n\t\t\t\tdout(\"i_size approaching max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\t\t}\n\t\t/* flush anything dirty? */\n\t\tif (cap == ci->i_auth_cap && (flags & CHECK_CAPS_FLUSH) &&\n\t\t    ci->i_dirty_caps) {\n\t\t\tdout(\"flushing dirty caps\\n\");\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* completed revocation? going down and there are no caps? */\n\t\tif (revoking && (revoking & cap_used) == 0) {\n\t\t\tdout(\"completed revocation of %s\\n\",\n\t\t\t     ceph_cap_string(cap->implemented & ~cap->issued));\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* want more caps from mds? */\n\t\tif (want & ~(cap->mds_wanted | cap->issued))\n\t\t\tgoto ack;\n\n\t\t/* things we might delay */\n\t\tif ((cap->issued & ~retain) == 0 &&\n\t\t    cap->mds_wanted == want)\n\t\t\tcontinue;     /* nope, all good */\n\n\t\tif (is_delayed)\n\t\t\tgoto ack;\n\n\t\t/* delay? */\n\t\tif ((ci->i_ceph_flags & CEPH_I_NODELAY) == 0 &&\n\t\t    time_before(jiffies, ci->i_hold_caps_max)) {\n\t\t\tdout(\" delaying issued %s -> %s, wanted %s -> %s\\n\",\n\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t     ceph_cap_string(cap->issued & retain),\n\t\t\t     ceph_cap_string(cap->mds_wanted),\n\t\t\t     ceph_cap_string(want));\n\t\t\tdelayed++;\n\t\t\tcontinue;\n\t\t}\n\nack:\n\t\tif (ci->i_ceph_flags & CEPH_I_NOFLUSH) {\n\t\t\tdout(\" skipping %p I_NOFLUSH set\\n\", inode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (session && session != cap->session) {\n\t\t\tdout(\"oops, wrong session %p mutex\\n\", session);\n\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tsession = NULL;\n\t\t}\n\t\tif (!session) {\n\t\t\tsession = cap->session;\n\t\t\tif (mutex_trylock(&session->s_mutex) == 0) {\n\t\t\t\tdout(\"inverting session/ino locks on %p\\n\",\n\t\t\t\t     session);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tif (took_snap_rwsem) {\n\t\t\t\t\tup_read(&mdsc->snap_rwsem);\n\t\t\t\t\ttook_snap_rwsem = 0;\n\t\t\t\t}\n\t\t\t\tmutex_lock(&session->s_mutex);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t\t/* take snap_rwsem after session mutex */\n\t\tif (!took_snap_rwsem) {\n\t\t\tif (down_read_trylock(&mdsc->snap_rwsem) == 0) {\n\t\t\t\tdout(\"inverting snap/in locks on %p\\n\",\n\t\t\t\t     inode);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tdown_read(&mdsc->snap_rwsem);\n\t\t\t\ttook_snap_rwsem = 1;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\ttook_snap_rwsem = 1;\n\t\t}\n\n\t\tif (cap == ci->i_auth_cap && ci->i_dirty_caps)\n\t\t\tflushing = __mark_caps_flushing(inode, session);\n\t\telse\n\t\t\tflushing = 0;\n\n\t\tmds = cap->mds;  /* remember mds, so we don't repeat */\n\t\tsent++;\n\n\t\t/* __send_cap drops i_ceph_lock */\n\t\tdelayed += __send_cap(mdsc, cap, CEPH_CAP_OP_UPDATE, cap_used,\n\t\t\t\t      want, retain, flushing, NULL);\n\t\tgoto retry; /* retake i_ceph_lock and restart our cap scan. */\n\t}\n\n\t/*\n\t * Reschedule delayed caps release if we delayed anything,\n\t * otherwise cancel.\n\t */\n\tif (delayed && is_delayed)\n\t\tforce_requeue = 1;   /* __send_cap delayed release; requeue */\n\tif (!delayed && !is_delayed)\n\t\t__cap_delay_cancel(mdsc, ci);\n\telse if (!is_delayed || force_requeue)\n\t\t__cap_delay_requeue(mdsc, ci);\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (queue_invalidate)\n\t\tceph_queue_invalidate(inode);\n\n\tif (session)\n\t\tmutex_unlock(&session->s_mutex);\n\tif (took_snap_rwsem)\n\t\tup_read(&mdsc->snap_rwsem);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_check_caps(struct ceph_inode_info *ci, int flags,\n\t\t     struct ceph_mds_session *session)\n{\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(&ci->vfs_inode);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct inode *inode = &ci->vfs_inode;\n\tstruct ceph_cap *cap;\n\tint file_wanted, used, cap_used;\n\tint took_snap_rwsem = 0;             /* true if mdsc->snap_rwsem held */\n\tint issued, implemented, want, retain, revoking, flushing = 0;\n\tint mds = -1;   /* keep track of how far we've gone through i_caps list\n\t\t\t   to avoid an infinite loop on retry */\n\tstruct rb_node *p;\n\tint tried_invalidate = 0;\n\tint delayed = 0, sent = 0, force_requeue = 0, num;\n\tint queue_invalidate = 0;\n\tint is_delayed = flags & CHECK_CAPS_NODELAY;\n\n\t/* if we are unmounting, flush any unused caps immediately. */\n\tif (mdsc->stopping)\n\t\tis_delayed = 1;\n\n\tspin_lock(&ci->i_ceph_lock);\n\n\tif (ci->i_ceph_flags & CEPH_I_FLUSH)\n\t\tflags |= CHECK_CAPS_FLUSH;\n\n\t/* flush snaps first time around only */\n\tif (!list_empty(&ci->i_cap_snaps))\n\t\t__ceph_flush_snaps(ci, &session, 0);\n\tgoto retry_locked;\nretry:\n\tspin_lock(&ci->i_ceph_lock);\nretry_locked:\n\tfile_wanted = __ceph_caps_file_wanted(ci);\n\tused = __ceph_caps_used(ci);\n\twant = file_wanted | used;\n\tissued = __ceph_caps_issued(ci, &implemented);\n\trevoking = implemented & ~issued;\n\n\tretain = want | CEPH_CAP_PIN;\n\tif (!mdsc->stopping && inode->i_nlink > 0) {\n\t\tif (want) {\n\t\t\tretain |= CEPH_CAP_ANY;       /* be greedy */\n\t\t} else {\n\t\t\tretain |= CEPH_CAP_ANY_SHARED;\n\t\t\t/*\n\t\t\t * keep RD only if we didn't have the file open RW,\n\t\t\t * because then the mds would revoke it anyway to\n\t\t\t * journal max_size=0.\n\t\t\t */\n\t\t\tif (ci->i_max_size == 0)\n\t\t\t\tretain |= CEPH_CAP_ANY_RD;\n\t\t}\n\t}\n\n\tdout(\"check_caps %p file_want %s used %s dirty %s flushing %s\"\n\t     \" issued %s revoking %s retain %s %s%s%s\\n\", inode,\n\t     ceph_cap_string(file_wanted),\n\t     ceph_cap_string(used), ceph_cap_string(ci->i_dirty_caps),\n\t     ceph_cap_string(ci->i_flushing_caps),\n\t     ceph_cap_string(issued), ceph_cap_string(revoking),\n\t     ceph_cap_string(retain),\n\t     (flags & CHECK_CAPS_AUTHONLY) ? \" AUTHONLY\" : \"\",\n\t     (flags & CHECK_CAPS_NODELAY) ? \" NODELAY\" : \"\",\n\t     (flags & CHECK_CAPS_FLUSH) ? \" FLUSH\" : \"\");\n\n\t/*\n\t * If we no longer need to hold onto old our caps, and we may\n\t * have cached pages, but don't want them, then try to invalidate.\n\t * If we fail, it's because pages are locked.... try again later.\n\t */\n\tif ((!is_delayed || mdsc->stopping) &&\n\t    ci->i_wrbuffer_ref == 0 &&               /* no dirty pages... */\n\t    inode->i_data.nrpages &&                 /* have cached pages */\n\t    (file_wanted == 0 ||                     /* no open files */\n\t     (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t  CEPH_CAP_FILE_LAZYIO))) && /*  or revoking cache */\n\t    !tried_invalidate) {\n\t\tdout(\"check_caps trying to invalidate on %p\\n\", inode);\n\t\tif (try_nonblocking_invalidate(inode) < 0) {\n\t\t\tif (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t\t\tCEPH_CAP_FILE_LAZYIO)) {\n\t\t\t\tdout(\"check_caps queuing invalidate\\n\");\n\t\t\t\tqueue_invalidate = 1;\n\t\t\t\tci->i_rdcache_revoking = ci->i_rdcache_gen;\n\t\t\t} else {\n\t\t\t\tdout(\"check_caps failed to invalidate pages\\n\");\n\t\t\t\t/* we failed to invalidate pages.  check these\n\t\t\t\t   caps again later. */\n\t\t\t\tforce_requeue = 1;\n\t\t\t\t__cap_set_timeouts(mdsc, ci);\n\t\t\t}\n\t\t}\n\t\ttried_invalidate = 1;\n\t\tgoto retry_locked;\n\t}\n\n\tnum = 0;\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tnum++;\n\n\t\t/* avoid looping forever */\n\t\tif (mds >= cap->mds ||\n\t\t    ((flags & CHECK_CAPS_AUTHONLY) && cap != ci->i_auth_cap))\n\t\t\tcontinue;\n\n\t\t/* NOTE: no side-effects allowed, until we take s_mutex */\n\n\t\tcap_used = used;\n\t\tif (ci->i_auth_cap && cap != ci->i_auth_cap)\n\t\t\tcap_used &= ~ci->i_auth_cap->issued;\n\n\t\trevoking = cap->implemented & ~cap->issued;\n\t\tdout(\" mds%d cap %p used %s issued %s implemented %s revoking %s\\n\",\n\t\t     cap->mds, cap, ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(cap_used),\n\t\t     ceph_cap_string(cap->implemented),\n\t\t     ceph_cap_string(revoking));\n\n\t\tif (cap == ci->i_auth_cap &&\n\t\t    (cap->issued & CEPH_CAP_FILE_WR)) {\n\t\t\t/* request larger max_size from MDS? */\n\t\t\tif (ci->i_wanted_max_size > ci->i_max_size &&\n\t\t\t    ci->i_wanted_max_size > ci->i_requested_max_size) {\n\t\t\t\tdout(\"requesting new max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\n\t\t\t/* approaching file_max? */\n\t\t\tif ((inode->i_size << 1) >= ci->i_max_size &&\n\t\t\t    (ci->i_reported_size << 1) < ci->i_max_size) {\n\t\t\t\tdout(\"i_size approaching max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\t\t}\n\t\t/* flush anything dirty? */\n\t\tif (cap == ci->i_auth_cap && (flags & CHECK_CAPS_FLUSH) &&\n\t\t    ci->i_dirty_caps) {\n\t\t\tdout(\"flushing dirty caps\\n\");\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* completed revocation? going down and there are no caps? */\n\t\tif (revoking && (revoking & cap_used) == 0) {\n\t\t\tdout(\"completed revocation of %s\\n\",\n\t\t\t     ceph_cap_string(cap->implemented & ~cap->issued));\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* want more caps from mds? */\n\t\tif (want & ~(cap->mds_wanted | cap->issued))\n\t\t\tgoto ack;\n\n\t\t/* things we might delay */\n\t\tif ((cap->issued & ~retain) == 0 &&\n\t\t    cap->mds_wanted == want)\n\t\t\tcontinue;     /* nope, all good */\n\n\t\tif (is_delayed)\n\t\t\tgoto ack;\n\n\t\t/* delay? */\n\t\tif ((ci->i_ceph_flags & CEPH_I_NODELAY) == 0 &&\n\t\t    time_before(jiffies, ci->i_hold_caps_max)) {\n\t\t\tdout(\" delaying issued %s -> %s, wanted %s -> %s\\n\",\n\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t     ceph_cap_string(cap->issued & retain),\n\t\t\t     ceph_cap_string(cap->mds_wanted),\n\t\t\t     ceph_cap_string(want));\n\t\t\tdelayed++;\n\t\t\tcontinue;\n\t\t}\n\nack:\n\t\tif (ci->i_ceph_flags & CEPH_I_NOFLUSH) {\n\t\t\tdout(\" skipping %p I_NOFLUSH set\\n\", inode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (session && session != cap->session) {\n\t\t\tdout(\"oops, wrong session %p mutex\\n\", session);\n\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tsession = NULL;\n\t\t}\n\t\tif (!session) {\n\t\t\tsession = cap->session;\n\t\t\tif (mutex_trylock(&session->s_mutex) == 0) {\n\t\t\t\tdout(\"inverting session/ino locks on %p\\n\",\n\t\t\t\t     session);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tif (took_snap_rwsem) {\n\t\t\t\t\tup_read(&mdsc->snap_rwsem);\n\t\t\t\t\ttook_snap_rwsem = 0;\n\t\t\t\t}\n\t\t\t\tmutex_lock(&session->s_mutex);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t\t/* take snap_rwsem after session mutex */\n\t\tif (!took_snap_rwsem) {\n\t\t\tif (down_read_trylock(&mdsc->snap_rwsem) == 0) {\n\t\t\t\tdout(\"inverting snap/in locks on %p\\n\",\n\t\t\t\t     inode);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tdown_read(&mdsc->snap_rwsem);\n\t\t\t\ttook_snap_rwsem = 1;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\ttook_snap_rwsem = 1;\n\t\t}\n\n\t\tif (cap == ci->i_auth_cap && ci->i_dirty_caps)\n\t\t\tflushing = __mark_caps_flushing(inode, session);\n\t\telse\n\t\t\tflushing = 0;\n\n\t\tmds = cap->mds;  /* remember mds, so we don't repeat */\n\t\tsent++;\n\n\t\t/* __send_cap drops i_ceph_lock */\n\t\tdelayed += __send_cap(mdsc, cap, CEPH_CAP_OP_UPDATE, cap_used,\n\t\t\t\t      want, retain, flushing, NULL);\n\t\tgoto retry; /* retake i_ceph_lock and restart our cap scan. */\n\t}\n\n\t/*\n\t * Reschedule delayed caps release if we delayed anything,\n\t * otherwise cancel.\n\t */\n\tif (delayed && is_delayed)\n\t\tforce_requeue = 1;   /* __send_cap delayed release; requeue */\n\tif (!delayed && !is_delayed)\n\t\t__cap_delay_cancel(mdsc, ci);\n\telse if (!is_delayed || force_requeue)\n\t\t__cap_delay_requeue(mdsc, ci);\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (queue_invalidate)\n\t\tceph_queue_invalidate(inode);\n\n\tif (session)\n\t\tmutex_unlock(&session->s_mutex);\n\tif (took_snap_rwsem)\n\t\tup_read(&mdsc->snap_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"ioctl_layzio: file %p marked lazy\\n\"",
            "file"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ioctl.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/in.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic long ceph_ioctl_lazyio(struct file *file)\n{\n\tstruct ceph_file_info *fi = file->private_data;\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tif ((fi->fmode & CEPH_FILE_MODE_LAZY) == 0) {\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tci->i_nr_by_mode[fi->fmode]--;\n\t\tfi->fmode |= CEPH_FILE_MODE_LAZY;\n\t\tci->i_nr_by_mode[fi->fmode]++;\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tdout(\"ioctl_layzio: file %p marked lazy\\n\", file);\n\n\t\tceph_check_caps(ci, 0, NULL);\n\t} else {\n\t\tdout(\"ioctl_layzio: file %p already lazy\\n\", file);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ceph_ioctl_get_dataloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/ioctl.c",
    "lines": "178-240",
    "snippet": "static long ceph_ioctl_get_dataloc(struct file *file, void __user *arg)\n{\n\tstruct ceph_ioctl_dataloc dl;\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_osd_client *osdc =\n\t\t&ceph_sb_to_client(inode->i_sb)->client->osdc;\n\tstruct ceph_object_locator oloc;\n\tstruct ceph_object_id oid;\n\tu64 len = 1, olen;\n\tu64 tmp;\n\tstruct ceph_pg pgid;\n\tint r;\n\n\t/* copy and validate */\n\tif (copy_from_user(&dl, arg, sizeof(dl)))\n\t\treturn -EFAULT;\n\n\tdown_read(&osdc->map_sem);\n\tr = ceph_calc_file_object_mapping(&ci->i_layout, dl.file_offset, len,\n\t\t\t\t\t  &dl.object_no, &dl.object_offset,\n\t\t\t\t\t  &olen);\n\tif (r < 0) {\n\t\tup_read(&osdc->map_sem);\n\t\treturn -EIO;\n\t}\n\tdl.file_offset -= dl.object_offset;\n\tdl.object_size = ceph_file_layout_object_size(ci->i_layout);\n\tdl.block_size = ceph_file_layout_su(ci->i_layout);\n\n\t/* block_offset = object_offset % block_size */\n\ttmp = dl.object_offset;\n\tdl.block_offset = do_div(tmp, dl.block_size);\n\n\tsnprintf(dl.object_name, sizeof(dl.object_name), \"%llx.%08llx\",\n\t\t ceph_ino(inode), dl.object_no);\n\n\toloc.pool = ceph_file_layout_pg_pool(ci->i_layout);\n\tceph_oid_set_name(&oid, dl.object_name);\n\n\tr = ceph_oloc_oid_to_pg(osdc->osdmap, &oloc, &oid, &pgid);\n\tif (r < 0) {\n\t\tup_read(&osdc->map_sem);\n\t\treturn r;\n\t}\n\n\tdl.osd = ceph_calc_pg_primary(osdc->osdmap, pgid);\n\tif (dl.osd >= 0) {\n\t\tstruct ceph_entity_addr *a =\n\t\t\tceph_osd_addr(osdc->osdmap, dl.osd);\n\t\tif (a)\n\t\t\tmemcpy(&dl.osd_addr, &a->in_addr, sizeof(dl.osd_addr));\n\t} else {\n\t\tmemset(&dl.osd_addr, 0, sizeof(dl.osd_addr));\n\t}\n\tup_read(&osdc->map_sem);\n\n\t/* send result back to user */\n\tif (copy_to_user(arg, &dl, sizeof(dl)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ioctl.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/in.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "arg",
            "&dl",
            "sizeof(dl)"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&osdc->map_sem"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&dl.osd_addr",
            "0",
            "sizeof(dl.osd_addr)"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&dl.osd_addr",
            "&a->in_addr",
            "sizeof(dl.osd_addr)"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_osd_addr",
          "args": [
            "osdc->osdmap",
            "dl.osd"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_calc_pg_primary",
          "args": [
            "osdc->osdmap",
            "pgid"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&osdc->map_sem"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_oloc_oid_to_pg",
          "args": [
            "osdc->osdmap",
            "&oloc",
            "&oid",
            "&pgid"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_oid_set_name",
          "args": [
            "&oid",
            "dl.object_name"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_file_layout_pg_pool",
          "args": [
            "ci->i_layout"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "dl.object_name",
            "sizeof(dl.object_name)",
            "\"%llx.%08llx\"",
            "ceph_ino(inode)",
            "dl.object_no"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_ino",
          "args": [
            "inode"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "412-415",
          "snippet": "static inline u64 ceph_ino(struct inode *inode)\n{\n\treturn ceph_inode(inode)->i_vino.ino;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline u64 ceph_ino(struct inode *inode)\n{\n\treturn ceph_inode(inode)->i_vino.ino;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "tmp",
            "dl.block_size"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_file_layout_su",
          "args": [
            "ci->i_layout"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_file_layout_object_size",
          "args": [
            "ci->i_layout"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&osdc->map_sem"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_calc_file_object_mapping",
          "args": [
            "&ci->i_layout",
            "dl.file_offset",
            "len",
            "&dl.object_no",
            "&dl.object_offset",
            "&olen"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&osdc->map_sem"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&dl",
            "arg",
            "sizeof(dl)"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_sb_to_client",
          "args": [
            "inode->i_sb"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_sb_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "352-355",
          "snippet": "static inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ioctl.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/in.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic long ceph_ioctl_get_dataloc(struct file *file, void __user *arg)\n{\n\tstruct ceph_ioctl_dataloc dl;\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_osd_client *osdc =\n\t\t&ceph_sb_to_client(inode->i_sb)->client->osdc;\n\tstruct ceph_object_locator oloc;\n\tstruct ceph_object_id oid;\n\tu64 len = 1, olen;\n\tu64 tmp;\n\tstruct ceph_pg pgid;\n\tint r;\n\n\t/* copy and validate */\n\tif (copy_from_user(&dl, arg, sizeof(dl)))\n\t\treturn -EFAULT;\n\n\tdown_read(&osdc->map_sem);\n\tr = ceph_calc_file_object_mapping(&ci->i_layout, dl.file_offset, len,\n\t\t\t\t\t  &dl.object_no, &dl.object_offset,\n\t\t\t\t\t  &olen);\n\tif (r < 0) {\n\t\tup_read(&osdc->map_sem);\n\t\treturn -EIO;\n\t}\n\tdl.file_offset -= dl.object_offset;\n\tdl.object_size = ceph_file_layout_object_size(ci->i_layout);\n\tdl.block_size = ceph_file_layout_su(ci->i_layout);\n\n\t/* block_offset = object_offset % block_size */\n\ttmp = dl.object_offset;\n\tdl.block_offset = do_div(tmp, dl.block_size);\n\n\tsnprintf(dl.object_name, sizeof(dl.object_name), \"%llx.%08llx\",\n\t\t ceph_ino(inode), dl.object_no);\n\n\toloc.pool = ceph_file_layout_pg_pool(ci->i_layout);\n\tceph_oid_set_name(&oid, dl.object_name);\n\n\tr = ceph_oloc_oid_to_pg(osdc->osdmap, &oloc, &oid, &pgid);\n\tif (r < 0) {\n\t\tup_read(&osdc->map_sem);\n\t\treturn r;\n\t}\n\n\tdl.osd = ceph_calc_pg_primary(osdc->osdmap, pgid);\n\tif (dl.osd >= 0) {\n\t\tstruct ceph_entity_addr *a =\n\t\t\tceph_osd_addr(osdc->osdmap, dl.osd);\n\t\tif (a)\n\t\t\tmemcpy(&dl.osd_addr, &a->in_addr, sizeof(dl.osd_addr));\n\t} else {\n\t\tmemset(&dl.osd_addr, 0, sizeof(dl.osd_addr));\n\t}\n\tup_read(&osdc->map_sem);\n\n\t/* send result back to user */\n\tif (copy_to_user(arg, &dl, sizeof(dl)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ceph_ioctl_set_layout_policy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/ioctl.c",
    "lines": "135-172",
    "snippet": "static long ceph_ioctl_set_layout_policy (struct file *file, void __user *arg)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_mds_request *req;\n\tstruct ceph_ioctl_layout l;\n\tint err;\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;\n\n\t/* copy and validate */\n\tif (copy_from_user(&l, arg, sizeof(l)))\n\t\treturn -EFAULT;\n\n\terr = __validate_layout(mdsc, &l);\n\tif (err)\n\t\treturn err;\n\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_SETDIRLAYOUT,\n\t\t\t\t       USE_AUTH_MDS);\n\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\treq->r_inode = inode;\n\tihold(inode);\n\treq->r_num_caps = 1;\n\n\treq->r_args.setlayout.layout.fl_stripe_unit =\n\t\t\tcpu_to_le32(l.stripe_unit);\n\treq->r_args.setlayout.layout.fl_stripe_count =\n\t\t\tcpu_to_le32(l.stripe_count);\n\treq->r_args.setlayout.layout.fl_object_size =\n\t\t\tcpu_to_le32(l.object_size);\n\treq->r_args.setlayout.layout.fl_pg_pool =\n\t\t\tcpu_to_le32(l.data_pool);\n\n\terr = ceph_mdsc_do_request(mdsc, inode, req);\n\tceph_mdsc_put_request(req);\n\treturn err;\n}",
    "includes": [
      "#include \"ioctl.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/in.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_mdsc_put_request",
          "args": [
            "req"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_put_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.h",
          "lines": "377-380",
          "snippet": "static inline void ceph_mdsc_put_request(struct ceph_mds_request *req)\n{\n\tkref_put(&req->r_kref, ceph_mdsc_release_request);\n}",
          "includes": [
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mdsmap.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/kref.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/auth.h>\n#include <linux/ceph/mdsmap.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/types.h>\n#include <linux/spinlock.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/kref.h>\n#include <linux/completion.h>\n\nstatic inline void ceph_mdsc_put_request(struct ceph_mds_request *req)\n{\n\tkref_put(&req->r_kref, ceph_mdsc_release_request);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_do_request",
          "args": [
            "mdsc",
            "inode",
            "req"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_do_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "2212-2284",
          "snippet": "int ceph_mdsc_do_request(struct ceph_mds_client *mdsc,\n\t\t\t struct inode *dir,\n\t\t\t struct ceph_mds_request *req)\n{\n\tint err;\n\n\tdout(\"do_request on %p\\n\", req);\n\n\t/* take CAP_PIN refs for r_inode, r_locked_dir, r_old_dentry */\n\tif (req->r_inode)\n\t\tceph_get_cap_refs(ceph_inode(req->r_inode), CEPH_CAP_PIN);\n\tif (req->r_locked_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_locked_dir), CEPH_CAP_PIN);\n\tif (req->r_old_dentry_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_old_dentry_dir),\n\t\t\t\t  CEPH_CAP_PIN);\n\n\t/* issue */\n\tmutex_lock(&mdsc->mutex);\n\t__register_request(mdsc, req, dir);\n\t__do_request(mdsc, req);\n\n\tif (req->r_err) {\n\t\terr = req->r_err;\n\t\t__unregister_request(mdsc, req);\n\t\tdout(\"do_request early error %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\t/* wait */\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request waiting\\n\");\n\tif (req->r_timeout) {\n\t\terr = (long)wait_for_completion_killable_timeout(\n\t\t\t&req->r_completion, req->r_timeout);\n\t\tif (err == 0)\n\t\t\terr = -EIO;\n\t} else if (req->r_wait_for_completion) {\n\t\terr = req->r_wait_for_completion(mdsc, req);\n\t} else {\n\t\terr = wait_for_completion_killable(&req->r_completion);\n\t}\n\tdout(\"do_request waited, got %d\\n\", err);\n\tmutex_lock(&mdsc->mutex);\n\n\t/* only abort if we didn't race with a real reply */\n\tif (req->r_got_result) {\n\t\terr = le32_to_cpu(req->r_reply_info.head->result);\n\t} else if (err < 0) {\n\t\tdout(\"aborted request %lld with %d\\n\", req->r_tid, err);\n\n\t\t/*\n\t\t * ensure we aren't running concurrently with\n\t\t * ceph_fill_trace or ceph_readdir_prepopulate, which\n\t\t * rely on locks (dir mutex) held by our caller.\n\t\t */\n\t\tmutex_lock(&req->r_fill_mutex);\n\t\treq->r_err = err;\n\t\treq->r_aborted = true;\n\t\tmutex_unlock(&req->r_fill_mutex);\n\n\t\tif (req->r_locked_dir &&\n\t\t    (req->r_op & CEPH_MDS_OP_WRITE))\n\t\t\tceph_invalidate_dir_request(req);\n\t} else {\n\t\terr = req->r_err;\n\t}\n\nout:\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request %p done, result %d\\n\", req, err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);\n\nint ceph_mdsc_do_request(struct ceph_mds_client *mdsc,\n\t\t\t struct inode *dir,\n\t\t\t struct ceph_mds_request *req)\n{\n\tint err;\n\n\tdout(\"do_request on %p\\n\", req);\n\n\t/* take CAP_PIN refs for r_inode, r_locked_dir, r_old_dentry */\n\tif (req->r_inode)\n\t\tceph_get_cap_refs(ceph_inode(req->r_inode), CEPH_CAP_PIN);\n\tif (req->r_locked_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_locked_dir), CEPH_CAP_PIN);\n\tif (req->r_old_dentry_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_old_dentry_dir),\n\t\t\t\t  CEPH_CAP_PIN);\n\n\t/* issue */\n\tmutex_lock(&mdsc->mutex);\n\t__register_request(mdsc, req, dir);\n\t__do_request(mdsc, req);\n\n\tif (req->r_err) {\n\t\terr = req->r_err;\n\t\t__unregister_request(mdsc, req);\n\t\tdout(\"do_request early error %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\t/* wait */\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request waiting\\n\");\n\tif (req->r_timeout) {\n\t\terr = (long)wait_for_completion_killable_timeout(\n\t\t\t&req->r_completion, req->r_timeout);\n\t\tif (err == 0)\n\t\t\terr = -EIO;\n\t} else if (req->r_wait_for_completion) {\n\t\terr = req->r_wait_for_completion(mdsc, req);\n\t} else {\n\t\terr = wait_for_completion_killable(&req->r_completion);\n\t}\n\tdout(\"do_request waited, got %d\\n\", err);\n\tmutex_lock(&mdsc->mutex);\n\n\t/* only abort if we didn't race with a real reply */\n\tif (req->r_got_result) {\n\t\terr = le32_to_cpu(req->r_reply_info.head->result);\n\t} else if (err < 0) {\n\t\tdout(\"aborted request %lld with %d\\n\", req->r_tid, err);\n\n\t\t/*\n\t\t * ensure we aren't running concurrently with\n\t\t * ceph_fill_trace or ceph_readdir_prepopulate, which\n\t\t * rely on locks (dir mutex) held by our caller.\n\t\t */\n\t\tmutex_lock(&req->r_fill_mutex);\n\t\treq->r_err = err;\n\t\treq->r_aborted = true;\n\t\tmutex_unlock(&req->r_fill_mutex);\n\n\t\tif (req->r_locked_dir &&\n\t\t    (req->r_op & CEPH_MDS_OP_WRITE))\n\t\t\tceph_invalidate_dir_request(req);\n\t} else {\n\t\terr = req->r_err;\n\t}\n\nout:\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request %p done, result %d\\n\", req, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "l.data_pool"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "l.object_size"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "l.stripe_count"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "l.stripe_unit"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "inode"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "req"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "req"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_create_request",
          "args": [
            "mdsc",
            "CEPH_MDS_OP_SETDIRLAYOUT",
            "USE_AUTH_MDS"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_create_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1640-1665",
          "snippet": "struct ceph_mds_request *\nceph_mdsc_create_request(struct ceph_mds_client *mdsc, int op, int mode)\n{\n\tstruct ceph_mds_request *req = kzalloc(sizeof(*req), GFP_NOFS);\n\n\tif (!req)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&req->r_fill_mutex);\n\treq->r_mdsc = mdsc;\n\treq->r_started = jiffies;\n\treq->r_resend_mds = -1;\n\tINIT_LIST_HEAD(&req->r_unsafe_dir_item);\n\treq->r_fmode = -1;\n\tkref_init(&req->r_kref);\n\tINIT_LIST_HEAD(&req->r_wait);\n\tinit_completion(&req->r_completion);\n\tinit_completion(&req->r_safe_completion);\n\tINIT_LIST_HEAD(&req->r_unsafe_item);\n\n\treq->r_stamp = CURRENT_TIME;\n\n\treq->r_op = op;\n\treq->r_direct_mode = mode;\n\treturn req;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct ceph_mds_request *\nceph_mdsc_create_request(struct ceph_mds_client *mdsc, int op, int mode)\n{\n\tstruct ceph_mds_request *req = kzalloc(sizeof(*req), GFP_NOFS);\n\n\tif (!req)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&req->r_fill_mutex);\n\treq->r_mdsc = mdsc;\n\treq->r_started = jiffies;\n\treq->r_resend_mds = -1;\n\tINIT_LIST_HEAD(&req->r_unsafe_dir_item);\n\treq->r_fmode = -1;\n\tkref_init(&req->r_kref);\n\tINIT_LIST_HEAD(&req->r_wait);\n\tinit_completion(&req->r_completion);\n\tinit_completion(&req->r_safe_completion);\n\tINIT_LIST_HEAD(&req->r_unsafe_item);\n\n\treq->r_stamp = CURRENT_TIME;\n\n\treq->r_op = op;\n\treq->r_direct_mode = mode;\n\treturn req;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__validate_layout",
          "args": [
            "mdsc",
            "&l"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "__validate_layout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/ioctl.c",
          "lines": "36-61",
          "snippet": "static long __validate_layout(struct ceph_mds_client *mdsc,\n\t\t\t      struct ceph_ioctl_layout *l)\n{\n\tint i, err;\n\n\t/* validate striping parameters */\n\tif ((l->object_size & ~PAGE_MASK) ||\n\t    (l->stripe_unit & ~PAGE_MASK) ||\n\t    ((unsigned)l->stripe_unit != 0 &&\n\t     ((unsigned)l->object_size % (unsigned)l->stripe_unit)))\n\t\treturn -EINVAL;\n\n\t/* make sure it's a valid data pool */\n\tmutex_lock(&mdsc->mutex);\n\terr = -EINVAL;\n\tfor (i = 0; i < mdsc->mdsmap->m_num_data_pg_pools; i++)\n\t\tif (mdsc->mdsmap->m_data_pg_pools[i] == l->data_pool) {\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\tmutex_unlock(&mdsc->mutex);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ioctl.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/in.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ioctl.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/in.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic long __validate_layout(struct ceph_mds_client *mdsc,\n\t\t\t      struct ceph_ioctl_layout *l)\n{\n\tint i, err;\n\n\t/* validate striping parameters */\n\tif ((l->object_size & ~PAGE_MASK) ||\n\t    (l->stripe_unit & ~PAGE_MASK) ||\n\t    ((unsigned)l->stripe_unit != 0 &&\n\t     ((unsigned)l->object_size % (unsigned)l->stripe_unit)))\n\t\treturn -EINVAL;\n\n\t/* make sure it's a valid data pool */\n\tmutex_lock(&mdsc->mutex);\n\terr = -EINVAL;\n\tfor (i = 0; i < mdsc->mdsmap->m_num_data_pg_pools; i++)\n\t\tif (mdsc->mdsmap->m_data_pg_pools[i] == l->data_pool) {\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\tmutex_unlock(&mdsc->mutex);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&l",
            "arg",
            "sizeof(l)"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_sb_to_client",
          "args": [
            "inode->i_sb"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_sb_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "352-355",
          "snippet": "static inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ioctl.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/in.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic long ceph_ioctl_set_layout_policy (struct file *file, void __user *arg)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_mds_request *req;\n\tstruct ceph_ioctl_layout l;\n\tint err;\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;\n\n\t/* copy and validate */\n\tif (copy_from_user(&l, arg, sizeof(l)))\n\t\treturn -EFAULT;\n\n\terr = __validate_layout(mdsc, &l);\n\tif (err)\n\t\treturn err;\n\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_SETDIRLAYOUT,\n\t\t\t\t       USE_AUTH_MDS);\n\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\treq->r_inode = inode;\n\tihold(inode);\n\treq->r_num_caps = 1;\n\n\treq->r_args.setlayout.layout.fl_stripe_unit =\n\t\t\tcpu_to_le32(l.stripe_unit);\n\treq->r_args.setlayout.layout.fl_stripe_count =\n\t\t\tcpu_to_le32(l.stripe_count);\n\treq->r_args.setlayout.layout.fl_object_size =\n\t\t\tcpu_to_le32(l.object_size);\n\treq->r_args.setlayout.layout.fl_pg_pool =\n\t\t\tcpu_to_le32(l.data_pool);\n\n\terr = ceph_mdsc_do_request(mdsc, inode, req);\n\tceph_mdsc_put_request(req);\n\treturn err;\n}"
  },
  {
    "function_name": "ceph_ioctl_set_layout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/ioctl.c",
    "lines": "63-127",
    "snippet": "static long ceph_ioctl_set_layout(struct file *file, void __user *arg)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;\n\tstruct ceph_mds_request *req;\n\tstruct ceph_ioctl_layout l;\n\tstruct ceph_inode_info *ci = ceph_inode(file_inode(file));\n\tstruct ceph_ioctl_layout nl;\n\tint err;\n\n\tif (copy_from_user(&l, arg, sizeof(l)))\n\t\treturn -EFAULT;\n\n\t/* validate changed params against current layout */\n\terr = ceph_do_getattr(file_inode(file), CEPH_STAT_CAP_LAYOUT, false);\n\tif (err)\n\t\treturn err;\n\n\tmemset(&nl, 0, sizeof(nl));\n\tif (l.stripe_count)\n\t\tnl.stripe_count = l.stripe_count;\n\telse\n\t\tnl.stripe_count = ceph_file_layout_stripe_count(ci->i_layout);\n\tif (l.stripe_unit)\n\t\tnl.stripe_unit = l.stripe_unit;\n\telse\n\t\tnl.stripe_unit = ceph_file_layout_su(ci->i_layout);\n\tif (l.object_size)\n\t\tnl.object_size = l.object_size;\n\telse\n\t\tnl.object_size = ceph_file_layout_object_size(ci->i_layout);\n\tif (l.data_pool)\n\t\tnl.data_pool = l.data_pool;\n\telse\n\t\tnl.data_pool = ceph_file_layout_pg_pool(ci->i_layout);\n\n\t/* this is obsolete, and always -1 */\n\tnl.preferred_osd = le64_to_cpu(-1);\n\n\terr = __validate_layout(mdsc, &nl);\n\tif (err)\n\t\treturn err;\n\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_SETLAYOUT,\n\t\t\t\t       USE_AUTH_MDS);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\treq->r_inode = inode;\n\tihold(inode);\n\treq->r_num_caps = 1;\n\n\treq->r_inode_drop = CEPH_CAP_FILE_SHARED | CEPH_CAP_FILE_EXCL;\n\n\treq->r_args.setlayout.layout.fl_stripe_unit =\n\t\tcpu_to_le32(l.stripe_unit);\n\treq->r_args.setlayout.layout.fl_stripe_count =\n\t\tcpu_to_le32(l.stripe_count);\n\treq->r_args.setlayout.layout.fl_object_size =\n\t\tcpu_to_le32(l.object_size);\n\treq->r_args.setlayout.layout.fl_pg_pool = cpu_to_le32(l.data_pool);\n\n\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\tceph_mdsc_put_request(req);\n\treturn err;\n}",
    "includes": [
      "#include \"ioctl.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/in.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_mdsc_put_request",
          "args": [
            "req"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_put_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.h",
          "lines": "377-380",
          "snippet": "static inline void ceph_mdsc_put_request(struct ceph_mds_request *req)\n{\n\tkref_put(&req->r_kref, ceph_mdsc_release_request);\n}",
          "includes": [
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mdsmap.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/kref.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/auth.h>\n#include <linux/ceph/mdsmap.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/types.h>\n#include <linux/spinlock.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/kref.h>\n#include <linux/completion.h>\n\nstatic inline void ceph_mdsc_put_request(struct ceph_mds_request *req)\n{\n\tkref_put(&req->r_kref, ceph_mdsc_release_request);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_do_request",
          "args": [
            "mdsc",
            "NULL",
            "req"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_do_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "2212-2284",
          "snippet": "int ceph_mdsc_do_request(struct ceph_mds_client *mdsc,\n\t\t\t struct inode *dir,\n\t\t\t struct ceph_mds_request *req)\n{\n\tint err;\n\n\tdout(\"do_request on %p\\n\", req);\n\n\t/* take CAP_PIN refs for r_inode, r_locked_dir, r_old_dentry */\n\tif (req->r_inode)\n\t\tceph_get_cap_refs(ceph_inode(req->r_inode), CEPH_CAP_PIN);\n\tif (req->r_locked_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_locked_dir), CEPH_CAP_PIN);\n\tif (req->r_old_dentry_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_old_dentry_dir),\n\t\t\t\t  CEPH_CAP_PIN);\n\n\t/* issue */\n\tmutex_lock(&mdsc->mutex);\n\t__register_request(mdsc, req, dir);\n\t__do_request(mdsc, req);\n\n\tif (req->r_err) {\n\t\terr = req->r_err;\n\t\t__unregister_request(mdsc, req);\n\t\tdout(\"do_request early error %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\t/* wait */\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request waiting\\n\");\n\tif (req->r_timeout) {\n\t\terr = (long)wait_for_completion_killable_timeout(\n\t\t\t&req->r_completion, req->r_timeout);\n\t\tif (err == 0)\n\t\t\terr = -EIO;\n\t} else if (req->r_wait_for_completion) {\n\t\terr = req->r_wait_for_completion(mdsc, req);\n\t} else {\n\t\terr = wait_for_completion_killable(&req->r_completion);\n\t}\n\tdout(\"do_request waited, got %d\\n\", err);\n\tmutex_lock(&mdsc->mutex);\n\n\t/* only abort if we didn't race with a real reply */\n\tif (req->r_got_result) {\n\t\terr = le32_to_cpu(req->r_reply_info.head->result);\n\t} else if (err < 0) {\n\t\tdout(\"aborted request %lld with %d\\n\", req->r_tid, err);\n\n\t\t/*\n\t\t * ensure we aren't running concurrently with\n\t\t * ceph_fill_trace or ceph_readdir_prepopulate, which\n\t\t * rely on locks (dir mutex) held by our caller.\n\t\t */\n\t\tmutex_lock(&req->r_fill_mutex);\n\t\treq->r_err = err;\n\t\treq->r_aborted = true;\n\t\tmutex_unlock(&req->r_fill_mutex);\n\n\t\tif (req->r_locked_dir &&\n\t\t    (req->r_op & CEPH_MDS_OP_WRITE))\n\t\t\tceph_invalidate_dir_request(req);\n\t} else {\n\t\terr = req->r_err;\n\t}\n\nout:\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request %p done, result %d\\n\", req, err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);\n\nint ceph_mdsc_do_request(struct ceph_mds_client *mdsc,\n\t\t\t struct inode *dir,\n\t\t\t struct ceph_mds_request *req)\n{\n\tint err;\n\n\tdout(\"do_request on %p\\n\", req);\n\n\t/* take CAP_PIN refs for r_inode, r_locked_dir, r_old_dentry */\n\tif (req->r_inode)\n\t\tceph_get_cap_refs(ceph_inode(req->r_inode), CEPH_CAP_PIN);\n\tif (req->r_locked_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_locked_dir), CEPH_CAP_PIN);\n\tif (req->r_old_dentry_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_old_dentry_dir),\n\t\t\t\t  CEPH_CAP_PIN);\n\n\t/* issue */\n\tmutex_lock(&mdsc->mutex);\n\t__register_request(mdsc, req, dir);\n\t__do_request(mdsc, req);\n\n\tif (req->r_err) {\n\t\terr = req->r_err;\n\t\t__unregister_request(mdsc, req);\n\t\tdout(\"do_request early error %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\t/* wait */\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request waiting\\n\");\n\tif (req->r_timeout) {\n\t\terr = (long)wait_for_completion_killable_timeout(\n\t\t\t&req->r_completion, req->r_timeout);\n\t\tif (err == 0)\n\t\t\terr = -EIO;\n\t} else if (req->r_wait_for_completion) {\n\t\terr = req->r_wait_for_completion(mdsc, req);\n\t} else {\n\t\terr = wait_for_completion_killable(&req->r_completion);\n\t}\n\tdout(\"do_request waited, got %d\\n\", err);\n\tmutex_lock(&mdsc->mutex);\n\n\t/* only abort if we didn't race with a real reply */\n\tif (req->r_got_result) {\n\t\terr = le32_to_cpu(req->r_reply_info.head->result);\n\t} else if (err < 0) {\n\t\tdout(\"aborted request %lld with %d\\n\", req->r_tid, err);\n\n\t\t/*\n\t\t * ensure we aren't running concurrently with\n\t\t * ceph_fill_trace or ceph_readdir_prepopulate, which\n\t\t * rely on locks (dir mutex) held by our caller.\n\t\t */\n\t\tmutex_lock(&req->r_fill_mutex);\n\t\treq->r_err = err;\n\t\treq->r_aborted = true;\n\t\tmutex_unlock(&req->r_fill_mutex);\n\n\t\tif (req->r_locked_dir &&\n\t\t    (req->r_op & CEPH_MDS_OP_WRITE))\n\t\t\tceph_invalidate_dir_request(req);\n\t} else {\n\t\terr = req->r_err;\n\t}\n\nout:\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request %p done, result %d\\n\", req, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "l.data_pool"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "l.object_size"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "l.stripe_count"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "l.stripe_unit"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "inode"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "req"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "req"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_create_request",
          "args": [
            "mdsc",
            "CEPH_MDS_OP_SETLAYOUT",
            "USE_AUTH_MDS"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_create_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1640-1665",
          "snippet": "struct ceph_mds_request *\nceph_mdsc_create_request(struct ceph_mds_client *mdsc, int op, int mode)\n{\n\tstruct ceph_mds_request *req = kzalloc(sizeof(*req), GFP_NOFS);\n\n\tif (!req)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&req->r_fill_mutex);\n\treq->r_mdsc = mdsc;\n\treq->r_started = jiffies;\n\treq->r_resend_mds = -1;\n\tINIT_LIST_HEAD(&req->r_unsafe_dir_item);\n\treq->r_fmode = -1;\n\tkref_init(&req->r_kref);\n\tINIT_LIST_HEAD(&req->r_wait);\n\tinit_completion(&req->r_completion);\n\tinit_completion(&req->r_safe_completion);\n\tINIT_LIST_HEAD(&req->r_unsafe_item);\n\n\treq->r_stamp = CURRENT_TIME;\n\n\treq->r_op = op;\n\treq->r_direct_mode = mode;\n\treturn req;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct ceph_mds_request *\nceph_mdsc_create_request(struct ceph_mds_client *mdsc, int op, int mode)\n{\n\tstruct ceph_mds_request *req = kzalloc(sizeof(*req), GFP_NOFS);\n\n\tif (!req)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&req->r_fill_mutex);\n\treq->r_mdsc = mdsc;\n\treq->r_started = jiffies;\n\treq->r_resend_mds = -1;\n\tINIT_LIST_HEAD(&req->r_unsafe_dir_item);\n\treq->r_fmode = -1;\n\tkref_init(&req->r_kref);\n\tINIT_LIST_HEAD(&req->r_wait);\n\tinit_completion(&req->r_completion);\n\tinit_completion(&req->r_safe_completion);\n\tINIT_LIST_HEAD(&req->r_unsafe_item);\n\n\treq->r_stamp = CURRENT_TIME;\n\n\treq->r_op = op;\n\treq->r_direct_mode = mode;\n\treturn req;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__validate_layout",
          "args": [
            "mdsc",
            "&nl"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "__validate_layout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/ioctl.c",
          "lines": "36-61",
          "snippet": "static long __validate_layout(struct ceph_mds_client *mdsc,\n\t\t\t      struct ceph_ioctl_layout *l)\n{\n\tint i, err;\n\n\t/* validate striping parameters */\n\tif ((l->object_size & ~PAGE_MASK) ||\n\t    (l->stripe_unit & ~PAGE_MASK) ||\n\t    ((unsigned)l->stripe_unit != 0 &&\n\t     ((unsigned)l->object_size % (unsigned)l->stripe_unit)))\n\t\treturn -EINVAL;\n\n\t/* make sure it's a valid data pool */\n\tmutex_lock(&mdsc->mutex);\n\terr = -EINVAL;\n\tfor (i = 0; i < mdsc->mdsmap->m_num_data_pg_pools; i++)\n\t\tif (mdsc->mdsmap->m_data_pg_pools[i] == l->data_pool) {\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\tmutex_unlock(&mdsc->mutex);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ioctl.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/in.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ioctl.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/in.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic long __validate_layout(struct ceph_mds_client *mdsc,\n\t\t\t      struct ceph_ioctl_layout *l)\n{\n\tint i, err;\n\n\t/* validate striping parameters */\n\tif ((l->object_size & ~PAGE_MASK) ||\n\t    (l->stripe_unit & ~PAGE_MASK) ||\n\t    ((unsigned)l->stripe_unit != 0 &&\n\t     ((unsigned)l->object_size % (unsigned)l->stripe_unit)))\n\t\treturn -EINVAL;\n\n\t/* make sure it's a valid data pool */\n\tmutex_lock(&mdsc->mutex);\n\terr = -EINVAL;\n\tfor (i = 0; i < mdsc->mdsmap->m_num_data_pg_pools; i++)\n\t\tif (mdsc->mdsmap->m_data_pg_pools[i] == l->data_pool) {\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\tmutex_unlock(&mdsc->mutex);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "-1"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_file_layout_pg_pool",
          "args": [
            "ci->i_layout"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_file_layout_object_size",
          "args": [
            "ci->i_layout"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_file_layout_su",
          "args": [
            "ci->i_layout"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_file_layout_stripe_count",
          "args": [
            "ci->i_layout"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&nl",
            "0",
            "sizeof(nl)"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_do_getattr",
          "args": [
            "file_inode(file)",
            "CEPH_STAT_CAP_LAYOUT",
            "false"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_do_getattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "751-754",
          "snippet": "static inline int ceph_do_getattr(struct inode *inode, int mask, bool force)\n{\n\treturn __ceph_do_getattr(inode, NULL, mask, force);\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline int ceph_do_getattr(struct inode *inode, int mask, bool force)\n{\n\treturn __ceph_do_getattr(inode, NULL, mask, force);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&l",
            "arg",
            "sizeof(l)"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "file_inode(file)"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_sb_to_client",
          "args": [
            "inode->i_sb"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_sb_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "352-355",
          "snippet": "static inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ioctl.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/in.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic long ceph_ioctl_set_layout(struct file *file, void __user *arg)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(inode->i_sb)->mdsc;\n\tstruct ceph_mds_request *req;\n\tstruct ceph_ioctl_layout l;\n\tstruct ceph_inode_info *ci = ceph_inode(file_inode(file));\n\tstruct ceph_ioctl_layout nl;\n\tint err;\n\n\tif (copy_from_user(&l, arg, sizeof(l)))\n\t\treturn -EFAULT;\n\n\t/* validate changed params against current layout */\n\terr = ceph_do_getattr(file_inode(file), CEPH_STAT_CAP_LAYOUT, false);\n\tif (err)\n\t\treturn err;\n\n\tmemset(&nl, 0, sizeof(nl));\n\tif (l.stripe_count)\n\t\tnl.stripe_count = l.stripe_count;\n\telse\n\t\tnl.stripe_count = ceph_file_layout_stripe_count(ci->i_layout);\n\tif (l.stripe_unit)\n\t\tnl.stripe_unit = l.stripe_unit;\n\telse\n\t\tnl.stripe_unit = ceph_file_layout_su(ci->i_layout);\n\tif (l.object_size)\n\t\tnl.object_size = l.object_size;\n\telse\n\t\tnl.object_size = ceph_file_layout_object_size(ci->i_layout);\n\tif (l.data_pool)\n\t\tnl.data_pool = l.data_pool;\n\telse\n\t\tnl.data_pool = ceph_file_layout_pg_pool(ci->i_layout);\n\n\t/* this is obsolete, and always -1 */\n\tnl.preferred_osd = le64_to_cpu(-1);\n\n\terr = __validate_layout(mdsc, &nl);\n\tif (err)\n\t\treturn err;\n\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_SETLAYOUT,\n\t\t\t\t       USE_AUTH_MDS);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\treq->r_inode = inode;\n\tihold(inode);\n\treq->r_num_caps = 1;\n\n\treq->r_inode_drop = CEPH_CAP_FILE_SHARED | CEPH_CAP_FILE_EXCL;\n\n\treq->r_args.setlayout.layout.fl_stripe_unit =\n\t\tcpu_to_le32(l.stripe_unit);\n\treq->r_args.setlayout.layout.fl_stripe_count =\n\t\tcpu_to_le32(l.stripe_count);\n\treq->r_args.setlayout.layout.fl_object_size =\n\t\tcpu_to_le32(l.object_size);\n\treq->r_args.setlayout.layout.fl_pg_pool = cpu_to_le32(l.data_pool);\n\n\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\tceph_mdsc_put_request(req);\n\treturn err;\n}"
  },
  {
    "function_name": "__validate_layout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/ioctl.c",
    "lines": "36-61",
    "snippet": "static long __validate_layout(struct ceph_mds_client *mdsc,\n\t\t\t      struct ceph_ioctl_layout *l)\n{\n\tint i, err;\n\n\t/* validate striping parameters */\n\tif ((l->object_size & ~PAGE_MASK) ||\n\t    (l->stripe_unit & ~PAGE_MASK) ||\n\t    ((unsigned)l->stripe_unit != 0 &&\n\t     ((unsigned)l->object_size % (unsigned)l->stripe_unit)))\n\t\treturn -EINVAL;\n\n\t/* make sure it's a valid data pool */\n\tmutex_lock(&mdsc->mutex);\n\terr = -EINVAL;\n\tfor (i = 0; i < mdsc->mdsmap->m_num_data_pg_pools; i++)\n\t\tif (mdsc->mdsmap->m_data_pg_pools[i] == l->data_pool) {\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\tmutex_unlock(&mdsc->mutex);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ioctl.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/in.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&mdsc->mutex"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ioctl.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/in.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic long __validate_layout(struct ceph_mds_client *mdsc,\n\t\t\t      struct ceph_ioctl_layout *l)\n{\n\tint i, err;\n\n\t/* validate striping parameters */\n\tif ((l->object_size & ~PAGE_MASK) ||\n\t    (l->stripe_unit & ~PAGE_MASK) ||\n\t    ((unsigned)l->stripe_unit != 0 &&\n\t     ((unsigned)l->object_size % (unsigned)l->stripe_unit)))\n\t\treturn -EINVAL;\n\n\t/* make sure it's a valid data pool */\n\tmutex_lock(&mdsc->mutex);\n\terr = -EINVAL;\n\tfor (i = 0; i < mdsc->mdsmap->m_num_data_pg_pools; i++)\n\t\tif (mdsc->mdsmap->m_data_pg_pools[i] == l->data_pool) {\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\tmutex_unlock(&mdsc->mutex);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ceph_ioctl_get_layout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/ioctl.c",
    "lines": "16-34",
    "snippet": "static long ceph_ioctl_get_layout(struct file *file, void __user *arg)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(file_inode(file));\n\tstruct ceph_ioctl_layout l;\n\tint err;\n\n\terr = ceph_do_getattr(file_inode(file), CEPH_STAT_CAP_LAYOUT, false);\n\tif (!err) {\n\t\tl.stripe_unit = ceph_file_layout_su(ci->i_layout);\n\t\tl.stripe_count = ceph_file_layout_stripe_count(ci->i_layout);\n\t\tl.object_size = ceph_file_layout_object_size(ci->i_layout);\n\t\tl.data_pool = le32_to_cpu(ci->i_layout.fl_pg_pool);\n\t\tl.preferred_osd = (s32)-1;\n\t\tif (copy_to_user(arg, &l, sizeof(l)))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include \"ioctl.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/in.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "arg",
            "&l",
            "sizeof(l)"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ci->i_layout.fl_pg_pool"
          ],
          "line": 27
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_file_layout_object_size",
          "args": [
            "ci->i_layout"
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_file_layout_stripe_count",
          "args": [
            "ci->i_layout"
          ],
          "line": 25
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_file_layout_su",
          "args": [
            "ci->i_layout"
          ],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_do_getattr",
          "args": [
            "file_inode(file)",
            "CEPH_STAT_CAP_LAYOUT",
            "false"
          ],
          "line": 22
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_do_getattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "751-754",
          "snippet": "static inline int ceph_do_getattr(struct inode *inode, int mask, bool force)\n{\n\treturn __ceph_do_getattr(inode, NULL, mask, force);\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline int ceph_do_getattr(struct inode *inode, int mask, bool force)\n{\n\treturn __ceph_do_getattr(inode, NULL, mask, force);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 22
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "file_inode(file)"
          ],
          "line": 18
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ioctl.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/in.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic long ceph_ioctl_get_layout(struct file *file, void __user *arg)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(file_inode(file));\n\tstruct ceph_ioctl_layout l;\n\tint err;\n\n\terr = ceph_do_getattr(file_inode(file), CEPH_STAT_CAP_LAYOUT, false);\n\tif (!err) {\n\t\tl.stripe_unit = ceph_file_layout_su(ci->i_layout);\n\t\tl.stripe_count = ceph_file_layout_stripe_count(ci->i_layout);\n\t\tl.object_size = ceph_file_layout_object_size(ci->i_layout);\n\t\tl.data_pool = le32_to_cpu(ci->i_layout.fl_pg_pool);\n\t\tl.preferred_osd = (s32)-1;\n\t\tif (copy_to_user(arg, &l, sizeof(l)))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn err;\n}"
  }
]