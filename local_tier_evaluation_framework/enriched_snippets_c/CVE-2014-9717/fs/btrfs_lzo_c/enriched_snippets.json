[
  {
    "function_name": "lzo_decompress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/lzo.c",
    "lines": "381-435",
    "snippet": "static int lzo_decompress(struct list_head *ws, unsigned char *data_in,\n\t\t\t  struct page *dest_page,\n\t\t\t  unsigned long start_byte,\n\t\t\t  size_t srclen, size_t destlen)\n{\n\tstruct workspace *workspace = list_entry(ws, struct workspace, list);\n\tsize_t in_len;\n\tsize_t out_len;\n\tsize_t tot_len;\n\tint ret = 0;\n\tchar *kaddr;\n\tunsigned long bytes;\n\n\tBUG_ON(srclen < LZO_LEN);\n\n\ttot_len = read_compress_length(data_in);\n\tdata_in += LZO_LEN;\n\n\tin_len = read_compress_length(data_in);\n\tdata_in += LZO_LEN;\n\n\tout_len = PAGE_CACHE_SIZE;\n\tret = lzo1x_decompress_safe(data_in, in_len, workspace->buf, &out_len);\n\tif (ret != LZO_E_OK) {\n\t\tprintk(KERN_WARNING \"BTRFS: decompress failed!\\n\");\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (out_len < start_byte) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * the caller is already checking against PAGE_SIZE, but lets\n\t * move this check closer to the memcpy/memset\n\t */\n\tdestlen = min_t(unsigned long, destlen, PAGE_SIZE);\n\tbytes = min_t(unsigned long, destlen, out_len - start_byte);\n\n\tkaddr = kmap_atomic(dest_page);\n\tmemcpy(kaddr, workspace->buf + start_byte, bytes);\n\n\t/*\n\t * btrfs_getblock is doing a zero on the tail of the page too,\n\t * but this will cover anything missing from the decompressed\n\t * data.\n\t */\n\tif (bytes < destlen)\n\t\tmemset(kaddr+bytes, 0, destlen-bytes);\n\tkunmap_atomic(kaddr);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"compression.h\"",
      "#include <linux/lzo.h>",
      "#include <linux/bio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>",
      "#include <linux/err.h>",
      "#include <linux/init.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define LZO_LEN\t4"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "kaddr+bytes",
            "0",
            "destlen-bytes"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "kaddr",
            "workspace->buf + start_byte",
            "bytes"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "dest_page"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedlong",
            "destlen",
            "out_len - start_byte"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedlong",
            "destlen",
            "PAGE_SIZE"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"BTRFS: decompress failed!\\n\""
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lzo1x_decompress_safe",
          "args": [
            "data_in",
            "in_len",
            "workspace->buf",
            "&out_len"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_compress_length",
          "args": [
            "data_in"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "read_compress_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/lzo.c",
          "lines": "79-85",
          "snippet": "static inline size_t read_compress_length(char *buf)\n{\n\t__le32 dlen;\n\n\tmemcpy(&dlen, buf, LZO_LEN);\n\treturn le32_to_cpu(dlen);\n}",
          "includes": [
            "#include \"compression.h\"",
            "#include <linux/lzo.h>",
            "#include <linux/bio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/init.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define LZO_LEN\t4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"compression.h\"\n#include <linux/lzo.h>\n#include <linux/bio.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\n#define LZO_LEN\t4\n\nstatic inline size_t read_compress_length(char *buf)\n{\n\t__le32 dlen;\n\n\tmemcpy(&dlen, buf, LZO_LEN);\n\treturn le32_to_cpu(dlen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "srclen < LZO_LEN"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "ws",
            "structworkspace",
            "list"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"compression.h\"\n#include <linux/lzo.h>\n#include <linux/bio.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\n#define LZO_LEN\t4\n\nstatic int lzo_decompress(struct list_head *ws, unsigned char *data_in,\n\t\t\t  struct page *dest_page,\n\t\t\t  unsigned long start_byte,\n\t\t\t  size_t srclen, size_t destlen)\n{\n\tstruct workspace *workspace = list_entry(ws, struct workspace, list);\n\tsize_t in_len;\n\tsize_t out_len;\n\tsize_t tot_len;\n\tint ret = 0;\n\tchar *kaddr;\n\tunsigned long bytes;\n\n\tBUG_ON(srclen < LZO_LEN);\n\n\ttot_len = read_compress_length(data_in);\n\tdata_in += LZO_LEN;\n\n\tin_len = read_compress_length(data_in);\n\tdata_in += LZO_LEN;\n\n\tout_len = PAGE_CACHE_SIZE;\n\tret = lzo1x_decompress_safe(data_in, in_len, workspace->buf, &out_len);\n\tif (ret != LZO_E_OK) {\n\t\tprintk(KERN_WARNING \"BTRFS: decompress failed!\\n\");\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (out_len < start_byte) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * the caller is already checking against PAGE_SIZE, but lets\n\t * move this check closer to the memcpy/memset\n\t */\n\tdestlen = min_t(unsigned long, destlen, PAGE_SIZE);\n\tbytes = min_t(unsigned long, destlen, out_len - start_byte);\n\n\tkaddr = kmap_atomic(dest_page);\n\tmemcpy(kaddr, workspace->buf + start_byte, bytes);\n\n\t/*\n\t * btrfs_getblock is doing a zero on the tail of the page too,\n\t * but this will cover anything missing from the decompressed\n\t * data.\n\t */\n\tif (bytes < destlen)\n\t\tmemset(kaddr+bytes, 0, destlen-bytes);\n\tkunmap_atomic(kaddr);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "lzo_decompress_biovec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/lzo.c",
    "lines": "257-379",
    "snippet": "static int lzo_decompress_biovec(struct list_head *ws,\n\t\t\t\t struct page **pages_in,\n\t\t\t\t u64 disk_start,\n\t\t\t\t struct bio_vec *bvec,\n\t\t\t\t int vcnt,\n\t\t\t\t size_t srclen)\n{\n\tstruct workspace *workspace = list_entry(ws, struct workspace, list);\n\tint ret = 0, ret2;\n\tchar *data_in;\n\tunsigned long page_in_index = 0;\n\tunsigned long page_out_index = 0;\n\tunsigned long total_pages_in = DIV_ROUND_UP(srclen, PAGE_CACHE_SIZE);\n\tunsigned long buf_start;\n\tunsigned long buf_offset = 0;\n\tunsigned long bytes;\n\tunsigned long working_bytes;\n\tunsigned long pg_offset;\n\n\tsize_t in_len;\n\tsize_t out_len;\n\tunsigned long in_offset;\n\tunsigned long in_page_bytes_left;\n\tunsigned long tot_in;\n\tunsigned long tot_out;\n\tunsigned long tot_len;\n\tchar *buf;\n\tbool may_late_unmap, need_unmap;\n\n\tdata_in = kmap(pages_in[0]);\n\ttot_len = read_compress_length(data_in);\n\n\ttot_in = LZO_LEN;\n\tin_offset = LZO_LEN;\n\ttot_len = min_t(size_t, srclen, tot_len);\n\tin_page_bytes_left = PAGE_CACHE_SIZE - LZO_LEN;\n\n\ttot_out = 0;\n\tpg_offset = 0;\n\n\twhile (tot_in < tot_len) {\n\t\tin_len = read_compress_length(data_in + in_offset);\n\t\tin_page_bytes_left -= LZO_LEN;\n\t\tin_offset += LZO_LEN;\n\t\ttot_in += LZO_LEN;\n\n\t\ttot_in += in_len;\n\t\tworking_bytes = in_len;\n\t\tmay_late_unmap = need_unmap = false;\n\n\t\t/* fast path: avoid using the working buffer */\n\t\tif (in_page_bytes_left >= in_len) {\n\t\t\tbuf = data_in + in_offset;\n\t\t\tbytes = in_len;\n\t\t\tmay_late_unmap = true;\n\t\t\tgoto cont;\n\t\t}\n\n\t\t/* copy bytes from the pages into the working buffer */\n\t\tbuf = workspace->cbuf;\n\t\tbuf_offset = 0;\n\t\twhile (working_bytes) {\n\t\t\tbytes = min(working_bytes, in_page_bytes_left);\n\n\t\t\tmemcpy(buf + buf_offset, data_in + in_offset, bytes);\n\t\t\tbuf_offset += bytes;\ncont:\n\t\t\tworking_bytes -= bytes;\n\t\t\tin_page_bytes_left -= bytes;\n\t\t\tin_offset += bytes;\n\n\t\t\t/* check if we need to pick another page */\n\t\t\tif ((working_bytes == 0 && in_page_bytes_left < LZO_LEN)\n\t\t\t    || in_page_bytes_left == 0) {\n\t\t\t\ttot_in += in_page_bytes_left;\n\n\t\t\t\tif (working_bytes == 0 && tot_in >= tot_len)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (page_in_index + 1 >= total_pages_in) {\n\t\t\t\t\tret = -EIO;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tif (may_late_unmap)\n\t\t\t\t\tneed_unmap = true;\n\t\t\t\telse\n\t\t\t\t\tkunmap(pages_in[page_in_index]);\n\n\t\t\t\tdata_in = kmap(pages_in[++page_in_index]);\n\n\t\t\t\tin_page_bytes_left = PAGE_CACHE_SIZE;\n\t\t\t\tin_offset = 0;\n\t\t\t}\n\t\t}\n\n\t\tout_len = lzo1x_worst_compress(PAGE_CACHE_SIZE);\n\t\tret = lzo1x_decompress_safe(buf, in_len, workspace->buf,\n\t\t\t\t\t    &out_len);\n\t\tif (need_unmap)\n\t\t\tkunmap(pages_in[page_in_index - 1]);\n\t\tif (ret != LZO_E_OK) {\n\t\t\tprintk(KERN_WARNING \"BTRFS: decompress failed\\n\");\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tbuf_start = tot_out;\n\t\ttot_out += out_len;\n\n\t\tret2 = btrfs_decompress_buf2page(workspace->buf, buf_start,\n\t\t\t\t\t\t tot_out, disk_start,\n\t\t\t\t\t\t bvec, vcnt,\n\t\t\t\t\t\t &page_out_index, &pg_offset);\n\t\tif (ret2 == 0)\n\t\t\tbreak;\n\t}\ndone:\n\tkunmap(pages_in[page_in_index]);\n\tif (!ret)\n\t\tbtrfs_clear_biovec_end(bvec, vcnt, page_out_index, pg_offset);\n\treturn ret;\n}",
    "includes": [
      "#include \"compression.h\"",
      "#include <linux/lzo.h>",
      "#include <linux/bio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>",
      "#include <linux/err.h>",
      "#include <linux/init.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define LZO_LEN\t4"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_clear_biovec_end",
          "args": [
            "bvec",
            "vcnt",
            "page_out_index",
            "pg_offset"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_clear_biovec_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/compression.c",
          "lines": "1069-1091",
          "snippet": "void btrfs_clear_biovec_end(struct bio_vec *bvec, int vcnt,\n\t\t\t\t   unsigned long pg_index,\n\t\t\t\t   unsigned long pg_offset)\n{\n\twhile (pg_index < vcnt) {\n\t\tstruct page *page = bvec[pg_index].bv_page;\n\t\tunsigned long off = bvec[pg_index].bv_offset;\n\t\tunsigned long len = bvec[pg_index].bv_len;\n\n\t\tif (pg_offset < off)\n\t\t\tpg_offset = off;\n\t\tif (pg_offset < off + len) {\n\t\t\tunsigned long bytes = off + len - pg_offset;\n\t\t\tchar *kaddr;\n\n\t\t\tkaddr = kmap_atomic(page);\n\t\t\tmemset(kaddr + pg_offset, 0, bytes);\n\t\t\tkunmap_atomic(kaddr);\n\t\t}\n\t\tpg_index++;\n\t\tpg_offset = 0;\n\t}\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include \"compression.h\"",
            "#include \"ordered-data.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include \"compression.h\"\n#include \"ordered-data.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nvoid btrfs_clear_biovec_end(struct bio_vec *bvec, int vcnt,\n\t\t\t\t   unsigned long pg_index,\n\t\t\t\t   unsigned long pg_offset)\n{\n\twhile (pg_index < vcnt) {\n\t\tstruct page *page = bvec[pg_index].bv_page;\n\t\tunsigned long off = bvec[pg_index].bv_offset;\n\t\tunsigned long len = bvec[pg_index].bv_len;\n\n\t\tif (pg_offset < off)\n\t\t\tpg_offset = off;\n\t\tif (pg_offset < off + len) {\n\t\t\tunsigned long bytes = off + len - pg_offset;\n\t\t\tchar *kaddr;\n\n\t\t\tkaddr = kmap_atomic(page);\n\t\t\tmemset(kaddr + pg_offset, 0, bytes);\n\t\t\tkunmap_atomic(kaddr);\n\t\t}\n\t\tpg_index++;\n\t\tpg_offset = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "pages_in[page_in_index]"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_decompress_buf2page",
          "args": [
            "workspace->buf",
            "buf_start",
            "tot_out",
            "disk_start",
            "bvec",
            "vcnt",
            "&page_out_index",
            "&pg_offset"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_decompress_buf2page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/compression.c",
          "lines": "977-1060",
          "snippet": "int btrfs_decompress_buf2page(char *buf, unsigned long buf_start,\n\t\t\t      unsigned long total_out, u64 disk_start,\n\t\t\t      struct bio_vec *bvec, int vcnt,\n\t\t\t      unsigned long *pg_index,\n\t\t\t      unsigned long *pg_offset)\n{\n\tunsigned long buf_offset;\n\tunsigned long current_buf_start;\n\tunsigned long start_byte;\n\tunsigned long working_bytes = total_out - buf_start;\n\tunsigned long bytes;\n\tchar *kaddr;\n\tstruct page *page_out = bvec[*pg_index].bv_page;\n\n\t/*\n\t * start byte is the first byte of the page we're currently\n\t * copying into relative to the start of the compressed data.\n\t */\n\tstart_byte = page_offset(page_out) - disk_start;\n\n\t/* we haven't yet hit data corresponding to this page */\n\tif (total_out <= start_byte)\n\t\treturn 1;\n\n\t/*\n\t * the start of the data we care about is offset into\n\t * the middle of our working buffer\n\t */\n\tif (total_out > start_byte && buf_start < start_byte) {\n\t\tbuf_offset = start_byte - buf_start;\n\t\tworking_bytes -= buf_offset;\n\t} else {\n\t\tbuf_offset = 0;\n\t}\n\tcurrent_buf_start = buf_start;\n\n\t/* copy bytes from the working buffer into the pages */\n\twhile (working_bytes > 0) {\n\t\tbytes = min(PAGE_CACHE_SIZE - *pg_offset,\n\t\t\t    PAGE_CACHE_SIZE - buf_offset);\n\t\tbytes = min(bytes, working_bytes);\n\t\tkaddr = kmap_atomic(page_out);\n\t\tmemcpy(kaddr + *pg_offset, buf + buf_offset, bytes);\n\t\tkunmap_atomic(kaddr);\n\t\tflush_dcache_page(page_out);\n\n\t\t*pg_offset += bytes;\n\t\tbuf_offset += bytes;\n\t\tworking_bytes -= bytes;\n\t\tcurrent_buf_start += bytes;\n\n\t\t/* check if we need to pick another page */\n\t\tif (*pg_offset == PAGE_CACHE_SIZE) {\n\t\t\t(*pg_index)++;\n\t\t\tif (*pg_index >= vcnt)\n\t\t\t\treturn 0;\n\n\t\t\tpage_out = bvec[*pg_index].bv_page;\n\t\t\t*pg_offset = 0;\n\t\t\tstart_byte = page_offset(page_out) - disk_start;\n\n\t\t\t/*\n\t\t\t * make sure our new page is covered by this\n\t\t\t * working buffer\n\t\t\t */\n\t\t\tif (total_out <= start_byte)\n\t\t\t\treturn 1;\n\n\t\t\t/*\n\t\t\t * the next page in the biovec might not be adjacent\n\t\t\t * to the last page, but it might still be found\n\t\t\t * inside this working buffer. bump our offset pointer\n\t\t\t */\n\t\t\tif (total_out > start_byte &&\n\t\t\t    current_buf_start < start_byte) {\n\t\t\t\tbuf_offset = start_byte - buf_start;\n\t\t\t\tworking_bytes = total_out - start_byte;\n\t\t\t\tcurrent_buf_start = buf_start + buf_offset;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include \"compression.h\"",
            "#include \"ordered-data.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include \"compression.h\"\n#include \"ordered-data.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nint btrfs_decompress_buf2page(char *buf, unsigned long buf_start,\n\t\t\t      unsigned long total_out, u64 disk_start,\n\t\t\t      struct bio_vec *bvec, int vcnt,\n\t\t\t      unsigned long *pg_index,\n\t\t\t      unsigned long *pg_offset)\n{\n\tunsigned long buf_offset;\n\tunsigned long current_buf_start;\n\tunsigned long start_byte;\n\tunsigned long working_bytes = total_out - buf_start;\n\tunsigned long bytes;\n\tchar *kaddr;\n\tstruct page *page_out = bvec[*pg_index].bv_page;\n\n\t/*\n\t * start byte is the first byte of the page we're currently\n\t * copying into relative to the start of the compressed data.\n\t */\n\tstart_byte = page_offset(page_out) - disk_start;\n\n\t/* we haven't yet hit data corresponding to this page */\n\tif (total_out <= start_byte)\n\t\treturn 1;\n\n\t/*\n\t * the start of the data we care about is offset into\n\t * the middle of our working buffer\n\t */\n\tif (total_out > start_byte && buf_start < start_byte) {\n\t\tbuf_offset = start_byte - buf_start;\n\t\tworking_bytes -= buf_offset;\n\t} else {\n\t\tbuf_offset = 0;\n\t}\n\tcurrent_buf_start = buf_start;\n\n\t/* copy bytes from the working buffer into the pages */\n\twhile (working_bytes > 0) {\n\t\tbytes = min(PAGE_CACHE_SIZE - *pg_offset,\n\t\t\t    PAGE_CACHE_SIZE - buf_offset);\n\t\tbytes = min(bytes, working_bytes);\n\t\tkaddr = kmap_atomic(page_out);\n\t\tmemcpy(kaddr + *pg_offset, buf + buf_offset, bytes);\n\t\tkunmap_atomic(kaddr);\n\t\tflush_dcache_page(page_out);\n\n\t\t*pg_offset += bytes;\n\t\tbuf_offset += bytes;\n\t\tworking_bytes -= bytes;\n\t\tcurrent_buf_start += bytes;\n\n\t\t/* check if we need to pick another page */\n\t\tif (*pg_offset == PAGE_CACHE_SIZE) {\n\t\t\t(*pg_index)++;\n\t\t\tif (*pg_index >= vcnt)\n\t\t\t\treturn 0;\n\n\t\t\tpage_out = bvec[*pg_index].bv_page;\n\t\t\t*pg_offset = 0;\n\t\t\tstart_byte = page_offset(page_out) - disk_start;\n\n\t\t\t/*\n\t\t\t * make sure our new page is covered by this\n\t\t\t * working buffer\n\t\t\t */\n\t\t\tif (total_out <= start_byte)\n\t\t\t\treturn 1;\n\n\t\t\t/*\n\t\t\t * the next page in the biovec might not be adjacent\n\t\t\t * to the last page, but it might still be found\n\t\t\t * inside this working buffer. bump our offset pointer\n\t\t\t */\n\t\t\tif (total_out > start_byte &&\n\t\t\t    current_buf_start < start_byte) {\n\t\t\t\tbuf_offset = start_byte - buf_start;\n\t\t\t\tworking_bytes = total_out - start_byte;\n\t\t\t\tcurrent_buf_start = buf_start + buf_offset;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"BTRFS: decompress failed\\n\""
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "pages_in[page_in_index - 1]"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lzo1x_decompress_safe",
          "args": [
            "buf",
            "in_len",
            "workspace->buf",
            "&out_len"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lzo1x_worst_compress",
          "args": [
            "PAGE_CACHE_SIZE"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "pages_in[++page_in_index]"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "pages_in[page_in_index]"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf + buf_offset",
            "data_in + in_offset",
            "bytes"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "working_bytes",
            "in_page_bytes_left"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_compress_length",
          "args": [
            "data_in + in_offset"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "read_compress_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/lzo.c",
          "lines": "79-85",
          "snippet": "static inline size_t read_compress_length(char *buf)\n{\n\t__le32 dlen;\n\n\tmemcpy(&dlen, buf, LZO_LEN);\n\treturn le32_to_cpu(dlen);\n}",
          "includes": [
            "#include \"compression.h\"",
            "#include <linux/lzo.h>",
            "#include <linux/bio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/init.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define LZO_LEN\t4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"compression.h\"\n#include <linux/lzo.h>\n#include <linux/bio.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\n#define LZO_LEN\t4\n\nstatic inline size_t read_compress_length(char *buf)\n{\n\t__le32 dlen;\n\n\tmemcpy(&dlen, buf, LZO_LEN);\n\treturn le32_to_cpu(dlen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "srclen",
            "tot_len"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "pages_in[0]"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "srclen",
            "PAGE_CACHE_SIZE"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "ws",
            "structworkspace",
            "list"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"compression.h\"\n#include <linux/lzo.h>\n#include <linux/bio.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\n#define LZO_LEN\t4\n\nstatic int lzo_decompress_biovec(struct list_head *ws,\n\t\t\t\t struct page **pages_in,\n\t\t\t\t u64 disk_start,\n\t\t\t\t struct bio_vec *bvec,\n\t\t\t\t int vcnt,\n\t\t\t\t size_t srclen)\n{\n\tstruct workspace *workspace = list_entry(ws, struct workspace, list);\n\tint ret = 0, ret2;\n\tchar *data_in;\n\tunsigned long page_in_index = 0;\n\tunsigned long page_out_index = 0;\n\tunsigned long total_pages_in = DIV_ROUND_UP(srclen, PAGE_CACHE_SIZE);\n\tunsigned long buf_start;\n\tunsigned long buf_offset = 0;\n\tunsigned long bytes;\n\tunsigned long working_bytes;\n\tunsigned long pg_offset;\n\n\tsize_t in_len;\n\tsize_t out_len;\n\tunsigned long in_offset;\n\tunsigned long in_page_bytes_left;\n\tunsigned long tot_in;\n\tunsigned long tot_out;\n\tunsigned long tot_len;\n\tchar *buf;\n\tbool may_late_unmap, need_unmap;\n\n\tdata_in = kmap(pages_in[0]);\n\ttot_len = read_compress_length(data_in);\n\n\ttot_in = LZO_LEN;\n\tin_offset = LZO_LEN;\n\ttot_len = min_t(size_t, srclen, tot_len);\n\tin_page_bytes_left = PAGE_CACHE_SIZE - LZO_LEN;\n\n\ttot_out = 0;\n\tpg_offset = 0;\n\n\twhile (tot_in < tot_len) {\n\t\tin_len = read_compress_length(data_in + in_offset);\n\t\tin_page_bytes_left -= LZO_LEN;\n\t\tin_offset += LZO_LEN;\n\t\ttot_in += LZO_LEN;\n\n\t\ttot_in += in_len;\n\t\tworking_bytes = in_len;\n\t\tmay_late_unmap = need_unmap = false;\n\n\t\t/* fast path: avoid using the working buffer */\n\t\tif (in_page_bytes_left >= in_len) {\n\t\t\tbuf = data_in + in_offset;\n\t\t\tbytes = in_len;\n\t\t\tmay_late_unmap = true;\n\t\t\tgoto cont;\n\t\t}\n\n\t\t/* copy bytes from the pages into the working buffer */\n\t\tbuf = workspace->cbuf;\n\t\tbuf_offset = 0;\n\t\twhile (working_bytes) {\n\t\t\tbytes = min(working_bytes, in_page_bytes_left);\n\n\t\t\tmemcpy(buf + buf_offset, data_in + in_offset, bytes);\n\t\t\tbuf_offset += bytes;\ncont:\n\t\t\tworking_bytes -= bytes;\n\t\t\tin_page_bytes_left -= bytes;\n\t\t\tin_offset += bytes;\n\n\t\t\t/* check if we need to pick another page */\n\t\t\tif ((working_bytes == 0 && in_page_bytes_left < LZO_LEN)\n\t\t\t    || in_page_bytes_left == 0) {\n\t\t\t\ttot_in += in_page_bytes_left;\n\n\t\t\t\tif (working_bytes == 0 && tot_in >= tot_len)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (page_in_index + 1 >= total_pages_in) {\n\t\t\t\t\tret = -EIO;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tif (may_late_unmap)\n\t\t\t\t\tneed_unmap = true;\n\t\t\t\telse\n\t\t\t\t\tkunmap(pages_in[page_in_index]);\n\n\t\t\t\tdata_in = kmap(pages_in[++page_in_index]);\n\n\t\t\t\tin_page_bytes_left = PAGE_CACHE_SIZE;\n\t\t\t\tin_offset = 0;\n\t\t\t}\n\t\t}\n\n\t\tout_len = lzo1x_worst_compress(PAGE_CACHE_SIZE);\n\t\tret = lzo1x_decompress_safe(buf, in_len, workspace->buf,\n\t\t\t\t\t    &out_len);\n\t\tif (need_unmap)\n\t\t\tkunmap(pages_in[page_in_index - 1]);\n\t\tif (ret != LZO_E_OK) {\n\t\t\tprintk(KERN_WARNING \"BTRFS: decompress failed\\n\");\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tbuf_start = tot_out;\n\t\ttot_out += out_len;\n\n\t\tret2 = btrfs_decompress_buf2page(workspace->buf, buf_start,\n\t\t\t\t\t\t tot_out, disk_start,\n\t\t\t\t\t\t bvec, vcnt,\n\t\t\t\t\t\t &page_out_index, &pg_offset);\n\t\tif (ret2 == 0)\n\t\t\tbreak;\n\t}\ndone:\n\tkunmap(pages_in[page_in_index]);\n\tif (!ret)\n\t\tbtrfs_clear_biovec_end(bvec, vcnt, page_out_index, pg_offset);\n\treturn ret;\n}"
  },
  {
    "function_name": "lzo_compress_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/lzo.c",
    "lines": "87-255",
    "snippet": "static int lzo_compress_pages(struct list_head *ws,\n\t\t\t      struct address_space *mapping,\n\t\t\t      u64 start, unsigned long len,\n\t\t\t      struct page **pages,\n\t\t\t      unsigned long nr_dest_pages,\n\t\t\t      unsigned long *out_pages,\n\t\t\t      unsigned long *total_in,\n\t\t\t      unsigned long *total_out,\n\t\t\t      unsigned long max_out)\n{\n\tstruct workspace *workspace = list_entry(ws, struct workspace, list);\n\tint ret = 0;\n\tchar *data_in;\n\tchar *cpage_out;\n\tint nr_pages = 0;\n\tstruct page *in_page = NULL;\n\tstruct page *out_page = NULL;\n\tunsigned long bytes_left;\n\n\tsize_t in_len;\n\tsize_t out_len;\n\tchar *buf;\n\tunsigned long tot_in = 0;\n\tunsigned long tot_out = 0;\n\tunsigned long pg_bytes_left;\n\tunsigned long out_offset;\n\tunsigned long bytes;\n\n\t*out_pages = 0;\n\t*total_out = 0;\n\t*total_in = 0;\n\n\tin_page = find_get_page(mapping, start >> PAGE_CACHE_SHIFT);\n\tdata_in = kmap(in_page);\n\n\t/*\n\t * store the size of all chunks of compressed data in\n\t * the first 4 bytes\n\t */\n\tout_page = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\tif (out_page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tcpage_out = kmap(out_page);\n\tout_offset = LZO_LEN;\n\ttot_out = LZO_LEN;\n\tpages[0] = out_page;\n\tnr_pages = 1;\n\tpg_bytes_left = PAGE_CACHE_SIZE - LZO_LEN;\n\n\t/* compress at most one page of data each time */\n\tin_len = min(len, PAGE_CACHE_SIZE);\n\twhile (tot_in < len) {\n\t\tret = lzo1x_1_compress(data_in, in_len, workspace->cbuf,\n\t\t\t\t       &out_len, workspace->mem);\n\t\tif (ret != LZO_E_OK) {\n\t\t\tprintk(KERN_DEBUG \"BTRFS: deflate in loop returned %d\\n\",\n\t\t\t       ret);\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* store the size of this chunk of compressed data */\n\t\twrite_compress_length(cpage_out + out_offset, out_len);\n\t\ttot_out += LZO_LEN;\n\t\tout_offset += LZO_LEN;\n\t\tpg_bytes_left -= LZO_LEN;\n\n\t\ttot_in += in_len;\n\t\ttot_out += out_len;\n\n\t\t/* copy bytes from the working buffer into the pages */\n\t\tbuf = workspace->cbuf;\n\t\twhile (out_len) {\n\t\t\tbytes = min_t(unsigned long, pg_bytes_left, out_len);\n\n\t\t\tmemcpy(cpage_out + out_offset, buf, bytes);\n\n\t\t\tout_len -= bytes;\n\t\t\tpg_bytes_left -= bytes;\n\t\t\tbuf += bytes;\n\t\t\tout_offset += bytes;\n\n\t\t\t/*\n\t\t\t * we need another page for writing out.\n\t\t\t *\n\t\t\t * Note if there's less than 4 bytes left, we just\n\t\t\t * skip to a new page.\n\t\t\t */\n\t\t\tif ((out_len == 0 && pg_bytes_left < LZO_LEN) ||\n\t\t\t    pg_bytes_left == 0) {\n\t\t\t\tif (pg_bytes_left) {\n\t\t\t\t\tmemset(cpage_out + out_offset, 0,\n\t\t\t\t\t       pg_bytes_left);\n\t\t\t\t\ttot_out += pg_bytes_left;\n\t\t\t\t}\n\n\t\t\t\t/* we're done, don't allocate new page */\n\t\t\t\tif (out_len == 0 && tot_in >= len)\n\t\t\t\t\tbreak;\n\n\t\t\t\tkunmap(out_page);\n\t\t\t\tif (nr_pages == nr_dest_pages) {\n\t\t\t\t\tout_page = NULL;\n\t\t\t\t\tret = -E2BIG;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tout_page = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\t\t\t\tif (out_page == NULL) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tcpage_out = kmap(out_page);\n\t\t\t\tpages[nr_pages++] = out_page;\n\n\t\t\t\tpg_bytes_left = PAGE_CACHE_SIZE;\n\t\t\t\tout_offset = 0;\n\t\t\t}\n\t\t}\n\n\t\t/* we're making it bigger, give up */\n\t\tif (tot_in > 8192 && tot_in < tot_out) {\n\t\t\tret = -E2BIG;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* we're all done */\n\t\tif (tot_in >= len)\n\t\t\tbreak;\n\n\t\tif (tot_out > max_out)\n\t\t\tbreak;\n\n\t\tbytes_left = len - tot_in;\n\t\tkunmap(in_page);\n\t\tpage_cache_release(in_page);\n\n\t\tstart += PAGE_CACHE_SIZE;\n\t\tin_page = find_get_page(mapping, start >> PAGE_CACHE_SHIFT);\n\t\tdata_in = kmap(in_page);\n\t\tin_len = min(bytes_left, PAGE_CACHE_SIZE);\n\t}\n\n\tif (tot_out > tot_in)\n\t\tgoto out;\n\n\t/* store the size of all chunks of compressed data */\n\tcpage_out = kmap(pages[0]);\n\twrite_compress_length(cpage_out, tot_out);\n\n\tkunmap(pages[0]);\n\n\tret = 0;\n\t*total_out = tot_out;\n\t*total_in = tot_in;\nout:\n\t*out_pages = nr_pages;\n\tif (out_page)\n\t\tkunmap(out_page);\n\n\tif (in_page) {\n\t\tkunmap(in_page);\n\t\tpage_cache_release(in_page);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"compression.h\"",
      "#include <linux/lzo.h>",
      "#include <linux/bio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>",
      "#include <linux/err.h>",
      "#include <linux/init.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define LZO_LEN\t4"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "in_page"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "in_page"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "out_page"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "pages[0]"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_compress_length",
          "args": [
            "cpage_out",
            "tot_out"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "write_compress_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/lzo.c",
          "lines": "71-77",
          "snippet": "static inline void write_compress_length(char *buf, size_t len)\n{\n\t__le32 dlen;\n\n\tdlen = cpu_to_le32(len);\n\tmemcpy(buf, &dlen, LZO_LEN);\n}",
          "includes": [
            "#include \"compression.h\"",
            "#include <linux/lzo.h>",
            "#include <linux/bio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/init.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define LZO_LEN\t4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"compression.h\"\n#include <linux/lzo.h>\n#include <linux/bio.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\n#define LZO_LEN\t4\n\nstatic inline void write_compress_length(char *buf, size_t len)\n{\n\t__le32 dlen;\n\n\tdlen = cpu_to_le32(len);\n\tmemcpy(buf, &dlen, LZO_LEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "pages[0]"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "bytes_left",
            "PAGE_CACHE_SIZE"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "in_page"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_page",
          "args": [
            "mapping",
            "start >> PAGE_CACHE_SHIFT"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "in_page"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "in_page"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "out_page"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_NOFS | __GFP_HIGHMEM"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "out_page"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "cpage_out + out_offset",
            "0",
            "pg_bytes_left"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cpage_out + out_offset",
            "buf",
            "bytes"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedlong",
            "pg_bytes_left",
            "out_len"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"BTRFS: deflate in loop returned %d\\n\"",
            "ret"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lzo1x_1_compress",
          "args": [
            "data_in",
            "in_len",
            "workspace->cbuf",
            "&out_len",
            "workspace->mem"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "out_page"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "in_page"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_page",
          "args": [
            "mapping",
            "start >> PAGE_CACHE_SHIFT"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "ws",
            "structworkspace",
            "list"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"compression.h\"\n#include <linux/lzo.h>\n#include <linux/bio.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\n#define LZO_LEN\t4\n\nstatic int lzo_compress_pages(struct list_head *ws,\n\t\t\t      struct address_space *mapping,\n\t\t\t      u64 start, unsigned long len,\n\t\t\t      struct page **pages,\n\t\t\t      unsigned long nr_dest_pages,\n\t\t\t      unsigned long *out_pages,\n\t\t\t      unsigned long *total_in,\n\t\t\t      unsigned long *total_out,\n\t\t\t      unsigned long max_out)\n{\n\tstruct workspace *workspace = list_entry(ws, struct workspace, list);\n\tint ret = 0;\n\tchar *data_in;\n\tchar *cpage_out;\n\tint nr_pages = 0;\n\tstruct page *in_page = NULL;\n\tstruct page *out_page = NULL;\n\tunsigned long bytes_left;\n\n\tsize_t in_len;\n\tsize_t out_len;\n\tchar *buf;\n\tunsigned long tot_in = 0;\n\tunsigned long tot_out = 0;\n\tunsigned long pg_bytes_left;\n\tunsigned long out_offset;\n\tunsigned long bytes;\n\n\t*out_pages = 0;\n\t*total_out = 0;\n\t*total_in = 0;\n\n\tin_page = find_get_page(mapping, start >> PAGE_CACHE_SHIFT);\n\tdata_in = kmap(in_page);\n\n\t/*\n\t * store the size of all chunks of compressed data in\n\t * the first 4 bytes\n\t */\n\tout_page = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\tif (out_page == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tcpage_out = kmap(out_page);\n\tout_offset = LZO_LEN;\n\ttot_out = LZO_LEN;\n\tpages[0] = out_page;\n\tnr_pages = 1;\n\tpg_bytes_left = PAGE_CACHE_SIZE - LZO_LEN;\n\n\t/* compress at most one page of data each time */\n\tin_len = min(len, PAGE_CACHE_SIZE);\n\twhile (tot_in < len) {\n\t\tret = lzo1x_1_compress(data_in, in_len, workspace->cbuf,\n\t\t\t\t       &out_len, workspace->mem);\n\t\tif (ret != LZO_E_OK) {\n\t\t\tprintk(KERN_DEBUG \"BTRFS: deflate in loop returned %d\\n\",\n\t\t\t       ret);\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* store the size of this chunk of compressed data */\n\t\twrite_compress_length(cpage_out + out_offset, out_len);\n\t\ttot_out += LZO_LEN;\n\t\tout_offset += LZO_LEN;\n\t\tpg_bytes_left -= LZO_LEN;\n\n\t\ttot_in += in_len;\n\t\ttot_out += out_len;\n\n\t\t/* copy bytes from the working buffer into the pages */\n\t\tbuf = workspace->cbuf;\n\t\twhile (out_len) {\n\t\t\tbytes = min_t(unsigned long, pg_bytes_left, out_len);\n\n\t\t\tmemcpy(cpage_out + out_offset, buf, bytes);\n\n\t\t\tout_len -= bytes;\n\t\t\tpg_bytes_left -= bytes;\n\t\t\tbuf += bytes;\n\t\t\tout_offset += bytes;\n\n\t\t\t/*\n\t\t\t * we need another page for writing out.\n\t\t\t *\n\t\t\t * Note if there's less than 4 bytes left, we just\n\t\t\t * skip to a new page.\n\t\t\t */\n\t\t\tif ((out_len == 0 && pg_bytes_left < LZO_LEN) ||\n\t\t\t    pg_bytes_left == 0) {\n\t\t\t\tif (pg_bytes_left) {\n\t\t\t\t\tmemset(cpage_out + out_offset, 0,\n\t\t\t\t\t       pg_bytes_left);\n\t\t\t\t\ttot_out += pg_bytes_left;\n\t\t\t\t}\n\n\t\t\t\t/* we're done, don't allocate new page */\n\t\t\t\tif (out_len == 0 && tot_in >= len)\n\t\t\t\t\tbreak;\n\n\t\t\t\tkunmap(out_page);\n\t\t\t\tif (nr_pages == nr_dest_pages) {\n\t\t\t\t\tout_page = NULL;\n\t\t\t\t\tret = -E2BIG;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tout_page = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\n\t\t\t\tif (out_page == NULL) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tcpage_out = kmap(out_page);\n\t\t\t\tpages[nr_pages++] = out_page;\n\n\t\t\t\tpg_bytes_left = PAGE_CACHE_SIZE;\n\t\t\t\tout_offset = 0;\n\t\t\t}\n\t\t}\n\n\t\t/* we're making it bigger, give up */\n\t\tif (tot_in > 8192 && tot_in < tot_out) {\n\t\t\tret = -E2BIG;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* we're all done */\n\t\tif (tot_in >= len)\n\t\t\tbreak;\n\n\t\tif (tot_out > max_out)\n\t\t\tbreak;\n\n\t\tbytes_left = len - tot_in;\n\t\tkunmap(in_page);\n\t\tpage_cache_release(in_page);\n\n\t\tstart += PAGE_CACHE_SIZE;\n\t\tin_page = find_get_page(mapping, start >> PAGE_CACHE_SHIFT);\n\t\tdata_in = kmap(in_page);\n\t\tin_len = min(bytes_left, PAGE_CACHE_SIZE);\n\t}\n\n\tif (tot_out > tot_in)\n\t\tgoto out;\n\n\t/* store the size of all chunks of compressed data */\n\tcpage_out = kmap(pages[0]);\n\twrite_compress_length(cpage_out, tot_out);\n\n\tkunmap(pages[0]);\n\n\tret = 0;\n\t*total_out = tot_out;\n\t*total_in = tot_in;\nout:\n\t*out_pages = nr_pages;\n\tif (out_page)\n\t\tkunmap(out_page);\n\n\tif (in_page) {\n\t\tkunmap(in_page);\n\t\tpage_cache_release(in_page);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "read_compress_length",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/lzo.c",
    "lines": "79-85",
    "snippet": "static inline size_t read_compress_length(char *buf)\n{\n\t__le32 dlen;\n\n\tmemcpy(&dlen, buf, LZO_LEN);\n\treturn le32_to_cpu(dlen);\n}",
    "includes": [
      "#include \"compression.h\"",
      "#include <linux/lzo.h>",
      "#include <linux/bio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>",
      "#include <linux/err.h>",
      "#include <linux/init.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define LZO_LEN\t4"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dlen"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&dlen",
            "buf",
            "LZO_LEN"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"compression.h\"\n#include <linux/lzo.h>\n#include <linux/bio.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\n#define LZO_LEN\t4\n\nstatic inline size_t read_compress_length(char *buf)\n{\n\t__le32 dlen;\n\n\tmemcpy(&dlen, buf, LZO_LEN);\n\treturn le32_to_cpu(dlen);\n}"
  },
  {
    "function_name": "write_compress_length",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/lzo.c",
    "lines": "71-77",
    "snippet": "static inline void write_compress_length(char *buf, size_t len)\n{\n\t__le32 dlen;\n\n\tdlen = cpu_to_le32(len);\n\tmemcpy(buf, &dlen, LZO_LEN);\n}",
    "includes": [
      "#include \"compression.h\"",
      "#include <linux/lzo.h>",
      "#include <linux/bio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>",
      "#include <linux/err.h>",
      "#include <linux/init.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define LZO_LEN\t4"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "&dlen",
            "LZO_LEN"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "len"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"compression.h\"\n#include <linux/lzo.h>\n#include <linux/bio.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\n#define LZO_LEN\t4\n\nstatic inline void write_compress_length(char *buf, size_t len)\n{\n\t__le32 dlen;\n\n\tdlen = cpu_to_le32(len);\n\tmemcpy(buf, &dlen, LZO_LEN);\n}"
  },
  {
    "function_name": "lzo_alloc_workspace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/lzo.c",
    "lines": "49-69",
    "snippet": "static struct list_head *lzo_alloc_workspace(void)\n{\n\tstruct workspace *workspace;\n\n\tworkspace = kzalloc(sizeof(*workspace), GFP_NOFS);\n\tif (!workspace)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tworkspace->mem = vmalloc(LZO1X_MEM_COMPRESS);\n\tworkspace->buf = vmalloc(lzo1x_worst_compress(PAGE_CACHE_SIZE));\n\tworkspace->cbuf = vmalloc(lzo1x_worst_compress(PAGE_CACHE_SIZE));\n\tif (!workspace->mem || !workspace->buf || !workspace->cbuf)\n\t\tgoto fail;\n\n\tINIT_LIST_HEAD(&workspace->list);\n\n\treturn &workspace->list;\nfail:\n\tlzo_free_workspace(&workspace->list);\n\treturn ERR_PTR(-ENOMEM);\n}",
    "includes": [
      "#include \"compression.h\"",
      "#include <linux/lzo.h>",
      "#include <linux/bio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>",
      "#include <linux/err.h>",
      "#include <linux/init.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lzo_free_workspace",
          "args": [
            "&workspace->list"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "lzo_free_workspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/lzo.c",
          "lines": "39-47",
          "snippet": "static void lzo_free_workspace(struct list_head *ws)\n{\n\tstruct workspace *workspace = list_entry(ws, struct workspace, list);\n\n\tvfree(workspace->buf);\n\tvfree(workspace->cbuf);\n\tvfree(workspace->mem);\n\tkfree(workspace);\n}",
          "includes": [
            "#include \"compression.h\"",
            "#include <linux/lzo.h>",
            "#include <linux/bio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>",
            "#include <linux/err.h>",
            "#include <linux/init.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"compression.h\"\n#include <linux/lzo.h>\n#include <linux/bio.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void lzo_free_workspace(struct list_head *ws)\n{\n\tstruct workspace *workspace = list_entry(ws, struct workspace, list);\n\n\tvfree(workspace->buf);\n\tvfree(workspace->cbuf);\n\tvfree(workspace->mem);\n\tkfree(workspace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&workspace->list"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmalloc",
          "args": [
            "lzo1x_worst_compress(PAGE_CACHE_SIZE)"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_blocks_use_vmalloc(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.h",
          "lines": "292-295",
          "snippet": "tatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"os-linux.h\"\n#",
            "include \"os-ecos.h\"\n#",
            "include \"summary.h\"",
            "include \"acl.h\"\n#",
            "include \"xattr.h\"\n#",
            "include \"jffs2_fs_i.h\"\n#",
            "include \"jffs2_fs_sb.h\"\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/types.h>\n#",
            "include <linux/fs.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"os-linux.h\"\n#\ninclude \"os-ecos.h\"\n#\ninclude \"summary.h\"\ninclude \"acl.h\"\n#\ninclude \"xattr.h\"\n#\ninclude \"jffs2_fs_i.h\"\n#\ninclude \"jffs2_fs_sb.h\"\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/types.h>\n#\ninclude <linux/fs.h>\n#\n\ntatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lzo1x_worst_compress",
          "args": [
            "PAGE_CACHE_SIZE"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lzo1x_worst_compress",
          "args": [
            "PAGE_CACHE_SIZE"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*workspace)",
            "GFP_NOFS"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"compression.h\"\n#include <linux/lzo.h>\n#include <linux/bio.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct list_head *lzo_alloc_workspace(void)\n{\n\tstruct workspace *workspace;\n\n\tworkspace = kzalloc(sizeof(*workspace), GFP_NOFS);\n\tif (!workspace)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tworkspace->mem = vmalloc(LZO1X_MEM_COMPRESS);\n\tworkspace->buf = vmalloc(lzo1x_worst_compress(PAGE_CACHE_SIZE));\n\tworkspace->cbuf = vmalloc(lzo1x_worst_compress(PAGE_CACHE_SIZE));\n\tif (!workspace->mem || !workspace->buf || !workspace->cbuf)\n\t\tgoto fail;\n\n\tINIT_LIST_HEAD(&workspace->list);\n\n\treturn &workspace->list;\nfail:\n\tlzo_free_workspace(&workspace->list);\n\treturn ERR_PTR(-ENOMEM);\n}"
  },
  {
    "function_name": "lzo_free_workspace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/lzo.c",
    "lines": "39-47",
    "snippet": "static void lzo_free_workspace(struct list_head *ws)\n{\n\tstruct workspace *workspace = list_entry(ws, struct workspace, list);\n\n\tvfree(workspace->buf);\n\tvfree(workspace->cbuf);\n\tvfree(workspace->mem);\n\tkfree(workspace);\n}",
    "includes": [
      "#include \"compression.h\"",
      "#include <linux/lzo.h>",
      "#include <linux/bio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>",
      "#include <linux/err.h>",
      "#include <linux/init.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "workspace"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "workspace->mem"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "workspace->cbuf"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "workspace->buf"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "ws",
            "structworkspace",
            "list"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"compression.h\"\n#include <linux/lzo.h>\n#include <linux/bio.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void lzo_free_workspace(struct list_head *ws)\n{\n\tstruct workspace *workspace = list_entry(ws, struct workspace, list);\n\n\tvfree(workspace->buf);\n\tvfree(workspace->cbuf);\n\tvfree(workspace->mem);\n\tkfree(workspace);\n}"
  }
]