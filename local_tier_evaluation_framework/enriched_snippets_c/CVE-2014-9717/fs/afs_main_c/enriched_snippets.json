[
  {
    "function_name": "afs_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/main.c",
    "lines": "165-182",
    "snippet": "static void __exit afs_exit(void)\n{\n\tprintk(KERN_INFO \"kAFS: Red Hat AFS client v0.1 unregistering.\\n\");\n\n\tafs_fs_exit();\n\tafs_kill_lock_manager();\n\tafs_close_socket();\n\tafs_purge_servers();\n\tafs_callback_update_kill();\n\tafs_vlocation_purge();\n\tdestroy_workqueue(afs_wq);\n\tafs_cell_purge();\n#ifdef CONFIG_AFS_FSCACHE\n\tfscache_unregister_netfs(&afs_cache_netfs);\n#endif\n\tafs_proc_cleanup();\n\trcu_barrier();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/completion.h>",
      "#include <linux/init.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct workqueue_struct *afs_wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_proc_cleanup",
          "args": [],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "afs_proc_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/proc.c",
          "lines": "150-153",
          "snippet": "void afs_proc_cleanup(void)\n{\n\tremove_proc_subtree(\"fs/afs\", NULL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nvoid afs_proc_cleanup(void)\n{\n\tremove_proc_subtree(\"fs/afs\", NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_unregister_netfs",
          "args": [
            "&afs_cache_netfs"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_unregister_netfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/netfs.c",
          "lines": "88-103",
          "snippet": "void __fscache_unregister_netfs(struct fscache_netfs *netfs)\n{\n\t_enter(\"{%s.%u}\", netfs->name, netfs->version);\n\n\tdown_write(&fscache_addremove_sem);\n\n\tlist_del(&netfs->link);\n\tfscache_relinquish_cookie(netfs->primary_index, 0);\n\n\tup_write(&fscache_addremove_sem);\n\n\tpr_notice(\"Netfs '%s' unregistered from caching\\n\",\n\t\t  netfs->name);\n\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nvoid __fscache_unregister_netfs(struct fscache_netfs *netfs)\n{\n\t_enter(\"{%s.%u}\", netfs->name, netfs->version);\n\n\tdown_write(&fscache_addremove_sem);\n\n\tlist_del(&netfs->link);\n\tfscache_relinquish_cookie(netfs->primary_index, 0);\n\n\tup_write(&fscache_addremove_sem);\n\n\tpr_notice(\"Netfs '%s' unregistered from caching\\n\",\n\t\t  netfs->name);\n\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_cell_purge",
          "args": [],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "afs_cell_purge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/cell.c",
          "lines": "425-460",
          "snippet": "void afs_cell_purge(void)\n{\n\tstruct afs_cell *cell;\n\n\t_enter(\"\");\n\n\tafs_put_cell(afs_cell_root);\n\n\tdown_write(&afs_cells_sem);\n\n\twhile (!list_empty(&afs_cells)) {\n\t\tcell = NULL;\n\n\t\t/* remove the next cell from the front of the list */\n\t\twrite_lock(&afs_cells_lock);\n\n\t\tif (!list_empty(&afs_cells)) {\n\t\t\tcell = list_entry(afs_cells.next,\n\t\t\t\t\t  struct afs_cell, link);\n\t\t\tlist_del_init(&cell->link);\n\t\t}\n\n\t\twrite_unlock(&afs_cells_lock);\n\n\t\tif (cell) {\n\t\t\t_debug(\"PURGING CELL %s (%d)\",\n\t\t\t       cell->name, atomic_read(&cell->usage));\n\n\t\t\t/* now the cell should be left with no references */\n\t\t\tafs_cell_destroy(cell);\n\t\t}\n\t}\n\n\tup_write(&afs_cells_sem);\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <keys/rxrpc-type.h>",
            "#include <linux/sched.h>",
            "#include <linux/dns_resolver.h>",
            "#include <linux/ctype.h>",
            "#include <linux/key.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(afs_cells);",
            "static DEFINE_RWLOCK(afs_cells_lock);",
            "static DECLARE_RWSEM(afs_cells_sem);",
            "static struct afs_cell *afs_cell_root;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <keys/rxrpc-type.h>\n#include <linux/sched.h>\n#include <linux/dns_resolver.h>\n#include <linux/ctype.h>\n#include <linux/key.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(afs_cells);\nstatic DEFINE_RWLOCK(afs_cells_lock);\nstatic DECLARE_RWSEM(afs_cells_sem);\nstatic struct afs_cell *afs_cell_root;\n\nvoid afs_cell_purge(void)\n{\n\tstruct afs_cell *cell;\n\n\t_enter(\"\");\n\n\tafs_put_cell(afs_cell_root);\n\n\tdown_write(&afs_cells_sem);\n\n\twhile (!list_empty(&afs_cells)) {\n\t\tcell = NULL;\n\n\t\t/* remove the next cell from the front of the list */\n\t\twrite_lock(&afs_cells_lock);\n\n\t\tif (!list_empty(&afs_cells)) {\n\t\t\tcell = list_entry(afs_cells.next,\n\t\t\t\t\t  struct afs_cell, link);\n\t\t\tlist_del_init(&cell->link);\n\t\t}\n\n\t\twrite_unlock(&afs_cells_lock);\n\n\t\tif (cell) {\n\t\t\t_debug(\"PURGING CELL %s (%d)\",\n\t\t\t       cell->name, atomic_read(&cell->usage));\n\n\t\t\t/* now the cell should be left with no references */\n\t\t\tafs_cell_destroy(cell);\n\t\t}\n\t}\n\n\tup_write(&afs_cells_sem);\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_workqueue",
          "args": [
            "afs_wq"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "343-351",
          "snippet": "void btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_vlocation_purge",
          "args": [],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vlocation_purge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vlocation.c",
          "lines": "605-616",
          "snippet": "void afs_vlocation_purge(void)\n{\n\tafs_vlocation_timeout = 0;\n\n\tspin_lock(&afs_vlocation_updates_lock);\n\tlist_del_init(&afs_vlocation_updates);\n\tspin_unlock(&afs_vlocation_updates_lock);\n\tmod_delayed_work(afs_vlocation_update_worker, &afs_vlocation_update, 0);\n\tdestroy_workqueue(afs_vlocation_update_worker);\n\n\tmod_delayed_work(afs_wq, &afs_vlocation_reap, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned afs_vlocation_timeout = 10;",
            "static LIST_HEAD(afs_vlocation_updates);",
            "static DEFINE_SPINLOCK(afs_vlocation_updates_lock);",
            "static struct workqueue_struct *afs_vlocation_update_worker;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic unsigned afs_vlocation_timeout = 10;\nstatic LIST_HEAD(afs_vlocation_updates);\nstatic DEFINE_SPINLOCK(afs_vlocation_updates_lock);\nstatic struct workqueue_struct *afs_vlocation_update_worker;\n\nvoid afs_vlocation_purge(void)\n{\n\tafs_vlocation_timeout = 0;\n\n\tspin_lock(&afs_vlocation_updates_lock);\n\tlist_del_init(&afs_vlocation_updates);\n\tspin_unlock(&afs_vlocation_updates_lock);\n\tmod_delayed_work(afs_vlocation_update_worker, &afs_vlocation_update, 0);\n\tdestroy_workqueue(afs_vlocation_update_worker);\n\n\tmod_delayed_work(afs_wq, &afs_vlocation_reap, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_callback_update_kill",
          "args": [],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "afs_callback_update_kill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/callback.c",
          "lines": "472-475",
          "snippet": "void afs_callback_update_kill(void)\n{\n\tdestroy_workqueue(afs_callback_update_worker);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *afs_callback_update_worker;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/circ_buf.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *afs_callback_update_worker;\n\nvoid afs_callback_update_kill(void)\n{\n\tdestroy_workqueue(afs_callback_update_worker);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_purge_servers",
          "args": [],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "afs_purge_servers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/server.c",
          "lines": "318-322",
          "snippet": "void __exit afs_purge_servers(void)\n{\n\tafs_server_timeout = 0;\n\tmod_delayed_work(afs_wq, &afs_server_reaper, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned afs_server_timeout = 10;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic unsigned afs_server_timeout = 10;\n\nvoid __exit afs_purge_servers(void)\n{\n\tafs_server_timeout = 0;\n\tmod_delayed_work(afs_wq, &afs_server_reaper, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_close_socket",
          "args": [],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "afs_close_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "125-137",
          "snippet": "void afs_close_socket(void)\n{\n\t_enter(\"\");\n\n\tsock_release(afs_socket);\n\n\t_debug(\"dework\");\n\tdestroy_workqueue(afs_async_calls);\n\n\tASSERTCMP(atomic_read(&afs_outstanding_skbs), ==, 0);\n\tASSERTCMP(atomic_read(&afs_outstanding_calls), ==, 0);\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct socket *afs_socket;",
            "static struct workqueue_struct *afs_async_calls;",
            "static atomic_t afs_outstanding_calls;",
            "static atomic_t afs_outstanding_skbs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic struct socket *afs_socket;\nstatic struct workqueue_struct *afs_async_calls;\nstatic atomic_t afs_outstanding_calls;\nstatic atomic_t afs_outstanding_skbs;\n\nvoid afs_close_socket(void)\n{\n\t_enter(\"\");\n\n\tsock_release(afs_socket);\n\n\t_debug(\"dework\");\n\tdestroy_workqueue(afs_async_calls);\n\n\tASSERTCMP(atomic_read(&afs_outstanding_skbs), ==, 0);\n\tASSERTCMP(atomic_read(&afs_outstanding_calls), ==, 0);\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_kill_lock_manager",
          "args": [],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "afs_kill_lock_manager",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/flock.c",
          "lines": "52-56",
          "snippet": "void __exit afs_kill_lock_manager(void)\n{\n\tif (afs_lock_manager)\n\t\tdestroy_workqueue(afs_lock_manager);\n}",
          "includes": [
            "#include \"internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *afs_lock_manager;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n\nstatic struct workqueue_struct *afs_lock_manager;\n\nvoid __exit afs_kill_lock_manager(void)\n{\n\tif (afs_lock_manager)\n\t\tdestroy_workqueue(afs_lock_manager);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_fs_exit",
          "args": [],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "afs_fs_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/super.c",
          "lines": "116-136",
          "snippet": "void __exit afs_fs_exit(void)\n{\n\t_enter(\"\");\n\n\tafs_mntpt_kill_timer();\n\tunregister_filesystem(&afs_fs_type);\n\n\tif (atomic_read(&afs_count_active_inodes) != 0) {\n\t\tprintk(\"kAFS: %d active inode objects still present\\n\",\n\t\t       atomic_read(&afs_count_active_inodes));\n\t\tBUG();\n\t}\n\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(afs_inode_cachep);\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/sched.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void afs_destroy_inode(struct inode *inode);",
            "struct file_system_type afs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"afs\",\n\t.mount\t\t= afs_mount,\n\t.kill_sb\t= afs_kill_super,\n\t.fs_flags\t= 0,\n};",
            "static struct kmem_cache *afs_inode_cachep;",
            "static atomic_t afs_count_active_inodes;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <net/net_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/sched.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void afs_destroy_inode(struct inode *inode);\nstruct file_system_type afs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"afs\",\n\t.mount\t\t= afs_mount,\n\t.kill_sb\t= afs_kill_super,\n\t.fs_flags\t= 0,\n};\nstatic struct kmem_cache *afs_inode_cachep;\nstatic atomic_t afs_count_active_inodes;\n\nvoid __exit afs_fs_exit(void)\n{\n\t_enter(\"\");\n\n\tafs_mntpt_kill_timer();\n\tunregister_filesystem(&afs_fs_type);\n\n\tif (atomic_read(&afs_count_active_inodes) != 0) {\n\t\tprintk(\"kAFS: %d active inode objects still present\\n\",\n\t\t       atomic_read(&afs_count_active_inodes));\n\t\tBUG();\n\t}\n\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(afs_inode_cachep);\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"kAFS: Red Hat AFS client v0.1 unregistering.\\n\""
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/completion.h>\n#include <linux/init.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n\nstruct workqueue_struct *afs_wq;\n\nstatic void __exit afs_exit(void)\n{\n\tprintk(KERN_INFO \"kAFS: Red Hat AFS client v0.1 unregistering.\\n\");\n\n\tafs_fs_exit();\n\tafs_kill_lock_manager();\n\tafs_close_socket();\n\tafs_purge_servers();\n\tafs_callback_update_kill();\n\tafs_vlocation_purge();\n\tdestroy_workqueue(afs_wq);\n\tafs_cell_purge();\n#ifdef CONFIG_AFS_FSCACHE\n\tfscache_unregister_netfs(&afs_cache_netfs);\n#endif\n\tafs_proc_cleanup();\n\trcu_barrier();\n}"
  },
  {
    "function_name": "afs_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/main.c",
    "lines": "81-155",
    "snippet": "static int __init afs_init(void)\n{\n\tint ret;\n\n\tprintk(KERN_INFO \"kAFS: Red Hat AFS client v0.1 registering.\\n\");\n\n\tret = afs_get_client_UUID();\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* create workqueue */\n\tret = -ENOMEM;\n\tafs_wq = alloc_workqueue(\"afs\", 0, 0);\n\tif (!afs_wq)\n\t\treturn ret;\n\n\t/* register the /proc stuff */\n\tret = afs_proc_init();\n\tif (ret < 0)\n\t\tgoto error_proc;\n\n#ifdef CONFIG_AFS_FSCACHE\n\t/* we want to be able to cache */\n\tret = fscache_register_netfs(&afs_cache_netfs);\n\tif (ret < 0)\n\t\tgoto error_cache;\n#endif\n\n\t/* initialise the cell DB */\n\tret = afs_cell_init(rootcell);\n\tif (ret < 0)\n\t\tgoto error_cell_init;\n\n\t/* initialise the VL update process */\n\tret = afs_vlocation_update_init();\n\tif (ret < 0)\n\t\tgoto error_vl_update_init;\n\n\t/* initialise the callback update process */\n\tret = afs_callback_update_init();\n\tif (ret < 0)\n\t\tgoto error_callback_update_init;\n\n\t/* create the RxRPC transport */\n\tret = afs_open_socket();\n\tif (ret < 0)\n\t\tgoto error_open_socket;\n\n\t/* register the filesystems */\n\tret = afs_fs_init();\n\tif (ret < 0)\n\t\tgoto error_fs;\n\n\treturn ret;\n\nerror_fs:\n\tafs_close_socket();\nerror_open_socket:\n\tafs_callback_update_kill();\nerror_callback_update_init:\n\tafs_vlocation_purge();\nerror_vl_update_init:\n\tafs_cell_purge();\nerror_cell_init:\n#ifdef CONFIG_AFS_FSCACHE\n\tfscache_unregister_netfs(&afs_cache_netfs);\nerror_cache:\n#endif\n\tafs_proc_cleanup();\nerror_proc:\n\tdestroy_workqueue(afs_wq);\n\trcu_barrier();\n\tprintk(KERN_ERR \"kAFS: failed to register: %d\\n\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/completion.h>",
      "#include <linux/init.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *rootcell;",
      "struct workqueue_struct *afs_wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"kAFS: failed to register: %d\\n\"",
            "ret"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_workqueue",
          "args": [
            "afs_wq"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "343-351",
          "snippet": "void btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_proc_cleanup",
          "args": [],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "afs_proc_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/proc.c",
          "lines": "150-153",
          "snippet": "void afs_proc_cleanup(void)\n{\n\tremove_proc_subtree(\"fs/afs\", NULL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nvoid afs_proc_cleanup(void)\n{\n\tremove_proc_subtree(\"fs/afs\", NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_unregister_netfs",
          "args": [
            "&afs_cache_netfs"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_unregister_netfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/netfs.c",
          "lines": "88-103",
          "snippet": "void __fscache_unregister_netfs(struct fscache_netfs *netfs)\n{\n\t_enter(\"{%s.%u}\", netfs->name, netfs->version);\n\n\tdown_write(&fscache_addremove_sem);\n\n\tlist_del(&netfs->link);\n\tfscache_relinquish_cookie(netfs->primary_index, 0);\n\n\tup_write(&fscache_addremove_sem);\n\n\tpr_notice(\"Netfs '%s' unregistered from caching\\n\",\n\t\t  netfs->name);\n\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nvoid __fscache_unregister_netfs(struct fscache_netfs *netfs)\n{\n\t_enter(\"{%s.%u}\", netfs->name, netfs->version);\n\n\tdown_write(&fscache_addremove_sem);\n\n\tlist_del(&netfs->link);\n\tfscache_relinquish_cookie(netfs->primary_index, 0);\n\n\tup_write(&fscache_addremove_sem);\n\n\tpr_notice(\"Netfs '%s' unregistered from caching\\n\",\n\t\t  netfs->name);\n\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_cell_purge",
          "args": [],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "afs_cell_purge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/cell.c",
          "lines": "425-460",
          "snippet": "void afs_cell_purge(void)\n{\n\tstruct afs_cell *cell;\n\n\t_enter(\"\");\n\n\tafs_put_cell(afs_cell_root);\n\n\tdown_write(&afs_cells_sem);\n\n\twhile (!list_empty(&afs_cells)) {\n\t\tcell = NULL;\n\n\t\t/* remove the next cell from the front of the list */\n\t\twrite_lock(&afs_cells_lock);\n\n\t\tif (!list_empty(&afs_cells)) {\n\t\t\tcell = list_entry(afs_cells.next,\n\t\t\t\t\t  struct afs_cell, link);\n\t\t\tlist_del_init(&cell->link);\n\t\t}\n\n\t\twrite_unlock(&afs_cells_lock);\n\n\t\tif (cell) {\n\t\t\t_debug(\"PURGING CELL %s (%d)\",\n\t\t\t       cell->name, atomic_read(&cell->usage));\n\n\t\t\t/* now the cell should be left with no references */\n\t\t\tafs_cell_destroy(cell);\n\t\t}\n\t}\n\n\tup_write(&afs_cells_sem);\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <keys/rxrpc-type.h>",
            "#include <linux/sched.h>",
            "#include <linux/dns_resolver.h>",
            "#include <linux/ctype.h>",
            "#include <linux/key.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(afs_cells);",
            "static DEFINE_RWLOCK(afs_cells_lock);",
            "static DECLARE_RWSEM(afs_cells_sem);",
            "static struct afs_cell *afs_cell_root;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <keys/rxrpc-type.h>\n#include <linux/sched.h>\n#include <linux/dns_resolver.h>\n#include <linux/ctype.h>\n#include <linux/key.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(afs_cells);\nstatic DEFINE_RWLOCK(afs_cells_lock);\nstatic DECLARE_RWSEM(afs_cells_sem);\nstatic struct afs_cell *afs_cell_root;\n\nvoid afs_cell_purge(void)\n{\n\tstruct afs_cell *cell;\n\n\t_enter(\"\");\n\n\tafs_put_cell(afs_cell_root);\n\n\tdown_write(&afs_cells_sem);\n\n\twhile (!list_empty(&afs_cells)) {\n\t\tcell = NULL;\n\n\t\t/* remove the next cell from the front of the list */\n\t\twrite_lock(&afs_cells_lock);\n\n\t\tif (!list_empty(&afs_cells)) {\n\t\t\tcell = list_entry(afs_cells.next,\n\t\t\t\t\t  struct afs_cell, link);\n\t\t\tlist_del_init(&cell->link);\n\t\t}\n\n\t\twrite_unlock(&afs_cells_lock);\n\n\t\tif (cell) {\n\t\t\t_debug(\"PURGING CELL %s (%d)\",\n\t\t\t       cell->name, atomic_read(&cell->usage));\n\n\t\t\t/* now the cell should be left with no references */\n\t\t\tafs_cell_destroy(cell);\n\t\t}\n\t}\n\n\tup_write(&afs_cells_sem);\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_vlocation_purge",
          "args": [],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vlocation_purge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vlocation.c",
          "lines": "605-616",
          "snippet": "void afs_vlocation_purge(void)\n{\n\tafs_vlocation_timeout = 0;\n\n\tspin_lock(&afs_vlocation_updates_lock);\n\tlist_del_init(&afs_vlocation_updates);\n\tspin_unlock(&afs_vlocation_updates_lock);\n\tmod_delayed_work(afs_vlocation_update_worker, &afs_vlocation_update, 0);\n\tdestroy_workqueue(afs_vlocation_update_worker);\n\n\tmod_delayed_work(afs_wq, &afs_vlocation_reap, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned afs_vlocation_timeout = 10;",
            "static LIST_HEAD(afs_vlocation_updates);",
            "static DEFINE_SPINLOCK(afs_vlocation_updates_lock);",
            "static struct workqueue_struct *afs_vlocation_update_worker;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic unsigned afs_vlocation_timeout = 10;\nstatic LIST_HEAD(afs_vlocation_updates);\nstatic DEFINE_SPINLOCK(afs_vlocation_updates_lock);\nstatic struct workqueue_struct *afs_vlocation_update_worker;\n\nvoid afs_vlocation_purge(void)\n{\n\tafs_vlocation_timeout = 0;\n\n\tspin_lock(&afs_vlocation_updates_lock);\n\tlist_del_init(&afs_vlocation_updates);\n\tspin_unlock(&afs_vlocation_updates_lock);\n\tmod_delayed_work(afs_vlocation_update_worker, &afs_vlocation_update, 0);\n\tdestroy_workqueue(afs_vlocation_update_worker);\n\n\tmod_delayed_work(afs_wq, &afs_vlocation_reap, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_callback_update_kill",
          "args": [],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "afs_callback_update_kill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/callback.c",
          "lines": "472-475",
          "snippet": "void afs_callback_update_kill(void)\n{\n\tdestroy_workqueue(afs_callback_update_worker);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *afs_callback_update_worker;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/circ_buf.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *afs_callback_update_worker;\n\nvoid afs_callback_update_kill(void)\n{\n\tdestroy_workqueue(afs_callback_update_worker);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_close_socket",
          "args": [],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "afs_close_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "125-137",
          "snippet": "void afs_close_socket(void)\n{\n\t_enter(\"\");\n\n\tsock_release(afs_socket);\n\n\t_debug(\"dework\");\n\tdestroy_workqueue(afs_async_calls);\n\n\tASSERTCMP(atomic_read(&afs_outstanding_skbs), ==, 0);\n\tASSERTCMP(atomic_read(&afs_outstanding_calls), ==, 0);\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct socket *afs_socket;",
            "static struct workqueue_struct *afs_async_calls;",
            "static atomic_t afs_outstanding_calls;",
            "static atomic_t afs_outstanding_skbs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic struct socket *afs_socket;\nstatic struct workqueue_struct *afs_async_calls;\nstatic atomic_t afs_outstanding_calls;\nstatic atomic_t afs_outstanding_skbs;\n\nvoid afs_close_socket(void)\n{\n\t_enter(\"\");\n\n\tsock_release(afs_socket);\n\n\t_debug(\"dework\");\n\tdestroy_workqueue(afs_async_calls);\n\n\tASSERTCMP(atomic_read(&afs_outstanding_skbs), ==, 0);\n\tASSERTCMP(atomic_read(&afs_outstanding_calls), ==, 0);\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_fs_init",
          "args": [],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "afs_fs_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/super.c",
          "lines": "81-111",
          "snippet": "int __init afs_fs_init(void)\n{\n\tint ret;\n\n\t_enter(\"\");\n\n\t/* create ourselves an inode cache */\n\tatomic_set(&afs_count_active_inodes, 0);\n\n\tret = -ENOMEM;\n\tafs_inode_cachep = kmem_cache_create(\"afs_inode_cache\",\n\t\t\t\t\t     sizeof(struct afs_vnode),\n\t\t\t\t\t     0,\n\t\t\t\t\t     SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t     afs_i_init_once);\n\tif (!afs_inode_cachep) {\n\t\tprintk(KERN_NOTICE \"kAFS: Failed to allocate inode cache\\n\");\n\t\treturn ret;\n\t}\n\n\t/* now export our filesystem to lesser mortals */\n\tret = register_filesystem(&afs_fs_type);\n\tif (ret < 0) {\n\t\tkmem_cache_destroy(afs_inode_cachep);\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\t}\n\n\t_leave(\" = 0\");\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/sched.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void afs_destroy_inode(struct inode *inode);",
            "struct file_system_type afs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"afs\",\n\t.mount\t\t= afs_mount,\n\t.kill_sb\t= afs_kill_super,\n\t.fs_flags\t= 0,\n};",
            "static struct kmem_cache *afs_inode_cachep;",
            "static atomic_t afs_count_active_inodes;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <net/net_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/sched.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void afs_destroy_inode(struct inode *inode);\nstruct file_system_type afs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"afs\",\n\t.mount\t\t= afs_mount,\n\t.kill_sb\t= afs_kill_super,\n\t.fs_flags\t= 0,\n};\nstatic struct kmem_cache *afs_inode_cachep;\nstatic atomic_t afs_count_active_inodes;\n\nint __init afs_fs_init(void)\n{\n\tint ret;\n\n\t_enter(\"\");\n\n\t/* create ourselves an inode cache */\n\tatomic_set(&afs_count_active_inodes, 0);\n\n\tret = -ENOMEM;\n\tafs_inode_cachep = kmem_cache_create(\"afs_inode_cache\",\n\t\t\t\t\t     sizeof(struct afs_vnode),\n\t\t\t\t\t     0,\n\t\t\t\t\t     SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t     afs_i_init_once);\n\tif (!afs_inode_cachep) {\n\t\tprintk(KERN_NOTICE \"kAFS: Failed to allocate inode cache\\n\");\n\t\treturn ret;\n\t}\n\n\t/* now export our filesystem to lesser mortals */\n\tret = register_filesystem(&afs_fs_type);\n\tif (ret < 0) {\n\t\tkmem_cache_destroy(afs_inode_cachep);\n\t\t_leave(\" = %d\", ret);\n\t\treturn ret;\n\t}\n\n\t_leave(\" = 0\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_open_socket",
          "args": [],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "afs_open_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/rxrpc.c",
          "lines": "72-120",
          "snippet": "int afs_open_socket(void)\n{\n\tstruct sockaddr_rxrpc srx;\n\tstruct socket *socket;\n\tint ret;\n\n\t_enter(\"\");\n\n\tskb_queue_head_init(&afs_incoming_calls);\n\n\tafs_async_calls = create_singlethread_workqueue(\"kafsd\");\n\tif (!afs_async_calls) {\n\t\t_leave(\" = -ENOMEM [wq]\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = sock_create_kern(AF_RXRPC, SOCK_DGRAM, PF_INET, &socket);\n\tif (ret < 0) {\n\t\tdestroy_workqueue(afs_async_calls);\n\t\t_leave(\" = %d [socket]\", ret);\n\t\treturn ret;\n\t}\n\n\tsocket->sk->sk_allocation = GFP_NOFS;\n\n\t/* bind the callback manager's address to make this a server socket */\n\tsrx.srx_family\t\t\t= AF_RXRPC;\n\tsrx.srx_service\t\t\t= CM_SERVICE;\n\tsrx.transport_type\t\t= SOCK_DGRAM;\n\tsrx.transport_len\t\t= sizeof(srx.transport.sin);\n\tsrx.transport.sin.sin_family\t= AF_INET;\n\tsrx.transport.sin.sin_port\t= htons(AFS_CM_PORT);\n\tmemset(&srx.transport.sin.sin_addr, 0,\n\t       sizeof(srx.transport.sin.sin_addr));\n\n\tret = kernel_bind(socket, (struct sockaddr *) &srx, sizeof(srx));\n\tif (ret < 0) {\n\t\tsock_release(socket);\n\t\tdestroy_workqueue(afs_async_calls);\n\t\t_leave(\" = %d [bind]\", ret);\n\t\treturn ret;\n\t}\n\n\trxrpc_kernel_intercept_rx_messages(socket, afs_rx_interceptor);\n\n\tafs_socket = socket;\n\t_leave(\" = 0\");\n\treturn 0;\n}",
          "includes": [
            "#include \"afs_cm.h\"",
            "#include \"internal.h\"",
            "#include <rxrpc/packet.h>",
            "#include <net/af_rxrpc.h>",
            "#include <net/sock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct socket *afs_socket;",
            "static struct workqueue_struct *afs_async_calls;",
            "static struct sk_buff_head afs_incoming_calls;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_cm.h\"\n#include \"internal.h\"\n#include <rxrpc/packet.h>\n#include <net/af_rxrpc.h>\n#include <net/sock.h>\n#include <linux/slab.h>\n\nstatic struct socket *afs_socket;\nstatic struct workqueue_struct *afs_async_calls;\nstatic struct sk_buff_head afs_incoming_calls;\n\nint afs_open_socket(void)\n{\n\tstruct sockaddr_rxrpc srx;\n\tstruct socket *socket;\n\tint ret;\n\n\t_enter(\"\");\n\n\tskb_queue_head_init(&afs_incoming_calls);\n\n\tafs_async_calls = create_singlethread_workqueue(\"kafsd\");\n\tif (!afs_async_calls) {\n\t\t_leave(\" = -ENOMEM [wq]\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = sock_create_kern(AF_RXRPC, SOCK_DGRAM, PF_INET, &socket);\n\tif (ret < 0) {\n\t\tdestroy_workqueue(afs_async_calls);\n\t\t_leave(\" = %d [socket]\", ret);\n\t\treturn ret;\n\t}\n\n\tsocket->sk->sk_allocation = GFP_NOFS;\n\n\t/* bind the callback manager's address to make this a server socket */\n\tsrx.srx_family\t\t\t= AF_RXRPC;\n\tsrx.srx_service\t\t\t= CM_SERVICE;\n\tsrx.transport_type\t\t= SOCK_DGRAM;\n\tsrx.transport_len\t\t= sizeof(srx.transport.sin);\n\tsrx.transport.sin.sin_family\t= AF_INET;\n\tsrx.transport.sin.sin_port\t= htons(AFS_CM_PORT);\n\tmemset(&srx.transport.sin.sin_addr, 0,\n\t       sizeof(srx.transport.sin.sin_addr));\n\n\tret = kernel_bind(socket, (struct sockaddr *) &srx, sizeof(srx));\n\tif (ret < 0) {\n\t\tsock_release(socket);\n\t\tdestroy_workqueue(afs_async_calls);\n\t\t_leave(\" = %d [bind]\", ret);\n\t\treturn ret;\n\t}\n\n\trxrpc_kernel_intercept_rx_messages(socket, afs_rx_interceptor);\n\n\tafs_socket = socket;\n\t_leave(\" = 0\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_callback_update_init",
          "args": [],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "afs_callback_update_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/callback.c",
          "lines": "462-467",
          "snippet": "int __init afs_callback_update_init(void)\n{\n\tafs_callback_update_worker =\n\t\tcreate_singlethread_workqueue(\"kafs_callbackd\");\n\treturn afs_callback_update_worker ? 0 : -ENOMEM;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *afs_callback_update_worker;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/circ_buf.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *afs_callback_update_worker;\n\nint __init afs_callback_update_init(void)\n{\n\tafs_callback_update_worker =\n\t\tcreate_singlethread_workqueue(\"kafs_callbackd\");\n\treturn afs_callback_update_worker ? 0 : -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_vlocation_update_init",
          "args": [],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vlocation_update_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vlocation.c",
          "lines": "595-600",
          "snippet": "int __init afs_vlocation_update_init(void)\n{\n\tafs_vlocation_update_worker =\n\t\tcreate_singlethread_workqueue(\"kafs_vlupdated\");\n\treturn afs_vlocation_update_worker ? 0 : -ENOMEM;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *afs_vlocation_update_worker;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *afs_vlocation_update_worker;\n\nint __init afs_vlocation_update_init(void)\n{\n\tafs_vlocation_update_worker =\n\t\tcreate_singlethread_workqueue(\"kafs_vlupdated\");\n\treturn afs_vlocation_update_worker ? 0 : -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_cell_init",
          "args": [
            "rootcell"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "afs_cell_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/cell.c",
          "lines": "226-263",
          "snippet": "int afs_cell_init(char *rootcell)\n{\n\tstruct afs_cell *old_root, *new_root;\n\tchar *cp;\n\n\t_enter(\"\");\n\n\tif (!rootcell) {\n\t\t/* module is loaded with no parameters, or built statically.\n\t\t * - in the future we might initialize cell DB here.\n\t\t */\n\t\t_leave(\" = 0 [no root]\");\n\t\treturn 0;\n\t}\n\n\tcp = strchr(rootcell, ':');\n\tif (!cp)\n\t\t_debug(\"kAFS: no VL server IP addresses specified\");\n\telse\n\t\t*cp++ = 0;\n\n\t/* allocate a cell record for the root cell */\n\tnew_root = afs_cell_create(rootcell, strlen(rootcell), cp, false);\n\tif (IS_ERR(new_root)) {\n\t\t_leave(\" = %ld\", PTR_ERR(new_root));\n\t\treturn PTR_ERR(new_root);\n\t}\n\n\t/* install the new cell */\n\twrite_lock(&afs_cells_lock);\n\told_root = afs_cell_root;\n\tafs_cell_root = new_root;\n\twrite_unlock(&afs_cells_lock);\n\tafs_put_cell(old_root);\n\n\t_leave(\" = 0\");\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <keys/rxrpc-type.h>",
            "#include <linux/sched.h>",
            "#include <linux/dns_resolver.h>",
            "#include <linux/ctype.h>",
            "#include <linux/key.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(afs_cells_lock);",
            "static struct afs_cell *afs_cell_root;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <keys/rxrpc-type.h>\n#include <linux/sched.h>\n#include <linux/dns_resolver.h>\n#include <linux/ctype.h>\n#include <linux/key.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic DEFINE_RWLOCK(afs_cells_lock);\nstatic struct afs_cell *afs_cell_root;\n\nint afs_cell_init(char *rootcell)\n{\n\tstruct afs_cell *old_root, *new_root;\n\tchar *cp;\n\n\t_enter(\"\");\n\n\tif (!rootcell) {\n\t\t/* module is loaded with no parameters, or built statically.\n\t\t * - in the future we might initialize cell DB here.\n\t\t */\n\t\t_leave(\" = 0 [no root]\");\n\t\treturn 0;\n\t}\n\n\tcp = strchr(rootcell, ':');\n\tif (!cp)\n\t\t_debug(\"kAFS: no VL server IP addresses specified\");\n\telse\n\t\t*cp++ = 0;\n\n\t/* allocate a cell record for the root cell */\n\tnew_root = afs_cell_create(rootcell, strlen(rootcell), cp, false);\n\tif (IS_ERR(new_root)) {\n\t\t_leave(\" = %ld\", PTR_ERR(new_root));\n\t\treturn PTR_ERR(new_root);\n\t}\n\n\t/* install the new cell */\n\twrite_lock(&afs_cells_lock);\n\told_root = afs_cell_root;\n\tafs_cell_root = new_root;\n\twrite_unlock(&afs_cells_lock);\n\tafs_put_cell(old_root);\n\n\t_leave(\" = 0\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_register_netfs",
          "args": [
            "&afs_cache_netfs"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_register_netfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/netfs.c",
          "lines": "22-81",
          "snippet": "int __fscache_register_netfs(struct fscache_netfs *netfs)\n{\n\tstruct fscache_netfs *ptr;\n\tint ret;\n\n\t_enter(\"{%s}\", netfs->name);\n\n\tINIT_LIST_HEAD(&netfs->link);\n\n\t/* allocate a cookie for the primary index */\n\tnetfs->primary_index =\n\t\tkmem_cache_zalloc(fscache_cookie_jar, GFP_KERNEL);\n\n\tif (!netfs->primary_index) {\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* initialise the primary index cookie */\n\tatomic_set(&netfs->primary_index->usage, 1);\n\tatomic_set(&netfs->primary_index->n_children, 0);\n\tatomic_set(&netfs->primary_index->n_active, 1);\n\n\tnetfs->primary_index->def\t\t= &fscache_fsdef_netfs_def;\n\tnetfs->primary_index->parent\t\t= &fscache_fsdef_index;\n\tnetfs->primary_index->netfs_data\t= netfs;\n\tnetfs->primary_index->flags\t\t= 1 << FSCACHE_COOKIE_ENABLED;\n\n\tatomic_inc(&netfs->primary_index->parent->usage);\n\tatomic_inc(&netfs->primary_index->parent->n_children);\n\n\tspin_lock_init(&netfs->primary_index->lock);\n\tINIT_HLIST_HEAD(&netfs->primary_index->backing_objects);\n\n\t/* check the netfs type is not already present */\n\tdown_write(&fscache_addremove_sem);\n\n\tret = -EEXIST;\n\tlist_for_each_entry(ptr, &fscache_netfs_list, link) {\n\t\tif (strcmp(ptr->name, netfs->name) == 0)\n\t\t\tgoto already_registered;\n\t}\n\n\tlist_add(&netfs->link, &fscache_netfs_list);\n\tret = 0;\n\n\tpr_notice(\"Netfs '%s' registered for caching\\n\", netfs->name);\n\nalready_registered:\n\tup_write(&fscache_addremove_sem);\n\n\tif (ret < 0) {\n\t\tnetfs->primary_index->parent = NULL;\n\t\t__fscache_cookie_put(netfs->primary_index);\n\t\tnetfs->primary_index = NULL;\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(fscache_netfs_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(fscache_netfs_list);\n\nint __fscache_register_netfs(struct fscache_netfs *netfs)\n{\n\tstruct fscache_netfs *ptr;\n\tint ret;\n\n\t_enter(\"{%s}\", netfs->name);\n\n\tINIT_LIST_HEAD(&netfs->link);\n\n\t/* allocate a cookie for the primary index */\n\tnetfs->primary_index =\n\t\tkmem_cache_zalloc(fscache_cookie_jar, GFP_KERNEL);\n\n\tif (!netfs->primary_index) {\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* initialise the primary index cookie */\n\tatomic_set(&netfs->primary_index->usage, 1);\n\tatomic_set(&netfs->primary_index->n_children, 0);\n\tatomic_set(&netfs->primary_index->n_active, 1);\n\n\tnetfs->primary_index->def\t\t= &fscache_fsdef_netfs_def;\n\tnetfs->primary_index->parent\t\t= &fscache_fsdef_index;\n\tnetfs->primary_index->netfs_data\t= netfs;\n\tnetfs->primary_index->flags\t\t= 1 << FSCACHE_COOKIE_ENABLED;\n\n\tatomic_inc(&netfs->primary_index->parent->usage);\n\tatomic_inc(&netfs->primary_index->parent->n_children);\n\n\tspin_lock_init(&netfs->primary_index->lock);\n\tINIT_HLIST_HEAD(&netfs->primary_index->backing_objects);\n\n\t/* check the netfs type is not already present */\n\tdown_write(&fscache_addremove_sem);\n\n\tret = -EEXIST;\n\tlist_for_each_entry(ptr, &fscache_netfs_list, link) {\n\t\tif (strcmp(ptr->name, netfs->name) == 0)\n\t\t\tgoto already_registered;\n\t}\n\n\tlist_add(&netfs->link, &fscache_netfs_list);\n\tret = 0;\n\n\tpr_notice(\"Netfs '%s' registered for caching\\n\", netfs->name);\n\nalready_registered:\n\tup_write(&fscache_addremove_sem);\n\n\tif (ret < 0) {\n\t\tnetfs->primary_index->parent = NULL;\n\t\t__fscache_cookie_put(netfs->primary_index);\n\t\tnetfs->primary_index = NULL;\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_proc_init",
          "args": [],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "afs_proc_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/proc.c",
          "lines": "125-145",
          "snippet": "int afs_proc_init(void)\n{\n\t_enter(\"\");\n\n\tproc_afs = proc_mkdir(\"fs/afs\", NULL);\n\tif (!proc_afs)\n\t\tgoto error_dir;\n\n\tif (!proc_create(\"cells\", 0644, proc_afs, &afs_proc_cells_fops) ||\n\t    !proc_create(\"rootcell\", 0644, proc_afs, &afs_proc_rootcell_fops))\n\t\tgoto error_tree;\n\n\t_leave(\" = 0\");\n\treturn 0;\n\nerror_tree:\n\tremove_proc_subtree(\"fs/afs\", NULL);\nerror_dir:\n\t_leave(\" = -ENOMEM\");\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct proc_dir_entry *proc_afs;",
            "static const struct file_operations afs_proc_cells_fops = {\n\t.open\t\t= afs_proc_cells_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= afs_proc_cells_write,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};",
            "static const struct file_operations afs_proc_rootcell_fops = {\n\t.read\t\t= afs_proc_rootcell_read,\n\t.write\t\t= afs_proc_rootcell_write,\n\t.llseek\t\t= no_llseek,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nstatic struct proc_dir_entry *proc_afs;\nstatic const struct file_operations afs_proc_cells_fops = {\n\t.open\t\t= afs_proc_cells_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= afs_proc_cells_write,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};\nstatic const struct file_operations afs_proc_rootcell_fops = {\n\t.read\t\t= afs_proc_rootcell_read,\n\t.write\t\t= afs_proc_rootcell_write,\n\t.llseek\t\t= no_llseek,\n};\n\nint afs_proc_init(void)\n{\n\t_enter(\"\");\n\n\tproc_afs = proc_mkdir(\"fs/afs\", NULL);\n\tif (!proc_afs)\n\t\tgoto error_dir;\n\n\tif (!proc_create(\"cells\", 0644, proc_afs, &afs_proc_cells_fops) ||\n\t    !proc_create(\"rootcell\", 0644, proc_afs, &afs_proc_rootcell_fops))\n\t\tgoto error_tree;\n\n\t_leave(\" = 0\");\n\treturn 0;\n\nerror_tree:\n\tremove_proc_subtree(\"fs/afs\", NULL);\nerror_dir:\n\t_leave(\" = -ENOMEM\");\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_workqueue",
          "args": [
            "\"afs\"",
            "0",
            "0"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_get_client_UUID",
          "args": [],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "afs_get_client_UUID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/main.c",
          "lines": "38-76",
          "snippet": "static int __init afs_get_client_UUID(void)\n{\n\tstruct timespec ts;\n\tu64 uuidtime;\n\tu16 clockseq;\n\tint ret;\n\n\t/* read the MAC address of one of the external interfaces and construct\n\t * a UUID from it */\n\tret = afs_get_MAC_address(afs_uuid.node, sizeof(afs_uuid.node));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tgetnstimeofday(&ts);\n\tuuidtime = (u64) ts.tv_sec * 1000 * 1000 * 10;\n\tuuidtime += ts.tv_nsec / 100;\n\tuuidtime += AFS_UUID_TO_UNIX_TIME;\n\tafs_uuid.time_low = uuidtime;\n\tafs_uuid.time_mid = uuidtime >> 32;\n\tafs_uuid.time_hi_and_version = (uuidtime >> 48) & AFS_UUID_TIMEHI_MASK;\n\tafs_uuid.time_hi_and_version |= AFS_UUID_VERSION_TIME;\n\n\tget_random_bytes(&clockseq, 2);\n\tafs_uuid.clock_seq_low = clockseq;\n\tafs_uuid.clock_seq_hi_and_reserved =\n\t\t(clockseq >> 8) & AFS_UUID_CLOCKHI_MASK;\n\tafs_uuid.clock_seq_hi_and_reserved |= AFS_UUID_VARIANT_STD;\n\n\t_debug(\"AFS UUID: %08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n\t       afs_uuid.time_low,\n\t       afs_uuid.time_mid,\n\t       afs_uuid.time_hi_and_version,\n\t       afs_uuid.clock_seq_hi_and_reserved,\n\t       afs_uuid.clock_seq_low,\n\t       afs_uuid.node[0], afs_uuid.node[1], afs_uuid.node[2],\n\t       afs_uuid.node[3], afs_uuid.node[4], afs_uuid.node[5]);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/completion.h>",
            "#include <linux/init.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct afs_uuid afs_uuid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/completion.h>\n#include <linux/init.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n\nstruct afs_uuid afs_uuid;\n\nstatic int __init afs_get_client_UUID(void)\n{\n\tstruct timespec ts;\n\tu64 uuidtime;\n\tu16 clockseq;\n\tint ret;\n\n\t/* read the MAC address of one of the external interfaces and construct\n\t * a UUID from it */\n\tret = afs_get_MAC_address(afs_uuid.node, sizeof(afs_uuid.node));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tgetnstimeofday(&ts);\n\tuuidtime = (u64) ts.tv_sec * 1000 * 1000 * 10;\n\tuuidtime += ts.tv_nsec / 100;\n\tuuidtime += AFS_UUID_TO_UNIX_TIME;\n\tafs_uuid.time_low = uuidtime;\n\tafs_uuid.time_mid = uuidtime >> 32;\n\tafs_uuid.time_hi_and_version = (uuidtime >> 48) & AFS_UUID_TIMEHI_MASK;\n\tafs_uuid.time_hi_and_version |= AFS_UUID_VERSION_TIME;\n\n\tget_random_bytes(&clockseq, 2);\n\tafs_uuid.clock_seq_low = clockseq;\n\tafs_uuid.clock_seq_hi_and_reserved =\n\t\t(clockseq >> 8) & AFS_UUID_CLOCKHI_MASK;\n\tafs_uuid.clock_seq_hi_and_reserved |= AFS_UUID_VARIANT_STD;\n\n\t_debug(\"AFS UUID: %08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n\t       afs_uuid.time_low,\n\t       afs_uuid.time_mid,\n\t       afs_uuid.time_hi_and_version,\n\t       afs_uuid.clock_seq_hi_and_reserved,\n\t       afs_uuid.clock_seq_low,\n\t       afs_uuid.node[0], afs_uuid.node[1], afs_uuid.node[2],\n\t       afs_uuid.node[3], afs_uuid.node[4], afs_uuid.node[5]);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/completion.h>\n#include <linux/init.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n\nstatic char *rootcell;\nstruct workqueue_struct *afs_wq;\n\nstatic int __init afs_init(void)\n{\n\tint ret;\n\n\tprintk(KERN_INFO \"kAFS: Red Hat AFS client v0.1 registering.\\n\");\n\n\tret = afs_get_client_UUID();\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* create workqueue */\n\tret = -ENOMEM;\n\tafs_wq = alloc_workqueue(\"afs\", 0, 0);\n\tif (!afs_wq)\n\t\treturn ret;\n\n\t/* register the /proc stuff */\n\tret = afs_proc_init();\n\tif (ret < 0)\n\t\tgoto error_proc;\n\n#ifdef CONFIG_AFS_FSCACHE\n\t/* we want to be able to cache */\n\tret = fscache_register_netfs(&afs_cache_netfs);\n\tif (ret < 0)\n\t\tgoto error_cache;\n#endif\n\n\t/* initialise the cell DB */\n\tret = afs_cell_init(rootcell);\n\tif (ret < 0)\n\t\tgoto error_cell_init;\n\n\t/* initialise the VL update process */\n\tret = afs_vlocation_update_init();\n\tif (ret < 0)\n\t\tgoto error_vl_update_init;\n\n\t/* initialise the callback update process */\n\tret = afs_callback_update_init();\n\tif (ret < 0)\n\t\tgoto error_callback_update_init;\n\n\t/* create the RxRPC transport */\n\tret = afs_open_socket();\n\tif (ret < 0)\n\t\tgoto error_open_socket;\n\n\t/* register the filesystems */\n\tret = afs_fs_init();\n\tif (ret < 0)\n\t\tgoto error_fs;\n\n\treturn ret;\n\nerror_fs:\n\tafs_close_socket();\nerror_open_socket:\n\tafs_callback_update_kill();\nerror_callback_update_init:\n\tafs_vlocation_purge();\nerror_vl_update_init:\n\tafs_cell_purge();\nerror_cell_init:\n#ifdef CONFIG_AFS_FSCACHE\n\tfscache_unregister_netfs(&afs_cache_netfs);\nerror_cache:\n#endif\n\tafs_proc_cleanup();\nerror_proc:\n\tdestroy_workqueue(afs_wq);\n\trcu_barrier();\n\tprintk(KERN_ERR \"kAFS: failed to register: %d\\n\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "afs_get_client_UUID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/main.c",
    "lines": "38-76",
    "snippet": "static int __init afs_get_client_UUID(void)\n{\n\tstruct timespec ts;\n\tu64 uuidtime;\n\tu16 clockseq;\n\tint ret;\n\n\t/* read the MAC address of one of the external interfaces and construct\n\t * a UUID from it */\n\tret = afs_get_MAC_address(afs_uuid.node, sizeof(afs_uuid.node));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tgetnstimeofday(&ts);\n\tuuidtime = (u64) ts.tv_sec * 1000 * 1000 * 10;\n\tuuidtime += ts.tv_nsec / 100;\n\tuuidtime += AFS_UUID_TO_UNIX_TIME;\n\tafs_uuid.time_low = uuidtime;\n\tafs_uuid.time_mid = uuidtime >> 32;\n\tafs_uuid.time_hi_and_version = (uuidtime >> 48) & AFS_UUID_TIMEHI_MASK;\n\tafs_uuid.time_hi_and_version |= AFS_UUID_VERSION_TIME;\n\n\tget_random_bytes(&clockseq, 2);\n\tafs_uuid.clock_seq_low = clockseq;\n\tafs_uuid.clock_seq_hi_and_reserved =\n\t\t(clockseq >> 8) & AFS_UUID_CLOCKHI_MASK;\n\tafs_uuid.clock_seq_hi_and_reserved |= AFS_UUID_VARIANT_STD;\n\n\t_debug(\"AFS UUID: %08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n\t       afs_uuid.time_low,\n\t       afs_uuid.time_mid,\n\t       afs_uuid.time_hi_and_version,\n\t       afs_uuid.clock_seq_hi_and_reserved,\n\t       afs_uuid.clock_seq_low,\n\t       afs_uuid.node[0], afs_uuid.node[1], afs_uuid.node[2],\n\t       afs_uuid.node[3], afs_uuid.node[4], afs_uuid.node[5]);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/completion.h>",
      "#include <linux/init.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct afs_uuid afs_uuid;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"AFS UUID: %08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x\"",
            "afs_uuid.time_low",
            "afs_uuid.time_mid",
            "afs_uuid.time_hi_and_version",
            "afs_uuid.clock_seq_hi_and_reserved",
            "afs_uuid.clock_seq_low",
            "afs_uuid.node[0]",
            "afs_uuid.node[1]",
            "afs_uuid.node[2]",
            "afs_uuid.node[3]",
            "afs_uuid.node[4]",
            "afs_uuid.node[5]"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_random_bytes",
          "args": [
            "&clockseq",
            "2"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getnstimeofday",
          "args": [
            "&ts"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_get_MAC_address",
          "args": [
            "afs_uuid.node",
            "sizeof(afs_uuid.node)"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "afs_get_MAC_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/netdevices.c",
          "lines": "18-33",
          "snippet": "int afs_get_MAC_address(u8 *mac, size_t maclen)\n{\n\tstruct net_device *dev;\n\tint ret = -ENODEV;\n\n\tBUG_ON(maclen != ETH_ALEN);\n\n\trtnl_lock();\n\tdev = __dev_getfirstbyhwtype(&init_net, ARPHRD_ETHER);\n\tif (dev) {\n\t\tmemcpy(mac, dev->dev_addr, maclen);\n\t\tret = 0;\n\t}\n\trtnl_unlock();\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/if_arp.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/inetdevice.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <net/net_namespace.h>\n#include <linux/if_arp.h>\n#include <linux/netdevice.h>\n#include <linux/inetdevice.h>\n#include <linux/rtnetlink.h>\n#include <linux/string.h>\n\nint afs_get_MAC_address(u8 *mac, size_t maclen)\n{\n\tstruct net_device *dev;\n\tint ret = -ENODEV;\n\n\tBUG_ON(maclen != ETH_ALEN);\n\n\trtnl_lock();\n\tdev = __dev_getfirstbyhwtype(&init_net, ARPHRD_ETHER);\n\tif (dev) {\n\t\tmemcpy(mac, dev->dev_addr, maclen);\n\t\tret = 0;\n\t}\n\trtnl_unlock();\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/completion.h>\n#include <linux/init.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n\nstruct afs_uuid afs_uuid;\n\nstatic int __init afs_get_client_UUID(void)\n{\n\tstruct timespec ts;\n\tu64 uuidtime;\n\tu16 clockseq;\n\tint ret;\n\n\t/* read the MAC address of one of the external interfaces and construct\n\t * a UUID from it */\n\tret = afs_get_MAC_address(afs_uuid.node, sizeof(afs_uuid.node));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tgetnstimeofday(&ts);\n\tuuidtime = (u64) ts.tv_sec * 1000 * 1000 * 10;\n\tuuidtime += ts.tv_nsec / 100;\n\tuuidtime += AFS_UUID_TO_UNIX_TIME;\n\tafs_uuid.time_low = uuidtime;\n\tafs_uuid.time_mid = uuidtime >> 32;\n\tafs_uuid.time_hi_and_version = (uuidtime >> 48) & AFS_UUID_TIMEHI_MASK;\n\tafs_uuid.time_hi_and_version |= AFS_UUID_VERSION_TIME;\n\n\tget_random_bytes(&clockseq, 2);\n\tafs_uuid.clock_seq_low = clockseq;\n\tafs_uuid.clock_seq_hi_and_reserved =\n\t\t(clockseq >> 8) & AFS_UUID_CLOCKHI_MASK;\n\tafs_uuid.clock_seq_hi_and_reserved |= AFS_UUID_VARIANT_STD;\n\n\t_debug(\"AFS UUID: %08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n\t       afs_uuid.time_low,\n\t       afs_uuid.time_mid,\n\t       afs_uuid.time_hi_and_version,\n\t       afs_uuid.clock_seq_hi_and_reserved,\n\t       afs_uuid.clock_seq_low,\n\t       afs_uuid.node[0], afs_uuid.node[1], afs_uuid.node[2],\n\t       afs_uuid.node[3], afs_uuid.node[4], afs_uuid.node[5]);\n\n\treturn 0;\n}"
  }
]