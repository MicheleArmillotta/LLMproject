[
  {
    "function_name": "xfs_setup_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
    "lines": "1242-1332",
    "snippet": "void\nxfs_setup_inode(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct inode\t\t*inode = &ip->i_vnode;\n\tgfp_t\t\t\tgfp_mask;\n\n\tinode->i_ino = ip->i_ino;\n\tinode->i_state = I_NEW;\n\n\tinode_sb_list_add(inode);\n\t/* make the inode look hashed for the writeback code */\n\thlist_add_fake(&inode->i_hash);\n\n\tinode->i_mode\t= ip->i_d.di_mode;\n\tset_nlink(inode, ip->i_d.di_nlink);\n\tinode->i_uid    = xfs_uid_to_kuid(ip->i_d.di_uid);\n\tinode->i_gid    = xfs_gid_to_kgid(ip->i_d.di_gid);\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\t\tinode->i_rdev =\n\t\t\tMKDEV(sysv_major(ip->i_df.if_u2.if_rdev) & 0x1ff,\n\t\t\t      sysv_minor(ip->i_df.if_u2.if_rdev));\n\t\tbreak;\n\tdefault:\n\t\tinode->i_rdev = 0;\n\t\tbreak;\n\t}\n\n\tinode->i_generation = ip->i_d.di_gen;\n\ti_size_write(inode, ip->i_d.di_size);\n\tinode->i_atime.tv_sec\t= ip->i_d.di_atime.t_sec;\n\tinode->i_atime.tv_nsec\t= ip->i_d.di_atime.t_nsec;\n\tinode->i_mtime.tv_sec\t= ip->i_d.di_mtime.t_sec;\n\tinode->i_mtime.tv_nsec\t= ip->i_d.di_mtime.t_nsec;\n\tinode->i_ctime.tv_sec\t= ip->i_d.di_ctime.t_sec;\n\tinode->i_ctime.tv_nsec\t= ip->i_d.di_ctime.t_nsec;\n\txfs_diflags_to_iflags(inode, ip);\n\n\tip->d_ops = ip->i_mount->m_nondir_inode_ops;\n\tlockdep_set_class(&ip->i_lock.mr_lock, &xfs_nondir_ilock_class);\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tinode->i_op = &xfs_inode_operations;\n\t\tinode->i_fop = &xfs_file_operations;\n\t\tinode->i_mapping->a_ops = &xfs_address_space_operations;\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tlockdep_set_class(&ip->i_lock.mr_lock, &xfs_dir_ilock_class);\n\t\tif (xfs_sb_version_hasasciici(&XFS_M(inode->i_sb)->m_sb))\n\t\t\tinode->i_op = &xfs_dir_ci_inode_operations;\n\t\telse\n\t\t\tinode->i_op = &xfs_dir_inode_operations;\n\t\tinode->i_fop = &xfs_dir_file_operations;\n\t\tip->d_ops = ip->i_mount->m_dir_inode_ops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &xfs_symlink_inode_operations;\n\t\tif (!(ip->i_df.if_flags & XFS_IFINLINE))\n\t\t\tinode->i_mapping->a_ops = &xfs_address_space_operations;\n\t\tbreak;\n\tdefault:\n\t\tinode->i_op = &xfs_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\t}\n\n\t/*\n\t * Ensure all page cache allocations are done from GFP_NOFS context to\n\t * prevent direct reclaim recursion back into the filesystem and blowing\n\t * stacks or deadlocking.\n\t */\n\tgfp_mask = mapping_gfp_mask(inode->i_mapping);\n\tmapping_set_gfp_mask(inode->i_mapping, (gfp_mask & ~(__GFP_FS)));\n\n\t/*\n\t * If there is no attribute fork no ACL can exist on this inode,\n\t * and it can't have any file capabilities attached to it either.\n\t */\n\tif (!XFS_IFORK_Q(ip)) {\n\t\tinode_has_no_xattr(inode);\n\t\tcache_no_acl(inode);\n\t}\n\n\txfs_iflags_clear(ip, XFS_INEW);\n\tbarrier();\n\n\tunlock_new_inode(inode);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/security.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/namei.h>",
      "#include <linux/xattr.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_acl.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lock_class_key xfs_nondir_ilock_class;",
      "static struct lock_class_key xfs_dir_ilock_class;",
      "STATIC struct",
      "STATIC struct",
      "static const struct inode_operations xfs_inode_operations = {\n\t.get_acl\t\t= xfs_get_acl,\n\t.set_acl\t\t= xfs_set_acl,\n\t.getattr\t\t= xfs_vn_getattr,\n\t.setattr\t\t= xfs_vn_setattr,\n\t.setxattr\t\t= generic_setxattr,\n\t.getxattr\t\t= generic_getxattr,\n\t.removexattr\t\t= generic_removexattr,\n\t.listxattr\t\t= xfs_vn_listxattr,\n\t.fiemap\t\t\t= xfs_vn_fiemap,\n\t.update_time\t\t= xfs_vn_update_time,\n};",
      "static const struct inode_operations xfs_dir_inode_operations = {\n\t.create\t\t\t= xfs_vn_create,\n\t.lookup\t\t\t= xfs_vn_lookup,\n\t.link\t\t\t= xfs_vn_link,\n\t.unlink\t\t\t= xfs_vn_unlink,\n\t.symlink\t\t= xfs_vn_symlink,\n\t.mkdir\t\t\t= xfs_vn_mkdir,\n\t/*\n\t * Yes, XFS uses the same method for rmdir and unlink.\n\t *\n\t * There are some subtile differences deeper in the code,\n\t * but we use S_ISDIR to check for those.\n\t */\n\t.rmdir\t\t\t= xfs_vn_unlink,\n\t.mknod\t\t\t= xfs_vn_mknod,\n\t.rename2\t\t= xfs_vn_rename,\n\t.get_acl\t\t= xfs_get_acl,\n\t.set_acl\t\t= xfs_set_acl,\n\t.getattr\t\t= xfs_vn_getattr,\n\t.setattr\t\t= xfs_vn_setattr,\n\t.setxattr\t\t= generic_setxattr,\n\t.getxattr\t\t= generic_getxattr,\n\t.removexattr\t\t= generic_removexattr,\n\t.listxattr\t\t= xfs_vn_listxattr,\n\t.update_time\t\t= xfs_vn_update_time,\n\t.tmpfile\t\t= xfs_vn_tmpfile,\n};",
      "static const struct inode_operations xfs_dir_ci_inode_operations = {\n\t.create\t\t\t= xfs_vn_create,\n\t.lookup\t\t\t= xfs_vn_ci_lookup,\n\t.link\t\t\t= xfs_vn_link,\n\t.unlink\t\t\t= xfs_vn_unlink,\n\t.symlink\t\t= xfs_vn_symlink,\n\t.mkdir\t\t\t= xfs_vn_mkdir,\n\t/*\n\t * Yes, XFS uses the same method for rmdir and unlink.\n\t *\n\t * There are some subtile differences deeper in the code,\n\t * but we use S_ISDIR to check for those.\n\t */\n\t.rmdir\t\t\t= xfs_vn_unlink,\n\t.mknod\t\t\t= xfs_vn_mknod,\n\t.rename2\t\t= xfs_vn_rename,\n\t.get_acl\t\t= xfs_get_acl,\n\t.set_acl\t\t= xfs_set_acl,\n\t.getattr\t\t= xfs_vn_getattr,\n\t.setattr\t\t= xfs_vn_setattr,\n\t.setxattr\t\t= generic_setxattr,\n\t.getxattr\t\t= generic_getxattr,\n\t.removexattr\t\t= generic_removexattr,\n\t.listxattr\t\t= xfs_vn_listxattr,\n\t.update_time\t\t= xfs_vn_update_time,\n\t.tmpfile\t\t= xfs_vn_tmpfile,\n};",
      "static const struct inode_operations xfs_symlink_inode_operations = {\n\t.readlink\t\t= generic_readlink,\n\t.follow_link\t\t= xfs_vn_follow_link,\n\t.put_link\t\t= kfree_put_link,\n\t.getattr\t\t= xfs_vn_getattr,\n\t.setattr\t\t= xfs_vn_setattr,\n\t.setxattr\t\t= generic_setxattr,\n\t.getxattr\t\t= generic_getxattr,\n\t.removexattr\t\t= generic_removexattr,\n\t.listxattr\t\t= xfs_vn_listxattr,\n\t.update_time\t\t= xfs_vn_update_time,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 1331
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iflags_clear",
          "args": [
            "ip",
            "XFS_INEW"
          ],
          "line": 1328
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iflags_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "126-132",
          "snippet": "static inline void\nxfs_iflags_clear(xfs_inode_t *ip, unsigned short flags)\n{\n\tspin_lock(&ip->i_flags_lock);\n\tip->i_flags &= ~flags;\n\tspin_unlock(&ip->i_flags_lock);\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline void\nxfs_iflags_clear(xfs_inode_t *ip, unsigned short flags)\n{\n\tspin_lock(&ip->i_flags_lock);\n\tip->i_flags &= ~flags;\n\tspin_unlock(&ip->i_flags_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache_no_acl",
          "args": [
            "inode"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_has_no_xattr",
          "args": [
            "inode"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_Q",
          "args": [
            "ip"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_set_gfp_mask",
          "args": [
            "inode->i_mapping",
            "(gfp_mask & ~(__GFP_FS))"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_gfp_mask",
          "args": [
            "inode->i_mapping"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_special_inode",
          "args": [
            "inode",
            "inode->i_mode",
            "inode->i_rdev"
          ],
          "line": 1307
        },
        "resolved": true,
        "details": {
          "function_name": "init_special_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1854-1871",
          "snippet": "void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hasasciici",
          "args": [
            "&XFS_M(inode->i_sb)->m_sb"
          ],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hasasciici",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "427-430",
          "snippet": "static inline bool xfs_sb_version_hasasciici(struct xfs_sb *sbp)\n{\n\treturn (sbp->sb_versionnum & XFS_SB_VERSION_BORGBIT);\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_BORGBIT\t\t0x4000\t/* ASCII only case-insens. */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_BORGBIT\t\t0x4000\t/* ASCII only case-insens. */\n\nstatic inline bool xfs_sb_version_hasasciici(struct xfs_sb *sbp)\n{\n\treturn (sbp->sb_versionnum & XFS_SB_VERSION_BORGBIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_M",
          "args": [
            "inode->i_sb"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_set_class",
          "args": [
            "&ip->i_lock.mr_lock",
            "&xfs_dir_ilock_class"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_set_class",
          "args": [
            "&ip->i_lock.mr_lock",
            "&xfs_nondir_ilock_class"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_diflags_to_iflags",
          "args": [
            "inode",
            "ip"
          ],
          "line": 1281
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_diflags_to_iflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
          "lines": "1207-1228",
          "snippet": "STATIC void\nxfs_diflags_to_iflags(\n\tstruct inode\t\t*inode,\n\tstruct xfs_inode\t*ip)\n{\n\tif (ip->i_d.di_flags & XFS_DIFLAG_IMMUTABLE)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\telse\n\t\tinode->i_flags &= ~S_IMMUTABLE;\n\tif (ip->i_d.di_flags & XFS_DIFLAG_APPEND)\n\t\tinode->i_flags |= S_APPEND;\n\telse\n\t\tinode->i_flags &= ~S_APPEND;\n\tif (ip->i_d.di_flags & XFS_DIFLAG_SYNC)\n\t\tinode->i_flags |= S_SYNC;\n\telse\n\t\tinode->i_flags &= ~S_SYNC;\n\tif (ip->i_d.di_flags & XFS_DIFLAG_NOATIME)\n\t\tinode->i_flags |= S_NOATIME;\n\telse\n\t\tinode->i_flags &= ~S_NOATIME;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/security.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/namei.h>",
            "#include <linux/xattr.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_acl.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_diflags_to_iflags(\n\tstruct inode\t\t*inode,\n\tstruct xfs_inode\t*ip)\n{\n\tif (ip->i_d.di_flags & XFS_DIFLAG_IMMUTABLE)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\telse\n\t\tinode->i_flags &= ~S_IMMUTABLE;\n\tif (ip->i_d.di_flags & XFS_DIFLAG_APPEND)\n\t\tinode->i_flags |= S_APPEND;\n\telse\n\t\tinode->i_flags &= ~S_APPEND;\n\tif (ip->i_d.di_flags & XFS_DIFLAG_SYNC)\n\t\tinode->i_flags |= S_SYNC;\n\telse\n\t\tinode->i_flags &= ~S_SYNC;\n\tif (ip->i_d.di_flags & XFS_DIFLAG_NOATIME)\n\t\tinode->i_flags |= S_NOATIME;\n\telse\n\t\tinode->i_flags &= ~S_NOATIME;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "ip->i_d.di_size"
          ],
          "line": 1274
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MKDEV",
          "args": [
            "sysv_major(ip->i_df.if_u2.if_rdev) & 0x1ff",
            "sysv_minor(ip->i_df.if_u2.if_rdev)"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysv_minor",
          "args": [
            "ip->i_df.if_u2.if_rdev"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysv_major",
          "args": [
            "ip->i_df.if_u2.if_rdev"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_gid_to_kgid",
          "args": [
            "ip->i_d.di_gid"
          ],
          "line": 1259
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_gid_to_kgid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "218-221",
          "snippet": "static inline kgid_t xfs_gid_to_kgid(__uint32_t gid)\n{\n\treturn make_kgid(&init_user_ns, gid);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline kgid_t xfs_gid_to_kgid(__uint32_t gid)\n{\n\treturn make_kgid(&init_user_ns, gid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_uid_to_kuid",
          "args": [
            "ip->i_d.di_uid"
          ],
          "line": 1258
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_uid_to_kuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "208-211",
          "snippet": "static inline kuid_t xfs_uid_to_kuid(__uint32_t uid)\n{\n\treturn make_kuid(&init_user_ns, uid);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline kuid_t xfs_uid_to_kuid(__uint32_t uid)\n{\n\treturn make_kuid(&init_user_ns, uid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "ip->i_d.di_nlink"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_add_fake",
          "args": [
            "&inode->i_hash"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_sb_list_add",
          "args": [
            "inode"
          ],
          "line": 1252
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "425-430",
          "snippet": "void inode_sb_list_add(struct inode *inode)\n{\n\tspin_lock(&inode_sb_list_lock);\n\tlist_add(&inode->i_sb_list, &inode->i_sb->s_inodes);\n\tspin_unlock(&inode_sb_list_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_sb_list_add(struct inode *inode)\n{\n\tspin_lock(&inode_sb_list_lock);\n\tlist_add(&inode->i_sb_list, &inode->i_sb->s_inodes);\n\tspin_unlock(&inode_sb_list_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic struct lock_class_key xfs_nondir_ilock_class;\nstatic struct lock_class_key xfs_dir_ilock_class;\nSTATIC struct;\nSTATIC struct;\nstatic const struct inode_operations xfs_inode_operations = {\n\t.get_acl\t\t= xfs_get_acl,\n\t.set_acl\t\t= xfs_set_acl,\n\t.getattr\t\t= xfs_vn_getattr,\n\t.setattr\t\t= xfs_vn_setattr,\n\t.setxattr\t\t= generic_setxattr,\n\t.getxattr\t\t= generic_getxattr,\n\t.removexattr\t\t= generic_removexattr,\n\t.listxattr\t\t= xfs_vn_listxattr,\n\t.fiemap\t\t\t= xfs_vn_fiemap,\n\t.update_time\t\t= xfs_vn_update_time,\n};\nstatic const struct inode_operations xfs_dir_inode_operations = {\n\t.create\t\t\t= xfs_vn_create,\n\t.lookup\t\t\t= xfs_vn_lookup,\n\t.link\t\t\t= xfs_vn_link,\n\t.unlink\t\t\t= xfs_vn_unlink,\n\t.symlink\t\t= xfs_vn_symlink,\n\t.mkdir\t\t\t= xfs_vn_mkdir,\n\t/*\n\t * Yes, XFS uses the same method for rmdir and unlink.\n\t *\n\t * There are some subtile differences deeper in the code,\n\t * but we use S_ISDIR to check for those.\n\t */\n\t.rmdir\t\t\t= xfs_vn_unlink,\n\t.mknod\t\t\t= xfs_vn_mknod,\n\t.rename2\t\t= xfs_vn_rename,\n\t.get_acl\t\t= xfs_get_acl,\n\t.set_acl\t\t= xfs_set_acl,\n\t.getattr\t\t= xfs_vn_getattr,\n\t.setattr\t\t= xfs_vn_setattr,\n\t.setxattr\t\t= generic_setxattr,\n\t.getxattr\t\t= generic_getxattr,\n\t.removexattr\t\t= generic_removexattr,\n\t.listxattr\t\t= xfs_vn_listxattr,\n\t.update_time\t\t= xfs_vn_update_time,\n\t.tmpfile\t\t= xfs_vn_tmpfile,\n};\nstatic const struct inode_operations xfs_dir_ci_inode_operations = {\n\t.create\t\t\t= xfs_vn_create,\n\t.lookup\t\t\t= xfs_vn_ci_lookup,\n\t.link\t\t\t= xfs_vn_link,\n\t.unlink\t\t\t= xfs_vn_unlink,\n\t.symlink\t\t= xfs_vn_symlink,\n\t.mkdir\t\t\t= xfs_vn_mkdir,\n\t/*\n\t * Yes, XFS uses the same method for rmdir and unlink.\n\t *\n\t * There are some subtile differences deeper in the code,\n\t * but we use S_ISDIR to check for those.\n\t */\n\t.rmdir\t\t\t= xfs_vn_unlink,\n\t.mknod\t\t\t= xfs_vn_mknod,\n\t.rename2\t\t= xfs_vn_rename,\n\t.get_acl\t\t= xfs_get_acl,\n\t.set_acl\t\t= xfs_set_acl,\n\t.getattr\t\t= xfs_vn_getattr,\n\t.setattr\t\t= xfs_vn_setattr,\n\t.setxattr\t\t= generic_setxattr,\n\t.getxattr\t\t= generic_getxattr,\n\t.removexattr\t\t= generic_removexattr,\n\t.listxattr\t\t= xfs_vn_listxattr,\n\t.update_time\t\t= xfs_vn_update_time,\n\t.tmpfile\t\t= xfs_vn_tmpfile,\n};\nstatic const struct inode_operations xfs_symlink_inode_operations = {\n\t.readlink\t\t= generic_readlink,\n\t.follow_link\t\t= xfs_vn_follow_link,\n\t.put_link\t\t= kfree_put_link,\n\t.getattr\t\t= xfs_vn_getattr,\n\t.setattr\t\t= xfs_vn_setattr,\n\t.setxattr\t\t= generic_setxattr,\n\t.getxattr\t\t= generic_getxattr,\n\t.removexattr\t\t= generic_removexattr,\n\t.listxattr\t\t= xfs_vn_listxattr,\n\t.update_time\t\t= xfs_vn_update_time,\n};\n\nvoid\nxfs_setup_inode(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct inode\t\t*inode = &ip->i_vnode;\n\tgfp_t\t\t\tgfp_mask;\n\n\tinode->i_ino = ip->i_ino;\n\tinode->i_state = I_NEW;\n\n\tinode_sb_list_add(inode);\n\t/* make the inode look hashed for the writeback code */\n\thlist_add_fake(&inode->i_hash);\n\n\tinode->i_mode\t= ip->i_d.di_mode;\n\tset_nlink(inode, ip->i_d.di_nlink);\n\tinode->i_uid    = xfs_uid_to_kuid(ip->i_d.di_uid);\n\tinode->i_gid    = xfs_gid_to_kgid(ip->i_d.di_gid);\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\t\tinode->i_rdev =\n\t\t\tMKDEV(sysv_major(ip->i_df.if_u2.if_rdev) & 0x1ff,\n\t\t\t      sysv_minor(ip->i_df.if_u2.if_rdev));\n\t\tbreak;\n\tdefault:\n\t\tinode->i_rdev = 0;\n\t\tbreak;\n\t}\n\n\tinode->i_generation = ip->i_d.di_gen;\n\ti_size_write(inode, ip->i_d.di_size);\n\tinode->i_atime.tv_sec\t= ip->i_d.di_atime.t_sec;\n\tinode->i_atime.tv_nsec\t= ip->i_d.di_atime.t_nsec;\n\tinode->i_mtime.tv_sec\t= ip->i_d.di_mtime.t_sec;\n\tinode->i_mtime.tv_nsec\t= ip->i_d.di_mtime.t_nsec;\n\tinode->i_ctime.tv_sec\t= ip->i_d.di_ctime.t_sec;\n\tinode->i_ctime.tv_nsec\t= ip->i_d.di_ctime.t_nsec;\n\txfs_diflags_to_iflags(inode, ip);\n\n\tip->d_ops = ip->i_mount->m_nondir_inode_ops;\n\tlockdep_set_class(&ip->i_lock.mr_lock, &xfs_nondir_ilock_class);\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFREG:\n\t\tinode->i_op = &xfs_inode_operations;\n\t\tinode->i_fop = &xfs_file_operations;\n\t\tinode->i_mapping->a_ops = &xfs_address_space_operations;\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tlockdep_set_class(&ip->i_lock.mr_lock, &xfs_dir_ilock_class);\n\t\tif (xfs_sb_version_hasasciici(&XFS_M(inode->i_sb)->m_sb))\n\t\t\tinode->i_op = &xfs_dir_ci_inode_operations;\n\t\telse\n\t\t\tinode->i_op = &xfs_dir_inode_operations;\n\t\tinode->i_fop = &xfs_dir_file_operations;\n\t\tip->d_ops = ip->i_mount->m_dir_inode_ops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &xfs_symlink_inode_operations;\n\t\tif (!(ip->i_df.if_flags & XFS_IFINLINE))\n\t\t\tinode->i_mapping->a_ops = &xfs_address_space_operations;\n\t\tbreak;\n\tdefault:\n\t\tinode->i_op = &xfs_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\t}\n\n\t/*\n\t * Ensure all page cache allocations are done from GFP_NOFS context to\n\t * prevent direct reclaim recursion back into the filesystem and blowing\n\t * stacks or deadlocking.\n\t */\n\tgfp_mask = mapping_gfp_mask(inode->i_mapping);\n\tmapping_set_gfp_mask(inode->i_mapping, (gfp_mask & ~(__GFP_FS)));\n\n\t/*\n\t * If there is no attribute fork no ACL can exist on this inode,\n\t * and it can't have any file capabilities attached to it either.\n\t */\n\tif (!XFS_IFORK_Q(ip)) {\n\t\tinode_has_no_xattr(inode);\n\t\tcache_no_acl(inode);\n\t}\n\n\txfs_iflags_clear(ip, XFS_INEW);\n\tbarrier();\n\n\tunlock_new_inode(inode);\n}"
  },
  {
    "function_name": "xfs_diflags_to_iflags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
    "lines": "1207-1228",
    "snippet": "STATIC void\nxfs_diflags_to_iflags(\n\tstruct inode\t\t*inode,\n\tstruct xfs_inode\t*ip)\n{\n\tif (ip->i_d.di_flags & XFS_DIFLAG_IMMUTABLE)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\telse\n\t\tinode->i_flags &= ~S_IMMUTABLE;\n\tif (ip->i_d.di_flags & XFS_DIFLAG_APPEND)\n\t\tinode->i_flags |= S_APPEND;\n\telse\n\t\tinode->i_flags &= ~S_APPEND;\n\tif (ip->i_d.di_flags & XFS_DIFLAG_SYNC)\n\t\tinode->i_flags |= S_SYNC;\n\telse\n\t\tinode->i_flags &= ~S_SYNC;\n\tif (ip->i_d.di_flags & XFS_DIFLAG_NOATIME)\n\t\tinode->i_flags |= S_NOATIME;\n\telse\n\t\tinode->i_flags &= ~S_NOATIME;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/security.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/namei.h>",
      "#include <linux/xattr.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_acl.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_diflags_to_iflags(\n\tstruct inode\t\t*inode,\n\tstruct xfs_inode\t*ip)\n{\n\tif (ip->i_d.di_flags & XFS_DIFLAG_IMMUTABLE)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\telse\n\t\tinode->i_flags &= ~S_IMMUTABLE;\n\tif (ip->i_d.di_flags & XFS_DIFLAG_APPEND)\n\t\tinode->i_flags |= S_APPEND;\n\telse\n\t\tinode->i_flags &= ~S_APPEND;\n\tif (ip->i_d.di_flags & XFS_DIFLAG_SYNC)\n\t\tinode->i_flags |= S_SYNC;\n\telse\n\t\tinode->i_flags &= ~S_SYNC;\n\tif (ip->i_d.di_flags & XFS_DIFLAG_NOATIME)\n\t\tinode->i_flags |= S_NOATIME;\n\telse\n\t\tinode->i_flags &= ~S_NOATIME;\n}"
  },
  {
    "function_name": "xfs_vn_tmpfile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
    "lines": "1116-1123",
    "snippet": "STATIC int\nxfs_vn_tmpfile(\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry,\n\tumode_t\t\tmode)\n{\n\treturn xfs_generic_create(dir, dentry, mode, 0, true);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/security.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/namei.h>",
      "#include <linux/xattr.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_acl.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_generic_create",
          "args": [
            "dir",
            "dentry",
            "mode",
            "0",
            "true"
          ],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_generic_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
          "lines": "127-202",
          "snippet": "STATIC int\nxfs_generic_create(\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry,\n\tumode_t\t\tmode,\n\tdev_t\t\trdev,\n\tbool\t\ttmpfile)\t/* unnamed file */\n{\n\tstruct inode\t*inode;\n\tstruct xfs_inode *ip = NULL;\n\tstruct posix_acl *default_acl, *acl;\n\tstruct xfs_name\tname;\n\tint\t\terror;\n\n\t/*\n\t * Irix uses Missed'em'V split, but doesn't want to see\n\t * the upper 5 bits of (14bit) major.\n\t */\n\tif (S_ISCHR(mode) || S_ISBLK(mode)) {\n\t\tif (unlikely(!sysv_valid_dev(rdev) || MAJOR(rdev) & ~0x1ff))\n\t\t\treturn -EINVAL;\n\t\trdev = sysv_encode_dev(rdev);\n\t} else {\n\t\trdev = 0;\n\t}\n\n\terror = posix_acl_create(dir, &mode, &default_acl, &acl);\n\tif (error)\n\t\treturn error;\n\n\tif (!tmpfile) {\n\t\txfs_dentry_to_name(&name, dentry, mode);\n\t\terror = xfs_create(XFS_I(dir), &name, mode, rdev, &ip);\n\t} else {\n\t\terror = xfs_create_tmpfile(XFS_I(dir), dentry, mode, &ip);\n\t}\n\tif (unlikely(error))\n\t\tgoto out_free_acl;\n\n\tinode = VFS_I(ip);\n\n\terror = xfs_init_security(inode, dir, &dentry->d_name);\n\tif (unlikely(error))\n\t\tgoto out_cleanup_inode;\n\n#ifdef CONFIG_XFS_POSIX_ACL\n\tif (default_acl) {\n\t\terror = xfs_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);\n\t\tif (error)\n\t\t\tgoto out_cleanup_inode;\n\t}\n\tif (acl) {\n\t\terror = xfs_set_acl(inode, acl, ACL_TYPE_ACCESS);\n\t\tif (error)\n\t\t\tgoto out_cleanup_inode;\n\t}\n#endif\n\n\tif (tmpfile)\n\t\td_tmpfile(dentry, inode);\n\telse\n\t\td_instantiate(dentry, inode);\n\n out_free_acl:\n\tif (default_acl)\n\t\tposix_acl_release(default_acl);\n\tif (acl)\n\t\tposix_acl_release(acl);\n\treturn error;\n\n out_cleanup_inode:\n\tif (!tmpfile)\n\t\txfs_cleanup_inode(dir, inode, dentry);\n\tiput(inode);\n\tgoto out_free_acl;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/security.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/namei.h>",
            "#include <linux/xattr.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_acl.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_generic_create(\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry,\n\tumode_t\t\tmode,\n\tdev_t\t\trdev,\n\tbool\t\ttmpfile)\t/* unnamed file */\n{\n\tstruct inode\t*inode;\n\tstruct xfs_inode *ip = NULL;\n\tstruct posix_acl *default_acl, *acl;\n\tstruct xfs_name\tname;\n\tint\t\terror;\n\n\t/*\n\t * Irix uses Missed'em'V split, but doesn't want to see\n\t * the upper 5 bits of (14bit) major.\n\t */\n\tif (S_ISCHR(mode) || S_ISBLK(mode)) {\n\t\tif (unlikely(!sysv_valid_dev(rdev) || MAJOR(rdev) & ~0x1ff))\n\t\t\treturn -EINVAL;\n\t\trdev = sysv_encode_dev(rdev);\n\t} else {\n\t\trdev = 0;\n\t}\n\n\terror = posix_acl_create(dir, &mode, &default_acl, &acl);\n\tif (error)\n\t\treturn error;\n\n\tif (!tmpfile) {\n\t\txfs_dentry_to_name(&name, dentry, mode);\n\t\terror = xfs_create(XFS_I(dir), &name, mode, rdev, &ip);\n\t} else {\n\t\terror = xfs_create_tmpfile(XFS_I(dir), dentry, mode, &ip);\n\t}\n\tif (unlikely(error))\n\t\tgoto out_free_acl;\n\n\tinode = VFS_I(ip);\n\n\terror = xfs_init_security(inode, dir, &dentry->d_name);\n\tif (unlikely(error))\n\t\tgoto out_cleanup_inode;\n\n#ifdef CONFIG_XFS_POSIX_ACL\n\tif (default_acl) {\n\t\terror = xfs_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);\n\t\tif (error)\n\t\t\tgoto out_cleanup_inode;\n\t}\n\tif (acl) {\n\t\terror = xfs_set_acl(inode, acl, ACL_TYPE_ACCESS);\n\t\tif (error)\n\t\t\tgoto out_cleanup_inode;\n\t}\n#endif\n\n\tif (tmpfile)\n\t\td_tmpfile(dentry, inode);\n\telse\n\t\td_instantiate(dentry, inode);\n\n out_free_acl:\n\tif (default_acl)\n\t\tposix_acl_release(default_acl);\n\tif (acl)\n\t\tposix_acl_release(acl);\n\treturn error;\n\n out_cleanup_inode:\n\tif (!tmpfile)\n\t\txfs_cleanup_inode(dir, inode, dentry);\n\tiput(inode);\n\tgoto out_free_acl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_vn_tmpfile(\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry,\n\tumode_t\t\tmode)\n{\n\treturn xfs_generic_create(dir, dentry, mode, 0, true);\n}"
  },
  {
    "function_name": "xfs_vn_fiemap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
    "lines": "1075-1114",
    "snippet": "STATIC int\nxfs_vn_fiemap(\n\tstruct inode\t\t*inode,\n\tstruct fiemap_extent_info *fieinfo,\n\tu64\t\t\tstart,\n\tu64\t\t\tlength)\n{\n\txfs_inode_t\t\t*ip = XFS_I(inode);\n\tstruct getbmapx\t\tbm;\n\tint\t\t\terror;\n\n\terror = fiemap_check_flags(fieinfo, XFS_FIEMAP_FLAGS);\n\tif (error)\n\t\treturn error;\n\n\t/* Set up bmap header for xfs internal routine */\n\tbm.bmv_offset = BTOBBT(start);\n\t/* Special case for whole file */\n\tif (length == FIEMAP_MAX_OFFSET)\n\t\tbm.bmv_length = -1LL;\n\telse\n\t\tbm.bmv_length = BTOBB(start + length) - bm.bmv_offset;\n\n\t/* We add one because in getbmap world count includes the header */\n\tbm.bmv_count = !fieinfo->fi_extents_max ? MAXEXTNUM :\n\t\t\t\t\tfieinfo->fi_extents_max + 1;\n\tbm.bmv_count = min_t(__s32, bm.bmv_count,\n\t\t\t     (PAGE_SIZE * 16 / sizeof(struct getbmapx)));\n\tbm.bmv_iflags = BMV_IF_PREALLOC | BMV_IF_NO_HOLES;\n\tif (fieinfo->fi_flags & FIEMAP_FLAG_XATTR)\n\t\tbm.bmv_iflags |= BMV_IF_ATTRFORK;\n\tif (!(fieinfo->fi_flags & FIEMAP_FLAG_SYNC))\n\t\tbm.bmv_iflags |= BMV_IF_DELALLOC;\n\n\terror = xfs_getbmap(ip, &bm, xfs_fiemap_format, fieinfo);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/security.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/namei.h>",
      "#include <linux/xattr.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_acl.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [
      "#define XFS_FIEMAP_FLAGS\t(FIEMAP_FLAG_SYNC|FIEMAP_FLAG_XATTR)"
    ],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_getbmap",
          "args": [
            "ip",
            "&bm",
            "xfs_fiemap_format",
            "fieinfo"
          ],
          "line": 1109
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_getbmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "489-715",
          "snippet": "int\t\t\t\t\t\t/* error code */\nxfs_getbmap(\n\txfs_inode_t\t\t*ip,\n\tstruct getbmapx\t\t*bmv,\t\t/* user bmap structure */\n\txfs_bmap_format_t\tformatter,\t/* format to user */\n\tvoid\t\t\t*arg)\t\t/* formatter arg */\n{\n\t__int64_t\t\tbmvend;\t\t/* last block requested */\n\tint\t\t\terror = 0;\t/* return value */\n\t__int64_t\t\tfixlen;\t\t/* length for -1 case */\n\tint\t\t\ti;\t\t/* extent number */\n\tint\t\t\tlock;\t\t/* lock state */\n\txfs_bmbt_irec_t\t\t*map;\t\t/* buffer for user's data */\n\txfs_mount_t\t\t*mp;\t\t/* file system mount point */\n\tint\t\t\tnex;\t\t/* # of user extents can do */\n\tint\t\t\tnexleft;\t/* # of user extents left */\n\tint\t\t\tsubnex;\t\t/* # of bmapi's can do */\n\tint\t\t\tnmap;\t\t/* number of map entries */\n\tstruct getbmapx\t\t*out;\t\t/* output structure */\n\tint\t\t\twhichfork;\t/* data or attr fork */\n\tint\t\t\tprealloced;\t/* this is a file with\n\t\t\t\t\t\t * preallocated data space */\n\tint\t\t\tiflags;\t\t/* interface flags */\n\tint\t\t\tbmapi_flags;\t/* flags for xfs_bmapi */\n\tint\t\t\tcur_ext = 0;\n\n\tmp = ip->i_mount;\n\tiflags = bmv->bmv_iflags;\n\twhichfork = iflags & BMV_IF_ATTRFORK ? XFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tif (whichfork == XFS_ATTR_FORK) {\n\t\tif (XFS_IFORK_Q(ip)) {\n\t\t\tif (ip->i_d.di_aformat != XFS_DINODE_FMT_EXTENTS &&\n\t\t\t    ip->i_d.di_aformat != XFS_DINODE_FMT_BTREE &&\n\t\t\t    ip->i_d.di_aformat != XFS_DINODE_FMT_LOCAL)\n\t\t\t\treturn -EINVAL;\n\t\t} else if (unlikely(\n\t\t\t   ip->i_d.di_aformat != 0 &&\n\t\t\t   ip->i_d.di_aformat != XFS_DINODE_FMT_EXTENTS)) {\n\t\t\tXFS_ERROR_REPORT(\"xfs_getbmap\", XFS_ERRLEVEL_LOW,\n\t\t\t\t\t ip->i_mount);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\n\t\tprealloced = 0;\n\t\tfixlen = 1LL << 32;\n\t} else {\n\t\tif (ip->i_d.di_format != XFS_DINODE_FMT_EXTENTS &&\n\t\t    ip->i_d.di_format != XFS_DINODE_FMT_BTREE &&\n\t\t    ip->i_d.di_format != XFS_DINODE_FMT_LOCAL)\n\t\t\treturn -EINVAL;\n\n\t\tif (xfs_get_extsz_hint(ip) ||\n\t\t    ip->i_d.di_flags & (XFS_DIFLAG_PREALLOC|XFS_DIFLAG_APPEND)){\n\t\t\tprealloced = 1;\n\t\t\tfixlen = mp->m_super->s_maxbytes;\n\t\t} else {\n\t\t\tprealloced = 0;\n\t\t\tfixlen = XFS_ISIZE(ip);\n\t\t}\n\t}\n\n\tif (bmv->bmv_length == -1) {\n\t\tfixlen = XFS_FSB_TO_BB(mp, XFS_B_TO_FSB(mp, fixlen));\n\t\tbmv->bmv_length =\n\t\t\tmax_t(__int64_t, fixlen - bmv->bmv_offset, 0);\n\t} else if (bmv->bmv_length == 0) {\n\t\tbmv->bmv_entries = 0;\n\t\treturn 0;\n\t} else if (bmv->bmv_length < 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tnex = bmv->bmv_count - 1;\n\tif (nex <= 0)\n\t\treturn -EINVAL;\n\tbmvend = bmv->bmv_offset + bmv->bmv_length;\n\n\n\tif (bmv->bmv_count > ULONG_MAX / sizeof(struct getbmapx))\n\t\treturn -ENOMEM;\n\tout = kmem_zalloc_large(bmv->bmv_count * sizeof(struct getbmapx), 0);\n\tif (!out)\n\t\treturn -ENOMEM;\n\n\txfs_ilock(ip, XFS_IOLOCK_SHARED);\n\tif (whichfork == XFS_DATA_FORK) {\n\t\tif (!(iflags & BMV_IF_DELALLOC) &&\n\t\t    (ip->i_delayed_blks || XFS_ISIZE(ip) > ip->i_d.di_size)) {\n\t\t\terror = filemap_write_and_wait(VFS_I(ip)->i_mapping);\n\t\t\tif (error)\n\t\t\t\tgoto out_unlock_iolock;\n\n\t\t\t/*\n\t\t\t * Even after flushing the inode, there can still be\n\t\t\t * delalloc blocks on the inode beyond EOF due to\n\t\t\t * speculative preallocation.  These are not removed\n\t\t\t * until the release function is called or the inode\n\t\t\t * is inactivated.  Hence we cannot assert here that\n\t\t\t * ip->i_delayed_blks == 0.\n\t\t\t */\n\t\t}\n\n\t\tlock = xfs_ilock_data_map_shared(ip);\n\t} else {\n\t\tlock = xfs_ilock_attr_map_shared(ip);\n\t}\n\n\t/*\n\t * Don't let nex be bigger than the number of extents\n\t * we can have assuming alternating holes and real extents.\n\t */\n\tif (nex > XFS_IFORK_NEXTENTS(ip, whichfork) * 2 + 1)\n\t\tnex = XFS_IFORK_NEXTENTS(ip, whichfork) * 2 + 1;\n\n\tbmapi_flags = xfs_bmapi_aflag(whichfork);\n\tif (!(iflags & BMV_IF_PREALLOC))\n\t\tbmapi_flags |= XFS_BMAPI_IGSTATE;\n\n\t/*\n\t * Allocate enough space to handle \"subnex\" maps at a time.\n\t */\n\terror = -ENOMEM;\n\tsubnex = 16;\n\tmap = kmem_alloc(subnex * sizeof(*map), KM_MAYFAIL | KM_NOFS);\n\tif (!map)\n\t\tgoto out_unlock_ilock;\n\n\tbmv->bmv_entries = 0;\n\n\tif (XFS_IFORK_NEXTENTS(ip, whichfork) == 0 &&\n\t    (whichfork == XFS_ATTR_FORK || !(iflags & BMV_IF_DELALLOC))) {\n\t\terror = 0;\n\t\tgoto out_free_map;\n\t}\n\n\tnexleft = nex;\n\n\tdo {\n\t\tnmap = (nexleft > subnex) ? subnex : nexleft;\n\t\terror = xfs_bmapi_read(ip, XFS_BB_TO_FSBT(mp, bmv->bmv_offset),\n\t\t\t\t       XFS_BB_TO_FSB(mp, bmv->bmv_length),\n\t\t\t\t       map, &nmap, bmapi_flags);\n\t\tif (error)\n\t\t\tgoto out_free_map;\n\t\tASSERT(nmap <= subnex);\n\n\t\tfor (i = 0; i < nmap && nexleft && bmv->bmv_length; i++) {\n\t\t\tout[cur_ext].bmv_oflags = 0;\n\t\t\tif (map[i].br_state == XFS_EXT_UNWRITTEN)\n\t\t\t\tout[cur_ext].bmv_oflags |= BMV_OF_PREALLOC;\n\t\t\telse if (map[i].br_startblock == DELAYSTARTBLOCK)\n\t\t\t\tout[cur_ext].bmv_oflags |= BMV_OF_DELALLOC;\n\t\t\tout[cur_ext].bmv_offset =\n\t\t\t\tXFS_FSB_TO_BB(mp, map[i].br_startoff);\n\t\t\tout[cur_ext].bmv_length =\n\t\t\t\tXFS_FSB_TO_BB(mp, map[i].br_blockcount);\n\t\t\tout[cur_ext].bmv_unused1 = 0;\n\t\t\tout[cur_ext].bmv_unused2 = 0;\n\n\t\t\t/*\n\t\t\t * delayed allocation extents that start beyond EOF can\n\t\t\t * occur due to speculative EOF allocation when the\n\t\t\t * delalloc extent is larger than the largest freespace\n\t\t\t * extent at conversion time. These extents cannot be\n\t\t\t * converted by data writeback, so can exist here even\n\t\t\t * if we are not supposed to be finding delalloc\n\t\t\t * extents.\n\t\t\t */\n\t\t\tif (map[i].br_startblock == DELAYSTARTBLOCK &&\n\t\t\t    map[i].br_startoff <= XFS_B_TO_FSB(mp, XFS_ISIZE(ip)))\n\t\t\t\tASSERT((iflags & BMV_IF_DELALLOC) != 0);\n\n                        if (map[i].br_startblock == HOLESTARTBLOCK &&\n\t\t\t    whichfork == XFS_ATTR_FORK) {\n\t\t\t\t/* came to the end of attribute fork */\n\t\t\t\tout[cur_ext].bmv_oflags |= BMV_OF_LAST;\n\t\t\t\tgoto out_free_map;\n\t\t\t}\n\n\t\t\tif (!xfs_getbmapx_fix_eof_hole(ip, &out[cur_ext],\n\t\t\t\t\tprealloced, bmvend,\n\t\t\t\t\tmap[i].br_startblock))\n\t\t\t\tgoto out_free_map;\n\n\t\t\tbmv->bmv_offset =\n\t\t\t\tout[cur_ext].bmv_offset +\n\t\t\t\tout[cur_ext].bmv_length;\n\t\t\tbmv->bmv_length =\n\t\t\t\tmax_t(__int64_t, 0, bmvend - bmv->bmv_offset);\n\n\t\t\t/*\n\t\t\t * In case we don't want to return the hole,\n\t\t\t * don't increase cur_ext so that we can reuse\n\t\t\t * it in the next loop.\n\t\t\t */\n\t\t\tif ((iflags & BMV_IF_NO_HOLES) &&\n\t\t\t    map[i].br_startblock == HOLESTARTBLOCK) {\n\t\t\t\tmemset(&out[cur_ext], 0, sizeof(out[cur_ext]));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnexleft--;\n\t\t\tbmv->bmv_entries++;\n\t\t\tcur_ext++;\n\t\t}\n\t} while (nmap && nexleft && bmv->bmv_length);\n\n out_free_map:\n\tkmem_free(map);\n out_unlock_ilock:\n\txfs_iunlock(ip, lock);\n out_unlock_iolock:\n\txfs_iunlock(ip, XFS_IOLOCK_SHARED);\n\n\tfor (i = 0; i < cur_ext; i++) {\n\t\tint full = 0;\t/* user array is full */\n\n\t\t/* format results & advance arg */\n\t\terror = formatter(&arg, &out[i], &full);\n\t\tif (error || full)\n\t\t\tbreak;\n\t}\n\n\tkmem_free(out);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error code */\nxfs_getbmap(\n\txfs_inode_t\t\t*ip,\n\tstruct getbmapx\t\t*bmv,\t\t/* user bmap structure */\n\txfs_bmap_format_t\tformatter,\t/* format to user */\n\tvoid\t\t\t*arg)\t\t/* formatter arg */\n{\n\t__int64_t\t\tbmvend;\t\t/* last block requested */\n\tint\t\t\terror = 0;\t/* return value */\n\t__int64_t\t\tfixlen;\t\t/* length for -1 case */\n\tint\t\t\ti;\t\t/* extent number */\n\tint\t\t\tlock;\t\t/* lock state */\n\txfs_bmbt_irec_t\t\t*map;\t\t/* buffer for user's data */\n\txfs_mount_t\t\t*mp;\t\t/* file system mount point */\n\tint\t\t\tnex;\t\t/* # of user extents can do */\n\tint\t\t\tnexleft;\t/* # of user extents left */\n\tint\t\t\tsubnex;\t\t/* # of bmapi's can do */\n\tint\t\t\tnmap;\t\t/* number of map entries */\n\tstruct getbmapx\t\t*out;\t\t/* output structure */\n\tint\t\t\twhichfork;\t/* data or attr fork */\n\tint\t\t\tprealloced;\t/* this is a file with\n\t\t\t\t\t\t * preallocated data space */\n\tint\t\t\tiflags;\t\t/* interface flags */\n\tint\t\t\tbmapi_flags;\t/* flags for xfs_bmapi */\n\tint\t\t\tcur_ext = 0;\n\n\tmp = ip->i_mount;\n\tiflags = bmv->bmv_iflags;\n\twhichfork = iflags & BMV_IF_ATTRFORK ? XFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tif (whichfork == XFS_ATTR_FORK) {\n\t\tif (XFS_IFORK_Q(ip)) {\n\t\t\tif (ip->i_d.di_aformat != XFS_DINODE_FMT_EXTENTS &&\n\t\t\t    ip->i_d.di_aformat != XFS_DINODE_FMT_BTREE &&\n\t\t\t    ip->i_d.di_aformat != XFS_DINODE_FMT_LOCAL)\n\t\t\t\treturn -EINVAL;\n\t\t} else if (unlikely(\n\t\t\t   ip->i_d.di_aformat != 0 &&\n\t\t\t   ip->i_d.di_aformat != XFS_DINODE_FMT_EXTENTS)) {\n\t\t\tXFS_ERROR_REPORT(\"xfs_getbmap\", XFS_ERRLEVEL_LOW,\n\t\t\t\t\t ip->i_mount);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\n\t\tprealloced = 0;\n\t\tfixlen = 1LL << 32;\n\t} else {\n\t\tif (ip->i_d.di_format != XFS_DINODE_FMT_EXTENTS &&\n\t\t    ip->i_d.di_format != XFS_DINODE_FMT_BTREE &&\n\t\t    ip->i_d.di_format != XFS_DINODE_FMT_LOCAL)\n\t\t\treturn -EINVAL;\n\n\t\tif (xfs_get_extsz_hint(ip) ||\n\t\t    ip->i_d.di_flags & (XFS_DIFLAG_PREALLOC|XFS_DIFLAG_APPEND)){\n\t\t\tprealloced = 1;\n\t\t\tfixlen = mp->m_super->s_maxbytes;\n\t\t} else {\n\t\t\tprealloced = 0;\n\t\t\tfixlen = XFS_ISIZE(ip);\n\t\t}\n\t}\n\n\tif (bmv->bmv_length == -1) {\n\t\tfixlen = XFS_FSB_TO_BB(mp, XFS_B_TO_FSB(mp, fixlen));\n\t\tbmv->bmv_length =\n\t\t\tmax_t(__int64_t, fixlen - bmv->bmv_offset, 0);\n\t} else if (bmv->bmv_length == 0) {\n\t\tbmv->bmv_entries = 0;\n\t\treturn 0;\n\t} else if (bmv->bmv_length < 0) {\n\t\treturn -EINVAL;\n\t}\n\n\tnex = bmv->bmv_count - 1;\n\tif (nex <= 0)\n\t\treturn -EINVAL;\n\tbmvend = bmv->bmv_offset + bmv->bmv_length;\n\n\n\tif (bmv->bmv_count > ULONG_MAX / sizeof(struct getbmapx))\n\t\treturn -ENOMEM;\n\tout = kmem_zalloc_large(bmv->bmv_count * sizeof(struct getbmapx), 0);\n\tif (!out)\n\t\treturn -ENOMEM;\n\n\txfs_ilock(ip, XFS_IOLOCK_SHARED);\n\tif (whichfork == XFS_DATA_FORK) {\n\t\tif (!(iflags & BMV_IF_DELALLOC) &&\n\t\t    (ip->i_delayed_blks || XFS_ISIZE(ip) > ip->i_d.di_size)) {\n\t\t\terror = filemap_write_and_wait(VFS_I(ip)->i_mapping);\n\t\t\tif (error)\n\t\t\t\tgoto out_unlock_iolock;\n\n\t\t\t/*\n\t\t\t * Even after flushing the inode, there can still be\n\t\t\t * delalloc blocks on the inode beyond EOF due to\n\t\t\t * speculative preallocation.  These are not removed\n\t\t\t * until the release function is called or the inode\n\t\t\t * is inactivated.  Hence we cannot assert here that\n\t\t\t * ip->i_delayed_blks == 0.\n\t\t\t */\n\t\t}\n\n\t\tlock = xfs_ilock_data_map_shared(ip);\n\t} else {\n\t\tlock = xfs_ilock_attr_map_shared(ip);\n\t}\n\n\t/*\n\t * Don't let nex be bigger than the number of extents\n\t * we can have assuming alternating holes and real extents.\n\t */\n\tif (nex > XFS_IFORK_NEXTENTS(ip, whichfork) * 2 + 1)\n\t\tnex = XFS_IFORK_NEXTENTS(ip, whichfork) * 2 + 1;\n\n\tbmapi_flags = xfs_bmapi_aflag(whichfork);\n\tif (!(iflags & BMV_IF_PREALLOC))\n\t\tbmapi_flags |= XFS_BMAPI_IGSTATE;\n\n\t/*\n\t * Allocate enough space to handle \"subnex\" maps at a time.\n\t */\n\terror = -ENOMEM;\n\tsubnex = 16;\n\tmap = kmem_alloc(subnex * sizeof(*map), KM_MAYFAIL | KM_NOFS);\n\tif (!map)\n\t\tgoto out_unlock_ilock;\n\n\tbmv->bmv_entries = 0;\n\n\tif (XFS_IFORK_NEXTENTS(ip, whichfork) == 0 &&\n\t    (whichfork == XFS_ATTR_FORK || !(iflags & BMV_IF_DELALLOC))) {\n\t\terror = 0;\n\t\tgoto out_free_map;\n\t}\n\n\tnexleft = nex;\n\n\tdo {\n\t\tnmap = (nexleft > subnex) ? subnex : nexleft;\n\t\terror = xfs_bmapi_read(ip, XFS_BB_TO_FSBT(mp, bmv->bmv_offset),\n\t\t\t\t       XFS_BB_TO_FSB(mp, bmv->bmv_length),\n\t\t\t\t       map, &nmap, bmapi_flags);\n\t\tif (error)\n\t\t\tgoto out_free_map;\n\t\tASSERT(nmap <= subnex);\n\n\t\tfor (i = 0; i < nmap && nexleft && bmv->bmv_length; i++) {\n\t\t\tout[cur_ext].bmv_oflags = 0;\n\t\t\tif (map[i].br_state == XFS_EXT_UNWRITTEN)\n\t\t\t\tout[cur_ext].bmv_oflags |= BMV_OF_PREALLOC;\n\t\t\telse if (map[i].br_startblock == DELAYSTARTBLOCK)\n\t\t\t\tout[cur_ext].bmv_oflags |= BMV_OF_DELALLOC;\n\t\t\tout[cur_ext].bmv_offset =\n\t\t\t\tXFS_FSB_TO_BB(mp, map[i].br_startoff);\n\t\t\tout[cur_ext].bmv_length =\n\t\t\t\tXFS_FSB_TO_BB(mp, map[i].br_blockcount);\n\t\t\tout[cur_ext].bmv_unused1 = 0;\n\t\t\tout[cur_ext].bmv_unused2 = 0;\n\n\t\t\t/*\n\t\t\t * delayed allocation extents that start beyond EOF can\n\t\t\t * occur due to speculative EOF allocation when the\n\t\t\t * delalloc extent is larger than the largest freespace\n\t\t\t * extent at conversion time. These extents cannot be\n\t\t\t * converted by data writeback, so can exist here even\n\t\t\t * if we are not supposed to be finding delalloc\n\t\t\t * extents.\n\t\t\t */\n\t\t\tif (map[i].br_startblock == DELAYSTARTBLOCK &&\n\t\t\t    map[i].br_startoff <= XFS_B_TO_FSB(mp, XFS_ISIZE(ip)))\n\t\t\t\tASSERT((iflags & BMV_IF_DELALLOC) != 0);\n\n                        if (map[i].br_startblock == HOLESTARTBLOCK &&\n\t\t\t    whichfork == XFS_ATTR_FORK) {\n\t\t\t\t/* came to the end of attribute fork */\n\t\t\t\tout[cur_ext].bmv_oflags |= BMV_OF_LAST;\n\t\t\t\tgoto out_free_map;\n\t\t\t}\n\n\t\t\tif (!xfs_getbmapx_fix_eof_hole(ip, &out[cur_ext],\n\t\t\t\t\tprealloced, bmvend,\n\t\t\t\t\tmap[i].br_startblock))\n\t\t\t\tgoto out_free_map;\n\n\t\t\tbmv->bmv_offset =\n\t\t\t\tout[cur_ext].bmv_offset +\n\t\t\t\tout[cur_ext].bmv_length;\n\t\t\tbmv->bmv_length =\n\t\t\t\tmax_t(__int64_t, 0, bmvend - bmv->bmv_offset);\n\n\t\t\t/*\n\t\t\t * In case we don't want to return the hole,\n\t\t\t * don't increase cur_ext so that we can reuse\n\t\t\t * it in the next loop.\n\t\t\t */\n\t\t\tif ((iflags & BMV_IF_NO_HOLES) &&\n\t\t\t    map[i].br_startblock == HOLESTARTBLOCK) {\n\t\t\t\tmemset(&out[cur_ext], 0, sizeof(out[cur_ext]));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnexleft--;\n\t\t\tbmv->bmv_entries++;\n\t\t\tcur_ext++;\n\t\t}\n\t} while (nmap && nexleft && bmv->bmv_length);\n\n out_free_map:\n\tkmem_free(map);\n out_unlock_ilock:\n\txfs_iunlock(ip, lock);\n out_unlock_iolock:\n\txfs_iunlock(ip, XFS_IOLOCK_SHARED);\n\n\tfor (i = 0; i < cur_ext; i++) {\n\t\tint full = 0;\t/* user array is full */\n\n\t\t/* format results & advance arg */\n\t\terror = formatter(&arg, &out[i], &full);\n\t\tif (error || full)\n\t\t\tbreak;\n\t}\n\n\tkmem_free(out);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "__s32",
            "bm.bmv_count",
            "(PAGE_SIZE * 16 / sizeof(struct getbmapx))"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTOBB",
          "args": [
            "start + length"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTOBBT",
          "args": [
            "start"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fiemap_check_flags",
          "args": [
            "fieinfo",
            "XFS_FIEMAP_FLAGS"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "fiemap_check_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ioctl.c",
          "lines": "138-148",
          "snippet": "int fiemap_check_flags(struct fiemap_extent_info *fieinfo, u32 fs_flags)\n{\n\tu32 incompat_flags;\n\n\tincompat_flags = fieinfo->fi_flags & ~(FIEMAP_FLAGS_COMPAT & fs_flags);\n\tif (incompat_flags) {\n\t\tfieinfo->fi_flags = incompat_flags;\n\t\treturn -EBADR;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <asm/ioctls.h>",
            "#include <linux/falloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ioctls.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nint fiemap_check_flags(struct fiemap_extent_info *fieinfo, u32 fs_flags)\n{\n\tu32 incompat_flags;\n\n\tincompat_flags = fieinfo->fi_flags & ~(FIEMAP_FLAGS_COMPAT & fs_flags);\n\tif (incompat_flags) {\n\t\tfieinfo->fi_flags = incompat_flags;\n\t\treturn -EBADR;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "inode"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\n#define XFS_FIEMAP_FLAGS\t(FIEMAP_FLAG_SYNC|FIEMAP_FLAG_XATTR)\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_vn_fiemap(\n\tstruct inode\t\t*inode,\n\tstruct fiemap_extent_info *fieinfo,\n\tu64\t\t\tstart,\n\tu64\t\t\tlength)\n{\n\txfs_inode_t\t\t*ip = XFS_I(inode);\n\tstruct getbmapx\t\tbm;\n\tint\t\t\terror;\n\n\terror = fiemap_check_flags(fieinfo, XFS_FIEMAP_FLAGS);\n\tif (error)\n\t\treturn error;\n\n\t/* Set up bmap header for xfs internal routine */\n\tbm.bmv_offset = BTOBBT(start);\n\t/* Special case for whole file */\n\tif (length == FIEMAP_MAX_OFFSET)\n\t\tbm.bmv_length = -1LL;\n\telse\n\t\tbm.bmv_length = BTOBB(start + length) - bm.bmv_offset;\n\n\t/* We add one because in getbmap world count includes the header */\n\tbm.bmv_count = !fieinfo->fi_extents_max ? MAXEXTNUM :\n\t\t\t\t\tfieinfo->fi_extents_max + 1;\n\tbm.bmv_count = min_t(__s32, bm.bmv_count,\n\t\t\t     (PAGE_SIZE * 16 / sizeof(struct getbmapx)));\n\tbm.bmv_iflags = BMV_IF_PREALLOC | BMV_IF_NO_HOLES;\n\tif (fieinfo->fi_flags & FIEMAP_FLAG_XATTR)\n\t\tbm.bmv_iflags |= BMV_IF_ATTRFORK;\n\tif (!(fieinfo->fi_flags & FIEMAP_FLAG_SYNC))\n\t\tbm.bmv_iflags |= BMV_IF_DELALLOC;\n\n\terror = xfs_getbmap(ip, &bm, xfs_fiemap_format, fieinfo);\n\tif (error)\n\t\treturn error;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_fiemap_format",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
    "lines": "1036-1073",
    "snippet": "STATIC int\nxfs_fiemap_format(\n\tvoid\t\t\t**arg,\n\tstruct getbmapx\t\t*bmv,\n\tint\t\t\t*full)\n{\n\tint\t\t\terror;\n\tstruct fiemap_extent_info *fieinfo = *arg;\n\tu32\t\t\tfiemap_flags = 0;\n\tu64\t\t\tlogical, physical, length;\n\n\t/* Do nothing for a hole */\n\tif (bmv->bmv_block == -1LL)\n\t\treturn 0;\n\n\tlogical = BBTOB(bmv->bmv_offset);\n\tphysical = BBTOB(bmv->bmv_block);\n\tlength = BBTOB(bmv->bmv_length);\n\n\tif (bmv->bmv_oflags & BMV_OF_PREALLOC)\n\t\tfiemap_flags |= FIEMAP_EXTENT_UNWRITTEN;\n\telse if (bmv->bmv_oflags & BMV_OF_DELALLOC) {\n\t\tfiemap_flags |= (FIEMAP_EXTENT_DELALLOC |\n\t\t\t\t FIEMAP_EXTENT_UNKNOWN);\n\t\tphysical = 0;   /* no block yet */\n\t}\n\tif (bmv->bmv_oflags & BMV_OF_LAST)\n\t\tfiemap_flags |= FIEMAP_EXTENT_LAST;\n\n\terror = fiemap_fill_next_extent(fieinfo, logical, physical,\n\t\t\t\t\tlength, fiemap_flags);\n\tif (error > 0) {\n\t\terror = 0;\n\t\t*full = 1;\t/* user array now full */\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/security.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/namei.h>",
      "#include <linux/xattr.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_acl.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fiemap_fill_next_extent",
          "args": [
            "fieinfo",
            "logical",
            "physical",
            "length",
            "fiemap_flags"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "fiemap_fill_next_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ioctl.c",
          "lines": "85-121",
          "snippet": "int fiemap_fill_next_extent(struct fiemap_extent_info *fieinfo, u64 logical,\n\t\t\t    u64 phys, u64 len, u32 flags)\n{\n\tstruct fiemap_extent extent;\n\tstruct fiemap_extent __user *dest = fieinfo->fi_extents_start;\n\n\t/* only count the extents */\n\tif (fieinfo->fi_extents_max == 0) {\n\t\tfieinfo->fi_extents_mapped++;\n\t\treturn (flags & FIEMAP_EXTENT_LAST) ? 1 : 0;\n\t}\n\n\tif (fieinfo->fi_extents_mapped >= fieinfo->fi_extents_max)\n\t\treturn 1;\n\n\tif (flags & SET_UNKNOWN_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_UNKNOWN;\n\tif (flags & SET_NO_UNMOUNTED_IO_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_ENCODED;\n\tif (flags & SET_NOT_ALIGNED_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_NOT_ALIGNED;\n\n\tmemset(&extent, 0, sizeof(extent));\n\textent.fe_logical = logical;\n\textent.fe_physical = phys;\n\textent.fe_length = len;\n\textent.fe_flags = flags;\n\n\tdest += fieinfo->fi_extents_mapped;\n\tif (copy_to_user(dest, &extent, sizeof(extent)))\n\t\treturn -EFAULT;\n\n\tfieinfo->fi_extents_mapped++;\n\tif (fieinfo->fi_extents_mapped == fieinfo->fi_extents_max)\n\t\treturn 1;\n\treturn (flags & FIEMAP_EXTENT_LAST) ? 1 : 0;\n}",
          "includes": [
            "#include <asm/ioctls.h>",
            "#include <linux/falloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [
            "#define SET_NOT_ALIGNED_FLAGS\t(FIEMAP_EXTENT_DATA_TAIL|FIEMAP_EXTENT_DATA_INLINE)",
            "#define SET_NO_UNMOUNTED_IO_FLAGS\t(FIEMAP_EXTENT_DATA_ENCRYPTED)",
            "#define SET_UNKNOWN_FLAGS\t(FIEMAP_EXTENT_DELALLOC)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ioctls.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\n#define SET_NOT_ALIGNED_FLAGS\t(FIEMAP_EXTENT_DATA_TAIL|FIEMAP_EXTENT_DATA_INLINE)\n#define SET_NO_UNMOUNTED_IO_FLAGS\t(FIEMAP_EXTENT_DATA_ENCRYPTED)\n#define SET_UNKNOWN_FLAGS\t(FIEMAP_EXTENT_DELALLOC)\n\nint fiemap_fill_next_extent(struct fiemap_extent_info *fieinfo, u64 logical,\n\t\t\t    u64 phys, u64 len, u32 flags)\n{\n\tstruct fiemap_extent extent;\n\tstruct fiemap_extent __user *dest = fieinfo->fi_extents_start;\n\n\t/* only count the extents */\n\tif (fieinfo->fi_extents_max == 0) {\n\t\tfieinfo->fi_extents_mapped++;\n\t\treturn (flags & FIEMAP_EXTENT_LAST) ? 1 : 0;\n\t}\n\n\tif (fieinfo->fi_extents_mapped >= fieinfo->fi_extents_max)\n\t\treturn 1;\n\n\tif (flags & SET_UNKNOWN_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_UNKNOWN;\n\tif (flags & SET_NO_UNMOUNTED_IO_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_ENCODED;\n\tif (flags & SET_NOT_ALIGNED_FLAGS)\n\t\tflags |= FIEMAP_EXTENT_NOT_ALIGNED;\n\n\tmemset(&extent, 0, sizeof(extent));\n\textent.fe_logical = logical;\n\textent.fe_physical = phys;\n\textent.fe_length = len;\n\textent.fe_flags = flags;\n\n\tdest += fieinfo->fi_extents_mapped;\n\tif (copy_to_user(dest, &extent, sizeof(extent)))\n\t\treturn -EFAULT;\n\n\tfieinfo->fi_extents_mapped++;\n\tif (fieinfo->fi_extents_mapped == fieinfo->fi_extents_max)\n\t\treturn 1;\n\treturn (flags & FIEMAP_EXTENT_LAST) ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BBTOB",
          "args": [
            "bmv->bmv_length"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BBTOB",
          "args": [
            "bmv->bmv_block"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BBTOB",
          "args": [
            "bmv->bmv_offset"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_fiemap_format(\n\tvoid\t\t\t**arg,\n\tstruct getbmapx\t\t*bmv,\n\tint\t\t\t*full)\n{\n\tint\t\t\terror;\n\tstruct fiemap_extent_info *fieinfo = *arg;\n\tu32\t\t\tfiemap_flags = 0;\n\tu64\t\t\tlogical, physical, length;\n\n\t/* Do nothing for a hole */\n\tif (bmv->bmv_block == -1LL)\n\t\treturn 0;\n\n\tlogical = BBTOB(bmv->bmv_offset);\n\tphysical = BBTOB(bmv->bmv_block);\n\tlength = BBTOB(bmv->bmv_length);\n\n\tif (bmv->bmv_oflags & BMV_OF_PREALLOC)\n\t\tfiemap_flags |= FIEMAP_EXTENT_UNWRITTEN;\n\telse if (bmv->bmv_oflags & BMV_OF_DELALLOC) {\n\t\tfiemap_flags |= (FIEMAP_EXTENT_DELALLOC |\n\t\t\t\t FIEMAP_EXTENT_UNKNOWN);\n\t\tphysical = 0;   /* no block yet */\n\t}\n\tif (bmv->bmv_oflags & BMV_OF_LAST)\n\t\tfiemap_flags |= FIEMAP_EXTENT_LAST;\n\n\terror = fiemap_fill_next_extent(fieinfo, logical, physical,\n\t\t\t\t\tlength, fiemap_flags);\n\tif (error > 0) {\n\t\terror = 0;\n\t\t*full = 1;\t/* user array now full */\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_vn_update_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
    "lines": "989-1028",
    "snippet": "STATIC int\nxfs_vn_update_time(\n\tstruct inode\t\t*inode,\n\tstruct timespec\t\t*now,\n\tint\t\t\tflags)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\ttrace_xfs_update_time(ip);\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_FSYNC_TS);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_fsyncts, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\tif (flags & S_CTIME) {\n\t\tinode->i_ctime = *now;\n\t\tip->i_d.di_ctime.t_sec = (__int32_t)now->tv_sec;\n\t\tip->i_d.di_ctime.t_nsec = (__int32_t)now->tv_nsec;\n\t}\n\tif (flags & S_MTIME) {\n\t\tinode->i_mtime = *now;\n\t\tip->i_d.di_mtime.t_sec = (__int32_t)now->tv_sec;\n\t\tip->i_d.di_mtime.t_nsec = (__int32_t)now->tv_nsec;\n\t}\n\tif (flags & S_ATIME) {\n\t\tinode->i_atime = *now;\n\t\tip->i_d.di_atime.t_sec = (__int32_t)now->tv_sec;\n\t\tip->i_d.di_atime.t_nsec = (__int32_t)now->tv_nsec;\n\t}\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_TIMESTAMP);\n\treturn xfs_trans_commit(tp, 0);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/security.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/namei.h>",
      "#include <linux/xattr.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_acl.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_commit",
          "args": [
            "tp",
            "0"
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "845-927",
          "snippet": "int\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "tp",
            "ip",
            "XFS_ILOG_TIMESTAMP"
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ijoin",
          "args": [
            "tp",
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ijoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "37-57",
          "snippet": "void\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_cancel",
          "args": [
            "tp",
            "0"
          ],
          "line": 1005
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "937-986",
          "snippet": "void\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve",
          "args": [
            "tp",
            "&M_RES(mp)->tr_fsyncts",
            "0",
            "0"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "168-279",
          "snippet": "int\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_alloc",
          "args": [
            "mp",
            "XFS_TRANS_FSYNC_TS"
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "57-68",
          "snippet": "xfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_update_time",
          "args": [
            "ip"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "inode"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_vn_update_time(\n\tstruct inode\t\t*inode,\n\tstruct timespec\t\t*now,\n\tint\t\t\tflags)\n{\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\ttrace_xfs_update_time(ip);\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_FSYNC_TS);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_fsyncts, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\tif (flags & S_CTIME) {\n\t\tinode->i_ctime = *now;\n\t\tip->i_d.di_ctime.t_sec = (__int32_t)now->tv_sec;\n\t\tip->i_d.di_ctime.t_nsec = (__int32_t)now->tv_nsec;\n\t}\n\tif (flags & S_MTIME) {\n\t\tinode->i_mtime = *now;\n\t\tip->i_d.di_mtime.t_sec = (__int32_t)now->tv_sec;\n\t\tip->i_d.di_mtime.t_nsec = (__int32_t)now->tv_nsec;\n\t}\n\tif (flags & S_ATIME) {\n\t\tinode->i_atime = *now;\n\t\tip->i_d.di_atime.t_sec = (__int32_t)now->tv_sec;\n\t\tip->i_d.di_atime.t_nsec = (__int32_t)now->tv_nsec;\n\t}\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_TIMESTAMP);\n\treturn xfs_trans_commit(tp, 0);\n}"
  },
  {
    "function_name": "xfs_vn_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
    "lines": "966-987",
    "snippet": "STATIC int\nxfs_vn_setattr(\n\tstruct dentry\t\t*dentry,\n\tstruct iattr\t\t*iattr)\n{\n\tstruct xfs_inode\t*ip = XFS_I(dentry->d_inode);\n\tint\t\t\terror;\n\n\tif (iattr->ia_valid & ATTR_SIZE) {\n\t\tuint\t\tiolock = XFS_IOLOCK_EXCL;\n\n\t\txfs_ilock(ip, iolock);\n\t\terror = xfs_break_layouts(dentry->d_inode, &iolock);\n\t\tif (!error)\n\t\t\terror = xfs_setattr_size(ip, iattr);\n\t\txfs_iunlock(ip, iolock);\n\t} else {\n\t\terror = xfs_setattr_nonsize(ip, iattr, 0);\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/security.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/namei.h>",
      "#include <linux/xattr.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_acl.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_setattr_nonsize",
          "args": [
            "ip",
            "iattr",
            "0"
          ],
          "line": 983
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_setattr_nonsize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
          "lines": "535-737",
          "snippet": "int\nxfs_setattr_nonsize(\n\tstruct xfs_inode\t*ip,\n\tstruct iattr\t\t*iattr,\n\tint\t\t\tflags)\n{\n\txfs_mount_t\t\t*mp = ip->i_mount;\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tint\t\t\tmask = iattr->ia_valid;\n\txfs_trans_t\t\t*tp;\n\tint\t\t\terror;\n\tkuid_t\t\t\tuid = GLOBAL_ROOT_UID, iuid = GLOBAL_ROOT_UID;\n\tkgid_t\t\t\tgid = GLOBAL_ROOT_GID, igid = GLOBAL_ROOT_GID;\n\tstruct xfs_dquot\t*udqp = NULL, *gdqp = NULL;\n\tstruct xfs_dquot\t*olddquot1 = NULL, *olddquot2 = NULL;\n\n\ttrace_xfs_setattr(ip);\n\n\t/* If acls are being inherited, we already have this checked */\n\tif (!(flags & XFS_ATTR_NOACL)) {\n\t\tif (mp->m_flags & XFS_MOUNT_RDONLY)\n\t\t\treturn -EROFS;\n\n\t\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\t\treturn -EIO;\n\n\t\terror = inode_change_ok(inode, iattr);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tASSERT((mask & ATTR_SIZE) == 0);\n\n\t/*\n\t * If disk quotas is on, we make sure that the dquots do exist on disk,\n\t * before we start any other transactions. Trying to do this later\n\t * is messy. We don't care to take a readlock to look at the ids\n\t * in inode here, because we can't hold it across the trans_reserve.\n\t * If the IDs do change before we take the ilock, we're covered\n\t * because the i_*dquot fields will get updated anyway.\n\t */\n\tif (XFS_IS_QUOTA_ON(mp) && (mask & (ATTR_UID|ATTR_GID))) {\n\t\tuint\tqflags = 0;\n\n\t\tif ((mask & ATTR_UID) && XFS_IS_UQUOTA_ON(mp)) {\n\t\t\tuid = iattr->ia_uid;\n\t\t\tqflags |= XFS_QMOPT_UQUOTA;\n\t\t} else {\n\t\t\tuid = inode->i_uid;\n\t\t}\n\t\tif ((mask & ATTR_GID) && XFS_IS_GQUOTA_ON(mp)) {\n\t\t\tgid = iattr->ia_gid;\n\t\t\tqflags |= XFS_QMOPT_GQUOTA;\n\t\t}  else {\n\t\t\tgid = inode->i_gid;\n\t\t}\n\n\t\t/*\n\t\t * We take a reference when we initialize udqp and gdqp,\n\t\t * so it is important that we never blindly double trip on\n\t\t * the same variable. See xfs_create() for an example.\n\t\t */\n\t\tASSERT(udqp == NULL);\n\t\tASSERT(gdqp == NULL);\n\t\terror = xfs_qm_vop_dqalloc(ip, xfs_kuid_to_uid(uid),\n\t\t\t\t\t   xfs_kgid_to_gid(gid),\n\t\t\t\t\t   xfs_get_projid(ip),\n\t\t\t\t\t   qflags, &udqp, &gdqp, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_SETATTR_NOT_SIZE);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_ichange, 0, 0);\n\tif (error)\n\t\tgoto out_dqrele;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * Change file ownership.  Must be the owner or privileged.\n\t */\n\tif (mask & (ATTR_UID|ATTR_GID)) {\n\t\t/*\n\t\t * These IDs could have changed since we last looked at them.\n\t\t * But, we're assured that if the ownership did change\n\t\t * while we didn't have the inode locked, inode's dquot(s)\n\t\t * would have changed also.\n\t\t */\n\t\tiuid = inode->i_uid;\n\t\tigid = inode->i_gid;\n\t\tgid = (mask & ATTR_GID) ? iattr->ia_gid : igid;\n\t\tuid = (mask & ATTR_UID) ? iattr->ia_uid : iuid;\n\n\t\t/*\n\t\t * Do a quota reservation only if uid/gid is actually\n\t\t * going to change.\n\t\t */\n\t\tif (XFS_IS_QUOTA_RUNNING(mp) &&\n\t\t    ((XFS_IS_UQUOTA_ON(mp) && !uid_eq(iuid, uid)) ||\n\t\t     (XFS_IS_GQUOTA_ON(mp) && !gid_eq(igid, gid)))) {\n\t\t\tASSERT(tp);\n\t\t\terror = xfs_qm_vop_chown_reserve(tp, ip, udqp, gdqp,\n\t\t\t\t\t\tNULL, capable(CAP_FOWNER) ?\n\t\t\t\t\t\tXFS_QMOPT_FORCE_RES : 0);\n\t\t\tif (error)\t/* out of quota */\n\t\t\t\tgoto out_trans_cancel;\n\t\t}\n\t}\n\n\txfs_trans_ijoin(tp, ip, 0);\n\n\t/*\n\t * Change file ownership.  Must be the owner or privileged.\n\t */\n\tif (mask & (ATTR_UID|ATTR_GID)) {\n\t\t/*\n\t\t * CAP_FSETID overrides the following restrictions:\n\t\t *\n\t\t * The set-user-ID and set-group-ID bits of a file will be\n\t\t * cleared upon successful return from chown()\n\t\t */\n\t\tif ((ip->i_d.di_mode & (S_ISUID|S_ISGID)) &&\n\t\t    !capable(CAP_FSETID))\n\t\t\tip->i_d.di_mode &= ~(S_ISUID|S_ISGID);\n\n\t\t/*\n\t\t * Change the ownerships and register quota modifications\n\t\t * in the transaction.\n\t\t */\n\t\tif (!uid_eq(iuid, uid)) {\n\t\t\tif (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_UQUOTA_ON(mp)) {\n\t\t\t\tASSERT(mask & ATTR_UID);\n\t\t\t\tASSERT(udqp);\n\t\t\t\tolddquot1 = xfs_qm_vop_chown(tp, ip,\n\t\t\t\t\t\t\t&ip->i_udquot, udqp);\n\t\t\t}\n\t\t\tip->i_d.di_uid = xfs_kuid_to_uid(uid);\n\t\t\tinode->i_uid = uid;\n\t\t}\n\t\tif (!gid_eq(igid, gid)) {\n\t\t\tif (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_GQUOTA_ON(mp)) {\n\t\t\t\tASSERT(xfs_sb_version_has_pquotino(&mp->m_sb) ||\n\t\t\t\t       !XFS_IS_PQUOTA_ON(mp));\n\t\t\t\tASSERT(mask & ATTR_GID);\n\t\t\t\tASSERT(gdqp);\n\t\t\t\tolddquot2 = xfs_qm_vop_chown(tp, ip,\n\t\t\t\t\t\t\t&ip->i_gdquot, gdqp);\n\t\t\t}\n\t\t\tip->i_d.di_gid = xfs_kgid_to_gid(gid);\n\t\t\tinode->i_gid = gid;\n\t\t}\n\t}\n\n\tif (mask & ATTR_MODE)\n\t\txfs_setattr_mode(ip, iattr);\n\tif (mask & (ATTR_ATIME|ATTR_CTIME|ATTR_MTIME))\n\t\txfs_setattr_time(ip, iattr);\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tXFS_STATS_INC(xs_ig_attrchg);\n\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(tp);\n\terror = xfs_trans_commit(tp, 0);\n\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * Release any dquot(s) the inode had kept before chown.\n\t */\n\txfs_qm_dqrele(olddquot1);\n\txfs_qm_dqrele(olddquot2);\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * XXX(hch): Updating the ACL entries is not atomic vs the i_mode\n\t * \t     update.  We could avoid this with linked transactions\n\t * \t     and passing down the transaction pointer all the way\n\t *\t     to attr_set.  No previous user of the generic\n\t * \t     Posix ACL code seems to care about this issue either.\n\t */\n\tif ((mask & ATTR_MODE) && !(flags & XFS_ATTR_NOACL)) {\n\t\terror = posix_acl_chmod(inode, inode->i_mode);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n\nout_trans_cancel:\n\txfs_trans_cancel(tp, 0);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\nout_dqrele:\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\treturn error;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/security.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/namei.h>",
            "#include <linux/xattr.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_acl.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nint\nxfs_setattr_nonsize(\n\tstruct xfs_inode\t*ip,\n\tstruct iattr\t\t*iattr,\n\tint\t\t\tflags)\n{\n\txfs_mount_t\t\t*mp = ip->i_mount;\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tint\t\t\tmask = iattr->ia_valid;\n\txfs_trans_t\t\t*tp;\n\tint\t\t\terror;\n\tkuid_t\t\t\tuid = GLOBAL_ROOT_UID, iuid = GLOBAL_ROOT_UID;\n\tkgid_t\t\t\tgid = GLOBAL_ROOT_GID, igid = GLOBAL_ROOT_GID;\n\tstruct xfs_dquot\t*udqp = NULL, *gdqp = NULL;\n\tstruct xfs_dquot\t*olddquot1 = NULL, *olddquot2 = NULL;\n\n\ttrace_xfs_setattr(ip);\n\n\t/* If acls are being inherited, we already have this checked */\n\tif (!(flags & XFS_ATTR_NOACL)) {\n\t\tif (mp->m_flags & XFS_MOUNT_RDONLY)\n\t\t\treturn -EROFS;\n\n\t\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\t\treturn -EIO;\n\n\t\terror = inode_change_ok(inode, iattr);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tASSERT((mask & ATTR_SIZE) == 0);\n\n\t/*\n\t * If disk quotas is on, we make sure that the dquots do exist on disk,\n\t * before we start any other transactions. Trying to do this later\n\t * is messy. We don't care to take a readlock to look at the ids\n\t * in inode here, because we can't hold it across the trans_reserve.\n\t * If the IDs do change before we take the ilock, we're covered\n\t * because the i_*dquot fields will get updated anyway.\n\t */\n\tif (XFS_IS_QUOTA_ON(mp) && (mask & (ATTR_UID|ATTR_GID))) {\n\t\tuint\tqflags = 0;\n\n\t\tif ((mask & ATTR_UID) && XFS_IS_UQUOTA_ON(mp)) {\n\t\t\tuid = iattr->ia_uid;\n\t\t\tqflags |= XFS_QMOPT_UQUOTA;\n\t\t} else {\n\t\t\tuid = inode->i_uid;\n\t\t}\n\t\tif ((mask & ATTR_GID) && XFS_IS_GQUOTA_ON(mp)) {\n\t\t\tgid = iattr->ia_gid;\n\t\t\tqflags |= XFS_QMOPT_GQUOTA;\n\t\t}  else {\n\t\t\tgid = inode->i_gid;\n\t\t}\n\n\t\t/*\n\t\t * We take a reference when we initialize udqp and gdqp,\n\t\t * so it is important that we never blindly double trip on\n\t\t * the same variable. See xfs_create() for an example.\n\t\t */\n\t\tASSERT(udqp == NULL);\n\t\tASSERT(gdqp == NULL);\n\t\terror = xfs_qm_vop_dqalloc(ip, xfs_kuid_to_uid(uid),\n\t\t\t\t\t   xfs_kgid_to_gid(gid),\n\t\t\t\t\t   xfs_get_projid(ip),\n\t\t\t\t\t   qflags, &udqp, &gdqp, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_SETATTR_NOT_SIZE);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_ichange, 0, 0);\n\tif (error)\n\t\tgoto out_dqrele;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * Change file ownership.  Must be the owner or privileged.\n\t */\n\tif (mask & (ATTR_UID|ATTR_GID)) {\n\t\t/*\n\t\t * These IDs could have changed since we last looked at them.\n\t\t * But, we're assured that if the ownership did change\n\t\t * while we didn't have the inode locked, inode's dquot(s)\n\t\t * would have changed also.\n\t\t */\n\t\tiuid = inode->i_uid;\n\t\tigid = inode->i_gid;\n\t\tgid = (mask & ATTR_GID) ? iattr->ia_gid : igid;\n\t\tuid = (mask & ATTR_UID) ? iattr->ia_uid : iuid;\n\n\t\t/*\n\t\t * Do a quota reservation only if uid/gid is actually\n\t\t * going to change.\n\t\t */\n\t\tif (XFS_IS_QUOTA_RUNNING(mp) &&\n\t\t    ((XFS_IS_UQUOTA_ON(mp) && !uid_eq(iuid, uid)) ||\n\t\t     (XFS_IS_GQUOTA_ON(mp) && !gid_eq(igid, gid)))) {\n\t\t\tASSERT(tp);\n\t\t\terror = xfs_qm_vop_chown_reserve(tp, ip, udqp, gdqp,\n\t\t\t\t\t\tNULL, capable(CAP_FOWNER) ?\n\t\t\t\t\t\tXFS_QMOPT_FORCE_RES : 0);\n\t\t\tif (error)\t/* out of quota */\n\t\t\t\tgoto out_trans_cancel;\n\t\t}\n\t}\n\n\txfs_trans_ijoin(tp, ip, 0);\n\n\t/*\n\t * Change file ownership.  Must be the owner or privileged.\n\t */\n\tif (mask & (ATTR_UID|ATTR_GID)) {\n\t\t/*\n\t\t * CAP_FSETID overrides the following restrictions:\n\t\t *\n\t\t * The set-user-ID and set-group-ID bits of a file will be\n\t\t * cleared upon successful return from chown()\n\t\t */\n\t\tif ((ip->i_d.di_mode & (S_ISUID|S_ISGID)) &&\n\t\t    !capable(CAP_FSETID))\n\t\t\tip->i_d.di_mode &= ~(S_ISUID|S_ISGID);\n\n\t\t/*\n\t\t * Change the ownerships and register quota modifications\n\t\t * in the transaction.\n\t\t */\n\t\tif (!uid_eq(iuid, uid)) {\n\t\t\tif (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_UQUOTA_ON(mp)) {\n\t\t\t\tASSERT(mask & ATTR_UID);\n\t\t\t\tASSERT(udqp);\n\t\t\t\tolddquot1 = xfs_qm_vop_chown(tp, ip,\n\t\t\t\t\t\t\t&ip->i_udquot, udqp);\n\t\t\t}\n\t\t\tip->i_d.di_uid = xfs_kuid_to_uid(uid);\n\t\t\tinode->i_uid = uid;\n\t\t}\n\t\tif (!gid_eq(igid, gid)) {\n\t\t\tif (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_GQUOTA_ON(mp)) {\n\t\t\t\tASSERT(xfs_sb_version_has_pquotino(&mp->m_sb) ||\n\t\t\t\t       !XFS_IS_PQUOTA_ON(mp));\n\t\t\t\tASSERT(mask & ATTR_GID);\n\t\t\t\tASSERT(gdqp);\n\t\t\t\tolddquot2 = xfs_qm_vop_chown(tp, ip,\n\t\t\t\t\t\t\t&ip->i_gdquot, gdqp);\n\t\t\t}\n\t\t\tip->i_d.di_gid = xfs_kgid_to_gid(gid);\n\t\t\tinode->i_gid = gid;\n\t\t}\n\t}\n\n\tif (mask & ATTR_MODE)\n\t\txfs_setattr_mode(ip, iattr);\n\tif (mask & (ATTR_ATIME|ATTR_CTIME|ATTR_MTIME))\n\t\txfs_setattr_time(ip, iattr);\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tXFS_STATS_INC(xs_ig_attrchg);\n\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(tp);\n\terror = xfs_trans_commit(tp, 0);\n\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * Release any dquot(s) the inode had kept before chown.\n\t */\n\txfs_qm_dqrele(olddquot1);\n\txfs_qm_dqrele(olddquot2);\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * XXX(hch): Updating the ACL entries is not atomic vs the i_mode\n\t * \t     update.  We could avoid this with linked transactions\n\t * \t     and passing down the transaction pointer all the way\n\t *\t     to attr_set.  No previous user of the generic\n\t * \t     Posix ACL code seems to care about this issue either.\n\t */\n\tif ((mask & ATTR_MODE) && !(flags & XFS_ATTR_NOACL)) {\n\t\terror = posix_acl_chmod(inode, inode->i_mode);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n\nout_trans_cancel:\n\txfs_trans_cancel(tp, 0);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\nout_dqrele:\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "ip",
            "iolock"
          ],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_setattr_size",
          "args": [
            "ip",
            "iattr"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_setattr_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
          "lines": "742-964",
          "snippet": "int\nxfs_setattr_size(\n\tstruct xfs_inode\t*ip,\n\tstruct iattr\t\t*iattr)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct inode\t\t*inode = VFS_I(ip);\n\txfs_off_t\t\toldsize, newsize;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\tuint\t\t\tlock_flags = 0;\n\tuint\t\t\tcommit_flags = 0;\n\tbool\t\t\tdid_zeroing = false;\n\n\ttrace_xfs_setattr(ip);\n\n\tif (mp->m_flags & XFS_MOUNT_RDONLY)\n\t\treturn -EROFS;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\terror = inode_change_ok(inode, iattr);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\tASSERT(S_ISREG(ip->i_d.di_mode));\n\tASSERT((iattr->ia_valid & (ATTR_UID|ATTR_GID|ATTR_ATIME|ATTR_ATIME_SET|\n\t\tATTR_MTIME_SET|ATTR_KILL_PRIV|ATTR_TIMES_SET)) == 0);\n\n\toldsize = inode->i_size;\n\tnewsize = iattr->ia_size;\n\n\t/*\n\t * Short circuit the truncate case for zero length files.\n\t */\n\tif (newsize == 0 && oldsize == 0 && ip->i_d.di_nextents == 0) {\n\t\tif (!(iattr->ia_valid & (ATTR_CTIME|ATTR_MTIME)))\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * Use the regular setattr path to update the timestamps.\n\t\t */\n\t\tiattr->ia_valid &= ~ATTR_SIZE;\n\t\treturn xfs_setattr_nonsize(ip, iattr, 0);\n\t}\n\n\t/*\n\t * Make sure that the dquots are attached to the inode.\n\t */\n\terror = xfs_qm_dqattach(ip, 0);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * File data changes must be complete before we start the transaction to\n\t * modify the inode.  This needs to be done before joining the inode to\n\t * the transaction because the inode cannot be unlocked once it is a\n\t * part of the transaction.\n\t *\n\t * Start with zeroing any data block beyond EOF that we may expose on\n\t * file extension.\n\t */\n\tif (newsize > oldsize) {\n\t\terror = xfs_zero_eof(ip, newsize, oldsize, &did_zeroing);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * We are going to log the inode size change in this transaction so\n\t * any previous writes that are beyond the on disk EOF and the new\n\t * EOF that have not been written out need to be written here.  If we\n\t * do not write the data out, we expose ourselves to the null files\n\t * problem. Note that this includes any block zeroing we did above;\n\t * otherwise those blocks may not be zeroed after a crash.\n\t */\n\tif (newsize > ip->i_d.di_size &&\n\t    (oldsize != ip->i_d.di_size || did_zeroing)) {\n\t\terror = filemap_write_and_wait_range(VFS_I(ip)->i_mapping,\n\t\t\t\t\t\t      ip->i_d.di_size, newsize);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* Now wait for all direct I/O to complete. */\n\tinode_dio_wait(inode);\n\n\t/*\n\t * Do all the page cache truncate work outside the transaction context\n\t * as the \"lock\" order is page lock->log space reservation.  i.e.\n\t * locking pages inside the transaction can ABBA deadlock with\n\t * writeback. We have to do the VFS inode size update before we truncate\n\t * the pagecache, however, to avoid racing with page faults beyond the\n\t * new EOF they are not serialised against truncate operations except by\n\t * page locks and size updates.\n\t *\n\t * Hence we are in a situation where a truncate can fail with ENOMEM\n\t * from xfs_trans_reserve(), but having already truncated the in-memory\n\t * version of the file (i.e. made user visible changes). There's not\n\t * much we can do about this, except to hope that the caller sees ENOMEM\n\t * and retries the truncate operation.\n\t */\n\terror = block_truncate_page(inode->i_mapping, newsize, xfs_get_blocks);\n\tif (error)\n\t\treturn error;\n\ttruncate_setsize(inode, newsize);\n\n\t/*\n\t * The \"we can't serialise against page faults\" pain gets worse.\n\t *\n\t * If the file is mapped then we have to clean the page at the old EOF\n\t * when extending the file. Extending the file can expose changes the\n\t * underlying page mapping (e.g. from beyond EOF to a hole or\n\t * unwritten), and so on the next attempt to write to that page we need\n\t * to remap it for write. i.e. we need .page_mkwrite() to be called.\n\t * Hence we need to clean the page to clean the pte and so a new write\n\t * fault will be triggered appropriately.\n\t *\n\t * If we do it before we change the inode size, then we can race with a\n\t * page fault that maps the page with exactly the same problem. If we do\n\t * it after we change the file size, then a new page fault can come in\n\t * and allocate space before we've run the rest of the truncate\n\t * transaction. That's kinda grotesque, but it's better than have data\n\t * over a hole, and so that's the lesser evil that has been chosen here.\n\t *\n\t * The real solution, however, is to have some mechanism for locking out\n\t * page faults while a truncate is in progress.\n\t */\n\tif (newsize > oldsize && mapping_mapped(VFS_I(ip)->i_mapping)) {\n\t\terror = filemap_write_and_wait_range(\n\t\t\t\tVFS_I(ip)->i_mapping,\n\t\t\t\tround_down(oldsize, PAGE_CACHE_SIZE),\n\t\t\t\tround_up(oldsize, PAGE_CACHE_SIZE) - 1);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_SETATTR_SIZE);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\n\tif (error)\n\t\tgoto out_trans_cancel;\n\n\tcommit_flags = XFS_TRANS_RELEASE_LOG_RES;\n\tlock_flags |= XFS_ILOCK_EXCL;\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, 0);\n\n\t/*\n\t * Only change the c/mtime if we are changing the size or we are\n\t * explicitly asked to change it.  This handles the semantic difference\n\t * between truncate() and ftruncate() as implemented in the VFS.\n\t *\n\t * The regular truncate() case without ATTR_CTIME and ATTR_MTIME is a\n\t * special case where we need to update the times despite not having\n\t * these flags set.  For all other operations the VFS set these flags\n\t * explicitly if it wants a timestamp update.\n\t */\n\tif (newsize != oldsize &&\n\t    !(iattr->ia_valid & (ATTR_CTIME | ATTR_MTIME))) {\n\t\tiattr->ia_ctime = iattr->ia_mtime =\n\t\t\tcurrent_fs_time(inode->i_sb);\n\t\tiattr->ia_valid |= ATTR_CTIME | ATTR_MTIME;\n\t}\n\n\t/*\n\t * The first thing we do is set the size to new_size permanently on\n\t * disk.  This way we don't have to worry about anyone ever being able\n\t * to look at the data being freed even in the face of a crash.\n\t * What we're getting around here is the case where we free a block, it\n\t * is allocated to another file, it is written to, and then we crash.\n\t * If the new data gets written to the file but the log buffers\n\t * containing the free and reallocation don't, then we'd end up with\n\t * garbage in the blocks being freed.  As long as we make the new size\n\t * permanent before actually freeing any blocks it doesn't matter if\n\t * they get written to.\n\t */\n\tip->i_d.di_size = newsize;\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tif (newsize <= oldsize) {\n\t\terror = xfs_itruncate_extents(&tp, ip, XFS_DATA_FORK, newsize);\n\t\tif (error)\n\t\t\tgoto out_trans_abort;\n\n\t\t/*\n\t\t * Truncated \"down\", so we're removing references to old data\n\t\t * here - if we delay flushing for a long time, we expose\n\t\t * ourselves unduly to the notorious NULL files problem.  So,\n\t\t * we mark this inode and flush it when the file is closed,\n\t\t * and do not wait the usual (long) time for writeout.\n\t\t */\n\t\txfs_iflags_set(ip, XFS_ITRUNCATED);\n\n\t\t/* A truncate down always removes post-EOF blocks. */\n\t\txfs_inode_clear_eofblocks_tag(ip);\n\t}\n\n\tif (iattr->ia_valid & ATTR_MODE)\n\t\txfs_setattr_mode(ip, iattr);\n\tif (iattr->ia_valid & (ATTR_ATIME|ATTR_CTIME|ATTR_MTIME))\n\t\txfs_setattr_time(ip, iattr);\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tXFS_STATS_INC(xs_ig_attrchg);\n\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(tp);\n\n\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\nout_unlock:\n\tif (lock_flags)\n\t\txfs_iunlock(ip, lock_flags);\n\treturn error;\n\nout_trans_abort:\n\tcommit_flags |= XFS_TRANS_ABORT;\nout_trans_cancel:\n\txfs_trans_cancel(tp, commit_flags);\n\tgoto out_unlock;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/security.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/namei.h>",
            "#include <linux/xattr.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_acl.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nint\nxfs_setattr_size(\n\tstruct xfs_inode\t*ip,\n\tstruct iattr\t\t*iattr)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct inode\t\t*inode = VFS_I(ip);\n\txfs_off_t\t\toldsize, newsize;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\tuint\t\t\tlock_flags = 0;\n\tuint\t\t\tcommit_flags = 0;\n\tbool\t\t\tdid_zeroing = false;\n\n\ttrace_xfs_setattr(ip);\n\n\tif (mp->m_flags & XFS_MOUNT_RDONLY)\n\t\treturn -EROFS;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\terror = inode_change_ok(inode, iattr);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\tASSERT(S_ISREG(ip->i_d.di_mode));\n\tASSERT((iattr->ia_valid & (ATTR_UID|ATTR_GID|ATTR_ATIME|ATTR_ATIME_SET|\n\t\tATTR_MTIME_SET|ATTR_KILL_PRIV|ATTR_TIMES_SET)) == 0);\n\n\toldsize = inode->i_size;\n\tnewsize = iattr->ia_size;\n\n\t/*\n\t * Short circuit the truncate case for zero length files.\n\t */\n\tif (newsize == 0 && oldsize == 0 && ip->i_d.di_nextents == 0) {\n\t\tif (!(iattr->ia_valid & (ATTR_CTIME|ATTR_MTIME)))\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * Use the regular setattr path to update the timestamps.\n\t\t */\n\t\tiattr->ia_valid &= ~ATTR_SIZE;\n\t\treturn xfs_setattr_nonsize(ip, iattr, 0);\n\t}\n\n\t/*\n\t * Make sure that the dquots are attached to the inode.\n\t */\n\terror = xfs_qm_dqattach(ip, 0);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * File data changes must be complete before we start the transaction to\n\t * modify the inode.  This needs to be done before joining the inode to\n\t * the transaction because the inode cannot be unlocked once it is a\n\t * part of the transaction.\n\t *\n\t * Start with zeroing any data block beyond EOF that we may expose on\n\t * file extension.\n\t */\n\tif (newsize > oldsize) {\n\t\terror = xfs_zero_eof(ip, newsize, oldsize, &did_zeroing);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * We are going to log the inode size change in this transaction so\n\t * any previous writes that are beyond the on disk EOF and the new\n\t * EOF that have not been written out need to be written here.  If we\n\t * do not write the data out, we expose ourselves to the null files\n\t * problem. Note that this includes any block zeroing we did above;\n\t * otherwise those blocks may not be zeroed after a crash.\n\t */\n\tif (newsize > ip->i_d.di_size &&\n\t    (oldsize != ip->i_d.di_size || did_zeroing)) {\n\t\terror = filemap_write_and_wait_range(VFS_I(ip)->i_mapping,\n\t\t\t\t\t\t      ip->i_d.di_size, newsize);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* Now wait for all direct I/O to complete. */\n\tinode_dio_wait(inode);\n\n\t/*\n\t * Do all the page cache truncate work outside the transaction context\n\t * as the \"lock\" order is page lock->log space reservation.  i.e.\n\t * locking pages inside the transaction can ABBA deadlock with\n\t * writeback. We have to do the VFS inode size update before we truncate\n\t * the pagecache, however, to avoid racing with page faults beyond the\n\t * new EOF they are not serialised against truncate operations except by\n\t * page locks and size updates.\n\t *\n\t * Hence we are in a situation where a truncate can fail with ENOMEM\n\t * from xfs_trans_reserve(), but having already truncated the in-memory\n\t * version of the file (i.e. made user visible changes). There's not\n\t * much we can do about this, except to hope that the caller sees ENOMEM\n\t * and retries the truncate operation.\n\t */\n\terror = block_truncate_page(inode->i_mapping, newsize, xfs_get_blocks);\n\tif (error)\n\t\treturn error;\n\ttruncate_setsize(inode, newsize);\n\n\t/*\n\t * The \"we can't serialise against page faults\" pain gets worse.\n\t *\n\t * If the file is mapped then we have to clean the page at the old EOF\n\t * when extending the file. Extending the file can expose changes the\n\t * underlying page mapping (e.g. from beyond EOF to a hole or\n\t * unwritten), and so on the next attempt to write to that page we need\n\t * to remap it for write. i.e. we need .page_mkwrite() to be called.\n\t * Hence we need to clean the page to clean the pte and so a new write\n\t * fault will be triggered appropriately.\n\t *\n\t * If we do it before we change the inode size, then we can race with a\n\t * page fault that maps the page with exactly the same problem. If we do\n\t * it after we change the file size, then a new page fault can come in\n\t * and allocate space before we've run the rest of the truncate\n\t * transaction. That's kinda grotesque, but it's better than have data\n\t * over a hole, and so that's the lesser evil that has been chosen here.\n\t *\n\t * The real solution, however, is to have some mechanism for locking out\n\t * page faults while a truncate is in progress.\n\t */\n\tif (newsize > oldsize && mapping_mapped(VFS_I(ip)->i_mapping)) {\n\t\terror = filemap_write_and_wait_range(\n\t\t\t\tVFS_I(ip)->i_mapping,\n\t\t\t\tround_down(oldsize, PAGE_CACHE_SIZE),\n\t\t\t\tround_up(oldsize, PAGE_CACHE_SIZE) - 1);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_SETATTR_SIZE);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\n\tif (error)\n\t\tgoto out_trans_cancel;\n\n\tcommit_flags = XFS_TRANS_RELEASE_LOG_RES;\n\tlock_flags |= XFS_ILOCK_EXCL;\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, 0);\n\n\t/*\n\t * Only change the c/mtime if we are changing the size or we are\n\t * explicitly asked to change it.  This handles the semantic difference\n\t * between truncate() and ftruncate() as implemented in the VFS.\n\t *\n\t * The regular truncate() case without ATTR_CTIME and ATTR_MTIME is a\n\t * special case where we need to update the times despite not having\n\t * these flags set.  For all other operations the VFS set these flags\n\t * explicitly if it wants a timestamp update.\n\t */\n\tif (newsize != oldsize &&\n\t    !(iattr->ia_valid & (ATTR_CTIME | ATTR_MTIME))) {\n\t\tiattr->ia_ctime = iattr->ia_mtime =\n\t\t\tcurrent_fs_time(inode->i_sb);\n\t\tiattr->ia_valid |= ATTR_CTIME | ATTR_MTIME;\n\t}\n\n\t/*\n\t * The first thing we do is set the size to new_size permanently on\n\t * disk.  This way we don't have to worry about anyone ever being able\n\t * to look at the data being freed even in the face of a crash.\n\t * What we're getting around here is the case where we free a block, it\n\t * is allocated to another file, it is written to, and then we crash.\n\t * If the new data gets written to the file but the log buffers\n\t * containing the free and reallocation don't, then we'd end up with\n\t * garbage in the blocks being freed.  As long as we make the new size\n\t * permanent before actually freeing any blocks it doesn't matter if\n\t * they get written to.\n\t */\n\tip->i_d.di_size = newsize;\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tif (newsize <= oldsize) {\n\t\terror = xfs_itruncate_extents(&tp, ip, XFS_DATA_FORK, newsize);\n\t\tif (error)\n\t\t\tgoto out_trans_abort;\n\n\t\t/*\n\t\t * Truncated \"down\", so we're removing references to old data\n\t\t * here - if we delay flushing for a long time, we expose\n\t\t * ourselves unduly to the notorious NULL files problem.  So,\n\t\t * we mark this inode and flush it when the file is closed,\n\t\t * and do not wait the usual (long) time for writeout.\n\t\t */\n\t\txfs_iflags_set(ip, XFS_ITRUNCATED);\n\n\t\t/* A truncate down always removes post-EOF blocks. */\n\t\txfs_inode_clear_eofblocks_tag(ip);\n\t}\n\n\tif (iattr->ia_valid & ATTR_MODE)\n\t\txfs_setattr_mode(ip, iattr);\n\tif (iattr->ia_valid & (ATTR_ATIME|ATTR_CTIME|ATTR_MTIME))\n\t\txfs_setattr_time(ip, iattr);\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tXFS_STATS_INC(xs_ig_attrchg);\n\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(tp);\n\n\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\nout_unlock:\n\tif (lock_flags)\n\t\txfs_iunlock(ip, lock_flags);\n\treturn error;\n\nout_trans_abort:\n\tcommit_flags |= XFS_TRANS_ABORT;\nout_trans_cancel:\n\txfs_trans_cancel(tp, commit_flags);\n\tgoto out_unlock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_break_layouts",
          "args": [
            "dentry->d_inode",
            "&iolock"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_break_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_pnfs.h",
          "lines": "13-16",
          "snippet": "static inline int xfs_break_layouts(struct inode *inode, uint *iolock)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int xfs_break_layouts(struct inode *inode, uint *iolock)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "ip",
            "iolock"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "dentry->d_inode"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_vn_setattr(\n\tstruct dentry\t\t*dentry,\n\tstruct iattr\t\t*iattr)\n{\n\tstruct xfs_inode\t*ip = XFS_I(dentry->d_inode);\n\tint\t\t\terror;\n\n\tif (iattr->ia_valid & ATTR_SIZE) {\n\t\tuint\t\tiolock = XFS_IOLOCK_EXCL;\n\n\t\txfs_ilock(ip, iolock);\n\t\terror = xfs_break_layouts(dentry->d_inode, &iolock);\n\t\tif (!error)\n\t\t\terror = xfs_setattr_size(ip, iattr);\n\t\txfs_iunlock(ip, iolock);\n\t} else {\n\t\terror = xfs_setattr_nonsize(ip, iattr, 0);\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_setattr_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
    "lines": "742-964",
    "snippet": "int\nxfs_setattr_size(\n\tstruct xfs_inode\t*ip,\n\tstruct iattr\t\t*iattr)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct inode\t\t*inode = VFS_I(ip);\n\txfs_off_t\t\toldsize, newsize;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\tuint\t\t\tlock_flags = 0;\n\tuint\t\t\tcommit_flags = 0;\n\tbool\t\t\tdid_zeroing = false;\n\n\ttrace_xfs_setattr(ip);\n\n\tif (mp->m_flags & XFS_MOUNT_RDONLY)\n\t\treturn -EROFS;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\terror = inode_change_ok(inode, iattr);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\tASSERT(S_ISREG(ip->i_d.di_mode));\n\tASSERT((iattr->ia_valid & (ATTR_UID|ATTR_GID|ATTR_ATIME|ATTR_ATIME_SET|\n\t\tATTR_MTIME_SET|ATTR_KILL_PRIV|ATTR_TIMES_SET)) == 0);\n\n\toldsize = inode->i_size;\n\tnewsize = iattr->ia_size;\n\n\t/*\n\t * Short circuit the truncate case for zero length files.\n\t */\n\tif (newsize == 0 && oldsize == 0 && ip->i_d.di_nextents == 0) {\n\t\tif (!(iattr->ia_valid & (ATTR_CTIME|ATTR_MTIME)))\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * Use the regular setattr path to update the timestamps.\n\t\t */\n\t\tiattr->ia_valid &= ~ATTR_SIZE;\n\t\treturn xfs_setattr_nonsize(ip, iattr, 0);\n\t}\n\n\t/*\n\t * Make sure that the dquots are attached to the inode.\n\t */\n\terror = xfs_qm_dqattach(ip, 0);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * File data changes must be complete before we start the transaction to\n\t * modify the inode.  This needs to be done before joining the inode to\n\t * the transaction because the inode cannot be unlocked once it is a\n\t * part of the transaction.\n\t *\n\t * Start with zeroing any data block beyond EOF that we may expose on\n\t * file extension.\n\t */\n\tif (newsize > oldsize) {\n\t\terror = xfs_zero_eof(ip, newsize, oldsize, &did_zeroing);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * We are going to log the inode size change in this transaction so\n\t * any previous writes that are beyond the on disk EOF and the new\n\t * EOF that have not been written out need to be written here.  If we\n\t * do not write the data out, we expose ourselves to the null files\n\t * problem. Note that this includes any block zeroing we did above;\n\t * otherwise those blocks may not be zeroed after a crash.\n\t */\n\tif (newsize > ip->i_d.di_size &&\n\t    (oldsize != ip->i_d.di_size || did_zeroing)) {\n\t\terror = filemap_write_and_wait_range(VFS_I(ip)->i_mapping,\n\t\t\t\t\t\t      ip->i_d.di_size, newsize);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* Now wait for all direct I/O to complete. */\n\tinode_dio_wait(inode);\n\n\t/*\n\t * Do all the page cache truncate work outside the transaction context\n\t * as the \"lock\" order is page lock->log space reservation.  i.e.\n\t * locking pages inside the transaction can ABBA deadlock with\n\t * writeback. We have to do the VFS inode size update before we truncate\n\t * the pagecache, however, to avoid racing with page faults beyond the\n\t * new EOF they are not serialised against truncate operations except by\n\t * page locks and size updates.\n\t *\n\t * Hence we are in a situation where a truncate can fail with ENOMEM\n\t * from xfs_trans_reserve(), but having already truncated the in-memory\n\t * version of the file (i.e. made user visible changes). There's not\n\t * much we can do about this, except to hope that the caller sees ENOMEM\n\t * and retries the truncate operation.\n\t */\n\terror = block_truncate_page(inode->i_mapping, newsize, xfs_get_blocks);\n\tif (error)\n\t\treturn error;\n\ttruncate_setsize(inode, newsize);\n\n\t/*\n\t * The \"we can't serialise against page faults\" pain gets worse.\n\t *\n\t * If the file is mapped then we have to clean the page at the old EOF\n\t * when extending the file. Extending the file can expose changes the\n\t * underlying page mapping (e.g. from beyond EOF to a hole or\n\t * unwritten), and so on the next attempt to write to that page we need\n\t * to remap it for write. i.e. we need .page_mkwrite() to be called.\n\t * Hence we need to clean the page to clean the pte and so a new write\n\t * fault will be triggered appropriately.\n\t *\n\t * If we do it before we change the inode size, then we can race with a\n\t * page fault that maps the page with exactly the same problem. If we do\n\t * it after we change the file size, then a new page fault can come in\n\t * and allocate space before we've run the rest of the truncate\n\t * transaction. That's kinda grotesque, but it's better than have data\n\t * over a hole, and so that's the lesser evil that has been chosen here.\n\t *\n\t * The real solution, however, is to have some mechanism for locking out\n\t * page faults while a truncate is in progress.\n\t */\n\tif (newsize > oldsize && mapping_mapped(VFS_I(ip)->i_mapping)) {\n\t\terror = filemap_write_and_wait_range(\n\t\t\t\tVFS_I(ip)->i_mapping,\n\t\t\t\tround_down(oldsize, PAGE_CACHE_SIZE),\n\t\t\t\tround_up(oldsize, PAGE_CACHE_SIZE) - 1);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_SETATTR_SIZE);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\n\tif (error)\n\t\tgoto out_trans_cancel;\n\n\tcommit_flags = XFS_TRANS_RELEASE_LOG_RES;\n\tlock_flags |= XFS_ILOCK_EXCL;\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, 0);\n\n\t/*\n\t * Only change the c/mtime if we are changing the size or we are\n\t * explicitly asked to change it.  This handles the semantic difference\n\t * between truncate() and ftruncate() as implemented in the VFS.\n\t *\n\t * The regular truncate() case without ATTR_CTIME and ATTR_MTIME is a\n\t * special case where we need to update the times despite not having\n\t * these flags set.  For all other operations the VFS set these flags\n\t * explicitly if it wants a timestamp update.\n\t */\n\tif (newsize != oldsize &&\n\t    !(iattr->ia_valid & (ATTR_CTIME | ATTR_MTIME))) {\n\t\tiattr->ia_ctime = iattr->ia_mtime =\n\t\t\tcurrent_fs_time(inode->i_sb);\n\t\tiattr->ia_valid |= ATTR_CTIME | ATTR_MTIME;\n\t}\n\n\t/*\n\t * The first thing we do is set the size to new_size permanently on\n\t * disk.  This way we don't have to worry about anyone ever being able\n\t * to look at the data being freed even in the face of a crash.\n\t * What we're getting around here is the case where we free a block, it\n\t * is allocated to another file, it is written to, and then we crash.\n\t * If the new data gets written to the file but the log buffers\n\t * containing the free and reallocation don't, then we'd end up with\n\t * garbage in the blocks being freed.  As long as we make the new size\n\t * permanent before actually freeing any blocks it doesn't matter if\n\t * they get written to.\n\t */\n\tip->i_d.di_size = newsize;\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tif (newsize <= oldsize) {\n\t\terror = xfs_itruncate_extents(&tp, ip, XFS_DATA_FORK, newsize);\n\t\tif (error)\n\t\t\tgoto out_trans_abort;\n\n\t\t/*\n\t\t * Truncated \"down\", so we're removing references to old data\n\t\t * here - if we delay flushing for a long time, we expose\n\t\t * ourselves unduly to the notorious NULL files problem.  So,\n\t\t * we mark this inode and flush it when the file is closed,\n\t\t * and do not wait the usual (long) time for writeout.\n\t\t */\n\t\txfs_iflags_set(ip, XFS_ITRUNCATED);\n\n\t\t/* A truncate down always removes post-EOF blocks. */\n\t\txfs_inode_clear_eofblocks_tag(ip);\n\t}\n\n\tif (iattr->ia_valid & ATTR_MODE)\n\t\txfs_setattr_mode(ip, iattr);\n\tif (iattr->ia_valid & (ATTR_ATIME|ATTR_CTIME|ATTR_MTIME))\n\t\txfs_setattr_time(ip, iattr);\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tXFS_STATS_INC(xs_ig_attrchg);\n\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(tp);\n\n\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\nout_unlock:\n\tif (lock_flags)\n\t\txfs_iunlock(ip, lock_flags);\n\treturn error;\n\nout_trans_abort:\n\tcommit_flags |= XFS_TRANS_ABORT;\nout_trans_cancel:\n\txfs_trans_cancel(tp, commit_flags);\n\tgoto out_unlock;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/security.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/namei.h>",
      "#include <linux/xattr.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_acl.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_cancel",
          "args": [
            "tp",
            "commit_flags"
          ],
          "line": 962
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "937-986",
          "snippet": "void\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "ip",
            "lock_flags"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_commit",
          "args": [
            "tp",
            "XFS_TRANS_RELEASE_LOG_RES"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "845-927",
          "snippet": "int\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_set_sync",
          "args": [
            "tp"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_ig_attrchg"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "tp",
            "ip",
            "XFS_ILOG_CORE"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_setattr_time",
          "args": [
            "ip",
            "iattr"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_setattr_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
          "lines": "509-533",
          "snippet": "void\nxfs_setattr_time(\n\tstruct xfs_inode\t*ip,\n\tstruct iattr\t\t*iattr)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (iattr->ia_valid & ATTR_ATIME) {\n\t\tinode->i_atime = iattr->ia_atime;\n\t\tip->i_d.di_atime.t_sec = iattr->ia_atime.tv_sec;\n\t\tip->i_d.di_atime.t_nsec = iattr->ia_atime.tv_nsec;\n\t}\n\tif (iattr->ia_valid & ATTR_CTIME) {\n\t\tinode->i_ctime = iattr->ia_ctime;\n\t\tip->i_d.di_ctime.t_sec = iattr->ia_ctime.tv_sec;\n\t\tip->i_d.di_ctime.t_nsec = iattr->ia_ctime.tv_nsec;\n\t}\n\tif (iattr->ia_valid & ATTR_MTIME) {\n\t\tinode->i_mtime = iattr->ia_mtime;\n\t\tip->i_d.di_mtime.t_sec = iattr->ia_mtime.tv_sec;\n\t\tip->i_d.di_mtime.t_nsec = iattr->ia_mtime.tv_nsec;\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/security.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/namei.h>",
            "#include <linux/xattr.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_acl.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_setattr_time(\n\tstruct xfs_inode\t*ip,\n\tstruct iattr\t\t*iattr)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (iattr->ia_valid & ATTR_ATIME) {\n\t\tinode->i_atime = iattr->ia_atime;\n\t\tip->i_d.di_atime.t_sec = iattr->ia_atime.tv_sec;\n\t\tip->i_d.di_atime.t_nsec = iattr->ia_atime.tv_nsec;\n\t}\n\tif (iattr->ia_valid & ATTR_CTIME) {\n\t\tinode->i_ctime = iattr->ia_ctime;\n\t\tip->i_d.di_ctime.t_sec = iattr->ia_ctime.tv_sec;\n\t\tip->i_d.di_ctime.t_nsec = iattr->ia_ctime.tv_nsec;\n\t}\n\tif (iattr->ia_valid & ATTR_MTIME) {\n\t\tinode->i_mtime = iattr->ia_mtime;\n\t\tip->i_d.di_mtime.t_sec = iattr->ia_mtime.tv_sec;\n\t\tip->i_d.di_mtime.t_nsec = iattr->ia_mtime.tv_nsec;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_setattr_mode",
          "args": [
            "ip",
            "iattr"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_setattr_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
          "lines": "492-507",
          "snippet": "static void\nxfs_setattr_mode(\n\tstruct xfs_inode\t*ip,\n\tstruct iattr\t\t*iattr)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tumode_t\t\t\tmode = iattr->ia_mode;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tip->i_d.di_mode &= S_IFMT;\n\tip->i_d.di_mode |= mode & ~S_IFMT;\n\n\tinode->i_mode &= S_IFMT;\n\tinode->i_mode |= mode & ~S_IFMT;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/security.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/namei.h>",
            "#include <linux/xattr.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_acl.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nstatic void\nxfs_setattr_mode(\n\tstruct xfs_inode\t*ip,\n\tstruct iattr\t\t*iattr)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tumode_t\t\t\tmode = iattr->ia_mode;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tip->i_d.di_mode &= S_IFMT;\n\tip->i_d.di_mode |= mode & ~S_IFMT;\n\n\tinode->i_mode &= S_IFMT;\n\tinode->i_mode |= mode & ~S_IFMT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_inode_clear_eofblocks_tag",
          "args": [
            "ip"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inode_clear_eofblocks_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_icache.c",
          "lines": "1390-1417",
          "snippet": "void\nxfs_inode_clear_eofblocks_tag(\n\txfs_inode_t\t*ip)\n{\n\tstruct xfs_mount *mp = ip->i_mount;\n\tstruct xfs_perag *pag;\n\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ip->i_ino));\n\tspin_lock(&pag->pag_ici_lock);\n\ttrace_xfs_inode_clear_eofblocks_tag(ip);\n\n\tradix_tree_tag_clear(&pag->pag_ici_root,\n\t\t\t     XFS_INO_TO_AGINO(ip->i_mount, ip->i_ino),\n\t\t\t     XFS_ICI_EOFBLOCKS_TAG);\n\tif (!radix_tree_tagged(&pag->pag_ici_root, XFS_ICI_EOFBLOCKS_TAG)) {\n\t\t/* clear the eofblocks tag from the perag radix tree */\n\t\tspin_lock(&ip->i_mount->m_perag_lock);\n\t\tradix_tree_tag_clear(&ip->i_mount->m_perag_tree,\n\t\t\t\t     XFS_INO_TO_AGNO(ip->i_mount, ip->i_ino),\n\t\t\t\t     XFS_ICI_EOFBLOCKS_TAG);\n\t\tspin_unlock(&ip->i_mount->m_perag_lock);\n\t\ttrace_xfs_perag_clear_eofblocks(ip->i_mount, pag->pag_agno,\n\t\t\t\t\t       -1, _RET_IP_);\n\t}\n\n\tspin_unlock(&pag->pag_ici_lock);\n\txfs_perag_put(pag);\n}",
          "includes": [
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void __xfs_inode_clear_reclaim_tag(struct xfs_mount *mp,\n\t\t\t\tstruct xfs_perag *pag, struct xfs_inode *ip);\n\nvoid\nxfs_inode_clear_eofblocks_tag(\n\txfs_inode_t\t*ip)\n{\n\tstruct xfs_mount *mp = ip->i_mount;\n\tstruct xfs_perag *pag;\n\n\tpag = xfs_perag_get(mp, XFS_INO_TO_AGNO(mp, ip->i_ino));\n\tspin_lock(&pag->pag_ici_lock);\n\ttrace_xfs_inode_clear_eofblocks_tag(ip);\n\n\tradix_tree_tag_clear(&pag->pag_ici_root,\n\t\t\t     XFS_INO_TO_AGINO(ip->i_mount, ip->i_ino),\n\t\t\t     XFS_ICI_EOFBLOCKS_TAG);\n\tif (!radix_tree_tagged(&pag->pag_ici_root, XFS_ICI_EOFBLOCKS_TAG)) {\n\t\t/* clear the eofblocks tag from the perag radix tree */\n\t\tspin_lock(&ip->i_mount->m_perag_lock);\n\t\tradix_tree_tag_clear(&ip->i_mount->m_perag_tree,\n\t\t\t\t     XFS_INO_TO_AGNO(ip->i_mount, ip->i_ino),\n\t\t\t\t     XFS_ICI_EOFBLOCKS_TAG);\n\t\tspin_unlock(&ip->i_mount->m_perag_lock);\n\t\ttrace_xfs_perag_clear_eofblocks(ip->i_mount, pag->pag_agno,\n\t\t\t\t\t       -1, _RET_IP_);\n\t}\n\n\tspin_unlock(&pag->pag_ici_lock);\n\txfs_perag_put(pag);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iflags_set",
          "args": [
            "ip",
            "XFS_ITRUNCATED"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iflags_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "118-124",
          "snippet": "static inline void\nxfs_iflags_set(xfs_inode_t *ip, unsigned short flags)\n{\n\tspin_lock(&ip->i_flags_lock);\n\t__xfs_iflags_set(ip, flags);\n\tspin_unlock(&ip->i_flags_lock);\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline void\nxfs_iflags_set(xfs_inode_t *ip, unsigned short flags)\n{\n\tspin_lock(&ip->i_flags_lock);\n\t__xfs_iflags_set(ip, flags);\n\tspin_unlock(&ip->i_flags_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_itruncate_extents",
          "args": [
            "&tp",
            "ip",
            "XFS_DATA_FORK",
            "newsize"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_itruncate_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "1492-1605",
          "snippet": "int\nxfs_itruncate_extents(\n\tstruct xfs_trans\t**tpp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork,\n\txfs_fsize_t\t\tnew_size)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp = *tpp;\n\tstruct xfs_trans\t*ntp;\n\txfs_bmap_free_t\t\tfree_list;\n\txfs_fsblock_t\t\tfirst_block;\n\txfs_fileoff_t\t\tfirst_unmap_block;\n\txfs_fileoff_t\t\tlast_block;\n\txfs_filblks_t\t\tunmap_len;\n\tint\t\t\tcommitted;\n\tint\t\t\terror = 0;\n\tint\t\t\tdone = 0;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(!atomic_read(&VFS_I(ip)->i_count) ||\n\t       xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\tASSERT(new_size <= XFS_ISIZE(ip));\n\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(ip->i_itemp->ili_lock_flags == 0);\n\tASSERT(!XFS_NOT_DQATTACHED(mp, ip));\n\n\ttrace_xfs_itruncate_extents_start(ip, new_size);\n\n\t/*\n\t * Since it is possible for space to become allocated beyond\n\t * the end of the file (in a crash where the space is allocated\n\t * but the inode size is not yet updated), simply remove any\n\t * blocks which show up between the new EOF and the maximum\n\t * possible file size.  If the first block to be removed is\n\t * beyond the maximum file size (ie it is the same as last_block),\n\t * then there is nothing to do.\n\t */\n\tfirst_unmap_block = XFS_B_TO_FSB(mp, (xfs_ufsize_t)new_size);\n\tlast_block = XFS_B_TO_FSB(mp, mp->m_super->s_maxbytes);\n\tif (first_unmap_block == last_block)\n\t\treturn 0;\n\n\tASSERT(first_unmap_block < last_block);\n\tunmap_len = last_block - first_unmap_block + 1;\n\twhile (!done) {\n\t\txfs_bmap_init(&free_list, &first_block);\n\t\terror = xfs_bunmapi(tp, ip,\n\t\t\t\t    first_unmap_block, unmap_len,\n\t\t\t\t    xfs_bmapi_aflag(whichfork),\n\t\t\t\t    XFS_ITRUNC_MAX_EXTENTS,\n\t\t\t\t    &first_block, &free_list,\n\t\t\t\t    &done);\n\t\tif (error)\n\t\t\tgoto out_bmap_cancel;\n\n\t\t/*\n\t\t * Duplicate the transaction that has the permanent\n\t\t * reservation and commit the old transaction.\n\t\t */\n\t\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(tp, ip, 0);\n\t\tif (error)\n\t\t\tgoto out_bmap_cancel;\n\n\t\tif (committed) {\n\t\t\t/*\n\t\t\t * Mark the inode dirty so it will be logged and\n\t\t\t * moved forward in the log as part of every commit.\n\t\t\t */\n\t\t\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\t\t}\n\n\t\tntp = xfs_trans_dup(tp);\n\t\terror = xfs_trans_commit(tp, 0);\n\t\ttp = ntp;\n\n\t\txfs_trans_ijoin(tp, ip, 0);\n\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Transaction commit worked ok so we can drop the extra ticket\n\t\t * reference that we gained in xfs_trans_dup()\n\t\t */\n\t\txfs_log_ticket_put(tp->t_ticket);\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Always re-log the inode so that our permanent transaction can keep\n\t * on rolling it forward in the log.\n\t */\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\ttrace_xfs_itruncate_extents_end(ip, new_size);\n\nout:\n\t*tpp = tp;\n\treturn error;\nout_bmap_cancel:\n\t/*\n\t * If the bunmapi call encounters an error, return to the caller where\n\t * the transaction can be properly aborted.  We just need to make sure\n\t * we're not holding any resources that we were not when we came in.\n\t */\n\txfs_bmap_cancel(&free_list);\n\tgoto out;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [
            "#define\tXFS_ITRUNC_MAX_EXTENTS\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\n#define\tXFS_ITRUNC_MAX_EXTENTS\t2\n\nint\nxfs_itruncate_extents(\n\tstruct xfs_trans\t**tpp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork,\n\txfs_fsize_t\t\tnew_size)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_trans\t*tp = *tpp;\n\tstruct xfs_trans\t*ntp;\n\txfs_bmap_free_t\t\tfree_list;\n\txfs_fsblock_t\t\tfirst_block;\n\txfs_fileoff_t\t\tfirst_unmap_block;\n\txfs_fileoff_t\t\tlast_block;\n\txfs_filblks_t\t\tunmap_len;\n\tint\t\t\tcommitted;\n\tint\t\t\terror = 0;\n\tint\t\t\tdone = 0;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(!atomic_read(&VFS_I(ip)->i_count) ||\n\t       xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\tASSERT(new_size <= XFS_ISIZE(ip));\n\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(ip->i_itemp->ili_lock_flags == 0);\n\tASSERT(!XFS_NOT_DQATTACHED(mp, ip));\n\n\ttrace_xfs_itruncate_extents_start(ip, new_size);\n\n\t/*\n\t * Since it is possible for space to become allocated beyond\n\t * the end of the file (in a crash where the space is allocated\n\t * but the inode size is not yet updated), simply remove any\n\t * blocks which show up between the new EOF and the maximum\n\t * possible file size.  If the first block to be removed is\n\t * beyond the maximum file size (ie it is the same as last_block),\n\t * then there is nothing to do.\n\t */\n\tfirst_unmap_block = XFS_B_TO_FSB(mp, (xfs_ufsize_t)new_size);\n\tlast_block = XFS_B_TO_FSB(mp, mp->m_super->s_maxbytes);\n\tif (first_unmap_block == last_block)\n\t\treturn 0;\n\n\tASSERT(first_unmap_block < last_block);\n\tunmap_len = last_block - first_unmap_block + 1;\n\twhile (!done) {\n\t\txfs_bmap_init(&free_list, &first_block);\n\t\terror = xfs_bunmapi(tp, ip,\n\t\t\t\t    first_unmap_block, unmap_len,\n\t\t\t\t    xfs_bmapi_aflag(whichfork),\n\t\t\t\t    XFS_ITRUNC_MAX_EXTENTS,\n\t\t\t\t    &first_block, &free_list,\n\t\t\t\t    &done);\n\t\tif (error)\n\t\t\tgoto out_bmap_cancel;\n\n\t\t/*\n\t\t * Duplicate the transaction that has the permanent\n\t\t * reservation and commit the old transaction.\n\t\t */\n\t\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(tp, ip, 0);\n\t\tif (error)\n\t\t\tgoto out_bmap_cancel;\n\n\t\tif (committed) {\n\t\t\t/*\n\t\t\t * Mark the inode dirty so it will be logged and\n\t\t\t * moved forward in the log as part of every commit.\n\t\t\t */\n\t\t\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\t\t}\n\n\t\tntp = xfs_trans_dup(tp);\n\t\terror = xfs_trans_commit(tp, 0);\n\t\ttp = ntp;\n\n\t\txfs_trans_ijoin(tp, ip, 0);\n\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Transaction commit worked ok so we can drop the extra ticket\n\t\t * reference that we gained in xfs_trans_dup()\n\t\t */\n\t\txfs_log_ticket_put(tp->t_ticket);\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Always re-log the inode so that our permanent transaction can keep\n\t * on rolling it forward in the log.\n\t */\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\ttrace_xfs_itruncate_extents_end(ip, new_size);\n\nout:\n\t*tpp = tp;\n\treturn error;\nout_bmap_cancel:\n\t/*\n\t * If the bunmapi call encounters an error, return to the caller where\n\t * the transaction can be properly aborted.  We just need to make sure\n\t * we're not holding any resources that we were not when we came in.\n\t */\n\txfs_bmap_cancel(&free_list);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fs_time",
          "args": [
            "inode->i_sb"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_ijoin",
          "args": [
            "tp",
            "ip",
            "0"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ijoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "37-57",
          "snippet": "void\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve",
          "args": [
            "tp",
            "&M_RES(mp)->tr_itruncate",
            "0",
            "0"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "168-279",
          "snippet": "int\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_alloc",
          "args": [
            "mp",
            "XFS_TRANS_SETATTR_SIZE"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "57-68",
          "snippet": "xfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait_range",
          "args": [
            "VFS_I(ip)->i_mapping",
            "round_down(oldsize, PAGE_CACHE_SIZE)",
            "round_up(oldsize, PAGE_CACHE_SIZE) - 1"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "oldsize",
            "PAGE_CACHE_SIZE"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_down",
          "args": [
            "oldsize",
            "PAGE_CACHE_SIZE"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "ip"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "78-81",
          "snippet": "static inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_mapped",
          "args": [
            "VFS_I(ip)->i_mapping"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truncate_setsize",
          "args": [
            "inode",
            "newsize"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block_truncate_page",
          "args": [
            "inode->i_mapping",
            "newsize",
            "xfs_get_blocks"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "block_truncate_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2806-2879",
          "snippet": "int block_truncate_page(struct address_space *mapping,\n\t\t\tloff_t from, get_block_t *get_block)\n{\n\tpgoff_t index = from >> PAGE_CACHE_SHIFT;\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tunsigned blocksize;\n\tsector_t iblock;\n\tunsigned length, pos;\n\tstruct inode *inode = mapping->host;\n\tstruct page *page;\n\tstruct buffer_head *bh;\n\tint err;\n\n\tblocksize = 1 << inode->i_blkbits;\n\tlength = offset & (blocksize - 1);\n\n\t/* Block boundary? Nothing to do */\n\tif (!length)\n\t\treturn 0;\n\n\tlength = blocksize - length;\n\tiblock = (sector_t)index << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\t\n\tpage = grab_cache_page(mapping, index);\n\terr = -ENOMEM;\n\tif (!page)\n\t\tgoto out;\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\n\t/* Find the buffer that contains \"offset\" */\n\tbh = page_buffers(page);\n\tpos = blocksize;\n\twhile (offset >= pos) {\n\t\tbh = bh->b_this_page;\n\t\tiblock++;\n\t\tpos += blocksize;\n\t}\n\n\terr = 0;\n\tif (!buffer_mapped(bh)) {\n\t\tWARN_ON(bh->b_size != blocksize);\n\t\terr = get_block(inode, iblock, bh, 0);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t\t/* unmapped? It's a hole - nothing to do */\n\t\tif (!buffer_mapped(bh))\n\t\t\tgoto unlock;\n\t}\n\n\t/* Ok, it's mapped. Make sure it's up-to-date */\n\tif (PageUptodate(page))\n\t\tset_buffer_uptodate(bh);\n\n\tif (!buffer_uptodate(bh) && !buffer_delay(bh) && !buffer_unwritten(bh)) {\n\t\terr = -EIO;\n\t\tll_rw_block(READ, 1, &bh);\n\t\twait_on_buffer(bh);\n\t\t/* Uhhuh. Read error. Complain and punt. */\n\t\tif (!buffer_uptodate(bh))\n\t\t\tgoto unlock;\n\t}\n\n\tzero_user(page, offset, length);\n\tmark_buffer_dirty(bh);\n\terr = 0;\n\nunlock:\n\tunlock_page(page);\n\tpage_cache_release(page);\nout:\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_truncate_page(struct address_space *mapping,\n\t\t\tloff_t from, get_block_t *get_block)\n{\n\tpgoff_t index = from >> PAGE_CACHE_SHIFT;\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tunsigned blocksize;\n\tsector_t iblock;\n\tunsigned length, pos;\n\tstruct inode *inode = mapping->host;\n\tstruct page *page;\n\tstruct buffer_head *bh;\n\tint err;\n\n\tblocksize = 1 << inode->i_blkbits;\n\tlength = offset & (blocksize - 1);\n\n\t/* Block boundary? Nothing to do */\n\tif (!length)\n\t\treturn 0;\n\n\tlength = blocksize - length;\n\tiblock = (sector_t)index << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\t\n\tpage = grab_cache_page(mapping, index);\n\terr = -ENOMEM;\n\tif (!page)\n\t\tgoto out;\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\n\t/* Find the buffer that contains \"offset\" */\n\tbh = page_buffers(page);\n\tpos = blocksize;\n\twhile (offset >= pos) {\n\t\tbh = bh->b_this_page;\n\t\tiblock++;\n\t\tpos += blocksize;\n\t}\n\n\terr = 0;\n\tif (!buffer_mapped(bh)) {\n\t\tWARN_ON(bh->b_size != blocksize);\n\t\terr = get_block(inode, iblock, bh, 0);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t\t/* unmapped? It's a hole - nothing to do */\n\t\tif (!buffer_mapped(bh))\n\t\t\tgoto unlock;\n\t}\n\n\t/* Ok, it's mapped. Make sure it's up-to-date */\n\tif (PageUptodate(page))\n\t\tset_buffer_uptodate(bh);\n\n\tif (!buffer_uptodate(bh) && !buffer_delay(bh) && !buffer_unwritten(bh)) {\n\t\terr = -EIO;\n\t\tll_rw_block(READ, 1, &bh);\n\t\twait_on_buffer(bh);\n\t\t/* Uhhuh. Read error. Complain and punt. */\n\t\tif (!buffer_uptodate(bh))\n\t\t\tgoto unlock;\n\t}\n\n\tzero_user(page, offset, length);\n\tmark_buffer_dirty(bh);\n\terr = 0;\n\nunlock:\n\tunlock_page(page);\n\tpage_cache_release(page);\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_dio_wait",
          "args": [
            "inode"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "inode_dio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1941-1945",
          "snippet": "void inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait_range",
          "args": [
            "VFS_I(ip)->i_mapping",
            "ip->i_d.di_size",
            "newsize"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_zero_eof",
          "args": [
            "ip",
            "newsize",
            "oldsize",
            "&did_zeroing"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_zero_eof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_file.c",
          "lines": "444-537",
          "snippet": "int\t\t\t\t\t/* error (positive) */\nxfs_zero_eof(\n\tstruct xfs_inode\t*ip,\n\txfs_off_t\t\toffset,\t\t/* starting I/O offset */\n\txfs_fsize_t\t\tisize,\t\t/* current inode size */\n\tbool\t\t\t*did_zeroing)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\txfs_fileoff_t\t\tstart_zero_fsb;\n\txfs_fileoff_t\t\tend_zero_fsb;\n\txfs_fileoff_t\t\tzero_count_fsb;\n\txfs_fileoff_t\t\tlast_fsb;\n\txfs_fileoff_t\t\tzero_off;\n\txfs_fsize_t\t\tzero_len;\n\tint\t\t\tnimaps;\n\tint\t\t\terror = 0;\n\tstruct xfs_bmbt_irec\timap;\n\n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\tASSERT(offset > isize);\n\n\t/*\n\t * First handle zeroing the block on which isize resides.\n\t *\n\t * We only zero a part of that block so it is handled specially.\n\t */\n\tif (XFS_B_FSB_OFFSET(mp, isize) != 0) {\n\t\terror = xfs_zero_last_block(ip, offset, isize, did_zeroing);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * Calculate the range between the new size and the old where blocks\n\t * needing to be zeroed may exist.\n\t *\n\t * To get the block where the last byte in the file currently resides,\n\t * we need to subtract one from the size and truncate back to a block\n\t * boundary.  We subtract 1 in case the size is exactly on a block\n\t * boundary.\n\t */\n\tlast_fsb = isize ? XFS_B_TO_FSBT(mp, isize - 1) : (xfs_fileoff_t)-1;\n\tstart_zero_fsb = XFS_B_TO_FSB(mp, (xfs_ufsize_t)isize);\n\tend_zero_fsb = XFS_B_TO_FSBT(mp, offset - 1);\n\tASSERT((xfs_sfiloff_t)last_fsb < (xfs_sfiloff_t)start_zero_fsb);\n\tif (last_fsb == end_zero_fsb) {\n\t\t/*\n\t\t * The size was only incremented on its last block.\n\t\t * We took care of that above, so just return.\n\t\t */\n\t\treturn 0;\n\t}\n\n\tASSERT(start_zero_fsb <= end_zero_fsb);\n\twhile (start_zero_fsb <= end_zero_fsb) {\n\t\tnimaps = 1;\n\t\tzero_count_fsb = end_zero_fsb - start_zero_fsb + 1;\n\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\terror = xfs_bmapi_read(ip, start_zero_fsb, zero_count_fsb,\n\t\t\t\t\t  &imap, &nimaps, 0);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tASSERT(nimaps > 0);\n\n\t\tif (imap.br_state == XFS_EXT_UNWRITTEN ||\n\t\t    imap.br_startblock == HOLESTARTBLOCK) {\n\t\t\tstart_zero_fsb = imap.br_startoff + imap.br_blockcount;\n\t\t\tASSERT(start_zero_fsb <= (end_zero_fsb + 1));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * There are blocks we need to zero.\n\t\t */\n\t\tzero_off = XFS_FSB_TO_B(mp, start_zero_fsb);\n\t\tzero_len = XFS_FSB_TO_B(mp, imap.br_blockcount);\n\n\t\tif ((zero_off + zero_len) > offset)\n\t\t\tzero_len = offset - zero_off;\n\n\t\terror = xfs_iozero(ip, zero_off, zero_len);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t*did_zeroing = true;\n\t\tstart_zero_fsb = imap.br_startoff + imap.br_blockcount;\n\t\tASSERT(start_zero_fsb <= (end_zero_fsb + 1));\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/pagevec.h>",
            "#include <linux/falloc.h>",
            "#include <linux/dcache.h>",
            "#include <linux/aio.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_ioctl.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagevec.h>\n#include <linux/falloc.h>\n#include <linux/dcache.h>\n#include <linux/aio.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_ioctl.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error (positive) */\nxfs_zero_eof(\n\tstruct xfs_inode\t*ip,\n\txfs_off_t\t\toffset,\t\t/* starting I/O offset */\n\txfs_fsize_t\t\tisize,\t\t/* current inode size */\n\tbool\t\t\t*did_zeroing)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\txfs_fileoff_t\t\tstart_zero_fsb;\n\txfs_fileoff_t\t\tend_zero_fsb;\n\txfs_fileoff_t\t\tzero_count_fsb;\n\txfs_fileoff_t\t\tlast_fsb;\n\txfs_fileoff_t\t\tzero_off;\n\txfs_fsize_t\t\tzero_len;\n\tint\t\t\tnimaps;\n\tint\t\t\terror = 0;\n\tstruct xfs_bmbt_irec\timap;\n\n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\tASSERT(offset > isize);\n\n\t/*\n\t * First handle zeroing the block on which isize resides.\n\t *\n\t * We only zero a part of that block so it is handled specially.\n\t */\n\tif (XFS_B_FSB_OFFSET(mp, isize) != 0) {\n\t\terror = xfs_zero_last_block(ip, offset, isize, did_zeroing);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * Calculate the range between the new size and the old where blocks\n\t * needing to be zeroed may exist.\n\t *\n\t * To get the block where the last byte in the file currently resides,\n\t * we need to subtract one from the size and truncate back to a block\n\t * boundary.  We subtract 1 in case the size is exactly on a block\n\t * boundary.\n\t */\n\tlast_fsb = isize ? XFS_B_TO_FSBT(mp, isize - 1) : (xfs_fileoff_t)-1;\n\tstart_zero_fsb = XFS_B_TO_FSB(mp, (xfs_ufsize_t)isize);\n\tend_zero_fsb = XFS_B_TO_FSBT(mp, offset - 1);\n\tASSERT((xfs_sfiloff_t)last_fsb < (xfs_sfiloff_t)start_zero_fsb);\n\tif (last_fsb == end_zero_fsb) {\n\t\t/*\n\t\t * The size was only incremented on its last block.\n\t\t * We took care of that above, so just return.\n\t\t */\n\t\treturn 0;\n\t}\n\n\tASSERT(start_zero_fsb <= end_zero_fsb);\n\twhile (start_zero_fsb <= end_zero_fsb) {\n\t\tnimaps = 1;\n\t\tzero_count_fsb = end_zero_fsb - start_zero_fsb + 1;\n\n\t\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\t\terror = xfs_bmapi_read(ip, start_zero_fsb, zero_count_fsb,\n\t\t\t\t\t  &imap, &nimaps, 0);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tASSERT(nimaps > 0);\n\n\t\tif (imap.br_state == XFS_EXT_UNWRITTEN ||\n\t\t    imap.br_startblock == HOLESTARTBLOCK) {\n\t\t\tstart_zero_fsb = imap.br_startoff + imap.br_blockcount;\n\t\t\tASSERT(start_zero_fsb <= (end_zero_fsb + 1));\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * There are blocks we need to zero.\n\t\t */\n\t\tzero_off = XFS_FSB_TO_B(mp, start_zero_fsb);\n\t\tzero_len = XFS_FSB_TO_B(mp, imap.br_blockcount);\n\n\t\tif ((zero_off + zero_len) > offset)\n\t\t\tzero_len = offset - zero_off;\n\n\t\terror = xfs_iozero(ip, zero_off, zero_len);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t*did_zeroing = true;\n\t\tstart_zero_fsb = imap.br_startoff + imap.br_blockcount;\n\t\tASSERT(start_zero_fsb <= (end_zero_fsb + 1));\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_qm_dqattach",
          "args": [
            "ip",
            "0"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqattach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
          "lines": "379-394",
          "snippet": "int\nxfs_qm_dqattach(\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tflags)\n{\n\tint\t\t\terror;\n\n\tif (!xfs_qm_need_dqattach(ip))\n\t\treturn 0;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\terror = xfs_qm_dqattach_locked(ip, flags);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_qm_dqattach(\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tflags)\n{\n\tint\t\t\terror;\n\n\tif (!xfs_qm_need_dqattach(ip))\n\t\treturn 0;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\terror = xfs_qm_dqattach_locked(ip, flags);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_setattr_nonsize",
          "args": [
            "ip",
            "iattr",
            "0"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_setattr_nonsize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
          "lines": "535-737",
          "snippet": "int\nxfs_setattr_nonsize(\n\tstruct xfs_inode\t*ip,\n\tstruct iattr\t\t*iattr,\n\tint\t\t\tflags)\n{\n\txfs_mount_t\t\t*mp = ip->i_mount;\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tint\t\t\tmask = iattr->ia_valid;\n\txfs_trans_t\t\t*tp;\n\tint\t\t\terror;\n\tkuid_t\t\t\tuid = GLOBAL_ROOT_UID, iuid = GLOBAL_ROOT_UID;\n\tkgid_t\t\t\tgid = GLOBAL_ROOT_GID, igid = GLOBAL_ROOT_GID;\n\tstruct xfs_dquot\t*udqp = NULL, *gdqp = NULL;\n\tstruct xfs_dquot\t*olddquot1 = NULL, *olddquot2 = NULL;\n\n\ttrace_xfs_setattr(ip);\n\n\t/* If acls are being inherited, we already have this checked */\n\tif (!(flags & XFS_ATTR_NOACL)) {\n\t\tif (mp->m_flags & XFS_MOUNT_RDONLY)\n\t\t\treturn -EROFS;\n\n\t\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\t\treturn -EIO;\n\n\t\terror = inode_change_ok(inode, iattr);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tASSERT((mask & ATTR_SIZE) == 0);\n\n\t/*\n\t * If disk quotas is on, we make sure that the dquots do exist on disk,\n\t * before we start any other transactions. Trying to do this later\n\t * is messy. We don't care to take a readlock to look at the ids\n\t * in inode here, because we can't hold it across the trans_reserve.\n\t * If the IDs do change before we take the ilock, we're covered\n\t * because the i_*dquot fields will get updated anyway.\n\t */\n\tif (XFS_IS_QUOTA_ON(mp) && (mask & (ATTR_UID|ATTR_GID))) {\n\t\tuint\tqflags = 0;\n\n\t\tif ((mask & ATTR_UID) && XFS_IS_UQUOTA_ON(mp)) {\n\t\t\tuid = iattr->ia_uid;\n\t\t\tqflags |= XFS_QMOPT_UQUOTA;\n\t\t} else {\n\t\t\tuid = inode->i_uid;\n\t\t}\n\t\tif ((mask & ATTR_GID) && XFS_IS_GQUOTA_ON(mp)) {\n\t\t\tgid = iattr->ia_gid;\n\t\t\tqflags |= XFS_QMOPT_GQUOTA;\n\t\t}  else {\n\t\t\tgid = inode->i_gid;\n\t\t}\n\n\t\t/*\n\t\t * We take a reference when we initialize udqp and gdqp,\n\t\t * so it is important that we never blindly double trip on\n\t\t * the same variable. See xfs_create() for an example.\n\t\t */\n\t\tASSERT(udqp == NULL);\n\t\tASSERT(gdqp == NULL);\n\t\terror = xfs_qm_vop_dqalloc(ip, xfs_kuid_to_uid(uid),\n\t\t\t\t\t   xfs_kgid_to_gid(gid),\n\t\t\t\t\t   xfs_get_projid(ip),\n\t\t\t\t\t   qflags, &udqp, &gdqp, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_SETATTR_NOT_SIZE);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_ichange, 0, 0);\n\tif (error)\n\t\tgoto out_dqrele;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * Change file ownership.  Must be the owner or privileged.\n\t */\n\tif (mask & (ATTR_UID|ATTR_GID)) {\n\t\t/*\n\t\t * These IDs could have changed since we last looked at them.\n\t\t * But, we're assured that if the ownership did change\n\t\t * while we didn't have the inode locked, inode's dquot(s)\n\t\t * would have changed also.\n\t\t */\n\t\tiuid = inode->i_uid;\n\t\tigid = inode->i_gid;\n\t\tgid = (mask & ATTR_GID) ? iattr->ia_gid : igid;\n\t\tuid = (mask & ATTR_UID) ? iattr->ia_uid : iuid;\n\n\t\t/*\n\t\t * Do a quota reservation only if uid/gid is actually\n\t\t * going to change.\n\t\t */\n\t\tif (XFS_IS_QUOTA_RUNNING(mp) &&\n\t\t    ((XFS_IS_UQUOTA_ON(mp) && !uid_eq(iuid, uid)) ||\n\t\t     (XFS_IS_GQUOTA_ON(mp) && !gid_eq(igid, gid)))) {\n\t\t\tASSERT(tp);\n\t\t\terror = xfs_qm_vop_chown_reserve(tp, ip, udqp, gdqp,\n\t\t\t\t\t\tNULL, capable(CAP_FOWNER) ?\n\t\t\t\t\t\tXFS_QMOPT_FORCE_RES : 0);\n\t\t\tif (error)\t/* out of quota */\n\t\t\t\tgoto out_trans_cancel;\n\t\t}\n\t}\n\n\txfs_trans_ijoin(tp, ip, 0);\n\n\t/*\n\t * Change file ownership.  Must be the owner or privileged.\n\t */\n\tif (mask & (ATTR_UID|ATTR_GID)) {\n\t\t/*\n\t\t * CAP_FSETID overrides the following restrictions:\n\t\t *\n\t\t * The set-user-ID and set-group-ID bits of a file will be\n\t\t * cleared upon successful return from chown()\n\t\t */\n\t\tif ((ip->i_d.di_mode & (S_ISUID|S_ISGID)) &&\n\t\t    !capable(CAP_FSETID))\n\t\t\tip->i_d.di_mode &= ~(S_ISUID|S_ISGID);\n\n\t\t/*\n\t\t * Change the ownerships and register quota modifications\n\t\t * in the transaction.\n\t\t */\n\t\tif (!uid_eq(iuid, uid)) {\n\t\t\tif (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_UQUOTA_ON(mp)) {\n\t\t\t\tASSERT(mask & ATTR_UID);\n\t\t\t\tASSERT(udqp);\n\t\t\t\tolddquot1 = xfs_qm_vop_chown(tp, ip,\n\t\t\t\t\t\t\t&ip->i_udquot, udqp);\n\t\t\t}\n\t\t\tip->i_d.di_uid = xfs_kuid_to_uid(uid);\n\t\t\tinode->i_uid = uid;\n\t\t}\n\t\tif (!gid_eq(igid, gid)) {\n\t\t\tif (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_GQUOTA_ON(mp)) {\n\t\t\t\tASSERT(xfs_sb_version_has_pquotino(&mp->m_sb) ||\n\t\t\t\t       !XFS_IS_PQUOTA_ON(mp));\n\t\t\t\tASSERT(mask & ATTR_GID);\n\t\t\t\tASSERT(gdqp);\n\t\t\t\tolddquot2 = xfs_qm_vop_chown(tp, ip,\n\t\t\t\t\t\t\t&ip->i_gdquot, gdqp);\n\t\t\t}\n\t\t\tip->i_d.di_gid = xfs_kgid_to_gid(gid);\n\t\t\tinode->i_gid = gid;\n\t\t}\n\t}\n\n\tif (mask & ATTR_MODE)\n\t\txfs_setattr_mode(ip, iattr);\n\tif (mask & (ATTR_ATIME|ATTR_CTIME|ATTR_MTIME))\n\t\txfs_setattr_time(ip, iattr);\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tXFS_STATS_INC(xs_ig_attrchg);\n\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(tp);\n\terror = xfs_trans_commit(tp, 0);\n\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * Release any dquot(s) the inode had kept before chown.\n\t */\n\txfs_qm_dqrele(olddquot1);\n\txfs_qm_dqrele(olddquot2);\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * XXX(hch): Updating the ACL entries is not atomic vs the i_mode\n\t * \t     update.  We could avoid this with linked transactions\n\t * \t     and passing down the transaction pointer all the way\n\t *\t     to attr_set.  No previous user of the generic\n\t * \t     Posix ACL code seems to care about this issue either.\n\t */\n\tif ((mask & ATTR_MODE) && !(flags & XFS_ATTR_NOACL)) {\n\t\terror = posix_acl_chmod(inode, inode->i_mode);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n\nout_trans_cancel:\n\txfs_trans_cancel(tp, 0);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\nout_dqrele:\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\treturn error;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/security.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/namei.h>",
            "#include <linux/xattr.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_acl.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nint\nxfs_setattr_nonsize(\n\tstruct xfs_inode\t*ip,\n\tstruct iattr\t\t*iattr,\n\tint\t\t\tflags)\n{\n\txfs_mount_t\t\t*mp = ip->i_mount;\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tint\t\t\tmask = iattr->ia_valid;\n\txfs_trans_t\t\t*tp;\n\tint\t\t\terror;\n\tkuid_t\t\t\tuid = GLOBAL_ROOT_UID, iuid = GLOBAL_ROOT_UID;\n\tkgid_t\t\t\tgid = GLOBAL_ROOT_GID, igid = GLOBAL_ROOT_GID;\n\tstruct xfs_dquot\t*udqp = NULL, *gdqp = NULL;\n\tstruct xfs_dquot\t*olddquot1 = NULL, *olddquot2 = NULL;\n\n\ttrace_xfs_setattr(ip);\n\n\t/* If acls are being inherited, we already have this checked */\n\tif (!(flags & XFS_ATTR_NOACL)) {\n\t\tif (mp->m_flags & XFS_MOUNT_RDONLY)\n\t\t\treturn -EROFS;\n\n\t\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\t\treturn -EIO;\n\n\t\terror = inode_change_ok(inode, iattr);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tASSERT((mask & ATTR_SIZE) == 0);\n\n\t/*\n\t * If disk quotas is on, we make sure that the dquots do exist on disk,\n\t * before we start any other transactions. Trying to do this later\n\t * is messy. We don't care to take a readlock to look at the ids\n\t * in inode here, because we can't hold it across the trans_reserve.\n\t * If the IDs do change before we take the ilock, we're covered\n\t * because the i_*dquot fields will get updated anyway.\n\t */\n\tif (XFS_IS_QUOTA_ON(mp) && (mask & (ATTR_UID|ATTR_GID))) {\n\t\tuint\tqflags = 0;\n\n\t\tif ((mask & ATTR_UID) && XFS_IS_UQUOTA_ON(mp)) {\n\t\t\tuid = iattr->ia_uid;\n\t\t\tqflags |= XFS_QMOPT_UQUOTA;\n\t\t} else {\n\t\t\tuid = inode->i_uid;\n\t\t}\n\t\tif ((mask & ATTR_GID) && XFS_IS_GQUOTA_ON(mp)) {\n\t\t\tgid = iattr->ia_gid;\n\t\t\tqflags |= XFS_QMOPT_GQUOTA;\n\t\t}  else {\n\t\t\tgid = inode->i_gid;\n\t\t}\n\n\t\t/*\n\t\t * We take a reference when we initialize udqp and gdqp,\n\t\t * so it is important that we never blindly double trip on\n\t\t * the same variable. See xfs_create() for an example.\n\t\t */\n\t\tASSERT(udqp == NULL);\n\t\tASSERT(gdqp == NULL);\n\t\terror = xfs_qm_vop_dqalloc(ip, xfs_kuid_to_uid(uid),\n\t\t\t\t\t   xfs_kgid_to_gid(gid),\n\t\t\t\t\t   xfs_get_projid(ip),\n\t\t\t\t\t   qflags, &udqp, &gdqp, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_SETATTR_NOT_SIZE);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_ichange, 0, 0);\n\tif (error)\n\t\tgoto out_dqrele;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * Change file ownership.  Must be the owner or privileged.\n\t */\n\tif (mask & (ATTR_UID|ATTR_GID)) {\n\t\t/*\n\t\t * These IDs could have changed since we last looked at them.\n\t\t * But, we're assured that if the ownership did change\n\t\t * while we didn't have the inode locked, inode's dquot(s)\n\t\t * would have changed also.\n\t\t */\n\t\tiuid = inode->i_uid;\n\t\tigid = inode->i_gid;\n\t\tgid = (mask & ATTR_GID) ? iattr->ia_gid : igid;\n\t\tuid = (mask & ATTR_UID) ? iattr->ia_uid : iuid;\n\n\t\t/*\n\t\t * Do a quota reservation only if uid/gid is actually\n\t\t * going to change.\n\t\t */\n\t\tif (XFS_IS_QUOTA_RUNNING(mp) &&\n\t\t    ((XFS_IS_UQUOTA_ON(mp) && !uid_eq(iuid, uid)) ||\n\t\t     (XFS_IS_GQUOTA_ON(mp) && !gid_eq(igid, gid)))) {\n\t\t\tASSERT(tp);\n\t\t\terror = xfs_qm_vop_chown_reserve(tp, ip, udqp, gdqp,\n\t\t\t\t\t\tNULL, capable(CAP_FOWNER) ?\n\t\t\t\t\t\tXFS_QMOPT_FORCE_RES : 0);\n\t\t\tif (error)\t/* out of quota */\n\t\t\t\tgoto out_trans_cancel;\n\t\t}\n\t}\n\n\txfs_trans_ijoin(tp, ip, 0);\n\n\t/*\n\t * Change file ownership.  Must be the owner or privileged.\n\t */\n\tif (mask & (ATTR_UID|ATTR_GID)) {\n\t\t/*\n\t\t * CAP_FSETID overrides the following restrictions:\n\t\t *\n\t\t * The set-user-ID and set-group-ID bits of a file will be\n\t\t * cleared upon successful return from chown()\n\t\t */\n\t\tif ((ip->i_d.di_mode & (S_ISUID|S_ISGID)) &&\n\t\t    !capable(CAP_FSETID))\n\t\t\tip->i_d.di_mode &= ~(S_ISUID|S_ISGID);\n\n\t\t/*\n\t\t * Change the ownerships and register quota modifications\n\t\t * in the transaction.\n\t\t */\n\t\tif (!uid_eq(iuid, uid)) {\n\t\t\tif (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_UQUOTA_ON(mp)) {\n\t\t\t\tASSERT(mask & ATTR_UID);\n\t\t\t\tASSERT(udqp);\n\t\t\t\tolddquot1 = xfs_qm_vop_chown(tp, ip,\n\t\t\t\t\t\t\t&ip->i_udquot, udqp);\n\t\t\t}\n\t\t\tip->i_d.di_uid = xfs_kuid_to_uid(uid);\n\t\t\tinode->i_uid = uid;\n\t\t}\n\t\tif (!gid_eq(igid, gid)) {\n\t\t\tif (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_GQUOTA_ON(mp)) {\n\t\t\t\tASSERT(xfs_sb_version_has_pquotino(&mp->m_sb) ||\n\t\t\t\t       !XFS_IS_PQUOTA_ON(mp));\n\t\t\t\tASSERT(mask & ATTR_GID);\n\t\t\t\tASSERT(gdqp);\n\t\t\t\tolddquot2 = xfs_qm_vop_chown(tp, ip,\n\t\t\t\t\t\t\t&ip->i_gdquot, gdqp);\n\t\t\t}\n\t\t\tip->i_d.di_gid = xfs_kgid_to_gid(gid);\n\t\t\tinode->i_gid = gid;\n\t\t}\n\t}\n\n\tif (mask & ATTR_MODE)\n\t\txfs_setattr_mode(ip, iattr);\n\tif (mask & (ATTR_ATIME|ATTR_CTIME|ATTR_MTIME))\n\t\txfs_setattr_time(ip, iattr);\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tXFS_STATS_INC(xs_ig_attrchg);\n\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(tp);\n\terror = xfs_trans_commit(tp, 0);\n\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * Release any dquot(s) the inode had kept before chown.\n\t */\n\txfs_qm_dqrele(olddquot1);\n\txfs_qm_dqrele(olddquot2);\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * XXX(hch): Updating the ACL entries is not atomic vs the i_mode\n\t * \t     update.  We could avoid this with linked transactions\n\t * \t     and passing down the transaction pointer all the way\n\t *\t     to attr_set.  No previous user of the generic\n\t * \t     Posix ACL code seems to care about this issue either.\n\t */\n\tif ((mask & ATTR_MODE) && !(flags & XFS_ATTR_NOACL)) {\n\t\terror = posix_acl_chmod(inode, inode->i_mode);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n\nout_trans_cancel:\n\txfs_trans_cancel(tp, 0);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\nout_dqrele:\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(iattr->ia_valid & (ATTR_UID|ATTR_GID|ATTR_ATIME|ATTR_ATIME_SET|\n\t\tATTR_MTIME_SET|ATTR_KILL_PRIV|ATTR_TIMES_SET)) == 0"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "S_ISREG(ip->i_d.di_mode)"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "ip->i_d.di_mode"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_isilocked(ip, XFS_IOLOCK_EXCL)"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_isilocked",
          "args": [
            "ip",
            "XFS_IOLOCK_EXCL"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_isilocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "286-305",
          "snippet": "int\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_change_ok",
          "args": [
            "inode",
            "iattr"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "inode_change_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "31-81",
          "snippet": "int inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_setattr",
          "args": [
            "ip"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nint\nxfs_setattr_size(\n\tstruct xfs_inode\t*ip,\n\tstruct iattr\t\t*iattr)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct inode\t\t*inode = VFS_I(ip);\n\txfs_off_t\t\toldsize, newsize;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\tuint\t\t\tlock_flags = 0;\n\tuint\t\t\tcommit_flags = 0;\n\tbool\t\t\tdid_zeroing = false;\n\n\ttrace_xfs_setattr(ip);\n\n\tif (mp->m_flags & XFS_MOUNT_RDONLY)\n\t\treturn -EROFS;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\terror = inode_change_ok(inode, iattr);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\tASSERT(S_ISREG(ip->i_d.di_mode));\n\tASSERT((iattr->ia_valid & (ATTR_UID|ATTR_GID|ATTR_ATIME|ATTR_ATIME_SET|\n\t\tATTR_MTIME_SET|ATTR_KILL_PRIV|ATTR_TIMES_SET)) == 0);\n\n\toldsize = inode->i_size;\n\tnewsize = iattr->ia_size;\n\n\t/*\n\t * Short circuit the truncate case for zero length files.\n\t */\n\tif (newsize == 0 && oldsize == 0 && ip->i_d.di_nextents == 0) {\n\t\tif (!(iattr->ia_valid & (ATTR_CTIME|ATTR_MTIME)))\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * Use the regular setattr path to update the timestamps.\n\t\t */\n\t\tiattr->ia_valid &= ~ATTR_SIZE;\n\t\treturn xfs_setattr_nonsize(ip, iattr, 0);\n\t}\n\n\t/*\n\t * Make sure that the dquots are attached to the inode.\n\t */\n\terror = xfs_qm_dqattach(ip, 0);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * File data changes must be complete before we start the transaction to\n\t * modify the inode.  This needs to be done before joining the inode to\n\t * the transaction because the inode cannot be unlocked once it is a\n\t * part of the transaction.\n\t *\n\t * Start with zeroing any data block beyond EOF that we may expose on\n\t * file extension.\n\t */\n\tif (newsize > oldsize) {\n\t\terror = xfs_zero_eof(ip, newsize, oldsize, &did_zeroing);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * We are going to log the inode size change in this transaction so\n\t * any previous writes that are beyond the on disk EOF and the new\n\t * EOF that have not been written out need to be written here.  If we\n\t * do not write the data out, we expose ourselves to the null files\n\t * problem. Note that this includes any block zeroing we did above;\n\t * otherwise those blocks may not be zeroed after a crash.\n\t */\n\tif (newsize > ip->i_d.di_size &&\n\t    (oldsize != ip->i_d.di_size || did_zeroing)) {\n\t\terror = filemap_write_and_wait_range(VFS_I(ip)->i_mapping,\n\t\t\t\t\t\t      ip->i_d.di_size, newsize);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* Now wait for all direct I/O to complete. */\n\tinode_dio_wait(inode);\n\n\t/*\n\t * Do all the page cache truncate work outside the transaction context\n\t * as the \"lock\" order is page lock->log space reservation.  i.e.\n\t * locking pages inside the transaction can ABBA deadlock with\n\t * writeback. We have to do the VFS inode size update before we truncate\n\t * the pagecache, however, to avoid racing with page faults beyond the\n\t * new EOF they are not serialised against truncate operations except by\n\t * page locks and size updates.\n\t *\n\t * Hence we are in a situation where a truncate can fail with ENOMEM\n\t * from xfs_trans_reserve(), but having already truncated the in-memory\n\t * version of the file (i.e. made user visible changes). There's not\n\t * much we can do about this, except to hope that the caller sees ENOMEM\n\t * and retries the truncate operation.\n\t */\n\terror = block_truncate_page(inode->i_mapping, newsize, xfs_get_blocks);\n\tif (error)\n\t\treturn error;\n\ttruncate_setsize(inode, newsize);\n\n\t/*\n\t * The \"we can't serialise against page faults\" pain gets worse.\n\t *\n\t * If the file is mapped then we have to clean the page at the old EOF\n\t * when extending the file. Extending the file can expose changes the\n\t * underlying page mapping (e.g. from beyond EOF to a hole or\n\t * unwritten), and so on the next attempt to write to that page we need\n\t * to remap it for write. i.e. we need .page_mkwrite() to be called.\n\t * Hence we need to clean the page to clean the pte and so a new write\n\t * fault will be triggered appropriately.\n\t *\n\t * If we do it before we change the inode size, then we can race with a\n\t * page fault that maps the page with exactly the same problem. If we do\n\t * it after we change the file size, then a new page fault can come in\n\t * and allocate space before we've run the rest of the truncate\n\t * transaction. That's kinda grotesque, but it's better than have data\n\t * over a hole, and so that's the lesser evil that has been chosen here.\n\t *\n\t * The real solution, however, is to have some mechanism for locking out\n\t * page faults while a truncate is in progress.\n\t */\n\tif (newsize > oldsize && mapping_mapped(VFS_I(ip)->i_mapping)) {\n\t\terror = filemap_write_and_wait_range(\n\t\t\t\tVFS_I(ip)->i_mapping,\n\t\t\t\tround_down(oldsize, PAGE_CACHE_SIZE),\n\t\t\t\tround_up(oldsize, PAGE_CACHE_SIZE) - 1);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_SETATTR_SIZE);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\n\tif (error)\n\t\tgoto out_trans_cancel;\n\n\tcommit_flags = XFS_TRANS_RELEASE_LOG_RES;\n\tlock_flags |= XFS_ILOCK_EXCL;\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, 0);\n\n\t/*\n\t * Only change the c/mtime if we are changing the size or we are\n\t * explicitly asked to change it.  This handles the semantic difference\n\t * between truncate() and ftruncate() as implemented in the VFS.\n\t *\n\t * The regular truncate() case without ATTR_CTIME and ATTR_MTIME is a\n\t * special case where we need to update the times despite not having\n\t * these flags set.  For all other operations the VFS set these flags\n\t * explicitly if it wants a timestamp update.\n\t */\n\tif (newsize != oldsize &&\n\t    !(iattr->ia_valid & (ATTR_CTIME | ATTR_MTIME))) {\n\t\tiattr->ia_ctime = iattr->ia_mtime =\n\t\t\tcurrent_fs_time(inode->i_sb);\n\t\tiattr->ia_valid |= ATTR_CTIME | ATTR_MTIME;\n\t}\n\n\t/*\n\t * The first thing we do is set the size to new_size permanently on\n\t * disk.  This way we don't have to worry about anyone ever being able\n\t * to look at the data being freed even in the face of a crash.\n\t * What we're getting around here is the case where we free a block, it\n\t * is allocated to another file, it is written to, and then we crash.\n\t * If the new data gets written to the file but the log buffers\n\t * containing the free and reallocation don't, then we'd end up with\n\t * garbage in the blocks being freed.  As long as we make the new size\n\t * permanent before actually freeing any blocks it doesn't matter if\n\t * they get written to.\n\t */\n\tip->i_d.di_size = newsize;\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tif (newsize <= oldsize) {\n\t\terror = xfs_itruncate_extents(&tp, ip, XFS_DATA_FORK, newsize);\n\t\tif (error)\n\t\t\tgoto out_trans_abort;\n\n\t\t/*\n\t\t * Truncated \"down\", so we're removing references to old data\n\t\t * here - if we delay flushing for a long time, we expose\n\t\t * ourselves unduly to the notorious NULL files problem.  So,\n\t\t * we mark this inode and flush it when the file is closed,\n\t\t * and do not wait the usual (long) time for writeout.\n\t\t */\n\t\txfs_iflags_set(ip, XFS_ITRUNCATED);\n\n\t\t/* A truncate down always removes post-EOF blocks. */\n\t\txfs_inode_clear_eofblocks_tag(ip);\n\t}\n\n\tif (iattr->ia_valid & ATTR_MODE)\n\t\txfs_setattr_mode(ip, iattr);\n\tif (iattr->ia_valid & (ATTR_ATIME|ATTR_CTIME|ATTR_MTIME))\n\t\txfs_setattr_time(ip, iattr);\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tXFS_STATS_INC(xs_ig_attrchg);\n\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(tp);\n\n\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\nout_unlock:\n\tif (lock_flags)\n\t\txfs_iunlock(ip, lock_flags);\n\treturn error;\n\nout_trans_abort:\n\tcommit_flags |= XFS_TRANS_ABORT;\nout_trans_cancel:\n\txfs_trans_cancel(tp, commit_flags);\n\tgoto out_unlock;\n}"
  },
  {
    "function_name": "xfs_setattr_nonsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
    "lines": "535-737",
    "snippet": "int\nxfs_setattr_nonsize(\n\tstruct xfs_inode\t*ip,\n\tstruct iattr\t\t*iattr,\n\tint\t\t\tflags)\n{\n\txfs_mount_t\t\t*mp = ip->i_mount;\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tint\t\t\tmask = iattr->ia_valid;\n\txfs_trans_t\t\t*tp;\n\tint\t\t\terror;\n\tkuid_t\t\t\tuid = GLOBAL_ROOT_UID, iuid = GLOBAL_ROOT_UID;\n\tkgid_t\t\t\tgid = GLOBAL_ROOT_GID, igid = GLOBAL_ROOT_GID;\n\tstruct xfs_dquot\t*udqp = NULL, *gdqp = NULL;\n\tstruct xfs_dquot\t*olddquot1 = NULL, *olddquot2 = NULL;\n\n\ttrace_xfs_setattr(ip);\n\n\t/* If acls are being inherited, we already have this checked */\n\tif (!(flags & XFS_ATTR_NOACL)) {\n\t\tif (mp->m_flags & XFS_MOUNT_RDONLY)\n\t\t\treturn -EROFS;\n\n\t\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\t\treturn -EIO;\n\n\t\terror = inode_change_ok(inode, iattr);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tASSERT((mask & ATTR_SIZE) == 0);\n\n\t/*\n\t * If disk quotas is on, we make sure that the dquots do exist on disk,\n\t * before we start any other transactions. Trying to do this later\n\t * is messy. We don't care to take a readlock to look at the ids\n\t * in inode here, because we can't hold it across the trans_reserve.\n\t * If the IDs do change before we take the ilock, we're covered\n\t * because the i_*dquot fields will get updated anyway.\n\t */\n\tif (XFS_IS_QUOTA_ON(mp) && (mask & (ATTR_UID|ATTR_GID))) {\n\t\tuint\tqflags = 0;\n\n\t\tif ((mask & ATTR_UID) && XFS_IS_UQUOTA_ON(mp)) {\n\t\t\tuid = iattr->ia_uid;\n\t\t\tqflags |= XFS_QMOPT_UQUOTA;\n\t\t} else {\n\t\t\tuid = inode->i_uid;\n\t\t}\n\t\tif ((mask & ATTR_GID) && XFS_IS_GQUOTA_ON(mp)) {\n\t\t\tgid = iattr->ia_gid;\n\t\t\tqflags |= XFS_QMOPT_GQUOTA;\n\t\t}  else {\n\t\t\tgid = inode->i_gid;\n\t\t}\n\n\t\t/*\n\t\t * We take a reference when we initialize udqp and gdqp,\n\t\t * so it is important that we never blindly double trip on\n\t\t * the same variable. See xfs_create() for an example.\n\t\t */\n\t\tASSERT(udqp == NULL);\n\t\tASSERT(gdqp == NULL);\n\t\terror = xfs_qm_vop_dqalloc(ip, xfs_kuid_to_uid(uid),\n\t\t\t\t\t   xfs_kgid_to_gid(gid),\n\t\t\t\t\t   xfs_get_projid(ip),\n\t\t\t\t\t   qflags, &udqp, &gdqp, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_SETATTR_NOT_SIZE);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_ichange, 0, 0);\n\tif (error)\n\t\tgoto out_dqrele;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * Change file ownership.  Must be the owner or privileged.\n\t */\n\tif (mask & (ATTR_UID|ATTR_GID)) {\n\t\t/*\n\t\t * These IDs could have changed since we last looked at them.\n\t\t * But, we're assured that if the ownership did change\n\t\t * while we didn't have the inode locked, inode's dquot(s)\n\t\t * would have changed also.\n\t\t */\n\t\tiuid = inode->i_uid;\n\t\tigid = inode->i_gid;\n\t\tgid = (mask & ATTR_GID) ? iattr->ia_gid : igid;\n\t\tuid = (mask & ATTR_UID) ? iattr->ia_uid : iuid;\n\n\t\t/*\n\t\t * Do a quota reservation only if uid/gid is actually\n\t\t * going to change.\n\t\t */\n\t\tif (XFS_IS_QUOTA_RUNNING(mp) &&\n\t\t    ((XFS_IS_UQUOTA_ON(mp) && !uid_eq(iuid, uid)) ||\n\t\t     (XFS_IS_GQUOTA_ON(mp) && !gid_eq(igid, gid)))) {\n\t\t\tASSERT(tp);\n\t\t\terror = xfs_qm_vop_chown_reserve(tp, ip, udqp, gdqp,\n\t\t\t\t\t\tNULL, capable(CAP_FOWNER) ?\n\t\t\t\t\t\tXFS_QMOPT_FORCE_RES : 0);\n\t\t\tif (error)\t/* out of quota */\n\t\t\t\tgoto out_trans_cancel;\n\t\t}\n\t}\n\n\txfs_trans_ijoin(tp, ip, 0);\n\n\t/*\n\t * Change file ownership.  Must be the owner or privileged.\n\t */\n\tif (mask & (ATTR_UID|ATTR_GID)) {\n\t\t/*\n\t\t * CAP_FSETID overrides the following restrictions:\n\t\t *\n\t\t * The set-user-ID and set-group-ID bits of a file will be\n\t\t * cleared upon successful return from chown()\n\t\t */\n\t\tif ((ip->i_d.di_mode & (S_ISUID|S_ISGID)) &&\n\t\t    !capable(CAP_FSETID))\n\t\t\tip->i_d.di_mode &= ~(S_ISUID|S_ISGID);\n\n\t\t/*\n\t\t * Change the ownerships and register quota modifications\n\t\t * in the transaction.\n\t\t */\n\t\tif (!uid_eq(iuid, uid)) {\n\t\t\tif (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_UQUOTA_ON(mp)) {\n\t\t\t\tASSERT(mask & ATTR_UID);\n\t\t\t\tASSERT(udqp);\n\t\t\t\tolddquot1 = xfs_qm_vop_chown(tp, ip,\n\t\t\t\t\t\t\t&ip->i_udquot, udqp);\n\t\t\t}\n\t\t\tip->i_d.di_uid = xfs_kuid_to_uid(uid);\n\t\t\tinode->i_uid = uid;\n\t\t}\n\t\tif (!gid_eq(igid, gid)) {\n\t\t\tif (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_GQUOTA_ON(mp)) {\n\t\t\t\tASSERT(xfs_sb_version_has_pquotino(&mp->m_sb) ||\n\t\t\t\t       !XFS_IS_PQUOTA_ON(mp));\n\t\t\t\tASSERT(mask & ATTR_GID);\n\t\t\t\tASSERT(gdqp);\n\t\t\t\tolddquot2 = xfs_qm_vop_chown(tp, ip,\n\t\t\t\t\t\t\t&ip->i_gdquot, gdqp);\n\t\t\t}\n\t\t\tip->i_d.di_gid = xfs_kgid_to_gid(gid);\n\t\t\tinode->i_gid = gid;\n\t\t}\n\t}\n\n\tif (mask & ATTR_MODE)\n\t\txfs_setattr_mode(ip, iattr);\n\tif (mask & (ATTR_ATIME|ATTR_CTIME|ATTR_MTIME))\n\t\txfs_setattr_time(ip, iattr);\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tXFS_STATS_INC(xs_ig_attrchg);\n\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(tp);\n\terror = xfs_trans_commit(tp, 0);\n\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * Release any dquot(s) the inode had kept before chown.\n\t */\n\txfs_qm_dqrele(olddquot1);\n\txfs_qm_dqrele(olddquot2);\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * XXX(hch): Updating the ACL entries is not atomic vs the i_mode\n\t * \t     update.  We could avoid this with linked transactions\n\t * \t     and passing down the transaction pointer all the way\n\t *\t     to attr_set.  No previous user of the generic\n\t * \t     Posix ACL code seems to care about this issue either.\n\t */\n\tif ((mask & ATTR_MODE) && !(flags & XFS_ATTR_NOACL)) {\n\t\terror = posix_acl_chmod(inode, inode->i_mode);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n\nout_trans_cancel:\n\txfs_trans_cancel(tp, 0);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\nout_dqrele:\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\treturn error;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/security.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/namei.h>",
      "#include <linux/xattr.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_acl.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_qm_dqrele",
          "args": [
            "gdqp"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqrele",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
          "lines": "862-879",
          "snippet": "void\nxfs_qm_dqrele(\n\txfs_dquot_t\t*dqp)\n{\n\tif (!dqp)\n\t\treturn;\n\n\ttrace_xfs_dqrele(dqp);\n\n\txfs_dqlock(dqp);\n\t/*\n\t * We don't care to flush it if the dquot is dirty here.\n\t * That will create stutters that we want to avoid.\n\t * Instead we do a delayed write when we try to reclaim\n\t * a dirty dquot. Also xfs_sync will take part of the burden...\n\t */\n\txfs_qm_dqput(dqp);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_qm_dqrele(\n\txfs_dquot_t\t*dqp)\n{\n\tif (!dqp)\n\t\treturn;\n\n\ttrace_xfs_dqrele(dqp);\n\n\txfs_dqlock(dqp);\n\t/*\n\t * We don't care to flush it if the dquot is dirty here.\n\t * That will create stutters that we want to avoid.\n\t * Instead we do a delayed write when we try to reclaim\n\t * a dirty dquot. Also xfs_sync will take part of the burden...\n\t */\n\txfs_qm_dqput(dqp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_cancel",
          "args": [
            "tp",
            "0"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "937-986",
          "snippet": "void\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_chmod",
          "args": [
            "inode",
            "inode->i_mode"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_chmod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "518-542",
          "snippet": "int\nposix_acl_chmod(struct inode *inode, umode_t mode)\n{\n\tstruct posix_acl *acl;\n\tint ret = 0;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn 0;\n\tif (!inode->i_op->set_acl)\n\t\treturn -EOPNOTSUPP;\n\n\tacl = get_acl(inode, ACL_TYPE_ACCESS);\n\tif (IS_ERR_OR_NULL(acl)) {\n\t\tif (acl == ERR_PTR(-EOPNOTSUPP))\n\t\t\treturn 0;\n\t\treturn PTR_ERR(acl);\n\t}\n\n\tret = __posix_acl_chmod(&acl, GFP_KERNEL, mode);\n\tif (ret)\n\t\treturn ret;\n\tret = inode->i_op->set_acl(inode, acl, ACL_TYPE_ACCESS);\n\tposix_acl_release(acl);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nposix_acl_chmod(struct inode *inode, umode_t mode)\n{\n\tstruct posix_acl *acl;\n\tint ret = 0;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn 0;\n\tif (!inode->i_op->set_acl)\n\t\treturn -EOPNOTSUPP;\n\n\tacl = get_acl(inode, ACL_TYPE_ACCESS);\n\tif (IS_ERR_OR_NULL(acl)) {\n\t\tif (acl == ERR_PTR(-EOPNOTSUPP))\n\t\t\treturn 0;\n\t\treturn PTR_ERR(acl);\n\t}\n\n\tret = __posix_acl_chmod(&acl, GFP_KERNEL, mode);\n\tif (ret)\n\t\treturn ret;\n\tret = inode->i_op->set_acl(inode, acl, ACL_TYPE_ACCESS);\n\tposix_acl_release(acl);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_commit",
          "args": [
            "tp",
            "0"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "845-927",
          "snippet": "int\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_set_sync",
          "args": [
            "tp"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_ig_attrchg"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "tp",
            "ip",
            "XFS_ILOG_CORE"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_setattr_time",
          "args": [
            "ip",
            "iattr"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_setattr_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
          "lines": "509-533",
          "snippet": "void\nxfs_setattr_time(\n\tstruct xfs_inode\t*ip,\n\tstruct iattr\t\t*iattr)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (iattr->ia_valid & ATTR_ATIME) {\n\t\tinode->i_atime = iattr->ia_atime;\n\t\tip->i_d.di_atime.t_sec = iattr->ia_atime.tv_sec;\n\t\tip->i_d.di_atime.t_nsec = iattr->ia_atime.tv_nsec;\n\t}\n\tif (iattr->ia_valid & ATTR_CTIME) {\n\t\tinode->i_ctime = iattr->ia_ctime;\n\t\tip->i_d.di_ctime.t_sec = iattr->ia_ctime.tv_sec;\n\t\tip->i_d.di_ctime.t_nsec = iattr->ia_ctime.tv_nsec;\n\t}\n\tif (iattr->ia_valid & ATTR_MTIME) {\n\t\tinode->i_mtime = iattr->ia_mtime;\n\t\tip->i_d.di_mtime.t_sec = iattr->ia_mtime.tv_sec;\n\t\tip->i_d.di_mtime.t_nsec = iattr->ia_mtime.tv_nsec;\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/security.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/namei.h>",
            "#include <linux/xattr.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_acl.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_setattr_time(\n\tstruct xfs_inode\t*ip,\n\tstruct iattr\t\t*iattr)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (iattr->ia_valid & ATTR_ATIME) {\n\t\tinode->i_atime = iattr->ia_atime;\n\t\tip->i_d.di_atime.t_sec = iattr->ia_atime.tv_sec;\n\t\tip->i_d.di_atime.t_nsec = iattr->ia_atime.tv_nsec;\n\t}\n\tif (iattr->ia_valid & ATTR_CTIME) {\n\t\tinode->i_ctime = iattr->ia_ctime;\n\t\tip->i_d.di_ctime.t_sec = iattr->ia_ctime.tv_sec;\n\t\tip->i_d.di_ctime.t_nsec = iattr->ia_ctime.tv_nsec;\n\t}\n\tif (iattr->ia_valid & ATTR_MTIME) {\n\t\tinode->i_mtime = iattr->ia_mtime;\n\t\tip->i_d.di_mtime.t_sec = iattr->ia_mtime.tv_sec;\n\t\tip->i_d.di_mtime.t_nsec = iattr->ia_mtime.tv_nsec;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_setattr_mode",
          "args": [
            "ip",
            "iattr"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_setattr_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
          "lines": "492-507",
          "snippet": "static void\nxfs_setattr_mode(\n\tstruct xfs_inode\t*ip,\n\tstruct iattr\t\t*iattr)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tumode_t\t\t\tmode = iattr->ia_mode;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tip->i_d.di_mode &= S_IFMT;\n\tip->i_d.di_mode |= mode & ~S_IFMT;\n\n\tinode->i_mode &= S_IFMT;\n\tinode->i_mode |= mode & ~S_IFMT;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/security.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/namei.h>",
            "#include <linux/xattr.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_acl.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nstatic void\nxfs_setattr_mode(\n\tstruct xfs_inode\t*ip,\n\tstruct iattr\t\t*iattr)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tumode_t\t\t\tmode = iattr->ia_mode;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tip->i_d.di_mode &= S_IFMT;\n\tip->i_d.di_mode |= mode & ~S_IFMT;\n\n\tinode->i_mode &= S_IFMT;\n\tinode->i_mode |= mode & ~S_IFMT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_kgid_to_gid",
          "args": [
            "gid"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_kgid_to_gid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "213-216",
          "snippet": "static inline __uint32_t xfs_kgid_to_gid(kgid_t gid)\n{\n\treturn from_kgid(&init_user_ns, gid);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline __uint32_t xfs_kgid_to_gid(kgid_t gid)\n{\n\treturn from_kgid(&init_user_ns, gid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_qm_vop_chown",
          "args": [
            "tp",
            "ip",
            "&ip->i_gdquot",
            "gdqp"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_vop_chown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
          "lines": "1738-1772",
          "snippet": "xfs_dquot_t *\nxfs_qm_vop_chown(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\txfs_dquot_t\t**IO_olddq,\n\txfs_dquot_t\t*newdq)\n{\n\txfs_dquot_t\t*prevdq;\n\tuint\t\tbfield = XFS_IS_REALTIME_INODE(ip) ?\n\t\t\t\t XFS_TRANS_DQ_RTBCOUNT : XFS_TRANS_DQ_BCOUNT;\n\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(XFS_IS_QUOTA_RUNNING(ip->i_mount));\n\n\t/* old dquot */\n\tprevdq = *IO_olddq;\n\tASSERT(prevdq);\n\tASSERT(prevdq != newdq);\n\n\txfs_trans_mod_dquot(tp, prevdq, bfield, -(ip->i_d.di_nblocks));\n\txfs_trans_mod_dquot(tp, prevdq, XFS_TRANS_DQ_ICOUNT, -1);\n\n\t/* the sparkling new dquot */\n\txfs_trans_mod_dquot(tp, newdq, bfield, ip->i_d.di_nblocks);\n\txfs_trans_mod_dquot(tp, newdq, XFS_TRANS_DQ_ICOUNT, 1);\n\n\t/*\n\t * Take an extra reference, because the inode is going to keep\n\t * this dquot pointer even after the trans_commit.\n\t */\n\t*IO_olddq = xfs_qm_dqhold(newdq);\n\n\treturn prevdq;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_dquot_t *\nxfs_qm_vop_chown(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\txfs_dquot_t\t**IO_olddq,\n\txfs_dquot_t\t*newdq)\n{\n\txfs_dquot_t\t*prevdq;\n\tuint\t\tbfield = XFS_IS_REALTIME_INODE(ip) ?\n\t\t\t\t XFS_TRANS_DQ_RTBCOUNT : XFS_TRANS_DQ_BCOUNT;\n\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(XFS_IS_QUOTA_RUNNING(ip->i_mount));\n\n\t/* old dquot */\n\tprevdq = *IO_olddq;\n\tASSERT(prevdq);\n\tASSERT(prevdq != newdq);\n\n\txfs_trans_mod_dquot(tp, prevdq, bfield, -(ip->i_d.di_nblocks));\n\txfs_trans_mod_dquot(tp, prevdq, XFS_TRANS_DQ_ICOUNT, -1);\n\n\t/* the sparkling new dquot */\n\txfs_trans_mod_dquot(tp, newdq, bfield, ip->i_d.di_nblocks);\n\txfs_trans_mod_dquot(tp, newdq, XFS_TRANS_DQ_ICOUNT, 1);\n\n\t/*\n\t * Take an extra reference, because the inode is going to keep\n\t * this dquot pointer even after the trans_commit.\n\t */\n\t*IO_olddq = xfs_qm_dqhold(newdq);\n\n\treturn prevdq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "gdqp"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "mask & ATTR_GID"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_sb_version_has_pquotino(&mp->m_sb) ||\n\t\t\t\t       !XFS_IS_PQUOTA_ON(mp)"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_PQUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_has_pquotino",
          "args": [
            "&mp->m_sb"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_has_pquotino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "552-555",
          "snippet": "static inline int xfs_sb_version_has_pquotino(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_has_pquotino(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IS_GQUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_QUOTA_RUNNING",
          "args": [
            "mp"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "igid",
            "gid"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_kuid_to_uid",
          "args": [
            "uid"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_kuid_to_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "203-206",
          "snippet": "static inline __uint32_t xfs_kuid_to_uid(kuid_t uid)\n{\n\treturn from_kuid(&init_user_ns, uid);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline __uint32_t xfs_kuid_to_uid(kuid_t uid)\n{\n\treturn from_kuid(&init_user_ns, uid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "udqp"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "mask & ATTR_UID"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_UQUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_QUOTA_RUNNING",
          "args": [
            "mp"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "iuid",
            "uid"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_FSETID"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ijoin",
          "args": [
            "tp",
            "ip",
            "0"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ijoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "37-57",
          "snippet": "void\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_qm_vop_chown_reserve",
          "args": [
            "tp",
            "ip",
            "udqp",
            "gdqp",
            "NULL",
            "capable(CAP_FOWNER) ?\n\t\t\t\t\t\tXFS_QMOPT_FORCE_RES : 0"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_vop_chown_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
          "lines": "1777-1867",
          "snippet": "int\nxfs_qm_vop_chown_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_dquot\t*udqp,\n\tstruct xfs_dquot\t*gdqp,\n\tstruct xfs_dquot\t*pdqp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tuint\t\t\tdelblks, blkflags, prjflags = 0;\n\tstruct xfs_dquot\t*udq_unres = NULL;\n\tstruct xfs_dquot\t*gdq_unres = NULL;\n\tstruct xfs_dquot\t*pdq_unres = NULL;\n\tstruct xfs_dquot\t*udq_delblks = NULL;\n\tstruct xfs_dquot\t*gdq_delblks = NULL;\n\tstruct xfs_dquot\t*pdq_delblks = NULL;\n\tint\t\t\terror;\n\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL|XFS_ILOCK_SHARED));\n\tASSERT(XFS_IS_QUOTA_RUNNING(mp));\n\n\tdelblks = ip->i_delayed_blks;\n\tblkflags = XFS_IS_REALTIME_INODE(ip) ?\n\t\t\tXFS_QMOPT_RES_RTBLKS : XFS_QMOPT_RES_REGBLKS;\n\n\tif (XFS_IS_UQUOTA_ON(mp) && udqp &&\n\t    ip->i_d.di_uid != be32_to_cpu(udqp->q_core.d_id)) {\n\t\tudq_delblks = udqp;\n\t\t/*\n\t\t * If there are delayed allocation blocks, then we have to\n\t\t * unreserve those from the old dquot, and add them to the\n\t\t * new dquot.\n\t\t */\n\t\tif (delblks) {\n\t\t\tASSERT(ip->i_udquot);\n\t\t\tudq_unres = ip->i_udquot;\n\t\t}\n\t}\n\tif (XFS_IS_GQUOTA_ON(ip->i_mount) && gdqp &&\n\t    ip->i_d.di_gid != be32_to_cpu(gdqp->q_core.d_id)) {\n\t\tgdq_delblks = gdqp;\n\t\tif (delblks) {\n\t\t\tASSERT(ip->i_gdquot);\n\t\t\tgdq_unres = ip->i_gdquot;\n\t\t}\n\t}\n\n\tif (XFS_IS_PQUOTA_ON(ip->i_mount) && pdqp &&\n\t    xfs_get_projid(ip) != be32_to_cpu(pdqp->q_core.d_id)) {\n\t\tprjflags = XFS_QMOPT_ENOSPC;\n\t\tpdq_delblks = pdqp;\n\t\tif (delblks) {\n\t\t\tASSERT(ip->i_pdquot);\n\t\t\tpdq_unres = ip->i_pdquot;\n\t\t}\n\t}\n\n\terror = xfs_trans_reserve_quota_bydquots(tp, ip->i_mount,\n\t\t\t\tudq_delblks, gdq_delblks, pdq_delblks,\n\t\t\t\tip->i_d.di_nblocks, 1,\n\t\t\t\tflags | blkflags | prjflags);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Do the delayed blks reservations/unreservations now. Since, these\n\t * are done without the help of a transaction, if a reservation fails\n\t * its previous reservations won't be automatically undone by trans\n\t * code. So, we have to do it manually here.\n\t */\n\tif (delblks) {\n\t\t/*\n\t\t * Do the reservations first. Unreservation can't fail.\n\t\t */\n\t\tASSERT(udq_delblks || gdq_delblks || pdq_delblks);\n\t\tASSERT(udq_unres || gdq_unres || pdq_unres);\n\t\terror = xfs_trans_reserve_quota_bydquots(NULL, ip->i_mount,\n\t\t\t    udq_delblks, gdq_delblks, pdq_delblks,\n\t\t\t    (xfs_qcnt_t)delblks, 0,\n\t\t\t    flags | blkflags | prjflags);\n\t\tif (error)\n\t\t\treturn error;\n\t\txfs_trans_reserve_quota_bydquots(NULL, ip->i_mount,\n\t\t\t\tudq_unres, gdq_unres, pdq_unres,\n\t\t\t\t-((xfs_qcnt_t)delblks), 0, blkflags);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_qm_vop_chown_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_dquot\t*udqp,\n\tstruct xfs_dquot\t*gdqp,\n\tstruct xfs_dquot\t*pdqp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tuint\t\t\tdelblks, blkflags, prjflags = 0;\n\tstruct xfs_dquot\t*udq_unres = NULL;\n\tstruct xfs_dquot\t*gdq_unres = NULL;\n\tstruct xfs_dquot\t*pdq_unres = NULL;\n\tstruct xfs_dquot\t*udq_delblks = NULL;\n\tstruct xfs_dquot\t*gdq_delblks = NULL;\n\tstruct xfs_dquot\t*pdq_delblks = NULL;\n\tint\t\t\terror;\n\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL|XFS_ILOCK_SHARED));\n\tASSERT(XFS_IS_QUOTA_RUNNING(mp));\n\n\tdelblks = ip->i_delayed_blks;\n\tblkflags = XFS_IS_REALTIME_INODE(ip) ?\n\t\t\tXFS_QMOPT_RES_RTBLKS : XFS_QMOPT_RES_REGBLKS;\n\n\tif (XFS_IS_UQUOTA_ON(mp) && udqp &&\n\t    ip->i_d.di_uid != be32_to_cpu(udqp->q_core.d_id)) {\n\t\tudq_delblks = udqp;\n\t\t/*\n\t\t * If there are delayed allocation blocks, then we have to\n\t\t * unreserve those from the old dquot, and add them to the\n\t\t * new dquot.\n\t\t */\n\t\tif (delblks) {\n\t\t\tASSERT(ip->i_udquot);\n\t\t\tudq_unres = ip->i_udquot;\n\t\t}\n\t}\n\tif (XFS_IS_GQUOTA_ON(ip->i_mount) && gdqp &&\n\t    ip->i_d.di_gid != be32_to_cpu(gdqp->q_core.d_id)) {\n\t\tgdq_delblks = gdqp;\n\t\tif (delblks) {\n\t\t\tASSERT(ip->i_gdquot);\n\t\t\tgdq_unres = ip->i_gdquot;\n\t\t}\n\t}\n\n\tif (XFS_IS_PQUOTA_ON(ip->i_mount) && pdqp &&\n\t    xfs_get_projid(ip) != be32_to_cpu(pdqp->q_core.d_id)) {\n\t\tprjflags = XFS_QMOPT_ENOSPC;\n\t\tpdq_delblks = pdqp;\n\t\tif (delblks) {\n\t\t\tASSERT(ip->i_pdquot);\n\t\t\tpdq_unres = ip->i_pdquot;\n\t\t}\n\t}\n\n\terror = xfs_trans_reserve_quota_bydquots(tp, ip->i_mount,\n\t\t\t\tudq_delblks, gdq_delblks, pdq_delblks,\n\t\t\t\tip->i_d.di_nblocks, 1,\n\t\t\t\tflags | blkflags | prjflags);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Do the delayed blks reservations/unreservations now. Since, these\n\t * are done without the help of a transaction, if a reservation fails\n\t * its previous reservations won't be automatically undone by trans\n\t * code. So, we have to do it manually here.\n\t */\n\tif (delblks) {\n\t\t/*\n\t\t * Do the reservations first. Unreservation can't fail.\n\t\t */\n\t\tASSERT(udq_delblks || gdq_delblks || pdq_delblks);\n\t\tASSERT(udq_unres || gdq_unres || pdq_unres);\n\t\terror = xfs_trans_reserve_quota_bydquots(NULL, ip->i_mount,\n\t\t\t    udq_delblks, gdq_delblks, pdq_delblks,\n\t\t\t    (xfs_qcnt_t)delblks, 0,\n\t\t\t    flags | blkflags | prjflags);\n\t\tif (error)\n\t\t\treturn error;\n\t\txfs_trans_reserve_quota_bydquots(NULL, ip->i_mount,\n\t\t\t\tudq_unres, gdq_unres, pdq_unres,\n\t\t\t\t-((xfs_qcnt_t)delblks), 0, blkflags);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "tp"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "igid",
            "gid"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_GQUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_UQUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_QUOTA_RUNNING",
          "args": [
            "mp"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve",
          "args": [
            "tp",
            "&M_RES(mp)->tr_ichange",
            "0",
            "0"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "168-279",
          "snippet": "int\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_alloc",
          "args": [
            "mp",
            "XFS_TRANS_SETATTR_NOT_SIZE"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "57-68",
          "snippet": "xfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_qm_vop_dqalloc",
          "args": [
            "ip",
            "xfs_kuid_to_uid(uid)",
            "xfs_kgid_to_gid(gid)",
            "xfs_get_projid(ip)",
            "qflags",
            "&udqp",
            "&gdqp",
            "NULL"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_vop_dqalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_quota.h",
          "lines": "105-114",
          "snippet": "static inline int\nxfs_qm_vop_dqalloc(struct xfs_inode *ip, xfs_dqid_t uid, xfs_dqid_t gid,\n\t\tprid_t prid, uint flags, struct xfs_dquot **udqp,\n\t\tstruct xfs_dquot **gdqp, struct xfs_dquot **pdqp)\n{\n\t*udqp = NULL;\n\t*gdqp = NULL;\n\t*pdqp = NULL;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_quota_defs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_quota_defs.h\"\n\nstatic inline int\nxfs_qm_vop_dqalloc(struct xfs_inode *ip, xfs_dqid_t uid, xfs_dqid_t gid,\n\t\tprid_t prid, uint flags, struct xfs_dquot **udqp,\n\t\tstruct xfs_dquot **gdqp, struct xfs_dquot **pdqp)\n{\n\t*udqp = NULL;\n\t*gdqp = NULL;\n\t*pdqp = NULL;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_get_projid",
          "args": [
            "ip"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_get_projid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "181-185",
          "snippet": "static inline prid_t\nxfs_get_projid(struct xfs_inode *ip)\n{\n\treturn (prid_t)ip->i_d.di_projid_hi << 16 | ip->i_d.di_projid_lo;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline prid_t\nxfs_get_projid(struct xfs_inode *ip)\n{\n\treturn (prid_t)ip->i_d.di_projid_hi << 16 | ip->i_d.di_projid_lo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "gdqp == NULL"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "udqp == NULL"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_GQUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_UQUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_QUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(mask & ATTR_SIZE) == 0"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_change_ok",
          "args": [
            "inode",
            "iattr"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "inode_change_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "31-81",
          "snippet": "int inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_setattr",
          "args": [
            "ip"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "ip"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "78-81",
          "snippet": "static inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nint\nxfs_setattr_nonsize(\n\tstruct xfs_inode\t*ip,\n\tstruct iattr\t\t*iattr,\n\tint\t\t\tflags)\n{\n\txfs_mount_t\t\t*mp = ip->i_mount;\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tint\t\t\tmask = iattr->ia_valid;\n\txfs_trans_t\t\t*tp;\n\tint\t\t\terror;\n\tkuid_t\t\t\tuid = GLOBAL_ROOT_UID, iuid = GLOBAL_ROOT_UID;\n\tkgid_t\t\t\tgid = GLOBAL_ROOT_GID, igid = GLOBAL_ROOT_GID;\n\tstruct xfs_dquot\t*udqp = NULL, *gdqp = NULL;\n\tstruct xfs_dquot\t*olddquot1 = NULL, *olddquot2 = NULL;\n\n\ttrace_xfs_setattr(ip);\n\n\t/* If acls are being inherited, we already have this checked */\n\tif (!(flags & XFS_ATTR_NOACL)) {\n\t\tif (mp->m_flags & XFS_MOUNT_RDONLY)\n\t\t\treturn -EROFS;\n\n\t\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\t\treturn -EIO;\n\n\t\terror = inode_change_ok(inode, iattr);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tASSERT((mask & ATTR_SIZE) == 0);\n\n\t/*\n\t * If disk quotas is on, we make sure that the dquots do exist on disk,\n\t * before we start any other transactions. Trying to do this later\n\t * is messy. We don't care to take a readlock to look at the ids\n\t * in inode here, because we can't hold it across the trans_reserve.\n\t * If the IDs do change before we take the ilock, we're covered\n\t * because the i_*dquot fields will get updated anyway.\n\t */\n\tif (XFS_IS_QUOTA_ON(mp) && (mask & (ATTR_UID|ATTR_GID))) {\n\t\tuint\tqflags = 0;\n\n\t\tif ((mask & ATTR_UID) && XFS_IS_UQUOTA_ON(mp)) {\n\t\t\tuid = iattr->ia_uid;\n\t\t\tqflags |= XFS_QMOPT_UQUOTA;\n\t\t} else {\n\t\t\tuid = inode->i_uid;\n\t\t}\n\t\tif ((mask & ATTR_GID) && XFS_IS_GQUOTA_ON(mp)) {\n\t\t\tgid = iattr->ia_gid;\n\t\t\tqflags |= XFS_QMOPT_GQUOTA;\n\t\t}  else {\n\t\t\tgid = inode->i_gid;\n\t\t}\n\n\t\t/*\n\t\t * We take a reference when we initialize udqp and gdqp,\n\t\t * so it is important that we never blindly double trip on\n\t\t * the same variable. See xfs_create() for an example.\n\t\t */\n\t\tASSERT(udqp == NULL);\n\t\tASSERT(gdqp == NULL);\n\t\terror = xfs_qm_vop_dqalloc(ip, xfs_kuid_to_uid(uid),\n\t\t\t\t\t   xfs_kgid_to_gid(gid),\n\t\t\t\t\t   xfs_get_projid(ip),\n\t\t\t\t\t   qflags, &udqp, &gdqp, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_SETATTR_NOT_SIZE);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_ichange, 0, 0);\n\tif (error)\n\t\tgoto out_dqrele;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * Change file ownership.  Must be the owner or privileged.\n\t */\n\tif (mask & (ATTR_UID|ATTR_GID)) {\n\t\t/*\n\t\t * These IDs could have changed since we last looked at them.\n\t\t * But, we're assured that if the ownership did change\n\t\t * while we didn't have the inode locked, inode's dquot(s)\n\t\t * would have changed also.\n\t\t */\n\t\tiuid = inode->i_uid;\n\t\tigid = inode->i_gid;\n\t\tgid = (mask & ATTR_GID) ? iattr->ia_gid : igid;\n\t\tuid = (mask & ATTR_UID) ? iattr->ia_uid : iuid;\n\n\t\t/*\n\t\t * Do a quota reservation only if uid/gid is actually\n\t\t * going to change.\n\t\t */\n\t\tif (XFS_IS_QUOTA_RUNNING(mp) &&\n\t\t    ((XFS_IS_UQUOTA_ON(mp) && !uid_eq(iuid, uid)) ||\n\t\t     (XFS_IS_GQUOTA_ON(mp) && !gid_eq(igid, gid)))) {\n\t\t\tASSERT(tp);\n\t\t\terror = xfs_qm_vop_chown_reserve(tp, ip, udqp, gdqp,\n\t\t\t\t\t\tNULL, capable(CAP_FOWNER) ?\n\t\t\t\t\t\tXFS_QMOPT_FORCE_RES : 0);\n\t\t\tif (error)\t/* out of quota */\n\t\t\t\tgoto out_trans_cancel;\n\t\t}\n\t}\n\n\txfs_trans_ijoin(tp, ip, 0);\n\n\t/*\n\t * Change file ownership.  Must be the owner or privileged.\n\t */\n\tif (mask & (ATTR_UID|ATTR_GID)) {\n\t\t/*\n\t\t * CAP_FSETID overrides the following restrictions:\n\t\t *\n\t\t * The set-user-ID and set-group-ID bits of a file will be\n\t\t * cleared upon successful return from chown()\n\t\t */\n\t\tif ((ip->i_d.di_mode & (S_ISUID|S_ISGID)) &&\n\t\t    !capable(CAP_FSETID))\n\t\t\tip->i_d.di_mode &= ~(S_ISUID|S_ISGID);\n\n\t\t/*\n\t\t * Change the ownerships and register quota modifications\n\t\t * in the transaction.\n\t\t */\n\t\tif (!uid_eq(iuid, uid)) {\n\t\t\tif (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_UQUOTA_ON(mp)) {\n\t\t\t\tASSERT(mask & ATTR_UID);\n\t\t\t\tASSERT(udqp);\n\t\t\t\tolddquot1 = xfs_qm_vop_chown(tp, ip,\n\t\t\t\t\t\t\t&ip->i_udquot, udqp);\n\t\t\t}\n\t\t\tip->i_d.di_uid = xfs_kuid_to_uid(uid);\n\t\t\tinode->i_uid = uid;\n\t\t}\n\t\tif (!gid_eq(igid, gid)) {\n\t\t\tif (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_GQUOTA_ON(mp)) {\n\t\t\t\tASSERT(xfs_sb_version_has_pquotino(&mp->m_sb) ||\n\t\t\t\t       !XFS_IS_PQUOTA_ON(mp));\n\t\t\t\tASSERT(mask & ATTR_GID);\n\t\t\t\tASSERT(gdqp);\n\t\t\t\tolddquot2 = xfs_qm_vop_chown(tp, ip,\n\t\t\t\t\t\t\t&ip->i_gdquot, gdqp);\n\t\t\t}\n\t\t\tip->i_d.di_gid = xfs_kgid_to_gid(gid);\n\t\t\tinode->i_gid = gid;\n\t\t}\n\t}\n\n\tif (mask & ATTR_MODE)\n\t\txfs_setattr_mode(ip, iattr);\n\tif (mask & (ATTR_ATIME|ATTR_CTIME|ATTR_MTIME))\n\t\txfs_setattr_time(ip, iattr);\n\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tXFS_STATS_INC(xs_ig_attrchg);\n\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(tp);\n\terror = xfs_trans_commit(tp, 0);\n\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * Release any dquot(s) the inode had kept before chown.\n\t */\n\txfs_qm_dqrele(olddquot1);\n\txfs_qm_dqrele(olddquot2);\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * XXX(hch): Updating the ACL entries is not atomic vs the i_mode\n\t * \t     update.  We could avoid this with linked transactions\n\t * \t     and passing down the transaction pointer all the way\n\t *\t     to attr_set.  No previous user of the generic\n\t * \t     Posix ACL code seems to care about this issue either.\n\t */\n\tif ((mask & ATTR_MODE) && !(flags & XFS_ATTR_NOACL)) {\n\t\terror = posix_acl_chmod(inode, inode->i_mode);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n\nout_trans_cancel:\n\txfs_trans_cancel(tp, 0);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\nout_dqrele:\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_setattr_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
    "lines": "509-533",
    "snippet": "void\nxfs_setattr_time(\n\tstruct xfs_inode\t*ip,\n\tstruct iattr\t\t*iattr)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (iattr->ia_valid & ATTR_ATIME) {\n\t\tinode->i_atime = iattr->ia_atime;\n\t\tip->i_d.di_atime.t_sec = iattr->ia_atime.tv_sec;\n\t\tip->i_d.di_atime.t_nsec = iattr->ia_atime.tv_nsec;\n\t}\n\tif (iattr->ia_valid & ATTR_CTIME) {\n\t\tinode->i_ctime = iattr->ia_ctime;\n\t\tip->i_d.di_ctime.t_sec = iattr->ia_ctime.tv_sec;\n\t\tip->i_d.di_ctime.t_nsec = iattr->ia_ctime.tv_nsec;\n\t}\n\tif (iattr->ia_valid & ATTR_MTIME) {\n\t\tinode->i_mtime = iattr->ia_mtime;\n\t\tip->i_d.di_mtime.t_sec = iattr->ia_mtime.tv_sec;\n\t\tip->i_d.di_mtime.t_nsec = iattr->ia_mtime.tv_nsec;\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/security.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/namei.h>",
      "#include <linux/xattr.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_acl.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_isilocked(ip, XFS_ILOCK_EXCL)"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_isilocked",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_isilocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "286-305",
          "snippet": "int\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "ip"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "78-81",
          "snippet": "static inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_setattr_time(\n\tstruct xfs_inode\t*ip,\n\tstruct iattr\t\t*iattr)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (iattr->ia_valid & ATTR_ATIME) {\n\t\tinode->i_atime = iattr->ia_atime;\n\t\tip->i_d.di_atime.t_sec = iattr->ia_atime.tv_sec;\n\t\tip->i_d.di_atime.t_nsec = iattr->ia_atime.tv_nsec;\n\t}\n\tif (iattr->ia_valid & ATTR_CTIME) {\n\t\tinode->i_ctime = iattr->ia_ctime;\n\t\tip->i_d.di_ctime.t_sec = iattr->ia_ctime.tv_sec;\n\t\tip->i_d.di_ctime.t_nsec = iattr->ia_ctime.tv_nsec;\n\t}\n\tif (iattr->ia_valid & ATTR_MTIME) {\n\t\tinode->i_mtime = iattr->ia_mtime;\n\t\tip->i_d.di_mtime.t_sec = iattr->ia_mtime.tv_sec;\n\t\tip->i_d.di_mtime.t_nsec = iattr->ia_mtime.tv_nsec;\n\t}\n}"
  },
  {
    "function_name": "xfs_setattr_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
    "lines": "492-507",
    "snippet": "static void\nxfs_setattr_mode(\n\tstruct xfs_inode\t*ip,\n\tstruct iattr\t\t*iattr)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tumode_t\t\t\tmode = iattr->ia_mode;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tip->i_d.di_mode &= S_IFMT;\n\tip->i_d.di_mode |= mode & ~S_IFMT;\n\n\tinode->i_mode &= S_IFMT;\n\tinode->i_mode |= mode & ~S_IFMT;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/security.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/namei.h>",
      "#include <linux/xattr.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_acl.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_isilocked(ip, XFS_ILOCK_EXCL)"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_isilocked",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_isilocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "286-305",
          "snippet": "int\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "ip"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "78-81",
          "snippet": "static inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nstatic void\nxfs_setattr_mode(\n\tstruct xfs_inode\t*ip,\n\tstruct iattr\t\t*iattr)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tumode_t\t\t\tmode = iattr->ia_mode;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tip->i_d.di_mode &= S_IFMT;\n\tip->i_d.di_mode |= mode & ~S_IFMT;\n\n\tinode->i_mode &= S_IFMT;\n\tinode->i_mode |= mode & ~S_IFMT;\n}"
  },
  {
    "function_name": "xfs_vn_getattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
    "lines": "438-490",
    "snippet": "STATIC int\nxfs_vn_getattr(\n\tstruct vfsmount\t\t*mnt,\n\tstruct dentry\t\t*dentry,\n\tstruct kstat\t\t*stat)\n{\n\tstruct inode\t\t*inode = dentry->d_inode;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\ttrace_xfs_getattr(ip);\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tstat->size = XFS_ISIZE(ip);\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->mode = ip->i_d.di_mode;\n\tstat->nlink = ip->i_d.di_nlink;\n\tstat->uid = inode->i_uid;\n\tstat->gid = inode->i_gid;\n\tstat->ino = ip->i_ino;\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode->i_ctime;\n\tstat->blocks =\n\t\tXFS_FSB_TO_BB(mp, ip->i_d.di_nblocks + ip->i_delayed_blks);\n\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\t\tstat->blksize = BLKDEV_IOSIZE;\n\t\tstat->rdev = MKDEV(sysv_major(ip->i_df.if_u2.if_rdev) & 0x1ff,\n\t\t\t\t   sysv_minor(ip->i_df.if_u2.if_rdev));\n\t\tbreak;\n\tdefault:\n\t\tif (XFS_IS_REALTIME_INODE(ip)) {\n\t\t\t/*\n\t\t\t * If the file blocks are being allocated from a\n\t\t\t * realtime volume, then return the inode's realtime\n\t\t\t * extent size or the realtime volume's extent size.\n\t\t\t */\n\t\t\tstat->blksize =\n\t\t\t\txfs_get_extsz_hint(ip) << mp->m_sb.sb_blocklog;\n\t\t} else\n\t\t\tstat->blksize = xfs_preferred_iosize(mp);\n\t\tstat->rdev = 0;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/security.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/namei.h>",
      "#include <linux/xattr.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_acl.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_preferred_iosize",
          "args": [
            "mp"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_preferred_iosize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.h",
          "lines": "256-266",
          "snippet": "static inline unsigned long\nxfs_preferred_iosize(xfs_mount_t *mp)\n{\n\tif (mp->m_flags & XFS_MOUNT_COMPAT_IOSIZE)\n\t\treturn PAGE_CACHE_SIZE;\n\treturn (mp->m_swidth ?\n\t\t(mp->m_swidth << mp->m_sb.sb_blocklog) :\n\t\t((mp->m_flags & XFS_MOUNT_DFLT_IOSIZE) ?\n\t\t\t(1 << (int)MAX(mp->m_readio_log, mp->m_writeio_log)) :\n\t\t\tPAGE_CACHE_SIZE));\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_MOUNT_COMPAT_IOSIZE\t(1ULL << 22)\t/* don't report large preferred\n\t\t\t\t\t\t * I/O size in stat() */",
            "#define XFS_MOUNT_DFLT_IOSIZE\t(1ULL << 12)\t/* set default i/o size */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_MOUNT_COMPAT_IOSIZE\t(1ULL << 22)\t/* don't report large preferred\n\t\t\t\t\t\t * I/O size in stat() */\n#define XFS_MOUNT_DFLT_IOSIZE\t(1ULL << 12)\t/* set default i/o size */\n\nstatic inline unsigned long\nxfs_preferred_iosize(xfs_mount_t *mp)\n{\n\tif (mp->m_flags & XFS_MOUNT_COMPAT_IOSIZE)\n\t\treturn PAGE_CACHE_SIZE;\n\treturn (mp->m_swidth ?\n\t\t(mp->m_swidth << mp->m_sb.sb_blocklog) :\n\t\t((mp->m_flags & XFS_MOUNT_DFLT_IOSIZE) ?\n\t\t\t(1 << (int)MAX(mp->m_readio_log, mp->m_writeio_log)) :\n\t\t\tPAGE_CACHE_SIZE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_get_extsz_hint",
          "args": [
            "ip"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_get_extsz_hint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "67-76",
          "snippet": "xfs_extlen_t\nxfs_get_extsz_hint(\n\tstruct xfs_inode\t*ip)\n{\n\tif ((ip->i_d.di_flags & XFS_DIFLAG_EXTSIZE) && ip->i_d.di_extsize)\n\t\treturn ip->i_d.di_extsize;\n\tif (XFS_IS_REALTIME_INODE(ip))\n\t\treturn ip->i_mount->m_sb.sb_rextsize;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_extlen_t\nxfs_get_extsz_hint(\n\tstruct xfs_inode\t*ip)\n{\n\tif ((ip->i_d.di_flags & XFS_DIFLAG_EXTSIZE) && ip->i_d.di_extsize)\n\t\treturn ip->i_d.di_extsize;\n\tif (XFS_IS_REALTIME_INODE(ip))\n\t\treturn ip->i_mount->m_sb.sb_rextsize;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IS_REALTIME_INODE",
          "args": [
            "ip"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MKDEV",
          "args": [
            "sysv_major(ip->i_df.if_u2.if_rdev) & 0x1ff",
            "sysv_minor(ip->i_df.if_u2.if_rdev)"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysv_minor",
          "args": [
            "ip->i_df.if_u2.if_rdev"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysv_major",
          "args": [
            "ip->i_df.if_u2.if_rdev"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_BB",
          "args": [
            "mp",
            "ip->i_d.di_nblocks + ip->i_delayed_blks"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ISIZE",
          "args": [
            "ip"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_getattr",
          "args": [
            "ip"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_vn_getattr(\n\tstruct vfsmount\t\t*mnt,\n\tstruct dentry\t\t*dentry,\n\tstruct kstat\t\t*stat)\n{\n\tstruct inode\t\t*inode = dentry->d_inode;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\ttrace_xfs_getattr(ip);\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tstat->size = XFS_ISIZE(ip);\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->mode = ip->i_d.di_mode;\n\tstat->nlink = ip->i_d.di_nlink;\n\tstat->uid = inode->i_uid;\n\tstat->gid = inode->i_gid;\n\tstat->ino = ip->i_ino;\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode->i_ctime;\n\tstat->blocks =\n\t\tXFS_FSB_TO_BB(mp, ip->i_d.di_nblocks + ip->i_delayed_blks);\n\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\t\tstat->blksize = BLKDEV_IOSIZE;\n\t\tstat->rdev = MKDEV(sysv_major(ip->i_df.if_u2.if_rdev) & 0x1ff,\n\t\t\t\t   sysv_minor(ip->i_df.if_u2.if_rdev));\n\t\tbreak;\n\tdefault:\n\t\tif (XFS_IS_REALTIME_INODE(ip)) {\n\t\t\t/*\n\t\t\t * If the file blocks are being allocated from a\n\t\t\t * realtime volume, then return the inode's realtime\n\t\t\t * extent size or the realtime volume's extent size.\n\t\t\t */\n\t\t\tstat->blksize =\n\t\t\t\txfs_get_extsz_hint(ip) << mp->m_sb.sb_blocklog;\n\t\t} else\n\t\t\tstat->blksize = xfs_preferred_iosize(mp);\n\t\tstat->rdev = 0;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_vn_follow_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
    "lines": "412-436",
    "snippet": "STATIC void *\nxfs_vn_follow_link(\n\tstruct dentry\t\t*dentry,\n\tstruct nameidata\t*nd)\n{\n\tchar\t\t\t*link;\n\tint\t\t\terror = -ENOMEM;\n\n\tlink = kmalloc(MAXPATHLEN+1, GFP_KERNEL);\n\tif (!link)\n\t\tgoto out_err;\n\n\terror = xfs_readlink(XFS_I(dentry->d_inode), link);\n\tif (unlikely(error))\n\t\tgoto out_kfree;\n\n\tnd_set_link(nd, link);\n\treturn NULL;\n\n out_kfree:\n\tkfree(link);\n out_err:\n\tnd_set_link(nd, ERR_PTR(error));\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/security.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/namei.h>",
      "#include <linux/xattr.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_acl.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nd_set_link",
          "args": [
            "nd",
            "ERR_PTR(error)"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "nd_set_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "717-720",
          "snippet": "void nd_set_link(struct nameidata *nd, char *path)\n{\n\tnd->saved_names[nd->depth] = path;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_path_walk(const char *, struct nameidata *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstatic int link_path_walk(const char *, struct nameidata *);\n\nvoid nd_set_link(struct nameidata *nd, char *path)\n{\n\tnd->saved_names[nd->depth] = path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "link"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_readlink",
          "args": [
            "XFS_I(dentry->d_inode)",
            "link"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_readlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_symlink.c",
          "lines": "123-163",
          "snippet": "int\nxfs_readlink(\n\tstruct xfs_inode *ip,\n\tchar\t\t*link)\n{\n\tstruct xfs_mount *mp = ip->i_mount;\n\txfs_fsize_t\tpathlen;\n\tint\t\terror = 0;\n\n\ttrace_xfs_readlink(ip);\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\txfs_ilock(ip, XFS_ILOCK_SHARED);\n\n\tpathlen = ip->i_d.di_size;\n\tif (!pathlen)\n\t\tgoto out;\n\n\tif (pathlen < 0 || pathlen > MAXPATHLEN) {\n\t\txfs_alert(mp, \"%s: inode (%llu) bad symlink length (%lld)\",\n\t\t\t __func__, (unsigned long long) ip->i_ino,\n\t\t\t (long long) pathlen);\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out;\n\t}\n\n\n\tif (ip->i_df.if_flags & XFS_IFINLINE) {\n\t\tmemcpy(link, ip->i_df.if_u1.if_data, pathlen);\n\t\tlink[pathlen] = '\\0';\n\t} else {\n\t\terror = xfs_readlink_bmap(ip, link);\n\t}\n\n out:\n\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nint\nxfs_readlink(\n\tstruct xfs_inode *ip,\n\tchar\t\t*link)\n{\n\tstruct xfs_mount *mp = ip->i_mount;\n\txfs_fsize_t\tpathlen;\n\tint\t\terror = 0;\n\n\ttrace_xfs_readlink(ip);\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\txfs_ilock(ip, XFS_ILOCK_SHARED);\n\n\tpathlen = ip->i_d.di_size;\n\tif (!pathlen)\n\t\tgoto out;\n\n\tif (pathlen < 0 || pathlen > MAXPATHLEN) {\n\t\txfs_alert(mp, \"%s: inode (%llu) bad symlink length (%lld)\",\n\t\t\t __func__, (unsigned long long) ip->i_ino,\n\t\t\t (long long) pathlen);\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out;\n\t}\n\n\n\tif (ip->i_df.if_flags & XFS_IFINLINE) {\n\t\tmemcpy(link, ip->i_df.if_u1.if_data, pathlen);\n\t\tlink[pathlen] = '\\0';\n\t} else {\n\t\terror = xfs_readlink_bmap(ip, link);\n\t}\n\n out:\n\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "dentry->d_inode"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "MAXPATHLEN+1",
            "GFP_KERNEL"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void *\nxfs_vn_follow_link(\n\tstruct dentry\t\t*dentry,\n\tstruct nameidata\t*nd)\n{\n\tchar\t\t\t*link;\n\tint\t\t\terror = -ENOMEM;\n\n\tlink = kmalloc(MAXPATHLEN+1, GFP_KERNEL);\n\tif (!link)\n\t\tgoto out_err;\n\n\terror = xfs_readlink(XFS_I(dentry->d_inode), link);\n\tif (unlikely(error))\n\t\tgoto out_kfree;\n\n\tnd_set_link(nd, link);\n\treturn NULL;\n\n out_kfree:\n\tkfree(link);\n out_err:\n\tnd_set_link(nd, ERR_PTR(error));\n\treturn NULL;\n}"
  },
  {
    "function_name": "xfs_vn_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
    "lines": "379-405",
    "snippet": "STATIC int\nxfs_vn_rename(\n\tstruct inode\t*odir,\n\tstruct dentry\t*odentry,\n\tstruct inode\t*ndir,\n\tstruct dentry\t*ndentry,\n\tunsigned int\tflags)\n{\n\tstruct inode\t*new_inode = ndentry->d_inode;\n\tint\t\tomode = 0;\n\tstruct xfs_name\toname;\n\tstruct xfs_name\tnname;\n\n\tif (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE))\n\t\treturn -EINVAL;\n\n\t/* if we are exchanging files, we need to set i_mode of both files */\n\tif (flags & RENAME_EXCHANGE)\n\t\tomode = ndentry->d_inode->i_mode;\n\n\txfs_dentry_to_name(&oname, odentry, omode);\n\txfs_dentry_to_name(&nname, ndentry, odentry->d_inode->i_mode);\n\n\treturn xfs_rename(XFS_I(odir), &oname, XFS_I(odentry->d_inode),\n\t\t\t  XFS_I(ndir), &nname,\n\t\t\t  new_inode ? XFS_I(new_inode) : NULL, flags);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/security.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/namei.h>",
      "#include <linux/xattr.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_acl.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_rename",
          "args": [
            "XFS_I(odir)",
            "&oname",
            "XFS_I(odentry->d_inode)",
            "XFS_I(ndir)",
            "&nname",
            "new_inode ? XFS_I(new_inode) : NULL",
            "flags"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "2781-3052",
          "snippet": "int\nxfs_rename(\n\txfs_inode_t\t*src_dp,\n\tstruct xfs_name\t*src_name,\n\txfs_inode_t\t*src_ip,\n\txfs_inode_t\t*target_dp,\n\tstruct xfs_name\t*target_name,\n\txfs_inode_t\t*target_ip,\n\tunsigned int\tflags)\n{\n\txfs_trans_t\t*tp = NULL;\n\txfs_mount_t\t*mp = src_dp->i_mount;\n\tint\t\tnew_parent;\t\t/* moving to a new dir */\n\tint\t\tsrc_is_directory;\t/* src_name is a directory */\n\tint\t\terror;\n\txfs_bmap_free_t free_list;\n\txfs_fsblock_t   first_block;\n\tint\t\tcancel_flags;\n\tint\t\tcommitted;\n\txfs_inode_t\t*inodes[4];\n\tint\t\tspaceres;\n\tint\t\tnum_inodes;\n\n\ttrace_xfs_rename(src_dp, target_dp, src_name, target_name);\n\n\tnew_parent = (src_dp != target_dp);\n\tsrc_is_directory = S_ISDIR(src_ip->i_d.di_mode);\n\n\txfs_sort_for_rename(src_dp, target_dp, src_ip, target_ip,\n\t\t\t\tinodes, &num_inodes);\n\n\txfs_bmap_init(&free_list, &first_block);\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_RENAME);\n\tcancel_flags = XFS_TRANS_RELEASE_LOG_RES;\n\tspaceres = XFS_RENAME_SPACE_RES(mp, target_name->len);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_rename, spaceres, 0);\n\tif (error == -ENOSPC) {\n\t\tspaceres = 0;\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_rename, 0, 0);\n\t}\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\tgoto std_return;\n\t}\n\n\t/*\n\t * Attach the dquots to the inodes\n\t */\n\terror = xfs_qm_vop_rename_dqattach(inodes);\n\tif (error) {\n\t\txfs_trans_cancel(tp, cancel_flags);\n\t\tgoto std_return;\n\t}\n\n\t/*\n\t * Lock all the participating inodes. Depending upon whether\n\t * the target_name exists in the target directory, and\n\t * whether the target directory is the same as the source\n\t * directory, we can lock from 2 to 4 inodes.\n\t */\n\txfs_lock_inodes(inodes, num_inodes, XFS_ILOCK_EXCL);\n\n\t/*\n\t * Join all the inodes to the transaction. From this point on,\n\t * we can rely on either trans_commit or trans_cancel to unlock\n\t * them.\n\t */\n\txfs_trans_ijoin(tp, src_dp, XFS_ILOCK_EXCL);\n\tif (new_parent)\n\t\txfs_trans_ijoin(tp, target_dp, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, src_ip, XFS_ILOCK_EXCL);\n\tif (target_ip)\n\t\txfs_trans_ijoin(tp, target_ip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * If we are using project inheritance, we only allow renames\n\t * into our tree when the project IDs are the same; else the\n\t * tree quota mechanism would be circumvented.\n\t */\n\tif (unlikely((target_dp->i_d.di_flags & XFS_DIFLAG_PROJINHERIT) &&\n\t\t     (xfs_get_projid(target_dp) != xfs_get_projid(src_ip)))) {\n\t\terror = -EXDEV;\n\t\tgoto error_return;\n\t}\n\n\t/*\n\t * Handle RENAME_EXCHANGE flags\n\t */\n\tif (flags & RENAME_EXCHANGE) {\n\t\tif (target_ip == NULL) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto error_return;\n\t\t}\n\t\terror = xfs_cross_rename(tp, src_dp, src_name, src_ip,\n\t\t\t\t\t target_dp, target_name, target_ip,\n\t\t\t\t\t &free_list, &first_block, spaceres);\n\t\tif (error)\n\t\t\tgoto abort_return;\n\t\tgoto finish_rename;\n\t}\n\n\t/*\n\t * Set up the target.\n\t */\n\tif (target_ip == NULL) {\n\t\t/*\n\t\t * If there's no space reservation, check the entry will\n\t\t * fit before actually inserting it.\n\t\t */\n\t\tif (!spaceres) {\n\t\t\terror = xfs_dir_canenter(tp, target_dp, target_name);\n\t\t\tif (error)\n\t\t\t\tgoto error_return;\n\t\t}\n\t\t/*\n\t\t * If target does not exist and the rename crosses\n\t\t * directories, adjust the target directory link count\n\t\t * to account for the \"..\" reference from the new entry.\n\t\t */\n\t\terror = xfs_dir_createname(tp, target_dp, target_name,\n\t\t\t\t\t\tsrc_ip->i_ino, &first_block,\n\t\t\t\t\t\t&free_list, spaceres);\n\t\tif (error == -ENOSPC)\n\t\t\tgoto error_return;\n\t\tif (error)\n\t\t\tgoto abort_return;\n\n\t\txfs_trans_ichgtime(tp, target_dp,\n\t\t\t\t\tXFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\n\t\tif (new_parent && src_is_directory) {\n\t\t\terror = xfs_bumplink(tp, target_dp);\n\t\t\tif (error)\n\t\t\t\tgoto abort_return;\n\t\t}\n\t} else { /* target_ip != NULL */\n\t\t/*\n\t\t * If target exists and it's a directory, check that both\n\t\t * target and source are directories and that target can be\n\t\t * destroyed, or that neither is a directory.\n\t\t */\n\t\tif (S_ISDIR(target_ip->i_d.di_mode)) {\n\t\t\t/*\n\t\t\t * Make sure target dir is empty.\n\t\t\t */\n\t\t\tif (!(xfs_dir_isempty(target_ip)) ||\n\t\t\t    (target_ip->i_d.di_nlink > 2)) {\n\t\t\t\terror = -EEXIST;\n\t\t\t\tgoto error_return;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Link the source inode under the target name.\n\t\t * If the source inode is a directory and we are moving\n\t\t * it across directories, its \"..\" entry will be\n\t\t * inconsistent until we replace that down below.\n\t\t *\n\t\t * In case there is already an entry with the same\n\t\t * name at the destination directory, remove it first.\n\t\t */\n\t\terror = xfs_dir_replace(tp, target_dp, target_name,\n\t\t\t\t\tsrc_ip->i_ino,\n\t\t\t\t\t&first_block, &free_list, spaceres);\n\t\tif (error)\n\t\t\tgoto abort_return;\n\n\t\txfs_trans_ichgtime(tp, target_dp,\n\t\t\t\t\tXFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\n\t\t/*\n\t\t * Decrement the link count on the target since the target\n\t\t * dir no longer points to it.\n\t\t */\n\t\terror = xfs_droplink(tp, target_ip);\n\t\tif (error)\n\t\t\tgoto abort_return;\n\n\t\tif (src_is_directory) {\n\t\t\t/*\n\t\t\t * Drop the link from the old \".\" entry.\n\t\t\t */\n\t\t\terror = xfs_droplink(tp, target_ip);\n\t\t\tif (error)\n\t\t\t\tgoto abort_return;\n\t\t}\n\t} /* target_ip != NULL */\n\n\t/*\n\t * Remove the source.\n\t */\n\tif (new_parent && src_is_directory) {\n\t\t/*\n\t\t * Rewrite the \"..\" entry to point to the new\n\t\t * directory.\n\t\t */\n\t\terror = xfs_dir_replace(tp, src_ip, &xfs_name_dotdot,\n\t\t\t\t\ttarget_dp->i_ino,\n\t\t\t\t\t&first_block, &free_list, spaceres);\n\t\tASSERT(error != -EEXIST);\n\t\tif (error)\n\t\t\tgoto abort_return;\n\t}\n\n\t/*\n\t * We always want to hit the ctime on the source inode.\n\t *\n\t * This isn't strictly required by the standards since the source\n\t * inode isn't really being changed, but old unix file systems did\n\t * it and some incremental backup programs won't work without it.\n\t */\n\txfs_trans_ichgtime(tp, src_ip, XFS_ICHGTIME_CHG);\n\txfs_trans_log_inode(tp, src_ip, XFS_ILOG_CORE);\n\n\t/*\n\t * Adjust the link count on src_dp.  This is necessary when\n\t * renaming a directory, either within one parent when\n\t * the target existed, or across two parent directories.\n\t */\n\tif (src_is_directory && (new_parent || target_ip != NULL)) {\n\n\t\t/*\n\t\t * Decrement link count on src_directory since the\n\t\t * entry that's moved no longer points to it.\n\t\t */\n\t\terror = xfs_droplink(tp, src_dp);\n\t\tif (error)\n\t\t\tgoto abort_return;\n\t}\n\n\terror = xfs_dir_removename(tp, src_dp, src_name, src_ip->i_ino,\n\t\t\t\t\t&first_block, &free_list, spaceres);\n\tif (error)\n\t\tgoto abort_return;\n\n\txfs_trans_ichgtime(tp, src_dp, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\txfs_trans_log_inode(tp, src_dp, XFS_ILOG_CORE);\n\tif (new_parent)\n\t\txfs_trans_log_inode(tp, target_dp, XFS_ILOG_CORE);\n\nfinish_rename:\n\t/*\n\t * If this is a synchronous mount, make sure that the\n\t * rename transaction goes to disk before returning to\n\t * the user.\n\t */\n\tif (mp->m_flags & (XFS_MOUNT_WSYNC|XFS_MOUNT_DIRSYNC)) {\n\t\txfs_trans_set_sync(tp);\n\t}\n\n\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\tif (error) {\n\t\txfs_bmap_cancel(&free_list);\n\t\txfs_trans_cancel(tp, (XFS_TRANS_RELEASE_LOG_RES |\n\t\t\t\t XFS_TRANS_ABORT));\n\t\tgoto std_return;\n\t}\n\n\t/*\n\t * trans_commit will unlock src_ip, target_ip & decrement\n\t * the vnode references.\n\t */\n\treturn xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\n abort_return:\n\tcancel_flags |= XFS_TRANS_ABORT;\n error_return:\n\txfs_bmap_cancel(&free_list);\n\txfs_trans_cancel(tp, cancel_flags);\n std_return:\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_rename(\n\txfs_inode_t\t*src_dp,\n\tstruct xfs_name\t*src_name,\n\txfs_inode_t\t*src_ip,\n\txfs_inode_t\t*target_dp,\n\tstruct xfs_name\t*target_name,\n\txfs_inode_t\t*target_ip,\n\tunsigned int\tflags)\n{\n\txfs_trans_t\t*tp = NULL;\n\txfs_mount_t\t*mp = src_dp->i_mount;\n\tint\t\tnew_parent;\t\t/* moving to a new dir */\n\tint\t\tsrc_is_directory;\t/* src_name is a directory */\n\tint\t\terror;\n\txfs_bmap_free_t free_list;\n\txfs_fsblock_t   first_block;\n\tint\t\tcancel_flags;\n\tint\t\tcommitted;\n\txfs_inode_t\t*inodes[4];\n\tint\t\tspaceres;\n\tint\t\tnum_inodes;\n\n\ttrace_xfs_rename(src_dp, target_dp, src_name, target_name);\n\n\tnew_parent = (src_dp != target_dp);\n\tsrc_is_directory = S_ISDIR(src_ip->i_d.di_mode);\n\n\txfs_sort_for_rename(src_dp, target_dp, src_ip, target_ip,\n\t\t\t\tinodes, &num_inodes);\n\n\txfs_bmap_init(&free_list, &first_block);\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_RENAME);\n\tcancel_flags = XFS_TRANS_RELEASE_LOG_RES;\n\tspaceres = XFS_RENAME_SPACE_RES(mp, target_name->len);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_rename, spaceres, 0);\n\tif (error == -ENOSPC) {\n\t\tspaceres = 0;\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_rename, 0, 0);\n\t}\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\tgoto std_return;\n\t}\n\n\t/*\n\t * Attach the dquots to the inodes\n\t */\n\terror = xfs_qm_vop_rename_dqattach(inodes);\n\tif (error) {\n\t\txfs_trans_cancel(tp, cancel_flags);\n\t\tgoto std_return;\n\t}\n\n\t/*\n\t * Lock all the participating inodes. Depending upon whether\n\t * the target_name exists in the target directory, and\n\t * whether the target directory is the same as the source\n\t * directory, we can lock from 2 to 4 inodes.\n\t */\n\txfs_lock_inodes(inodes, num_inodes, XFS_ILOCK_EXCL);\n\n\t/*\n\t * Join all the inodes to the transaction. From this point on,\n\t * we can rely on either trans_commit or trans_cancel to unlock\n\t * them.\n\t */\n\txfs_trans_ijoin(tp, src_dp, XFS_ILOCK_EXCL);\n\tif (new_parent)\n\t\txfs_trans_ijoin(tp, target_dp, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, src_ip, XFS_ILOCK_EXCL);\n\tif (target_ip)\n\t\txfs_trans_ijoin(tp, target_ip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * If we are using project inheritance, we only allow renames\n\t * into our tree when the project IDs are the same; else the\n\t * tree quota mechanism would be circumvented.\n\t */\n\tif (unlikely((target_dp->i_d.di_flags & XFS_DIFLAG_PROJINHERIT) &&\n\t\t     (xfs_get_projid(target_dp) != xfs_get_projid(src_ip)))) {\n\t\terror = -EXDEV;\n\t\tgoto error_return;\n\t}\n\n\t/*\n\t * Handle RENAME_EXCHANGE flags\n\t */\n\tif (flags & RENAME_EXCHANGE) {\n\t\tif (target_ip == NULL) {\n\t\t\terror = -EINVAL;\n\t\t\tgoto error_return;\n\t\t}\n\t\terror = xfs_cross_rename(tp, src_dp, src_name, src_ip,\n\t\t\t\t\t target_dp, target_name, target_ip,\n\t\t\t\t\t &free_list, &first_block, spaceres);\n\t\tif (error)\n\t\t\tgoto abort_return;\n\t\tgoto finish_rename;\n\t}\n\n\t/*\n\t * Set up the target.\n\t */\n\tif (target_ip == NULL) {\n\t\t/*\n\t\t * If there's no space reservation, check the entry will\n\t\t * fit before actually inserting it.\n\t\t */\n\t\tif (!spaceres) {\n\t\t\terror = xfs_dir_canenter(tp, target_dp, target_name);\n\t\t\tif (error)\n\t\t\t\tgoto error_return;\n\t\t}\n\t\t/*\n\t\t * If target does not exist and the rename crosses\n\t\t * directories, adjust the target directory link count\n\t\t * to account for the \"..\" reference from the new entry.\n\t\t */\n\t\terror = xfs_dir_createname(tp, target_dp, target_name,\n\t\t\t\t\t\tsrc_ip->i_ino, &first_block,\n\t\t\t\t\t\t&free_list, spaceres);\n\t\tif (error == -ENOSPC)\n\t\t\tgoto error_return;\n\t\tif (error)\n\t\t\tgoto abort_return;\n\n\t\txfs_trans_ichgtime(tp, target_dp,\n\t\t\t\t\tXFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\n\t\tif (new_parent && src_is_directory) {\n\t\t\terror = xfs_bumplink(tp, target_dp);\n\t\t\tif (error)\n\t\t\t\tgoto abort_return;\n\t\t}\n\t} else { /* target_ip != NULL */\n\t\t/*\n\t\t * If target exists and it's a directory, check that both\n\t\t * target and source are directories and that target can be\n\t\t * destroyed, or that neither is a directory.\n\t\t */\n\t\tif (S_ISDIR(target_ip->i_d.di_mode)) {\n\t\t\t/*\n\t\t\t * Make sure target dir is empty.\n\t\t\t */\n\t\t\tif (!(xfs_dir_isempty(target_ip)) ||\n\t\t\t    (target_ip->i_d.di_nlink > 2)) {\n\t\t\t\terror = -EEXIST;\n\t\t\t\tgoto error_return;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Link the source inode under the target name.\n\t\t * If the source inode is a directory and we are moving\n\t\t * it across directories, its \"..\" entry will be\n\t\t * inconsistent until we replace that down below.\n\t\t *\n\t\t * In case there is already an entry with the same\n\t\t * name at the destination directory, remove it first.\n\t\t */\n\t\terror = xfs_dir_replace(tp, target_dp, target_name,\n\t\t\t\t\tsrc_ip->i_ino,\n\t\t\t\t\t&first_block, &free_list, spaceres);\n\t\tif (error)\n\t\t\tgoto abort_return;\n\n\t\txfs_trans_ichgtime(tp, target_dp,\n\t\t\t\t\tXFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\n\t\t/*\n\t\t * Decrement the link count on the target since the target\n\t\t * dir no longer points to it.\n\t\t */\n\t\terror = xfs_droplink(tp, target_ip);\n\t\tif (error)\n\t\t\tgoto abort_return;\n\n\t\tif (src_is_directory) {\n\t\t\t/*\n\t\t\t * Drop the link from the old \".\" entry.\n\t\t\t */\n\t\t\terror = xfs_droplink(tp, target_ip);\n\t\t\tif (error)\n\t\t\t\tgoto abort_return;\n\t\t}\n\t} /* target_ip != NULL */\n\n\t/*\n\t * Remove the source.\n\t */\n\tif (new_parent && src_is_directory) {\n\t\t/*\n\t\t * Rewrite the \"..\" entry to point to the new\n\t\t * directory.\n\t\t */\n\t\terror = xfs_dir_replace(tp, src_ip, &xfs_name_dotdot,\n\t\t\t\t\ttarget_dp->i_ino,\n\t\t\t\t\t&first_block, &free_list, spaceres);\n\t\tASSERT(error != -EEXIST);\n\t\tif (error)\n\t\t\tgoto abort_return;\n\t}\n\n\t/*\n\t * We always want to hit the ctime on the source inode.\n\t *\n\t * This isn't strictly required by the standards since the source\n\t * inode isn't really being changed, but old unix file systems did\n\t * it and some incremental backup programs won't work without it.\n\t */\n\txfs_trans_ichgtime(tp, src_ip, XFS_ICHGTIME_CHG);\n\txfs_trans_log_inode(tp, src_ip, XFS_ILOG_CORE);\n\n\t/*\n\t * Adjust the link count on src_dp.  This is necessary when\n\t * renaming a directory, either within one parent when\n\t * the target existed, or across two parent directories.\n\t */\n\tif (src_is_directory && (new_parent || target_ip != NULL)) {\n\n\t\t/*\n\t\t * Decrement link count on src_directory since the\n\t\t * entry that's moved no longer points to it.\n\t\t */\n\t\terror = xfs_droplink(tp, src_dp);\n\t\tif (error)\n\t\t\tgoto abort_return;\n\t}\n\n\terror = xfs_dir_removename(tp, src_dp, src_name, src_ip->i_ino,\n\t\t\t\t\t&first_block, &free_list, spaceres);\n\tif (error)\n\t\tgoto abort_return;\n\n\txfs_trans_ichgtime(tp, src_dp, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\txfs_trans_log_inode(tp, src_dp, XFS_ILOG_CORE);\n\tif (new_parent)\n\t\txfs_trans_log_inode(tp, target_dp, XFS_ILOG_CORE);\n\nfinish_rename:\n\t/*\n\t * If this is a synchronous mount, make sure that the\n\t * rename transaction goes to disk before returning to\n\t * the user.\n\t */\n\tif (mp->m_flags & (XFS_MOUNT_WSYNC|XFS_MOUNT_DIRSYNC)) {\n\t\txfs_trans_set_sync(tp);\n\t}\n\n\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\tif (error) {\n\t\txfs_bmap_cancel(&free_list);\n\t\txfs_trans_cancel(tp, (XFS_TRANS_RELEASE_LOG_RES |\n\t\t\t\t XFS_TRANS_ABORT));\n\t\tgoto std_return;\n\t}\n\n\t/*\n\t * trans_commit will unlock src_ip, target_ip & decrement\n\t * the vnode references.\n\t */\n\treturn xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\n abort_return:\n\tcancel_flags |= XFS_TRANS_ABORT;\n error_return:\n\txfs_bmap_cancel(&free_list);\n\txfs_trans_cancel(tp, cancel_flags);\n std_return:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "new_inode"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dentry_to_name",
          "args": [
            "&nname",
            "ndentry",
            "odentry->d_inode->i_mode"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dentry_to_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
          "lines": "98-107",
          "snippet": "static void\nxfs_dentry_to_name(\n\tstruct xfs_name\t*namep,\n\tstruct dentry\t*dentry,\n\tint\t\tmode)\n{\n\tnamep->name = dentry->d_name.name;\n\tnamep->len = dentry->d_name.len;\n\tnamep->type = xfs_mode_to_ftype[(mode & S_IFMT) >> S_SHIFT];\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/security.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/namei.h>",
            "#include <linux/xattr.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_acl.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nstatic void\nxfs_dentry_to_name(\n\tstruct xfs_name\t*namep,\n\tstruct dentry\t*dentry,\n\tint\t\tmode)\n{\n\tnamep->name = dentry->d_name.name;\n\tnamep->len = dentry->d_name.len;\n\tnamep->type = xfs_mode_to_ftype[(mode & S_IFMT) >> S_SHIFT];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_vn_rename(\n\tstruct inode\t*odir,\n\tstruct dentry\t*odentry,\n\tstruct inode\t*ndir,\n\tstruct dentry\t*ndentry,\n\tunsigned int\tflags)\n{\n\tstruct inode\t*new_inode = ndentry->d_inode;\n\tint\t\tomode = 0;\n\tstruct xfs_name\toname;\n\tstruct xfs_name\tnname;\n\n\tif (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE))\n\t\treturn -EINVAL;\n\n\t/* if we are exchanging files, we need to set i_mode of both files */\n\tif (flags & RENAME_EXCHANGE)\n\t\tomode = ndentry->d_inode->i_mode;\n\n\txfs_dentry_to_name(&oname, odentry, omode);\n\txfs_dentry_to_name(&nname, ndentry, odentry->d_inode->i_mode);\n\n\treturn xfs_rename(XFS_I(odir), &oname, XFS_I(odentry->d_inode),\n\t\t\t  XFS_I(ndir), &nname,\n\t\t\t  new_inode ? XFS_I(new_inode) : NULL, flags);\n}"
  },
  {
    "function_name": "xfs_vn_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
    "lines": "343-377",
    "snippet": "STATIC int\nxfs_vn_symlink(\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry,\n\tconst char\t*symname)\n{\n\tstruct inode\t*inode;\n\tstruct xfs_inode *cip = NULL;\n\tstruct xfs_name\tname;\n\tint\t\terror;\n\tumode_t\t\tmode;\n\n\tmode = S_IFLNK |\n\t\t(irix_symlink_mode ? 0777 & ~current_umask() : S_IRWXUGO);\n\txfs_dentry_to_name(&name, dentry, mode);\n\n\terror = xfs_symlink(XFS_I(dir), &name, symname, mode, &cip);\n\tif (unlikely(error))\n\t\tgoto out;\n\n\tinode = VFS_I(cip);\n\n\terror = xfs_init_security(inode, dir, &dentry->d_name);\n\tif (unlikely(error))\n\t\tgoto out_cleanup_inode;\n\n\td_instantiate(dentry, inode);\n\treturn 0;\n\n out_cleanup_inode:\n\txfs_cleanup_inode(dir, inode, dentry);\n\tiput(inode);\n out:\n\treturn error;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/security.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/namei.h>",
      "#include <linux/xattr.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_acl.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_cleanup_inode",
          "args": [
            "dir",
            "inode",
            "dentry"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_cleanup_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
          "lines": "109-125",
          "snippet": "STATIC void\nxfs_cleanup_inode(\n\tstruct inode\t*dir,\n\tstruct inode\t*inode,\n\tstruct dentry\t*dentry)\n{\n\tstruct xfs_name\tteardown;\n\n\t/* Oh, the horror.\n\t * If we can't add the ACL or we fail in\n\t * xfs_init_security we must back out.\n\t * ENOSPC can hit here, among other things.\n\t */\n\txfs_dentry_to_name(&teardown, dentry, 0);\n\n\txfs_remove(XFS_I(dir), &teardown, XFS_I(inode));\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/security.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/namei.h>",
            "#include <linux/xattr.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_acl.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_cleanup_inode(\n\tstruct inode\t*dir,\n\tstruct inode\t*inode,\n\tstruct dentry\t*dentry)\n{\n\tstruct xfs_name\tteardown;\n\n\t/* Oh, the horror.\n\t * If we can't add the ACL or we fail in\n\t * xfs_init_security we must back out.\n\t * ENOSPC can hit here, among other things.\n\t */\n\txfs_dentry_to_name(&teardown, dentry, 0);\n\n\txfs_remove(XFS_I(dir), &teardown, XFS_I(inode));\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_init_security",
          "args": [
            "inode",
            "dir",
            "&dentry->d_name"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_init_security",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
          "lines": "88-96",
          "snippet": "STATIC int\nxfs_init_security(\n\tstruct inode\t*inode,\n\tstruct inode\t*dir,\n\tconst struct qstr *qstr)\n{\n\treturn security_inode_init_security(inode, dir, qstr,\n\t\t\t\t\t     &xfs_initxattrs, NULL);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/security.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/namei.h>",
            "#include <linux/xattr.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_acl.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_init_security(\n\tstruct inode\t*inode,\n\tstruct inode\t*dir,\n\tconst struct qstr *qstr)\n{\n\treturn security_inode_init_security(inode, dir, qstr,\n\t\t\t\t\t     &xfs_initxattrs, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "cip"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "78-81",
          "snippet": "static inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_symlink",
          "args": [
            "XFS_I(dir)",
            "&name",
            "symname",
            "mode",
            "&cip"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_symlink.c",
          "lines": "165-421",
          "snippet": "int\nxfs_symlink(\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_name\t\t*link_name,\n\tconst char\t\t*target_path,\n\tumode_t\t\t\tmode,\n\tstruct xfs_inode\t**ipp)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_trans\t*tp = NULL;\n\tstruct xfs_inode\t*ip = NULL;\n\tint\t\t\terror = 0;\n\tint\t\t\tpathlen;\n\tstruct xfs_bmap_free\tfree_list;\n\txfs_fsblock_t\t\tfirst_block;\n\tbool\t\t\tunlock_dp_on_error = false;\n\tuint\t\t\tcancel_flags;\n\tint\t\t\tcommitted;\n\txfs_fileoff_t\t\tfirst_fsb;\n\txfs_filblks_t\t\tfs_blocks;\n\tint\t\t\tnmaps;\n\tstruct xfs_bmbt_irec\tmval[XFS_SYMLINK_MAPS];\n\txfs_daddr_t\t\td;\n\tconst char\t\t*cur_chunk;\n\tint\t\t\tbyte_cnt;\n\tint\t\t\tn;\n\txfs_buf_t\t\t*bp;\n\tprid_t\t\t\tprid;\n\tstruct xfs_dquot\t*udqp = NULL;\n\tstruct xfs_dquot\t*gdqp = NULL;\n\tstruct xfs_dquot\t*pdqp = NULL;\n\tuint\t\t\tresblks;\n\n\t*ipp = NULL;\n\n\ttrace_xfs_symlink(dp, link_name);\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\t/*\n\t * Check component lengths of the target path name.\n\t */\n\tpathlen = strlen(target_path);\n\tif (pathlen >= MAXPATHLEN)      /* total string too long */\n\t\treturn -ENAMETOOLONG;\n\n\tudqp = gdqp = NULL;\n\tprid = xfs_get_initial_prid(dp);\n\n\t/*\n\t * Make sure that we have allocated dquot(s) on disk.\n\t */\n\terror = xfs_qm_vop_dqalloc(dp,\n\t\t\txfs_kuid_to_uid(current_fsuid()),\n\t\t\txfs_kgid_to_gid(current_fsgid()), prid,\n\t\t\tXFS_QMOPT_QUOTALL | XFS_QMOPT_INHERIT,\n\t\t\t&udqp, &gdqp, &pdqp);\n\tif (error)\n\t\tgoto std_return;\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_SYMLINK);\n\tcancel_flags = XFS_TRANS_RELEASE_LOG_RES;\n\t/*\n\t * The symlink will fit into the inode data fork?\n\t * There can't be any attributes so we get the whole variable part.\n\t */\n\tif (pathlen <= XFS_LITINO(mp, dp->i_d.di_version))\n\t\tfs_blocks = 0;\n\telse\n\t\tfs_blocks = xfs_symlink_blocks(mp, pathlen);\n\tresblks = XFS_SYMLINK_SPACE_RES(mp, link_name->len, fs_blocks);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_symlink, resblks, 0);\n\tif (error == -ENOSPC && fs_blocks == 0) {\n\t\tresblks = 0;\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_symlink, 0, 0);\n\t}\n\tif (error) {\n\t\tcancel_flags = 0;\n\t\tgoto error_return;\n\t}\n\n\txfs_ilock(dp, XFS_ILOCK_EXCL | XFS_ILOCK_PARENT);\n\tunlock_dp_on_error = true;\n\n\t/*\n\t * Check whether the directory allows new symlinks or not.\n\t */\n\tif (dp->i_d.di_flags & XFS_DIFLAG_NOSYMLINKS) {\n\t\terror = -EPERM;\n\t\tgoto error_return;\n\t}\n\n\t/*\n\t * Reserve disk quota : blocks and inode.\n\t */\n\terror = xfs_trans_reserve_quota(tp, mp, udqp, gdqp,\n\t\t\t\t\t\tpdqp, resblks, 1, 0);\n\tif (error)\n\t\tgoto error_return;\n\n\t/*\n\t * Check for ability to enter directory entry, if no space reserved.\n\t */\n\tif (!resblks) {\n\t\terror = xfs_dir_canenter(tp, dp, link_name);\n\t\tif (error)\n\t\t\tgoto error_return;\n\t}\n\t/*\n\t * Initialize the bmap freelist prior to calling either\n\t * bmapi or the directory create code.\n\t */\n\txfs_bmap_init(&free_list, &first_block);\n\n\t/*\n\t * Allocate an inode for the symlink.\n\t */\n\terror = xfs_dir_ialloc(&tp, dp, S_IFLNK | (mode & ~S_IFMT), 1, 0,\n\t\t\t       prid, resblks > 0, &ip, NULL);\n\tif (error) {\n\t\tif (error == -ENOSPC)\n\t\t\tgoto error_return;\n\t\tgoto error1;\n\t}\n\n\t/*\n\t * An error after we've joined dp to the transaction will result in the\n\t * transaction cancel unlocking dp so don't do it explicitly in the\n\t * error path.\n\t */\n\txfs_trans_ijoin(tp, dp, XFS_ILOCK_EXCL);\n\tunlock_dp_on_error = false;\n\n\t/*\n\t * Also attach the dquot(s) to it, if applicable.\n\t */\n\txfs_qm_vop_create_dqattach(tp, ip, udqp, gdqp, pdqp);\n\n\tif (resblks)\n\t\tresblks -= XFS_IALLOC_SPACE_RES(mp);\n\t/*\n\t * If the symlink will fit into the inode, write it inline.\n\t */\n\tif (pathlen <= XFS_IFORK_DSIZE(ip)) {\n\t\txfs_idata_realloc(ip, pathlen, XFS_DATA_FORK);\n\t\tmemcpy(ip->i_df.if_u1.if_data, target_path, pathlen);\n\t\tip->i_d.di_size = pathlen;\n\n\t\t/*\n\t\t * The inode was initially created in extent format.\n\t\t */\n\t\tip->i_df.if_flags &= ~(XFS_IFEXTENTS | XFS_IFBROOT);\n\t\tip->i_df.if_flags |= XFS_IFINLINE;\n\n\t\tip->i_d.di_format = XFS_DINODE_FMT_LOCAL;\n\t\txfs_trans_log_inode(tp, ip, XFS_ILOG_DDATA | XFS_ILOG_CORE);\n\n\t} else {\n\t\tint\toffset;\n\n\t\tfirst_fsb = 0;\n\t\tnmaps = XFS_SYMLINK_MAPS;\n\n\t\terror = xfs_bmapi_write(tp, ip, first_fsb, fs_blocks,\n\t\t\t\t  XFS_BMAPI_METADATA, &first_block, resblks,\n\t\t\t\t  mval, &nmaps, &free_list);\n\t\tif (error)\n\t\t\tgoto error2;\n\n\t\tif (resblks)\n\t\t\tresblks -= fs_blocks;\n\t\tip->i_d.di_size = pathlen;\n\t\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\t\tcur_chunk = target_path;\n\t\toffset = 0;\n\t\tfor (n = 0; n < nmaps; n++) {\n\t\t\tchar\t*buf;\n\n\t\t\td = XFS_FSB_TO_DADDR(mp, mval[n].br_startblock);\n\t\t\tbyte_cnt = XFS_FSB_TO_B(mp, mval[n].br_blockcount);\n\t\t\tbp = xfs_trans_get_buf(tp, mp->m_ddev_targp, d,\n\t\t\t\t\t       BTOBB(byte_cnt), 0);\n\t\t\tif (!bp) {\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto error2;\n\t\t\t}\n\t\t\tbp->b_ops = &xfs_symlink_buf_ops;\n\n\t\t\tbyte_cnt = XFS_SYMLINK_BUF_SPACE(mp, byte_cnt);\n\t\t\tbyte_cnt = min(byte_cnt, pathlen);\n\n\t\t\tbuf = bp->b_addr;\n\t\t\tbuf += xfs_symlink_hdr_set(mp, ip->i_ino, offset,\n\t\t\t\t\t\t   byte_cnt, bp);\n\n\t\t\tmemcpy(buf, cur_chunk, byte_cnt);\n\n\t\t\tcur_chunk += byte_cnt;\n\t\t\tpathlen -= byte_cnt;\n\t\t\toffset += byte_cnt;\n\n\t\t\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_SYMLINK_BUF);\n\t\t\txfs_trans_log_buf(tp, bp, 0, (buf + byte_cnt - 1) -\n\t\t\t\t\t\t\t(char *)bp->b_addr);\n\t\t}\n\t\tASSERT(pathlen == 0);\n\t}\n\n\t/*\n\t * Create the directory entry for the symlink.\n\t */\n\terror = xfs_dir_createname(tp, dp, link_name, ip->i_ino,\n\t\t\t\t\t&first_block, &free_list, resblks);\n\tif (error)\n\t\tgoto error2;\n\txfs_trans_ichgtime(tp, dp, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\txfs_trans_log_inode(tp, dp, XFS_ILOG_CORE);\n\n\t/*\n\t * If this is a synchronous mount, make sure that the\n\t * symlink transaction goes to disk before returning to\n\t * the user.\n\t */\n\tif (mp->m_flags & (XFS_MOUNT_WSYNC|XFS_MOUNT_DIRSYNC)) {\n\t\txfs_trans_set_sync(tp);\n\t}\n\n\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\tif (error) {\n\t\tgoto error2;\n\t}\n\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\txfs_qm_dqrele(pdqp);\n\n\t*ipp = ip;\n\treturn 0;\n\n error2:\n\tIRELE(ip);\n error1:\n\txfs_bmap_cancel(&free_list);\n\tcancel_flags |= XFS_TRANS_ABORT;\n error_return:\n\txfs_trans_cancel(tp, cancel_flags);\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\txfs_qm_dqrele(pdqp);\n\n\tif (unlock_dp_on_error)\n\t\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n std_return:\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nint\nxfs_symlink(\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_name\t\t*link_name,\n\tconst char\t\t*target_path,\n\tumode_t\t\t\tmode,\n\tstruct xfs_inode\t**ipp)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_trans\t*tp = NULL;\n\tstruct xfs_inode\t*ip = NULL;\n\tint\t\t\terror = 0;\n\tint\t\t\tpathlen;\n\tstruct xfs_bmap_free\tfree_list;\n\txfs_fsblock_t\t\tfirst_block;\n\tbool\t\t\tunlock_dp_on_error = false;\n\tuint\t\t\tcancel_flags;\n\tint\t\t\tcommitted;\n\txfs_fileoff_t\t\tfirst_fsb;\n\txfs_filblks_t\t\tfs_blocks;\n\tint\t\t\tnmaps;\n\tstruct xfs_bmbt_irec\tmval[XFS_SYMLINK_MAPS];\n\txfs_daddr_t\t\td;\n\tconst char\t\t*cur_chunk;\n\tint\t\t\tbyte_cnt;\n\tint\t\t\tn;\n\txfs_buf_t\t\t*bp;\n\tprid_t\t\t\tprid;\n\tstruct xfs_dquot\t*udqp = NULL;\n\tstruct xfs_dquot\t*gdqp = NULL;\n\tstruct xfs_dquot\t*pdqp = NULL;\n\tuint\t\t\tresblks;\n\n\t*ipp = NULL;\n\n\ttrace_xfs_symlink(dp, link_name);\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\t/*\n\t * Check component lengths of the target path name.\n\t */\n\tpathlen = strlen(target_path);\n\tif (pathlen >= MAXPATHLEN)      /* total string too long */\n\t\treturn -ENAMETOOLONG;\n\n\tudqp = gdqp = NULL;\n\tprid = xfs_get_initial_prid(dp);\n\n\t/*\n\t * Make sure that we have allocated dquot(s) on disk.\n\t */\n\terror = xfs_qm_vop_dqalloc(dp,\n\t\t\txfs_kuid_to_uid(current_fsuid()),\n\t\t\txfs_kgid_to_gid(current_fsgid()), prid,\n\t\t\tXFS_QMOPT_QUOTALL | XFS_QMOPT_INHERIT,\n\t\t\t&udqp, &gdqp, &pdqp);\n\tif (error)\n\t\tgoto std_return;\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_SYMLINK);\n\tcancel_flags = XFS_TRANS_RELEASE_LOG_RES;\n\t/*\n\t * The symlink will fit into the inode data fork?\n\t * There can't be any attributes so we get the whole variable part.\n\t */\n\tif (pathlen <= XFS_LITINO(mp, dp->i_d.di_version))\n\t\tfs_blocks = 0;\n\telse\n\t\tfs_blocks = xfs_symlink_blocks(mp, pathlen);\n\tresblks = XFS_SYMLINK_SPACE_RES(mp, link_name->len, fs_blocks);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_symlink, resblks, 0);\n\tif (error == -ENOSPC && fs_blocks == 0) {\n\t\tresblks = 0;\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_symlink, 0, 0);\n\t}\n\tif (error) {\n\t\tcancel_flags = 0;\n\t\tgoto error_return;\n\t}\n\n\txfs_ilock(dp, XFS_ILOCK_EXCL | XFS_ILOCK_PARENT);\n\tunlock_dp_on_error = true;\n\n\t/*\n\t * Check whether the directory allows new symlinks or not.\n\t */\n\tif (dp->i_d.di_flags & XFS_DIFLAG_NOSYMLINKS) {\n\t\terror = -EPERM;\n\t\tgoto error_return;\n\t}\n\n\t/*\n\t * Reserve disk quota : blocks and inode.\n\t */\n\terror = xfs_trans_reserve_quota(tp, mp, udqp, gdqp,\n\t\t\t\t\t\tpdqp, resblks, 1, 0);\n\tif (error)\n\t\tgoto error_return;\n\n\t/*\n\t * Check for ability to enter directory entry, if no space reserved.\n\t */\n\tif (!resblks) {\n\t\terror = xfs_dir_canenter(tp, dp, link_name);\n\t\tif (error)\n\t\t\tgoto error_return;\n\t}\n\t/*\n\t * Initialize the bmap freelist prior to calling either\n\t * bmapi or the directory create code.\n\t */\n\txfs_bmap_init(&free_list, &first_block);\n\n\t/*\n\t * Allocate an inode for the symlink.\n\t */\n\terror = xfs_dir_ialloc(&tp, dp, S_IFLNK | (mode & ~S_IFMT), 1, 0,\n\t\t\t       prid, resblks > 0, &ip, NULL);\n\tif (error) {\n\t\tif (error == -ENOSPC)\n\t\t\tgoto error_return;\n\t\tgoto error1;\n\t}\n\n\t/*\n\t * An error after we've joined dp to the transaction will result in the\n\t * transaction cancel unlocking dp so don't do it explicitly in the\n\t * error path.\n\t */\n\txfs_trans_ijoin(tp, dp, XFS_ILOCK_EXCL);\n\tunlock_dp_on_error = false;\n\n\t/*\n\t * Also attach the dquot(s) to it, if applicable.\n\t */\n\txfs_qm_vop_create_dqattach(tp, ip, udqp, gdqp, pdqp);\n\n\tif (resblks)\n\t\tresblks -= XFS_IALLOC_SPACE_RES(mp);\n\t/*\n\t * If the symlink will fit into the inode, write it inline.\n\t */\n\tif (pathlen <= XFS_IFORK_DSIZE(ip)) {\n\t\txfs_idata_realloc(ip, pathlen, XFS_DATA_FORK);\n\t\tmemcpy(ip->i_df.if_u1.if_data, target_path, pathlen);\n\t\tip->i_d.di_size = pathlen;\n\n\t\t/*\n\t\t * The inode was initially created in extent format.\n\t\t */\n\t\tip->i_df.if_flags &= ~(XFS_IFEXTENTS | XFS_IFBROOT);\n\t\tip->i_df.if_flags |= XFS_IFINLINE;\n\n\t\tip->i_d.di_format = XFS_DINODE_FMT_LOCAL;\n\t\txfs_trans_log_inode(tp, ip, XFS_ILOG_DDATA | XFS_ILOG_CORE);\n\n\t} else {\n\t\tint\toffset;\n\n\t\tfirst_fsb = 0;\n\t\tnmaps = XFS_SYMLINK_MAPS;\n\n\t\terror = xfs_bmapi_write(tp, ip, first_fsb, fs_blocks,\n\t\t\t\t  XFS_BMAPI_METADATA, &first_block, resblks,\n\t\t\t\t  mval, &nmaps, &free_list);\n\t\tif (error)\n\t\t\tgoto error2;\n\n\t\tif (resblks)\n\t\t\tresblks -= fs_blocks;\n\t\tip->i_d.di_size = pathlen;\n\t\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\t\tcur_chunk = target_path;\n\t\toffset = 0;\n\t\tfor (n = 0; n < nmaps; n++) {\n\t\t\tchar\t*buf;\n\n\t\t\td = XFS_FSB_TO_DADDR(mp, mval[n].br_startblock);\n\t\t\tbyte_cnt = XFS_FSB_TO_B(mp, mval[n].br_blockcount);\n\t\t\tbp = xfs_trans_get_buf(tp, mp->m_ddev_targp, d,\n\t\t\t\t\t       BTOBB(byte_cnt), 0);\n\t\t\tif (!bp) {\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto error2;\n\t\t\t}\n\t\t\tbp->b_ops = &xfs_symlink_buf_ops;\n\n\t\t\tbyte_cnt = XFS_SYMLINK_BUF_SPACE(mp, byte_cnt);\n\t\t\tbyte_cnt = min(byte_cnt, pathlen);\n\n\t\t\tbuf = bp->b_addr;\n\t\t\tbuf += xfs_symlink_hdr_set(mp, ip->i_ino, offset,\n\t\t\t\t\t\t   byte_cnt, bp);\n\n\t\t\tmemcpy(buf, cur_chunk, byte_cnt);\n\n\t\t\tcur_chunk += byte_cnt;\n\t\t\tpathlen -= byte_cnt;\n\t\t\toffset += byte_cnt;\n\n\t\t\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_SYMLINK_BUF);\n\t\t\txfs_trans_log_buf(tp, bp, 0, (buf + byte_cnt - 1) -\n\t\t\t\t\t\t\t(char *)bp->b_addr);\n\t\t}\n\t\tASSERT(pathlen == 0);\n\t}\n\n\t/*\n\t * Create the directory entry for the symlink.\n\t */\n\terror = xfs_dir_createname(tp, dp, link_name, ip->i_ino,\n\t\t\t\t\t&first_block, &free_list, resblks);\n\tif (error)\n\t\tgoto error2;\n\txfs_trans_ichgtime(tp, dp, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\txfs_trans_log_inode(tp, dp, XFS_ILOG_CORE);\n\n\t/*\n\t * If this is a synchronous mount, make sure that the\n\t * symlink transaction goes to disk before returning to\n\t * the user.\n\t */\n\tif (mp->m_flags & (XFS_MOUNT_WSYNC|XFS_MOUNT_DIRSYNC)) {\n\t\txfs_trans_set_sync(tp);\n\t}\n\n\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\tif (error) {\n\t\tgoto error2;\n\t}\n\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\txfs_qm_dqrele(pdqp);\n\n\t*ipp = ip;\n\treturn 0;\n\n error2:\n\tIRELE(ip);\n error1:\n\txfs_bmap_cancel(&free_list);\n\tcancel_flags |= XFS_TRANS_ABORT;\n error_return:\n\txfs_trans_cancel(tp, cancel_flags);\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\txfs_qm_dqrele(pdqp);\n\n\tif (unlock_dp_on_error)\n\t\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n std_return:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "dir"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dentry_to_name",
          "args": [
            "&name",
            "dentry",
            "mode"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dentry_to_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
          "lines": "98-107",
          "snippet": "static void\nxfs_dentry_to_name(\n\tstruct xfs_name\t*namep,\n\tstruct dentry\t*dentry,\n\tint\t\tmode)\n{\n\tnamep->name = dentry->d_name.name;\n\tnamep->len = dentry->d_name.len;\n\tnamep->type = xfs_mode_to_ftype[(mode & S_IFMT) >> S_SHIFT];\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/security.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/namei.h>",
            "#include <linux/xattr.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_acl.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nstatic void\nxfs_dentry_to_name(\n\tstruct xfs_name\t*namep,\n\tstruct dentry\t*dentry,\n\tint\t\tmode)\n{\n\tnamep->name = dentry->d_name.name;\n\tnamep->len = dentry->d_name.len;\n\tnamep->type = xfs_mode_to_ftype[(mode & S_IFMT) >> S_SHIFT];\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_umask",
          "args": [],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "current_umask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs_struct.c",
          "lines": "154-157",
          "snippet": "int current_umask(void)\n{\n\treturn current->fs->umask;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/slab.h>",
            "#include <linux/path.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/slab.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n\nint current_umask(void)\n{\n\treturn current->fs->umask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_vn_symlink(\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry,\n\tconst char\t*symname)\n{\n\tstruct inode\t*inode;\n\tstruct xfs_inode *cip = NULL;\n\tstruct xfs_name\tname;\n\tint\t\terror;\n\tumode_t\t\tmode;\n\n\tmode = S_IFLNK |\n\t\t(irix_symlink_mode ? 0777 & ~current_umask() : S_IRWXUGO);\n\txfs_dentry_to_name(&name, dentry, mode);\n\n\terror = xfs_symlink(XFS_I(dir), &name, symname, mode, &cip);\n\tif (unlikely(error))\n\t\tgoto out;\n\n\tinode = VFS_I(cip);\n\n\terror = xfs_init_security(inode, dir, &dentry->d_name);\n\tif (unlikely(error))\n\t\tgoto out_cleanup_inode;\n\n\td_instantiate(dentry, inode);\n\treturn 0;\n\n out_cleanup_inode:\n\txfs_cleanup_inode(dir, inode, dentry);\n\tiput(inode);\n out:\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_vn_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
    "lines": "319-341",
    "snippet": "STATIC int\nxfs_vn_unlink(\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry)\n{\n\tstruct xfs_name\tname;\n\tint\t\terror;\n\n\txfs_dentry_to_name(&name, dentry, 0);\n\n\terror = xfs_remove(XFS_I(dir), &name, XFS_I(dentry->d_inode));\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * With unlink, the VFS makes the dentry \"negative\": no inode,\n\t * but still hashed. This is incompatible with case-insensitive\n\t * mode, so invalidate (unhash) the dentry in CI-mode.\n\t */\n\tif (xfs_sb_version_hasasciici(&XFS_M(dir->i_sb)->m_sb))\n\t\td_invalidate(dentry);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/security.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/namei.h>",
      "#include <linux/xattr.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_acl.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_invalidate",
          "args": [
            "dentry"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "d_invalidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1465-1506",
          "snippet": "void d_invalidate(struct dentry *dentry)\n{\n\t/*\n\t * If it's already been dropped, return OK.\n\t */\n\tspin_lock(&dentry->d_lock);\n\tif (d_unhashed(dentry)) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\treturn;\n\t}\n\tspin_unlock(&dentry->d_lock);\n\n\t/* Negative dentries can be dropped without further checks */\n\tif (!dentry->d_inode) {\n\t\td_drop(dentry);\n\t\treturn;\n\t}\n\n\tfor (;;) {\n\t\tstruct detach_data data;\n\n\t\tdata.mountpoint = NULL;\n\t\tINIT_LIST_HEAD(&data.select.dispose);\n\t\tdata.select.start = dentry;\n\t\tdata.select.found = 0;\n\n\t\td_walk(dentry, &data, detach_and_collect, check_and_drop);\n\n\t\tif (data.select.found)\n\t\t\tshrink_dentry_list(&data.select.dispose);\n\n\t\tif (data.mountpoint) {\n\t\t\tdetach_mounts(data.mountpoint);\n\t\t\tdput(data.mountpoint);\n\t\t}\n\n\t\tif (!data.mountpoint && !data.select.found)\n\t\t\tbreak;\n\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid d_invalidate(struct dentry *dentry)\n{\n\t/*\n\t * If it's already been dropped, return OK.\n\t */\n\tspin_lock(&dentry->d_lock);\n\tif (d_unhashed(dentry)) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\treturn;\n\t}\n\tspin_unlock(&dentry->d_lock);\n\n\t/* Negative dentries can be dropped without further checks */\n\tif (!dentry->d_inode) {\n\t\td_drop(dentry);\n\t\treturn;\n\t}\n\n\tfor (;;) {\n\t\tstruct detach_data data;\n\n\t\tdata.mountpoint = NULL;\n\t\tINIT_LIST_HEAD(&data.select.dispose);\n\t\tdata.select.start = dentry;\n\t\tdata.select.found = 0;\n\n\t\td_walk(dentry, &data, detach_and_collect, check_and_drop);\n\n\t\tif (data.select.found)\n\t\t\tshrink_dentry_list(&data.select.dispose);\n\n\t\tif (data.mountpoint) {\n\t\t\tdetach_mounts(data.mountpoint);\n\t\t\tdput(data.mountpoint);\n\t\t}\n\n\t\tif (!data.mountpoint && !data.select.found)\n\t\t\tbreak;\n\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hasasciici",
          "args": [
            "&XFS_M(dir->i_sb)->m_sb"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hasasciici",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "427-430",
          "snippet": "static inline bool xfs_sb_version_hasasciici(struct xfs_sb *sbp)\n{\n\treturn (sbp->sb_versionnum & XFS_SB_VERSION_BORGBIT);\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_BORGBIT\t\t0x4000\t/* ASCII only case-insens. */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_BORGBIT\t\t0x4000\t/* ASCII only case-insens. */\n\nstatic inline bool xfs_sb_version_hasasciici(struct xfs_sb *sbp)\n{\n\treturn (sbp->sb_versionnum & XFS_SB_VERSION_BORGBIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_M",
          "args": [
            "dir->i_sb"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_remove",
          "args": [
            "XFS_I(dir)",
            "&name",
            "XFS_I(dentry->d_inode)"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "2474-2609",
          "snippet": "int\nxfs_remove(\n\txfs_inode_t             *dp,\n\tstruct xfs_name\t\t*name,\n\txfs_inode_t\t\t*ip)\n{\n\txfs_mount_t\t\t*mp = dp->i_mount;\n\txfs_trans_t             *tp = NULL;\n\tint\t\t\tis_dir = S_ISDIR(ip->i_d.di_mode);\n\tint                     error = 0;\n\txfs_bmap_free_t         free_list;\n\txfs_fsblock_t           first_block;\n\tint\t\t\tcancel_flags;\n\tint\t\t\tcommitted;\n\tuint\t\t\tresblks;\n\n\ttrace_xfs_remove(dp, name);\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\terror = xfs_qm_dqattach(dp, 0);\n\tif (error)\n\t\tgoto std_return;\n\n\terror = xfs_qm_dqattach(ip, 0);\n\tif (error)\n\t\tgoto std_return;\n\n\tif (is_dir)\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_RMDIR);\n\telse\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_REMOVE);\n\tcancel_flags = XFS_TRANS_RELEASE_LOG_RES;\n\n\t/*\n\t * We try to get the real space reservation first,\n\t * allowing for directory btree deletion(s) implying\n\t * possible bmap insert(s).  If we can't get the space\n\t * reservation then we use 0 instead, and avoid the bmap\n\t * btree insert(s) in the directory code by, if the bmap\n\t * insert tries to happen, instead trimming the LAST\n\t * block from the directory.\n\t */\n\tresblks = XFS_REMOVE_SPACE_RES(mp);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_remove, resblks, 0);\n\tif (error == -ENOSPC) {\n\t\tresblks = 0;\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_remove, 0, 0);\n\t}\n\tif (error) {\n\t\tASSERT(error != -ENOSPC);\n\t\tcancel_flags = 0;\n\t\tgoto out_trans_cancel;\n\t}\n\n\txfs_lock_two_inodes(dp, ip, XFS_ILOCK_EXCL);\n\n\txfs_trans_ijoin(tp, dp, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * If we're removing a directory perform some additional validation.\n\t */\n\tcancel_flags |= XFS_TRANS_ABORT;\n\tif (is_dir) {\n\t\tASSERT(ip->i_d.di_nlink >= 2);\n\t\tif (ip->i_d.di_nlink != 2) {\n\t\t\terror = -ENOTEMPTY;\n\t\t\tgoto out_trans_cancel;\n\t\t}\n\t\tif (!xfs_dir_isempty(ip)) {\n\t\t\terror = -ENOTEMPTY;\n\t\t\tgoto out_trans_cancel;\n\t\t}\n\n\t\t/* Drop the link from ip's \"..\".  */\n\t\terror = xfs_droplink(tp, dp);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\n\t\t/* Drop the \".\" link from ip to self.  */\n\t\terror = xfs_droplink(tp, ip);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\t} else {\n\t\t/*\n\t\t * When removing a non-directory we need to log the parent\n\t\t * inode here.  For a directory this is done implicitly\n\t\t * by the xfs_droplink call for the \"..\" entry.\n\t\t */\n\t\txfs_trans_log_inode(tp, dp, XFS_ILOG_CORE);\n\t}\n\txfs_trans_ichgtime(tp, dp, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\n\t/* Drop the link from dp to ip. */\n\terror = xfs_droplink(tp, ip);\n\tif (error)\n\t\tgoto out_trans_cancel;\n\n\txfs_bmap_init(&free_list, &first_block);\n\terror = xfs_dir_removename(tp, dp, name, ip->i_ino,\n\t\t\t\t\t&first_block, &free_list, resblks);\n\tif (error) {\n\t\tASSERT(error != -ENOENT);\n\t\tgoto out_bmap_cancel;\n\t}\n\n\t/*\n\t * If this is a synchronous mount, make sure that the\n\t * remove transaction goes to disk before returning to\n\t * the user.\n\t */\n\tif (mp->m_flags & (XFS_MOUNT_WSYNC|XFS_MOUNT_DIRSYNC))\n\t\txfs_trans_set_sync(tp);\n\n\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\tif (error)\n\t\tgoto out_bmap_cancel;\n\n\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\tif (error)\n\t\tgoto std_return;\n\n\tif (is_dir && xfs_inode_is_filestream(ip))\n\t\txfs_filestream_deassociate(ip);\n\n\treturn 0;\n\n out_bmap_cancel:\n\txfs_bmap_cancel(&free_list);\n out_trans_cancel:\n\txfs_trans_cancel(tp, cancel_flags);\n std_return:\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_remove(\n\txfs_inode_t             *dp,\n\tstruct xfs_name\t\t*name,\n\txfs_inode_t\t\t*ip)\n{\n\txfs_mount_t\t\t*mp = dp->i_mount;\n\txfs_trans_t             *tp = NULL;\n\tint\t\t\tis_dir = S_ISDIR(ip->i_d.di_mode);\n\tint                     error = 0;\n\txfs_bmap_free_t         free_list;\n\txfs_fsblock_t           first_block;\n\tint\t\t\tcancel_flags;\n\tint\t\t\tcommitted;\n\tuint\t\t\tresblks;\n\n\ttrace_xfs_remove(dp, name);\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\terror = xfs_qm_dqattach(dp, 0);\n\tif (error)\n\t\tgoto std_return;\n\n\terror = xfs_qm_dqattach(ip, 0);\n\tif (error)\n\t\tgoto std_return;\n\n\tif (is_dir)\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_RMDIR);\n\telse\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_REMOVE);\n\tcancel_flags = XFS_TRANS_RELEASE_LOG_RES;\n\n\t/*\n\t * We try to get the real space reservation first,\n\t * allowing for directory btree deletion(s) implying\n\t * possible bmap insert(s).  If we can't get the space\n\t * reservation then we use 0 instead, and avoid the bmap\n\t * btree insert(s) in the directory code by, if the bmap\n\t * insert tries to happen, instead trimming the LAST\n\t * block from the directory.\n\t */\n\tresblks = XFS_REMOVE_SPACE_RES(mp);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_remove, resblks, 0);\n\tif (error == -ENOSPC) {\n\t\tresblks = 0;\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_remove, 0, 0);\n\t}\n\tif (error) {\n\t\tASSERT(error != -ENOSPC);\n\t\tcancel_flags = 0;\n\t\tgoto out_trans_cancel;\n\t}\n\n\txfs_lock_two_inodes(dp, ip, XFS_ILOCK_EXCL);\n\n\txfs_trans_ijoin(tp, dp, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * If we're removing a directory perform some additional validation.\n\t */\n\tcancel_flags |= XFS_TRANS_ABORT;\n\tif (is_dir) {\n\t\tASSERT(ip->i_d.di_nlink >= 2);\n\t\tif (ip->i_d.di_nlink != 2) {\n\t\t\terror = -ENOTEMPTY;\n\t\t\tgoto out_trans_cancel;\n\t\t}\n\t\tif (!xfs_dir_isempty(ip)) {\n\t\t\terror = -ENOTEMPTY;\n\t\t\tgoto out_trans_cancel;\n\t\t}\n\n\t\t/* Drop the link from ip's \"..\".  */\n\t\terror = xfs_droplink(tp, dp);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\n\t\t/* Drop the \".\" link from ip to self.  */\n\t\terror = xfs_droplink(tp, ip);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\t} else {\n\t\t/*\n\t\t * When removing a non-directory we need to log the parent\n\t\t * inode here.  For a directory this is done implicitly\n\t\t * by the xfs_droplink call for the \"..\" entry.\n\t\t */\n\t\txfs_trans_log_inode(tp, dp, XFS_ILOG_CORE);\n\t}\n\txfs_trans_ichgtime(tp, dp, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\n\t/* Drop the link from dp to ip. */\n\terror = xfs_droplink(tp, ip);\n\tif (error)\n\t\tgoto out_trans_cancel;\n\n\txfs_bmap_init(&free_list, &first_block);\n\terror = xfs_dir_removename(tp, dp, name, ip->i_ino,\n\t\t\t\t\t&first_block, &free_list, resblks);\n\tif (error) {\n\t\tASSERT(error != -ENOENT);\n\t\tgoto out_bmap_cancel;\n\t}\n\n\t/*\n\t * If this is a synchronous mount, make sure that the\n\t * remove transaction goes to disk before returning to\n\t * the user.\n\t */\n\tif (mp->m_flags & (XFS_MOUNT_WSYNC|XFS_MOUNT_DIRSYNC))\n\t\txfs_trans_set_sync(tp);\n\n\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\tif (error)\n\t\tgoto out_bmap_cancel;\n\n\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\tif (error)\n\t\tgoto std_return;\n\n\tif (is_dir && xfs_inode_is_filestream(ip))\n\t\txfs_filestream_deassociate(ip);\n\n\treturn 0;\n\n out_bmap_cancel:\n\txfs_bmap_cancel(&free_list);\n out_trans_cancel:\n\txfs_trans_cancel(tp, cancel_flags);\n std_return:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "dentry->d_inode"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dentry_to_name",
          "args": [
            "&name",
            "dentry",
            "0"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dentry_to_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
          "lines": "98-107",
          "snippet": "static void\nxfs_dentry_to_name(\n\tstruct xfs_name\t*namep,\n\tstruct dentry\t*dentry,\n\tint\t\tmode)\n{\n\tnamep->name = dentry->d_name.name;\n\tnamep->len = dentry->d_name.len;\n\tnamep->type = xfs_mode_to_ftype[(mode & S_IFMT) >> S_SHIFT];\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/security.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/namei.h>",
            "#include <linux/xattr.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_acl.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nstatic void\nxfs_dentry_to_name(\n\tstruct xfs_name\t*namep,\n\tstruct dentry\t*dentry,\n\tint\t\tmode)\n{\n\tnamep->name = dentry->d_name.name;\n\tnamep->len = dentry->d_name.len;\n\tnamep->type = xfs_mode_to_ftype[(mode & S_IFMT) >> S_SHIFT];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_vn_unlink(\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry)\n{\n\tstruct xfs_name\tname;\n\tint\t\terror;\n\n\txfs_dentry_to_name(&name, dentry, 0);\n\n\terror = xfs_remove(XFS_I(dir), &name, XFS_I(dentry->d_inode));\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * With unlink, the VFS makes the dentry \"negative\": no inode,\n\t * but still hashed. This is incompatible with case-insensitive\n\t * mode, so invalidate (unhash) the dentry in CI-mode.\n\t */\n\tif (xfs_sb_version_hasasciici(&XFS_M(dir->i_sb)->m_sb))\n\t\td_invalidate(dentry);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_vn_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
    "lines": "298-317",
    "snippet": "STATIC int\nxfs_vn_link(\n\tstruct dentry\t*old_dentry,\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry)\n{\n\tstruct inode\t*inode = old_dentry->d_inode;\n\tstruct xfs_name\tname;\n\tint\t\terror;\n\n\txfs_dentry_to_name(&name, dentry, inode->i_mode);\n\n\terror = xfs_link(XFS_I(dir), XFS_I(inode), &name);\n\tif (unlikely(error))\n\t\treturn error;\n\n\tihold(inode);\n\td_instantiate(dentry, inode);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/security.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/namei.h>",
      "#include <linux/xattr.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_acl.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "inode"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_link",
          "args": [
            "XFS_I(dir)",
            "XFS_I(inode)",
            "&name"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "1362-1469",
          "snippet": "int\nxfs_link(\n\txfs_inode_t\t\t*tdp,\n\txfs_inode_t\t\t*sip,\n\tstruct xfs_name\t\t*target_name)\n{\n\txfs_mount_t\t\t*mp = tdp->i_mount;\n\txfs_trans_t\t\t*tp;\n\tint\t\t\terror;\n\txfs_bmap_free_t         free_list;\n\txfs_fsblock_t           first_block;\n\tint\t\t\tcancel_flags;\n\tint\t\t\tcommitted;\n\tint\t\t\tresblks;\n\n\ttrace_xfs_link(tdp, target_name);\n\n\tASSERT(!S_ISDIR(sip->i_d.di_mode));\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\terror = xfs_qm_dqattach(sip, 0);\n\tif (error)\n\t\tgoto std_return;\n\n\terror = xfs_qm_dqattach(tdp, 0);\n\tif (error)\n\t\tgoto std_return;\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_LINK);\n\tcancel_flags = XFS_TRANS_RELEASE_LOG_RES;\n\tresblks = XFS_LINK_SPACE_RES(mp, target_name->len);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_link, resblks, 0);\n\tif (error == -ENOSPC) {\n\t\tresblks = 0;\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_link, 0, 0);\n\t}\n\tif (error) {\n\t\tcancel_flags = 0;\n\t\tgoto error_return;\n\t}\n\n\txfs_lock_two_inodes(sip, tdp, XFS_ILOCK_EXCL);\n\n\txfs_trans_ijoin(tp, sip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, tdp, XFS_ILOCK_EXCL);\n\n\t/*\n\t * If we are using project inheritance, we only allow hard link\n\t * creation in our tree when the project IDs are the same; else\n\t * the tree quota mechanism could be circumvented.\n\t */\n\tif (unlikely((tdp->i_d.di_flags & XFS_DIFLAG_PROJINHERIT) &&\n\t\t     (xfs_get_projid(tdp) != xfs_get_projid(sip)))) {\n\t\terror = -EXDEV;\n\t\tgoto error_return;\n\t}\n\n\tif (!resblks) {\n\t\terror = xfs_dir_canenter(tp, tdp, target_name);\n\t\tif (error)\n\t\t\tgoto error_return;\n\t}\n\n\txfs_bmap_init(&free_list, &first_block);\n\n\tif (sip->i_d.di_nlink == 0) {\n\t\terror = xfs_iunlink_remove(tp, sip);\n\t\tif (error)\n\t\t\tgoto abort_return;\n\t}\n\n\terror = xfs_dir_createname(tp, tdp, target_name, sip->i_ino,\n\t\t\t\t\t&first_block, &free_list, resblks);\n\tif (error)\n\t\tgoto abort_return;\n\txfs_trans_ichgtime(tp, tdp, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\txfs_trans_log_inode(tp, tdp, XFS_ILOG_CORE);\n\n\terror = xfs_bumplink(tp, sip);\n\tif (error)\n\t\tgoto abort_return;\n\n\t/*\n\t * If this is a synchronous mount, make sure that the\n\t * link transaction goes to disk before returning to\n\t * the user.\n\t */\n\tif (mp->m_flags & (XFS_MOUNT_WSYNC|XFS_MOUNT_DIRSYNC)) {\n\t\txfs_trans_set_sync(tp);\n\t}\n\n\terror = xfs_bmap_finish (&tp, &free_list, &committed);\n\tif (error) {\n\t\txfs_bmap_cancel(&free_list);\n\t\tgoto abort_return;\n\t}\n\n\treturn xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\n abort_return:\n\tcancel_flags |= XFS_TRANS_ABORT;\n error_return:\n\txfs_trans_cancel(tp, cancel_flags);\n std_return:\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_link(\n\txfs_inode_t\t\t*tdp,\n\txfs_inode_t\t\t*sip,\n\tstruct xfs_name\t\t*target_name)\n{\n\txfs_mount_t\t\t*mp = tdp->i_mount;\n\txfs_trans_t\t\t*tp;\n\tint\t\t\terror;\n\txfs_bmap_free_t         free_list;\n\txfs_fsblock_t           first_block;\n\tint\t\t\tcancel_flags;\n\tint\t\t\tcommitted;\n\tint\t\t\tresblks;\n\n\ttrace_xfs_link(tdp, target_name);\n\n\tASSERT(!S_ISDIR(sip->i_d.di_mode));\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\terror = xfs_qm_dqattach(sip, 0);\n\tif (error)\n\t\tgoto std_return;\n\n\terror = xfs_qm_dqattach(tdp, 0);\n\tif (error)\n\t\tgoto std_return;\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_LINK);\n\tcancel_flags = XFS_TRANS_RELEASE_LOG_RES;\n\tresblks = XFS_LINK_SPACE_RES(mp, target_name->len);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_link, resblks, 0);\n\tif (error == -ENOSPC) {\n\t\tresblks = 0;\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_link, 0, 0);\n\t}\n\tif (error) {\n\t\tcancel_flags = 0;\n\t\tgoto error_return;\n\t}\n\n\txfs_lock_two_inodes(sip, tdp, XFS_ILOCK_EXCL);\n\n\txfs_trans_ijoin(tp, sip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, tdp, XFS_ILOCK_EXCL);\n\n\t/*\n\t * If we are using project inheritance, we only allow hard link\n\t * creation in our tree when the project IDs are the same; else\n\t * the tree quota mechanism could be circumvented.\n\t */\n\tif (unlikely((tdp->i_d.di_flags & XFS_DIFLAG_PROJINHERIT) &&\n\t\t     (xfs_get_projid(tdp) != xfs_get_projid(sip)))) {\n\t\terror = -EXDEV;\n\t\tgoto error_return;\n\t}\n\n\tif (!resblks) {\n\t\terror = xfs_dir_canenter(tp, tdp, target_name);\n\t\tif (error)\n\t\t\tgoto error_return;\n\t}\n\n\txfs_bmap_init(&free_list, &first_block);\n\n\tif (sip->i_d.di_nlink == 0) {\n\t\terror = xfs_iunlink_remove(tp, sip);\n\t\tif (error)\n\t\t\tgoto abort_return;\n\t}\n\n\terror = xfs_dir_createname(tp, tdp, target_name, sip->i_ino,\n\t\t\t\t\t&first_block, &free_list, resblks);\n\tif (error)\n\t\tgoto abort_return;\n\txfs_trans_ichgtime(tp, tdp, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\txfs_trans_log_inode(tp, tdp, XFS_ILOG_CORE);\n\n\terror = xfs_bumplink(tp, sip);\n\tif (error)\n\t\tgoto abort_return;\n\n\t/*\n\t * If this is a synchronous mount, make sure that the\n\t * link transaction goes to disk before returning to\n\t * the user.\n\t */\n\tif (mp->m_flags & (XFS_MOUNT_WSYNC|XFS_MOUNT_DIRSYNC)) {\n\t\txfs_trans_set_sync(tp);\n\t}\n\n\terror = xfs_bmap_finish (&tp, &free_list, &committed);\n\tif (error) {\n\t\txfs_bmap_cancel(&free_list);\n\t\tgoto abort_return;\n\t}\n\n\treturn xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\n abort_return:\n\tcancel_flags |= XFS_TRANS_ABORT;\n error_return:\n\txfs_trans_cancel(tp, cancel_flags);\n std_return:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "inode"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dentry_to_name",
          "args": [
            "&name",
            "dentry",
            "inode->i_mode"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dentry_to_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
          "lines": "98-107",
          "snippet": "static void\nxfs_dentry_to_name(\n\tstruct xfs_name\t*namep,\n\tstruct dentry\t*dentry,\n\tint\t\tmode)\n{\n\tnamep->name = dentry->d_name.name;\n\tnamep->len = dentry->d_name.len;\n\tnamep->type = xfs_mode_to_ftype[(mode & S_IFMT) >> S_SHIFT];\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/security.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/namei.h>",
            "#include <linux/xattr.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_acl.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nstatic void\nxfs_dentry_to_name(\n\tstruct xfs_name\t*namep,\n\tstruct dentry\t*dentry,\n\tint\t\tmode)\n{\n\tnamep->name = dentry->d_name.name;\n\tnamep->len = dentry->d_name.len;\n\tnamep->type = xfs_mode_to_ftype[(mode & S_IFMT) >> S_SHIFT];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_vn_link(\n\tstruct dentry\t*old_dentry,\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry)\n{\n\tstruct inode\t*inode = old_dentry->d_inode;\n\tstruct xfs_name\tname;\n\tint\t\terror;\n\n\txfs_dentry_to_name(&name, dentry, inode->i_mode);\n\n\terror = xfs_link(XFS_I(dir), XFS_I(inode), &name);\n\tif (unlikely(error))\n\t\treturn error;\n\n\tihold(inode);\n\td_instantiate(dentry, inode);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_vn_ci_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
    "lines": "258-296",
    "snippet": "dentry *\nxfs_vn_ci_lookup(\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry,\n\tunsigned int flags)\n{\n\tstruct xfs_inode *ip;\n\tstruct xfs_name\txname;\n\tstruct xfs_name ci_name;\n\tstruct qstr\tdname;\n\tint\t\terror;\n\n\tif (dentry->d_name.len >= MAXNAMELEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\txfs_dentry_to_name(&xname, dentry, 0);\n\terror = xfs_lookup(XFS_I(dir), &xname, &ip, &ci_name);\n\tif (unlikely(error)) {\n\t\tif (unlikely(error != -ENOENT))\n\t\t\treturn ERR_PTR(error);\n\t\t/*\n\t\t * call d_add(dentry, NULL) here when d_drop_negative_children\n\t\t * is called in xfs_vn_mknod (ie. allow negative dentries\n\t\t * with CI filesystems).\n\t\t */\n\t\treturn NULL;\n\t}\n\n\t/* if exact match, just splice and exit */\n\tif (!ci_name.name)\n\t\treturn d_splice_alias(VFS_I(ip), dentry);\n\n\t/* else case-insensitive match... */\n\tdname.name = ci_name.name;\n\tdname.len = ci_name.len;\n\tdentry = d_add_ci(dentry, VFS_I(ip), &dname);\n\tkmem_free(ci_name.name);\n\treturn dentry;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/security.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/namei.h>",
      "#include <linux/xattr.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_acl.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "ci_name.name"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_add_ci",
          "args": [
            "dentry",
            "VFS_I(ip)",
            "&dname"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "d_add_ci",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2020-2046",
          "snippet": "struct dentry *d_add_ci(struct dentry *dentry, struct inode *inode,\n\t\t\tstruct qstr *name)\n{\n\tstruct dentry *found;\n\tstruct dentry *new;\n\n\t/*\n\t * First check if a dentry matching the name already exists,\n\t * if not go ahead and create it now.\n\t */\n\tfound = d_hash_and_lookup(dentry->d_parent, name);\n\tif (!found) {\n\t\tnew = d_alloc(dentry->d_parent, name);\n\t\tif (!new) {\n\t\t\tfound = ERR_PTR(-ENOMEM);\n\t\t} else {\n\t\t\tfound = d_splice_alias(inode, new);\n\t\t\tif (found) {\n\t\t\t\tdput(new);\n\t\t\t\treturn found;\n\t\t\t}\n\t\t\treturn new;\n\t\t}\n\t}\n\tiput(inode);\n\treturn found;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_add_ci(struct dentry *dentry, struct inode *inode,\n\t\t\tstruct qstr *name)\n{\n\tstruct dentry *found;\n\tstruct dentry *new;\n\n\t/*\n\t * First check if a dentry matching the name already exists,\n\t * if not go ahead and create it now.\n\t */\n\tfound = d_hash_and_lookup(dentry->d_parent, name);\n\tif (!found) {\n\t\tnew = d_alloc(dentry->d_parent, name);\n\t\tif (!new) {\n\t\t\tfound = ERR_PTR(-ENOMEM);\n\t\t} else {\n\t\t\tfound = d_splice_alias(inode, new);\n\t\t\tif (found) {\n\t\t\t\tdput(new);\n\t\t\t\treturn found;\n\t\t\t}\n\t\t\treturn new;\n\t\t}\n\t}\n\tiput(inode);\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "ip"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "78-81",
          "snippet": "static inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_splice_alias",
          "args": [
            "VFS_I(ip)",
            "dentry"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "d_splice_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2741-2792",
          "snippet": "struct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nstruct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error != -ENOENT"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_lookup",
          "args": [
            "XFS_I(dir)",
            "&xname",
            "&ip",
            "&ci_name"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "570-605",
          "snippet": "int\nxfs_lookup(\n\txfs_inode_t\t\t*dp,\n\tstruct xfs_name\t\t*name,\n\txfs_inode_t\t\t**ipp,\n\tstruct xfs_name\t\t*ci_name)\n{\n\txfs_ino_t\t\tinum;\n\tint\t\t\terror;\n\tuint\t\t\tlock_mode;\n\n\ttrace_xfs_lookup(dp, name);\n\n\tif (XFS_FORCED_SHUTDOWN(dp->i_mount))\n\t\treturn -EIO;\n\n\tlock_mode = xfs_ilock_data_map_shared(dp);\n\terror = xfs_dir_lookup(NULL, dp, name, &inum, ci_name);\n\txfs_iunlock(dp, lock_mode);\n\n\tif (error)\n\t\tgoto out;\n\n\terror = xfs_iget(dp->i_mount, NULL, inum, 0, 0, ipp);\n\tif (error)\n\t\tgoto out_free_name;\n\n\treturn 0;\n\nout_free_name:\n\tif (ci_name)\n\t\tkmem_free(ci_name->name);\nout:\n\t*ipp = NULL;\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_lookup(\n\txfs_inode_t\t\t*dp,\n\tstruct xfs_name\t\t*name,\n\txfs_inode_t\t\t**ipp,\n\tstruct xfs_name\t\t*ci_name)\n{\n\txfs_ino_t\t\tinum;\n\tint\t\t\terror;\n\tuint\t\t\tlock_mode;\n\n\ttrace_xfs_lookup(dp, name);\n\n\tif (XFS_FORCED_SHUTDOWN(dp->i_mount))\n\t\treturn -EIO;\n\n\tlock_mode = xfs_ilock_data_map_shared(dp);\n\terror = xfs_dir_lookup(NULL, dp, name, &inum, ci_name);\n\txfs_iunlock(dp, lock_mode);\n\n\tif (error)\n\t\tgoto out;\n\n\terror = xfs_iget(dp->i_mount, NULL, inum, 0, 0, ipp);\n\tif (error)\n\t\tgoto out_free_name;\n\n\treturn 0;\n\nout_free_name:\n\tif (ci_name)\n\t\tkmem_free(ci_name->name);\nout:\n\t*ipp = NULL;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "dir"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dentry_to_name",
          "args": [
            "&xname",
            "dentry",
            "0"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dentry_to_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
          "lines": "98-107",
          "snippet": "static void\nxfs_dentry_to_name(\n\tstruct xfs_name\t*namep,\n\tstruct dentry\t*dentry,\n\tint\t\tmode)\n{\n\tnamep->name = dentry->d_name.name;\n\tnamep->len = dentry->d_name.len;\n\tnamep->type = xfs_mode_to_ftype[(mode & S_IFMT) >> S_SHIFT];\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/security.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/namei.h>",
            "#include <linux/xattr.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_acl.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nstatic void\nxfs_dentry_to_name(\n\tstruct xfs_name\t*namep,\n\tstruct dentry\t*dentry,\n\tint\t\tmode)\n{\n\tnamep->name = dentry->d_name.name;\n\tnamep->len = dentry->d_name.len;\n\tnamep->type = xfs_mode_to_ftype[(mode & S_IFMT) >> S_SHIFT];\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENAMETOOLONG"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\ndentry *\nxfs_vn_ci_lookup(\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry,\n\tunsigned int flags)\n{\n\tstruct xfs_inode *ip;\n\tstruct xfs_name\txname;\n\tstruct xfs_name ci_name;\n\tstruct qstr\tdname;\n\tint\t\terror;\n\n\tif (dentry->d_name.len >= MAXNAMELEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\txfs_dentry_to_name(&xname, dentry, 0);\n\terror = xfs_lookup(XFS_I(dir), &xname, &ip, &ci_name);\n\tif (unlikely(error)) {\n\t\tif (unlikely(error != -ENOENT))\n\t\t\treturn ERR_PTR(error);\n\t\t/*\n\t\t * call d_add(dentry, NULL) here when d_drop_negative_children\n\t\t * is called in xfs_vn_mknod (ie. allow negative dentries\n\t\t * with CI filesystems).\n\t\t */\n\t\treturn NULL;\n\t}\n\n\t/* if exact match, just splice and exit */\n\tif (!ci_name.name)\n\t\treturn d_splice_alias(VFS_I(ip), dentry);\n\n\t/* else case-insensitive match... */\n\tdname.name = ci_name.name;\n\tdname.len = ci_name.len;\n\tdentry = d_add_ci(dentry, VFS_I(ip), &dname);\n\tkmem_free(ci_name.name);\n\treturn dentry;\n}"
  },
  {
    "function_name": "xfs_vn_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
    "lines": "233-256",
    "snippet": "dentry *\nxfs_vn_lookup(\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry,\n\tunsigned int flags)\n{\n\tstruct xfs_inode *cip;\n\tstruct xfs_name\tname;\n\tint\t\terror;\n\n\tif (dentry->d_name.len >= MAXNAMELEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\txfs_dentry_to_name(&name, dentry, 0);\n\terror = xfs_lookup(XFS_I(dir), &name, &cip, NULL);\n\tif (unlikely(error)) {\n\t\tif (unlikely(error != -ENOENT))\n\t\t\treturn ERR_PTR(error);\n\t\td_add(dentry, NULL);\n\t\treturn NULL;\n\t}\n\n\treturn d_splice_alias(VFS_I(cip), dentry);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/security.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/namei.h>",
      "#include <linux/xattr.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_acl.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_splice_alias",
          "args": [
            "VFS_I(cip)",
            "dentry"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "d_splice_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2741-2792",
          "snippet": "struct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nstruct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "cip"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "78-81",
          "snippet": "static inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dentry",
            "NULL"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error != -ENOENT"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_lookup",
          "args": [
            "XFS_I(dir)",
            "&name",
            "&cip",
            "NULL"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "570-605",
          "snippet": "int\nxfs_lookup(\n\txfs_inode_t\t\t*dp,\n\tstruct xfs_name\t\t*name,\n\txfs_inode_t\t\t**ipp,\n\tstruct xfs_name\t\t*ci_name)\n{\n\txfs_ino_t\t\tinum;\n\tint\t\t\terror;\n\tuint\t\t\tlock_mode;\n\n\ttrace_xfs_lookup(dp, name);\n\n\tif (XFS_FORCED_SHUTDOWN(dp->i_mount))\n\t\treturn -EIO;\n\n\tlock_mode = xfs_ilock_data_map_shared(dp);\n\terror = xfs_dir_lookup(NULL, dp, name, &inum, ci_name);\n\txfs_iunlock(dp, lock_mode);\n\n\tif (error)\n\t\tgoto out;\n\n\terror = xfs_iget(dp->i_mount, NULL, inum, 0, 0, ipp);\n\tif (error)\n\t\tgoto out_free_name;\n\n\treturn 0;\n\nout_free_name:\n\tif (ci_name)\n\t\tkmem_free(ci_name->name);\nout:\n\t*ipp = NULL;\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_lookup(\n\txfs_inode_t\t\t*dp,\n\tstruct xfs_name\t\t*name,\n\txfs_inode_t\t\t**ipp,\n\tstruct xfs_name\t\t*ci_name)\n{\n\txfs_ino_t\t\tinum;\n\tint\t\t\terror;\n\tuint\t\t\tlock_mode;\n\n\ttrace_xfs_lookup(dp, name);\n\n\tif (XFS_FORCED_SHUTDOWN(dp->i_mount))\n\t\treturn -EIO;\n\n\tlock_mode = xfs_ilock_data_map_shared(dp);\n\terror = xfs_dir_lookup(NULL, dp, name, &inum, ci_name);\n\txfs_iunlock(dp, lock_mode);\n\n\tif (error)\n\t\tgoto out;\n\n\terror = xfs_iget(dp->i_mount, NULL, inum, 0, 0, ipp);\n\tif (error)\n\t\tgoto out_free_name;\n\n\treturn 0;\n\nout_free_name:\n\tif (ci_name)\n\t\tkmem_free(ci_name->name);\nout:\n\t*ipp = NULL;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "dir"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dentry_to_name",
          "args": [
            "&name",
            "dentry",
            "0"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dentry_to_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
          "lines": "98-107",
          "snippet": "static void\nxfs_dentry_to_name(\n\tstruct xfs_name\t*namep,\n\tstruct dentry\t*dentry,\n\tint\t\tmode)\n{\n\tnamep->name = dentry->d_name.name;\n\tnamep->len = dentry->d_name.len;\n\tnamep->type = xfs_mode_to_ftype[(mode & S_IFMT) >> S_SHIFT];\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/security.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/namei.h>",
            "#include <linux/xattr.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_acl.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nstatic void\nxfs_dentry_to_name(\n\tstruct xfs_name\t*namep,\n\tstruct dentry\t*dentry,\n\tint\t\tmode)\n{\n\tnamep->name = dentry->d_name.name;\n\tnamep->len = dentry->d_name.len;\n\tnamep->type = xfs_mode_to_ftype[(mode & S_IFMT) >> S_SHIFT];\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENAMETOOLONG"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\ndentry *\nxfs_vn_lookup(\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry,\n\tunsigned int flags)\n{\n\tstruct xfs_inode *cip;\n\tstruct xfs_name\tname;\n\tint\t\terror;\n\n\tif (dentry->d_name.len >= MAXNAMELEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\txfs_dentry_to_name(&name, dentry, 0);\n\terror = xfs_lookup(XFS_I(dir), &name, &cip, NULL);\n\tif (unlikely(error)) {\n\t\tif (unlikely(error != -ENOENT))\n\t\t\treturn ERR_PTR(error);\n\t\td_add(dentry, NULL);\n\t\treturn NULL;\n\t}\n\n\treturn d_splice_alias(VFS_I(cip), dentry);\n}"
  },
  {
    "function_name": "xfs_vn_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
    "lines": "224-231",
    "snippet": "STATIC int\nxfs_vn_mkdir(\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry,\n\tumode_t\t\tmode)\n{\n\treturn xfs_vn_mknod(dir, dentry, mode|S_IFDIR, 0);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/security.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/namei.h>",
      "#include <linux/xattr.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_acl.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_vn_mknod",
          "args": [
            "dir",
            "dentry",
            "mode|S_IFDIR",
            "0"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_vn_mknod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
          "lines": "204-212",
          "snippet": "STATIC int\nxfs_vn_mknod(\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry,\n\tumode_t\t\tmode,\n\tdev_t\t\trdev)\n{\n\treturn xfs_generic_create(dir, dentry, mode, rdev, false);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/security.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/namei.h>",
            "#include <linux/xattr.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_acl.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_vn_mknod(\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry,\n\tumode_t\t\tmode,\n\tdev_t\t\trdev)\n{\n\treturn xfs_generic_create(dir, dentry, mode, rdev, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_vn_mkdir(\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry,\n\tumode_t\t\tmode)\n{\n\treturn xfs_vn_mknod(dir, dentry, mode|S_IFDIR, 0);\n}"
  },
  {
    "function_name": "xfs_vn_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
    "lines": "214-222",
    "snippet": "STATIC int\nxfs_vn_create(\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry,\n\tumode_t\t\tmode,\n\tbool\t\tflags)\n{\n\treturn xfs_vn_mknod(dir, dentry, mode, 0);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/security.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/namei.h>",
      "#include <linux/xattr.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_acl.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_vn_mknod",
          "args": [
            "dir",
            "dentry",
            "mode",
            "0"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_vn_mknod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
          "lines": "204-212",
          "snippet": "STATIC int\nxfs_vn_mknod(\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry,\n\tumode_t\t\tmode,\n\tdev_t\t\trdev)\n{\n\treturn xfs_generic_create(dir, dentry, mode, rdev, false);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/security.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/namei.h>",
            "#include <linux/xattr.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_acl.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_vn_mknod(\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry,\n\tumode_t\t\tmode,\n\tdev_t\t\trdev)\n{\n\treturn xfs_generic_create(dir, dentry, mode, rdev, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_vn_create(\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry,\n\tumode_t\t\tmode,\n\tbool\t\tflags)\n{\n\treturn xfs_vn_mknod(dir, dentry, mode, 0);\n}"
  },
  {
    "function_name": "xfs_vn_mknod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
    "lines": "204-212",
    "snippet": "STATIC int\nxfs_vn_mknod(\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry,\n\tumode_t\t\tmode,\n\tdev_t\t\trdev)\n{\n\treturn xfs_generic_create(dir, dentry, mode, rdev, false);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/security.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/namei.h>",
      "#include <linux/xattr.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_acl.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_generic_create",
          "args": [
            "dir",
            "dentry",
            "mode",
            "rdev",
            "false"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_generic_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
          "lines": "127-202",
          "snippet": "STATIC int\nxfs_generic_create(\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry,\n\tumode_t\t\tmode,\n\tdev_t\t\trdev,\n\tbool\t\ttmpfile)\t/* unnamed file */\n{\n\tstruct inode\t*inode;\n\tstruct xfs_inode *ip = NULL;\n\tstruct posix_acl *default_acl, *acl;\n\tstruct xfs_name\tname;\n\tint\t\terror;\n\n\t/*\n\t * Irix uses Missed'em'V split, but doesn't want to see\n\t * the upper 5 bits of (14bit) major.\n\t */\n\tif (S_ISCHR(mode) || S_ISBLK(mode)) {\n\t\tif (unlikely(!sysv_valid_dev(rdev) || MAJOR(rdev) & ~0x1ff))\n\t\t\treturn -EINVAL;\n\t\trdev = sysv_encode_dev(rdev);\n\t} else {\n\t\trdev = 0;\n\t}\n\n\terror = posix_acl_create(dir, &mode, &default_acl, &acl);\n\tif (error)\n\t\treturn error;\n\n\tif (!tmpfile) {\n\t\txfs_dentry_to_name(&name, dentry, mode);\n\t\terror = xfs_create(XFS_I(dir), &name, mode, rdev, &ip);\n\t} else {\n\t\terror = xfs_create_tmpfile(XFS_I(dir), dentry, mode, &ip);\n\t}\n\tif (unlikely(error))\n\t\tgoto out_free_acl;\n\n\tinode = VFS_I(ip);\n\n\terror = xfs_init_security(inode, dir, &dentry->d_name);\n\tif (unlikely(error))\n\t\tgoto out_cleanup_inode;\n\n#ifdef CONFIG_XFS_POSIX_ACL\n\tif (default_acl) {\n\t\terror = xfs_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);\n\t\tif (error)\n\t\t\tgoto out_cleanup_inode;\n\t}\n\tif (acl) {\n\t\terror = xfs_set_acl(inode, acl, ACL_TYPE_ACCESS);\n\t\tif (error)\n\t\t\tgoto out_cleanup_inode;\n\t}\n#endif\n\n\tif (tmpfile)\n\t\td_tmpfile(dentry, inode);\n\telse\n\t\td_instantiate(dentry, inode);\n\n out_free_acl:\n\tif (default_acl)\n\t\tposix_acl_release(default_acl);\n\tif (acl)\n\t\tposix_acl_release(acl);\n\treturn error;\n\n out_cleanup_inode:\n\tif (!tmpfile)\n\t\txfs_cleanup_inode(dir, inode, dentry);\n\tiput(inode);\n\tgoto out_free_acl;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/security.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/namei.h>",
            "#include <linux/xattr.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_acl.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_generic_create(\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry,\n\tumode_t\t\tmode,\n\tdev_t\t\trdev,\n\tbool\t\ttmpfile)\t/* unnamed file */\n{\n\tstruct inode\t*inode;\n\tstruct xfs_inode *ip = NULL;\n\tstruct posix_acl *default_acl, *acl;\n\tstruct xfs_name\tname;\n\tint\t\terror;\n\n\t/*\n\t * Irix uses Missed'em'V split, but doesn't want to see\n\t * the upper 5 bits of (14bit) major.\n\t */\n\tif (S_ISCHR(mode) || S_ISBLK(mode)) {\n\t\tif (unlikely(!sysv_valid_dev(rdev) || MAJOR(rdev) & ~0x1ff))\n\t\t\treturn -EINVAL;\n\t\trdev = sysv_encode_dev(rdev);\n\t} else {\n\t\trdev = 0;\n\t}\n\n\terror = posix_acl_create(dir, &mode, &default_acl, &acl);\n\tif (error)\n\t\treturn error;\n\n\tif (!tmpfile) {\n\t\txfs_dentry_to_name(&name, dentry, mode);\n\t\terror = xfs_create(XFS_I(dir), &name, mode, rdev, &ip);\n\t} else {\n\t\terror = xfs_create_tmpfile(XFS_I(dir), dentry, mode, &ip);\n\t}\n\tif (unlikely(error))\n\t\tgoto out_free_acl;\n\n\tinode = VFS_I(ip);\n\n\terror = xfs_init_security(inode, dir, &dentry->d_name);\n\tif (unlikely(error))\n\t\tgoto out_cleanup_inode;\n\n#ifdef CONFIG_XFS_POSIX_ACL\n\tif (default_acl) {\n\t\terror = xfs_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);\n\t\tif (error)\n\t\t\tgoto out_cleanup_inode;\n\t}\n\tif (acl) {\n\t\terror = xfs_set_acl(inode, acl, ACL_TYPE_ACCESS);\n\t\tif (error)\n\t\t\tgoto out_cleanup_inode;\n\t}\n#endif\n\n\tif (tmpfile)\n\t\td_tmpfile(dentry, inode);\n\telse\n\t\td_instantiate(dentry, inode);\n\n out_free_acl:\n\tif (default_acl)\n\t\tposix_acl_release(default_acl);\n\tif (acl)\n\t\tposix_acl_release(acl);\n\treturn error;\n\n out_cleanup_inode:\n\tif (!tmpfile)\n\t\txfs_cleanup_inode(dir, inode, dentry);\n\tiput(inode);\n\tgoto out_free_acl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_vn_mknod(\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry,\n\tumode_t\t\tmode,\n\tdev_t\t\trdev)\n{\n\treturn xfs_generic_create(dir, dentry, mode, rdev, false);\n}"
  },
  {
    "function_name": "xfs_generic_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
    "lines": "127-202",
    "snippet": "STATIC int\nxfs_generic_create(\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry,\n\tumode_t\t\tmode,\n\tdev_t\t\trdev,\n\tbool\t\ttmpfile)\t/* unnamed file */\n{\n\tstruct inode\t*inode;\n\tstruct xfs_inode *ip = NULL;\n\tstruct posix_acl *default_acl, *acl;\n\tstruct xfs_name\tname;\n\tint\t\terror;\n\n\t/*\n\t * Irix uses Missed'em'V split, but doesn't want to see\n\t * the upper 5 bits of (14bit) major.\n\t */\n\tif (S_ISCHR(mode) || S_ISBLK(mode)) {\n\t\tif (unlikely(!sysv_valid_dev(rdev) || MAJOR(rdev) & ~0x1ff))\n\t\t\treturn -EINVAL;\n\t\trdev = sysv_encode_dev(rdev);\n\t} else {\n\t\trdev = 0;\n\t}\n\n\terror = posix_acl_create(dir, &mode, &default_acl, &acl);\n\tif (error)\n\t\treturn error;\n\n\tif (!tmpfile) {\n\t\txfs_dentry_to_name(&name, dentry, mode);\n\t\terror = xfs_create(XFS_I(dir), &name, mode, rdev, &ip);\n\t} else {\n\t\terror = xfs_create_tmpfile(XFS_I(dir), dentry, mode, &ip);\n\t}\n\tif (unlikely(error))\n\t\tgoto out_free_acl;\n\n\tinode = VFS_I(ip);\n\n\terror = xfs_init_security(inode, dir, &dentry->d_name);\n\tif (unlikely(error))\n\t\tgoto out_cleanup_inode;\n\n#ifdef CONFIG_XFS_POSIX_ACL\n\tif (default_acl) {\n\t\terror = xfs_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);\n\t\tif (error)\n\t\t\tgoto out_cleanup_inode;\n\t}\n\tif (acl) {\n\t\terror = xfs_set_acl(inode, acl, ACL_TYPE_ACCESS);\n\t\tif (error)\n\t\t\tgoto out_cleanup_inode;\n\t}\n#endif\n\n\tif (tmpfile)\n\t\td_tmpfile(dentry, inode);\n\telse\n\t\td_instantiate(dentry, inode);\n\n out_free_acl:\n\tif (default_acl)\n\t\tposix_acl_release(default_acl);\n\tif (acl)\n\t\tposix_acl_release(acl);\n\treturn error;\n\n out_cleanup_inode:\n\tif (!tmpfile)\n\t\txfs_cleanup_inode(dir, inode, dentry);\n\tiput(inode);\n\tgoto out_free_acl;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/security.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/namei.h>",
      "#include <linux/xattr.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_acl.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_cleanup_inode",
          "args": [
            "dir",
            "inode",
            "dentry"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_cleanup_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
          "lines": "109-125",
          "snippet": "STATIC void\nxfs_cleanup_inode(\n\tstruct inode\t*dir,\n\tstruct inode\t*inode,\n\tstruct dentry\t*dentry)\n{\n\tstruct xfs_name\tteardown;\n\n\t/* Oh, the horror.\n\t * If we can't add the ACL or we fail in\n\t * xfs_init_security we must back out.\n\t * ENOSPC can hit here, among other things.\n\t */\n\txfs_dentry_to_name(&teardown, dentry, 0);\n\n\txfs_remove(XFS_I(dir), &teardown, XFS_I(inode));\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/security.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/namei.h>",
            "#include <linux/xattr.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_acl.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_cleanup_inode(\n\tstruct inode\t*dir,\n\tstruct inode\t*inode,\n\tstruct dentry\t*dentry)\n{\n\tstruct xfs_name\tteardown;\n\n\t/* Oh, the horror.\n\t * If we can't add the ACL or we fail in\n\t * xfs_init_security we must back out.\n\t * ENOSPC can hit here, among other things.\n\t */\n\txfs_dentry_to_name(&teardown, dentry, 0);\n\n\txfs_remove(XFS_I(dir), &teardown, XFS_I(inode));\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "acl"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "default_acl"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_tmpfile",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "d_tmpfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "3325-3338",
          "snippet": "void d_tmpfile(struct dentry *dentry, struct inode *inode)\n{\n\tinode_dec_link_count(inode);\n\tBUG_ON(dentry->d_name.name != dentry->d_iname ||\n\t\t!hlist_unhashed(&dentry->d_u.d_alias) ||\n\t\t!d_unlinked(dentry));\n\tspin_lock(&dentry->d_parent->d_lock);\n\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\tdentry->d_name.len = sprintf(dentry->d_iname, \"#%llu\",\n\t\t\t\t(unsigned long long)inode->i_ino);\n\tspin_unlock(&dentry->d_lock);\n\tspin_unlock(&dentry->d_parent->d_lock);\n\td_instantiate(dentry, inode);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid d_tmpfile(struct dentry *dentry, struct inode *inode)\n{\n\tinode_dec_link_count(inode);\n\tBUG_ON(dentry->d_name.name != dentry->d_iname ||\n\t\t!hlist_unhashed(&dentry->d_u.d_alias) ||\n\t\t!d_unlinked(dentry));\n\tspin_lock(&dentry->d_parent->d_lock);\n\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\tdentry->d_name.len = sprintf(dentry->d_iname, \"#%llu\",\n\t\t\t\t(unsigned long long)inode->i_ino);\n\tspin_unlock(&dentry->d_lock);\n\tspin_unlock(&dentry->d_parent->d_lock);\n\td_instantiate(dentry, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_set_acl",
          "args": [
            "inode",
            "acl",
            "ACL_TYPE_ACCESS"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_set_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_acl.c",
          "lines": "274-304",
          "snippet": "int\nxfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint error = 0;\n\n\tif (!acl)\n\t\tgoto set_acl;\n\n\terror = -E2BIG;\n\tif (acl->a_count > XFS_ACL_MAX_ENTRIES(XFS_M(inode->i_sb)))\n\t\treturn error;\n\n\tif (type == ACL_TYPE_ACCESS) {\n\t\tumode_t mode = inode->i_mode;\n\t\terror = posix_acl_equiv_mode(acl, &mode);\n\n\t\tif (error <= 0) {\n\t\t\tacl = NULL;\n\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t}\n\n\t\terror = xfs_set_mode(inode, mode);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n set_acl:\n\treturn __xfs_set_acl(inode, type, acl);\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_acl.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include \"xfs_trace.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint error = 0;\n\n\tif (!acl)\n\t\tgoto set_acl;\n\n\terror = -E2BIG;\n\tif (acl->a_count > XFS_ACL_MAX_ENTRIES(XFS_M(inode->i_sb)))\n\t\treturn error;\n\n\tif (type == ACL_TYPE_ACCESS) {\n\t\tumode_t mode = inode->i_mode;\n\t\terror = posix_acl_equiv_mode(acl, &mode);\n\n\t\tif (error <= 0) {\n\t\t\tacl = NULL;\n\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t}\n\n\t\terror = xfs_set_mode(inode, mode);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n set_acl:\n\treturn __xfs_set_acl(inode, type, acl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_init_security",
          "args": [
            "inode",
            "dir",
            "&dentry->d_name"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_init_security",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
          "lines": "88-96",
          "snippet": "STATIC int\nxfs_init_security(\n\tstruct inode\t*inode,\n\tstruct inode\t*dir,\n\tconst struct qstr *qstr)\n{\n\treturn security_inode_init_security(inode, dir, qstr,\n\t\t\t\t\t     &xfs_initxattrs, NULL);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/security.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/namei.h>",
            "#include <linux/xattr.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_acl.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_init_security(\n\tstruct inode\t*inode,\n\tstruct inode\t*dir,\n\tconst struct qstr *qstr)\n{\n\treturn security_inode_init_security(inode, dir, qstr,\n\t\t\t\t\t     &xfs_initxattrs, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "ip"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "78-81",
          "snippet": "static inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_create_tmpfile",
          "args": [
            "XFS_I(dir)",
            "dentry",
            "mode",
            "&ip"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_create_tmpfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "1254-1360",
          "snippet": "int\nxfs_create_tmpfile(\n\tstruct xfs_inode\t*dp,\n\tstruct dentry\t\t*dentry,\n\tumode_t\t\t\tmode,\n\tstruct xfs_inode\t**ipp)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_inode\t*ip = NULL;\n\tstruct xfs_trans\t*tp = NULL;\n\tint\t\t\terror;\n\tuint\t\t\tcancel_flags = XFS_TRANS_RELEASE_LOG_RES;\n\tprid_t                  prid;\n\tstruct xfs_dquot\t*udqp = NULL;\n\tstruct xfs_dquot\t*gdqp = NULL;\n\tstruct xfs_dquot\t*pdqp = NULL;\n\tstruct xfs_trans_res\t*tres;\n\tuint\t\t\tresblks;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tprid = xfs_get_initial_prid(dp);\n\n\t/*\n\t * Make sure that we have allocated dquot(s) on disk.\n\t */\n\terror = xfs_qm_vop_dqalloc(dp, xfs_kuid_to_uid(current_fsuid()),\n\t\t\t\txfs_kgid_to_gid(current_fsgid()), prid,\n\t\t\t\tXFS_QMOPT_QUOTALL | XFS_QMOPT_INHERIT,\n\t\t\t\t&udqp, &gdqp, &pdqp);\n\tif (error)\n\t\treturn error;\n\n\tresblks = XFS_IALLOC_SPACE_RES(mp);\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_CREATE_TMPFILE);\n\n\ttres = &M_RES(mp)->tr_create_tmpfile;\n\terror = xfs_trans_reserve(tp, tres, resblks, 0);\n\tif (error == -ENOSPC) {\n\t\t/* No space at all so try a \"no-allocation\" reservation */\n\t\tresblks = 0;\n\t\terror = xfs_trans_reserve(tp, tres, 0, 0);\n\t}\n\tif (error) {\n\t\tcancel_flags = 0;\n\t\tgoto out_trans_cancel;\n\t}\n\n\terror = xfs_trans_reserve_quota(tp, mp, udqp, gdqp,\n\t\t\t\t\t\tpdqp, resblks, 1, 0);\n\tif (error)\n\t\tgoto out_trans_cancel;\n\n\terror = xfs_dir_ialloc(&tp, dp, mode, 1, 0,\n\t\t\t\tprid, resblks > 0, &ip, NULL);\n\tif (error) {\n\t\tif (error == -ENOSPC)\n\t\t\tgoto out_trans_cancel;\n\t\tgoto out_trans_abort;\n\t}\n\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(tp);\n\n\t/*\n\t * Attach the dquot(s) to the inodes and modify them incore.\n\t * These ids of the inode couldn't have changed since the new\n\t * inode has been locked ever since it was created.\n\t */\n\txfs_qm_vop_create_dqattach(tp, ip, udqp, gdqp, pdqp);\n\n\tip->i_d.di_nlink--;\n\terror = xfs_iunlink(tp, ip);\n\tif (error)\n\t\tgoto out_trans_abort;\n\n\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\tif (error)\n\t\tgoto out_release_inode;\n\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\txfs_qm_dqrele(pdqp);\n\n\t*ipp = ip;\n\treturn 0;\n\n out_trans_abort:\n\tcancel_flags |= XFS_TRANS_ABORT;\n out_trans_cancel:\n\txfs_trans_cancel(tp, cancel_flags);\n out_release_inode:\n\t/*\n\t * Wait until after the current transaction is aborted to\n\t * release the inode.  This prevents recursive transactions\n\t * and deadlocks from xfs_inactive.\n\t */\n\tif (ip)\n\t\tIRELE(ip);\n\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\txfs_qm_dqrele(pdqp);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nint\nxfs_create_tmpfile(\n\tstruct xfs_inode\t*dp,\n\tstruct dentry\t\t*dentry,\n\tumode_t\t\t\tmode,\n\tstruct xfs_inode\t**ipp)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_inode\t*ip = NULL;\n\tstruct xfs_trans\t*tp = NULL;\n\tint\t\t\terror;\n\tuint\t\t\tcancel_flags = XFS_TRANS_RELEASE_LOG_RES;\n\tprid_t                  prid;\n\tstruct xfs_dquot\t*udqp = NULL;\n\tstruct xfs_dquot\t*gdqp = NULL;\n\tstruct xfs_dquot\t*pdqp = NULL;\n\tstruct xfs_trans_res\t*tres;\n\tuint\t\t\tresblks;\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tprid = xfs_get_initial_prid(dp);\n\n\t/*\n\t * Make sure that we have allocated dquot(s) on disk.\n\t */\n\terror = xfs_qm_vop_dqalloc(dp, xfs_kuid_to_uid(current_fsuid()),\n\t\t\t\txfs_kgid_to_gid(current_fsgid()), prid,\n\t\t\t\tXFS_QMOPT_QUOTALL | XFS_QMOPT_INHERIT,\n\t\t\t\t&udqp, &gdqp, &pdqp);\n\tif (error)\n\t\treturn error;\n\n\tresblks = XFS_IALLOC_SPACE_RES(mp);\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_CREATE_TMPFILE);\n\n\ttres = &M_RES(mp)->tr_create_tmpfile;\n\terror = xfs_trans_reserve(tp, tres, resblks, 0);\n\tif (error == -ENOSPC) {\n\t\t/* No space at all so try a \"no-allocation\" reservation */\n\t\tresblks = 0;\n\t\terror = xfs_trans_reserve(tp, tres, 0, 0);\n\t}\n\tif (error) {\n\t\tcancel_flags = 0;\n\t\tgoto out_trans_cancel;\n\t}\n\n\terror = xfs_trans_reserve_quota(tp, mp, udqp, gdqp,\n\t\t\t\t\t\tpdqp, resblks, 1, 0);\n\tif (error)\n\t\tgoto out_trans_cancel;\n\n\terror = xfs_dir_ialloc(&tp, dp, mode, 1, 0,\n\t\t\t\tprid, resblks > 0, &ip, NULL);\n\tif (error) {\n\t\tif (error == -ENOSPC)\n\t\t\tgoto out_trans_cancel;\n\t\tgoto out_trans_abort;\n\t}\n\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(tp);\n\n\t/*\n\t * Attach the dquot(s) to the inodes and modify them incore.\n\t * These ids of the inode couldn't have changed since the new\n\t * inode has been locked ever since it was created.\n\t */\n\txfs_qm_vop_create_dqattach(tp, ip, udqp, gdqp, pdqp);\n\n\tip->i_d.di_nlink--;\n\terror = xfs_iunlink(tp, ip);\n\tif (error)\n\t\tgoto out_trans_abort;\n\n\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\tif (error)\n\t\tgoto out_release_inode;\n\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\txfs_qm_dqrele(pdqp);\n\n\t*ipp = ip;\n\treturn 0;\n\n out_trans_abort:\n\tcancel_flags |= XFS_TRANS_ABORT;\n out_trans_cancel:\n\txfs_trans_cancel(tp, cancel_flags);\n out_release_inode:\n\t/*\n\t * Wait until after the current transaction is aborted to\n\t * release the inode.  This prevents recursive transactions\n\t * and deadlocks from xfs_inactive.\n\t */\n\tif (ip)\n\t\tIRELE(ip);\n\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\txfs_qm_dqrele(pdqp);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "dir"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_create",
          "args": [
            "XFS_I(dir)",
            "&name",
            "mode",
            "rdev",
            "&ip"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "1061-1252",
          "snippet": "int\nxfs_create(\n\txfs_inode_t\t\t*dp,\n\tstruct xfs_name\t\t*name,\n\tumode_t\t\t\tmode,\n\txfs_dev_t\t\trdev,\n\txfs_inode_t\t\t**ipp)\n{\n\tint\t\t\tis_dir = S_ISDIR(mode);\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_inode\t*ip = NULL;\n\tstruct xfs_trans\t*tp = NULL;\n\tint\t\t\terror;\n\txfs_bmap_free_t\t\tfree_list;\n\txfs_fsblock_t\t\tfirst_block;\n\tbool                    unlock_dp_on_error = false;\n\tuint\t\t\tcancel_flags;\n\tint\t\t\tcommitted;\n\tprid_t\t\t\tprid;\n\tstruct xfs_dquot\t*udqp = NULL;\n\tstruct xfs_dquot\t*gdqp = NULL;\n\tstruct xfs_dquot\t*pdqp = NULL;\n\tstruct xfs_trans_res\t*tres;\n\tuint\t\t\tresblks;\n\n\ttrace_xfs_create(dp, name);\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tprid = xfs_get_initial_prid(dp);\n\n\t/*\n\t * Make sure that we have allocated dquot(s) on disk.\n\t */\n\terror = xfs_qm_vop_dqalloc(dp, xfs_kuid_to_uid(current_fsuid()),\n\t\t\t\t\txfs_kgid_to_gid(current_fsgid()), prid,\n\t\t\t\t\tXFS_QMOPT_QUOTALL | XFS_QMOPT_INHERIT,\n\t\t\t\t\t&udqp, &gdqp, &pdqp);\n\tif (error)\n\t\treturn error;\n\n\tif (is_dir) {\n\t\trdev = 0;\n\t\tresblks = XFS_MKDIR_SPACE_RES(mp, name->len);\n\t\ttres = &M_RES(mp)->tr_mkdir;\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_MKDIR);\n\t} else {\n\t\tresblks = XFS_CREATE_SPACE_RES(mp, name->len);\n\t\ttres = &M_RES(mp)->tr_create;\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_CREATE);\n\t}\n\n\tcancel_flags = XFS_TRANS_RELEASE_LOG_RES;\n\n\t/*\n\t * Initially assume that the file does not exist and\n\t * reserve the resources for that case.  If that is not\n\t * the case we'll drop the one we have and get a more\n\t * appropriate transaction later.\n\t */\n\terror = xfs_trans_reserve(tp, tres, resblks, 0);\n\tif (error == -ENOSPC) {\n\t\t/* flush outstanding delalloc blocks and retry */\n\t\txfs_flush_inodes(mp);\n\t\terror = xfs_trans_reserve(tp, tres, resblks, 0);\n\t}\n\tif (error == -ENOSPC) {\n\t\t/* No space at all so try a \"no-allocation\" reservation */\n\t\tresblks = 0;\n\t\terror = xfs_trans_reserve(tp, tres, 0, 0);\n\t}\n\tif (error) {\n\t\tcancel_flags = 0;\n\t\tgoto out_trans_cancel;\n\t}\n\n\txfs_ilock(dp, XFS_ILOCK_EXCL | XFS_ILOCK_PARENT);\n\tunlock_dp_on_error = true;\n\n\txfs_bmap_init(&free_list, &first_block);\n\n\t/*\n\t * Reserve disk quota and the inode.\n\t */\n\terror = xfs_trans_reserve_quota(tp, mp, udqp, gdqp,\n\t\t\t\t\t\tpdqp, resblks, 1, 0);\n\tif (error)\n\t\tgoto out_trans_cancel;\n\n\tif (!resblks) {\n\t\terror = xfs_dir_canenter(tp, dp, name);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\t}\n\n\t/*\n\t * A newly created regular or special file just has one directory\n\t * entry pointing to them, but a directory also the \".\" entry\n\t * pointing to itself.\n\t */\n\terror = xfs_dir_ialloc(&tp, dp, mode, is_dir ? 2 : 1, rdev,\n\t\t\t       prid, resblks > 0, &ip, &committed);\n\tif (error) {\n\t\tif (error == -ENOSPC)\n\t\t\tgoto out_trans_cancel;\n\t\tgoto out_trans_abort;\n\t}\n\n\t/*\n\t * Now we join the directory inode to the transaction.  We do not do it\n\t * earlier because xfs_dir_ialloc might commit the previous transaction\n\t * (and release all the locks).  An error from here on will result in\n\t * the transaction cancel unlocking dp so don't do it explicitly in the\n\t * error path.\n\t */\n\txfs_trans_ijoin(tp, dp, XFS_ILOCK_EXCL);\n\tunlock_dp_on_error = false;\n\n\terror = xfs_dir_createname(tp, dp, name, ip->i_ino,\n\t\t\t\t\t&first_block, &free_list, resblks ?\n\t\t\t\t\tresblks - XFS_IALLOC_SPACE_RES(mp) : 0);\n\tif (error) {\n\t\tASSERT(error != -ENOSPC);\n\t\tgoto out_trans_abort;\n\t}\n\txfs_trans_ichgtime(tp, dp, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\txfs_trans_log_inode(tp, dp, XFS_ILOG_CORE);\n\n\tif (is_dir) {\n\t\terror = xfs_dir_init(tp, ip, dp);\n\t\tif (error)\n\t\t\tgoto out_bmap_cancel;\n\n\t\terror = xfs_bumplink(tp, dp);\n\t\tif (error)\n\t\t\tgoto out_bmap_cancel;\n\t}\n\n\t/*\n\t * If this is a synchronous mount, make sure that the\n\t * create transaction goes to disk before returning to\n\t * the user.\n\t */\n\tif (mp->m_flags & (XFS_MOUNT_WSYNC|XFS_MOUNT_DIRSYNC))\n\t\txfs_trans_set_sync(tp);\n\n\t/*\n\t * Attach the dquot(s) to the inodes and modify them incore.\n\t * These ids of the inode couldn't have changed since the new\n\t * inode has been locked ever since it was created.\n\t */\n\txfs_qm_vop_create_dqattach(tp, ip, udqp, gdqp, pdqp);\n\n\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\tif (error)\n\t\tgoto out_bmap_cancel;\n\n\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\tif (error)\n\t\tgoto out_release_inode;\n\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\txfs_qm_dqrele(pdqp);\n\n\t*ipp = ip;\n\treturn 0;\n\n out_bmap_cancel:\n\txfs_bmap_cancel(&free_list);\n out_trans_abort:\n\tcancel_flags |= XFS_TRANS_ABORT;\n out_trans_cancel:\n\txfs_trans_cancel(tp, cancel_flags);\n out_release_inode:\n\t/*\n\t * Wait until after the current transaction is aborted to\n\t * release the inode.  This prevents recursive transactions\n\t * and deadlocks from xfs_inactive.\n\t */\n\tif (ip)\n\t\tIRELE(ip);\n\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\txfs_qm_dqrele(pdqp);\n\n\tif (unlock_dp_on_error)\n\t\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_create(\n\txfs_inode_t\t\t*dp,\n\tstruct xfs_name\t\t*name,\n\tumode_t\t\t\tmode,\n\txfs_dev_t\t\trdev,\n\txfs_inode_t\t\t**ipp)\n{\n\tint\t\t\tis_dir = S_ISDIR(mode);\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_inode\t*ip = NULL;\n\tstruct xfs_trans\t*tp = NULL;\n\tint\t\t\terror;\n\txfs_bmap_free_t\t\tfree_list;\n\txfs_fsblock_t\t\tfirst_block;\n\tbool                    unlock_dp_on_error = false;\n\tuint\t\t\tcancel_flags;\n\tint\t\t\tcommitted;\n\tprid_t\t\t\tprid;\n\tstruct xfs_dquot\t*udqp = NULL;\n\tstruct xfs_dquot\t*gdqp = NULL;\n\tstruct xfs_dquot\t*pdqp = NULL;\n\tstruct xfs_trans_res\t*tres;\n\tuint\t\t\tresblks;\n\n\ttrace_xfs_create(dp, name);\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tprid = xfs_get_initial_prid(dp);\n\n\t/*\n\t * Make sure that we have allocated dquot(s) on disk.\n\t */\n\terror = xfs_qm_vop_dqalloc(dp, xfs_kuid_to_uid(current_fsuid()),\n\t\t\t\t\txfs_kgid_to_gid(current_fsgid()), prid,\n\t\t\t\t\tXFS_QMOPT_QUOTALL | XFS_QMOPT_INHERIT,\n\t\t\t\t\t&udqp, &gdqp, &pdqp);\n\tif (error)\n\t\treturn error;\n\n\tif (is_dir) {\n\t\trdev = 0;\n\t\tresblks = XFS_MKDIR_SPACE_RES(mp, name->len);\n\t\ttres = &M_RES(mp)->tr_mkdir;\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_MKDIR);\n\t} else {\n\t\tresblks = XFS_CREATE_SPACE_RES(mp, name->len);\n\t\ttres = &M_RES(mp)->tr_create;\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_CREATE);\n\t}\n\n\tcancel_flags = XFS_TRANS_RELEASE_LOG_RES;\n\n\t/*\n\t * Initially assume that the file does not exist and\n\t * reserve the resources for that case.  If that is not\n\t * the case we'll drop the one we have and get a more\n\t * appropriate transaction later.\n\t */\n\terror = xfs_trans_reserve(tp, tres, resblks, 0);\n\tif (error == -ENOSPC) {\n\t\t/* flush outstanding delalloc blocks and retry */\n\t\txfs_flush_inodes(mp);\n\t\terror = xfs_trans_reserve(tp, tres, resblks, 0);\n\t}\n\tif (error == -ENOSPC) {\n\t\t/* No space at all so try a \"no-allocation\" reservation */\n\t\tresblks = 0;\n\t\terror = xfs_trans_reserve(tp, tres, 0, 0);\n\t}\n\tif (error) {\n\t\tcancel_flags = 0;\n\t\tgoto out_trans_cancel;\n\t}\n\n\txfs_ilock(dp, XFS_ILOCK_EXCL | XFS_ILOCK_PARENT);\n\tunlock_dp_on_error = true;\n\n\txfs_bmap_init(&free_list, &first_block);\n\n\t/*\n\t * Reserve disk quota and the inode.\n\t */\n\terror = xfs_trans_reserve_quota(tp, mp, udqp, gdqp,\n\t\t\t\t\t\tpdqp, resblks, 1, 0);\n\tif (error)\n\t\tgoto out_trans_cancel;\n\n\tif (!resblks) {\n\t\terror = xfs_dir_canenter(tp, dp, name);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\t}\n\n\t/*\n\t * A newly created regular or special file just has one directory\n\t * entry pointing to them, but a directory also the \".\" entry\n\t * pointing to itself.\n\t */\n\terror = xfs_dir_ialloc(&tp, dp, mode, is_dir ? 2 : 1, rdev,\n\t\t\t       prid, resblks > 0, &ip, &committed);\n\tif (error) {\n\t\tif (error == -ENOSPC)\n\t\t\tgoto out_trans_cancel;\n\t\tgoto out_trans_abort;\n\t}\n\n\t/*\n\t * Now we join the directory inode to the transaction.  We do not do it\n\t * earlier because xfs_dir_ialloc might commit the previous transaction\n\t * (and release all the locks).  An error from here on will result in\n\t * the transaction cancel unlocking dp so don't do it explicitly in the\n\t * error path.\n\t */\n\txfs_trans_ijoin(tp, dp, XFS_ILOCK_EXCL);\n\tunlock_dp_on_error = false;\n\n\terror = xfs_dir_createname(tp, dp, name, ip->i_ino,\n\t\t\t\t\t&first_block, &free_list, resblks ?\n\t\t\t\t\tresblks - XFS_IALLOC_SPACE_RES(mp) : 0);\n\tif (error) {\n\t\tASSERT(error != -ENOSPC);\n\t\tgoto out_trans_abort;\n\t}\n\txfs_trans_ichgtime(tp, dp, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\txfs_trans_log_inode(tp, dp, XFS_ILOG_CORE);\n\n\tif (is_dir) {\n\t\terror = xfs_dir_init(tp, ip, dp);\n\t\tif (error)\n\t\t\tgoto out_bmap_cancel;\n\n\t\terror = xfs_bumplink(tp, dp);\n\t\tif (error)\n\t\t\tgoto out_bmap_cancel;\n\t}\n\n\t/*\n\t * If this is a synchronous mount, make sure that the\n\t * create transaction goes to disk before returning to\n\t * the user.\n\t */\n\tif (mp->m_flags & (XFS_MOUNT_WSYNC|XFS_MOUNT_DIRSYNC))\n\t\txfs_trans_set_sync(tp);\n\n\t/*\n\t * Attach the dquot(s) to the inodes and modify them incore.\n\t * These ids of the inode couldn't have changed since the new\n\t * inode has been locked ever since it was created.\n\t */\n\txfs_qm_vop_create_dqattach(tp, ip, udqp, gdqp, pdqp);\n\n\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\tif (error)\n\t\tgoto out_bmap_cancel;\n\n\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\tif (error)\n\t\tgoto out_release_inode;\n\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\txfs_qm_dqrele(pdqp);\n\n\t*ipp = ip;\n\treturn 0;\n\n out_bmap_cancel:\n\txfs_bmap_cancel(&free_list);\n out_trans_abort:\n\tcancel_flags |= XFS_TRANS_ABORT;\n out_trans_cancel:\n\txfs_trans_cancel(tp, cancel_flags);\n out_release_inode:\n\t/*\n\t * Wait until after the current transaction is aborted to\n\t * release the inode.  This prevents recursive transactions\n\t * and deadlocks from xfs_inactive.\n\t */\n\tif (ip)\n\t\tIRELE(ip);\n\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\txfs_qm_dqrele(pdqp);\n\n\tif (unlock_dp_on_error)\n\t\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dentry_to_name",
          "args": [
            "&name",
            "dentry",
            "mode"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dentry_to_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
          "lines": "98-107",
          "snippet": "static void\nxfs_dentry_to_name(\n\tstruct xfs_name\t*namep,\n\tstruct dentry\t*dentry,\n\tint\t\tmode)\n{\n\tnamep->name = dentry->d_name.name;\n\tnamep->len = dentry->d_name.len;\n\tnamep->type = xfs_mode_to_ftype[(mode & S_IFMT) >> S_SHIFT];\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/security.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/namei.h>",
            "#include <linux/xattr.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_acl.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nstatic void\nxfs_dentry_to_name(\n\tstruct xfs_name\t*namep,\n\tstruct dentry\t*dentry,\n\tint\t\tmode)\n{\n\tnamep->name = dentry->d_name.name;\n\tnamep->len = dentry->d_name.len;\n\tnamep->type = xfs_mode_to_ftype[(mode & S_IFMT) >> S_SHIFT];\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_create",
          "args": [
            "dir",
            "&mode",
            "&default_acl",
            "&acl"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "545-598",
          "snippet": "int\nposix_acl_create(struct inode *dir, umode_t *mode,\n\t\tstruct posix_acl **default_acl, struct posix_acl **acl)\n{\n\tstruct posix_acl *p;\n\tint ret;\n\n\tif (S_ISLNK(*mode) || !IS_POSIXACL(dir))\n\t\tgoto no_acl;\n\n\tp = get_acl(dir, ACL_TYPE_DEFAULT);\n\tif (IS_ERR(p)) {\n\t\tif (p == ERR_PTR(-EOPNOTSUPP))\n\t\t\tgoto apply_umask;\n\t\treturn PTR_ERR(p);\n\t}\n\n\tif (!p)\n\t\tgoto apply_umask;\n\n\t*acl = posix_acl_clone(p, GFP_NOFS);\n\tif (!*acl)\n\t\tgoto no_mem;\n\n\tret = posix_acl_create_masq(*acl, mode);\n\tif (ret < 0)\n\t\tgoto no_mem_clone;\n\n\tif (ret == 0) {\n\t\tposix_acl_release(*acl);\n\t\t*acl = NULL;\n\t}\n\n\tif (!S_ISDIR(*mode)) {\n\t\tposix_acl_release(p);\n\t\t*default_acl = NULL;\n\t} else {\n\t\t*default_acl = p;\n\t}\n\treturn 0;\n\napply_umask:\n\t*mode &= ~current_umask();\nno_acl:\n\t*default_acl = NULL;\n\t*acl = NULL;\n\treturn 0;\n\nno_mem_clone:\n\tposix_acl_release(*acl);\nno_mem:\n\tposix_acl_release(p);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nposix_acl_create(struct inode *dir, umode_t *mode,\n\t\tstruct posix_acl **default_acl, struct posix_acl **acl)\n{\n\tstruct posix_acl *p;\n\tint ret;\n\n\tif (S_ISLNK(*mode) || !IS_POSIXACL(dir))\n\t\tgoto no_acl;\n\n\tp = get_acl(dir, ACL_TYPE_DEFAULT);\n\tif (IS_ERR(p)) {\n\t\tif (p == ERR_PTR(-EOPNOTSUPP))\n\t\t\tgoto apply_umask;\n\t\treturn PTR_ERR(p);\n\t}\n\n\tif (!p)\n\t\tgoto apply_umask;\n\n\t*acl = posix_acl_clone(p, GFP_NOFS);\n\tif (!*acl)\n\t\tgoto no_mem;\n\n\tret = posix_acl_create_masq(*acl, mode);\n\tif (ret < 0)\n\t\tgoto no_mem_clone;\n\n\tif (ret == 0) {\n\t\tposix_acl_release(*acl);\n\t\t*acl = NULL;\n\t}\n\n\tif (!S_ISDIR(*mode)) {\n\t\tposix_acl_release(p);\n\t\t*default_acl = NULL;\n\t} else {\n\t\t*default_acl = p;\n\t}\n\treturn 0;\n\napply_umask:\n\t*mode &= ~current_umask();\nno_acl:\n\t*default_acl = NULL;\n\t*acl = NULL;\n\treturn 0;\n\nno_mem_clone:\n\tposix_acl_release(*acl);\nno_mem:\n\tposix_acl_release(p);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysv_encode_dev",
          "args": [
            "rdev"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!sysv_valid_dev(rdev) || MAJOR(rdev) & ~0x1ff"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "rdev"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysv_valid_dev",
          "args": [
            "rdev"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "mode"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "mode"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_generic_create(\n\tstruct inode\t*dir,\n\tstruct dentry\t*dentry,\n\tumode_t\t\tmode,\n\tdev_t\t\trdev,\n\tbool\t\ttmpfile)\t/* unnamed file */\n{\n\tstruct inode\t*inode;\n\tstruct xfs_inode *ip = NULL;\n\tstruct posix_acl *default_acl, *acl;\n\tstruct xfs_name\tname;\n\tint\t\terror;\n\n\t/*\n\t * Irix uses Missed'em'V split, but doesn't want to see\n\t * the upper 5 bits of (14bit) major.\n\t */\n\tif (S_ISCHR(mode) || S_ISBLK(mode)) {\n\t\tif (unlikely(!sysv_valid_dev(rdev) || MAJOR(rdev) & ~0x1ff))\n\t\t\treturn -EINVAL;\n\t\trdev = sysv_encode_dev(rdev);\n\t} else {\n\t\trdev = 0;\n\t}\n\n\terror = posix_acl_create(dir, &mode, &default_acl, &acl);\n\tif (error)\n\t\treturn error;\n\n\tif (!tmpfile) {\n\t\txfs_dentry_to_name(&name, dentry, mode);\n\t\terror = xfs_create(XFS_I(dir), &name, mode, rdev, &ip);\n\t} else {\n\t\terror = xfs_create_tmpfile(XFS_I(dir), dentry, mode, &ip);\n\t}\n\tif (unlikely(error))\n\t\tgoto out_free_acl;\n\n\tinode = VFS_I(ip);\n\n\terror = xfs_init_security(inode, dir, &dentry->d_name);\n\tif (unlikely(error))\n\t\tgoto out_cleanup_inode;\n\n#ifdef CONFIG_XFS_POSIX_ACL\n\tif (default_acl) {\n\t\terror = xfs_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);\n\t\tif (error)\n\t\t\tgoto out_cleanup_inode;\n\t}\n\tif (acl) {\n\t\terror = xfs_set_acl(inode, acl, ACL_TYPE_ACCESS);\n\t\tif (error)\n\t\t\tgoto out_cleanup_inode;\n\t}\n#endif\n\n\tif (tmpfile)\n\t\td_tmpfile(dentry, inode);\n\telse\n\t\td_instantiate(dentry, inode);\n\n out_free_acl:\n\tif (default_acl)\n\t\tposix_acl_release(default_acl);\n\tif (acl)\n\t\tposix_acl_release(acl);\n\treturn error;\n\n out_cleanup_inode:\n\tif (!tmpfile)\n\t\txfs_cleanup_inode(dir, inode, dentry);\n\tiput(inode);\n\tgoto out_free_acl;\n}"
  },
  {
    "function_name": "xfs_cleanup_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
    "lines": "109-125",
    "snippet": "STATIC void\nxfs_cleanup_inode(\n\tstruct inode\t*dir,\n\tstruct inode\t*inode,\n\tstruct dentry\t*dentry)\n{\n\tstruct xfs_name\tteardown;\n\n\t/* Oh, the horror.\n\t * If we can't add the ACL or we fail in\n\t * xfs_init_security we must back out.\n\t * ENOSPC can hit here, among other things.\n\t */\n\txfs_dentry_to_name(&teardown, dentry, 0);\n\n\txfs_remove(XFS_I(dir), &teardown, XFS_I(inode));\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/security.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/namei.h>",
      "#include <linux/xattr.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_acl.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_remove",
          "args": [
            "XFS_I(dir)",
            "&teardown",
            "XFS_I(inode)"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "2474-2609",
          "snippet": "int\nxfs_remove(\n\txfs_inode_t             *dp,\n\tstruct xfs_name\t\t*name,\n\txfs_inode_t\t\t*ip)\n{\n\txfs_mount_t\t\t*mp = dp->i_mount;\n\txfs_trans_t             *tp = NULL;\n\tint\t\t\tis_dir = S_ISDIR(ip->i_d.di_mode);\n\tint                     error = 0;\n\txfs_bmap_free_t         free_list;\n\txfs_fsblock_t           first_block;\n\tint\t\t\tcancel_flags;\n\tint\t\t\tcommitted;\n\tuint\t\t\tresblks;\n\n\ttrace_xfs_remove(dp, name);\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\terror = xfs_qm_dqattach(dp, 0);\n\tif (error)\n\t\tgoto std_return;\n\n\terror = xfs_qm_dqattach(ip, 0);\n\tif (error)\n\t\tgoto std_return;\n\n\tif (is_dir)\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_RMDIR);\n\telse\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_REMOVE);\n\tcancel_flags = XFS_TRANS_RELEASE_LOG_RES;\n\n\t/*\n\t * We try to get the real space reservation first,\n\t * allowing for directory btree deletion(s) implying\n\t * possible bmap insert(s).  If we can't get the space\n\t * reservation then we use 0 instead, and avoid the bmap\n\t * btree insert(s) in the directory code by, if the bmap\n\t * insert tries to happen, instead trimming the LAST\n\t * block from the directory.\n\t */\n\tresblks = XFS_REMOVE_SPACE_RES(mp);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_remove, resblks, 0);\n\tif (error == -ENOSPC) {\n\t\tresblks = 0;\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_remove, 0, 0);\n\t}\n\tif (error) {\n\t\tASSERT(error != -ENOSPC);\n\t\tcancel_flags = 0;\n\t\tgoto out_trans_cancel;\n\t}\n\n\txfs_lock_two_inodes(dp, ip, XFS_ILOCK_EXCL);\n\n\txfs_trans_ijoin(tp, dp, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * If we're removing a directory perform some additional validation.\n\t */\n\tcancel_flags |= XFS_TRANS_ABORT;\n\tif (is_dir) {\n\t\tASSERT(ip->i_d.di_nlink >= 2);\n\t\tif (ip->i_d.di_nlink != 2) {\n\t\t\terror = -ENOTEMPTY;\n\t\t\tgoto out_trans_cancel;\n\t\t}\n\t\tif (!xfs_dir_isempty(ip)) {\n\t\t\terror = -ENOTEMPTY;\n\t\t\tgoto out_trans_cancel;\n\t\t}\n\n\t\t/* Drop the link from ip's \"..\".  */\n\t\terror = xfs_droplink(tp, dp);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\n\t\t/* Drop the \".\" link from ip to self.  */\n\t\terror = xfs_droplink(tp, ip);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\t} else {\n\t\t/*\n\t\t * When removing a non-directory we need to log the parent\n\t\t * inode here.  For a directory this is done implicitly\n\t\t * by the xfs_droplink call for the \"..\" entry.\n\t\t */\n\t\txfs_trans_log_inode(tp, dp, XFS_ILOG_CORE);\n\t}\n\txfs_trans_ichgtime(tp, dp, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\n\t/* Drop the link from dp to ip. */\n\terror = xfs_droplink(tp, ip);\n\tif (error)\n\t\tgoto out_trans_cancel;\n\n\txfs_bmap_init(&free_list, &first_block);\n\terror = xfs_dir_removename(tp, dp, name, ip->i_ino,\n\t\t\t\t\t&first_block, &free_list, resblks);\n\tif (error) {\n\t\tASSERT(error != -ENOENT);\n\t\tgoto out_bmap_cancel;\n\t}\n\n\t/*\n\t * If this is a synchronous mount, make sure that the\n\t * remove transaction goes to disk before returning to\n\t * the user.\n\t */\n\tif (mp->m_flags & (XFS_MOUNT_WSYNC|XFS_MOUNT_DIRSYNC))\n\t\txfs_trans_set_sync(tp);\n\n\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\tif (error)\n\t\tgoto out_bmap_cancel;\n\n\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\tif (error)\n\t\tgoto std_return;\n\n\tif (is_dir && xfs_inode_is_filestream(ip))\n\t\txfs_filestream_deassociate(ip);\n\n\treturn 0;\n\n out_bmap_cancel:\n\txfs_bmap_cancel(&free_list);\n out_trans_cancel:\n\txfs_trans_cancel(tp, cancel_flags);\n std_return:\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_remove(\n\txfs_inode_t             *dp,\n\tstruct xfs_name\t\t*name,\n\txfs_inode_t\t\t*ip)\n{\n\txfs_mount_t\t\t*mp = dp->i_mount;\n\txfs_trans_t             *tp = NULL;\n\tint\t\t\tis_dir = S_ISDIR(ip->i_d.di_mode);\n\tint                     error = 0;\n\txfs_bmap_free_t         free_list;\n\txfs_fsblock_t           first_block;\n\tint\t\t\tcancel_flags;\n\tint\t\t\tcommitted;\n\tuint\t\t\tresblks;\n\n\ttrace_xfs_remove(dp, name);\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\terror = xfs_qm_dqattach(dp, 0);\n\tif (error)\n\t\tgoto std_return;\n\n\terror = xfs_qm_dqattach(ip, 0);\n\tif (error)\n\t\tgoto std_return;\n\n\tif (is_dir)\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_RMDIR);\n\telse\n\t\ttp = xfs_trans_alloc(mp, XFS_TRANS_REMOVE);\n\tcancel_flags = XFS_TRANS_RELEASE_LOG_RES;\n\n\t/*\n\t * We try to get the real space reservation first,\n\t * allowing for directory btree deletion(s) implying\n\t * possible bmap insert(s).  If we can't get the space\n\t * reservation then we use 0 instead, and avoid the bmap\n\t * btree insert(s) in the directory code by, if the bmap\n\t * insert tries to happen, instead trimming the LAST\n\t * block from the directory.\n\t */\n\tresblks = XFS_REMOVE_SPACE_RES(mp);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_remove, resblks, 0);\n\tif (error == -ENOSPC) {\n\t\tresblks = 0;\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_remove, 0, 0);\n\t}\n\tif (error) {\n\t\tASSERT(error != -ENOSPC);\n\t\tcancel_flags = 0;\n\t\tgoto out_trans_cancel;\n\t}\n\n\txfs_lock_two_inodes(dp, ip, XFS_ILOCK_EXCL);\n\n\txfs_trans_ijoin(tp, dp, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * If we're removing a directory perform some additional validation.\n\t */\n\tcancel_flags |= XFS_TRANS_ABORT;\n\tif (is_dir) {\n\t\tASSERT(ip->i_d.di_nlink >= 2);\n\t\tif (ip->i_d.di_nlink != 2) {\n\t\t\terror = -ENOTEMPTY;\n\t\t\tgoto out_trans_cancel;\n\t\t}\n\t\tif (!xfs_dir_isempty(ip)) {\n\t\t\terror = -ENOTEMPTY;\n\t\t\tgoto out_trans_cancel;\n\t\t}\n\n\t\t/* Drop the link from ip's \"..\".  */\n\t\terror = xfs_droplink(tp, dp);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\n\t\t/* Drop the \".\" link from ip to self.  */\n\t\terror = xfs_droplink(tp, ip);\n\t\tif (error)\n\t\t\tgoto out_trans_cancel;\n\t} else {\n\t\t/*\n\t\t * When removing a non-directory we need to log the parent\n\t\t * inode here.  For a directory this is done implicitly\n\t\t * by the xfs_droplink call for the \"..\" entry.\n\t\t */\n\t\txfs_trans_log_inode(tp, dp, XFS_ILOG_CORE);\n\t}\n\txfs_trans_ichgtime(tp, dp, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\n\t/* Drop the link from dp to ip. */\n\terror = xfs_droplink(tp, ip);\n\tif (error)\n\t\tgoto out_trans_cancel;\n\n\txfs_bmap_init(&free_list, &first_block);\n\terror = xfs_dir_removename(tp, dp, name, ip->i_ino,\n\t\t\t\t\t&first_block, &free_list, resblks);\n\tif (error) {\n\t\tASSERT(error != -ENOENT);\n\t\tgoto out_bmap_cancel;\n\t}\n\n\t/*\n\t * If this is a synchronous mount, make sure that the\n\t * remove transaction goes to disk before returning to\n\t * the user.\n\t */\n\tif (mp->m_flags & (XFS_MOUNT_WSYNC|XFS_MOUNT_DIRSYNC))\n\t\txfs_trans_set_sync(tp);\n\n\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\tif (error)\n\t\tgoto out_bmap_cancel;\n\n\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\tif (error)\n\t\tgoto std_return;\n\n\tif (is_dir && xfs_inode_is_filestream(ip))\n\t\txfs_filestream_deassociate(ip);\n\n\treturn 0;\n\n out_bmap_cancel:\n\txfs_bmap_cancel(&free_list);\n out_trans_cancel:\n\txfs_trans_cancel(tp, cancel_flags);\n std_return:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "inode"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dentry_to_name",
          "args": [
            "&teardown",
            "dentry",
            "0"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dentry_to_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
          "lines": "98-107",
          "snippet": "static void\nxfs_dentry_to_name(\n\tstruct xfs_name\t*namep,\n\tstruct dentry\t*dentry,\n\tint\t\tmode)\n{\n\tnamep->name = dentry->d_name.name;\n\tnamep->len = dentry->d_name.len;\n\tnamep->type = xfs_mode_to_ftype[(mode & S_IFMT) >> S_SHIFT];\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/security.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/namei.h>",
            "#include <linux/xattr.h>",
            "#include <linux/capability.h>",
            "#include \"xfs_pnfs.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_acl.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nstatic void\nxfs_dentry_to_name(\n\tstruct xfs_name\t*namep,\n\tstruct dentry\t*dentry,\n\tint\t\tmode)\n{\n\tnamep->name = dentry->d_name.name;\n\tnamep->len = dentry->d_name.len;\n\tnamep->type = xfs_mode_to_ftype[(mode & S_IFMT) >> S_SHIFT];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC void\nxfs_cleanup_inode(\n\tstruct inode\t*dir,\n\tstruct inode\t*inode,\n\tstruct dentry\t*dentry)\n{\n\tstruct xfs_name\tteardown;\n\n\t/* Oh, the horror.\n\t * If we can't add the ACL or we fail in\n\t * xfs_init_security we must back out.\n\t * ENOSPC can hit here, among other things.\n\t */\n\txfs_dentry_to_name(&teardown, dentry, 0);\n\n\txfs_remove(XFS_I(dir), &teardown, XFS_I(inode));\n}"
  },
  {
    "function_name": "xfs_dentry_to_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
    "lines": "98-107",
    "snippet": "static void\nxfs_dentry_to_name(\n\tstruct xfs_name\t*namep,\n\tstruct dentry\t*dentry,\n\tint\t\tmode)\n{\n\tnamep->name = dentry->d_name.name;\n\tnamep->len = dentry->d_name.len;\n\tnamep->type = xfs_mode_to_ftype[(mode & S_IFMT) >> S_SHIFT];\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/security.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/namei.h>",
      "#include <linux/xattr.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_acl.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nstatic void\nxfs_dentry_to_name(\n\tstruct xfs_name\t*namep,\n\tstruct dentry\t*dentry,\n\tint\t\tmode)\n{\n\tnamep->name = dentry->d_name.name;\n\tnamep->len = dentry->d_name.len;\n\tnamep->type = xfs_mode_to_ftype[(mode & S_IFMT) >> S_SHIFT];\n}"
  },
  {
    "function_name": "xfs_init_security",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
    "lines": "88-96",
    "snippet": "STATIC int\nxfs_init_security(\n\tstruct inode\t*inode,\n\tstruct inode\t*dir,\n\tconst struct qstr *qstr)\n{\n\treturn security_inode_init_security(inode, dir, qstr,\n\t\t\t\t\t     &xfs_initxattrs, NULL);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/security.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/namei.h>",
      "#include <linux/xattr.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_acl.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_inode_init_security",
          "args": [
            "inode",
            "dir",
            "qstr",
            "&xfs_initxattrs",
            "NULL"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nSTATIC int\nxfs_init_security(\n\tstruct inode\t*inode,\n\tstruct inode\t*dir,\n\tconst struct qstr *qstr)\n{\n\treturn security_inode_init_security(inode, dir, qstr,\n\t\t\t\t\t     &xfs_initxattrs, NULL);\n}"
  },
  {
    "function_name": "xfs_initxattrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iops.c",
    "lines": "62-79",
    "snippet": "static int\nxfs_initxattrs(\n\tstruct inode\t\t*inode,\n\tconst struct xattr\t*xattr_array,\n\tvoid\t\t\t*fs_info)\n{\n\tconst struct xattr\t*xattr;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tint\t\t\terror = 0;\n\n\tfor (xattr = xattr_array; xattr->name != NULL; xattr++) {\n\t\terror = xfs_attr_set(ip, xattr->name, xattr->value,\n\t\t\t\t      xattr->value_len, ATTR_SECURE);\n\t\tif (error < 0)\n\t\t\tbreak;\n\t}\n\treturn error;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/fiemap.h>",
      "#include <linux/security.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/namei.h>",
      "#include <linux/xattr.h>",
      "#include <linux/capability.h>",
      "#include \"xfs_pnfs.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_icache.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_attr.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_acl.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "STATIC struct",
      "STATIC struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_attr_set",
          "args": [
            "ip",
            "xattr->name",
            "xattr->value",
            "xattr->value_len",
            "ATTR_SECURE"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr.c",
          "lines": "194-398",
          "snippet": "int\nxfs_attr_set(\n\tstruct xfs_inode\t*dp,\n\tconst unsigned char\t*name,\n\tunsigned char\t\t*value,\n\tint\t\t\tvaluelen,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_da_args\targs;\n\tstruct xfs_bmap_free\tflist;\n\tstruct xfs_trans_res\ttres;\n\txfs_fsblock_t\t\tfirstblock;\n\tint\t\t\trsvd = (flags & ATTR_ROOT) != 0;\n\tint\t\t\terror, err2, committed, local;\n\n\tXFS_STATS_INC(xs_attr_set);\n\n\tif (XFS_FORCED_SHUTDOWN(dp->i_mount))\n\t\treturn -EIO;\n\n\terror = xfs_attr_args_init(&args, dp, name, flags);\n\tif (error)\n\t\treturn error;\n\n\targs.value = value;\n\targs.valuelen = valuelen;\n\targs.firstblock = &firstblock;\n\targs.flist = &flist;\n\targs.op_flags = XFS_DA_OP_ADDNAME | XFS_DA_OP_OKNOENT;\n\targs.total = xfs_attr_calc_size(&args, &local);\n\n\terror = xfs_qm_dqattach(dp, 0);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * If the inode doesn't have an attribute fork, add one.\n\t * (inode must not be locked when we call this routine)\n\t */\n\tif (XFS_IFORK_Q(dp) == 0) {\n\t\tint sf_size = sizeof(xfs_attr_sf_hdr_t) +\n\t\t\tXFS_ATTR_SF_ENTSIZE_BYNAME(args.namelen, valuelen);\n\n\t\terror = xfs_bmap_add_attrfork(dp, sf_size, rsvd);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * Start our first transaction of the day.\n\t *\n\t * All future transactions during this code must be \"chained\" off\n\t * this one via the trans_dup() call.  All transactions will contain\n\t * the inode, and the inode will always be marked with trans_ihold().\n\t * Since the inode will be locked in all transactions, we must log\n\t * the inode in every transaction to let it float upward through\n\t * the log.\n\t */\n\targs.trans = xfs_trans_alloc(mp, XFS_TRANS_ATTR_SET);\n\n\t/*\n\t * Root fork attributes can use reserved data blocks for this\n\t * operation if necessary\n\t */\n\n\tif (rsvd)\n\t\targs.trans->t_flags |= XFS_TRANS_RESERVE;\n\n\ttres.tr_logres = M_RES(mp)->tr_attrsetm.tr_logres +\n\t\t\t M_RES(mp)->tr_attrsetrt.tr_logres * args.total;\n\ttres.tr_logcount = XFS_ATTRSET_LOG_COUNT;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\terror = xfs_trans_reserve(args.trans, &tres, args.total, 0);\n\tif (error) {\n\t\txfs_trans_cancel(args.trans, 0);\n\t\treturn error;\n\t}\n\txfs_ilock(dp, XFS_ILOCK_EXCL);\n\n\terror = xfs_trans_reserve_quota_nblks(args.trans, dp, args.total, 0,\n\t\t\t\trsvd ? XFS_QMOPT_RES_REGBLKS | XFS_QMOPT_FORCE_RES :\n\t\t\t\t       XFS_QMOPT_RES_REGBLKS);\n\tif (error) {\n\t\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\t\txfs_trans_cancel(args.trans, XFS_TRANS_RELEASE_LOG_RES);\n\t\treturn error;\n\t}\n\n\txfs_trans_ijoin(args.trans, dp, 0);\n\n\t/*\n\t * If the attribute list is non-existent or a shortform list,\n\t * upgrade it to a single-leaf-block attribute list.\n\t */\n\tif (dp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL ||\n\t    (dp->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS &&\n\t     dp->i_d.di_anextents == 0)) {\n\n\t\t/*\n\t\t * Build initial attribute list (if required).\n\t\t */\n\t\tif (dp->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS)\n\t\t\txfs_attr_shortform_create(&args);\n\n\t\t/*\n\t\t * Try to add the attr to the attribute list in\n\t\t * the inode.\n\t\t */\n\t\terror = xfs_attr_shortform_addname(&args);\n\t\tif (error != -ENOSPC) {\n\t\t\t/*\n\t\t\t * Commit the shortform mods, and we're done.\n\t\t\t * NOTE: this is also the error path (EEXIST, etc).\n\t\t\t */\n\t\t\tASSERT(args.trans != NULL);\n\n\t\t\t/*\n\t\t\t * If this is a synchronous mount, make sure that\n\t\t\t * the transaction goes to disk before returning\n\t\t\t * to the user.\n\t\t\t */\n\t\t\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\t\t\txfs_trans_set_sync(args.trans);\n\n\t\t\tif (!error && (flags & ATTR_KERNOTIME) == 0) {\n\t\t\t\txfs_trans_ichgtime(args.trans, dp,\n\t\t\t\t\t\t\tXFS_ICHGTIME_CHG);\n\t\t\t}\n\t\t\terr2 = xfs_trans_commit(args.trans,\n\t\t\t\t\t\t XFS_TRANS_RELEASE_LOG_RES);\n\t\t\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\n\t\t\treturn error ? error : err2;\n\t\t}\n\n\t\t/*\n\t\t * It won't fit in the shortform, transform to a leaf block.\n\t\t * GROT: another possible req'mt for a double-split btree op.\n\t\t */\n\t\txfs_bmap_init(args.flist, args.firstblock);\n\t\terror = xfs_attr_shortform_to_leaf(&args);\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args.trans, args.flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs.trans = NULL;\n\t\t\txfs_bmap_cancel(&flist);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args.trans, dp, 0);\n\n\t\t/*\n\t\t * Commit the leaf transformation.  We'll need another (linked)\n\t\t * transaction to add the new attribute to the leaf.\n\t\t */\n\n\t\terror = xfs_trans_roll(&args.trans, dp);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t}\n\n\tif (xfs_bmap_one_block(dp, XFS_ATTR_FORK))\n\t\terror = xfs_attr_leaf_addname(&args);\n\telse\n\t\terror = xfs_attr_node_addname(&args);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * If this is a synchronous mount, make sure that the\n\t * transaction goes to disk before returning to the user.\n\t */\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(args.trans);\n\n\tif ((flags & ATTR_KERNOTIME) == 0)\n\t\txfs_trans_ichgtime(args.trans, dp, XFS_ICHGTIME_CHG);\n\n\t/*\n\t * Commit the last in the sequence of transactions.\n\t */\n\txfs_trans_log_inode(args.trans, dp, XFS_ILOG_CORE);\n\terror = xfs_trans_commit(args.trans, XFS_TRANS_RELEASE_LOG_RES);\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\n\treturn error;\n\nout:\n\tif (args.trans) {\n\t\txfs_trans_cancel(args.trans,\n\t\t\tXFS_TRANS_RELEASE_LOG_RES|XFS_TRANS_ABORT);\n\t}\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_get(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_get(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_addname(xfs_da_args_t *args);",
            "STATIC int xfs_attr_node_removename(xfs_da_args_t *args);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_attr_shortform_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_leaf_removename(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_get(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_addname(xfs_da_args_t *args);\nSTATIC int xfs_attr_node_removename(xfs_da_args_t *args);\n\nint\nxfs_attr_set(\n\tstruct xfs_inode\t*dp,\n\tconst unsigned char\t*name,\n\tunsigned char\t\t*value,\n\tint\t\t\tvaluelen,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_da_args\targs;\n\tstruct xfs_bmap_free\tflist;\n\tstruct xfs_trans_res\ttres;\n\txfs_fsblock_t\t\tfirstblock;\n\tint\t\t\trsvd = (flags & ATTR_ROOT) != 0;\n\tint\t\t\terror, err2, committed, local;\n\n\tXFS_STATS_INC(xs_attr_set);\n\n\tif (XFS_FORCED_SHUTDOWN(dp->i_mount))\n\t\treturn -EIO;\n\n\terror = xfs_attr_args_init(&args, dp, name, flags);\n\tif (error)\n\t\treturn error;\n\n\targs.value = value;\n\targs.valuelen = valuelen;\n\targs.firstblock = &firstblock;\n\targs.flist = &flist;\n\targs.op_flags = XFS_DA_OP_ADDNAME | XFS_DA_OP_OKNOENT;\n\targs.total = xfs_attr_calc_size(&args, &local);\n\n\terror = xfs_qm_dqattach(dp, 0);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * If the inode doesn't have an attribute fork, add one.\n\t * (inode must not be locked when we call this routine)\n\t */\n\tif (XFS_IFORK_Q(dp) == 0) {\n\t\tint sf_size = sizeof(xfs_attr_sf_hdr_t) +\n\t\t\tXFS_ATTR_SF_ENTSIZE_BYNAME(args.namelen, valuelen);\n\n\t\terror = xfs_bmap_add_attrfork(dp, sf_size, rsvd);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * Start our first transaction of the day.\n\t *\n\t * All future transactions during this code must be \"chained\" off\n\t * this one via the trans_dup() call.  All transactions will contain\n\t * the inode, and the inode will always be marked with trans_ihold().\n\t * Since the inode will be locked in all transactions, we must log\n\t * the inode in every transaction to let it float upward through\n\t * the log.\n\t */\n\targs.trans = xfs_trans_alloc(mp, XFS_TRANS_ATTR_SET);\n\n\t/*\n\t * Root fork attributes can use reserved data blocks for this\n\t * operation if necessary\n\t */\n\n\tif (rsvd)\n\t\targs.trans->t_flags |= XFS_TRANS_RESERVE;\n\n\ttres.tr_logres = M_RES(mp)->tr_attrsetm.tr_logres +\n\t\t\t M_RES(mp)->tr_attrsetrt.tr_logres * args.total;\n\ttres.tr_logcount = XFS_ATTRSET_LOG_COUNT;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\terror = xfs_trans_reserve(args.trans, &tres, args.total, 0);\n\tif (error) {\n\t\txfs_trans_cancel(args.trans, 0);\n\t\treturn error;\n\t}\n\txfs_ilock(dp, XFS_ILOCK_EXCL);\n\n\terror = xfs_trans_reserve_quota_nblks(args.trans, dp, args.total, 0,\n\t\t\t\trsvd ? XFS_QMOPT_RES_REGBLKS | XFS_QMOPT_FORCE_RES :\n\t\t\t\t       XFS_QMOPT_RES_REGBLKS);\n\tif (error) {\n\t\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\t\txfs_trans_cancel(args.trans, XFS_TRANS_RELEASE_LOG_RES);\n\t\treturn error;\n\t}\n\n\txfs_trans_ijoin(args.trans, dp, 0);\n\n\t/*\n\t * If the attribute list is non-existent or a shortform list,\n\t * upgrade it to a single-leaf-block attribute list.\n\t */\n\tif (dp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL ||\n\t    (dp->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS &&\n\t     dp->i_d.di_anextents == 0)) {\n\n\t\t/*\n\t\t * Build initial attribute list (if required).\n\t\t */\n\t\tif (dp->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS)\n\t\t\txfs_attr_shortform_create(&args);\n\n\t\t/*\n\t\t * Try to add the attr to the attribute list in\n\t\t * the inode.\n\t\t */\n\t\terror = xfs_attr_shortform_addname(&args);\n\t\tif (error != -ENOSPC) {\n\t\t\t/*\n\t\t\t * Commit the shortform mods, and we're done.\n\t\t\t * NOTE: this is also the error path (EEXIST, etc).\n\t\t\t */\n\t\t\tASSERT(args.trans != NULL);\n\n\t\t\t/*\n\t\t\t * If this is a synchronous mount, make sure that\n\t\t\t * the transaction goes to disk before returning\n\t\t\t * to the user.\n\t\t\t */\n\t\t\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\t\t\txfs_trans_set_sync(args.trans);\n\n\t\t\tif (!error && (flags & ATTR_KERNOTIME) == 0) {\n\t\t\t\txfs_trans_ichgtime(args.trans, dp,\n\t\t\t\t\t\t\tXFS_ICHGTIME_CHG);\n\t\t\t}\n\t\t\terr2 = xfs_trans_commit(args.trans,\n\t\t\t\t\t\t XFS_TRANS_RELEASE_LOG_RES);\n\t\t\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\n\t\t\treturn error ? error : err2;\n\t\t}\n\n\t\t/*\n\t\t * It won't fit in the shortform, transform to a leaf block.\n\t\t * GROT: another possible req'mt for a double-split btree op.\n\t\t */\n\t\txfs_bmap_init(args.flist, args.firstblock);\n\t\terror = xfs_attr_shortform_to_leaf(&args);\n\t\tif (!error) {\n\t\t\terror = xfs_bmap_finish(&args.trans, args.flist,\n\t\t\t\t\t\t&committed);\n\t\t}\n\t\tif (error) {\n\t\t\tASSERT(committed);\n\t\t\targs.trans = NULL;\n\t\t\txfs_bmap_cancel(&flist);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * bmap_finish() may have committed the last trans and started\n\t\t * a new one.  We need the inode to be in all transactions.\n\t\t */\n\t\tif (committed)\n\t\t\txfs_trans_ijoin(args.trans, dp, 0);\n\n\t\t/*\n\t\t * Commit the leaf transformation.  We'll need another (linked)\n\t\t * transaction to add the new attribute to the leaf.\n\t\t */\n\n\t\terror = xfs_trans_roll(&args.trans, dp);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t}\n\n\tif (xfs_bmap_one_block(dp, XFS_ATTR_FORK))\n\t\terror = xfs_attr_leaf_addname(&args);\n\telse\n\t\terror = xfs_attr_node_addname(&args);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * If this is a synchronous mount, make sure that the\n\t * transaction goes to disk before returning to the user.\n\t */\n\tif (mp->m_flags & XFS_MOUNT_WSYNC)\n\t\txfs_trans_set_sync(args.trans);\n\n\tif ((flags & ATTR_KERNOTIME) == 0)\n\t\txfs_trans_ichgtime(args.trans, dp, XFS_ICHGTIME_CHG);\n\n\t/*\n\t * Commit the last in the sequence of transactions.\n\t */\n\txfs_trans_log_inode(args.trans, dp, XFS_ILOG_CORE);\n\terror = xfs_trans_commit(args.trans, XFS_TRANS_RELEASE_LOG_RES);\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\n\treturn error;\n\nout:\n\tif (args.trans) {\n\t\txfs_trans_cancel(args.trans,\n\t\t\tXFS_TRANS_RELEASE_LOG_RES|XFS_TRANS_ABORT);\n\t}\n\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "inode"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/fiemap.h>\n#include <linux/security.h>\n#include <linux/posix_acl.h>\n#include <linux/namei.h>\n#include <linux/xattr.h>\n#include <linux/capability.h>\n#include \"xfs_pnfs.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nstatic int\nxfs_initxattrs(\n\tstruct inode\t\t*inode,\n\tconst struct xattr\t*xattr_array,\n\tvoid\t\t\t*fs_info)\n{\n\tconst struct xattr\t*xattr;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tint\t\t\terror = 0;\n\n\tfor (xattr = xattr_array; xattr->name != NULL; xattr++) {\n\t\terror = xfs_attr_set(ip, xattr->name, xattr->value,\n\t\t\t\t      xattr->value_len, ATTR_SECURE);\n\t\tif (error < 0)\n\t\t\tbreak;\n\t}\n\treturn error;\n}"
  }
]