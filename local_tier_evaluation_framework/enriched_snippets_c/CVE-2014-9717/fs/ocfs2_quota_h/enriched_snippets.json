[
  {
    "function_name": "ocfs2_global_release_dquot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota.h",
    "lines": "105-108",
    "snippet": "static inline int ocfs2_global_release_dquot(struct dquot *dquot)\n{\n\treturn __ocfs2_sync_dquot(dquot, 1);\n}",
    "includes": [
      "#include \"ocfs2.h\"",
      "#include <linux/dqblk_qtree.h>",
      "#include <linux/list.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ocfs2_sync_dquot",
          "args": [
            "dquot",
            "1"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_sync_dquot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
          "lines": "478-586",
          "snippet": "int __ocfs2_sync_dquot(struct dquot *dquot, int freeing)\n{\n\tint err, err2;\n\tstruct super_block *sb = dquot->dq_sb;\n\tint type = dquot->dq_id.type;\n\tstruct ocfs2_mem_dqinfo *info = sb_dqinfo(sb, type)->dqi_priv;\n\tstruct ocfs2_global_disk_dqblk dqblk;\n\ts64 spacechange, inodechange;\n\ttime_t olditime, oldbtime;\n\n\terr = sb->s_op->quota_read(sb, type, (char *)&dqblk,\n\t\t\t\t   sizeof(struct ocfs2_global_disk_dqblk),\n\t\t\t\t   dquot->dq_off);\n\tif (err != sizeof(struct ocfs2_global_disk_dqblk)) {\n\t\tif (err >= 0) {\n\t\t\tmlog(ML_ERROR, \"Short read from global quota file \"\n\t\t\t\t       \"(%u read)\\n\", err);\n\t\t\terr = -EIO;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* Update space and inode usage. Get also other information from\n\t * global quota file so that we don't overwrite any changes there.\n\t * We are */\n\tspin_lock(&dq_data_lock);\n\tspacechange = dquot->dq_dqb.dqb_curspace -\n\t\t\t\t\tOCFS2_DQUOT(dquot)->dq_origspace;\n\tinodechange = dquot->dq_dqb.dqb_curinodes -\n\t\t\t\t\tOCFS2_DQUOT(dquot)->dq_originodes;\n\tolditime = dquot->dq_dqb.dqb_itime;\n\toldbtime = dquot->dq_dqb.dqb_btime;\n\tocfs2_global_disk2memdqb(dquot, &dqblk);\n\ttrace_ocfs2_sync_dquot(from_kqid(&init_user_ns, dquot->dq_id),\n\t\t\t       dquot->dq_dqb.dqb_curspace,\n\t\t\t       (long long)spacechange,\n\t\t\t       dquot->dq_dqb.dqb_curinodes,\n\t\t\t       (long long)inodechange);\n\tif (!test_bit(DQ_LASTSET_B + QIF_SPACE_B, &dquot->dq_flags))\n\t\tdquot->dq_dqb.dqb_curspace += spacechange;\n\tif (!test_bit(DQ_LASTSET_B + QIF_INODES_B, &dquot->dq_flags))\n\t\tdquot->dq_dqb.dqb_curinodes += inodechange;\n\t/* Set properly space grace time... */\n\tif (dquot->dq_dqb.dqb_bsoftlimit &&\n\t    dquot->dq_dqb.dqb_curspace > dquot->dq_dqb.dqb_bsoftlimit) {\n\t\tif (!test_bit(DQ_LASTSET_B + QIF_BTIME_B, &dquot->dq_flags) &&\n\t\t    oldbtime > 0) {\n\t\t\tif (dquot->dq_dqb.dqb_btime > 0)\n\t\t\t\tdquot->dq_dqb.dqb_btime =\n\t\t\t\t\tmin(dquot->dq_dqb.dqb_btime, oldbtime);\n\t\t\telse\n\t\t\t\tdquot->dq_dqb.dqb_btime = oldbtime;\n\t\t}\n\t} else {\n\t\tdquot->dq_dqb.dqb_btime = 0;\n\t\tclear_bit(DQ_BLKS_B, &dquot->dq_flags);\n\t}\n\t/* Set properly inode grace time... */\n\tif (dquot->dq_dqb.dqb_isoftlimit &&\n\t    dquot->dq_dqb.dqb_curinodes > dquot->dq_dqb.dqb_isoftlimit) {\n\t\tif (!test_bit(DQ_LASTSET_B + QIF_ITIME_B, &dquot->dq_flags) &&\n\t\t    olditime > 0) {\n\t\t\tif (dquot->dq_dqb.dqb_itime > 0)\n\t\t\t\tdquot->dq_dqb.dqb_itime =\n\t\t\t\t\tmin(dquot->dq_dqb.dqb_itime, olditime);\n\t\t\telse\n\t\t\t\tdquot->dq_dqb.dqb_itime = olditime;\n\t\t}\n\t} else {\n\t\tdquot->dq_dqb.dqb_itime = 0;\n\t\tclear_bit(DQ_INODES_B, &dquot->dq_flags);\n\t}\n\t/* All information is properly updated, clear the flags */\n\t__clear_bit(DQ_LASTSET_B + QIF_SPACE_B, &dquot->dq_flags);\n\t__clear_bit(DQ_LASTSET_B + QIF_INODES_B, &dquot->dq_flags);\n\t__clear_bit(DQ_LASTSET_B + QIF_BLIMITS_B, &dquot->dq_flags);\n\t__clear_bit(DQ_LASTSET_B + QIF_ILIMITS_B, &dquot->dq_flags);\n\t__clear_bit(DQ_LASTSET_B + QIF_BTIME_B, &dquot->dq_flags);\n\t__clear_bit(DQ_LASTSET_B + QIF_ITIME_B, &dquot->dq_flags);\n\tOCFS2_DQUOT(dquot)->dq_origspace = dquot->dq_dqb.dqb_curspace;\n\tOCFS2_DQUOT(dquot)->dq_originodes = dquot->dq_dqb.dqb_curinodes;\n\tspin_unlock(&dq_data_lock);\n\terr = ocfs2_qinfo_lock(info, freeing);\n\tif (err < 0) {\n\t\tmlog(ML_ERROR, \"Failed to lock quota info, losing quota write\"\n\t\t\t       \" (type=%d, id=%u)\\n\", dquot->dq_id.type,\n\t\t\t       (unsigned)from_kqid(&init_user_ns, dquot->dq_id));\n\t\tgoto out;\n\t}\n\tif (freeing)\n\t\tOCFS2_DQUOT(dquot)->dq_use_count--;\n\terr = qtree_write_dquot(&info->dqi_gi, dquot);\n\tif (err < 0)\n\t\tgoto out_qlock;\n\tif (freeing && !OCFS2_DQUOT(dquot)->dq_use_count) {\n\t\terr = qtree_release_dquot(&info->dqi_gi, dquot);\n\t\tif (info_dirty(sb_dqinfo(sb, type))) {\n\t\t\terr2 = __ocfs2_global_write_info(sb, type);\n\t\t\tif (!err)\n\t\t\t\terr = err2;\n\t\t}\n\t}\nout_qlock:\n\tocfs2_qinfo_unlock(info, freeing);\nout:\n\tif (err < 0)\n\t\tmlog_errno(err);\n\treturn err;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"quota.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/llist.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/writeback.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/dqblk_qtree.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nint __ocfs2_sync_dquot(struct dquot *dquot, int freeing)\n{\n\tint err, err2;\n\tstruct super_block *sb = dquot->dq_sb;\n\tint type = dquot->dq_id.type;\n\tstruct ocfs2_mem_dqinfo *info = sb_dqinfo(sb, type)->dqi_priv;\n\tstruct ocfs2_global_disk_dqblk dqblk;\n\ts64 spacechange, inodechange;\n\ttime_t olditime, oldbtime;\n\n\terr = sb->s_op->quota_read(sb, type, (char *)&dqblk,\n\t\t\t\t   sizeof(struct ocfs2_global_disk_dqblk),\n\t\t\t\t   dquot->dq_off);\n\tif (err != sizeof(struct ocfs2_global_disk_dqblk)) {\n\t\tif (err >= 0) {\n\t\t\tmlog(ML_ERROR, \"Short read from global quota file \"\n\t\t\t\t       \"(%u read)\\n\", err);\n\t\t\terr = -EIO;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* Update space and inode usage. Get also other information from\n\t * global quota file so that we don't overwrite any changes there.\n\t * We are */\n\tspin_lock(&dq_data_lock);\n\tspacechange = dquot->dq_dqb.dqb_curspace -\n\t\t\t\t\tOCFS2_DQUOT(dquot)->dq_origspace;\n\tinodechange = dquot->dq_dqb.dqb_curinodes -\n\t\t\t\t\tOCFS2_DQUOT(dquot)->dq_originodes;\n\tolditime = dquot->dq_dqb.dqb_itime;\n\toldbtime = dquot->dq_dqb.dqb_btime;\n\tocfs2_global_disk2memdqb(dquot, &dqblk);\n\ttrace_ocfs2_sync_dquot(from_kqid(&init_user_ns, dquot->dq_id),\n\t\t\t       dquot->dq_dqb.dqb_curspace,\n\t\t\t       (long long)spacechange,\n\t\t\t       dquot->dq_dqb.dqb_curinodes,\n\t\t\t       (long long)inodechange);\n\tif (!test_bit(DQ_LASTSET_B + QIF_SPACE_B, &dquot->dq_flags))\n\t\tdquot->dq_dqb.dqb_curspace += spacechange;\n\tif (!test_bit(DQ_LASTSET_B + QIF_INODES_B, &dquot->dq_flags))\n\t\tdquot->dq_dqb.dqb_curinodes += inodechange;\n\t/* Set properly space grace time... */\n\tif (dquot->dq_dqb.dqb_bsoftlimit &&\n\t    dquot->dq_dqb.dqb_curspace > dquot->dq_dqb.dqb_bsoftlimit) {\n\t\tif (!test_bit(DQ_LASTSET_B + QIF_BTIME_B, &dquot->dq_flags) &&\n\t\t    oldbtime > 0) {\n\t\t\tif (dquot->dq_dqb.dqb_btime > 0)\n\t\t\t\tdquot->dq_dqb.dqb_btime =\n\t\t\t\t\tmin(dquot->dq_dqb.dqb_btime, oldbtime);\n\t\t\telse\n\t\t\t\tdquot->dq_dqb.dqb_btime = oldbtime;\n\t\t}\n\t} else {\n\t\tdquot->dq_dqb.dqb_btime = 0;\n\t\tclear_bit(DQ_BLKS_B, &dquot->dq_flags);\n\t}\n\t/* Set properly inode grace time... */\n\tif (dquot->dq_dqb.dqb_isoftlimit &&\n\t    dquot->dq_dqb.dqb_curinodes > dquot->dq_dqb.dqb_isoftlimit) {\n\t\tif (!test_bit(DQ_LASTSET_B + QIF_ITIME_B, &dquot->dq_flags) &&\n\t\t    olditime > 0) {\n\t\t\tif (dquot->dq_dqb.dqb_itime > 0)\n\t\t\t\tdquot->dq_dqb.dqb_itime =\n\t\t\t\t\tmin(dquot->dq_dqb.dqb_itime, olditime);\n\t\t\telse\n\t\t\t\tdquot->dq_dqb.dqb_itime = olditime;\n\t\t}\n\t} else {\n\t\tdquot->dq_dqb.dqb_itime = 0;\n\t\tclear_bit(DQ_INODES_B, &dquot->dq_flags);\n\t}\n\t/* All information is properly updated, clear the flags */\n\t__clear_bit(DQ_LASTSET_B + QIF_SPACE_B, &dquot->dq_flags);\n\t__clear_bit(DQ_LASTSET_B + QIF_INODES_B, &dquot->dq_flags);\n\t__clear_bit(DQ_LASTSET_B + QIF_BLIMITS_B, &dquot->dq_flags);\n\t__clear_bit(DQ_LASTSET_B + QIF_ILIMITS_B, &dquot->dq_flags);\n\t__clear_bit(DQ_LASTSET_B + QIF_BTIME_B, &dquot->dq_flags);\n\t__clear_bit(DQ_LASTSET_B + QIF_ITIME_B, &dquot->dq_flags);\n\tOCFS2_DQUOT(dquot)->dq_origspace = dquot->dq_dqb.dqb_curspace;\n\tOCFS2_DQUOT(dquot)->dq_originodes = dquot->dq_dqb.dqb_curinodes;\n\tspin_unlock(&dq_data_lock);\n\terr = ocfs2_qinfo_lock(info, freeing);\n\tif (err < 0) {\n\t\tmlog(ML_ERROR, \"Failed to lock quota info, losing quota write\"\n\t\t\t       \" (type=%d, id=%u)\\n\", dquot->dq_id.type,\n\t\t\t       (unsigned)from_kqid(&init_user_ns, dquot->dq_id));\n\t\tgoto out;\n\t}\n\tif (freeing)\n\t\tOCFS2_DQUOT(dquot)->dq_use_count--;\n\terr = qtree_write_dquot(&info->dqi_gi, dquot);\n\tif (err < 0)\n\t\tgoto out_qlock;\n\tif (freeing && !OCFS2_DQUOT(dquot)->dq_use_count) {\n\t\terr = qtree_release_dquot(&info->dqi_gi, dquot);\n\t\tif (info_dirty(sb_dqinfo(sb, type))) {\n\t\t\terr2 = __ocfs2_global_write_info(sb, type);\n\t\t\tif (!err)\n\t\t\t\terr = err2;\n\t\t}\n\t}\nout_qlock:\n\tocfs2_qinfo_unlock(info, freeing);\nout:\n\tif (err < 0)\n\t\tmlog_errno(err);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2.h\"\n#include <linux/dqblk_qtree.h>\n#include <linux/list.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic inline int ocfs2_global_release_dquot(struct dquot *dquot)\n{\n\treturn __ocfs2_sync_dquot(dquot, 1);\n}"
  },
  {
    "function_name": "ocfs2_sync_dquot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota.h",
    "lines": "101-104",
    "snippet": "static inline int ocfs2_sync_dquot(struct dquot *dquot)\n{\n\treturn __ocfs2_sync_dquot(dquot, 0);\n}",
    "includes": [
      "#include \"ocfs2.h\"",
      "#include <linux/dqblk_qtree.h>",
      "#include <linux/list.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ocfs2_sync_dquot",
          "args": [
            "dquot",
            "0"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_sync_dquot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota_global.c",
          "lines": "478-586",
          "snippet": "int __ocfs2_sync_dquot(struct dquot *dquot, int freeing)\n{\n\tint err, err2;\n\tstruct super_block *sb = dquot->dq_sb;\n\tint type = dquot->dq_id.type;\n\tstruct ocfs2_mem_dqinfo *info = sb_dqinfo(sb, type)->dqi_priv;\n\tstruct ocfs2_global_disk_dqblk dqblk;\n\ts64 spacechange, inodechange;\n\ttime_t olditime, oldbtime;\n\n\terr = sb->s_op->quota_read(sb, type, (char *)&dqblk,\n\t\t\t\t   sizeof(struct ocfs2_global_disk_dqblk),\n\t\t\t\t   dquot->dq_off);\n\tif (err != sizeof(struct ocfs2_global_disk_dqblk)) {\n\t\tif (err >= 0) {\n\t\t\tmlog(ML_ERROR, \"Short read from global quota file \"\n\t\t\t\t       \"(%u read)\\n\", err);\n\t\t\terr = -EIO;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* Update space and inode usage. Get also other information from\n\t * global quota file so that we don't overwrite any changes there.\n\t * We are */\n\tspin_lock(&dq_data_lock);\n\tspacechange = dquot->dq_dqb.dqb_curspace -\n\t\t\t\t\tOCFS2_DQUOT(dquot)->dq_origspace;\n\tinodechange = dquot->dq_dqb.dqb_curinodes -\n\t\t\t\t\tOCFS2_DQUOT(dquot)->dq_originodes;\n\tolditime = dquot->dq_dqb.dqb_itime;\n\toldbtime = dquot->dq_dqb.dqb_btime;\n\tocfs2_global_disk2memdqb(dquot, &dqblk);\n\ttrace_ocfs2_sync_dquot(from_kqid(&init_user_ns, dquot->dq_id),\n\t\t\t       dquot->dq_dqb.dqb_curspace,\n\t\t\t       (long long)spacechange,\n\t\t\t       dquot->dq_dqb.dqb_curinodes,\n\t\t\t       (long long)inodechange);\n\tif (!test_bit(DQ_LASTSET_B + QIF_SPACE_B, &dquot->dq_flags))\n\t\tdquot->dq_dqb.dqb_curspace += spacechange;\n\tif (!test_bit(DQ_LASTSET_B + QIF_INODES_B, &dquot->dq_flags))\n\t\tdquot->dq_dqb.dqb_curinodes += inodechange;\n\t/* Set properly space grace time... */\n\tif (dquot->dq_dqb.dqb_bsoftlimit &&\n\t    dquot->dq_dqb.dqb_curspace > dquot->dq_dqb.dqb_bsoftlimit) {\n\t\tif (!test_bit(DQ_LASTSET_B + QIF_BTIME_B, &dquot->dq_flags) &&\n\t\t    oldbtime > 0) {\n\t\t\tif (dquot->dq_dqb.dqb_btime > 0)\n\t\t\t\tdquot->dq_dqb.dqb_btime =\n\t\t\t\t\tmin(dquot->dq_dqb.dqb_btime, oldbtime);\n\t\t\telse\n\t\t\t\tdquot->dq_dqb.dqb_btime = oldbtime;\n\t\t}\n\t} else {\n\t\tdquot->dq_dqb.dqb_btime = 0;\n\t\tclear_bit(DQ_BLKS_B, &dquot->dq_flags);\n\t}\n\t/* Set properly inode grace time... */\n\tif (dquot->dq_dqb.dqb_isoftlimit &&\n\t    dquot->dq_dqb.dqb_curinodes > dquot->dq_dqb.dqb_isoftlimit) {\n\t\tif (!test_bit(DQ_LASTSET_B + QIF_ITIME_B, &dquot->dq_flags) &&\n\t\t    olditime > 0) {\n\t\t\tif (dquot->dq_dqb.dqb_itime > 0)\n\t\t\t\tdquot->dq_dqb.dqb_itime =\n\t\t\t\t\tmin(dquot->dq_dqb.dqb_itime, olditime);\n\t\t\telse\n\t\t\t\tdquot->dq_dqb.dqb_itime = olditime;\n\t\t}\n\t} else {\n\t\tdquot->dq_dqb.dqb_itime = 0;\n\t\tclear_bit(DQ_INODES_B, &dquot->dq_flags);\n\t}\n\t/* All information is properly updated, clear the flags */\n\t__clear_bit(DQ_LASTSET_B + QIF_SPACE_B, &dquot->dq_flags);\n\t__clear_bit(DQ_LASTSET_B + QIF_INODES_B, &dquot->dq_flags);\n\t__clear_bit(DQ_LASTSET_B + QIF_BLIMITS_B, &dquot->dq_flags);\n\t__clear_bit(DQ_LASTSET_B + QIF_ILIMITS_B, &dquot->dq_flags);\n\t__clear_bit(DQ_LASTSET_B + QIF_BTIME_B, &dquot->dq_flags);\n\t__clear_bit(DQ_LASTSET_B + QIF_ITIME_B, &dquot->dq_flags);\n\tOCFS2_DQUOT(dquot)->dq_origspace = dquot->dq_dqb.dqb_curspace;\n\tOCFS2_DQUOT(dquot)->dq_originodes = dquot->dq_dqb.dqb_curinodes;\n\tspin_unlock(&dq_data_lock);\n\terr = ocfs2_qinfo_lock(info, freeing);\n\tif (err < 0) {\n\t\tmlog(ML_ERROR, \"Failed to lock quota info, losing quota write\"\n\t\t\t       \" (type=%d, id=%u)\\n\", dquot->dq_id.type,\n\t\t\t       (unsigned)from_kqid(&init_user_ns, dquot->dq_id));\n\t\tgoto out;\n\t}\n\tif (freeing)\n\t\tOCFS2_DQUOT(dquot)->dq_use_count--;\n\terr = qtree_write_dquot(&info->dqi_gi, dquot);\n\tif (err < 0)\n\t\tgoto out_qlock;\n\tif (freeing && !OCFS2_DQUOT(dquot)->dq_use_count) {\n\t\terr = qtree_release_dquot(&info->dqi_gi, dquot);\n\t\tif (info_dirty(sb_dqinfo(sb, type))) {\n\t\t\terr2 = __ocfs2_global_write_info(sb, type);\n\t\t\tif (!err)\n\t\t\t\terr = err2;\n\t\t}\n\t}\nout_qlock:\n\tocfs2_qinfo_unlock(info, freeing);\nout:\n\tif (err < 0)\n\t\tmlog_errno(err);\n\treturn err;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"quota.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/llist.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/writeback.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/dqblk_qtree.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/quota.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"quota.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include \"ocfs2_fs.h\"\n#include <cluster/masklog.h>\n#include <linux/llist.h>\n#include <linux/workqueue.h>\n#include <linux/writeback.h>\n#include <linux/jiffies.h>\n#include <linux/dqblk_qtree.h>\n#include <linux/quotaops.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n\nint __ocfs2_sync_dquot(struct dquot *dquot, int freeing)\n{\n\tint err, err2;\n\tstruct super_block *sb = dquot->dq_sb;\n\tint type = dquot->dq_id.type;\n\tstruct ocfs2_mem_dqinfo *info = sb_dqinfo(sb, type)->dqi_priv;\n\tstruct ocfs2_global_disk_dqblk dqblk;\n\ts64 spacechange, inodechange;\n\ttime_t olditime, oldbtime;\n\n\terr = sb->s_op->quota_read(sb, type, (char *)&dqblk,\n\t\t\t\t   sizeof(struct ocfs2_global_disk_dqblk),\n\t\t\t\t   dquot->dq_off);\n\tif (err != sizeof(struct ocfs2_global_disk_dqblk)) {\n\t\tif (err >= 0) {\n\t\t\tmlog(ML_ERROR, \"Short read from global quota file \"\n\t\t\t\t       \"(%u read)\\n\", err);\n\t\t\terr = -EIO;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* Update space and inode usage. Get also other information from\n\t * global quota file so that we don't overwrite any changes there.\n\t * We are */\n\tspin_lock(&dq_data_lock);\n\tspacechange = dquot->dq_dqb.dqb_curspace -\n\t\t\t\t\tOCFS2_DQUOT(dquot)->dq_origspace;\n\tinodechange = dquot->dq_dqb.dqb_curinodes -\n\t\t\t\t\tOCFS2_DQUOT(dquot)->dq_originodes;\n\tolditime = dquot->dq_dqb.dqb_itime;\n\toldbtime = dquot->dq_dqb.dqb_btime;\n\tocfs2_global_disk2memdqb(dquot, &dqblk);\n\ttrace_ocfs2_sync_dquot(from_kqid(&init_user_ns, dquot->dq_id),\n\t\t\t       dquot->dq_dqb.dqb_curspace,\n\t\t\t       (long long)spacechange,\n\t\t\t       dquot->dq_dqb.dqb_curinodes,\n\t\t\t       (long long)inodechange);\n\tif (!test_bit(DQ_LASTSET_B + QIF_SPACE_B, &dquot->dq_flags))\n\t\tdquot->dq_dqb.dqb_curspace += spacechange;\n\tif (!test_bit(DQ_LASTSET_B + QIF_INODES_B, &dquot->dq_flags))\n\t\tdquot->dq_dqb.dqb_curinodes += inodechange;\n\t/* Set properly space grace time... */\n\tif (dquot->dq_dqb.dqb_bsoftlimit &&\n\t    dquot->dq_dqb.dqb_curspace > dquot->dq_dqb.dqb_bsoftlimit) {\n\t\tif (!test_bit(DQ_LASTSET_B + QIF_BTIME_B, &dquot->dq_flags) &&\n\t\t    oldbtime > 0) {\n\t\t\tif (dquot->dq_dqb.dqb_btime > 0)\n\t\t\t\tdquot->dq_dqb.dqb_btime =\n\t\t\t\t\tmin(dquot->dq_dqb.dqb_btime, oldbtime);\n\t\t\telse\n\t\t\t\tdquot->dq_dqb.dqb_btime = oldbtime;\n\t\t}\n\t} else {\n\t\tdquot->dq_dqb.dqb_btime = 0;\n\t\tclear_bit(DQ_BLKS_B, &dquot->dq_flags);\n\t}\n\t/* Set properly inode grace time... */\n\tif (dquot->dq_dqb.dqb_isoftlimit &&\n\t    dquot->dq_dqb.dqb_curinodes > dquot->dq_dqb.dqb_isoftlimit) {\n\t\tif (!test_bit(DQ_LASTSET_B + QIF_ITIME_B, &dquot->dq_flags) &&\n\t\t    olditime > 0) {\n\t\t\tif (dquot->dq_dqb.dqb_itime > 0)\n\t\t\t\tdquot->dq_dqb.dqb_itime =\n\t\t\t\t\tmin(dquot->dq_dqb.dqb_itime, olditime);\n\t\t\telse\n\t\t\t\tdquot->dq_dqb.dqb_itime = olditime;\n\t\t}\n\t} else {\n\t\tdquot->dq_dqb.dqb_itime = 0;\n\t\tclear_bit(DQ_INODES_B, &dquot->dq_flags);\n\t}\n\t/* All information is properly updated, clear the flags */\n\t__clear_bit(DQ_LASTSET_B + QIF_SPACE_B, &dquot->dq_flags);\n\t__clear_bit(DQ_LASTSET_B + QIF_INODES_B, &dquot->dq_flags);\n\t__clear_bit(DQ_LASTSET_B + QIF_BLIMITS_B, &dquot->dq_flags);\n\t__clear_bit(DQ_LASTSET_B + QIF_ILIMITS_B, &dquot->dq_flags);\n\t__clear_bit(DQ_LASTSET_B + QIF_BTIME_B, &dquot->dq_flags);\n\t__clear_bit(DQ_LASTSET_B + QIF_ITIME_B, &dquot->dq_flags);\n\tOCFS2_DQUOT(dquot)->dq_origspace = dquot->dq_dqb.dqb_curspace;\n\tOCFS2_DQUOT(dquot)->dq_originodes = dquot->dq_dqb.dqb_curinodes;\n\tspin_unlock(&dq_data_lock);\n\terr = ocfs2_qinfo_lock(info, freeing);\n\tif (err < 0) {\n\t\tmlog(ML_ERROR, \"Failed to lock quota info, losing quota write\"\n\t\t\t       \" (type=%d, id=%u)\\n\", dquot->dq_id.type,\n\t\t\t       (unsigned)from_kqid(&init_user_ns, dquot->dq_id));\n\t\tgoto out;\n\t}\n\tif (freeing)\n\t\tOCFS2_DQUOT(dquot)->dq_use_count--;\n\terr = qtree_write_dquot(&info->dqi_gi, dquot);\n\tif (err < 0)\n\t\tgoto out_qlock;\n\tif (freeing && !OCFS2_DQUOT(dquot)->dq_use_count) {\n\t\terr = qtree_release_dquot(&info->dqi_gi, dquot);\n\t\tif (info_dirty(sb_dqinfo(sb, type))) {\n\t\t\terr2 = __ocfs2_global_write_info(sb, type);\n\t\t\tif (!err)\n\t\t\t\terr = err2;\n\t\t}\n\t}\nout_qlock:\n\tocfs2_qinfo_unlock(info, freeing);\nout:\n\tif (err < 0)\n\t\tmlog_errno(err);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ocfs2.h\"\n#include <linux/dqblk_qtree.h>\n#include <linux/list.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic inline int ocfs2_sync_dquot(struct dquot *dquot)\n{\n\treturn __ocfs2_sync_dquot(dquot, 0);\n}"
  },
  {
    "function_name": "OCFS2_DQUOT",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/quota.h",
    "lines": "71-74",
    "snippet": "static inline struct ocfs2_dquot *OCFS2_DQUOT(struct dquot *dquot)\n{\n\treturn container_of(dquot, struct ocfs2_dquot, dq_dquot);\n}",
    "includes": [
      "#include \"ocfs2.h\"",
      "#include <linux/dqblk_qtree.h>",
      "#include <linux/list.h>",
      "#include <linux/quota.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "dquot",
            "structocfs2_dquot",
            "dq_dquot"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ocfs2.h\"\n#include <linux/dqblk_qtree.h>\n#include <linux/list.h>\n#include <linux/quota.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic inline struct ocfs2_dquot *OCFS2_DQUOT(struct dquot *dquot)\n{\n\treturn container_of(dquot, struct ocfs2_dquot, dq_dquot);\n}"
  }
]