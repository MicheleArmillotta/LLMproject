[
  {
    "function_name": "cifs_ci_compare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/dir.c",
    "lines": "873-918",
    "snippet": "static int cifs_ci_compare(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\tstruct nls_table *codepage = CIFS_SB(parent->d_sb)->local_nls;\n\twchar_t c1, c2;\n\tint i, l1, l2;\n\n\t/*\n\t * We make the assumption here that uppercase characters in the local\n\t * codepage are always the same length as their lowercase counterparts.\n\t *\n\t * If that's ever not the case, then this will fail to match it.\n\t */\n\tif (name->len != len)\n\t\treturn 1;\n\n\tfor (i = 0; i < len; i += l1) {\n\t\t/* Convert characters in both strings to UTF-16. */\n\t\tl1 = codepage->char2uni(&str[i], len - i, &c1);\n\t\tl2 = codepage->char2uni(&name->name[i], name->len - i, &c2);\n\n\t\t/*\n\t\t * If we can't convert either character, just declare it to\n\t\t * be 1 byte long and compare the original byte.\n\t\t */\n\t\tif (unlikely(l1 < 0 && l2 < 0)) {\n\t\t\tif (str[i] != name->name[i])\n\t\t\t\treturn 1;\n\t\t\tl1 = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Here, we again ass|u|me that upper/lowercase versions of\n\t\t * a character are the same length in the local NLS.\n\t\t */\n\t\tif (l1 != l2)\n\t\t\treturn 1;\n\n\t\t/* Now compare uppercase versions of these characters */\n\t\tif (cifs_toupper(c1) != cifs_toupper(c2))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_toupper",
          "args": [
            "c2"
          ],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_toupper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/winucase.c",
          "lines": "639-663",
          "snippet": "wchar_t\ncifs_toupper(wchar_t in)\n{\n\tunsigned char idx;\n\tconst wchar_t *tbl;\n\twchar_t out;\n\n\t/* grab upper byte */\n\tidx = (in & 0xff00) >> 8;\n\n\t/* find pointer to 2nd layer table */\n\ttbl = toplevel[idx];\n\tif (!tbl)\n\t\treturn in;\n\n\t/* grab lower byte */\n\tidx = in & 0xff;\n\n\t/* look up character in table */\n\tout = tbl[idx];\n\tif (out)\n\t\treturn out;\n\n\treturn in;\n}",
          "includes": [
            "#include <linux/nls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "wchar_t cifs_toupper(wchar_t in);",
            "static const wchar_t *const toplevel[256] = {\n\tt2_00, t2_01, t2_02, t2_03, t2_04, t2_05,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL, t2_1d, t2_1e, t2_1f,\n\tNULL, t2_21,  NULL,  NULL, t2_24,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL, t2_2c, t2_2d,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL, t2_a6, t2_a7,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL, t2_ff,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n\nwchar_t cifs_toupper(wchar_t in);\nstatic const wchar_t *const toplevel[256] = {\n\tt2_00, t2_01, t2_02, t2_03, t2_04, t2_05,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL, t2_1d, t2_1e, t2_1f,\n\tNULL, t2_21,  NULL,  NULL, t2_24,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL, t2_2c, t2_2d,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL, t2_a6, t2_a7,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL, t2_ff,\n};\n\nwchar_t\ncifs_toupper(wchar_t in)\n{\n\tunsigned char idx;\n\tconst wchar_t *tbl;\n\twchar_t out;\n\n\t/* grab upper byte */\n\tidx = (in & 0xff00) >> 8;\n\n\t/* find pointer to 2nd layer table */\n\ttbl = toplevel[idx];\n\tif (!tbl)\n\t\treturn in;\n\n\t/* grab lower byte */\n\tidx = in & 0xff;\n\n\t/* look up character in table */\n\tout = tbl[idx];\n\tif (out)\n\t\treturn out;\n\n\treturn in;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "l1 < 0 && l2 < 0"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "codepage->char2uni",
          "args": [
            "&name->name[i]",
            "name->len - i",
            "&c2"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "char2uni",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_cp932.c",
          "lines": "7877-7908",
          "snippet": "static int char2uni(const unsigned char *rawstring, int boundlen,\n\t\t    wchar_t *uni)\n{\n\tunsigned char ch, cl;\n\tconst wchar_t *charset2uni;\n\n\tif (boundlen <= 0)\n\t\treturn -ENAMETOOLONG;\n\n\tif (rawstring[0] <= 0x7F) {\n\t\t*uni = rawstring[0];\n\t\treturn 1;\n\t}\n\tif (0xA1 <= rawstring[0] && rawstring[0] <= 0xDF) {\n\t\t*uni = 0xFF00 | (rawstring[0] - 0x40);\n\t\treturn 1;\n\t}\n\n\tif (boundlen < 2)\n\t\treturn -ENAMETOOLONG;\n\tch = rawstring[0];\n\tcl = rawstring[1];\n\tcharset2uni = page_charset2uni[ch];\n\tif (charset2uni && cl) {\n\t\t*uni = charset2uni[cl];\n\t\tif (*uni == 0x0000)\n\t\t\treturn -EINVAL;\n\t\treturn 2;\n\t}\n\telse\n\t\treturn -EINVAL;\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const wchar_t *page_charset2uni[256] = {\n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   c2u_81, c2u_82, c2u_83, c2u_84, NULL,   NULL,   c2u_87, \n\tc2u_88, c2u_89, c2u_8A, c2u_8B, c2u_8C, c2u_8D, c2u_8E, c2u_8F, \n\tc2u_90, c2u_91, c2u_92, c2u_93, c2u_94, c2u_95, c2u_96, c2u_97, \n\tc2u_98, c2u_99, c2u_9A, c2u_9B, c2u_9C, c2u_9D, c2u_9E, c2u_9F, \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tc2u_E0, c2u_E1, c2u_E2, c2u_E3, c2u_E4, c2u_E5, c2u_E6, c2u_E7, \n\tc2u_E8, c2u_E9, c2u_EA, NULL,   NULL,   c2u_ED, c2u_EE, NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   c2u_FA, c2u_FB, c2u_FC, NULL,   NULL,   NULL,   \n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic const wchar_t *page_charset2uni[256] = {\n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   c2u_81, c2u_82, c2u_83, c2u_84, NULL,   NULL,   c2u_87, \n\tc2u_88, c2u_89, c2u_8A, c2u_8B, c2u_8C, c2u_8D, c2u_8E, c2u_8F, \n\tc2u_90, c2u_91, c2u_92, c2u_93, c2u_94, c2u_95, c2u_96, c2u_97, \n\tc2u_98, c2u_99, c2u_9A, c2u_9B, c2u_9C, c2u_9D, c2u_9E, c2u_9F, \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tc2u_E0, c2u_E1, c2u_E2, c2u_E3, c2u_E4, c2u_E5, c2u_E6, c2u_E7, \n\tc2u_E8, c2u_E9, c2u_EA, NULL,   NULL,   c2u_ED, c2u_EE, NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   c2u_FA, c2u_FB, c2u_FC, NULL,   NULL,   NULL,   \n};\n\nstatic int char2uni(const unsigned char *rawstring, int boundlen,\n\t\t    wchar_t *uni)\n{\n\tunsigned char ch, cl;\n\tconst wchar_t *charset2uni;\n\n\tif (boundlen <= 0)\n\t\treturn -ENAMETOOLONG;\n\n\tif (rawstring[0] <= 0x7F) {\n\t\t*uni = rawstring[0];\n\t\treturn 1;\n\t}\n\tif (0xA1 <= rawstring[0] && rawstring[0] <= 0xDF) {\n\t\t*uni = 0xFF00 | (rawstring[0] - 0x40);\n\t\treturn 1;\n\t}\n\n\tif (boundlen < 2)\n\t\treturn -ENAMETOOLONG;\n\tch = rawstring[0];\n\tcl = rawstring[1];\n\tcharset2uni = page_charset2uni[ch];\n\tif (charset2uni && cl) {\n\t\t*uni = charset2uni[cl];\n\t\tif (*uni == 0x0000)\n\t\t\treturn -EINVAL;\n\t\treturn 2;\n\t}\n\telse\n\t\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "parent->d_sb"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nstatic int cifs_ci_compare(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\tstruct nls_table *codepage = CIFS_SB(parent->d_sb)->local_nls;\n\twchar_t c1, c2;\n\tint i, l1, l2;\n\n\t/*\n\t * We make the assumption here that uppercase characters in the local\n\t * codepage are always the same length as their lowercase counterparts.\n\t *\n\t * If that's ever not the case, then this will fail to match it.\n\t */\n\tif (name->len != len)\n\t\treturn 1;\n\n\tfor (i = 0; i < len; i += l1) {\n\t\t/* Convert characters in both strings to UTF-16. */\n\t\tl1 = codepage->char2uni(&str[i], len - i, &c1);\n\t\tl2 = codepage->char2uni(&name->name[i], name->len - i, &c2);\n\n\t\t/*\n\t\t * If we can't convert either character, just declare it to\n\t\t * be 1 byte long and compare the original byte.\n\t\t */\n\t\tif (unlikely(l1 < 0 && l2 < 0)) {\n\t\t\tif (str[i] != name->name[i])\n\t\t\t\treturn 1;\n\t\t\tl1 = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Here, we again ass|u|me that upper/lowercase versions of\n\t\t * a character are the same length in the local NLS.\n\t\t */\n\t\tif (l1 != l2)\n\t\t\treturn 1;\n\n\t\t/* Now compare uppercase versions of these characters */\n\t\tif (cifs_toupper(c1) != cifs_toupper(c2))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cifs_ci_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/dir.c",
    "lines": "853-871",
    "snippet": "static int cifs_ci_hash(const struct dentry *dentry, struct qstr *q)\n{\n\tstruct nls_table *codepage = CIFS_SB(dentry->d_sb)->local_nls;\n\tunsigned long hash;\n\twchar_t c;\n\tint i, charlen;\n\n\thash = init_name_hash();\n\tfor (i = 0; i < q->len; i += charlen) {\n\t\tcharlen = codepage->char2uni(&q->name[i], q->len - i, &c);\n\t\t/* error out if we can't convert the character */\n\t\tif (unlikely(charlen < 0))\n\t\t\treturn charlen;\n\t\thash = partial_name_hash(cifs_toupper(c), hash);\n\t}\n\tq->hash = end_name_hash(hash);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "end_name_hash",
          "args": [
            "hash"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "partial_name_hash",
          "args": [
            "cifs_toupper(c)",
            "hash"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_toupper",
          "args": [
            "c"
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_toupper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/winucase.c",
          "lines": "639-663",
          "snippet": "wchar_t\ncifs_toupper(wchar_t in)\n{\n\tunsigned char idx;\n\tconst wchar_t *tbl;\n\twchar_t out;\n\n\t/* grab upper byte */\n\tidx = (in & 0xff00) >> 8;\n\n\t/* find pointer to 2nd layer table */\n\ttbl = toplevel[idx];\n\tif (!tbl)\n\t\treturn in;\n\n\t/* grab lower byte */\n\tidx = in & 0xff;\n\n\t/* look up character in table */\n\tout = tbl[idx];\n\tif (out)\n\t\treturn out;\n\n\treturn in;\n}",
          "includes": [
            "#include <linux/nls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "wchar_t cifs_toupper(wchar_t in);",
            "static const wchar_t *const toplevel[256] = {\n\tt2_00, t2_01, t2_02, t2_03, t2_04, t2_05,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL, t2_1d, t2_1e, t2_1f,\n\tNULL, t2_21,  NULL,  NULL, t2_24,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL, t2_2c, t2_2d,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL, t2_a6, t2_a7,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL, t2_ff,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nls.h>\n\nwchar_t cifs_toupper(wchar_t in);\nstatic const wchar_t *const toplevel[256] = {\n\tt2_00, t2_01, t2_02, t2_03, t2_04, t2_05,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL, t2_1d, t2_1e, t2_1f,\n\tNULL, t2_21,  NULL,  NULL, t2_24,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL, t2_2c, t2_2d,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL, t2_a6, t2_a7,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL,\n\tNULL,  NULL,  NULL,  NULL,  NULL,  NULL,  NULL, t2_ff,\n};\n\nwchar_t\ncifs_toupper(wchar_t in)\n{\n\tunsigned char idx;\n\tconst wchar_t *tbl;\n\twchar_t out;\n\n\t/* grab upper byte */\n\tidx = (in & 0xff00) >> 8;\n\n\t/* find pointer to 2nd layer table */\n\ttbl = toplevel[idx];\n\tif (!tbl)\n\t\treturn in;\n\n\t/* grab lower byte */\n\tidx = in & 0xff;\n\n\t/* look up character in table */\n\tout = tbl[idx];\n\tif (out)\n\t\treturn out;\n\n\treturn in;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "charlen < 0"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "codepage->char2uni",
          "args": [
            "&q->name[i]",
            "q->len - i",
            "&c"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "char2uni",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nls/nls_cp932.c",
          "lines": "7877-7908",
          "snippet": "static int char2uni(const unsigned char *rawstring, int boundlen,\n\t\t    wchar_t *uni)\n{\n\tunsigned char ch, cl;\n\tconst wchar_t *charset2uni;\n\n\tif (boundlen <= 0)\n\t\treturn -ENAMETOOLONG;\n\n\tif (rawstring[0] <= 0x7F) {\n\t\t*uni = rawstring[0];\n\t\treturn 1;\n\t}\n\tif (0xA1 <= rawstring[0] && rawstring[0] <= 0xDF) {\n\t\t*uni = 0xFF00 | (rawstring[0] - 0x40);\n\t\treturn 1;\n\t}\n\n\tif (boundlen < 2)\n\t\treturn -ENAMETOOLONG;\n\tch = rawstring[0];\n\tcl = rawstring[1];\n\tcharset2uni = page_charset2uni[ch];\n\tif (charset2uni && cl) {\n\t\t*uni = charset2uni[cl];\n\t\tif (*uni == 0x0000)\n\t\t\treturn -EINVAL;\n\t\treturn 2;\n\t}\n\telse\n\t\treturn -EINVAL;\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const wchar_t *page_charset2uni[256] = {\n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   c2u_81, c2u_82, c2u_83, c2u_84, NULL,   NULL,   c2u_87, \n\tc2u_88, c2u_89, c2u_8A, c2u_8B, c2u_8C, c2u_8D, c2u_8E, c2u_8F, \n\tc2u_90, c2u_91, c2u_92, c2u_93, c2u_94, c2u_95, c2u_96, c2u_97, \n\tc2u_98, c2u_99, c2u_9A, c2u_9B, c2u_9C, c2u_9D, c2u_9E, c2u_9F, \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tc2u_E0, c2u_E1, c2u_E2, c2u_E3, c2u_E4, c2u_E5, c2u_E6, c2u_E7, \n\tc2u_E8, c2u_E9, c2u_EA, NULL,   NULL,   c2u_ED, c2u_EE, NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   c2u_FA, c2u_FB, c2u_FC, NULL,   NULL,   NULL,   \n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic const wchar_t *page_charset2uni[256] = {\n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   c2u_81, c2u_82, c2u_83, c2u_84, NULL,   NULL,   c2u_87, \n\tc2u_88, c2u_89, c2u_8A, c2u_8B, c2u_8C, c2u_8D, c2u_8E, c2u_8F, \n\tc2u_90, c2u_91, c2u_92, c2u_93, c2u_94, c2u_95, c2u_96, c2u_97, \n\tc2u_98, c2u_99, c2u_9A, c2u_9B, c2u_9C, c2u_9D, c2u_9E, c2u_9F, \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tc2u_E0, c2u_E1, c2u_E2, c2u_E3, c2u_E4, c2u_E5, c2u_E6, c2u_E7, \n\tc2u_E8, c2u_E9, c2u_EA, NULL,   NULL,   c2u_ED, c2u_EE, NULL,   \n\tNULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   NULL,   \n\tNULL,   NULL,   c2u_FA, c2u_FB, c2u_FC, NULL,   NULL,   NULL,   \n};\n\nstatic int char2uni(const unsigned char *rawstring, int boundlen,\n\t\t    wchar_t *uni)\n{\n\tunsigned char ch, cl;\n\tconst wchar_t *charset2uni;\n\n\tif (boundlen <= 0)\n\t\treturn -ENAMETOOLONG;\n\n\tif (rawstring[0] <= 0x7F) {\n\t\t*uni = rawstring[0];\n\t\treturn 1;\n\t}\n\tif (0xA1 <= rawstring[0] && rawstring[0] <= 0xDF) {\n\t\t*uni = 0xFF00 | (rawstring[0] - 0x40);\n\t\treturn 1;\n\t}\n\n\tif (boundlen < 2)\n\t\treturn -ENAMETOOLONG;\n\tch = rawstring[0];\n\tcl = rawstring[1];\n\tcharset2uni = page_charset2uni[ch];\n\tif (charset2uni && cl) {\n\t\t*uni = charset2uni[cl];\n\t\tif (*uni == 0x0000)\n\t\t\treturn -EINVAL;\n\t\treturn 2;\n\t}\n\telse\n\t\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_name_hash",
          "args": [],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "dentry->d_sb"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nstatic int cifs_ci_hash(const struct dentry *dentry, struct qstr *q)\n{\n\tstruct nls_table *codepage = CIFS_SB(dentry->d_sb)->local_nls;\n\tunsigned long hash;\n\twchar_t c;\n\tint i, charlen;\n\n\thash = init_name_hash();\n\tfor (i = 0; i < q->len; i += charlen) {\n\t\tcharlen = codepage->char2uni(&q->name[i], q->len - i, &c);\n\t\t/* error out if we can't convert the character */\n\t\tif (unlikely(charlen < 0))\n\t\t\treturn charlen;\n\t\thash = partial_name_hash(cifs_toupper(c), hash);\n\t}\n\tq->hash = end_name_hash(hash);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cifs_d_revalidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/dir.c",
    "lines": "789-836",
    "snippet": "static int\ncifs_d_revalidate(struct dentry *direntry, unsigned int flags)\n{\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tif (direntry->d_inode) {\n\t\tif (cifs_revalidate_dentry(direntry))\n\t\t\treturn 0;\n\t\telse {\n\t\t\t/*\n\t\t\t * If the inode wasn't known to be a dfs entry when\n\t\t\t * the dentry was instantiated, such as when created\n\t\t\t * via ->readdir(), it needs to be set now since the\n\t\t\t * attributes will have been updated by\n\t\t\t * cifs_revalidate_dentry().\n\t\t\t */\n\t\t\tif (IS_AUTOMOUNT(direntry->d_inode) &&\n\t\t\t   !(direntry->d_flags & DCACHE_NEED_AUTOMOUNT)) {\n\t\t\t\tspin_lock(&direntry->d_lock);\n\t\t\t\tdirentry->d_flags |= DCACHE_NEED_AUTOMOUNT;\n\t\t\t\tspin_unlock(&direntry->d_lock);\n\t\t\t}\n\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/*\n\t * This may be nfsd (or something), anyway, we can't see the\n\t * intent of this. So, since this can be for creation, drop it.\n\t */\n\tif (!flags)\n\t\treturn 0;\n\n\t/*\n\t * Drop the negative dentry, in order to make sure to use the\n\t * case sensitive name which is specified by user if this is\n\t * for creation.\n\t */\n\tif (flags & (LOOKUP_CREATE | LOOKUP_RENAME_TARGET))\n\t\treturn 0;\n\n\tif (time_after(jiffies, direntry->d_time + HZ) || !lookupCacheEnabled)\n\t\treturn 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "jiffies",
            "direntry->d_time + HZ"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&direntry->d_lock"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&direntry->d_lock"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_AUTOMOUNT",
          "args": [
            "direntry->d_inode"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_revalidate_dentry",
          "args": [
            "direntry"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nstatic int\ncifs_d_revalidate(struct dentry *direntry, unsigned int flags)\n{\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tif (direntry->d_inode) {\n\t\tif (cifs_revalidate_dentry(direntry))\n\t\t\treturn 0;\n\t\telse {\n\t\t\t/*\n\t\t\t * If the inode wasn't known to be a dfs entry when\n\t\t\t * the dentry was instantiated, such as when created\n\t\t\t * via ->readdir(), it needs to be set now since the\n\t\t\t * attributes will have been updated by\n\t\t\t * cifs_revalidate_dentry().\n\t\t\t */\n\t\t\tif (IS_AUTOMOUNT(direntry->d_inode) &&\n\t\t\t   !(direntry->d_flags & DCACHE_NEED_AUTOMOUNT)) {\n\t\t\t\tspin_lock(&direntry->d_lock);\n\t\t\t\tdirentry->d_flags |= DCACHE_NEED_AUTOMOUNT;\n\t\t\t\tspin_unlock(&direntry->d_lock);\n\t\t\t}\n\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/*\n\t * This may be nfsd (or something), anyway, we can't see the\n\t * intent of this. So, since this can be for creation, drop it.\n\t */\n\tif (!flags)\n\t\treturn 0;\n\n\t/*\n\t * Drop the negative dentry, in order to make sure to use the\n\t * case sensitive name which is specified by user if this is\n\t * for creation.\n\t */\n\tif (flags & (LOOKUP_CREATE | LOOKUP_RENAME_TARGET))\n\t\treturn 0;\n\n\tif (time_after(jiffies, direntry->d_time + HZ) || !lookupCacheEnabled)\n\t\treturn 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "cifs_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/dir.c",
    "lines": "708-787",
    "snippet": "struct dentry *\ncifs_lookup(struct inode *parent_dir_inode, struct dentry *direntry,\n\t    unsigned int flags)\n{\n\tunsigned int xid;\n\tint rc = 0; /* to get around spurious gcc warning, set to zero here */\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *pTcon;\n\tstruct inode *newInode = NULL;\n\tchar *full_path = NULL;\n\n\txid = get_xid();\n\n\tcifs_dbg(FYI, \"parent inode = 0x%p name is: %pd and dentry = 0x%p\\n\",\n\t\t parent_dir_inode, direntry, direntry);\n\n\t/* check whether path exists */\n\n\tcifs_sb = CIFS_SB(parent_dir_inode->i_sb);\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink)) {\n\t\tfree_xid(xid);\n\t\treturn (struct dentry *)tlink;\n\t}\n\tpTcon = tlink_tcon(tlink);\n\n\trc = check_name(direntry);\n\tif (rc)\n\t\tgoto lookup_out;\n\n\t/* can not grab the rename sem here since it would\n\tdeadlock in the cases (beginning of sys_rename itself)\n\tin which we already have the sb rename sem */\n\tfull_path = build_path_from_dentry(direntry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto lookup_out;\n\t}\n\n\tif (direntry->d_inode != NULL) {\n\t\tcifs_dbg(FYI, \"non-NULL inode in lookup\\n\");\n\t} else {\n\t\tcifs_dbg(FYI, \"NULL inode in lookup\\n\");\n\t}\n\tcifs_dbg(FYI, \"Full path: %s inode = 0x%p\\n\",\n\t\t full_path, direntry->d_inode);\n\n\tif (pTcon->unix_ext) {\n\t\trc = cifs_get_inode_info_unix(&newInode, full_path,\n\t\t\t\t\t      parent_dir_inode->i_sb, xid);\n\t} else {\n\t\trc = cifs_get_inode_info(&newInode, full_path, NULL,\n\t\t\t\tparent_dir_inode->i_sb, xid, NULL);\n\t}\n\n\tif ((rc == 0) && (newInode != NULL)) {\n\t\td_add(direntry, newInode);\n\t\t/* since paths are not looked up by component - the parent\n\t\t   directories are presumed to be good here */\n\t\trenew_parental_timestamps(direntry);\n\n\t} else if (rc == -ENOENT) {\n\t\trc = 0;\n\t\tdirentry->d_time = jiffies;\n\t\td_add(direntry, NULL);\n\t/*\tif it was once a directory (but how can we tell?) we could do\n\t\tshrink_dcache_parent(direntry); */\n\t} else if (rc != -EACCES) {\n\t\tcifs_dbg(FYI, \"Unexpected lookup error %d\\n\", rc);\n\t\t/* We special case check for Access Denied - since that\n\t\tis a common return code */\n\t}\n\nlookup_out:\n\tkfree(full_path);\n\tcifs_put_tlink(tlink);\n\tfree_xid(xid);\n\treturn ERR_PTR(rc);\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "rc"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_xid",
          "args": [
            "xid"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "_free_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "63-71",
          "snippet": "void\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_put_tlink",
          "args": [
            "tlink"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_put_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2666-2682",
          "snippet": "void\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nvoid\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "full_path"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Unexpected lookup error %d\\n\"",
            "rc"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "direntry",
            "NULL"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "renew_parental_timestamps",
          "args": [
            "direntry"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "renew_parental_timestamps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/dir.c",
          "lines": "37-46",
          "snippet": "static void\nrenew_parental_timestamps(struct dentry *direntry)\n{\n\t/* BB check if there is a way to get the kernel to do this or if we\n\t   really need this */\n\tdo {\n\t\tdirentry->d_time = jiffies;\n\t\tdirentry = direntry->d_parent;\n\t} while (!IS_ROOT(direntry));\n}",
          "includes": [
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nstatic void\nrenew_parental_timestamps(struct dentry *direntry)\n{\n\t/* BB check if there is a way to get the kernel to do this or if we\n\t   really need this */\n\tdo {\n\t\tdirentry->d_time = jiffies;\n\t\tdirentry = direntry->d_parent;\n\t} while (!IS_ROOT(direntry));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_get_inode_info",
          "args": [
            "&newInode",
            "full_path",
            "NULL",
            "parent_dir_inode->i_sb",
            "xid",
            "NULL"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_get_inode_info_unix",
          "args": [
            "&newInode",
            "full_path",
            "parent_dir_inode->i_sb",
            "xid"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Full path: %s inode = 0x%p\\n\"",
            "full_path",
            "direntry->d_inode"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"NULL inode in lookup\\n\""
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"non-NULL inode in lookup\\n\""
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_path_from_dentry",
          "args": [
            "direntry"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "build_path_from_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/dir.c",
          "lines": "81-167",
          "snippet": "char *\nbuild_path_from_dentry(struct dentry *direntry)\n{\n\tstruct dentry *temp;\n\tint namelen;\n\tint dfsplen;\n\tchar *full_path;\n\tchar dirsep;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(direntry->d_sb);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\tunsigned seq;\n\n\tdirsep = CIFS_DIR_SEP(cifs_sb);\n\tif (tcon->Flags & SMB_SHARE_IS_IN_DFS)\n\t\tdfsplen = strnlen(tcon->treeName, MAX_TREE_SIZE + 1);\n\telse\n\t\tdfsplen = 0;\ncifs_bp_rename_retry:\n\tnamelen = dfsplen;\n\tseq = read_seqbegin(&rename_lock);\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tnamelen += (1 + temp->d_name.len);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcifs_dbg(VFS, \"corrupt dentry\\n\");\n\t\t\trcu_read_unlock();\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tfull_path = kmalloc(namelen+1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn full_path;\n\tfull_path[namelen] = 0;\t/* trailing null */\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tspin_lock(&temp->d_lock);\n\t\tnamelen -= 1 + temp->d_name.len;\n\t\tif (namelen < 0) {\n\t\t\tspin_unlock(&temp->d_lock);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tfull_path[namelen] = dirsep;\n\t\t\tstrncpy(full_path + namelen + 1, temp->d_name.name,\n\t\t\t\ttemp->d_name.len);\n\t\t\tcifs_dbg(FYI, \"name: %s\\n\", full_path + namelen);\n\t\t}\n\t\tspin_unlock(&temp->d_lock);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcifs_dbg(VFS, \"corrupt dentry\\n\");\n\t\t\trcu_read_unlock();\n\t\t\tkfree(full_path);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tif (namelen != dfsplen || read_seqretry(&rename_lock, seq)) {\n\t\tcifs_dbg(FYI, \"did not end path lookup where expected. namelen=%ddfsplen=%d\\n\",\n\t\t\t namelen, dfsplen);\n\t\t/* presumably this is only possible if racing with a rename\n\t\tof one of the parent directories  (we can not lock the dentries\n\t\tabove us to prevent this, but retrying should be harmless) */\n\t\tkfree(full_path);\n\t\tgoto cifs_bp_rename_retry;\n\t}\n\t/* DIR_SEP already set for byte  0 / vs \\ but not for\n\t   subsequent slashes in prepath which currently must\n\t   be entered the right way - not sure if there is an alternative\n\t   since the '\\' is a valid posix character so we can not switch\n\t   those safely to '/' if any are found in the middle of the prepath */\n\t/* BB test paths to Windows with '/' in the midst of prepath */\n\n\tif (dfsplen) {\n\t\tstrncpy(full_path, tcon->treeName, dfsplen);\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < dfsplen; i++) {\n\t\t\t\tif (full_path[i] == '\\\\')\n\t\t\t\t\tfull_path[i] = '/';\n\t\t\t}\n\t\t}\n\t}\n\treturn full_path;\n}",
          "includes": [
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nchar *\nbuild_path_from_dentry(struct dentry *direntry)\n{\n\tstruct dentry *temp;\n\tint namelen;\n\tint dfsplen;\n\tchar *full_path;\n\tchar dirsep;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(direntry->d_sb);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\tunsigned seq;\n\n\tdirsep = CIFS_DIR_SEP(cifs_sb);\n\tif (tcon->Flags & SMB_SHARE_IS_IN_DFS)\n\t\tdfsplen = strnlen(tcon->treeName, MAX_TREE_SIZE + 1);\n\telse\n\t\tdfsplen = 0;\ncifs_bp_rename_retry:\n\tnamelen = dfsplen;\n\tseq = read_seqbegin(&rename_lock);\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tnamelen += (1 + temp->d_name.len);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcifs_dbg(VFS, \"corrupt dentry\\n\");\n\t\t\trcu_read_unlock();\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tfull_path = kmalloc(namelen+1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn full_path;\n\tfull_path[namelen] = 0;\t/* trailing null */\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tspin_lock(&temp->d_lock);\n\t\tnamelen -= 1 + temp->d_name.len;\n\t\tif (namelen < 0) {\n\t\t\tspin_unlock(&temp->d_lock);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tfull_path[namelen] = dirsep;\n\t\t\tstrncpy(full_path + namelen + 1, temp->d_name.name,\n\t\t\t\ttemp->d_name.len);\n\t\t\tcifs_dbg(FYI, \"name: %s\\n\", full_path + namelen);\n\t\t}\n\t\tspin_unlock(&temp->d_lock);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcifs_dbg(VFS, \"corrupt dentry\\n\");\n\t\t\trcu_read_unlock();\n\t\t\tkfree(full_path);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tif (namelen != dfsplen || read_seqretry(&rename_lock, seq)) {\n\t\tcifs_dbg(FYI, \"did not end path lookup where expected. namelen=%ddfsplen=%d\\n\",\n\t\t\t namelen, dfsplen);\n\t\t/* presumably this is only possible if racing with a rename\n\t\tof one of the parent directories  (we can not lock the dentries\n\t\tabove us to prevent this, but retrying should be harmless) */\n\t\tkfree(full_path);\n\t\tgoto cifs_bp_rename_retry;\n\t}\n\t/* DIR_SEP already set for byte  0 / vs \\ but not for\n\t   subsequent slashes in prepath which currently must\n\t   be entered the right way - not sure if there is an alternative\n\t   since the '\\' is a valid posix character so we can not switch\n\t   those safely to '/' if any are found in the middle of the prepath */\n\t/* BB test paths to Windows with '/' in the midst of prepath */\n\n\tif (dfsplen) {\n\t\tstrncpy(full_path, tcon->treeName, dfsplen);\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < dfsplen; i++) {\n\t\t\t\tif (full_path[i] == '\\\\')\n\t\t\t\t\tfull_path[i] = '/';\n\t\t\t}\n\t\t}\n\t}\n\treturn full_path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_name",
          "args": [
            "direntry"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "check_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/dir.c",
          "lines": "173-188",
          "snippet": "static int\ncheck_name(struct dentry *direntry)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(direntry->d_sb);\n\tint i;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)) {\n\t\tfor (i = 0; i < direntry->d_name.len; i++) {\n\t\t\tif (direntry->d_name.name[i] == '\\\\') {\n\t\t\t\tcifs_dbg(FYI, \"Invalid file name\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nstatic int\ncheck_name(struct dentry *direntry)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(direntry->d_sb);\n\tint i;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)) {\n\t\tfor (i = 0; i < direntry->d_name.len; i++) {\n\t\t\tif (direntry->d_name.name[i] == '\\\\') {\n\t\t\t\tcifs_dbg(FYI, \"Invalid file name\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "tlink"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tlink"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_sb_tlink",
          "args": [
            "cifs_sb"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_sb_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "4011-4082",
          "snippet": "struct tcon_link *\ncifs_sb_tlink(struct cifs_sb_info *cifs_sb)\n{\n\tint ret;\n\tkuid_t fsuid = current_fsuid();\n\tstruct tcon_link *tlink, *newtlink;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\treturn cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\tif (tlink)\n\t\tcifs_get_tlink(tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tif (tlink == NULL) {\n\t\tnewtlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\n\t\tif (newtlink == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnewtlink->tl_uid = fsuid;\n\t\tnewtlink->tl_tcon = ERR_PTR(-EACCES);\n\t\tset_bit(TCON_LINK_PENDING, &newtlink->tl_flags);\n\t\tset_bit(TCON_LINK_IN_TREE, &newtlink->tl_flags);\n\t\tcifs_get_tlink(newtlink);\n\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t\t/* was one inserted after previous search? */\n\t\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\t\tif (tlink) {\n\t\t\tcifs_get_tlink(tlink);\n\t\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\t\tkfree(newtlink);\n\t\t\tgoto wait_for_construction;\n\t\t}\n\t\ttlink = newtlink;\n\t\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t} else {\nwait_for_construction:\n\t\tret = wait_on_bit(&tlink->tl_flags, TCON_LINK_PENDING,\n\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (ret) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-ERESTARTSYS);\n\t\t}\n\n\t\t/* if it's good, return it */\n\t\tif (!IS_ERR(tlink->tl_tcon))\n\t\t\treturn tlink;\n\n\t\t/* return error if we tried this already recently */\n\t\tif (time_before(jiffies, tlink->tl_time + TLINK_ERROR_EXPIRE)) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-EACCES);\n\t\t}\n\n\t\tif (test_and_set_bit(TCON_LINK_PENDING, &tlink->tl_flags))\n\t\t\tgoto wait_for_construction;\n\t}\n\n\ttlink->tl_tcon = cifs_construct_tcon(cifs_sb, fsuid);\n\tclear_bit(TCON_LINK_PENDING, &tlink->tl_flags);\n\twake_up_bit(&tlink->tl_flags, TCON_LINK_PENDING);\n\n\tif (IS_ERR(tlink->tl_tcon)) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn tlink;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define TLINK_ERROR_EXPIRE\t(1 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\n#define TLINK_ERROR_EXPIRE\t(1 * HZ)\n\nstruct tcon_link *\ncifs_sb_tlink(struct cifs_sb_info *cifs_sb)\n{\n\tint ret;\n\tkuid_t fsuid = current_fsuid();\n\tstruct tcon_link *tlink, *newtlink;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\treturn cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\tif (tlink)\n\t\tcifs_get_tlink(tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tif (tlink == NULL) {\n\t\tnewtlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\n\t\tif (newtlink == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnewtlink->tl_uid = fsuid;\n\t\tnewtlink->tl_tcon = ERR_PTR(-EACCES);\n\t\tset_bit(TCON_LINK_PENDING, &newtlink->tl_flags);\n\t\tset_bit(TCON_LINK_IN_TREE, &newtlink->tl_flags);\n\t\tcifs_get_tlink(newtlink);\n\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t\t/* was one inserted after previous search? */\n\t\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\t\tif (tlink) {\n\t\t\tcifs_get_tlink(tlink);\n\t\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\t\tkfree(newtlink);\n\t\t\tgoto wait_for_construction;\n\t\t}\n\t\ttlink = newtlink;\n\t\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t} else {\nwait_for_construction:\n\t\tret = wait_on_bit(&tlink->tl_flags, TCON_LINK_PENDING,\n\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (ret) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-ERESTARTSYS);\n\t\t}\n\n\t\t/* if it's good, return it */\n\t\tif (!IS_ERR(tlink->tl_tcon))\n\t\t\treturn tlink;\n\n\t\t/* return error if we tried this already recently */\n\t\tif (time_before(jiffies, tlink->tl_time + TLINK_ERROR_EXPIRE)) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-EACCES);\n\t\t}\n\n\t\tif (test_and_set_bit(TCON_LINK_PENDING, &tlink->tl_flags))\n\t\t\tgoto wait_for_construction;\n\t}\n\n\ttlink->tl_tcon = cifs_construct_tcon(cifs_sb, fsuid);\n\tclear_bit(TCON_LINK_PENDING, &tlink->tl_flags);\n\twake_up_bit(&tlink->tl_flags, TCON_LINK_PENDING);\n\n\tif (IS_ERR(tlink->tl_tcon)) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn tlink;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "parent_dir_inode->i_sb"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"parent inode = 0x%p name is: %pd and dentry = 0x%p\\n\"",
            "parent_dir_inode",
            "direntry",
            "direntry"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_xid",
          "args": [],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "_get_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "45-61",
          "snippet": "unsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nunsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nstruct dentry *\ncifs_lookup(struct inode *parent_dir_inode, struct dentry *direntry,\n\t    unsigned int flags)\n{\n\tunsigned int xid;\n\tint rc = 0; /* to get around spurious gcc warning, set to zero here */\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *pTcon;\n\tstruct inode *newInode = NULL;\n\tchar *full_path = NULL;\n\n\txid = get_xid();\n\n\tcifs_dbg(FYI, \"parent inode = 0x%p name is: %pd and dentry = 0x%p\\n\",\n\t\t parent_dir_inode, direntry, direntry);\n\n\t/* check whether path exists */\n\n\tcifs_sb = CIFS_SB(parent_dir_inode->i_sb);\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink)) {\n\t\tfree_xid(xid);\n\t\treturn (struct dentry *)tlink;\n\t}\n\tpTcon = tlink_tcon(tlink);\n\n\trc = check_name(direntry);\n\tif (rc)\n\t\tgoto lookup_out;\n\n\t/* can not grab the rename sem here since it would\n\tdeadlock in the cases (beginning of sys_rename itself)\n\tin which we already have the sb rename sem */\n\tfull_path = build_path_from_dentry(direntry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto lookup_out;\n\t}\n\n\tif (direntry->d_inode != NULL) {\n\t\tcifs_dbg(FYI, \"non-NULL inode in lookup\\n\");\n\t} else {\n\t\tcifs_dbg(FYI, \"NULL inode in lookup\\n\");\n\t}\n\tcifs_dbg(FYI, \"Full path: %s inode = 0x%p\\n\",\n\t\t full_path, direntry->d_inode);\n\n\tif (pTcon->unix_ext) {\n\t\trc = cifs_get_inode_info_unix(&newInode, full_path,\n\t\t\t\t\t      parent_dir_inode->i_sb, xid);\n\t} else {\n\t\trc = cifs_get_inode_info(&newInode, full_path, NULL,\n\t\t\t\tparent_dir_inode->i_sb, xid, NULL);\n\t}\n\n\tif ((rc == 0) && (newInode != NULL)) {\n\t\td_add(direntry, newInode);\n\t\t/* since paths are not looked up by component - the parent\n\t\t   directories are presumed to be good here */\n\t\trenew_parental_timestamps(direntry);\n\n\t} else if (rc == -ENOENT) {\n\t\trc = 0;\n\t\tdirentry->d_time = jiffies;\n\t\td_add(direntry, NULL);\n\t/*\tif it was once a directory (but how can we tell?) we could do\n\t\tshrink_dcache_parent(direntry); */\n\t} else if (rc != -EACCES) {\n\t\tcifs_dbg(FYI, \"Unexpected lookup error %d\\n\", rc);\n\t\t/* We special case check for Access Denied - since that\n\t\tis a common return code */\n\t}\n\nlookup_out:\n\tkfree(full_path);\n\tcifs_put_tlink(tlink);\n\tfree_xid(xid);\n\treturn ERR_PTR(rc);\n}"
  },
  {
    "function_name": "cifs_mknod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/dir.c",
    "lines": "568-706",
    "snippet": "int cifs_mknod(struct inode *inode, struct dentry *direntry, umode_t mode,\n\t\tdev_t device_number)\n{\n\tint rc = -EPERM;\n\tunsigned int xid;\n\tint create_options = CREATE_NOT_DIR | CREATE_OPTION_SPECIAL;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\tstruct cifs_io_parms io_parms;\n\tchar *full_path = NULL;\n\tstruct inode *newinode = NULL;\n\t__u32 oplock = 0;\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\tFILE_ALL_INFO *buf = NULL;\n\tunsigned int bytes_written;\n\tstruct win_dev *pdev;\n\tstruct kvec iov[2];\n\n\tif (!old_valid_dev(device_number))\n\t\treturn -EINVAL;\n\n\tcifs_sb = CIFS_SB(inode->i_sb);\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\n\ttcon = tlink_tcon(tlink);\n\n\txid = get_xid();\n\n\tfull_path = build_path_from_dentry(direntry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto mknod_out;\n\t}\n\n\tif (tcon->unix_ext) {\n\t\tstruct cifs_unix_set_info_args args = {\n\t\t\t.mode\t= mode & ~current_umask(),\n\t\t\t.ctime\t= NO_CHANGE_64,\n\t\t\t.atime\t= NO_CHANGE_64,\n\t\t\t.mtime\t= NO_CHANGE_64,\n\t\t\t.device\t= device_number,\n\t\t};\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID) {\n\t\t\targs.uid = current_fsuid();\n\t\t\targs.gid = current_fsgid();\n\t\t} else {\n\t\t\targs.uid = INVALID_UID; /* no change */\n\t\t\targs.gid = INVALID_GID; /* no change */\n\t\t}\n\t\trc = CIFSSMBUnixSetPathInfo(xid, tcon, full_path, &args,\n\t\t\t\t\t    cifs_sb->local_nls,\n\t\t\t\t\t    cifs_sb->mnt_cifs_flags &\n\t\t\t\t\t\tCIFS_MOUNT_MAP_SPECIAL_CHR);\n\t\tif (rc)\n\t\t\tgoto mknod_out;\n\n\t\trc = cifs_get_inode_info_unix(&newinode, full_path,\n\t\t\t\t\t\tinode->i_sb, xid);\n\n\t\tif (rc == 0)\n\t\t\td_instantiate(direntry, newinode);\n\t\tgoto mknod_out;\n\t}\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_UNX_EMUL))\n\t\tgoto mknod_out;\n\n\n\tcifs_dbg(FYI, \"sfu compat create special file\\n\");\n\n\tbuf = kmalloc(sizeof(FILE_ALL_INFO), GFP_KERNEL);\n\tif (buf == NULL) {\n\t\tkfree(full_path);\n\t\trc = -ENOMEM;\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\n\tif (backup_cred(cifs_sb))\n\t\tcreate_options |= CREATE_OPEN_BACKUP_INTENT;\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = GENERIC_WRITE;\n\toparms.create_options = create_options;\n\toparms.disposition = FILE_CREATE;\n\toparms.path = full_path;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\tif (tcon->ses->server->oplocks)\n\t\toplock = REQ_OPLOCK;\n\telse\n\t\toplock = 0;\n\trc = tcon->ses->server->ops->open(xid, &oparms, &oplock, buf);\n\tif (rc)\n\t\tgoto mknod_out;\n\n\t/*\n\t * BB Do not bother to decode buf since no local inode yet to put\n\t * timestamps in, but we can reuse it safely.\n\t */\n\n\tpdev = (struct win_dev *)buf;\n\tio_parms.pid = current->tgid;\n\tio_parms.tcon = tcon;\n\tio_parms.offset = 0;\n\tio_parms.length = sizeof(struct win_dev);\n\tiov[1].iov_base = buf;\n\tiov[1].iov_len = sizeof(struct win_dev);\n\tif (S_ISCHR(mode)) {\n\t\tmemcpy(pdev->type, \"IntxCHR\", 8);\n\t\tpdev->major = cpu_to_le64(MAJOR(device_number));\n\t\tpdev->minor = cpu_to_le64(MINOR(device_number));\n\t\trc = tcon->ses->server->ops->sync_write(xid, &fid, &io_parms,\n\t\t\t\t\t\t\t&bytes_written, iov, 1);\n\t} else if (S_ISBLK(mode)) {\n\t\tmemcpy(pdev->type, \"IntxBLK\", 8);\n\t\tpdev->major = cpu_to_le64(MAJOR(device_number));\n\t\tpdev->minor = cpu_to_le64(MINOR(device_number));\n\t\trc = tcon->ses->server->ops->sync_write(xid, &fid, &io_parms,\n\t\t\t\t\t\t\t&bytes_written, iov, 1);\n\t} /* else if (S_ISFIFO) */\n\ttcon->ses->server->ops->close(xid, tcon, &fid);\n\td_drop(direntry);\n\n\t/* FIXME: add code here to set EAs */\n\nmknod_out:\n\tkfree(full_path);\n\tkfree(buf);\n\tfree_xid(xid);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_put_tlink",
          "args": [
            "tlink"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_put_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2666-2682",
          "snippet": "void\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nvoid\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_xid",
          "args": [
            "xid"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "_free_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "63-71",
          "snippet": "void\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "full_path"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_drop",
          "args": [
            "direntry"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "check_and_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1447-1453",
          "snippet": "static void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tcon->ses->server->ops->close",
          "args": [
            "xid",
            "tcon",
            "&fid"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcon->ses->server->ops->sync_write",
          "args": [
            "xid",
            "&fid",
            "&io_parms",
            "&bytes_written",
            "iov",
            "1"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "MINOR(device_number)"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "device_number"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "MAJOR(device_number)"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "device_number"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "pdev->type",
            "\"IntxBLK\"",
            "8"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "mode"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcon->ses->server->ops->sync_write",
          "args": [
            "xid",
            "&fid",
            "&io_parms",
            "&bytes_written",
            "iov",
            "1"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "MINOR(device_number)"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "device_number"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "MAJOR(device_number)"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "device_number"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "pdev->type",
            "\"IntxCHR\"",
            "8"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "mode"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tcon->ses->server->ops->open",
          "args": [
            "xid",
            "&oparms",
            "&oplock",
            "buf"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "backup_cred",
          "args": [
            "cifs_sb"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "backup_cred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "598-611",
          "snippet": "bool\nbackup_cred(struct cifs_sb_info *cifs_sb)\n{\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPUID) {\n\t\tif (uid_eq(cifs_sb->mnt_backupuid, current_fsuid()))\n\t\t\treturn true;\n\t}\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPGID) {\n\t\tif (in_group_p(cifs_sb->mnt_backupgid))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nbool\nbackup_cred(struct cifs_sb_info *cifs_sb)\n{\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPUID) {\n\t\tif (uid_eq(cifs_sb->mnt_backupuid, current_fsuid()))\n\t\t\treturn true;\n\t}\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPGID) {\n\t\tif (in_group_p(cifs_sb->mnt_backupgid))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "full_path"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(FILE_ALL_INFO)",
            "GFP_KERNEL"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"sfu compat create special file\\n\""
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "direntry",
            "newinode"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_get_inode_info_unix",
          "args": [
            "&newinode",
            "full_path",
            "inode->i_sb",
            "xid"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFSSMBUnixSetPathInfo",
          "args": [
            "xid",
            "tcon",
            "full_path",
            "&args",
            "cifs_sb->local_nls",
            "cifs_sb->mnt_cifs_flags &\n\t\t\t\t\t\tCIFS_MOUNT_MAP_SPECIAL_CHR"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMBUnixSetPathInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "6056-6132",
          "snippet": "int\nCIFSSMBUnixSetPathInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t       const char *file_name,\n\t\t       const struct cifs_unix_set_info_args *args,\n\t\t       const struct nls_table *nls_codepage, int remap)\n{\n\tTRANSACTION2_SPI_REQ *pSMB = NULL;\n\tTRANSACTION2_SPI_RSP *pSMBr = NULL;\n\tint name_len;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tFILE_UNIX_BASIC_INFO *data_offset;\n\t__u16 params, param_offset, offset, count, byte_count;\n\n\tcifs_dbg(FYI, \"In SetUID/GID/Mode\\n\");\nsetPermsRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, file_name,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(file_name, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, file_name, name_len);\n\t}\n\n\tparams = 6 + name_len;\n\tcount = sizeof(FILE_UNIX_BASIC_INFO);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\tdata_offset =\n\t    (FILE_UNIX_BASIC_INFO *) ((char *) &pSMB->hdr.Protocol +\n\t\t\t\t      offset);\n\tmemset(data_offset, 0, count);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_UNIX_BASIC);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\n\tcifs_fill_unix_set_info(data_offset, args);\n\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"SetPathInfo (perms) returned %d\\n\", rc);\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto setPermsRetry;\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBUnixSetPathInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t       const char *file_name,\n\t\t       const struct cifs_unix_set_info_args *args,\n\t\t       const struct nls_table *nls_codepage, int remap)\n{\n\tTRANSACTION2_SPI_REQ *pSMB = NULL;\n\tTRANSACTION2_SPI_RSP *pSMBr = NULL;\n\tint name_len;\n\tint rc = 0;\n\tint bytes_returned = 0;\n\tFILE_UNIX_BASIC_INFO *data_offset;\n\t__u16 params, param_offset, offset, count, byte_count;\n\n\tcifs_dbg(FYI, \"In SetUID/GID/Mode\\n\");\nsetPermsRetry:\n\trc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,\n\t\t      (void **) &pSMBr);\n\tif (rc)\n\t\treturn rc;\n\n\tif (pSMB->hdr.Flags2 & SMBFLG2_UNICODE) {\n\t\tname_len =\n\t\t    cifsConvertToUTF16((__le16 *) pSMB->FileName, file_name,\n\t\t\t\t       PATH_MAX, nls_codepage, remap);\n\t\tname_len++;\t/* trailing null */\n\t\tname_len *= 2;\n\t} else {\t/* BB improve the check for buffer overruns BB */\n\t\tname_len = strnlen(file_name, PATH_MAX);\n\t\tname_len++;\t/* trailing null */\n\t\tstrncpy(pSMB->FileName, file_name, name_len);\n\t}\n\n\tparams = 6 + name_len;\n\tcount = sizeof(FILE_UNIX_BASIC_INFO);\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find max SMB PDU from sess structure BB */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_spi_req,\n\t\t\t\tInformationLevel) - 4;\n\toffset = param_offset + params;\n\tdata_offset =\n\t    (FILE_UNIX_BASIC_INFO *) ((char *) &pSMB->hdr.Protocol +\n\t\t\t\t      offset);\n\tmemset(data_offset, 0, count);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_PATH_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_UNIX_BASIC);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\n\tcifs_fill_unix_set_info(data_offset, args);\n\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\trc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,\n\t\t\t (struct smb_hdr *) pSMBr, &bytes_returned, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"SetPathInfo (perms) returned %d\\n\", rc);\n\n\tcifs_buf_release(pSMB);\n\tif (rc == -EAGAIN)\n\t\tgoto setPermsRetry;\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fsgid",
          "args": [],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_umask",
          "args": [],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "current_umask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs_struct.c",
          "lines": "154-157",
          "snippet": "int current_umask(void)\n{\n\treturn current->fs->umask;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/slab.h>",
            "#include <linux/path.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/slab.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n\nint current_umask(void)\n{\n\treturn current->fs->umask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "build_path_from_dentry",
          "args": [
            "direntry"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "build_path_from_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/dir.c",
          "lines": "81-167",
          "snippet": "char *\nbuild_path_from_dentry(struct dentry *direntry)\n{\n\tstruct dentry *temp;\n\tint namelen;\n\tint dfsplen;\n\tchar *full_path;\n\tchar dirsep;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(direntry->d_sb);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\tunsigned seq;\n\n\tdirsep = CIFS_DIR_SEP(cifs_sb);\n\tif (tcon->Flags & SMB_SHARE_IS_IN_DFS)\n\t\tdfsplen = strnlen(tcon->treeName, MAX_TREE_SIZE + 1);\n\telse\n\t\tdfsplen = 0;\ncifs_bp_rename_retry:\n\tnamelen = dfsplen;\n\tseq = read_seqbegin(&rename_lock);\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tnamelen += (1 + temp->d_name.len);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcifs_dbg(VFS, \"corrupt dentry\\n\");\n\t\t\trcu_read_unlock();\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tfull_path = kmalloc(namelen+1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn full_path;\n\tfull_path[namelen] = 0;\t/* trailing null */\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tspin_lock(&temp->d_lock);\n\t\tnamelen -= 1 + temp->d_name.len;\n\t\tif (namelen < 0) {\n\t\t\tspin_unlock(&temp->d_lock);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tfull_path[namelen] = dirsep;\n\t\t\tstrncpy(full_path + namelen + 1, temp->d_name.name,\n\t\t\t\ttemp->d_name.len);\n\t\t\tcifs_dbg(FYI, \"name: %s\\n\", full_path + namelen);\n\t\t}\n\t\tspin_unlock(&temp->d_lock);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcifs_dbg(VFS, \"corrupt dentry\\n\");\n\t\t\trcu_read_unlock();\n\t\t\tkfree(full_path);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tif (namelen != dfsplen || read_seqretry(&rename_lock, seq)) {\n\t\tcifs_dbg(FYI, \"did not end path lookup where expected. namelen=%ddfsplen=%d\\n\",\n\t\t\t namelen, dfsplen);\n\t\t/* presumably this is only possible if racing with a rename\n\t\tof one of the parent directories  (we can not lock the dentries\n\t\tabove us to prevent this, but retrying should be harmless) */\n\t\tkfree(full_path);\n\t\tgoto cifs_bp_rename_retry;\n\t}\n\t/* DIR_SEP already set for byte  0 / vs \\ but not for\n\t   subsequent slashes in prepath which currently must\n\t   be entered the right way - not sure if there is an alternative\n\t   since the '\\' is a valid posix character so we can not switch\n\t   those safely to '/' if any are found in the middle of the prepath */\n\t/* BB test paths to Windows with '/' in the midst of prepath */\n\n\tif (dfsplen) {\n\t\tstrncpy(full_path, tcon->treeName, dfsplen);\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < dfsplen; i++) {\n\t\t\t\tif (full_path[i] == '\\\\')\n\t\t\t\t\tfull_path[i] = '/';\n\t\t\t}\n\t\t}\n\t}\n\treturn full_path;\n}",
          "includes": [
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nchar *\nbuild_path_from_dentry(struct dentry *direntry)\n{\n\tstruct dentry *temp;\n\tint namelen;\n\tint dfsplen;\n\tchar *full_path;\n\tchar dirsep;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(direntry->d_sb);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\tunsigned seq;\n\n\tdirsep = CIFS_DIR_SEP(cifs_sb);\n\tif (tcon->Flags & SMB_SHARE_IS_IN_DFS)\n\t\tdfsplen = strnlen(tcon->treeName, MAX_TREE_SIZE + 1);\n\telse\n\t\tdfsplen = 0;\ncifs_bp_rename_retry:\n\tnamelen = dfsplen;\n\tseq = read_seqbegin(&rename_lock);\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tnamelen += (1 + temp->d_name.len);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcifs_dbg(VFS, \"corrupt dentry\\n\");\n\t\t\trcu_read_unlock();\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tfull_path = kmalloc(namelen+1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn full_path;\n\tfull_path[namelen] = 0;\t/* trailing null */\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tspin_lock(&temp->d_lock);\n\t\tnamelen -= 1 + temp->d_name.len;\n\t\tif (namelen < 0) {\n\t\t\tspin_unlock(&temp->d_lock);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tfull_path[namelen] = dirsep;\n\t\t\tstrncpy(full_path + namelen + 1, temp->d_name.name,\n\t\t\t\ttemp->d_name.len);\n\t\t\tcifs_dbg(FYI, \"name: %s\\n\", full_path + namelen);\n\t\t}\n\t\tspin_unlock(&temp->d_lock);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcifs_dbg(VFS, \"corrupt dentry\\n\");\n\t\t\trcu_read_unlock();\n\t\t\tkfree(full_path);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tif (namelen != dfsplen || read_seqretry(&rename_lock, seq)) {\n\t\tcifs_dbg(FYI, \"did not end path lookup where expected. namelen=%ddfsplen=%d\\n\",\n\t\t\t namelen, dfsplen);\n\t\t/* presumably this is only possible if racing with a rename\n\t\tof one of the parent directories  (we can not lock the dentries\n\t\tabove us to prevent this, but retrying should be harmless) */\n\t\tkfree(full_path);\n\t\tgoto cifs_bp_rename_retry;\n\t}\n\t/* DIR_SEP already set for byte  0 / vs \\ but not for\n\t   subsequent slashes in prepath which currently must\n\t   be entered the right way - not sure if there is an alternative\n\t   since the '\\' is a valid posix character so we can not switch\n\t   those safely to '/' if any are found in the middle of the prepath */\n\t/* BB test paths to Windows with '/' in the midst of prepath */\n\n\tif (dfsplen) {\n\t\tstrncpy(full_path, tcon->treeName, dfsplen);\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < dfsplen; i++) {\n\t\t\t\tif (full_path[i] == '\\\\')\n\t\t\t\t\tfull_path[i] = '/';\n\t\t\t}\n\t\t}\n\t}\n\treturn full_path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_xid",
          "args": [],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "_get_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "45-61",
          "snippet": "unsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nunsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "tlink"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tlink"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tlink"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_sb_tlink",
          "args": [
            "cifs_sb"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_sb_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "4011-4082",
          "snippet": "struct tcon_link *\ncifs_sb_tlink(struct cifs_sb_info *cifs_sb)\n{\n\tint ret;\n\tkuid_t fsuid = current_fsuid();\n\tstruct tcon_link *tlink, *newtlink;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\treturn cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\tif (tlink)\n\t\tcifs_get_tlink(tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tif (tlink == NULL) {\n\t\tnewtlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\n\t\tif (newtlink == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnewtlink->tl_uid = fsuid;\n\t\tnewtlink->tl_tcon = ERR_PTR(-EACCES);\n\t\tset_bit(TCON_LINK_PENDING, &newtlink->tl_flags);\n\t\tset_bit(TCON_LINK_IN_TREE, &newtlink->tl_flags);\n\t\tcifs_get_tlink(newtlink);\n\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t\t/* was one inserted after previous search? */\n\t\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\t\tif (tlink) {\n\t\t\tcifs_get_tlink(tlink);\n\t\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\t\tkfree(newtlink);\n\t\t\tgoto wait_for_construction;\n\t\t}\n\t\ttlink = newtlink;\n\t\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t} else {\nwait_for_construction:\n\t\tret = wait_on_bit(&tlink->tl_flags, TCON_LINK_PENDING,\n\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (ret) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-ERESTARTSYS);\n\t\t}\n\n\t\t/* if it's good, return it */\n\t\tif (!IS_ERR(tlink->tl_tcon))\n\t\t\treturn tlink;\n\n\t\t/* return error if we tried this already recently */\n\t\tif (time_before(jiffies, tlink->tl_time + TLINK_ERROR_EXPIRE)) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-EACCES);\n\t\t}\n\n\t\tif (test_and_set_bit(TCON_LINK_PENDING, &tlink->tl_flags))\n\t\t\tgoto wait_for_construction;\n\t}\n\n\ttlink->tl_tcon = cifs_construct_tcon(cifs_sb, fsuid);\n\tclear_bit(TCON_LINK_PENDING, &tlink->tl_flags);\n\twake_up_bit(&tlink->tl_flags, TCON_LINK_PENDING);\n\n\tif (IS_ERR(tlink->tl_tcon)) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn tlink;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define TLINK_ERROR_EXPIRE\t(1 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\n#define TLINK_ERROR_EXPIRE\t(1 * HZ)\n\nstruct tcon_link *\ncifs_sb_tlink(struct cifs_sb_info *cifs_sb)\n{\n\tint ret;\n\tkuid_t fsuid = current_fsuid();\n\tstruct tcon_link *tlink, *newtlink;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\treturn cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\tif (tlink)\n\t\tcifs_get_tlink(tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tif (tlink == NULL) {\n\t\tnewtlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\n\t\tif (newtlink == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnewtlink->tl_uid = fsuid;\n\t\tnewtlink->tl_tcon = ERR_PTR(-EACCES);\n\t\tset_bit(TCON_LINK_PENDING, &newtlink->tl_flags);\n\t\tset_bit(TCON_LINK_IN_TREE, &newtlink->tl_flags);\n\t\tcifs_get_tlink(newtlink);\n\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t\t/* was one inserted after previous search? */\n\t\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\t\tif (tlink) {\n\t\t\tcifs_get_tlink(tlink);\n\t\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\t\tkfree(newtlink);\n\t\t\tgoto wait_for_construction;\n\t\t}\n\t\ttlink = newtlink;\n\t\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t} else {\nwait_for_construction:\n\t\tret = wait_on_bit(&tlink->tl_flags, TCON_LINK_PENDING,\n\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (ret) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-ERESTARTSYS);\n\t\t}\n\n\t\t/* if it's good, return it */\n\t\tif (!IS_ERR(tlink->tl_tcon))\n\t\t\treturn tlink;\n\n\t\t/* return error if we tried this already recently */\n\t\tif (time_before(jiffies, tlink->tl_time + TLINK_ERROR_EXPIRE)) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-EACCES);\n\t\t}\n\n\t\tif (test_and_set_bit(TCON_LINK_PENDING, &tlink->tl_flags))\n\t\t\tgoto wait_for_construction;\n\t}\n\n\ttlink->tl_tcon = cifs_construct_tcon(cifs_sb, fsuid);\n\tclear_bit(TCON_LINK_PENDING, &tlink->tl_flags);\n\twake_up_bit(&tlink->tl_flags, TCON_LINK_PENDING);\n\n\tif (IS_ERR(tlink->tl_tcon)) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn tlink;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "old_valid_dev",
          "args": [
            "device_number"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nint cifs_mknod(struct inode *inode, struct dentry *direntry, umode_t mode,\n\t\tdev_t device_number)\n{\n\tint rc = -EPERM;\n\tunsigned int xid;\n\tint create_options = CREATE_NOT_DIR | CREATE_OPTION_SPECIAL;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\tstruct cifs_io_parms io_parms;\n\tchar *full_path = NULL;\n\tstruct inode *newinode = NULL;\n\t__u32 oplock = 0;\n\tstruct cifs_fid fid;\n\tstruct cifs_open_parms oparms;\n\tFILE_ALL_INFO *buf = NULL;\n\tunsigned int bytes_written;\n\tstruct win_dev *pdev;\n\tstruct kvec iov[2];\n\n\tif (!old_valid_dev(device_number))\n\t\treturn -EINVAL;\n\n\tcifs_sb = CIFS_SB(inode->i_sb);\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink))\n\t\treturn PTR_ERR(tlink);\n\n\ttcon = tlink_tcon(tlink);\n\n\txid = get_xid();\n\n\tfull_path = build_path_from_dentry(direntry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto mknod_out;\n\t}\n\n\tif (tcon->unix_ext) {\n\t\tstruct cifs_unix_set_info_args args = {\n\t\t\t.mode\t= mode & ~current_umask(),\n\t\t\t.ctime\t= NO_CHANGE_64,\n\t\t\t.atime\t= NO_CHANGE_64,\n\t\t\t.mtime\t= NO_CHANGE_64,\n\t\t\t.device\t= device_number,\n\t\t};\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID) {\n\t\t\targs.uid = current_fsuid();\n\t\t\targs.gid = current_fsgid();\n\t\t} else {\n\t\t\targs.uid = INVALID_UID; /* no change */\n\t\t\targs.gid = INVALID_GID; /* no change */\n\t\t}\n\t\trc = CIFSSMBUnixSetPathInfo(xid, tcon, full_path, &args,\n\t\t\t\t\t    cifs_sb->local_nls,\n\t\t\t\t\t    cifs_sb->mnt_cifs_flags &\n\t\t\t\t\t\tCIFS_MOUNT_MAP_SPECIAL_CHR);\n\t\tif (rc)\n\t\t\tgoto mknod_out;\n\n\t\trc = cifs_get_inode_info_unix(&newinode, full_path,\n\t\t\t\t\t\tinode->i_sb, xid);\n\n\t\tif (rc == 0)\n\t\t\td_instantiate(direntry, newinode);\n\t\tgoto mknod_out;\n\t}\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_UNX_EMUL))\n\t\tgoto mknod_out;\n\n\n\tcifs_dbg(FYI, \"sfu compat create special file\\n\");\n\n\tbuf = kmalloc(sizeof(FILE_ALL_INFO), GFP_KERNEL);\n\tif (buf == NULL) {\n\t\tkfree(full_path);\n\t\trc = -ENOMEM;\n\t\tfree_xid(xid);\n\t\treturn rc;\n\t}\n\n\tif (backup_cred(cifs_sb))\n\t\tcreate_options |= CREATE_OPEN_BACKUP_INTENT;\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = GENERIC_WRITE;\n\toparms.create_options = create_options;\n\toparms.disposition = FILE_CREATE;\n\toparms.path = full_path;\n\toparms.fid = &fid;\n\toparms.reconnect = false;\n\n\tif (tcon->ses->server->oplocks)\n\t\toplock = REQ_OPLOCK;\n\telse\n\t\toplock = 0;\n\trc = tcon->ses->server->ops->open(xid, &oparms, &oplock, buf);\n\tif (rc)\n\t\tgoto mknod_out;\n\n\t/*\n\t * BB Do not bother to decode buf since no local inode yet to put\n\t * timestamps in, but we can reuse it safely.\n\t */\n\n\tpdev = (struct win_dev *)buf;\n\tio_parms.pid = current->tgid;\n\tio_parms.tcon = tcon;\n\tio_parms.offset = 0;\n\tio_parms.length = sizeof(struct win_dev);\n\tiov[1].iov_base = buf;\n\tiov[1].iov_len = sizeof(struct win_dev);\n\tif (S_ISCHR(mode)) {\n\t\tmemcpy(pdev->type, \"IntxCHR\", 8);\n\t\tpdev->major = cpu_to_le64(MAJOR(device_number));\n\t\tpdev->minor = cpu_to_le64(MINOR(device_number));\n\t\trc = tcon->ses->server->ops->sync_write(xid, &fid, &io_parms,\n\t\t\t\t\t\t\t&bytes_written, iov, 1);\n\t} else if (S_ISBLK(mode)) {\n\t\tmemcpy(pdev->type, \"IntxBLK\", 8);\n\t\tpdev->major = cpu_to_le64(MAJOR(device_number));\n\t\tpdev->minor = cpu_to_le64(MINOR(device_number));\n\t\trc = tcon->ses->server->ops->sync_write(xid, &fid, &io_parms,\n\t\t\t\t\t\t\t&bytes_written, iov, 1);\n\t} /* else if (S_ISFIFO) */\n\ttcon->ses->server->ops->close(xid, tcon, &fid);\n\td_drop(direntry);\n\n\t/* FIXME: add code here to set EAs */\n\nmknod_out:\n\tkfree(full_path);\n\tkfree(buf);\n\tfree_xid(xid);\n\tcifs_put_tlink(tlink);\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/dir.c",
    "lines": "524-566",
    "snippet": "int cifs_create(struct inode *inode, struct dentry *direntry, umode_t mode,\n\t\tbool excl)\n{\n\tint rc;\n\tunsigned int xid = get_xid();\n\t/*\n\t * BB below access is probably too much for mknod to request\n\t *    but we have to do query and setpathinfo so requesting\n\t *    less could fail (unless we want to request getatr and setatr\n\t *    permissions (only).  At least for POSIX we do not have to\n\t *    request so much.\n\t */\n\tunsigned oflags = O_EXCL | O_CREAT | O_RDWR;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_fid fid;\n\t__u32 oplock;\n\n\tcifs_dbg(FYI, \"cifs_create parent inode = 0x%p name is: %pd and dentry = 0x%p\\n\",\n\t\t inode, direntry, direntry);\n\n\ttlink = cifs_sb_tlink(CIFS_SB(inode->i_sb));\n\trc = PTR_ERR(tlink);\n\tif (IS_ERR(tlink))\n\t\tgoto out_free_xid;\n\n\ttcon = tlink_tcon(tlink);\n\tserver = tcon->ses->server;\n\n\tif (server->ops->new_lease_key)\n\t\tserver->ops->new_lease_key(&fid);\n\n\trc = cifs_do_create(inode, direntry, xid, tlink, oflags, mode,\n\t\t\t    &oplock, &fid);\n\tif (!rc && server->ops->close)\n\t\tserver->ops->close(xid, tcon, &fid);\n\n\tcifs_put_tlink(tlink);\nout_free_xid:\n\tfree_xid(xid);\n\treturn rc;\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_xid",
          "args": [
            "xid"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "_free_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "63-71",
          "snippet": "void\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_put_tlink",
          "args": [
            "tlink"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_put_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2666-2682",
          "snippet": "void\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nvoid\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->ops->close",
          "args": [
            "xid",
            "tcon",
            "&fid"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_do_create",
          "args": [
            "inode",
            "direntry",
            "xid",
            "tlink",
            "oflags",
            "mode",
            "&oplock",
            "&fid"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_do_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/dir.c",
          "lines": "193-413",
          "snippet": "static int\ncifs_do_create(struct inode *inode, struct dentry *direntry, unsigned int xid,\n\t       struct tcon_link *tlink, unsigned oflags, umode_t mode,\n\t       __u32 *oplock, struct cifs_fid *fid)\n{\n\tint rc = -ENOENT;\n\tint create_options = CREATE_NOT_DIR;\n\tint desired_access;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct cifs_tcon *tcon = tlink_tcon(tlink);\n\tchar *full_path = NULL;\n\tFILE_ALL_INFO *buf = NULL;\n\tstruct inode *newinode = NULL;\n\tint disposition;\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct cifs_open_parms oparms;\n\n\t*oplock = 0;\n\tif (tcon->ses->server->oplocks)\n\t\t*oplock = REQ_OPLOCK;\n\n\tfull_path = build_path_from_dentry(direntry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (tcon->unix_ext && cap_unix(tcon->ses) && !tcon->broken_posix_open &&\n\t    (CIFS_UNIX_POSIX_PATH_OPS_CAP &\n\t\t\tle64_to_cpu(tcon->fsUnixInfo.Capability))) {\n\t\trc = cifs_posix_open(full_path, &newinode, inode->i_sb, mode,\n\t\t\t\t     oflags, oplock, &fid->netfid, xid);\n\t\tswitch (rc) {\n\t\tcase 0:\n\t\t\tif (newinode == NULL) {\n\t\t\t\t/* query inode info */\n\t\t\t\tgoto cifs_create_get_file_info;\n\t\t\t}\n\n\t\t\tif (!S_ISREG(newinode->i_mode)) {\n\t\t\t\t/*\n\t\t\t\t * The server may allow us to open things like\n\t\t\t\t * FIFOs, but the client isn't set up to deal\n\t\t\t\t * with that. If it's not a regular file, just\n\t\t\t\t * close it and proceed as if it were a normal\n\t\t\t\t * lookup.\n\t\t\t\t */\n\t\t\t\tCIFSSMBClose(xid, tcon, fid->netfid);\n\t\t\t\tgoto cifs_create_get_file_info;\n\t\t\t}\n\t\t\t/* success, no need to query */\n\t\t\tgoto cifs_create_set_dentry;\n\n\t\tcase -ENOENT:\n\t\t\tgoto cifs_create_get_file_info;\n\n\t\tcase -EIO:\n\t\tcase -EINVAL:\n\t\t\t/*\n\t\t\t * EIO could indicate that (posix open) operation is not\n\t\t\t * supported, despite what server claimed in capability\n\t\t\t * negotiation.\n\t\t\t *\n\t\t\t * POSIX open in samba versions 3.3.1 and earlier could\n\t\t\t * incorrectly fail with invalid parameter.\n\t\t\t */\n\t\t\ttcon->broken_posix_open = true;\n\t\t\tbreak;\n\n\t\tcase -EREMOTE:\n\t\tcase -EOPNOTSUPP:\n\t\t\t/*\n\t\t\t * EREMOTE indicates DFS junction, which is not handled\n\t\t\t * in posix open.  If either that or op not supported\n\t\t\t * returned, follow the normal lookup.\n\t\t\t */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * fallthrough to retry, using older open call, this is case\n\t\t * where server does not support this SMB level, and falsely\n\t\t * claims capability (also get here for DFS case which should be\n\t\t * rare for path not covered on files)\n\t\t */\n\t}\n\n\tdesired_access = 0;\n\tif (OPEN_FMODE(oflags) & FMODE_READ)\n\t\tdesired_access |= GENERIC_READ; /* is this too little? */\n\tif (OPEN_FMODE(oflags) & FMODE_WRITE)\n\t\tdesired_access |= GENERIC_WRITE;\n\n\tdisposition = FILE_OVERWRITE_IF;\n\tif ((oflags & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL))\n\t\tdisposition = FILE_CREATE;\n\telse if ((oflags & (O_CREAT | O_TRUNC)) == (O_CREAT | O_TRUNC))\n\t\tdisposition = FILE_OVERWRITE_IF;\n\telse if ((oflags & O_CREAT) == O_CREAT)\n\t\tdisposition = FILE_OPEN_IF;\n\telse\n\t\tcifs_dbg(FYI, \"Create flag not set in create function\\n\");\n\n\t/*\n\t * BB add processing to set equivalent of mode - e.g. via CreateX with\n\t * ACLs\n\t */\n\n\tif (!server->ops->open) {\n\t\trc = -ENOSYS;\n\t\tgoto out;\n\t}\n\n\tbuf = kmalloc(sizeof(FILE_ALL_INFO), GFP_KERNEL);\n\tif (buf == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * if we're not using unix extensions, see if we need to set\n\t * ATTR_READONLY on the create call\n\t */\n\tif (!tcon->unix_ext && (mode & S_IWUGO) == 0)\n\t\tcreate_options |= CREATE_OPTION_READONLY;\n\n\tif (backup_cred(cifs_sb))\n\t\tcreate_options |= CREATE_OPEN_BACKUP_INTENT;\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = desired_access;\n\toparms.create_options = create_options;\n\toparms.disposition = disposition;\n\toparms.path = full_path;\n\toparms.fid = fid;\n\toparms.reconnect = false;\n\n\trc = server->ops->open(xid, &oparms, oplock, buf);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"cifs_create returned 0x%x\\n\", rc);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If Open reported that we actually created a file then we now have to\n\t * set the mode if possible.\n\t */\n\tif ((tcon->unix_ext) && (*oplock & CIFS_CREATE_ACTION)) {\n\t\tstruct cifs_unix_set_info_args args = {\n\t\t\t\t.mode\t= mode,\n\t\t\t\t.ctime\t= NO_CHANGE_64,\n\t\t\t\t.atime\t= NO_CHANGE_64,\n\t\t\t\t.mtime\t= NO_CHANGE_64,\n\t\t\t\t.device\t= 0,\n\t\t};\n\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID) {\n\t\t\targs.uid = current_fsuid();\n\t\t\tif (inode->i_mode & S_ISGID)\n\t\t\t\targs.gid = inode->i_gid;\n\t\t\telse\n\t\t\t\targs.gid = current_fsgid();\n\t\t} else {\n\t\t\targs.uid = INVALID_UID; /* no change */\n\t\t\targs.gid = INVALID_GID; /* no change */\n\t\t}\n\t\tCIFSSMBUnixSetFileInfo(xid, tcon, &args, fid->netfid,\n\t\t\t\t       current->tgid);\n\t} else {\n\t\t/*\n\t\t * BB implement mode setting via Windows security\n\t\t * descriptors e.g.\n\t\t */\n\t\t/* CIFSSMBWinSetPerms(xid,tcon,path,mode,-1,-1,nls);*/\n\n\t\t/* Could set r/o dos attribute if mode & 0222 == 0 */\n\t}\n\ncifs_create_get_file_info:\n\t/* server might mask mode so we have to query for it */\n\tif (tcon->unix_ext)\n\t\trc = cifs_get_inode_info_unix(&newinode, full_path, inode->i_sb,\n\t\t\t\t\t      xid);\n\telse {\n\t\trc = cifs_get_inode_info(&newinode, full_path, buf, inode->i_sb,\n\t\t\t\t\t xid, fid);\n\t\tif (newinode) {\n\t\t\tif (server->ops->set_lease_key)\n\t\t\t\tserver->ops->set_lease_key(newinode, fid);\n\t\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DYNPERM)\n\t\t\t\tnewinode->i_mode = mode;\n\t\t\tif ((*oplock & CIFS_CREATE_ACTION) &&\n\t\t\t    (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID)) {\n\t\t\t\tnewinode->i_uid = current_fsuid();\n\t\t\t\tif (inode->i_mode & S_ISGID)\n\t\t\t\t\tnewinode->i_gid = inode->i_gid;\n\t\t\t\telse\n\t\t\t\t\tnewinode->i_gid = current_fsgid();\n\t\t\t}\n\t\t}\n\t}\n\ncifs_create_set_dentry:\n\tif (rc != 0) {\n\t\tcifs_dbg(FYI, \"Create worked, get_inode_info failed rc = %d\\n\",\n\t\t\t rc);\n\t\tif (server->ops->close)\n\t\t\tserver->ops->close(xid, tcon, fid);\n\t\tgoto out;\n\t}\n\td_drop(direntry);\n\td_add(direntry, newinode);\n\nout:\n\tkfree(buf);\n\tkfree(full_path);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nstatic int\ncifs_do_create(struct inode *inode, struct dentry *direntry, unsigned int xid,\n\t       struct tcon_link *tlink, unsigned oflags, umode_t mode,\n\t       __u32 *oplock, struct cifs_fid *fid)\n{\n\tint rc = -ENOENT;\n\tint create_options = CREATE_NOT_DIR;\n\tint desired_access;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct cifs_tcon *tcon = tlink_tcon(tlink);\n\tchar *full_path = NULL;\n\tFILE_ALL_INFO *buf = NULL;\n\tstruct inode *newinode = NULL;\n\tint disposition;\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct cifs_open_parms oparms;\n\n\t*oplock = 0;\n\tif (tcon->ses->server->oplocks)\n\t\t*oplock = REQ_OPLOCK;\n\n\tfull_path = build_path_from_dentry(direntry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (tcon->unix_ext && cap_unix(tcon->ses) && !tcon->broken_posix_open &&\n\t    (CIFS_UNIX_POSIX_PATH_OPS_CAP &\n\t\t\tle64_to_cpu(tcon->fsUnixInfo.Capability))) {\n\t\trc = cifs_posix_open(full_path, &newinode, inode->i_sb, mode,\n\t\t\t\t     oflags, oplock, &fid->netfid, xid);\n\t\tswitch (rc) {\n\t\tcase 0:\n\t\t\tif (newinode == NULL) {\n\t\t\t\t/* query inode info */\n\t\t\t\tgoto cifs_create_get_file_info;\n\t\t\t}\n\n\t\t\tif (!S_ISREG(newinode->i_mode)) {\n\t\t\t\t/*\n\t\t\t\t * The server may allow us to open things like\n\t\t\t\t * FIFOs, but the client isn't set up to deal\n\t\t\t\t * with that. If it's not a regular file, just\n\t\t\t\t * close it and proceed as if it were a normal\n\t\t\t\t * lookup.\n\t\t\t\t */\n\t\t\t\tCIFSSMBClose(xid, tcon, fid->netfid);\n\t\t\t\tgoto cifs_create_get_file_info;\n\t\t\t}\n\t\t\t/* success, no need to query */\n\t\t\tgoto cifs_create_set_dentry;\n\n\t\tcase -ENOENT:\n\t\t\tgoto cifs_create_get_file_info;\n\n\t\tcase -EIO:\n\t\tcase -EINVAL:\n\t\t\t/*\n\t\t\t * EIO could indicate that (posix open) operation is not\n\t\t\t * supported, despite what server claimed in capability\n\t\t\t * negotiation.\n\t\t\t *\n\t\t\t * POSIX open in samba versions 3.3.1 and earlier could\n\t\t\t * incorrectly fail with invalid parameter.\n\t\t\t */\n\t\t\ttcon->broken_posix_open = true;\n\t\t\tbreak;\n\n\t\tcase -EREMOTE:\n\t\tcase -EOPNOTSUPP:\n\t\t\t/*\n\t\t\t * EREMOTE indicates DFS junction, which is not handled\n\t\t\t * in posix open.  If either that or op not supported\n\t\t\t * returned, follow the normal lookup.\n\t\t\t */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * fallthrough to retry, using older open call, this is case\n\t\t * where server does not support this SMB level, and falsely\n\t\t * claims capability (also get here for DFS case which should be\n\t\t * rare for path not covered on files)\n\t\t */\n\t}\n\n\tdesired_access = 0;\n\tif (OPEN_FMODE(oflags) & FMODE_READ)\n\t\tdesired_access |= GENERIC_READ; /* is this too little? */\n\tif (OPEN_FMODE(oflags) & FMODE_WRITE)\n\t\tdesired_access |= GENERIC_WRITE;\n\n\tdisposition = FILE_OVERWRITE_IF;\n\tif ((oflags & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL))\n\t\tdisposition = FILE_CREATE;\n\telse if ((oflags & (O_CREAT | O_TRUNC)) == (O_CREAT | O_TRUNC))\n\t\tdisposition = FILE_OVERWRITE_IF;\n\telse if ((oflags & O_CREAT) == O_CREAT)\n\t\tdisposition = FILE_OPEN_IF;\n\telse\n\t\tcifs_dbg(FYI, \"Create flag not set in create function\\n\");\n\n\t/*\n\t * BB add processing to set equivalent of mode - e.g. via CreateX with\n\t * ACLs\n\t */\n\n\tif (!server->ops->open) {\n\t\trc = -ENOSYS;\n\t\tgoto out;\n\t}\n\n\tbuf = kmalloc(sizeof(FILE_ALL_INFO), GFP_KERNEL);\n\tif (buf == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * if we're not using unix extensions, see if we need to set\n\t * ATTR_READONLY on the create call\n\t */\n\tif (!tcon->unix_ext && (mode & S_IWUGO) == 0)\n\t\tcreate_options |= CREATE_OPTION_READONLY;\n\n\tif (backup_cred(cifs_sb))\n\t\tcreate_options |= CREATE_OPEN_BACKUP_INTENT;\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = desired_access;\n\toparms.create_options = create_options;\n\toparms.disposition = disposition;\n\toparms.path = full_path;\n\toparms.fid = fid;\n\toparms.reconnect = false;\n\n\trc = server->ops->open(xid, &oparms, oplock, buf);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"cifs_create returned 0x%x\\n\", rc);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If Open reported that we actually created a file then we now have to\n\t * set the mode if possible.\n\t */\n\tif ((tcon->unix_ext) && (*oplock & CIFS_CREATE_ACTION)) {\n\t\tstruct cifs_unix_set_info_args args = {\n\t\t\t\t.mode\t= mode,\n\t\t\t\t.ctime\t= NO_CHANGE_64,\n\t\t\t\t.atime\t= NO_CHANGE_64,\n\t\t\t\t.mtime\t= NO_CHANGE_64,\n\t\t\t\t.device\t= 0,\n\t\t};\n\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID) {\n\t\t\targs.uid = current_fsuid();\n\t\t\tif (inode->i_mode & S_ISGID)\n\t\t\t\targs.gid = inode->i_gid;\n\t\t\telse\n\t\t\t\targs.gid = current_fsgid();\n\t\t} else {\n\t\t\targs.uid = INVALID_UID; /* no change */\n\t\t\targs.gid = INVALID_GID; /* no change */\n\t\t}\n\t\tCIFSSMBUnixSetFileInfo(xid, tcon, &args, fid->netfid,\n\t\t\t\t       current->tgid);\n\t} else {\n\t\t/*\n\t\t * BB implement mode setting via Windows security\n\t\t * descriptors e.g.\n\t\t */\n\t\t/* CIFSSMBWinSetPerms(xid,tcon,path,mode,-1,-1,nls);*/\n\n\t\t/* Could set r/o dos attribute if mode & 0222 == 0 */\n\t}\n\ncifs_create_get_file_info:\n\t/* server might mask mode so we have to query for it */\n\tif (tcon->unix_ext)\n\t\trc = cifs_get_inode_info_unix(&newinode, full_path, inode->i_sb,\n\t\t\t\t\t      xid);\n\telse {\n\t\trc = cifs_get_inode_info(&newinode, full_path, buf, inode->i_sb,\n\t\t\t\t\t xid, fid);\n\t\tif (newinode) {\n\t\t\tif (server->ops->set_lease_key)\n\t\t\t\tserver->ops->set_lease_key(newinode, fid);\n\t\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DYNPERM)\n\t\t\t\tnewinode->i_mode = mode;\n\t\t\tif ((*oplock & CIFS_CREATE_ACTION) &&\n\t\t\t    (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID)) {\n\t\t\t\tnewinode->i_uid = current_fsuid();\n\t\t\t\tif (inode->i_mode & S_ISGID)\n\t\t\t\t\tnewinode->i_gid = inode->i_gid;\n\t\t\t\telse\n\t\t\t\t\tnewinode->i_gid = current_fsgid();\n\t\t\t}\n\t\t}\n\t}\n\ncifs_create_set_dentry:\n\tif (rc != 0) {\n\t\tcifs_dbg(FYI, \"Create worked, get_inode_info failed rc = %d\\n\",\n\t\t\t rc);\n\t\tif (server->ops->close)\n\t\t\tserver->ops->close(xid, tcon, fid);\n\t\tgoto out;\n\t}\n\td_drop(direntry);\n\td_add(direntry, newinode);\n\nout:\n\tkfree(buf);\n\tkfree(full_path);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->ops->new_lease_key",
          "args": [
            "&fid"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "tlink"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tlink"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tlink"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_sb_tlink",
          "args": [
            "CIFS_SB(inode->i_sb)"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_sb_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "4011-4082",
          "snippet": "struct tcon_link *\ncifs_sb_tlink(struct cifs_sb_info *cifs_sb)\n{\n\tint ret;\n\tkuid_t fsuid = current_fsuid();\n\tstruct tcon_link *tlink, *newtlink;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\treturn cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\tif (tlink)\n\t\tcifs_get_tlink(tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tif (tlink == NULL) {\n\t\tnewtlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\n\t\tif (newtlink == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnewtlink->tl_uid = fsuid;\n\t\tnewtlink->tl_tcon = ERR_PTR(-EACCES);\n\t\tset_bit(TCON_LINK_PENDING, &newtlink->tl_flags);\n\t\tset_bit(TCON_LINK_IN_TREE, &newtlink->tl_flags);\n\t\tcifs_get_tlink(newtlink);\n\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t\t/* was one inserted after previous search? */\n\t\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\t\tif (tlink) {\n\t\t\tcifs_get_tlink(tlink);\n\t\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\t\tkfree(newtlink);\n\t\t\tgoto wait_for_construction;\n\t\t}\n\t\ttlink = newtlink;\n\t\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t} else {\nwait_for_construction:\n\t\tret = wait_on_bit(&tlink->tl_flags, TCON_LINK_PENDING,\n\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (ret) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-ERESTARTSYS);\n\t\t}\n\n\t\t/* if it's good, return it */\n\t\tif (!IS_ERR(tlink->tl_tcon))\n\t\t\treturn tlink;\n\n\t\t/* return error if we tried this already recently */\n\t\tif (time_before(jiffies, tlink->tl_time + TLINK_ERROR_EXPIRE)) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-EACCES);\n\t\t}\n\n\t\tif (test_and_set_bit(TCON_LINK_PENDING, &tlink->tl_flags))\n\t\t\tgoto wait_for_construction;\n\t}\n\n\ttlink->tl_tcon = cifs_construct_tcon(cifs_sb, fsuid);\n\tclear_bit(TCON_LINK_PENDING, &tlink->tl_flags);\n\twake_up_bit(&tlink->tl_flags, TCON_LINK_PENDING);\n\n\tif (IS_ERR(tlink->tl_tcon)) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn tlink;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define TLINK_ERROR_EXPIRE\t(1 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\n#define TLINK_ERROR_EXPIRE\t(1 * HZ)\n\nstruct tcon_link *\ncifs_sb_tlink(struct cifs_sb_info *cifs_sb)\n{\n\tint ret;\n\tkuid_t fsuid = current_fsuid();\n\tstruct tcon_link *tlink, *newtlink;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\treturn cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\tif (tlink)\n\t\tcifs_get_tlink(tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tif (tlink == NULL) {\n\t\tnewtlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\n\t\tif (newtlink == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnewtlink->tl_uid = fsuid;\n\t\tnewtlink->tl_tcon = ERR_PTR(-EACCES);\n\t\tset_bit(TCON_LINK_PENDING, &newtlink->tl_flags);\n\t\tset_bit(TCON_LINK_IN_TREE, &newtlink->tl_flags);\n\t\tcifs_get_tlink(newtlink);\n\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t\t/* was one inserted after previous search? */\n\t\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\t\tif (tlink) {\n\t\t\tcifs_get_tlink(tlink);\n\t\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\t\tkfree(newtlink);\n\t\t\tgoto wait_for_construction;\n\t\t}\n\t\ttlink = newtlink;\n\t\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t} else {\nwait_for_construction:\n\t\tret = wait_on_bit(&tlink->tl_flags, TCON_LINK_PENDING,\n\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (ret) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-ERESTARTSYS);\n\t\t}\n\n\t\t/* if it's good, return it */\n\t\tif (!IS_ERR(tlink->tl_tcon))\n\t\t\treturn tlink;\n\n\t\t/* return error if we tried this already recently */\n\t\tif (time_before(jiffies, tlink->tl_time + TLINK_ERROR_EXPIRE)) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-EACCES);\n\t\t}\n\n\t\tif (test_and_set_bit(TCON_LINK_PENDING, &tlink->tl_flags))\n\t\t\tgoto wait_for_construction;\n\t}\n\n\ttlink->tl_tcon = cifs_construct_tcon(cifs_sb, fsuid);\n\tclear_bit(TCON_LINK_PENDING, &tlink->tl_flags);\n\twake_up_bit(&tlink->tl_flags, TCON_LINK_PENDING);\n\n\tif (IS_ERR(tlink->tl_tcon)) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn tlink;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"cifs_create parent inode = 0x%p name is: %pd and dentry = 0x%p\\n\"",
            "inode",
            "direntry",
            "direntry"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_xid",
          "args": [],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "_get_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "45-61",
          "snippet": "unsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nunsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nint cifs_create(struct inode *inode, struct dentry *direntry, umode_t mode,\n\t\tbool excl)\n{\n\tint rc;\n\tunsigned int xid = get_xid();\n\t/*\n\t * BB below access is probably too much for mknod to request\n\t *    but we have to do query and setpathinfo so requesting\n\t *    less could fail (unless we want to request getatr and setatr\n\t *    permissions (only).  At least for POSIX we do not have to\n\t *    request so much.\n\t */\n\tunsigned oflags = O_EXCL | O_CREAT | O_RDWR;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_fid fid;\n\t__u32 oplock;\n\n\tcifs_dbg(FYI, \"cifs_create parent inode = 0x%p name is: %pd and dentry = 0x%p\\n\",\n\t\t inode, direntry, direntry);\n\n\ttlink = cifs_sb_tlink(CIFS_SB(inode->i_sb));\n\trc = PTR_ERR(tlink);\n\tif (IS_ERR(tlink))\n\t\tgoto out_free_xid;\n\n\ttcon = tlink_tcon(tlink);\n\tserver = tcon->ses->server;\n\n\tif (server->ops->new_lease_key)\n\t\tserver->ops->new_lease_key(&fid);\n\n\trc = cifs_do_create(inode, direntry, xid, tlink, oflags, mode,\n\t\t\t    &oplock, &fid);\n\tif (!rc && server->ops->close)\n\t\tserver->ops->close(xid, tcon, &fid);\n\n\tcifs_put_tlink(tlink);\nout_free_xid:\n\tfree_xid(xid);\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_atomic_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/dir.c",
    "lines": "415-522",
    "snippet": "int\ncifs_atomic_open(struct inode *inode, struct dentry *direntry,\n\t\t struct file *file, unsigned oflags, umode_t mode,\n\t\t int *opened)\n{\n\tint rc;\n\tunsigned int xid;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_fid fid;\n\tstruct cifs_pending_open open;\n\t__u32 oplock;\n\tstruct cifsFileInfo *file_info;\n\n\t/*\n\t * Posix open is only called (at lookup time) for file create now. For\n\t * opens (rather than creates), because we do not know if it is a file\n\t * or directory yet, and current Samba no longer allows us to do posix\n\t * open on dirs, we could end up wasting an open call on what turns out\n\t * to be a dir. For file opens, we wait to call posix open till\n\t * cifs_open.  It could be added to atomic_open in the future but the\n\t * performance tradeoff of the extra network request when EISDIR or\n\t * EACCES is returned would have to be weighed against the 50% reduction\n\t * in network traffic in the other paths.\n\t */\n\tif (!(oflags & O_CREAT)) {\n\t\tstruct dentry *res;\n\n\t\t/*\n\t\t * Check for hashed negative dentry. We have already revalidated\n\t\t * the dentry and it is fine. No need to perform another lookup.\n\t\t */\n\t\tif (!d_unhashed(direntry))\n\t\t\treturn -ENOENT;\n\n\t\tres = cifs_lookup(inode, direntry, 0);\n\t\tif (IS_ERR(res))\n\t\t\treturn PTR_ERR(res);\n\n\t\treturn finish_no_open(file, res);\n\t}\n\n\trc = check_name(direntry);\n\tif (rc)\n\t\treturn rc;\n\n\txid = get_xid();\n\n\tcifs_dbg(FYI, \"parent inode = 0x%p name is: %pd and dentry = 0x%p\\n\",\n\t\t inode, direntry, direntry);\n\n\ttlink = cifs_sb_tlink(CIFS_SB(inode->i_sb));\n\tif (IS_ERR(tlink)) {\n\t\trc = PTR_ERR(tlink);\n\t\tgoto out_free_xid;\n\t}\n\n\ttcon = tlink_tcon(tlink);\n\tserver = tcon->ses->server;\n\n\tif (server->ops->new_lease_key)\n\t\tserver->ops->new_lease_key(&fid);\n\n\tcifs_add_pending_open(&fid, tlink, &open);\n\n\trc = cifs_do_create(inode, direntry, xid, tlink, oflags, mode,\n\t\t\t    &oplock, &fid);\n\n\tif (rc) {\n\t\tcifs_del_pending_open(&open);\n\t\tgoto out;\n\t}\n\n\tif ((oflags & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL))\n\t\t*opened |= FILE_CREATED;\n\n\trc = finish_open(file, direntry, generic_file_open, opened);\n\tif (rc) {\n\t\tif (server->ops->close)\n\t\t\tserver->ops->close(xid, tcon, &fid);\n\t\tcifs_del_pending_open(&open);\n\t\tgoto out;\n\t}\n\n\tif (file->f_flags & O_DIRECT &&\n\t    CIFS_SB(inode->i_sb)->mnt_cifs_flags & CIFS_MOUNT_STRICT_IO) {\n\t\tif (CIFS_SB(inode->i_sb)->mnt_cifs_flags & CIFS_MOUNT_NO_BRL)\n\t\t\tfile->f_op = &cifs_file_direct_nobrl_ops;\n\t\telse\n\t\t\tfile->f_op = &cifs_file_direct_ops;\n\t\t}\n\n\tfile_info = cifs_new_fileinfo(&fid, file, tlink, oplock);\n\tif (file_info == NULL) {\n\t\tif (server->ops->close)\n\t\t\tserver->ops->close(xid, tcon, &fid);\n\t\tcifs_del_pending_open(&open);\n\t\tfput(file);\n\t\trc = -ENOMEM;\n\t}\n\nout:\n\tcifs_put_tlink(tlink);\nout_free_xid:\n\tfree_xid(xid);\n\treturn rc;\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_xid",
          "args": [
            "xid"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "_free_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "63-71",
          "snippet": "void\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_put_tlink",
          "args": [
            "tlink"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_put_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2666-2682",
          "snippet": "void\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nvoid\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "file"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "293-300",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_del_pending_open",
          "args": [
            "&open"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_del_pending_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "613-619",
          "snippet": "void\ncifs_del_pending_open(struct cifs_pending_open *open)\n{\n\tspin_lock(&cifs_file_list_lock);\n\tlist_del(&open->olist);\n\tspin_unlock(&cifs_file_list_lock);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\ncifs_del_pending_open(struct cifs_pending_open *open)\n{\n\tspin_lock(&cifs_file_list_lock);\n\tlist_del(&open->olist);\n\tspin_unlock(&cifs_file_list_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->ops->close",
          "args": [
            "xid",
            "tcon",
            "&fid"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_new_fileinfo",
          "args": [
            "&fid",
            "file",
            "tlink",
            "oplock"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_new_fileinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "271-342",
          "snippet": "struct cifsFileInfo *\ncifs_new_fileinfo(struct cifs_fid *fid, struct file *file,\n\t\t  struct tcon_link *tlink, __u32 oplock)\n{\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct cifsInodeInfo *cinode = CIFS_I(inode);\n\tstruct cifsFileInfo *cfile;\n\tstruct cifs_fid_locks *fdlocks;\n\tstruct cifs_tcon *tcon = tlink_tcon(tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\n\tcfile = kzalloc(sizeof(struct cifsFileInfo), GFP_KERNEL);\n\tif (cfile == NULL)\n\t\treturn cfile;\n\n\tfdlocks = kzalloc(sizeof(struct cifs_fid_locks), GFP_KERNEL);\n\tif (!fdlocks) {\n\t\tkfree(cfile);\n\t\treturn NULL;\n\t}\n\n\tINIT_LIST_HEAD(&fdlocks->locks);\n\tfdlocks->cfile = cfile;\n\tcfile->llist = fdlocks;\n\tdown_write(&cinode->lock_sem);\n\tlist_add(&fdlocks->llist, &cinode->llist);\n\tup_write(&cinode->lock_sem);\n\n\tcfile->count = 1;\n\tcfile->pid = current->tgid;\n\tcfile->uid = current_fsuid();\n\tcfile->dentry = dget(dentry);\n\tcfile->f_flags = file->f_flags;\n\tcfile->invalidHandle = false;\n\tcfile->tlink = cifs_get_tlink(tlink);\n\tINIT_WORK(&cfile->oplock_break, cifs_oplock_break);\n\tmutex_init(&cfile->fh_mutex);\n\n\tcifs_sb_active(inode->i_sb);\n\n\t/*\n\t * If the server returned a read oplock and we have mandatory brlocks,\n\t * set oplock level to None.\n\t */\n\tif (server->ops->is_read_op(oplock) && cifs_has_mand_locks(cinode)) {\n\t\tcifs_dbg(FYI, \"Reset oplock val from read to None due to mand locks\\n\");\n\t\toplock = 0;\n\t}\n\n\tspin_lock(&cifs_file_list_lock);\n\tif (fid->pending_open->oplock != CIFS_OPLOCK_NO_CHANGE && oplock)\n\t\toplock = fid->pending_open->oplock;\n\tlist_del(&fid->pending_open->olist);\n\n\tfid->purge_cache = false;\n\tserver->ops->set_fid(cfile, fid, oplock);\n\n\tlist_add(&cfile->tlist, &tcon->openFileList);\n\t/* if readable file instance put first in list*/\n\tif (file->f_mode & FMODE_READ)\n\t\tlist_add(&cfile->flist, &cinode->openFileList);\n\telse\n\t\tlist_add_tail(&cfile->flist, &cinode->openFileList);\n\tspin_unlock(&cifs_file_list_lock);\n\n\tif (fid->purge_cache)\n\t\tcifs_zap_mapping(inode);\n\n\tfile->private_data = cfile;\n\treturn cfile;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cifs_push_posix_locks(struct cifsFileInfo *cfile);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nstatic int cifs_push_posix_locks(struct cifsFileInfo *cfile);\n\nstruct cifsFileInfo *\ncifs_new_fileinfo(struct cifs_fid *fid, struct file *file,\n\t\t  struct tcon_link *tlink, __u32 oplock)\n{\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct cifsInodeInfo *cinode = CIFS_I(inode);\n\tstruct cifsFileInfo *cfile;\n\tstruct cifs_fid_locks *fdlocks;\n\tstruct cifs_tcon *tcon = tlink_tcon(tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\n\tcfile = kzalloc(sizeof(struct cifsFileInfo), GFP_KERNEL);\n\tif (cfile == NULL)\n\t\treturn cfile;\n\n\tfdlocks = kzalloc(sizeof(struct cifs_fid_locks), GFP_KERNEL);\n\tif (!fdlocks) {\n\t\tkfree(cfile);\n\t\treturn NULL;\n\t}\n\n\tINIT_LIST_HEAD(&fdlocks->locks);\n\tfdlocks->cfile = cfile;\n\tcfile->llist = fdlocks;\n\tdown_write(&cinode->lock_sem);\n\tlist_add(&fdlocks->llist, &cinode->llist);\n\tup_write(&cinode->lock_sem);\n\n\tcfile->count = 1;\n\tcfile->pid = current->tgid;\n\tcfile->uid = current_fsuid();\n\tcfile->dentry = dget(dentry);\n\tcfile->f_flags = file->f_flags;\n\tcfile->invalidHandle = false;\n\tcfile->tlink = cifs_get_tlink(tlink);\n\tINIT_WORK(&cfile->oplock_break, cifs_oplock_break);\n\tmutex_init(&cfile->fh_mutex);\n\n\tcifs_sb_active(inode->i_sb);\n\n\t/*\n\t * If the server returned a read oplock and we have mandatory brlocks,\n\t * set oplock level to None.\n\t */\n\tif (server->ops->is_read_op(oplock) && cifs_has_mand_locks(cinode)) {\n\t\tcifs_dbg(FYI, \"Reset oplock val from read to None due to mand locks\\n\");\n\t\toplock = 0;\n\t}\n\n\tspin_lock(&cifs_file_list_lock);\n\tif (fid->pending_open->oplock != CIFS_OPLOCK_NO_CHANGE && oplock)\n\t\toplock = fid->pending_open->oplock;\n\tlist_del(&fid->pending_open->olist);\n\n\tfid->purge_cache = false;\n\tserver->ops->set_fid(cfile, fid, oplock);\n\n\tlist_add(&cfile->tlist, &tcon->openFileList);\n\t/* if readable file instance put first in list*/\n\tif (file->f_mode & FMODE_READ)\n\t\tlist_add(&cfile->flist, &cinode->openFileList);\n\telse\n\t\tlist_add_tail(&cfile->flist, &cinode->openFileList);\n\tspin_unlock(&cifs_file_list_lock);\n\n\tif (fid->purge_cache)\n\t\tcifs_zap_mapping(inode);\n\n\tfile->private_data = cfile;\n\treturn cfile;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->ops->close",
          "args": [
            "xid",
            "tcon",
            "&fid"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "finish_open",
          "args": [
            "file",
            "direntry",
            "generic_file_open",
            "opened"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "finish_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
          "lines": "784-797",
          "snippet": "int finish_open(struct file *file, struct dentry *dentry,\n\t\tint (*open)(struct inode *, struct file *),\n\t\tint *opened)\n{\n\tint error;\n\tBUG_ON(*opened & FILE_OPENED); /* once it's opened, it's opened */\n\n\tfile->f_path.dentry = dentry;\n\terror = do_dentry_open(file, open, current_cred());\n\tif (!error)\n\t\t*opened |= FILE_OPENED;\n\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint finish_open(struct file *file, struct dentry *dentry,\n\t\tint (*open)(struct inode *, struct file *),\n\t\tint *opened)\n{\n\tint error;\n\tBUG_ON(*opened & FILE_OPENED); /* once it's opened, it's opened */\n\n\tfile->f_path.dentry = dentry;\n\terror = do_dentry_open(file, open, current_cred());\n\tif (!error)\n\t\t*opened |= FILE_OPENED;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_do_create",
          "args": [
            "inode",
            "direntry",
            "xid",
            "tlink",
            "oflags",
            "mode",
            "&oplock",
            "&fid"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_do_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/dir.c",
          "lines": "193-413",
          "snippet": "static int\ncifs_do_create(struct inode *inode, struct dentry *direntry, unsigned int xid,\n\t       struct tcon_link *tlink, unsigned oflags, umode_t mode,\n\t       __u32 *oplock, struct cifs_fid *fid)\n{\n\tint rc = -ENOENT;\n\tint create_options = CREATE_NOT_DIR;\n\tint desired_access;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct cifs_tcon *tcon = tlink_tcon(tlink);\n\tchar *full_path = NULL;\n\tFILE_ALL_INFO *buf = NULL;\n\tstruct inode *newinode = NULL;\n\tint disposition;\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct cifs_open_parms oparms;\n\n\t*oplock = 0;\n\tif (tcon->ses->server->oplocks)\n\t\t*oplock = REQ_OPLOCK;\n\n\tfull_path = build_path_from_dentry(direntry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (tcon->unix_ext && cap_unix(tcon->ses) && !tcon->broken_posix_open &&\n\t    (CIFS_UNIX_POSIX_PATH_OPS_CAP &\n\t\t\tle64_to_cpu(tcon->fsUnixInfo.Capability))) {\n\t\trc = cifs_posix_open(full_path, &newinode, inode->i_sb, mode,\n\t\t\t\t     oflags, oplock, &fid->netfid, xid);\n\t\tswitch (rc) {\n\t\tcase 0:\n\t\t\tif (newinode == NULL) {\n\t\t\t\t/* query inode info */\n\t\t\t\tgoto cifs_create_get_file_info;\n\t\t\t}\n\n\t\t\tif (!S_ISREG(newinode->i_mode)) {\n\t\t\t\t/*\n\t\t\t\t * The server may allow us to open things like\n\t\t\t\t * FIFOs, but the client isn't set up to deal\n\t\t\t\t * with that. If it's not a regular file, just\n\t\t\t\t * close it and proceed as if it were a normal\n\t\t\t\t * lookup.\n\t\t\t\t */\n\t\t\t\tCIFSSMBClose(xid, tcon, fid->netfid);\n\t\t\t\tgoto cifs_create_get_file_info;\n\t\t\t}\n\t\t\t/* success, no need to query */\n\t\t\tgoto cifs_create_set_dentry;\n\n\t\tcase -ENOENT:\n\t\t\tgoto cifs_create_get_file_info;\n\n\t\tcase -EIO:\n\t\tcase -EINVAL:\n\t\t\t/*\n\t\t\t * EIO could indicate that (posix open) operation is not\n\t\t\t * supported, despite what server claimed in capability\n\t\t\t * negotiation.\n\t\t\t *\n\t\t\t * POSIX open in samba versions 3.3.1 and earlier could\n\t\t\t * incorrectly fail with invalid parameter.\n\t\t\t */\n\t\t\ttcon->broken_posix_open = true;\n\t\t\tbreak;\n\n\t\tcase -EREMOTE:\n\t\tcase -EOPNOTSUPP:\n\t\t\t/*\n\t\t\t * EREMOTE indicates DFS junction, which is not handled\n\t\t\t * in posix open.  If either that or op not supported\n\t\t\t * returned, follow the normal lookup.\n\t\t\t */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * fallthrough to retry, using older open call, this is case\n\t\t * where server does not support this SMB level, and falsely\n\t\t * claims capability (also get here for DFS case which should be\n\t\t * rare for path not covered on files)\n\t\t */\n\t}\n\n\tdesired_access = 0;\n\tif (OPEN_FMODE(oflags) & FMODE_READ)\n\t\tdesired_access |= GENERIC_READ; /* is this too little? */\n\tif (OPEN_FMODE(oflags) & FMODE_WRITE)\n\t\tdesired_access |= GENERIC_WRITE;\n\n\tdisposition = FILE_OVERWRITE_IF;\n\tif ((oflags & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL))\n\t\tdisposition = FILE_CREATE;\n\telse if ((oflags & (O_CREAT | O_TRUNC)) == (O_CREAT | O_TRUNC))\n\t\tdisposition = FILE_OVERWRITE_IF;\n\telse if ((oflags & O_CREAT) == O_CREAT)\n\t\tdisposition = FILE_OPEN_IF;\n\telse\n\t\tcifs_dbg(FYI, \"Create flag not set in create function\\n\");\n\n\t/*\n\t * BB add processing to set equivalent of mode - e.g. via CreateX with\n\t * ACLs\n\t */\n\n\tif (!server->ops->open) {\n\t\trc = -ENOSYS;\n\t\tgoto out;\n\t}\n\n\tbuf = kmalloc(sizeof(FILE_ALL_INFO), GFP_KERNEL);\n\tif (buf == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * if we're not using unix extensions, see if we need to set\n\t * ATTR_READONLY on the create call\n\t */\n\tif (!tcon->unix_ext && (mode & S_IWUGO) == 0)\n\t\tcreate_options |= CREATE_OPTION_READONLY;\n\n\tif (backup_cred(cifs_sb))\n\t\tcreate_options |= CREATE_OPEN_BACKUP_INTENT;\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = desired_access;\n\toparms.create_options = create_options;\n\toparms.disposition = disposition;\n\toparms.path = full_path;\n\toparms.fid = fid;\n\toparms.reconnect = false;\n\n\trc = server->ops->open(xid, &oparms, oplock, buf);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"cifs_create returned 0x%x\\n\", rc);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If Open reported that we actually created a file then we now have to\n\t * set the mode if possible.\n\t */\n\tif ((tcon->unix_ext) && (*oplock & CIFS_CREATE_ACTION)) {\n\t\tstruct cifs_unix_set_info_args args = {\n\t\t\t\t.mode\t= mode,\n\t\t\t\t.ctime\t= NO_CHANGE_64,\n\t\t\t\t.atime\t= NO_CHANGE_64,\n\t\t\t\t.mtime\t= NO_CHANGE_64,\n\t\t\t\t.device\t= 0,\n\t\t};\n\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID) {\n\t\t\targs.uid = current_fsuid();\n\t\t\tif (inode->i_mode & S_ISGID)\n\t\t\t\targs.gid = inode->i_gid;\n\t\t\telse\n\t\t\t\targs.gid = current_fsgid();\n\t\t} else {\n\t\t\targs.uid = INVALID_UID; /* no change */\n\t\t\targs.gid = INVALID_GID; /* no change */\n\t\t}\n\t\tCIFSSMBUnixSetFileInfo(xid, tcon, &args, fid->netfid,\n\t\t\t\t       current->tgid);\n\t} else {\n\t\t/*\n\t\t * BB implement mode setting via Windows security\n\t\t * descriptors e.g.\n\t\t */\n\t\t/* CIFSSMBWinSetPerms(xid,tcon,path,mode,-1,-1,nls);*/\n\n\t\t/* Could set r/o dos attribute if mode & 0222 == 0 */\n\t}\n\ncifs_create_get_file_info:\n\t/* server might mask mode so we have to query for it */\n\tif (tcon->unix_ext)\n\t\trc = cifs_get_inode_info_unix(&newinode, full_path, inode->i_sb,\n\t\t\t\t\t      xid);\n\telse {\n\t\trc = cifs_get_inode_info(&newinode, full_path, buf, inode->i_sb,\n\t\t\t\t\t xid, fid);\n\t\tif (newinode) {\n\t\t\tif (server->ops->set_lease_key)\n\t\t\t\tserver->ops->set_lease_key(newinode, fid);\n\t\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DYNPERM)\n\t\t\t\tnewinode->i_mode = mode;\n\t\t\tif ((*oplock & CIFS_CREATE_ACTION) &&\n\t\t\t    (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID)) {\n\t\t\t\tnewinode->i_uid = current_fsuid();\n\t\t\t\tif (inode->i_mode & S_ISGID)\n\t\t\t\t\tnewinode->i_gid = inode->i_gid;\n\t\t\t\telse\n\t\t\t\t\tnewinode->i_gid = current_fsgid();\n\t\t\t}\n\t\t}\n\t}\n\ncifs_create_set_dentry:\n\tif (rc != 0) {\n\t\tcifs_dbg(FYI, \"Create worked, get_inode_info failed rc = %d\\n\",\n\t\t\t rc);\n\t\tif (server->ops->close)\n\t\t\tserver->ops->close(xid, tcon, fid);\n\t\tgoto out;\n\t}\n\td_drop(direntry);\n\td_add(direntry, newinode);\n\nout:\n\tkfree(buf);\n\tkfree(full_path);\n\treturn rc;\n}",
          "includes": [
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nstatic int\ncifs_do_create(struct inode *inode, struct dentry *direntry, unsigned int xid,\n\t       struct tcon_link *tlink, unsigned oflags, umode_t mode,\n\t       __u32 *oplock, struct cifs_fid *fid)\n{\n\tint rc = -ENOENT;\n\tint create_options = CREATE_NOT_DIR;\n\tint desired_access;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct cifs_tcon *tcon = tlink_tcon(tlink);\n\tchar *full_path = NULL;\n\tFILE_ALL_INFO *buf = NULL;\n\tstruct inode *newinode = NULL;\n\tint disposition;\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct cifs_open_parms oparms;\n\n\t*oplock = 0;\n\tif (tcon->ses->server->oplocks)\n\t\t*oplock = REQ_OPLOCK;\n\n\tfull_path = build_path_from_dentry(direntry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (tcon->unix_ext && cap_unix(tcon->ses) && !tcon->broken_posix_open &&\n\t    (CIFS_UNIX_POSIX_PATH_OPS_CAP &\n\t\t\tle64_to_cpu(tcon->fsUnixInfo.Capability))) {\n\t\trc = cifs_posix_open(full_path, &newinode, inode->i_sb, mode,\n\t\t\t\t     oflags, oplock, &fid->netfid, xid);\n\t\tswitch (rc) {\n\t\tcase 0:\n\t\t\tif (newinode == NULL) {\n\t\t\t\t/* query inode info */\n\t\t\t\tgoto cifs_create_get_file_info;\n\t\t\t}\n\n\t\t\tif (!S_ISREG(newinode->i_mode)) {\n\t\t\t\t/*\n\t\t\t\t * The server may allow us to open things like\n\t\t\t\t * FIFOs, but the client isn't set up to deal\n\t\t\t\t * with that. If it's not a regular file, just\n\t\t\t\t * close it and proceed as if it were a normal\n\t\t\t\t * lookup.\n\t\t\t\t */\n\t\t\t\tCIFSSMBClose(xid, tcon, fid->netfid);\n\t\t\t\tgoto cifs_create_get_file_info;\n\t\t\t}\n\t\t\t/* success, no need to query */\n\t\t\tgoto cifs_create_set_dentry;\n\n\t\tcase -ENOENT:\n\t\t\tgoto cifs_create_get_file_info;\n\n\t\tcase -EIO:\n\t\tcase -EINVAL:\n\t\t\t/*\n\t\t\t * EIO could indicate that (posix open) operation is not\n\t\t\t * supported, despite what server claimed in capability\n\t\t\t * negotiation.\n\t\t\t *\n\t\t\t * POSIX open in samba versions 3.3.1 and earlier could\n\t\t\t * incorrectly fail with invalid parameter.\n\t\t\t */\n\t\t\ttcon->broken_posix_open = true;\n\t\t\tbreak;\n\n\t\tcase -EREMOTE:\n\t\tcase -EOPNOTSUPP:\n\t\t\t/*\n\t\t\t * EREMOTE indicates DFS junction, which is not handled\n\t\t\t * in posix open.  If either that or op not supported\n\t\t\t * returned, follow the normal lookup.\n\t\t\t */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * fallthrough to retry, using older open call, this is case\n\t\t * where server does not support this SMB level, and falsely\n\t\t * claims capability (also get here for DFS case which should be\n\t\t * rare for path not covered on files)\n\t\t */\n\t}\n\n\tdesired_access = 0;\n\tif (OPEN_FMODE(oflags) & FMODE_READ)\n\t\tdesired_access |= GENERIC_READ; /* is this too little? */\n\tif (OPEN_FMODE(oflags) & FMODE_WRITE)\n\t\tdesired_access |= GENERIC_WRITE;\n\n\tdisposition = FILE_OVERWRITE_IF;\n\tif ((oflags & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL))\n\t\tdisposition = FILE_CREATE;\n\telse if ((oflags & (O_CREAT | O_TRUNC)) == (O_CREAT | O_TRUNC))\n\t\tdisposition = FILE_OVERWRITE_IF;\n\telse if ((oflags & O_CREAT) == O_CREAT)\n\t\tdisposition = FILE_OPEN_IF;\n\telse\n\t\tcifs_dbg(FYI, \"Create flag not set in create function\\n\");\n\n\t/*\n\t * BB add processing to set equivalent of mode - e.g. via CreateX with\n\t * ACLs\n\t */\n\n\tif (!server->ops->open) {\n\t\trc = -ENOSYS;\n\t\tgoto out;\n\t}\n\n\tbuf = kmalloc(sizeof(FILE_ALL_INFO), GFP_KERNEL);\n\tif (buf == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * if we're not using unix extensions, see if we need to set\n\t * ATTR_READONLY on the create call\n\t */\n\tif (!tcon->unix_ext && (mode & S_IWUGO) == 0)\n\t\tcreate_options |= CREATE_OPTION_READONLY;\n\n\tif (backup_cred(cifs_sb))\n\t\tcreate_options |= CREATE_OPEN_BACKUP_INTENT;\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = desired_access;\n\toparms.create_options = create_options;\n\toparms.disposition = disposition;\n\toparms.path = full_path;\n\toparms.fid = fid;\n\toparms.reconnect = false;\n\n\trc = server->ops->open(xid, &oparms, oplock, buf);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"cifs_create returned 0x%x\\n\", rc);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If Open reported that we actually created a file then we now have to\n\t * set the mode if possible.\n\t */\n\tif ((tcon->unix_ext) && (*oplock & CIFS_CREATE_ACTION)) {\n\t\tstruct cifs_unix_set_info_args args = {\n\t\t\t\t.mode\t= mode,\n\t\t\t\t.ctime\t= NO_CHANGE_64,\n\t\t\t\t.atime\t= NO_CHANGE_64,\n\t\t\t\t.mtime\t= NO_CHANGE_64,\n\t\t\t\t.device\t= 0,\n\t\t};\n\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID) {\n\t\t\targs.uid = current_fsuid();\n\t\t\tif (inode->i_mode & S_ISGID)\n\t\t\t\targs.gid = inode->i_gid;\n\t\t\telse\n\t\t\t\targs.gid = current_fsgid();\n\t\t} else {\n\t\t\targs.uid = INVALID_UID; /* no change */\n\t\t\targs.gid = INVALID_GID; /* no change */\n\t\t}\n\t\tCIFSSMBUnixSetFileInfo(xid, tcon, &args, fid->netfid,\n\t\t\t\t       current->tgid);\n\t} else {\n\t\t/*\n\t\t * BB implement mode setting via Windows security\n\t\t * descriptors e.g.\n\t\t */\n\t\t/* CIFSSMBWinSetPerms(xid,tcon,path,mode,-1,-1,nls);*/\n\n\t\t/* Could set r/o dos attribute if mode & 0222 == 0 */\n\t}\n\ncifs_create_get_file_info:\n\t/* server might mask mode so we have to query for it */\n\tif (tcon->unix_ext)\n\t\trc = cifs_get_inode_info_unix(&newinode, full_path, inode->i_sb,\n\t\t\t\t\t      xid);\n\telse {\n\t\trc = cifs_get_inode_info(&newinode, full_path, buf, inode->i_sb,\n\t\t\t\t\t xid, fid);\n\t\tif (newinode) {\n\t\t\tif (server->ops->set_lease_key)\n\t\t\t\tserver->ops->set_lease_key(newinode, fid);\n\t\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DYNPERM)\n\t\t\t\tnewinode->i_mode = mode;\n\t\t\tif ((*oplock & CIFS_CREATE_ACTION) &&\n\t\t\t    (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID)) {\n\t\t\t\tnewinode->i_uid = current_fsuid();\n\t\t\t\tif (inode->i_mode & S_ISGID)\n\t\t\t\t\tnewinode->i_gid = inode->i_gid;\n\t\t\t\telse\n\t\t\t\t\tnewinode->i_gid = current_fsgid();\n\t\t\t}\n\t\t}\n\t}\n\ncifs_create_set_dentry:\n\tif (rc != 0) {\n\t\tcifs_dbg(FYI, \"Create worked, get_inode_info failed rc = %d\\n\",\n\t\t\t rc);\n\t\tif (server->ops->close)\n\t\t\tserver->ops->close(xid, tcon, fid);\n\t\tgoto out;\n\t}\n\td_drop(direntry);\n\td_add(direntry, newinode);\n\nout:\n\tkfree(buf);\n\tkfree(full_path);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_add_pending_open",
          "args": [
            "&fid",
            "tlink",
            "&open"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_add_pending_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "634-641",
          "snippet": "void\ncifs_add_pending_open(struct cifs_fid *fid, struct tcon_link *tlink,\n\t\t      struct cifs_pending_open *open)\n{\n\tspin_lock(&cifs_file_list_lock);\n\tcifs_add_pending_open_locked(fid, tlink, open);\n\tspin_unlock(&cifs_file_list_lock);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\ncifs_add_pending_open(struct cifs_fid *fid, struct tcon_link *tlink,\n\t\t      struct cifs_pending_open *open)\n{\n\tspin_lock(&cifs_file_list_lock);\n\tcifs_add_pending_open_locked(fid, tlink, open);\n\tspin_unlock(&cifs_file_list_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->ops->new_lease_key",
          "args": [
            "&fid"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "tlink"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tlink"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tlink"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_sb_tlink",
          "args": [
            "CIFS_SB(inode->i_sb)"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_sb_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "4011-4082",
          "snippet": "struct tcon_link *\ncifs_sb_tlink(struct cifs_sb_info *cifs_sb)\n{\n\tint ret;\n\tkuid_t fsuid = current_fsuid();\n\tstruct tcon_link *tlink, *newtlink;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\treturn cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\tif (tlink)\n\t\tcifs_get_tlink(tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tif (tlink == NULL) {\n\t\tnewtlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\n\t\tif (newtlink == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnewtlink->tl_uid = fsuid;\n\t\tnewtlink->tl_tcon = ERR_PTR(-EACCES);\n\t\tset_bit(TCON_LINK_PENDING, &newtlink->tl_flags);\n\t\tset_bit(TCON_LINK_IN_TREE, &newtlink->tl_flags);\n\t\tcifs_get_tlink(newtlink);\n\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t\t/* was one inserted after previous search? */\n\t\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\t\tif (tlink) {\n\t\t\tcifs_get_tlink(tlink);\n\t\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\t\tkfree(newtlink);\n\t\t\tgoto wait_for_construction;\n\t\t}\n\t\ttlink = newtlink;\n\t\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t} else {\nwait_for_construction:\n\t\tret = wait_on_bit(&tlink->tl_flags, TCON_LINK_PENDING,\n\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (ret) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-ERESTARTSYS);\n\t\t}\n\n\t\t/* if it's good, return it */\n\t\tif (!IS_ERR(tlink->tl_tcon))\n\t\t\treturn tlink;\n\n\t\t/* return error if we tried this already recently */\n\t\tif (time_before(jiffies, tlink->tl_time + TLINK_ERROR_EXPIRE)) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-EACCES);\n\t\t}\n\n\t\tif (test_and_set_bit(TCON_LINK_PENDING, &tlink->tl_flags))\n\t\t\tgoto wait_for_construction;\n\t}\n\n\ttlink->tl_tcon = cifs_construct_tcon(cifs_sb, fsuid);\n\tclear_bit(TCON_LINK_PENDING, &tlink->tl_flags);\n\twake_up_bit(&tlink->tl_flags, TCON_LINK_PENDING);\n\n\tif (IS_ERR(tlink->tl_tcon)) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn tlink;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define TLINK_ERROR_EXPIRE\t(1 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\n#define TLINK_ERROR_EXPIRE\t(1 * HZ)\n\nstruct tcon_link *\ncifs_sb_tlink(struct cifs_sb_info *cifs_sb)\n{\n\tint ret;\n\tkuid_t fsuid = current_fsuid();\n\tstruct tcon_link *tlink, *newtlink;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\treturn cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\tif (tlink)\n\t\tcifs_get_tlink(tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tif (tlink == NULL) {\n\t\tnewtlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\n\t\tif (newtlink == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnewtlink->tl_uid = fsuid;\n\t\tnewtlink->tl_tcon = ERR_PTR(-EACCES);\n\t\tset_bit(TCON_LINK_PENDING, &newtlink->tl_flags);\n\t\tset_bit(TCON_LINK_IN_TREE, &newtlink->tl_flags);\n\t\tcifs_get_tlink(newtlink);\n\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t\t/* was one inserted after previous search? */\n\t\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\t\tif (tlink) {\n\t\t\tcifs_get_tlink(tlink);\n\t\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\t\tkfree(newtlink);\n\t\t\tgoto wait_for_construction;\n\t\t}\n\t\ttlink = newtlink;\n\t\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t} else {\nwait_for_construction:\n\t\tret = wait_on_bit(&tlink->tl_flags, TCON_LINK_PENDING,\n\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (ret) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-ERESTARTSYS);\n\t\t}\n\n\t\t/* if it's good, return it */\n\t\tif (!IS_ERR(tlink->tl_tcon))\n\t\t\treturn tlink;\n\n\t\t/* return error if we tried this already recently */\n\t\tif (time_before(jiffies, tlink->tl_time + TLINK_ERROR_EXPIRE)) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-EACCES);\n\t\t}\n\n\t\tif (test_and_set_bit(TCON_LINK_PENDING, &tlink->tl_flags))\n\t\t\tgoto wait_for_construction;\n\t}\n\n\ttlink->tl_tcon = cifs_construct_tcon(cifs_sb, fsuid);\n\tclear_bit(TCON_LINK_PENDING, &tlink->tl_flags);\n\twake_up_bit(&tlink->tl_flags, TCON_LINK_PENDING);\n\n\tif (IS_ERR(tlink->tl_tcon)) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn tlink;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"parent inode = 0x%p name is: %pd and dentry = 0x%p\\n\"",
            "inode",
            "direntry",
            "direntry"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_xid",
          "args": [],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "_get_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "45-61",
          "snippet": "unsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nunsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_name",
          "args": [
            "direntry"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "check_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/dir.c",
          "lines": "173-188",
          "snippet": "static int\ncheck_name(struct dentry *direntry)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(direntry->d_sb);\n\tint i;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)) {\n\t\tfor (i = 0; i < direntry->d_name.len; i++) {\n\t\t\tif (direntry->d_name.name[i] == '\\\\') {\n\t\t\t\tcifs_dbg(FYI, \"Invalid file name\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nstatic int\ncheck_name(struct dentry *direntry)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(direntry->d_sb);\n\tint i;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)) {\n\t\tfor (i = 0; i < direntry->d_name.len; i++) {\n\t\t\tif (direntry->d_name.name[i] == '\\\\') {\n\t\t\t\tcifs_dbg(FYI, \"Invalid file name\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "finish_no_open",
          "args": [
            "file",
            "res"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "finish_no_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
          "lines": "814-818",
          "snippet": "int finish_no_open(struct file *file, struct dentry *dentry)\n{\n\tfile->f_path.dentry = dentry;\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint finish_no_open(struct file *file, struct dentry *dentry)\n{\n\tfile->f_path.dentry = dentry;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "res"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "res"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_lookup",
          "args": [
            "inode",
            "direntry",
            "0"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/dir.c",
          "lines": "708-787",
          "snippet": "struct dentry *\ncifs_lookup(struct inode *parent_dir_inode, struct dentry *direntry,\n\t    unsigned int flags)\n{\n\tunsigned int xid;\n\tint rc = 0; /* to get around spurious gcc warning, set to zero here */\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *pTcon;\n\tstruct inode *newInode = NULL;\n\tchar *full_path = NULL;\n\n\txid = get_xid();\n\n\tcifs_dbg(FYI, \"parent inode = 0x%p name is: %pd and dentry = 0x%p\\n\",\n\t\t parent_dir_inode, direntry, direntry);\n\n\t/* check whether path exists */\n\n\tcifs_sb = CIFS_SB(parent_dir_inode->i_sb);\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink)) {\n\t\tfree_xid(xid);\n\t\treturn (struct dentry *)tlink;\n\t}\n\tpTcon = tlink_tcon(tlink);\n\n\trc = check_name(direntry);\n\tif (rc)\n\t\tgoto lookup_out;\n\n\t/* can not grab the rename sem here since it would\n\tdeadlock in the cases (beginning of sys_rename itself)\n\tin which we already have the sb rename sem */\n\tfull_path = build_path_from_dentry(direntry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto lookup_out;\n\t}\n\n\tif (direntry->d_inode != NULL) {\n\t\tcifs_dbg(FYI, \"non-NULL inode in lookup\\n\");\n\t} else {\n\t\tcifs_dbg(FYI, \"NULL inode in lookup\\n\");\n\t}\n\tcifs_dbg(FYI, \"Full path: %s inode = 0x%p\\n\",\n\t\t full_path, direntry->d_inode);\n\n\tif (pTcon->unix_ext) {\n\t\trc = cifs_get_inode_info_unix(&newInode, full_path,\n\t\t\t\t\t      parent_dir_inode->i_sb, xid);\n\t} else {\n\t\trc = cifs_get_inode_info(&newInode, full_path, NULL,\n\t\t\t\tparent_dir_inode->i_sb, xid, NULL);\n\t}\n\n\tif ((rc == 0) && (newInode != NULL)) {\n\t\td_add(direntry, newInode);\n\t\t/* since paths are not looked up by component - the parent\n\t\t   directories are presumed to be good here */\n\t\trenew_parental_timestamps(direntry);\n\n\t} else if (rc == -ENOENT) {\n\t\trc = 0;\n\t\tdirentry->d_time = jiffies;\n\t\td_add(direntry, NULL);\n\t/*\tif it was once a directory (but how can we tell?) we could do\n\t\tshrink_dcache_parent(direntry); */\n\t} else if (rc != -EACCES) {\n\t\tcifs_dbg(FYI, \"Unexpected lookup error %d\\n\", rc);\n\t\t/* We special case check for Access Denied - since that\n\t\tis a common return code */\n\t}\n\nlookup_out:\n\tkfree(full_path);\n\tcifs_put_tlink(tlink);\n\tfree_xid(xid);\n\treturn ERR_PTR(rc);\n}",
          "includes": [
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nstruct dentry *\ncifs_lookup(struct inode *parent_dir_inode, struct dentry *direntry,\n\t    unsigned int flags)\n{\n\tunsigned int xid;\n\tint rc = 0; /* to get around spurious gcc warning, set to zero here */\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *pTcon;\n\tstruct inode *newInode = NULL;\n\tchar *full_path = NULL;\n\n\txid = get_xid();\n\n\tcifs_dbg(FYI, \"parent inode = 0x%p name is: %pd and dentry = 0x%p\\n\",\n\t\t parent_dir_inode, direntry, direntry);\n\n\t/* check whether path exists */\n\n\tcifs_sb = CIFS_SB(parent_dir_inode->i_sb);\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink)) {\n\t\tfree_xid(xid);\n\t\treturn (struct dentry *)tlink;\n\t}\n\tpTcon = tlink_tcon(tlink);\n\n\trc = check_name(direntry);\n\tif (rc)\n\t\tgoto lookup_out;\n\n\t/* can not grab the rename sem here since it would\n\tdeadlock in the cases (beginning of sys_rename itself)\n\tin which we already have the sb rename sem */\n\tfull_path = build_path_from_dentry(direntry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto lookup_out;\n\t}\n\n\tif (direntry->d_inode != NULL) {\n\t\tcifs_dbg(FYI, \"non-NULL inode in lookup\\n\");\n\t} else {\n\t\tcifs_dbg(FYI, \"NULL inode in lookup\\n\");\n\t}\n\tcifs_dbg(FYI, \"Full path: %s inode = 0x%p\\n\",\n\t\t full_path, direntry->d_inode);\n\n\tif (pTcon->unix_ext) {\n\t\trc = cifs_get_inode_info_unix(&newInode, full_path,\n\t\t\t\t\t      parent_dir_inode->i_sb, xid);\n\t} else {\n\t\trc = cifs_get_inode_info(&newInode, full_path, NULL,\n\t\t\t\tparent_dir_inode->i_sb, xid, NULL);\n\t}\n\n\tif ((rc == 0) && (newInode != NULL)) {\n\t\td_add(direntry, newInode);\n\t\t/* since paths are not looked up by component - the parent\n\t\t   directories are presumed to be good here */\n\t\trenew_parental_timestamps(direntry);\n\n\t} else if (rc == -ENOENT) {\n\t\trc = 0;\n\t\tdirentry->d_time = jiffies;\n\t\td_add(direntry, NULL);\n\t/*\tif it was once a directory (but how can we tell?) we could do\n\t\tshrink_dcache_parent(direntry); */\n\t} else if (rc != -EACCES) {\n\t\tcifs_dbg(FYI, \"Unexpected lookup error %d\\n\", rc);\n\t\t/* We special case check for Access Denied - since that\n\t\tis a common return code */\n\t}\n\nlookup_out:\n\tkfree(full_path);\n\tcifs_put_tlink(tlink);\n\tfree_xid(xid);\n\treturn ERR_PTR(rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_unhashed",
          "args": [
            "direntry"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nint\ncifs_atomic_open(struct inode *inode, struct dentry *direntry,\n\t\t struct file *file, unsigned oflags, umode_t mode,\n\t\t int *opened)\n{\n\tint rc;\n\tunsigned int xid;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_fid fid;\n\tstruct cifs_pending_open open;\n\t__u32 oplock;\n\tstruct cifsFileInfo *file_info;\n\n\t/*\n\t * Posix open is only called (at lookup time) for file create now. For\n\t * opens (rather than creates), because we do not know if it is a file\n\t * or directory yet, and current Samba no longer allows us to do posix\n\t * open on dirs, we could end up wasting an open call on what turns out\n\t * to be a dir. For file opens, we wait to call posix open till\n\t * cifs_open.  It could be added to atomic_open in the future but the\n\t * performance tradeoff of the extra network request when EISDIR or\n\t * EACCES is returned would have to be weighed against the 50% reduction\n\t * in network traffic in the other paths.\n\t */\n\tif (!(oflags & O_CREAT)) {\n\t\tstruct dentry *res;\n\n\t\t/*\n\t\t * Check for hashed negative dentry. We have already revalidated\n\t\t * the dentry and it is fine. No need to perform another lookup.\n\t\t */\n\t\tif (!d_unhashed(direntry))\n\t\t\treturn -ENOENT;\n\n\t\tres = cifs_lookup(inode, direntry, 0);\n\t\tif (IS_ERR(res))\n\t\t\treturn PTR_ERR(res);\n\n\t\treturn finish_no_open(file, res);\n\t}\n\n\trc = check_name(direntry);\n\tif (rc)\n\t\treturn rc;\n\n\txid = get_xid();\n\n\tcifs_dbg(FYI, \"parent inode = 0x%p name is: %pd and dentry = 0x%p\\n\",\n\t\t inode, direntry, direntry);\n\n\ttlink = cifs_sb_tlink(CIFS_SB(inode->i_sb));\n\tif (IS_ERR(tlink)) {\n\t\trc = PTR_ERR(tlink);\n\t\tgoto out_free_xid;\n\t}\n\n\ttcon = tlink_tcon(tlink);\n\tserver = tcon->ses->server;\n\n\tif (server->ops->new_lease_key)\n\t\tserver->ops->new_lease_key(&fid);\n\n\tcifs_add_pending_open(&fid, tlink, &open);\n\n\trc = cifs_do_create(inode, direntry, xid, tlink, oflags, mode,\n\t\t\t    &oplock, &fid);\n\n\tif (rc) {\n\t\tcifs_del_pending_open(&open);\n\t\tgoto out;\n\t}\n\n\tif ((oflags & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL))\n\t\t*opened |= FILE_CREATED;\n\n\trc = finish_open(file, direntry, generic_file_open, opened);\n\tif (rc) {\n\t\tif (server->ops->close)\n\t\t\tserver->ops->close(xid, tcon, &fid);\n\t\tcifs_del_pending_open(&open);\n\t\tgoto out;\n\t}\n\n\tif (file->f_flags & O_DIRECT &&\n\t    CIFS_SB(inode->i_sb)->mnt_cifs_flags & CIFS_MOUNT_STRICT_IO) {\n\t\tif (CIFS_SB(inode->i_sb)->mnt_cifs_flags & CIFS_MOUNT_NO_BRL)\n\t\t\tfile->f_op = &cifs_file_direct_nobrl_ops;\n\t\telse\n\t\t\tfile->f_op = &cifs_file_direct_ops;\n\t\t}\n\n\tfile_info = cifs_new_fileinfo(&fid, file, tlink, oplock);\n\tif (file_info == NULL) {\n\t\tif (server->ops->close)\n\t\t\tserver->ops->close(xid, tcon, &fid);\n\t\tcifs_del_pending_open(&open);\n\t\tfput(file);\n\t\trc = -ENOMEM;\n\t}\n\nout:\n\tcifs_put_tlink(tlink);\nout_free_xid:\n\tfree_xid(xid);\n\treturn rc;\n}"
  },
  {
    "function_name": "cifs_do_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/dir.c",
    "lines": "193-413",
    "snippet": "static int\ncifs_do_create(struct inode *inode, struct dentry *direntry, unsigned int xid,\n\t       struct tcon_link *tlink, unsigned oflags, umode_t mode,\n\t       __u32 *oplock, struct cifs_fid *fid)\n{\n\tint rc = -ENOENT;\n\tint create_options = CREATE_NOT_DIR;\n\tint desired_access;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct cifs_tcon *tcon = tlink_tcon(tlink);\n\tchar *full_path = NULL;\n\tFILE_ALL_INFO *buf = NULL;\n\tstruct inode *newinode = NULL;\n\tint disposition;\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct cifs_open_parms oparms;\n\n\t*oplock = 0;\n\tif (tcon->ses->server->oplocks)\n\t\t*oplock = REQ_OPLOCK;\n\n\tfull_path = build_path_from_dentry(direntry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (tcon->unix_ext && cap_unix(tcon->ses) && !tcon->broken_posix_open &&\n\t    (CIFS_UNIX_POSIX_PATH_OPS_CAP &\n\t\t\tle64_to_cpu(tcon->fsUnixInfo.Capability))) {\n\t\trc = cifs_posix_open(full_path, &newinode, inode->i_sb, mode,\n\t\t\t\t     oflags, oplock, &fid->netfid, xid);\n\t\tswitch (rc) {\n\t\tcase 0:\n\t\t\tif (newinode == NULL) {\n\t\t\t\t/* query inode info */\n\t\t\t\tgoto cifs_create_get_file_info;\n\t\t\t}\n\n\t\t\tif (!S_ISREG(newinode->i_mode)) {\n\t\t\t\t/*\n\t\t\t\t * The server may allow us to open things like\n\t\t\t\t * FIFOs, but the client isn't set up to deal\n\t\t\t\t * with that. If it's not a regular file, just\n\t\t\t\t * close it and proceed as if it were a normal\n\t\t\t\t * lookup.\n\t\t\t\t */\n\t\t\t\tCIFSSMBClose(xid, tcon, fid->netfid);\n\t\t\t\tgoto cifs_create_get_file_info;\n\t\t\t}\n\t\t\t/* success, no need to query */\n\t\t\tgoto cifs_create_set_dentry;\n\n\t\tcase -ENOENT:\n\t\t\tgoto cifs_create_get_file_info;\n\n\t\tcase -EIO:\n\t\tcase -EINVAL:\n\t\t\t/*\n\t\t\t * EIO could indicate that (posix open) operation is not\n\t\t\t * supported, despite what server claimed in capability\n\t\t\t * negotiation.\n\t\t\t *\n\t\t\t * POSIX open in samba versions 3.3.1 and earlier could\n\t\t\t * incorrectly fail with invalid parameter.\n\t\t\t */\n\t\t\ttcon->broken_posix_open = true;\n\t\t\tbreak;\n\n\t\tcase -EREMOTE:\n\t\tcase -EOPNOTSUPP:\n\t\t\t/*\n\t\t\t * EREMOTE indicates DFS junction, which is not handled\n\t\t\t * in posix open.  If either that or op not supported\n\t\t\t * returned, follow the normal lookup.\n\t\t\t */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * fallthrough to retry, using older open call, this is case\n\t\t * where server does not support this SMB level, and falsely\n\t\t * claims capability (also get here for DFS case which should be\n\t\t * rare for path not covered on files)\n\t\t */\n\t}\n\n\tdesired_access = 0;\n\tif (OPEN_FMODE(oflags) & FMODE_READ)\n\t\tdesired_access |= GENERIC_READ; /* is this too little? */\n\tif (OPEN_FMODE(oflags) & FMODE_WRITE)\n\t\tdesired_access |= GENERIC_WRITE;\n\n\tdisposition = FILE_OVERWRITE_IF;\n\tif ((oflags & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL))\n\t\tdisposition = FILE_CREATE;\n\telse if ((oflags & (O_CREAT | O_TRUNC)) == (O_CREAT | O_TRUNC))\n\t\tdisposition = FILE_OVERWRITE_IF;\n\telse if ((oflags & O_CREAT) == O_CREAT)\n\t\tdisposition = FILE_OPEN_IF;\n\telse\n\t\tcifs_dbg(FYI, \"Create flag not set in create function\\n\");\n\n\t/*\n\t * BB add processing to set equivalent of mode - e.g. via CreateX with\n\t * ACLs\n\t */\n\n\tif (!server->ops->open) {\n\t\trc = -ENOSYS;\n\t\tgoto out;\n\t}\n\n\tbuf = kmalloc(sizeof(FILE_ALL_INFO), GFP_KERNEL);\n\tif (buf == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * if we're not using unix extensions, see if we need to set\n\t * ATTR_READONLY on the create call\n\t */\n\tif (!tcon->unix_ext && (mode & S_IWUGO) == 0)\n\t\tcreate_options |= CREATE_OPTION_READONLY;\n\n\tif (backup_cred(cifs_sb))\n\t\tcreate_options |= CREATE_OPEN_BACKUP_INTENT;\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = desired_access;\n\toparms.create_options = create_options;\n\toparms.disposition = disposition;\n\toparms.path = full_path;\n\toparms.fid = fid;\n\toparms.reconnect = false;\n\n\trc = server->ops->open(xid, &oparms, oplock, buf);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"cifs_create returned 0x%x\\n\", rc);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If Open reported that we actually created a file then we now have to\n\t * set the mode if possible.\n\t */\n\tif ((tcon->unix_ext) && (*oplock & CIFS_CREATE_ACTION)) {\n\t\tstruct cifs_unix_set_info_args args = {\n\t\t\t\t.mode\t= mode,\n\t\t\t\t.ctime\t= NO_CHANGE_64,\n\t\t\t\t.atime\t= NO_CHANGE_64,\n\t\t\t\t.mtime\t= NO_CHANGE_64,\n\t\t\t\t.device\t= 0,\n\t\t};\n\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID) {\n\t\t\targs.uid = current_fsuid();\n\t\t\tif (inode->i_mode & S_ISGID)\n\t\t\t\targs.gid = inode->i_gid;\n\t\t\telse\n\t\t\t\targs.gid = current_fsgid();\n\t\t} else {\n\t\t\targs.uid = INVALID_UID; /* no change */\n\t\t\targs.gid = INVALID_GID; /* no change */\n\t\t}\n\t\tCIFSSMBUnixSetFileInfo(xid, tcon, &args, fid->netfid,\n\t\t\t\t       current->tgid);\n\t} else {\n\t\t/*\n\t\t * BB implement mode setting via Windows security\n\t\t * descriptors e.g.\n\t\t */\n\t\t/* CIFSSMBWinSetPerms(xid,tcon,path,mode,-1,-1,nls);*/\n\n\t\t/* Could set r/o dos attribute if mode & 0222 == 0 */\n\t}\n\ncifs_create_get_file_info:\n\t/* server might mask mode so we have to query for it */\n\tif (tcon->unix_ext)\n\t\trc = cifs_get_inode_info_unix(&newinode, full_path, inode->i_sb,\n\t\t\t\t\t      xid);\n\telse {\n\t\trc = cifs_get_inode_info(&newinode, full_path, buf, inode->i_sb,\n\t\t\t\t\t xid, fid);\n\t\tif (newinode) {\n\t\t\tif (server->ops->set_lease_key)\n\t\t\t\tserver->ops->set_lease_key(newinode, fid);\n\t\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DYNPERM)\n\t\t\t\tnewinode->i_mode = mode;\n\t\t\tif ((*oplock & CIFS_CREATE_ACTION) &&\n\t\t\t    (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID)) {\n\t\t\t\tnewinode->i_uid = current_fsuid();\n\t\t\t\tif (inode->i_mode & S_ISGID)\n\t\t\t\t\tnewinode->i_gid = inode->i_gid;\n\t\t\t\telse\n\t\t\t\t\tnewinode->i_gid = current_fsgid();\n\t\t\t}\n\t\t}\n\t}\n\ncifs_create_set_dentry:\n\tif (rc != 0) {\n\t\tcifs_dbg(FYI, \"Create worked, get_inode_info failed rc = %d\\n\",\n\t\t\t rc);\n\t\tif (server->ops->close)\n\t\t\tserver->ops->close(xid, tcon, fid);\n\t\tgoto out;\n\t}\n\td_drop(direntry);\n\td_add(direntry, newinode);\n\nout:\n\tkfree(buf);\n\tkfree(full_path);\n\treturn rc;\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "full_path"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "direntry",
            "newinode"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_drop",
          "args": [
            "direntry"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "check_and_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1447-1453",
          "snippet": "static void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "server->ops->close",
          "args": [
            "xid",
            "tcon",
            "fid"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Create worked, get_inode_info failed rc = %d\\n\"",
            "rc"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsgid",
          "args": [],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->set_lease_key",
          "args": [
            "newinode",
            "fid"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_get_inode_info",
          "args": [
            "&newinode",
            "full_path",
            "buf",
            "inode->i_sb",
            "xid",
            "fid"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_get_inode_info_unix",
          "args": [
            "&newinode",
            "full_path",
            "inode->i_sb",
            "xid"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFSSMBUnixSetFileInfo",
          "args": [
            "xid",
            "tcon",
            "&args",
            "fid->netfid",
            "current->tgid"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMBUnixSetFileInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "5991-6054",
          "snippet": "int\nCIFSSMBUnixSetFileInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t       const struct cifs_unix_set_info_args *args,\n\t\t       u16 fid, u32 pid_of_opener)\n{\n\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tchar *data_offset;\n\tint rc = 0;\n\tu16 params, param_offset, offset, byte_count, count;\n\n\tcifs_dbg(FYI, \"Set Unix Info (via SetFileInfo)\\n\");\n\trc = small_smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid_of_opener);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid_of_opener >> 16));\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\tdata_offset = (char *)pSMB +\n\t\t\toffsetof(struct smb_hdr, Protocol) + offset;\n\n\tcount = sizeof(FILE_UNIX_BASIC_INFO);\n\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find max SMB PDU from sess */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->Fid = fid;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_UNIX_BASIC);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\tcifs_fill_unix_set_info((FILE_UNIX_BASIC_INFO *)data_offset, args);\n\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in Set Time (SetFileInfo) = %d\\n\",\n\t\t\t rc);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBUnixSetFileInfo(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t       const struct cifs_unix_set_info_args *args,\n\t\t       u16 fid, u32 pid_of_opener)\n{\n\tstruct smb_com_transaction2_sfi_req *pSMB  = NULL;\n\tchar *data_offset;\n\tint rc = 0;\n\tu16 params, param_offset, offset, byte_count, count;\n\n\tcifs_dbg(FYI, \"Set Unix Info (via SetFileInfo)\\n\");\n\trc = small_smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB);\n\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->hdr.Pid = cpu_to_le16((__u16)pid_of_opener);\n\tpSMB->hdr.PidHigh = cpu_to_le16((__u16)(pid_of_opener >> 16));\n\n\tparams = 6;\n\tpSMB->MaxSetupCount = 0;\n\tpSMB->Reserved = 0;\n\tpSMB->Flags = 0;\n\tpSMB->Timeout = 0;\n\tpSMB->Reserved2 = 0;\n\tparam_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;\n\toffset = param_offset + params;\n\n\tdata_offset = (char *)pSMB +\n\t\t\toffsetof(struct smb_hdr, Protocol) + offset;\n\n\tcount = sizeof(FILE_UNIX_BASIC_INFO);\n\n\tpSMB->MaxParameterCount = cpu_to_le16(2);\n\t/* BB find max SMB PDU from sess */\n\tpSMB->MaxDataCount = cpu_to_le16(1000);\n\tpSMB->SetupCount = 1;\n\tpSMB->Reserved3 = 0;\n\tpSMB->SubCommand = cpu_to_le16(TRANS2_SET_FILE_INFORMATION);\n\tbyte_count = 3 /* pad */  + params + count;\n\tpSMB->DataCount = cpu_to_le16(count);\n\tpSMB->ParameterCount = cpu_to_le16(params);\n\tpSMB->TotalDataCount = pSMB->DataCount;\n\tpSMB->TotalParameterCount = pSMB->ParameterCount;\n\tpSMB->ParameterOffset = cpu_to_le16(param_offset);\n\tpSMB->DataOffset = cpu_to_le16(offset);\n\tpSMB->Fid = fid;\n\tpSMB->InformationLevel = cpu_to_le16(SMB_SET_FILE_UNIX_BASIC);\n\tpSMB->Reserved4 = 0;\n\tinc_rfc1001_len(pSMB, byte_count);\n\tpSMB->ByteCount = cpu_to_le16(byte_count);\n\n\tcifs_fill_unix_set_info((FILE_UNIX_BASIC_INFO *)data_offset, args);\n\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Send error in Set Time (SetFileInfo) = %d\\n\",\n\t\t\t rc);\n\n\t/* Note: On -EAGAIN error only caller can retry on handle based calls\n\t\tsince file handle passed in no longer valid */\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fsgid",
          "args": [],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"cifs_create returned 0x%x\\n\"",
            "rc"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->open",
          "args": [
            "xid",
            "&oparms",
            "oplock",
            "buf"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "backup_cred",
          "args": [
            "cifs_sb"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "backup_cred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "598-611",
          "snippet": "bool\nbackup_cred(struct cifs_sb_info *cifs_sb)\n{\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPUID) {\n\t\tif (uid_eq(cifs_sb->mnt_backupuid, current_fsuid()))\n\t\t\treturn true;\n\t}\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPGID) {\n\t\tif (in_group_p(cifs_sb->mnt_backupgid))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nbool\nbackup_cred(struct cifs_sb_info *cifs_sb)\n{\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPUID) {\n\t\tif (uid_eq(cifs_sb->mnt_backupuid, current_fsuid()))\n\t\t\treturn true;\n\t}\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPGID) {\n\t\tif (in_group_p(cifs_sb->mnt_backupgid))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(FILE_ALL_INFO)",
            "GFP_KERNEL"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Create flag not set in create function\\n\""
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OPEN_FMODE",
          "args": [
            "oflags"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OPEN_FMODE",
          "args": [
            "oflags"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFSSMBClose",
          "args": [
            "xid",
            "tcon",
            "fid->netfid"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "CIFSSMBClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifssmb.c",
          "lines": "2510-2541",
          "snippet": "int\nCIFSSMBClose(const unsigned int xid, struct cifs_tcon *tcon, int smb_file_id)\n{\n\tint rc = 0;\n\tCLOSE_REQ *pSMB = NULL;\n\tcifs_dbg(FYI, \"In CIFSSMBClose\\n\");\n\n/* do not retry on dead session on close */\n\trc = small_smb_init(SMB_COM_CLOSE, 3, tcon, (void **) &pSMB);\n\tif (rc == -EAGAIN)\n\t\treturn 0;\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->FileID = (__u16) smb_file_id;\n\tpSMB->LastWriteTime = 0xFFFFFFFF;\n\tpSMB->ByteCount = 0;\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_closes);\n\tif (rc) {\n\t\tif (rc != -EINTR) {\n\t\t\t/* EINTR is expected when user ctl-c to kill app */\n\t\t\tcifs_dbg(VFS, \"Send error in Close = %d\\n\", rc);\n\t\t}\n\t}\n\n\t/* Since session is dead, file will be closed on server already */\n\tif (rc == -EAGAIN)\n\t\trc = 0;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nCIFSSMBClose(const unsigned int xid, struct cifs_tcon *tcon, int smb_file_id)\n{\n\tint rc = 0;\n\tCLOSE_REQ *pSMB = NULL;\n\tcifs_dbg(FYI, \"In CIFSSMBClose\\n\");\n\n/* do not retry on dead session on close */\n\trc = small_smb_init(SMB_COM_CLOSE, 3, tcon, (void **) &pSMB);\n\tif (rc == -EAGAIN)\n\t\treturn 0;\n\tif (rc)\n\t\treturn rc;\n\n\tpSMB->FileID = (__u16) smb_file_id;\n\tpSMB->LastWriteTime = 0xFFFFFFFF;\n\tpSMB->ByteCount = 0;\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) pSMB, 0);\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_closes);\n\tif (rc) {\n\t\tif (rc != -EINTR) {\n\t\t\t/* EINTR is expected when user ctl-c to kill app */\n\t\t\tcifs_dbg(VFS, \"Send error in Close = %d\\n\", rc);\n\t\t}\n\t}\n\n\t/* Since session is dead, file will be closed on server already */\n\tif (rc == -EAGAIN)\n\t\trc = 0;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "newinode->i_mode"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_posix_open",
          "args": [
            "full_path",
            "&newinode",
            "inode->i_sb",
            "mode",
            "oflags",
            "oplock",
            "&fid->netfid",
            "xid"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_posix_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/file.c",
          "lines": "113-173",
          "snippet": "int cifs_posix_open(char *full_path, struct inode **pinode,\n\t\t\tstruct super_block *sb, int mode, unsigned int f_flags,\n\t\t\t__u32 *poplock, __u16 *pnetfid, unsigned int xid)\n{\n\tint rc;\n\tFILE_UNIX_BASIC_INFO *presp_data;\n\t__u32 posix_flags = 0;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifs_fattr fattr;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\n\tcifs_dbg(FYI, \"posix open %s\\n\", full_path);\n\n\tpresp_data = kzalloc(sizeof(FILE_UNIX_BASIC_INFO), GFP_KERNEL);\n\tif (presp_data == NULL)\n\t\treturn -ENOMEM;\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink)) {\n\t\trc = PTR_ERR(tlink);\n\t\tgoto posix_open_ret;\n\t}\n\n\ttcon = tlink_tcon(tlink);\n\tmode &= ~current_umask();\n\n\tposix_flags = cifs_posix_convert_flags(f_flags);\n\trc = CIFSPOSIXCreate(xid, tcon, posix_flags, mode, pnetfid, presp_data,\n\t\t\t     poplock, full_path, cifs_sb->local_nls,\n\t\t\t     cifs_sb->mnt_cifs_flags &\n\t\t\t\t\tCIFS_MOUNT_MAP_SPECIAL_CHR);\n\tcifs_put_tlink(tlink);\n\n\tif (rc)\n\t\tgoto posix_open_ret;\n\n\tif (presp_data->Type == cpu_to_le32(-1))\n\t\tgoto posix_open_ret; /* open ok, caller does qpathinfo */\n\n\tif (!pinode)\n\t\tgoto posix_open_ret; /* caller does not need info */\n\n\tcifs_unix_basic_to_fattr(&fattr, presp_data, cifs_sb);\n\n\t/* get new inode and set it up */\n\tif (*pinode == NULL) {\n\t\tcifs_fill_uniqueid(sb, &fattr);\n\t\t*pinode = cifs_iget(sb, &fattr);\n\t\tif (!*pinode) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto posix_open_ret;\n\t\t}\n\t} else {\n\t\tcifs_fattr_to_inode(*pinode, &fattr);\n\t}\n\nposix_open_ret:\n\tkfree(presp_data);\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/delay.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <asm/div64.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/delay.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/backing-dev.h>\n#include <linux/fs.h>\n\nint cifs_posix_open(char *full_path, struct inode **pinode,\n\t\t\tstruct super_block *sb, int mode, unsigned int f_flags,\n\t\t\t__u32 *poplock, __u16 *pnetfid, unsigned int xid)\n{\n\tint rc;\n\tFILE_UNIX_BASIC_INFO *presp_data;\n\t__u32 posix_flags = 0;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\n\tstruct cifs_fattr fattr;\n\tstruct tcon_link *tlink;\n\tstruct cifs_tcon *tcon;\n\n\tcifs_dbg(FYI, \"posix open %s\\n\", full_path);\n\n\tpresp_data = kzalloc(sizeof(FILE_UNIX_BASIC_INFO), GFP_KERNEL);\n\tif (presp_data == NULL)\n\t\treturn -ENOMEM;\n\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink)) {\n\t\trc = PTR_ERR(tlink);\n\t\tgoto posix_open_ret;\n\t}\n\n\ttcon = tlink_tcon(tlink);\n\tmode &= ~current_umask();\n\n\tposix_flags = cifs_posix_convert_flags(f_flags);\n\trc = CIFSPOSIXCreate(xid, tcon, posix_flags, mode, pnetfid, presp_data,\n\t\t\t     poplock, full_path, cifs_sb->local_nls,\n\t\t\t     cifs_sb->mnt_cifs_flags &\n\t\t\t\t\tCIFS_MOUNT_MAP_SPECIAL_CHR);\n\tcifs_put_tlink(tlink);\n\n\tif (rc)\n\t\tgoto posix_open_ret;\n\n\tif (presp_data->Type == cpu_to_le32(-1))\n\t\tgoto posix_open_ret; /* open ok, caller does qpathinfo */\n\n\tif (!pinode)\n\t\tgoto posix_open_ret; /* caller does not need info */\n\n\tcifs_unix_basic_to_fattr(&fattr, presp_data, cifs_sb);\n\n\t/* get new inode and set it up */\n\tif (*pinode == NULL) {\n\t\tcifs_fill_uniqueid(sb, &fattr);\n\t\t*pinode = cifs_iget(sb, &fattr);\n\t\tif (!*pinode) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto posix_open_ret;\n\t\t}\n\t} else {\n\t\tcifs_fattr_to_inode(*pinode, &fattr);\n\t}\n\nposix_open_ret:\n\tkfree(presp_data);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "tcon->fsUnixInfo.Capability"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cap_unix",
          "args": [
            "tcon->ses"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "cap_unix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "804-808",
          "snippet": "static inline bool\ncap_unix(struct cifs_ses *ses)\n{\n\treturn ses->server->vals->cap_unix & ses->capabilities;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline bool\ncap_unix(struct cifs_ses *ses)\n{\n\treturn ses->server->vals->cap_unix & ses->capabilities;\n}"
        }
      },
      {
        "call_info": {
          "callee": "build_path_from_dentry",
          "args": [
            "direntry"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "build_path_from_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/dir.c",
          "lines": "81-167",
          "snippet": "char *\nbuild_path_from_dentry(struct dentry *direntry)\n{\n\tstruct dentry *temp;\n\tint namelen;\n\tint dfsplen;\n\tchar *full_path;\n\tchar dirsep;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(direntry->d_sb);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\tunsigned seq;\n\n\tdirsep = CIFS_DIR_SEP(cifs_sb);\n\tif (tcon->Flags & SMB_SHARE_IS_IN_DFS)\n\t\tdfsplen = strnlen(tcon->treeName, MAX_TREE_SIZE + 1);\n\telse\n\t\tdfsplen = 0;\ncifs_bp_rename_retry:\n\tnamelen = dfsplen;\n\tseq = read_seqbegin(&rename_lock);\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tnamelen += (1 + temp->d_name.len);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcifs_dbg(VFS, \"corrupt dentry\\n\");\n\t\t\trcu_read_unlock();\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tfull_path = kmalloc(namelen+1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn full_path;\n\tfull_path[namelen] = 0;\t/* trailing null */\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tspin_lock(&temp->d_lock);\n\t\tnamelen -= 1 + temp->d_name.len;\n\t\tif (namelen < 0) {\n\t\t\tspin_unlock(&temp->d_lock);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tfull_path[namelen] = dirsep;\n\t\t\tstrncpy(full_path + namelen + 1, temp->d_name.name,\n\t\t\t\ttemp->d_name.len);\n\t\t\tcifs_dbg(FYI, \"name: %s\\n\", full_path + namelen);\n\t\t}\n\t\tspin_unlock(&temp->d_lock);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcifs_dbg(VFS, \"corrupt dentry\\n\");\n\t\t\trcu_read_unlock();\n\t\t\tkfree(full_path);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tif (namelen != dfsplen || read_seqretry(&rename_lock, seq)) {\n\t\tcifs_dbg(FYI, \"did not end path lookup where expected. namelen=%ddfsplen=%d\\n\",\n\t\t\t namelen, dfsplen);\n\t\t/* presumably this is only possible if racing with a rename\n\t\tof one of the parent directories  (we can not lock the dentries\n\t\tabove us to prevent this, but retrying should be harmless) */\n\t\tkfree(full_path);\n\t\tgoto cifs_bp_rename_retry;\n\t}\n\t/* DIR_SEP already set for byte  0 / vs \\ but not for\n\t   subsequent slashes in prepath which currently must\n\t   be entered the right way - not sure if there is an alternative\n\t   since the '\\' is a valid posix character so we can not switch\n\t   those safely to '/' if any are found in the middle of the prepath */\n\t/* BB test paths to Windows with '/' in the midst of prepath */\n\n\tif (dfsplen) {\n\t\tstrncpy(full_path, tcon->treeName, dfsplen);\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < dfsplen; i++) {\n\t\t\t\tif (full_path[i] == '\\\\')\n\t\t\t\t\tfull_path[i] = '/';\n\t\t\t}\n\t\t}\n\t}\n\treturn full_path;\n}",
          "includes": [
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nchar *\nbuild_path_from_dentry(struct dentry *direntry)\n{\n\tstruct dentry *temp;\n\tint namelen;\n\tint dfsplen;\n\tchar *full_path;\n\tchar dirsep;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(direntry->d_sb);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\tunsigned seq;\n\n\tdirsep = CIFS_DIR_SEP(cifs_sb);\n\tif (tcon->Flags & SMB_SHARE_IS_IN_DFS)\n\t\tdfsplen = strnlen(tcon->treeName, MAX_TREE_SIZE + 1);\n\telse\n\t\tdfsplen = 0;\ncifs_bp_rename_retry:\n\tnamelen = dfsplen;\n\tseq = read_seqbegin(&rename_lock);\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tnamelen += (1 + temp->d_name.len);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcifs_dbg(VFS, \"corrupt dentry\\n\");\n\t\t\trcu_read_unlock();\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tfull_path = kmalloc(namelen+1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn full_path;\n\tfull_path[namelen] = 0;\t/* trailing null */\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tspin_lock(&temp->d_lock);\n\t\tnamelen -= 1 + temp->d_name.len;\n\t\tif (namelen < 0) {\n\t\t\tspin_unlock(&temp->d_lock);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tfull_path[namelen] = dirsep;\n\t\t\tstrncpy(full_path + namelen + 1, temp->d_name.name,\n\t\t\t\ttemp->d_name.len);\n\t\t\tcifs_dbg(FYI, \"name: %s\\n\", full_path + namelen);\n\t\t}\n\t\tspin_unlock(&temp->d_lock);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcifs_dbg(VFS, \"corrupt dentry\\n\");\n\t\t\trcu_read_unlock();\n\t\t\tkfree(full_path);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tif (namelen != dfsplen || read_seqretry(&rename_lock, seq)) {\n\t\tcifs_dbg(FYI, \"did not end path lookup where expected. namelen=%ddfsplen=%d\\n\",\n\t\t\t namelen, dfsplen);\n\t\t/* presumably this is only possible if racing with a rename\n\t\tof one of the parent directories  (we can not lock the dentries\n\t\tabove us to prevent this, but retrying should be harmless) */\n\t\tkfree(full_path);\n\t\tgoto cifs_bp_rename_retry;\n\t}\n\t/* DIR_SEP already set for byte  0 / vs \\ but not for\n\t   subsequent slashes in prepath which currently must\n\t   be entered the right way - not sure if there is an alternative\n\t   since the '\\' is a valid posix character so we can not switch\n\t   those safely to '/' if any are found in the middle of the prepath */\n\t/* BB test paths to Windows with '/' in the midst of prepath */\n\n\tif (dfsplen) {\n\t\tstrncpy(full_path, tcon->treeName, dfsplen);\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < dfsplen; i++) {\n\t\t\t\tif (full_path[i] == '\\\\')\n\t\t\t\t\tfull_path[i] = '/';\n\t\t\t}\n\t\t}\n\t}\n\treturn full_path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "tlink"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nstatic int\ncifs_do_create(struct inode *inode, struct dentry *direntry, unsigned int xid,\n\t       struct tcon_link *tlink, unsigned oflags, umode_t mode,\n\t       __u32 *oplock, struct cifs_fid *fid)\n{\n\tint rc = -ENOENT;\n\tint create_options = CREATE_NOT_DIR;\n\tint desired_access;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\n\tstruct cifs_tcon *tcon = tlink_tcon(tlink);\n\tchar *full_path = NULL;\n\tFILE_ALL_INFO *buf = NULL;\n\tstruct inode *newinode = NULL;\n\tint disposition;\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct cifs_open_parms oparms;\n\n\t*oplock = 0;\n\tif (tcon->ses->server->oplocks)\n\t\t*oplock = REQ_OPLOCK;\n\n\tfull_path = build_path_from_dentry(direntry);\n\tif (full_path == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (tcon->unix_ext && cap_unix(tcon->ses) && !tcon->broken_posix_open &&\n\t    (CIFS_UNIX_POSIX_PATH_OPS_CAP &\n\t\t\tle64_to_cpu(tcon->fsUnixInfo.Capability))) {\n\t\trc = cifs_posix_open(full_path, &newinode, inode->i_sb, mode,\n\t\t\t\t     oflags, oplock, &fid->netfid, xid);\n\t\tswitch (rc) {\n\t\tcase 0:\n\t\t\tif (newinode == NULL) {\n\t\t\t\t/* query inode info */\n\t\t\t\tgoto cifs_create_get_file_info;\n\t\t\t}\n\n\t\t\tif (!S_ISREG(newinode->i_mode)) {\n\t\t\t\t/*\n\t\t\t\t * The server may allow us to open things like\n\t\t\t\t * FIFOs, but the client isn't set up to deal\n\t\t\t\t * with that. If it's not a regular file, just\n\t\t\t\t * close it and proceed as if it were a normal\n\t\t\t\t * lookup.\n\t\t\t\t */\n\t\t\t\tCIFSSMBClose(xid, tcon, fid->netfid);\n\t\t\t\tgoto cifs_create_get_file_info;\n\t\t\t}\n\t\t\t/* success, no need to query */\n\t\t\tgoto cifs_create_set_dentry;\n\n\t\tcase -ENOENT:\n\t\t\tgoto cifs_create_get_file_info;\n\n\t\tcase -EIO:\n\t\tcase -EINVAL:\n\t\t\t/*\n\t\t\t * EIO could indicate that (posix open) operation is not\n\t\t\t * supported, despite what server claimed in capability\n\t\t\t * negotiation.\n\t\t\t *\n\t\t\t * POSIX open in samba versions 3.3.1 and earlier could\n\t\t\t * incorrectly fail with invalid parameter.\n\t\t\t */\n\t\t\ttcon->broken_posix_open = true;\n\t\t\tbreak;\n\n\t\tcase -EREMOTE:\n\t\tcase -EOPNOTSUPP:\n\t\t\t/*\n\t\t\t * EREMOTE indicates DFS junction, which is not handled\n\t\t\t * in posix open.  If either that or op not supported\n\t\t\t * returned, follow the normal lookup.\n\t\t\t */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * fallthrough to retry, using older open call, this is case\n\t\t * where server does not support this SMB level, and falsely\n\t\t * claims capability (also get here for DFS case which should be\n\t\t * rare for path not covered on files)\n\t\t */\n\t}\n\n\tdesired_access = 0;\n\tif (OPEN_FMODE(oflags) & FMODE_READ)\n\t\tdesired_access |= GENERIC_READ; /* is this too little? */\n\tif (OPEN_FMODE(oflags) & FMODE_WRITE)\n\t\tdesired_access |= GENERIC_WRITE;\n\n\tdisposition = FILE_OVERWRITE_IF;\n\tif ((oflags & (O_CREAT | O_EXCL)) == (O_CREAT | O_EXCL))\n\t\tdisposition = FILE_CREATE;\n\telse if ((oflags & (O_CREAT | O_TRUNC)) == (O_CREAT | O_TRUNC))\n\t\tdisposition = FILE_OVERWRITE_IF;\n\telse if ((oflags & O_CREAT) == O_CREAT)\n\t\tdisposition = FILE_OPEN_IF;\n\telse\n\t\tcifs_dbg(FYI, \"Create flag not set in create function\\n\");\n\n\t/*\n\t * BB add processing to set equivalent of mode - e.g. via CreateX with\n\t * ACLs\n\t */\n\n\tif (!server->ops->open) {\n\t\trc = -ENOSYS;\n\t\tgoto out;\n\t}\n\n\tbuf = kmalloc(sizeof(FILE_ALL_INFO), GFP_KERNEL);\n\tif (buf == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * if we're not using unix extensions, see if we need to set\n\t * ATTR_READONLY on the create call\n\t */\n\tif (!tcon->unix_ext && (mode & S_IWUGO) == 0)\n\t\tcreate_options |= CREATE_OPTION_READONLY;\n\n\tif (backup_cred(cifs_sb))\n\t\tcreate_options |= CREATE_OPEN_BACKUP_INTENT;\n\n\toparms.tcon = tcon;\n\toparms.cifs_sb = cifs_sb;\n\toparms.desired_access = desired_access;\n\toparms.create_options = create_options;\n\toparms.disposition = disposition;\n\toparms.path = full_path;\n\toparms.fid = fid;\n\toparms.reconnect = false;\n\n\trc = server->ops->open(xid, &oparms, oplock, buf);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"cifs_create returned 0x%x\\n\", rc);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If Open reported that we actually created a file then we now have to\n\t * set the mode if possible.\n\t */\n\tif ((tcon->unix_ext) && (*oplock & CIFS_CREATE_ACTION)) {\n\t\tstruct cifs_unix_set_info_args args = {\n\t\t\t\t.mode\t= mode,\n\t\t\t\t.ctime\t= NO_CHANGE_64,\n\t\t\t\t.atime\t= NO_CHANGE_64,\n\t\t\t\t.mtime\t= NO_CHANGE_64,\n\t\t\t\t.device\t= 0,\n\t\t};\n\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID) {\n\t\t\targs.uid = current_fsuid();\n\t\t\tif (inode->i_mode & S_ISGID)\n\t\t\t\targs.gid = inode->i_gid;\n\t\t\telse\n\t\t\t\targs.gid = current_fsgid();\n\t\t} else {\n\t\t\targs.uid = INVALID_UID; /* no change */\n\t\t\targs.gid = INVALID_GID; /* no change */\n\t\t}\n\t\tCIFSSMBUnixSetFileInfo(xid, tcon, &args, fid->netfid,\n\t\t\t\t       current->tgid);\n\t} else {\n\t\t/*\n\t\t * BB implement mode setting via Windows security\n\t\t * descriptors e.g.\n\t\t */\n\t\t/* CIFSSMBWinSetPerms(xid,tcon,path,mode,-1,-1,nls);*/\n\n\t\t/* Could set r/o dos attribute if mode & 0222 == 0 */\n\t}\n\ncifs_create_get_file_info:\n\t/* server might mask mode so we have to query for it */\n\tif (tcon->unix_ext)\n\t\trc = cifs_get_inode_info_unix(&newinode, full_path, inode->i_sb,\n\t\t\t\t\t      xid);\n\telse {\n\t\trc = cifs_get_inode_info(&newinode, full_path, buf, inode->i_sb,\n\t\t\t\t\t xid, fid);\n\t\tif (newinode) {\n\t\t\tif (server->ops->set_lease_key)\n\t\t\t\tserver->ops->set_lease_key(newinode, fid);\n\t\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DYNPERM)\n\t\t\t\tnewinode->i_mode = mode;\n\t\t\tif ((*oplock & CIFS_CREATE_ACTION) &&\n\t\t\t    (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID)) {\n\t\t\t\tnewinode->i_uid = current_fsuid();\n\t\t\t\tif (inode->i_mode & S_ISGID)\n\t\t\t\t\tnewinode->i_gid = inode->i_gid;\n\t\t\t\telse\n\t\t\t\t\tnewinode->i_gid = current_fsgid();\n\t\t\t}\n\t\t}\n\t}\n\ncifs_create_set_dentry:\n\tif (rc != 0) {\n\t\tcifs_dbg(FYI, \"Create worked, get_inode_info failed rc = %d\\n\",\n\t\t\t rc);\n\t\tif (server->ops->close)\n\t\t\tserver->ops->close(xid, tcon, fid);\n\t\tgoto out;\n\t}\n\td_drop(direntry);\n\td_add(direntry, newinode);\n\nout:\n\tkfree(buf);\n\tkfree(full_path);\n\treturn rc;\n}"
  },
  {
    "function_name": "check_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/dir.c",
    "lines": "173-188",
    "snippet": "static int\ncheck_name(struct dentry *direntry)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(direntry->d_sb);\n\tint i;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)) {\n\t\tfor (i = 0; i < direntry->d_name.len; i++) {\n\t\t\tif (direntry->d_name.name[i] == '\\\\') {\n\t\t\t\tcifs_dbg(FYI, \"Invalid file name\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Invalid file name\\n\""
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "direntry->d_sb"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nstatic int\ncheck_name(struct dentry *direntry)\n{\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(direntry->d_sb);\n\tint i;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)) {\n\t\tfor (i = 0; i < direntry->d_name.len; i++) {\n\t\t\tif (direntry->d_name.name[i] == '\\\\') {\n\t\t\t\tcifs_dbg(FYI, \"Invalid file name\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "build_path_from_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/dir.c",
    "lines": "81-167",
    "snippet": "char *\nbuild_path_from_dentry(struct dentry *direntry)\n{\n\tstruct dentry *temp;\n\tint namelen;\n\tint dfsplen;\n\tchar *full_path;\n\tchar dirsep;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(direntry->d_sb);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\tunsigned seq;\n\n\tdirsep = CIFS_DIR_SEP(cifs_sb);\n\tif (tcon->Flags & SMB_SHARE_IS_IN_DFS)\n\t\tdfsplen = strnlen(tcon->treeName, MAX_TREE_SIZE + 1);\n\telse\n\t\tdfsplen = 0;\ncifs_bp_rename_retry:\n\tnamelen = dfsplen;\n\tseq = read_seqbegin(&rename_lock);\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tnamelen += (1 + temp->d_name.len);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcifs_dbg(VFS, \"corrupt dentry\\n\");\n\t\t\trcu_read_unlock();\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tfull_path = kmalloc(namelen+1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn full_path;\n\tfull_path[namelen] = 0;\t/* trailing null */\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tspin_lock(&temp->d_lock);\n\t\tnamelen -= 1 + temp->d_name.len;\n\t\tif (namelen < 0) {\n\t\t\tspin_unlock(&temp->d_lock);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tfull_path[namelen] = dirsep;\n\t\t\tstrncpy(full_path + namelen + 1, temp->d_name.name,\n\t\t\t\ttemp->d_name.len);\n\t\t\tcifs_dbg(FYI, \"name: %s\\n\", full_path + namelen);\n\t\t}\n\t\tspin_unlock(&temp->d_lock);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcifs_dbg(VFS, \"corrupt dentry\\n\");\n\t\t\trcu_read_unlock();\n\t\t\tkfree(full_path);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tif (namelen != dfsplen || read_seqretry(&rename_lock, seq)) {\n\t\tcifs_dbg(FYI, \"did not end path lookup where expected. namelen=%ddfsplen=%d\\n\",\n\t\t\t namelen, dfsplen);\n\t\t/* presumably this is only possible if racing with a rename\n\t\tof one of the parent directories  (we can not lock the dentries\n\t\tabove us to prevent this, but retrying should be harmless) */\n\t\tkfree(full_path);\n\t\tgoto cifs_bp_rename_retry;\n\t}\n\t/* DIR_SEP already set for byte  0 / vs \\ but not for\n\t   subsequent slashes in prepath which currently must\n\t   be entered the right way - not sure if there is an alternative\n\t   since the '\\' is a valid posix character so we can not switch\n\t   those safely to '/' if any are found in the middle of the prepath */\n\t/* BB test paths to Windows with '/' in the midst of prepath */\n\n\tif (dfsplen) {\n\t\tstrncpy(full_path, tcon->treeName, dfsplen);\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < dfsplen; i++) {\n\t\t\t\tif (full_path[i] == '\\\\')\n\t\t\t\t\tfull_path[i] = '/';\n\t\t\t}\n\t\t}\n\t}\n\treturn full_path;\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "full_path",
            "tcon->treeName",
            "dfsplen"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "full_path"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"did not end path lookup where expected. namelen=%ddfsplen=%d\\n\"",
            "namelen",
            "dfsplen"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqretry",
          "args": [
            "&rename_lock",
            "seq"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "full_path"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"corrupt dentry\\n\""
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&temp->d_lock"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"name: %s\\n\"",
            "full_path + namelen"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "full_path + namelen + 1",
            "temp->d_name.name",
            "temp->d_name.len"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&temp->d_lock"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "temp"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "namelen+1",
            "GFP_KERNEL"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"corrupt dentry\\n\""
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "temp"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqbegin",
          "args": [
            "&rename_lock"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "tcon->treeName",
            "MAX_TREE_SIZE + 1"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_DIR_SEP",
          "args": [
            "cifs_sb"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_DIR_SEP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1177-1183",
          "snippet": "static inline char CIFS_DIR_SEP(const struct cifs_sb_info *cifs_sb)\n{\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)\n\t\treturn '/';\n\telse\n\t\treturn '\\\\';\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline char CIFS_DIR_SEP(const struct cifs_sb_info *cifs_sb)\n{\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)\n\t\treturn '/';\n\telse\n\t\treturn '\\\\';\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_sb_master_tcon",
          "args": [
            "cifs_sb"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_sb_master_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "3948-3952",
          "snippet": "struct cifs_tcon *\ncifs_sb_master_tcon(struct cifs_sb_info *cifs_sb)\n{\n\treturn tlink_tcon(cifs_sb_master_tlink(cifs_sb));\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstruct cifs_tcon *\ncifs_sb_master_tcon(struct cifs_sb_info *cifs_sb)\n{\n\treturn tlink_tcon(cifs_sb_master_tlink(cifs_sb));\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "direntry->d_sb"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nchar *\nbuild_path_from_dentry(struct dentry *direntry)\n{\n\tstruct dentry *temp;\n\tint namelen;\n\tint dfsplen;\n\tchar *full_path;\n\tchar dirsep;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(direntry->d_sb);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\tunsigned seq;\n\n\tdirsep = CIFS_DIR_SEP(cifs_sb);\n\tif (tcon->Flags & SMB_SHARE_IS_IN_DFS)\n\t\tdfsplen = strnlen(tcon->treeName, MAX_TREE_SIZE + 1);\n\telse\n\t\tdfsplen = 0;\ncifs_bp_rename_retry:\n\tnamelen = dfsplen;\n\tseq = read_seqbegin(&rename_lock);\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tnamelen += (1 + temp->d_name.len);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcifs_dbg(VFS, \"corrupt dentry\\n\");\n\t\t\trcu_read_unlock();\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tfull_path = kmalloc(namelen+1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn full_path;\n\tfull_path[namelen] = 0;\t/* trailing null */\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tspin_lock(&temp->d_lock);\n\t\tnamelen -= 1 + temp->d_name.len;\n\t\tif (namelen < 0) {\n\t\t\tspin_unlock(&temp->d_lock);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tfull_path[namelen] = dirsep;\n\t\t\tstrncpy(full_path + namelen + 1, temp->d_name.name,\n\t\t\t\ttemp->d_name.len);\n\t\t\tcifs_dbg(FYI, \"name: %s\\n\", full_path + namelen);\n\t\t}\n\t\tspin_unlock(&temp->d_lock);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcifs_dbg(VFS, \"corrupt dentry\\n\");\n\t\t\trcu_read_unlock();\n\t\t\tkfree(full_path);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tif (namelen != dfsplen || read_seqretry(&rename_lock, seq)) {\n\t\tcifs_dbg(FYI, \"did not end path lookup where expected. namelen=%ddfsplen=%d\\n\",\n\t\t\t namelen, dfsplen);\n\t\t/* presumably this is only possible if racing with a rename\n\t\tof one of the parent directories  (we can not lock the dentries\n\t\tabove us to prevent this, but retrying should be harmless) */\n\t\tkfree(full_path);\n\t\tgoto cifs_bp_rename_retry;\n\t}\n\t/* DIR_SEP already set for byte  0 / vs \\ but not for\n\t   subsequent slashes in prepath which currently must\n\t   be entered the right way - not sure if there is an alternative\n\t   since the '\\' is a valid posix character so we can not switch\n\t   those safely to '/' if any are found in the middle of the prepath */\n\t/* BB test paths to Windows with '/' in the midst of prepath */\n\n\tif (dfsplen) {\n\t\tstrncpy(full_path, tcon->treeName, dfsplen);\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < dfsplen; i++) {\n\t\t\t\tif (full_path[i] == '\\\\')\n\t\t\t\t\tfull_path[i] = '/';\n\t\t\t}\n\t\t}\n\t}\n\treturn full_path;\n}"
  },
  {
    "function_name": "cifs_build_path_to_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/dir.c",
    "lines": "48-78",
    "snippet": "char *\ncifs_build_path_to_root(struct smb_vol *vol, struct cifs_sb_info *cifs_sb,\n\t\t\tstruct cifs_tcon *tcon)\n{\n\tint pplen = vol->prepath ? strlen(vol->prepath) + 1 : 0;\n\tint dfsplen;\n\tchar *full_path = NULL;\n\n\t/* if no prefix path, simply set path to the root of share to \"\" */\n\tif (pplen == 0) {\n\t\tfull_path = kzalloc(1, GFP_KERNEL);\n\t\treturn full_path;\n\t}\n\n\tif (tcon->Flags & SMB_SHARE_IS_IN_DFS)\n\t\tdfsplen = strnlen(tcon->treeName, MAX_TREE_SIZE + 1);\n\telse\n\t\tdfsplen = 0;\n\n\tfull_path = kmalloc(dfsplen + pplen + 1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn full_path;\n\n\tif (dfsplen)\n\t\tstrncpy(full_path, tcon->treeName, dfsplen);\n\tfull_path[dfsplen] = CIFS_DIR_SEP(cifs_sb);\n\tstrncpy(full_path + dfsplen + 1, vol->prepath, pplen);\n\tconvert_delimiter(full_path, CIFS_DIR_SEP(cifs_sb));\n\tfull_path[dfsplen + pplen] = 0; /* add trailing null */\n\treturn full_path;\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "convert_delimiter",
          "args": [
            "full_path",
            "CIFS_DIR_SEP(cifs_sb)"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "convert_delimiter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1185-1198",
          "snippet": "static inline void\nconvert_delimiter(char *path, char delim)\n{\n\tchar old_delim, *pos;\n\n\tif (delim == '/')\n\t\told_delim = '\\\\';\n\telse\n\t\told_delim = '/';\n\n\tpos = path;\n\twhile ((pos = strchr(pos, old_delim)))\n\t\t*pos = delim;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\nconvert_delimiter(char *path, char delim)\n{\n\tchar old_delim, *pos;\n\n\tif (delim == '/')\n\t\told_delim = '\\\\';\n\telse\n\t\told_delim = '/';\n\n\tpos = path;\n\twhile ((pos = strchr(pos, old_delim)))\n\t\t*pos = delim;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_DIR_SEP",
          "args": [
            "cifs_sb"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_DIR_SEP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1177-1183",
          "snippet": "static inline char CIFS_DIR_SEP(const struct cifs_sb_info *cifs_sb)\n{\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)\n\t\treturn '/';\n\telse\n\t\treturn '\\\\';\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline char CIFS_DIR_SEP(const struct cifs_sb_info *cifs_sb)\n{\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)\n\t\treturn '/';\n\telse\n\t\treturn '\\\\';\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "full_path + dfsplen + 1",
            "vol->prepath",
            "pplen"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "full_path",
            "tcon->treeName",
            "dfsplen"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "dfsplen + pplen + 1",
            "GFP_KERNEL"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "tcon->treeName",
            "MAX_TREE_SIZE + 1"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "1",
            "GFP_KERNEL"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "vol->prepath"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nchar *\ncifs_build_path_to_root(struct smb_vol *vol, struct cifs_sb_info *cifs_sb,\n\t\t\tstruct cifs_tcon *tcon)\n{\n\tint pplen = vol->prepath ? strlen(vol->prepath) + 1 : 0;\n\tint dfsplen;\n\tchar *full_path = NULL;\n\n\t/* if no prefix path, simply set path to the root of share to \"\" */\n\tif (pplen == 0) {\n\t\tfull_path = kzalloc(1, GFP_KERNEL);\n\t\treturn full_path;\n\t}\n\n\tif (tcon->Flags & SMB_SHARE_IS_IN_DFS)\n\t\tdfsplen = strnlen(tcon->treeName, MAX_TREE_SIZE + 1);\n\telse\n\t\tdfsplen = 0;\n\n\tfull_path = kmalloc(dfsplen + pplen + 1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn full_path;\n\n\tif (dfsplen)\n\t\tstrncpy(full_path, tcon->treeName, dfsplen);\n\tfull_path[dfsplen] = CIFS_DIR_SEP(cifs_sb);\n\tstrncpy(full_path + dfsplen + 1, vol->prepath, pplen);\n\tconvert_delimiter(full_path, CIFS_DIR_SEP(cifs_sb));\n\tfull_path[dfsplen + pplen] = 0; /* add trailing null */\n\treturn full_path;\n}"
  },
  {
    "function_name": "renew_parental_timestamps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/dir.c",
    "lines": "37-46",
    "snippet": "static void\nrenew_parental_timestamps(struct dentry *direntry)\n{\n\t/* BB check if there is a way to get the kernel to do this or if we\n\t   really need this */\n\tdo {\n\t\tdirentry->d_time = jiffies;\n\t\tdirentry = direntry->d_parent;\n\t} while (!IS_ROOT(direntry));\n}",
    "includes": [
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_fs_sb.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"cifspdu.h\"",
      "#include \"cifsfs.h\"",
      "#include <linux/file.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "direntry"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nstatic void\nrenew_parental_timestamps(struct dentry *direntry)\n{\n\t/* BB check if there is a way to get the kernel to do this or if we\n\t   really need this */\n\tdo {\n\t\tdirentry->d_time = jiffies;\n\t\tdirentry = direntry->d_parent;\n\t} while (!IS_ROOT(direntry));\n}"
  }
]