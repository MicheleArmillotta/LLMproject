[
  {
    "function_name": "f2fs_tmpfile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/namei.c",
    "lines": "665-705",
    "snippet": "static int f2fs_tmpfile(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tstruct inode *inode;\n\tint err;\n\n\tinode = f2fs_new_inode(dir, mode);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tinode->i_op = &f2fs_file_inode_operations;\n\tinode->i_fop = &f2fs_file_operations;\n\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\n\tf2fs_lock_op(sbi);\n\terr = acquire_orphan_inode(sbi);\n\tif (err)\n\t\tgoto out;\n\n\terr = f2fs_do_tmpfile(inode, dir);\n\tif (err)\n\t\tgoto release_out;\n\n\t/*\n\t * add this non-linked tmpfile to orphan list, in this way we could\n\t * remove all unused data of tmpfile after abnormal power-off.\n\t */\n\tadd_orphan_inode(sbi, inode->i_ino);\n\tf2fs_unlock_op(sbi);\n\n\talloc_nid_done(sbi, inode->i_ino);\n\td_tmpfile(dentry, inode);\n\tunlock_new_inode(inode);\n\treturn 0;\n\nrelease_out:\n\trelease_orphan_inode(sbi);\nout:\n\thandle_failed_inode(inode);\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/dcache.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "handle_failed_inode",
          "args": [
            "inode"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "handle_failed_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
          "lines": "343-364",
          "snippet": "void handle_failed_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\n\tclear_nlink(inode);\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\n\ti_size_write(inode, 0);\n\tif (F2FS_HAS_BLOCKS(inode))\n\t\tf2fs_truncate(inode);\n\n\tremove_inode_page(inode);\n\n\tclear_inode_flag(F2FS_I(inode), FI_INLINE_DATA);\n\tclear_inode_flag(F2FS_I(inode), FI_INLINE_DENTRY);\n\talloc_nid_failed(sbi, inode->i_ino);\n\tf2fs_unlock_op(sbi);\n\n\t/* iput will drop the inode object */\n\tiput(inode);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid handle_failed_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\n\tclear_nlink(inode);\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\n\ti_size_write(inode, 0);\n\tif (F2FS_HAS_BLOCKS(inode))\n\t\tf2fs_truncate(inode);\n\n\tremove_inode_page(inode);\n\n\tclear_inode_flag(F2FS_I(inode), FI_INLINE_DATA);\n\tclear_inode_flag(F2FS_I(inode), FI_INLINE_DENTRY);\n\talloc_nid_failed(sbi, inode->i_ino);\n\tf2fs_unlock_op(sbi);\n\n\t/* iput will drop the inode object */\n\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_orphan_inode",
          "args": [
            "sbi"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "release_orphan_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "433-441",
          "snippet": "void release_orphan_inode(struct f2fs_sb_info *sbi)\n{\n\tstruct inode_management *im = &sbi->im[ORPHAN_INO];\n\n\tspin_lock(&im->ino_lock);\n\tf2fs_bug_on(sbi, im->ino_num == 0);\n\tim->ino_num--;\n\tspin_unlock(&im->ino_lock);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nvoid release_orphan_inode(struct f2fs_sb_info *sbi)\n{\n\tstruct inode_management *im = &sbi->im[ORPHAN_INO];\n\n\tspin_lock(&im->ino_lock);\n\tf2fs_bug_on(sbi, im->ino_num == 0);\n\tim->ino_num--;\n\tspin_unlock(&im->ino_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_tmpfile",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "d_tmpfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "3325-3338",
          "snippet": "void d_tmpfile(struct dentry *dentry, struct inode *inode)\n{\n\tinode_dec_link_count(inode);\n\tBUG_ON(dentry->d_name.name != dentry->d_iname ||\n\t\t!hlist_unhashed(&dentry->d_u.d_alias) ||\n\t\t!d_unlinked(dentry));\n\tspin_lock(&dentry->d_parent->d_lock);\n\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\tdentry->d_name.len = sprintf(dentry->d_iname, \"#%llu\",\n\t\t\t\t(unsigned long long)inode->i_ino);\n\tspin_unlock(&dentry->d_lock);\n\tspin_unlock(&dentry->d_parent->d_lock);\n\td_instantiate(dentry, inode);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid d_tmpfile(struct dentry *dentry, struct inode *inode)\n{\n\tinode_dec_link_count(inode);\n\tBUG_ON(dentry->d_name.name != dentry->d_iname ||\n\t\t!hlist_unhashed(&dentry->d_u.d_alias) ||\n\t\t!d_unlinked(dentry));\n\tspin_lock(&dentry->d_parent->d_lock);\n\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\tdentry->d_name.len = sprintf(dentry->d_iname, \"#%llu\",\n\t\t\t\t(unsigned long long)inode->i_ino);\n\tspin_unlock(&dentry->d_lock);\n\tspin_unlock(&dentry->d_parent->d_lock);\n\td_instantiate(dentry, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_nid_done",
          "args": [
            "sbi",
            "inode->i_ino"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_nid_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1582-1594",
          "snippet": "void alloc_nid_done(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\n\tspin_lock(&nm_i->free_nid_list_lock);\n\ti = __lookup_free_nid_list(nm_i, nid);\n\tf2fs_bug_on(sbi, !i || i->state != NID_ALLOC);\n\t__del_from_free_nid_list(nm_i, i);\n\tspin_unlock(&nm_i->free_nid_list_lock);\n\n\tkmem_cache_free(free_nid_slab, i);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *free_nid_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *free_nid_slab;\n\nvoid alloc_nid_done(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\n\tspin_lock(&nm_i->free_nid_list_lock);\n\ti = __lookup_free_nid_list(nm_i, nid);\n\tf2fs_bug_on(sbi, !i || i->state != NID_ALLOC);\n\t__del_from_free_nid_list(nm_i, i);\n\tspin_unlock(&nm_i->free_nid_list_lock);\n\n\tkmem_cache_free(free_nid_slab, i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_unlock_op",
          "args": [
            "sbi"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_unlock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "760-763",
          "snippet": "static inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_orphan_inode",
          "args": [
            "sbi",
            "inode->i_ino"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "add_orphan_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "443-447",
          "snippet": "void add_orphan_inode(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\t/* add new orphan ino entry into list */\n\t__add_ino_entry(sbi, ino, ORPHAN_INO);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nvoid add_orphan_inode(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\t/* add new orphan ino entry into list */\n\t__add_ino_entry(sbi, ino, ORPHAN_INO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_do_tmpfile",
          "args": [
            "inode",
            "dir"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_do_tmpfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "584-603",
          "snippet": "int f2fs_do_tmpfile(struct inode *inode, struct inode *dir)\n{\n\tstruct page *page;\n\tint err = 0;\n\n\tdown_write(&F2FS_I(inode)->i_sem);\n\tpage = init_inode_metadata(inode, dir, NULL, NULL);\n\tif (IS_ERR(page)) {\n\t\terr = PTR_ERR(page);\n\t\tgoto fail;\n\t}\n\t/* we don't need to mark_inode_dirty now */\n\tupdate_inode(inode, page);\n\tf2fs_put_page(page, 1);\n\n\tclear_inode_flag(F2FS_I(inode), FI_NEW_INODE);\nfail:\n\tup_write(&F2FS_I(inode)->i_sem);\n\treturn err;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint f2fs_do_tmpfile(struct inode *inode, struct inode *dir)\n{\n\tstruct page *page;\n\tint err = 0;\n\n\tdown_write(&F2FS_I(inode)->i_sem);\n\tpage = init_inode_metadata(inode, dir, NULL, NULL);\n\tif (IS_ERR(page)) {\n\t\terr = PTR_ERR(page);\n\t\tgoto fail;\n\t}\n\t/* we don't need to mark_inode_dirty now */\n\tupdate_inode(inode, page);\n\tf2fs_put_page(page, 1);\n\n\tclear_inode_flag(F2FS_I(inode), FI_NEW_INODE);\nfail:\n\tup_write(&F2FS_I(inode)->i_sem);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "acquire_orphan_inode",
          "args": [
            "sbi"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "acquire_orphan_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "418-431",
          "snippet": "int acquire_orphan_inode(struct f2fs_sb_info *sbi)\n{\n\tstruct inode_management *im = &sbi->im[ORPHAN_INO];\n\tint err = 0;\n\n\tspin_lock(&im->ino_lock);\n\tif (unlikely(im->ino_num >= sbi->max_orphans))\n\t\terr = -ENOSPC;\n\telse\n\t\tim->ino_num++;\n\tspin_unlock(&im->ino_lock);\n\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nint acquire_orphan_inode(struct f2fs_sb_info *sbi)\n{\n\tstruct inode_management *im = &sbi->im[ORPHAN_INO];\n\tint err = 0;\n\n\tspin_lock(&im->ino_lock);\n\tif (unlikely(im->ino_num >= sbi->max_orphans))\n\t\terr = -ENOSPC;\n\telse\n\t\tim->ino_num++;\n\tspin_unlock(&im->ino_lock);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_lock_op",
          "args": [
            "sbi"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_lock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "755-758",
          "snippet": "static inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tdown_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tdown_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_new_inode",
          "args": [
            "dir",
            "mode"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/namei.c",
          "lines": "24-77",
          "snippet": "static struct inode *f2fs_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tnid_t ino;\n\tstruct inode *inode;\n\tbool nid_free = false;\n\tint err;\n\n\tinode = new_inode(dir->i_sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tf2fs_lock_op(sbi);\n\tif (!alloc_nid(sbi, &ino)) {\n\t\tf2fs_unlock_op(sbi);\n\t\terr = -ENOSPC;\n\t\tgoto fail;\n\t}\n\tf2fs_unlock_op(sbi);\n\n\tinode_init_owner(inode, dir, mode);\n\n\tinode->i_ino = ino;\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_generation = sbi->s_next_generation++;\n\n\terr = insert_inode_locked(inode);\n\tif (err) {\n\t\terr = -EINVAL;\n\t\tnid_free = true;\n\t\tgoto out;\n\t}\n\n\tif (f2fs_may_inline(inode))\n\t\tset_inode_flag(F2FS_I(inode), FI_INLINE_DATA);\n\tif (test_opt(sbi, INLINE_DENTRY) && S_ISDIR(inode->i_mode))\n\t\tset_inode_flag(F2FS_I(inode), FI_INLINE_DENTRY);\n\n\ttrace_f2fs_new_inode(inode, 0);\n\tmark_inode_dirty(inode);\n\treturn inode;\n\nout:\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\nfail:\n\ttrace_f2fs_new_inode(inode, err);\n\tmake_bad_inode(inode);\n\tiput(inode);\n\tif (nid_free)\n\t\talloc_nid_failed(sbi, ino);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/dcache.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct inode *f2fs_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tnid_t ino;\n\tstruct inode *inode;\n\tbool nid_free = false;\n\tint err;\n\n\tinode = new_inode(dir->i_sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tf2fs_lock_op(sbi);\n\tif (!alloc_nid(sbi, &ino)) {\n\t\tf2fs_unlock_op(sbi);\n\t\terr = -ENOSPC;\n\t\tgoto fail;\n\t}\n\tf2fs_unlock_op(sbi);\n\n\tinode_init_owner(inode, dir, mode);\n\n\tinode->i_ino = ino;\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_generation = sbi->s_next_generation++;\n\n\terr = insert_inode_locked(inode);\n\tif (err) {\n\t\terr = -EINVAL;\n\t\tnid_free = true;\n\t\tgoto out;\n\t}\n\n\tif (f2fs_may_inline(inode))\n\t\tset_inode_flag(F2FS_I(inode), FI_INLINE_DATA);\n\tif (test_opt(sbi, INLINE_DENTRY) && S_ISDIR(inode->i_mode))\n\t\tset_inode_flag(F2FS_I(inode), FI_INLINE_DENTRY);\n\n\ttrace_f2fs_new_inode(inode, 0);\n\tmark_inode_dirty(inode);\n\treturn inode;\n\nout:\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\nfail:\n\ttrace_f2fs_new_inode(inode, err);\n\tmake_bad_inode(inode);\n\tiput(inode);\n\tif (nid_free)\n\t\talloc_nid_failed(sbi, ino);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "dir"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int f2fs_tmpfile(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tstruct inode *inode;\n\tint err;\n\n\tinode = f2fs_new_inode(dir, mode);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tinode->i_op = &f2fs_file_inode_operations;\n\tinode->i_fop = &f2fs_file_operations;\n\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\n\tf2fs_lock_op(sbi);\n\terr = acquire_orphan_inode(sbi);\n\tif (err)\n\t\tgoto out;\n\n\terr = f2fs_do_tmpfile(inode, dir);\n\tif (err)\n\t\tgoto release_out;\n\n\t/*\n\t * add this non-linked tmpfile to orphan list, in this way we could\n\t * remove all unused data of tmpfile after abnormal power-off.\n\t */\n\tadd_orphan_inode(sbi, inode->i_ino);\n\tf2fs_unlock_op(sbi);\n\n\talloc_nid_done(sbi, inode->i_ino);\n\td_tmpfile(dentry, inode);\n\tunlock_new_inode(inode);\n\treturn 0;\n\nrelease_out:\n\trelease_orphan_inode(sbi);\nout:\n\thandle_failed_inode(inode);\n\treturn err;\n}"
  },
  {
    "function_name": "f2fs_rename2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/namei.c",
    "lines": "647-663",
    "snippet": "static int f2fs_rename2(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\tstruct inode *new_dir, struct dentry *new_dentry,\n\t\t\tunsigned int flags)\n{\n\tif (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE))\n\t\treturn -EINVAL;\n\n\tif (flags & RENAME_EXCHANGE) {\n\t\treturn f2fs_cross_rename(old_dir, old_dentry,\n\t\t\t\t\t new_dir, new_dentry);\n\t}\n\t/*\n\t * VFS has already handled the new dentry existence case,\n\t * here, we just deal with \"RENAME_NOREPLACE\" as regular rename.\n\t */\n\treturn f2fs_rename(old_dir, old_dentry, new_dir, new_dentry);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/dcache.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_rename",
          "args": [
            "old_dir",
            "old_dentry",
            "new_dir",
            "new_dentry"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/namei.c",
          "lines": "373-498",
          "snippet": "static int f2fs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\tstruct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(old_dir);\n\tstruct inode *old_inode = old_dentry->d_inode;\n\tstruct inode *new_inode = new_dentry->d_inode;\n\tstruct page *old_dir_page;\n\tstruct page *old_page, *new_page;\n\tstruct f2fs_dir_entry *old_dir_entry = NULL;\n\tstruct f2fs_dir_entry *old_entry;\n\tstruct f2fs_dir_entry *new_entry;\n\tint err = -ENOENT;\n\n\tf2fs_balance_fs(sbi);\n\n\told_entry = f2fs_find_entry(old_dir, &old_dentry->d_name, &old_page);\n\tif (!old_entry)\n\t\tgoto out;\n\n\tif (S_ISDIR(old_inode->i_mode)) {\n\t\terr = -EIO;\n\t\told_dir_entry = f2fs_parent_dir(old_inode, &old_dir_page);\n\t\tif (!old_dir_entry)\n\t\t\tgoto out_old;\n\t}\n\n\tif (new_inode) {\n\n\t\terr = -ENOTEMPTY;\n\t\tif (old_dir_entry && !f2fs_empty_dir(new_inode))\n\t\t\tgoto out_dir;\n\n\t\terr = -ENOENT;\n\t\tnew_entry = f2fs_find_entry(new_dir, &new_dentry->d_name,\n\t\t\t\t\t\t&new_page);\n\t\tif (!new_entry)\n\t\t\tgoto out_dir;\n\n\t\tf2fs_lock_op(sbi);\n\n\t\terr = acquire_orphan_inode(sbi);\n\t\tif (err)\n\t\t\tgoto put_out_dir;\n\n\t\tif (update_dent_inode(old_inode, &new_dentry->d_name)) {\n\t\t\trelease_orphan_inode(sbi);\n\t\t\tgoto put_out_dir;\n\t\t}\n\n\t\tf2fs_set_link(new_dir, new_entry, new_page, old_inode);\n\n\t\tnew_inode->i_ctime = CURRENT_TIME;\n\t\tdown_write(&F2FS_I(new_inode)->i_sem);\n\t\tif (old_dir_entry)\n\t\t\tdrop_nlink(new_inode);\n\t\tdrop_nlink(new_inode);\n\t\tup_write(&F2FS_I(new_inode)->i_sem);\n\n\t\tmark_inode_dirty(new_inode);\n\n\t\tif (!new_inode->i_nlink)\n\t\t\tadd_orphan_inode(sbi, new_inode->i_ino);\n\t\telse\n\t\t\trelease_orphan_inode(sbi);\n\n\t\tupdate_inode_page(old_inode);\n\t\tupdate_inode_page(new_inode);\n\t} else {\n\t\tf2fs_lock_op(sbi);\n\n\t\terr = f2fs_add_link(new_dentry, old_inode);\n\t\tif (err) {\n\t\t\tf2fs_unlock_op(sbi);\n\t\t\tgoto out_dir;\n\t\t}\n\n\t\tif (old_dir_entry) {\n\t\t\tinc_nlink(new_dir);\n\t\t\tupdate_inode_page(new_dir);\n\t\t}\n\t}\n\n\tdown_write(&F2FS_I(old_inode)->i_sem);\n\tfile_lost_pino(old_inode);\n\tup_write(&F2FS_I(old_inode)->i_sem);\n\n\told_inode->i_ctime = CURRENT_TIME;\n\tmark_inode_dirty(old_inode);\n\n\tf2fs_delete_entry(old_entry, old_page, old_dir, NULL);\n\n\tif (old_dir_entry) {\n\t\tif (old_dir != new_dir) {\n\t\t\tf2fs_set_link(old_inode, old_dir_entry,\n\t\t\t\t\t\told_dir_page, new_dir);\n\t\t\tupdate_inode_page(old_inode);\n\t\t} else {\n\t\t\tf2fs_dentry_kunmap(old_inode, old_dir_page);\n\t\t\tf2fs_put_page(old_dir_page, 0);\n\t\t}\n\t\tdrop_nlink(old_dir);\n\t\tmark_inode_dirty(old_dir);\n\t\tupdate_inode_page(old_dir);\n\t}\n\n\tf2fs_unlock_op(sbi);\n\n\tif (IS_DIRSYNC(old_dir) || IS_DIRSYNC(new_dir))\n\t\tf2fs_sync_fs(sbi->sb, 1);\n\treturn 0;\n\nput_out_dir:\n\tf2fs_unlock_op(sbi);\n\tf2fs_dentry_kunmap(new_dir, new_page);\n\tf2fs_put_page(new_page, 0);\nout_dir:\n\tif (old_dir_entry) {\n\t\tf2fs_dentry_kunmap(old_inode, old_dir_page);\n\t\tf2fs_put_page(old_dir_page, 0);\n\t}\nout_old:\n\tf2fs_dentry_kunmap(old_dir, old_page);\n\tf2fs_put_page(old_page, 0);\nout:\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/dcache.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int f2fs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\tstruct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(old_dir);\n\tstruct inode *old_inode = old_dentry->d_inode;\n\tstruct inode *new_inode = new_dentry->d_inode;\n\tstruct page *old_dir_page;\n\tstruct page *old_page, *new_page;\n\tstruct f2fs_dir_entry *old_dir_entry = NULL;\n\tstruct f2fs_dir_entry *old_entry;\n\tstruct f2fs_dir_entry *new_entry;\n\tint err = -ENOENT;\n\n\tf2fs_balance_fs(sbi);\n\n\told_entry = f2fs_find_entry(old_dir, &old_dentry->d_name, &old_page);\n\tif (!old_entry)\n\t\tgoto out;\n\n\tif (S_ISDIR(old_inode->i_mode)) {\n\t\terr = -EIO;\n\t\told_dir_entry = f2fs_parent_dir(old_inode, &old_dir_page);\n\t\tif (!old_dir_entry)\n\t\t\tgoto out_old;\n\t}\n\n\tif (new_inode) {\n\n\t\terr = -ENOTEMPTY;\n\t\tif (old_dir_entry && !f2fs_empty_dir(new_inode))\n\t\t\tgoto out_dir;\n\n\t\terr = -ENOENT;\n\t\tnew_entry = f2fs_find_entry(new_dir, &new_dentry->d_name,\n\t\t\t\t\t\t&new_page);\n\t\tif (!new_entry)\n\t\t\tgoto out_dir;\n\n\t\tf2fs_lock_op(sbi);\n\n\t\terr = acquire_orphan_inode(sbi);\n\t\tif (err)\n\t\t\tgoto put_out_dir;\n\n\t\tif (update_dent_inode(old_inode, &new_dentry->d_name)) {\n\t\t\trelease_orphan_inode(sbi);\n\t\t\tgoto put_out_dir;\n\t\t}\n\n\t\tf2fs_set_link(new_dir, new_entry, new_page, old_inode);\n\n\t\tnew_inode->i_ctime = CURRENT_TIME;\n\t\tdown_write(&F2FS_I(new_inode)->i_sem);\n\t\tif (old_dir_entry)\n\t\t\tdrop_nlink(new_inode);\n\t\tdrop_nlink(new_inode);\n\t\tup_write(&F2FS_I(new_inode)->i_sem);\n\n\t\tmark_inode_dirty(new_inode);\n\n\t\tif (!new_inode->i_nlink)\n\t\t\tadd_orphan_inode(sbi, new_inode->i_ino);\n\t\telse\n\t\t\trelease_orphan_inode(sbi);\n\n\t\tupdate_inode_page(old_inode);\n\t\tupdate_inode_page(new_inode);\n\t} else {\n\t\tf2fs_lock_op(sbi);\n\n\t\terr = f2fs_add_link(new_dentry, old_inode);\n\t\tif (err) {\n\t\t\tf2fs_unlock_op(sbi);\n\t\t\tgoto out_dir;\n\t\t}\n\n\t\tif (old_dir_entry) {\n\t\t\tinc_nlink(new_dir);\n\t\t\tupdate_inode_page(new_dir);\n\t\t}\n\t}\n\n\tdown_write(&F2FS_I(old_inode)->i_sem);\n\tfile_lost_pino(old_inode);\n\tup_write(&F2FS_I(old_inode)->i_sem);\n\n\told_inode->i_ctime = CURRENT_TIME;\n\tmark_inode_dirty(old_inode);\n\n\tf2fs_delete_entry(old_entry, old_page, old_dir, NULL);\n\n\tif (old_dir_entry) {\n\t\tif (old_dir != new_dir) {\n\t\t\tf2fs_set_link(old_inode, old_dir_entry,\n\t\t\t\t\t\told_dir_page, new_dir);\n\t\t\tupdate_inode_page(old_inode);\n\t\t} else {\n\t\t\tf2fs_dentry_kunmap(old_inode, old_dir_page);\n\t\t\tf2fs_put_page(old_dir_page, 0);\n\t\t}\n\t\tdrop_nlink(old_dir);\n\t\tmark_inode_dirty(old_dir);\n\t\tupdate_inode_page(old_dir);\n\t}\n\n\tf2fs_unlock_op(sbi);\n\n\tif (IS_DIRSYNC(old_dir) || IS_DIRSYNC(new_dir))\n\t\tf2fs_sync_fs(sbi->sb, 1);\n\treturn 0;\n\nput_out_dir:\n\tf2fs_unlock_op(sbi);\n\tf2fs_dentry_kunmap(new_dir, new_page);\n\tf2fs_put_page(new_page, 0);\nout_dir:\n\tif (old_dir_entry) {\n\t\tf2fs_dentry_kunmap(old_inode, old_dir_page);\n\t\tf2fs_put_page(old_dir_page, 0);\n\t}\nout_old:\n\tf2fs_dentry_kunmap(old_dir, old_page);\n\tf2fs_put_page(old_page, 0);\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_cross_rename",
          "args": [
            "old_dir",
            "old_dentry",
            "new_dir",
            "new_dentry"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_cross_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/namei.c",
          "lines": "500-645",
          "snippet": "static int f2fs_cross_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\t     struct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(old_dir);\n\tstruct inode *old_inode = old_dentry->d_inode;\n\tstruct inode *new_inode = new_dentry->d_inode;\n\tstruct page *old_dir_page, *new_dir_page;\n\tstruct page *old_page, *new_page;\n\tstruct f2fs_dir_entry *old_dir_entry = NULL, *new_dir_entry = NULL;\n\tstruct f2fs_dir_entry *old_entry, *new_entry;\n\tint old_nlink = 0, new_nlink = 0;\n\tint err = -ENOENT;\n\n\tf2fs_balance_fs(sbi);\n\n\told_entry = f2fs_find_entry(old_dir, &old_dentry->d_name, &old_page);\n\tif (!old_entry)\n\t\tgoto out;\n\n\tnew_entry = f2fs_find_entry(new_dir, &new_dentry->d_name, &new_page);\n\tif (!new_entry)\n\t\tgoto out_old;\n\n\t/* prepare for updating \"..\" directory entry info later */\n\tif (old_dir != new_dir) {\n\t\tif (S_ISDIR(old_inode->i_mode)) {\n\t\t\terr = -EIO;\n\t\t\told_dir_entry = f2fs_parent_dir(old_inode,\n\t\t\t\t\t\t\t&old_dir_page);\n\t\t\tif (!old_dir_entry)\n\t\t\t\tgoto out_new;\n\t\t}\n\n\t\tif (S_ISDIR(new_inode->i_mode)) {\n\t\t\terr = -EIO;\n\t\t\tnew_dir_entry = f2fs_parent_dir(new_inode,\n\t\t\t\t\t\t\t&new_dir_page);\n\t\t\tif (!new_dir_entry)\n\t\t\t\tgoto out_old_dir;\n\t\t}\n\t}\n\n\t/*\n\t * If cross rename between file and directory those are not\n\t * in the same directory, we will inc nlink of file's parent\n\t * later, so we should check upper boundary of its nlink.\n\t */\n\tif ((!old_dir_entry || !new_dir_entry) &&\n\t\t\t\told_dir_entry != new_dir_entry) {\n\t\told_nlink = old_dir_entry ? -1 : 1;\n\t\tnew_nlink = -old_nlink;\n\t\terr = -EMLINK;\n\t\tif ((old_nlink > 0 && old_inode->i_nlink >= F2FS_LINK_MAX) ||\n\t\t\t(new_nlink > 0 && new_inode->i_nlink >= F2FS_LINK_MAX))\n\t\t\tgoto out_new_dir;\n\t}\n\n\tf2fs_lock_op(sbi);\n\n\terr = update_dent_inode(old_inode, &new_dentry->d_name);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = update_dent_inode(new_inode, &old_dentry->d_name);\n\tif (err)\n\t\tgoto out_undo;\n\n\t/* update \"..\" directory entry info of old dentry */\n\tif (old_dir_entry)\n\t\tf2fs_set_link(old_inode, old_dir_entry, old_dir_page, new_dir);\n\n\t/* update \"..\" directory entry info of new dentry */\n\tif (new_dir_entry)\n\t\tf2fs_set_link(new_inode, new_dir_entry, new_dir_page, old_dir);\n\n\t/* update directory entry info of old dir inode */\n\tf2fs_set_link(old_dir, old_entry, old_page, new_inode);\n\n\tdown_write(&F2FS_I(old_inode)->i_sem);\n\tfile_lost_pino(old_inode);\n\tup_write(&F2FS_I(old_inode)->i_sem);\n\n\tupdate_inode_page(old_inode);\n\n\told_dir->i_ctime = CURRENT_TIME;\n\tif (old_nlink) {\n\t\tdown_write(&F2FS_I(old_dir)->i_sem);\n\t\tif (old_nlink < 0)\n\t\t\tdrop_nlink(old_dir);\n\t\telse\n\t\t\tinc_nlink(old_dir);\n\t\tup_write(&F2FS_I(old_dir)->i_sem);\n\t}\n\tmark_inode_dirty(old_dir);\n\tupdate_inode_page(old_dir);\n\n\t/* update directory entry info of new dir inode */\n\tf2fs_set_link(new_dir, new_entry, new_page, old_inode);\n\n\tdown_write(&F2FS_I(new_inode)->i_sem);\n\tfile_lost_pino(new_inode);\n\tup_write(&F2FS_I(new_inode)->i_sem);\n\n\tupdate_inode_page(new_inode);\n\n\tnew_dir->i_ctime = CURRENT_TIME;\n\tif (new_nlink) {\n\t\tdown_write(&F2FS_I(new_dir)->i_sem);\n\t\tif (new_nlink < 0)\n\t\t\tdrop_nlink(new_dir);\n\t\telse\n\t\t\tinc_nlink(new_dir);\n\t\tup_write(&F2FS_I(new_dir)->i_sem);\n\t}\n\tmark_inode_dirty(new_dir);\n\tupdate_inode_page(new_dir);\n\n\tf2fs_unlock_op(sbi);\n\n\tif (IS_DIRSYNC(old_dir) || IS_DIRSYNC(new_dir))\n\t\tf2fs_sync_fs(sbi->sb, 1);\n\treturn 0;\nout_undo:\n\t/* Still we may fail to recover name info of f2fs_inode here */\n\tupdate_dent_inode(old_inode, &old_dentry->d_name);\nout_unlock:\n\tf2fs_unlock_op(sbi);\nout_new_dir:\n\tif (new_dir_entry) {\n\t\tf2fs_dentry_kunmap(new_inode, new_dir_page);\n\t\tf2fs_put_page(new_dir_page, 0);\n\t}\nout_old_dir:\n\tif (old_dir_entry) {\n\t\tf2fs_dentry_kunmap(old_inode, old_dir_page);\n\t\tf2fs_put_page(old_dir_page, 0);\n\t}\nout_new:\n\tf2fs_dentry_kunmap(new_dir, new_page);\n\tf2fs_put_page(new_page, 0);\nout_old:\n\tf2fs_dentry_kunmap(old_dir, old_page);\n\tf2fs_put_page(old_page, 0);\nout:\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/dcache.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int f2fs_cross_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\t     struct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(old_dir);\n\tstruct inode *old_inode = old_dentry->d_inode;\n\tstruct inode *new_inode = new_dentry->d_inode;\n\tstruct page *old_dir_page, *new_dir_page;\n\tstruct page *old_page, *new_page;\n\tstruct f2fs_dir_entry *old_dir_entry = NULL, *new_dir_entry = NULL;\n\tstruct f2fs_dir_entry *old_entry, *new_entry;\n\tint old_nlink = 0, new_nlink = 0;\n\tint err = -ENOENT;\n\n\tf2fs_balance_fs(sbi);\n\n\told_entry = f2fs_find_entry(old_dir, &old_dentry->d_name, &old_page);\n\tif (!old_entry)\n\t\tgoto out;\n\n\tnew_entry = f2fs_find_entry(new_dir, &new_dentry->d_name, &new_page);\n\tif (!new_entry)\n\t\tgoto out_old;\n\n\t/* prepare for updating \"..\" directory entry info later */\n\tif (old_dir != new_dir) {\n\t\tif (S_ISDIR(old_inode->i_mode)) {\n\t\t\terr = -EIO;\n\t\t\told_dir_entry = f2fs_parent_dir(old_inode,\n\t\t\t\t\t\t\t&old_dir_page);\n\t\t\tif (!old_dir_entry)\n\t\t\t\tgoto out_new;\n\t\t}\n\n\t\tif (S_ISDIR(new_inode->i_mode)) {\n\t\t\terr = -EIO;\n\t\t\tnew_dir_entry = f2fs_parent_dir(new_inode,\n\t\t\t\t\t\t\t&new_dir_page);\n\t\t\tif (!new_dir_entry)\n\t\t\t\tgoto out_old_dir;\n\t\t}\n\t}\n\n\t/*\n\t * If cross rename between file and directory those are not\n\t * in the same directory, we will inc nlink of file's parent\n\t * later, so we should check upper boundary of its nlink.\n\t */\n\tif ((!old_dir_entry || !new_dir_entry) &&\n\t\t\t\told_dir_entry != new_dir_entry) {\n\t\told_nlink = old_dir_entry ? -1 : 1;\n\t\tnew_nlink = -old_nlink;\n\t\terr = -EMLINK;\n\t\tif ((old_nlink > 0 && old_inode->i_nlink >= F2FS_LINK_MAX) ||\n\t\t\t(new_nlink > 0 && new_inode->i_nlink >= F2FS_LINK_MAX))\n\t\t\tgoto out_new_dir;\n\t}\n\n\tf2fs_lock_op(sbi);\n\n\terr = update_dent_inode(old_inode, &new_dentry->d_name);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = update_dent_inode(new_inode, &old_dentry->d_name);\n\tif (err)\n\t\tgoto out_undo;\n\n\t/* update \"..\" directory entry info of old dentry */\n\tif (old_dir_entry)\n\t\tf2fs_set_link(old_inode, old_dir_entry, old_dir_page, new_dir);\n\n\t/* update \"..\" directory entry info of new dentry */\n\tif (new_dir_entry)\n\t\tf2fs_set_link(new_inode, new_dir_entry, new_dir_page, old_dir);\n\n\t/* update directory entry info of old dir inode */\n\tf2fs_set_link(old_dir, old_entry, old_page, new_inode);\n\n\tdown_write(&F2FS_I(old_inode)->i_sem);\n\tfile_lost_pino(old_inode);\n\tup_write(&F2FS_I(old_inode)->i_sem);\n\n\tupdate_inode_page(old_inode);\n\n\told_dir->i_ctime = CURRENT_TIME;\n\tif (old_nlink) {\n\t\tdown_write(&F2FS_I(old_dir)->i_sem);\n\t\tif (old_nlink < 0)\n\t\t\tdrop_nlink(old_dir);\n\t\telse\n\t\t\tinc_nlink(old_dir);\n\t\tup_write(&F2FS_I(old_dir)->i_sem);\n\t}\n\tmark_inode_dirty(old_dir);\n\tupdate_inode_page(old_dir);\n\n\t/* update directory entry info of new dir inode */\n\tf2fs_set_link(new_dir, new_entry, new_page, old_inode);\n\n\tdown_write(&F2FS_I(new_inode)->i_sem);\n\tfile_lost_pino(new_inode);\n\tup_write(&F2FS_I(new_inode)->i_sem);\n\n\tupdate_inode_page(new_inode);\n\n\tnew_dir->i_ctime = CURRENT_TIME;\n\tif (new_nlink) {\n\t\tdown_write(&F2FS_I(new_dir)->i_sem);\n\t\tif (new_nlink < 0)\n\t\t\tdrop_nlink(new_dir);\n\t\telse\n\t\t\tinc_nlink(new_dir);\n\t\tup_write(&F2FS_I(new_dir)->i_sem);\n\t}\n\tmark_inode_dirty(new_dir);\n\tupdate_inode_page(new_dir);\n\n\tf2fs_unlock_op(sbi);\n\n\tif (IS_DIRSYNC(old_dir) || IS_DIRSYNC(new_dir))\n\t\tf2fs_sync_fs(sbi->sb, 1);\n\treturn 0;\nout_undo:\n\t/* Still we may fail to recover name info of f2fs_inode here */\n\tupdate_dent_inode(old_inode, &old_dentry->d_name);\nout_unlock:\n\tf2fs_unlock_op(sbi);\nout_new_dir:\n\tif (new_dir_entry) {\n\t\tf2fs_dentry_kunmap(new_inode, new_dir_page);\n\t\tf2fs_put_page(new_dir_page, 0);\n\t}\nout_old_dir:\n\tif (old_dir_entry) {\n\t\tf2fs_dentry_kunmap(old_inode, old_dir_page);\n\t\tf2fs_put_page(old_dir_page, 0);\n\t}\nout_new:\n\tf2fs_dentry_kunmap(new_dir, new_page);\n\tf2fs_put_page(new_page, 0);\nout_old:\n\tf2fs_dentry_kunmap(old_dir, old_page);\n\tf2fs_put_page(old_page, 0);\nout:\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int f2fs_rename2(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\tstruct inode *new_dir, struct dentry *new_dentry,\n\t\t\tunsigned int flags)\n{\n\tif (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE))\n\t\treturn -EINVAL;\n\n\tif (flags & RENAME_EXCHANGE) {\n\t\treturn f2fs_cross_rename(old_dir, old_dentry,\n\t\t\t\t\t new_dir, new_dentry);\n\t}\n\t/*\n\t * VFS has already handled the new dentry existence case,\n\t * here, we just deal with \"RENAME_NOREPLACE\" as regular rename.\n\t */\n\treturn f2fs_rename(old_dir, old_dentry, new_dir, new_dentry);\n}"
  },
  {
    "function_name": "f2fs_cross_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/namei.c",
    "lines": "500-645",
    "snippet": "static int f2fs_cross_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\t     struct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(old_dir);\n\tstruct inode *old_inode = old_dentry->d_inode;\n\tstruct inode *new_inode = new_dentry->d_inode;\n\tstruct page *old_dir_page, *new_dir_page;\n\tstruct page *old_page, *new_page;\n\tstruct f2fs_dir_entry *old_dir_entry = NULL, *new_dir_entry = NULL;\n\tstruct f2fs_dir_entry *old_entry, *new_entry;\n\tint old_nlink = 0, new_nlink = 0;\n\tint err = -ENOENT;\n\n\tf2fs_balance_fs(sbi);\n\n\told_entry = f2fs_find_entry(old_dir, &old_dentry->d_name, &old_page);\n\tif (!old_entry)\n\t\tgoto out;\n\n\tnew_entry = f2fs_find_entry(new_dir, &new_dentry->d_name, &new_page);\n\tif (!new_entry)\n\t\tgoto out_old;\n\n\t/* prepare for updating \"..\" directory entry info later */\n\tif (old_dir != new_dir) {\n\t\tif (S_ISDIR(old_inode->i_mode)) {\n\t\t\terr = -EIO;\n\t\t\told_dir_entry = f2fs_parent_dir(old_inode,\n\t\t\t\t\t\t\t&old_dir_page);\n\t\t\tif (!old_dir_entry)\n\t\t\t\tgoto out_new;\n\t\t}\n\n\t\tif (S_ISDIR(new_inode->i_mode)) {\n\t\t\terr = -EIO;\n\t\t\tnew_dir_entry = f2fs_parent_dir(new_inode,\n\t\t\t\t\t\t\t&new_dir_page);\n\t\t\tif (!new_dir_entry)\n\t\t\t\tgoto out_old_dir;\n\t\t}\n\t}\n\n\t/*\n\t * If cross rename between file and directory those are not\n\t * in the same directory, we will inc nlink of file's parent\n\t * later, so we should check upper boundary of its nlink.\n\t */\n\tif ((!old_dir_entry || !new_dir_entry) &&\n\t\t\t\told_dir_entry != new_dir_entry) {\n\t\told_nlink = old_dir_entry ? -1 : 1;\n\t\tnew_nlink = -old_nlink;\n\t\terr = -EMLINK;\n\t\tif ((old_nlink > 0 && old_inode->i_nlink >= F2FS_LINK_MAX) ||\n\t\t\t(new_nlink > 0 && new_inode->i_nlink >= F2FS_LINK_MAX))\n\t\t\tgoto out_new_dir;\n\t}\n\n\tf2fs_lock_op(sbi);\n\n\terr = update_dent_inode(old_inode, &new_dentry->d_name);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = update_dent_inode(new_inode, &old_dentry->d_name);\n\tif (err)\n\t\tgoto out_undo;\n\n\t/* update \"..\" directory entry info of old dentry */\n\tif (old_dir_entry)\n\t\tf2fs_set_link(old_inode, old_dir_entry, old_dir_page, new_dir);\n\n\t/* update \"..\" directory entry info of new dentry */\n\tif (new_dir_entry)\n\t\tf2fs_set_link(new_inode, new_dir_entry, new_dir_page, old_dir);\n\n\t/* update directory entry info of old dir inode */\n\tf2fs_set_link(old_dir, old_entry, old_page, new_inode);\n\n\tdown_write(&F2FS_I(old_inode)->i_sem);\n\tfile_lost_pino(old_inode);\n\tup_write(&F2FS_I(old_inode)->i_sem);\n\n\tupdate_inode_page(old_inode);\n\n\told_dir->i_ctime = CURRENT_TIME;\n\tif (old_nlink) {\n\t\tdown_write(&F2FS_I(old_dir)->i_sem);\n\t\tif (old_nlink < 0)\n\t\t\tdrop_nlink(old_dir);\n\t\telse\n\t\t\tinc_nlink(old_dir);\n\t\tup_write(&F2FS_I(old_dir)->i_sem);\n\t}\n\tmark_inode_dirty(old_dir);\n\tupdate_inode_page(old_dir);\n\n\t/* update directory entry info of new dir inode */\n\tf2fs_set_link(new_dir, new_entry, new_page, old_inode);\n\n\tdown_write(&F2FS_I(new_inode)->i_sem);\n\tfile_lost_pino(new_inode);\n\tup_write(&F2FS_I(new_inode)->i_sem);\n\n\tupdate_inode_page(new_inode);\n\n\tnew_dir->i_ctime = CURRENT_TIME;\n\tif (new_nlink) {\n\t\tdown_write(&F2FS_I(new_dir)->i_sem);\n\t\tif (new_nlink < 0)\n\t\t\tdrop_nlink(new_dir);\n\t\telse\n\t\t\tinc_nlink(new_dir);\n\t\tup_write(&F2FS_I(new_dir)->i_sem);\n\t}\n\tmark_inode_dirty(new_dir);\n\tupdate_inode_page(new_dir);\n\n\tf2fs_unlock_op(sbi);\n\n\tif (IS_DIRSYNC(old_dir) || IS_DIRSYNC(new_dir))\n\t\tf2fs_sync_fs(sbi->sb, 1);\n\treturn 0;\nout_undo:\n\t/* Still we may fail to recover name info of f2fs_inode here */\n\tupdate_dent_inode(old_inode, &old_dentry->d_name);\nout_unlock:\n\tf2fs_unlock_op(sbi);\nout_new_dir:\n\tif (new_dir_entry) {\n\t\tf2fs_dentry_kunmap(new_inode, new_dir_page);\n\t\tf2fs_put_page(new_dir_page, 0);\n\t}\nout_old_dir:\n\tif (old_dir_entry) {\n\t\tf2fs_dentry_kunmap(old_inode, old_dir_page);\n\t\tf2fs_put_page(old_dir_page, 0);\n\t}\nout_new:\n\tf2fs_dentry_kunmap(new_dir, new_page);\n\tf2fs_put_page(new_page, 0);\nout_old:\n\tf2fs_dentry_kunmap(old_dir, old_page);\n\tf2fs_put_page(old_page, 0);\nout:\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/dcache.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "old_page",
            "0"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_dentry_kunmap",
          "args": [
            "old_dir",
            "old_page"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_dentry_kunmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1299-1303",
          "snippet": "static inline void f2fs_dentry_kunmap(struct inode *dir, struct page *page)\n{\n\tif (!f2fs_has_inline_dentry(dir))\n\t\tkunmap(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_dentry_kunmap(struct inode *dir, struct page *page)\n{\n\tif (!f2fs_has_inline_dentry(dir))\n\t\tkunmap(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_unlock_op",
          "args": [
            "sbi"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_unlock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "760-763",
          "snippet": "static inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_dent_inode",
          "args": [
            "old_inode",
            "&old_dentry->d_name"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "update_dent_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "310-322",
          "snippet": "int update_dent_inode(struct inode *inode, const struct qstr *name)\n{\n\tstruct page *page;\n\n\tpage = get_node_page(F2FS_I_SB(inode), inode->i_ino);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\n\tinit_dent_inode(name, page);\n\tf2fs_put_page(page, 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint update_dent_inode(struct inode *inode, const struct qstr *name)\n{\n\tstruct page *page;\n\n\tpage = get_node_page(F2FS_I_SB(inode), inode->i_ino);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\n\tinit_dent_inode(name, page);\n\tf2fs_put_page(page, 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_sync_fs",
          "args": [
            "sbi->sb",
            "1"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_sync_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
          "lines": "496-516",
          "snippet": "int f2fs_sync_fs(struct super_block *sb, int sync)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\n\ttrace_f2fs_sync_fs(sb, sync);\n\n\tif (sync) {\n\t\tstruct cp_control cpc;\n\n\t\tcpc.reason = __get_cp_reason(sbi);\n\n\t\tmutex_lock(&sbi->gc_mutex);\n\t\twrite_checkpoint(sbi, &cpc);\n\t\tmutex_unlock(&sbi->gc_mutex);\n\t} else {\n\t\tf2fs_balance_fs(sbi);\n\t}\n\tf2fs_trace_ios(NULL, NULL, 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"gc.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/random.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/parser.h>",
            "#include <linux/kthread.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nint f2fs_sync_fs(struct super_block *sb, int sync)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\n\ttrace_f2fs_sync_fs(sb, sync);\n\n\tif (sync) {\n\t\tstruct cp_control cpc;\n\n\t\tcpc.reason = __get_cp_reason(sbi);\n\n\t\tmutex_lock(&sbi->gc_mutex);\n\t\twrite_checkpoint(sbi, &cpc);\n\t\tmutex_unlock(&sbi->gc_mutex);\n\t} else {\n\t\tf2fs_balance_fs(sbi);\n\t}\n\tf2fs_trace_ios(NULL, NULL, 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "new_dir"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "old_dir"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_inode_page",
          "args": [
            "new_dir"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "update_inode_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
          "lines": "246-264",
          "snippet": "void update_inode_page(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct page *node_page;\nretry:\n\tnode_page = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(node_page)) {\n\t\tint err = PTR_ERR(node_page);\n\t\tif (err == -ENOMEM) {\n\t\t\tcond_resched();\n\t\t\tgoto retry;\n\t\t} else if (err != -ENOENT) {\n\t\t\tf2fs_stop_checkpoint(sbi);\n\t\t}\n\t\treturn;\n\t}\n\tupdate_inode(inode, node_page);\n\tf2fs_put_page(node_page, 1);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid update_inode_page(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct page *node_page;\nretry:\n\tnode_page = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(node_page)) {\n\t\tint err = PTR_ERR(node_page);\n\t\tif (err == -ENOMEM) {\n\t\t\tcond_resched();\n\t\t\tgoto retry;\n\t\t} else if (err != -ENOENT) {\n\t\t\tf2fs_stop_checkpoint(sbi);\n\t\t}\n\t\treturn;\n\t}\n\tupdate_inode(inode, node_page);\n\tf2fs_put_page(node_page, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "new_dir"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&F2FS_I(new_dir)->i_sem"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "new_dir"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "new_dir"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "new_dir"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "271-277",
          "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&F2FS_I(new_dir)->i_sem"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&F2FS_I(new_inode)->i_sem"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_lost_pino",
          "args": [
            "new_inode"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&F2FS_I(new_inode)->i_sem"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_set_link",
          "args": [
            "new_dir",
            "new_entry",
            "new_page",
            "old_inode"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_set_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "281-295",
          "snippet": "void f2fs_set_link(struct inode *dir, struct f2fs_dir_entry *de,\n\t\tstruct page *page, struct inode *inode)\n{\n\tenum page_type type = f2fs_has_inline_dentry(dir) ? NODE : DATA;\n\tlock_page(page);\n\tf2fs_wait_on_page_writeback(page, type);\n\tde->ino = cpu_to_le32(inode->i_ino);\n\tset_de_type(de, inode);\n\tf2fs_dentry_kunmap(dir, page);\n\tset_page_dirty(page);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME;\n\tmark_inode_dirty(dir);\n\n\tf2fs_put_page(page, 1);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_set_link(struct inode *dir, struct f2fs_dir_entry *de,\n\t\tstruct page *page, struct inode *inode)\n{\n\tenum page_type type = f2fs_has_inline_dentry(dir) ? NODE : DATA;\n\tlock_page(page);\n\tf2fs_wait_on_page_writeback(page, type);\n\tde->ino = cpu_to_le32(inode->i_ino);\n\tset_de_type(de, inode);\n\tf2fs_dentry_kunmap(dir, page);\n\tset_page_dirty(page);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME;\n\tmark_inode_dirty(dir);\n\n\tf2fs_put_page(page, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&F2FS_I(old_dir)->i_sem"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&F2FS_I(old_dir)->i_sem"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&F2FS_I(old_inode)->i_sem"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_lost_pino",
          "args": [
            "old_inode"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&F2FS_I(old_inode)->i_sem"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_lock_op",
          "args": [
            "sbi"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_lock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "755-758",
          "snippet": "static inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tdown_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tdown_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_parent_dir",
          "args": [
            "new_inode",
            "&new_dir_page"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_parent_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "245-263",
          "snippet": "struct f2fs_dir_entry *f2fs_parent_dir(struct inode *dir, struct page **p)\n{\n\tstruct page *page;\n\tstruct f2fs_dir_entry *de;\n\tstruct f2fs_dentry_block *dentry_blk;\n\n\tif (f2fs_has_inline_dentry(dir))\n\t\treturn f2fs_parent_inline_dir(dir, p);\n\n\tpage = get_lock_data_page(dir, 0);\n\tif (IS_ERR(page))\n\t\treturn NULL;\n\n\tdentry_blk = kmap(page);\n\tde = &dentry_blk->dentry[1];\n\t*p = page;\n\tunlock_page(page);\n\treturn de;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct f2fs_dir_entry *f2fs_parent_dir(struct inode *dir, struct page **p)\n{\n\tstruct page *page;\n\tstruct f2fs_dir_entry *de;\n\tstruct f2fs_dentry_block *dentry_blk;\n\n\tif (f2fs_has_inline_dentry(dir))\n\t\treturn f2fs_parent_inline_dir(dir, p);\n\n\tpage = get_lock_data_page(dir, 0);\n\tif (IS_ERR(page))\n\t\treturn NULL;\n\n\tdentry_blk = kmap(page);\n\tde = &dentry_blk->dentry[1];\n\t*p = page;\n\tunlock_page(page);\n\treturn de;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "new_inode->i_mode"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "old_inode->i_mode"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_find_entry",
          "args": [
            "new_dir",
            "&new_dentry->d_name",
            "&new_page"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "213-243",
          "snippet": "struct f2fs_dir_entry *f2fs_find_entry(struct inode *dir,\n\t\t\tstruct qstr *child, struct page **res_page)\n{\n\tunsigned long npages = dir_blocks(dir);\n\tstruct f2fs_dir_entry *de = NULL;\n\tf2fs_hash_t name_hash;\n\tunsigned int max_depth;\n\tunsigned int level;\n\n\tif (f2fs_has_inline_dentry(dir))\n\t\treturn find_in_inline_dir(dir, child, res_page);\n\n\tif (npages == 0)\n\t\treturn NULL;\n\n\t*res_page = NULL;\n\n\tname_hash = f2fs_dentry_hash(child);\n\tmax_depth = F2FS_I(dir)->i_current_depth;\n\n\tfor (level = 0; level < max_depth; level++) {\n\t\tde = find_in_level(dir, level, child, name_hash, res_page);\n\t\tif (de)\n\t\t\tbreak;\n\t}\n\tif (!de && F2FS_I(dir)->chash != name_hash) {\n\t\tF2FS_I(dir)->chash = name_hash;\n\t\tF2FS_I(dir)->clevel = level - 1;\n\t}\n\treturn de;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct f2fs_dir_entry *f2fs_find_entry(struct inode *dir,\n\t\t\tstruct qstr *child, struct page **res_page)\n{\n\tunsigned long npages = dir_blocks(dir);\n\tstruct f2fs_dir_entry *de = NULL;\n\tf2fs_hash_t name_hash;\n\tunsigned int max_depth;\n\tunsigned int level;\n\n\tif (f2fs_has_inline_dentry(dir))\n\t\treturn find_in_inline_dir(dir, child, res_page);\n\n\tif (npages == 0)\n\t\treturn NULL;\n\n\t*res_page = NULL;\n\n\tname_hash = f2fs_dentry_hash(child);\n\tmax_depth = F2FS_I(dir)->i_current_depth;\n\n\tfor (level = 0; level < max_depth; level++) {\n\t\tde = find_in_level(dir, level, child, name_hash, res_page);\n\t\tif (de)\n\t\t\tbreak;\n\t}\n\tif (!de && F2FS_I(dir)->chash != name_hash) {\n\t\tF2FS_I(dir)->chash = name_hash;\n\t\tF2FS_I(dir)->clevel = level - 1;\n\t}\n\treturn de;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_balance_fs",
          "args": [
            "sbi"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_balance_fs_bg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "278-285",
          "snippet": "void f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "old_dir"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int f2fs_cross_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\t     struct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(old_dir);\n\tstruct inode *old_inode = old_dentry->d_inode;\n\tstruct inode *new_inode = new_dentry->d_inode;\n\tstruct page *old_dir_page, *new_dir_page;\n\tstruct page *old_page, *new_page;\n\tstruct f2fs_dir_entry *old_dir_entry = NULL, *new_dir_entry = NULL;\n\tstruct f2fs_dir_entry *old_entry, *new_entry;\n\tint old_nlink = 0, new_nlink = 0;\n\tint err = -ENOENT;\n\n\tf2fs_balance_fs(sbi);\n\n\told_entry = f2fs_find_entry(old_dir, &old_dentry->d_name, &old_page);\n\tif (!old_entry)\n\t\tgoto out;\n\n\tnew_entry = f2fs_find_entry(new_dir, &new_dentry->d_name, &new_page);\n\tif (!new_entry)\n\t\tgoto out_old;\n\n\t/* prepare for updating \"..\" directory entry info later */\n\tif (old_dir != new_dir) {\n\t\tif (S_ISDIR(old_inode->i_mode)) {\n\t\t\terr = -EIO;\n\t\t\told_dir_entry = f2fs_parent_dir(old_inode,\n\t\t\t\t\t\t\t&old_dir_page);\n\t\t\tif (!old_dir_entry)\n\t\t\t\tgoto out_new;\n\t\t}\n\n\t\tif (S_ISDIR(new_inode->i_mode)) {\n\t\t\terr = -EIO;\n\t\t\tnew_dir_entry = f2fs_parent_dir(new_inode,\n\t\t\t\t\t\t\t&new_dir_page);\n\t\t\tif (!new_dir_entry)\n\t\t\t\tgoto out_old_dir;\n\t\t}\n\t}\n\n\t/*\n\t * If cross rename between file and directory those are not\n\t * in the same directory, we will inc nlink of file's parent\n\t * later, so we should check upper boundary of its nlink.\n\t */\n\tif ((!old_dir_entry || !new_dir_entry) &&\n\t\t\t\told_dir_entry != new_dir_entry) {\n\t\told_nlink = old_dir_entry ? -1 : 1;\n\t\tnew_nlink = -old_nlink;\n\t\terr = -EMLINK;\n\t\tif ((old_nlink > 0 && old_inode->i_nlink >= F2FS_LINK_MAX) ||\n\t\t\t(new_nlink > 0 && new_inode->i_nlink >= F2FS_LINK_MAX))\n\t\t\tgoto out_new_dir;\n\t}\n\n\tf2fs_lock_op(sbi);\n\n\terr = update_dent_inode(old_inode, &new_dentry->d_name);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = update_dent_inode(new_inode, &old_dentry->d_name);\n\tif (err)\n\t\tgoto out_undo;\n\n\t/* update \"..\" directory entry info of old dentry */\n\tif (old_dir_entry)\n\t\tf2fs_set_link(old_inode, old_dir_entry, old_dir_page, new_dir);\n\n\t/* update \"..\" directory entry info of new dentry */\n\tif (new_dir_entry)\n\t\tf2fs_set_link(new_inode, new_dir_entry, new_dir_page, old_dir);\n\n\t/* update directory entry info of old dir inode */\n\tf2fs_set_link(old_dir, old_entry, old_page, new_inode);\n\n\tdown_write(&F2FS_I(old_inode)->i_sem);\n\tfile_lost_pino(old_inode);\n\tup_write(&F2FS_I(old_inode)->i_sem);\n\n\tupdate_inode_page(old_inode);\n\n\told_dir->i_ctime = CURRENT_TIME;\n\tif (old_nlink) {\n\t\tdown_write(&F2FS_I(old_dir)->i_sem);\n\t\tif (old_nlink < 0)\n\t\t\tdrop_nlink(old_dir);\n\t\telse\n\t\t\tinc_nlink(old_dir);\n\t\tup_write(&F2FS_I(old_dir)->i_sem);\n\t}\n\tmark_inode_dirty(old_dir);\n\tupdate_inode_page(old_dir);\n\n\t/* update directory entry info of new dir inode */\n\tf2fs_set_link(new_dir, new_entry, new_page, old_inode);\n\n\tdown_write(&F2FS_I(new_inode)->i_sem);\n\tfile_lost_pino(new_inode);\n\tup_write(&F2FS_I(new_inode)->i_sem);\n\n\tupdate_inode_page(new_inode);\n\n\tnew_dir->i_ctime = CURRENT_TIME;\n\tif (new_nlink) {\n\t\tdown_write(&F2FS_I(new_dir)->i_sem);\n\t\tif (new_nlink < 0)\n\t\t\tdrop_nlink(new_dir);\n\t\telse\n\t\t\tinc_nlink(new_dir);\n\t\tup_write(&F2FS_I(new_dir)->i_sem);\n\t}\n\tmark_inode_dirty(new_dir);\n\tupdate_inode_page(new_dir);\n\n\tf2fs_unlock_op(sbi);\n\n\tif (IS_DIRSYNC(old_dir) || IS_DIRSYNC(new_dir))\n\t\tf2fs_sync_fs(sbi->sb, 1);\n\treturn 0;\nout_undo:\n\t/* Still we may fail to recover name info of f2fs_inode here */\n\tupdate_dent_inode(old_inode, &old_dentry->d_name);\nout_unlock:\n\tf2fs_unlock_op(sbi);\nout_new_dir:\n\tif (new_dir_entry) {\n\t\tf2fs_dentry_kunmap(new_inode, new_dir_page);\n\t\tf2fs_put_page(new_dir_page, 0);\n\t}\nout_old_dir:\n\tif (old_dir_entry) {\n\t\tf2fs_dentry_kunmap(old_inode, old_dir_page);\n\t\tf2fs_put_page(old_dir_page, 0);\n\t}\nout_new:\n\tf2fs_dentry_kunmap(new_dir, new_page);\n\tf2fs_put_page(new_page, 0);\nout_old:\n\tf2fs_dentry_kunmap(old_dir, old_page);\n\tf2fs_put_page(old_page, 0);\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "f2fs_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/namei.c",
    "lines": "373-498",
    "snippet": "static int f2fs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\tstruct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(old_dir);\n\tstruct inode *old_inode = old_dentry->d_inode;\n\tstruct inode *new_inode = new_dentry->d_inode;\n\tstruct page *old_dir_page;\n\tstruct page *old_page, *new_page;\n\tstruct f2fs_dir_entry *old_dir_entry = NULL;\n\tstruct f2fs_dir_entry *old_entry;\n\tstruct f2fs_dir_entry *new_entry;\n\tint err = -ENOENT;\n\n\tf2fs_balance_fs(sbi);\n\n\told_entry = f2fs_find_entry(old_dir, &old_dentry->d_name, &old_page);\n\tif (!old_entry)\n\t\tgoto out;\n\n\tif (S_ISDIR(old_inode->i_mode)) {\n\t\terr = -EIO;\n\t\told_dir_entry = f2fs_parent_dir(old_inode, &old_dir_page);\n\t\tif (!old_dir_entry)\n\t\t\tgoto out_old;\n\t}\n\n\tif (new_inode) {\n\n\t\terr = -ENOTEMPTY;\n\t\tif (old_dir_entry && !f2fs_empty_dir(new_inode))\n\t\t\tgoto out_dir;\n\n\t\terr = -ENOENT;\n\t\tnew_entry = f2fs_find_entry(new_dir, &new_dentry->d_name,\n\t\t\t\t\t\t&new_page);\n\t\tif (!new_entry)\n\t\t\tgoto out_dir;\n\n\t\tf2fs_lock_op(sbi);\n\n\t\terr = acquire_orphan_inode(sbi);\n\t\tif (err)\n\t\t\tgoto put_out_dir;\n\n\t\tif (update_dent_inode(old_inode, &new_dentry->d_name)) {\n\t\t\trelease_orphan_inode(sbi);\n\t\t\tgoto put_out_dir;\n\t\t}\n\n\t\tf2fs_set_link(new_dir, new_entry, new_page, old_inode);\n\n\t\tnew_inode->i_ctime = CURRENT_TIME;\n\t\tdown_write(&F2FS_I(new_inode)->i_sem);\n\t\tif (old_dir_entry)\n\t\t\tdrop_nlink(new_inode);\n\t\tdrop_nlink(new_inode);\n\t\tup_write(&F2FS_I(new_inode)->i_sem);\n\n\t\tmark_inode_dirty(new_inode);\n\n\t\tif (!new_inode->i_nlink)\n\t\t\tadd_orphan_inode(sbi, new_inode->i_ino);\n\t\telse\n\t\t\trelease_orphan_inode(sbi);\n\n\t\tupdate_inode_page(old_inode);\n\t\tupdate_inode_page(new_inode);\n\t} else {\n\t\tf2fs_lock_op(sbi);\n\n\t\terr = f2fs_add_link(new_dentry, old_inode);\n\t\tif (err) {\n\t\t\tf2fs_unlock_op(sbi);\n\t\t\tgoto out_dir;\n\t\t}\n\n\t\tif (old_dir_entry) {\n\t\t\tinc_nlink(new_dir);\n\t\t\tupdate_inode_page(new_dir);\n\t\t}\n\t}\n\n\tdown_write(&F2FS_I(old_inode)->i_sem);\n\tfile_lost_pino(old_inode);\n\tup_write(&F2FS_I(old_inode)->i_sem);\n\n\told_inode->i_ctime = CURRENT_TIME;\n\tmark_inode_dirty(old_inode);\n\n\tf2fs_delete_entry(old_entry, old_page, old_dir, NULL);\n\n\tif (old_dir_entry) {\n\t\tif (old_dir != new_dir) {\n\t\t\tf2fs_set_link(old_inode, old_dir_entry,\n\t\t\t\t\t\told_dir_page, new_dir);\n\t\t\tupdate_inode_page(old_inode);\n\t\t} else {\n\t\t\tf2fs_dentry_kunmap(old_inode, old_dir_page);\n\t\t\tf2fs_put_page(old_dir_page, 0);\n\t\t}\n\t\tdrop_nlink(old_dir);\n\t\tmark_inode_dirty(old_dir);\n\t\tupdate_inode_page(old_dir);\n\t}\n\n\tf2fs_unlock_op(sbi);\n\n\tif (IS_DIRSYNC(old_dir) || IS_DIRSYNC(new_dir))\n\t\tf2fs_sync_fs(sbi->sb, 1);\n\treturn 0;\n\nput_out_dir:\n\tf2fs_unlock_op(sbi);\n\tf2fs_dentry_kunmap(new_dir, new_page);\n\tf2fs_put_page(new_page, 0);\nout_dir:\n\tif (old_dir_entry) {\n\t\tf2fs_dentry_kunmap(old_inode, old_dir_page);\n\t\tf2fs_put_page(old_dir_page, 0);\n\t}\nout_old:\n\tf2fs_dentry_kunmap(old_dir, old_page);\n\tf2fs_put_page(old_page, 0);\nout:\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/dcache.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "old_page",
            "0"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_dentry_kunmap",
          "args": [
            "old_dir",
            "old_page"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_dentry_kunmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1299-1303",
          "snippet": "static inline void f2fs_dentry_kunmap(struct inode *dir, struct page *page)\n{\n\tif (!f2fs_has_inline_dentry(dir))\n\t\tkunmap(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_dentry_kunmap(struct inode *dir, struct page *page)\n{\n\tif (!f2fs_has_inline_dentry(dir))\n\t\tkunmap(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_unlock_op",
          "args": [
            "sbi"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_unlock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "760-763",
          "snippet": "static inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_sync_fs",
          "args": [
            "sbi->sb",
            "1"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_sync_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
          "lines": "496-516",
          "snippet": "int f2fs_sync_fs(struct super_block *sb, int sync)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\n\ttrace_f2fs_sync_fs(sb, sync);\n\n\tif (sync) {\n\t\tstruct cp_control cpc;\n\n\t\tcpc.reason = __get_cp_reason(sbi);\n\n\t\tmutex_lock(&sbi->gc_mutex);\n\t\twrite_checkpoint(sbi, &cpc);\n\t\tmutex_unlock(&sbi->gc_mutex);\n\t} else {\n\t\tf2fs_balance_fs(sbi);\n\t}\n\tf2fs_trace_ios(NULL, NULL, 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"gc.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/random.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/parser.h>",
            "#include <linux/kthread.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nint f2fs_sync_fs(struct super_block *sb, int sync)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\n\ttrace_f2fs_sync_fs(sb, sync);\n\n\tif (sync) {\n\t\tstruct cp_control cpc;\n\n\t\tcpc.reason = __get_cp_reason(sbi);\n\n\t\tmutex_lock(&sbi->gc_mutex);\n\t\twrite_checkpoint(sbi, &cpc);\n\t\tmutex_unlock(&sbi->gc_mutex);\n\t} else {\n\t\tf2fs_balance_fs(sbi);\n\t}\n\tf2fs_trace_ios(NULL, NULL, 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "new_dir"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "old_dir"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_inode_page",
          "args": [
            "old_dir"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "update_inode_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
          "lines": "246-264",
          "snippet": "void update_inode_page(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct page *node_page;\nretry:\n\tnode_page = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(node_page)) {\n\t\tint err = PTR_ERR(node_page);\n\t\tif (err == -ENOMEM) {\n\t\t\tcond_resched();\n\t\t\tgoto retry;\n\t\t} else if (err != -ENOENT) {\n\t\t\tf2fs_stop_checkpoint(sbi);\n\t\t}\n\t\treturn;\n\t}\n\tupdate_inode(inode, node_page);\n\tf2fs_put_page(node_page, 1);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid update_inode_page(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct page *node_page;\nretry:\n\tnode_page = get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(node_page)) {\n\t\tint err = PTR_ERR(node_page);\n\t\tif (err == -ENOMEM) {\n\t\t\tcond_resched();\n\t\t\tgoto retry;\n\t\t} else if (err != -ENOENT) {\n\t\t\tf2fs_stop_checkpoint(sbi);\n\t\t}\n\t\treturn;\n\t}\n\tupdate_inode(inode, node_page);\n\tf2fs_put_page(node_page, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "old_dir"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "old_dir"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "271-277",
          "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_set_link",
          "args": [
            "old_inode",
            "old_dir_entry",
            "old_dir_page",
            "new_dir"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_set_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "281-295",
          "snippet": "void f2fs_set_link(struct inode *dir, struct f2fs_dir_entry *de,\n\t\tstruct page *page, struct inode *inode)\n{\n\tenum page_type type = f2fs_has_inline_dentry(dir) ? NODE : DATA;\n\tlock_page(page);\n\tf2fs_wait_on_page_writeback(page, type);\n\tde->ino = cpu_to_le32(inode->i_ino);\n\tset_de_type(de, inode);\n\tf2fs_dentry_kunmap(dir, page);\n\tset_page_dirty(page);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME;\n\tmark_inode_dirty(dir);\n\n\tf2fs_put_page(page, 1);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_set_link(struct inode *dir, struct f2fs_dir_entry *de,\n\t\tstruct page *page, struct inode *inode)\n{\n\tenum page_type type = f2fs_has_inline_dentry(dir) ? NODE : DATA;\n\tlock_page(page);\n\tf2fs_wait_on_page_writeback(page, type);\n\tde->ino = cpu_to_le32(inode->i_ino);\n\tset_de_type(de, inode);\n\tf2fs_dentry_kunmap(dir, page);\n\tset_page_dirty(page);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME;\n\tmark_inode_dirty(dir);\n\n\tf2fs_put_page(page, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_delete_entry",
          "args": [
            "old_entry",
            "old_page",
            "old_dir",
            "NULL"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_delete_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "638-676",
          "snippet": "void f2fs_delete_entry(struct f2fs_dir_entry *dentry, struct page *page,\n\t\t\t\t\tstruct inode *dir, struct inode *inode)\n{\n\tstruct\tf2fs_dentry_block *dentry_blk;\n\tunsigned int bit_pos;\n\tint slots = GET_DENTRY_SLOTS(le16_to_cpu(dentry->name_len));\n\tint i;\n\n\tif (f2fs_has_inline_dentry(dir))\n\t\treturn f2fs_delete_inline_entry(dentry, page, dir, inode);\n\n\tlock_page(page);\n\tf2fs_wait_on_page_writeback(page, DATA);\n\n\tdentry_blk = page_address(page);\n\tbit_pos = dentry - dentry_blk->dentry;\n\tfor (i = 0; i < slots; i++)\n\t\tclear_bit_le(bit_pos + i, &dentry_blk->dentry_bitmap);\n\n\t/* Let's check and deallocate this dentry page */\n\tbit_pos = find_next_bit_le(&dentry_blk->dentry_bitmap,\n\t\t\tNR_DENTRY_IN_BLOCK,\n\t\t\t0);\n\tkunmap(page); /* kunmap - pair of f2fs_find_entry */\n\tset_page_dirty(page);\n\n\tdir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\n\tif (inode)\n\t\tf2fs_drop_nlink(dir, inode, NULL);\n\n\tif (bit_pos == NR_DENTRY_IN_BLOCK) {\n\t\ttruncate_hole(dir, page->index, page->index + 1);\n\t\tclear_page_dirty_for_io(page);\n\t\tClearPageUptodate(page);\n\t\tinode_dec_dirty_pages(dir);\n\t}\n\tf2fs_put_page(page, 1);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_delete_entry(struct f2fs_dir_entry *dentry, struct page *page,\n\t\t\t\t\tstruct inode *dir, struct inode *inode)\n{\n\tstruct\tf2fs_dentry_block *dentry_blk;\n\tunsigned int bit_pos;\n\tint slots = GET_DENTRY_SLOTS(le16_to_cpu(dentry->name_len));\n\tint i;\n\n\tif (f2fs_has_inline_dentry(dir))\n\t\treturn f2fs_delete_inline_entry(dentry, page, dir, inode);\n\n\tlock_page(page);\n\tf2fs_wait_on_page_writeback(page, DATA);\n\n\tdentry_blk = page_address(page);\n\tbit_pos = dentry - dentry_blk->dentry;\n\tfor (i = 0; i < slots; i++)\n\t\tclear_bit_le(bit_pos + i, &dentry_blk->dentry_bitmap);\n\n\t/* Let's check and deallocate this dentry page */\n\tbit_pos = find_next_bit_le(&dentry_blk->dentry_bitmap,\n\t\t\tNR_DENTRY_IN_BLOCK,\n\t\t\t0);\n\tkunmap(page); /* kunmap - pair of f2fs_find_entry */\n\tset_page_dirty(page);\n\n\tdir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\n\tif (inode)\n\t\tf2fs_drop_nlink(dir, inode, NULL);\n\n\tif (bit_pos == NR_DENTRY_IN_BLOCK) {\n\t\ttruncate_hole(dir, page->index, page->index + 1);\n\t\tclear_page_dirty_for_io(page);\n\t\tClearPageUptodate(page);\n\t\tinode_dec_dirty_pages(dir);\n\t}\n\tf2fs_put_page(page, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&F2FS_I(old_inode)->i_sem"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "old_inode"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_lost_pino",
          "args": [
            "old_inode"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&F2FS_I(old_inode)->i_sem"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "new_dir"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_add_link",
          "args": [
            "new_dentry",
            "old_inode"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_add_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1392-1396",
          "snippet": "static inline int f2fs_add_link(struct dentry *dentry, struct inode *inode)\n{\n\treturn __f2fs_add_link(dentry->d_parent->d_inode, &dentry->d_name,\n\t\t\t\tinode);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_add_link(struct dentry *dentry, struct inode *inode)\n{\n\treturn __f2fs_add_link(dentry->d_parent->d_inode, &dentry->d_name,\n\t\t\t\tinode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_lock_op",
          "args": [
            "sbi"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_lock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "755-758",
          "snippet": "static inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tdown_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tdown_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_orphan_inode",
          "args": [
            "sbi"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "release_orphan_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "433-441",
          "snippet": "void release_orphan_inode(struct f2fs_sb_info *sbi)\n{\n\tstruct inode_management *im = &sbi->im[ORPHAN_INO];\n\n\tspin_lock(&im->ino_lock);\n\tf2fs_bug_on(sbi, im->ino_num == 0);\n\tim->ino_num--;\n\tspin_unlock(&im->ino_lock);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nvoid release_orphan_inode(struct f2fs_sb_info *sbi)\n{\n\tstruct inode_management *im = &sbi->im[ORPHAN_INO];\n\n\tspin_lock(&im->ino_lock);\n\tf2fs_bug_on(sbi, im->ino_num == 0);\n\tim->ino_num--;\n\tspin_unlock(&im->ino_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_orphan_inode",
          "args": [
            "sbi",
            "new_inode->i_ino"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "add_orphan_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "443-447",
          "snippet": "void add_orphan_inode(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\t/* add new orphan ino entry into list */\n\t__add_ino_entry(sbi, ino, ORPHAN_INO);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nvoid add_orphan_inode(struct f2fs_sb_info *sbi, nid_t ino)\n{\n\t/* add new orphan ino entry into list */\n\t__add_ino_entry(sbi, ino, ORPHAN_INO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&F2FS_I(new_inode)->i_sem"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&F2FS_I(new_inode)->i_sem"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_dent_inode",
          "args": [
            "old_inode",
            "&new_dentry->d_name"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "update_dent_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "310-322",
          "snippet": "int update_dent_inode(struct inode *inode, const struct qstr *name)\n{\n\tstruct page *page;\n\n\tpage = get_node_page(F2FS_I_SB(inode), inode->i_ino);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\n\tinit_dent_inode(name, page);\n\tf2fs_put_page(page, 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nint update_dent_inode(struct inode *inode, const struct qstr *name)\n{\n\tstruct page *page;\n\n\tpage = get_node_page(F2FS_I_SB(inode), inode->i_ino);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\n\tinit_dent_inode(name, page);\n\tf2fs_put_page(page, 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "acquire_orphan_inode",
          "args": [
            "sbi"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "acquire_orphan_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "418-431",
          "snippet": "int acquire_orphan_inode(struct f2fs_sb_info *sbi)\n{\n\tstruct inode_management *im = &sbi->im[ORPHAN_INO];\n\tint err = 0;\n\n\tspin_lock(&im->ino_lock);\n\tif (unlikely(im->ino_num >= sbi->max_orphans))\n\t\terr = -ENOSPC;\n\telse\n\t\tim->ino_num++;\n\tspin_unlock(&im->ino_lock);\n\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nint acquire_orphan_inode(struct f2fs_sb_info *sbi)\n{\n\tstruct inode_management *im = &sbi->im[ORPHAN_INO];\n\tint err = 0;\n\n\tspin_lock(&im->ino_lock);\n\tif (unlikely(im->ino_num >= sbi->max_orphans))\n\t\terr = -ENOSPC;\n\telse\n\t\tim->ino_num++;\n\tspin_unlock(&im->ino_lock);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_find_entry",
          "args": [
            "new_dir",
            "&new_dentry->d_name",
            "&new_page"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "213-243",
          "snippet": "struct f2fs_dir_entry *f2fs_find_entry(struct inode *dir,\n\t\t\tstruct qstr *child, struct page **res_page)\n{\n\tunsigned long npages = dir_blocks(dir);\n\tstruct f2fs_dir_entry *de = NULL;\n\tf2fs_hash_t name_hash;\n\tunsigned int max_depth;\n\tunsigned int level;\n\n\tif (f2fs_has_inline_dentry(dir))\n\t\treturn find_in_inline_dir(dir, child, res_page);\n\n\tif (npages == 0)\n\t\treturn NULL;\n\n\t*res_page = NULL;\n\n\tname_hash = f2fs_dentry_hash(child);\n\tmax_depth = F2FS_I(dir)->i_current_depth;\n\n\tfor (level = 0; level < max_depth; level++) {\n\t\tde = find_in_level(dir, level, child, name_hash, res_page);\n\t\tif (de)\n\t\t\tbreak;\n\t}\n\tif (!de && F2FS_I(dir)->chash != name_hash) {\n\t\tF2FS_I(dir)->chash = name_hash;\n\t\tF2FS_I(dir)->clevel = level - 1;\n\t}\n\treturn de;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct f2fs_dir_entry *f2fs_find_entry(struct inode *dir,\n\t\t\tstruct qstr *child, struct page **res_page)\n{\n\tunsigned long npages = dir_blocks(dir);\n\tstruct f2fs_dir_entry *de = NULL;\n\tf2fs_hash_t name_hash;\n\tunsigned int max_depth;\n\tunsigned int level;\n\n\tif (f2fs_has_inline_dentry(dir))\n\t\treturn find_in_inline_dir(dir, child, res_page);\n\n\tif (npages == 0)\n\t\treturn NULL;\n\n\t*res_page = NULL;\n\n\tname_hash = f2fs_dentry_hash(child);\n\tmax_depth = F2FS_I(dir)->i_current_depth;\n\n\tfor (level = 0; level < max_depth; level++) {\n\t\tde = find_in_level(dir, level, child, name_hash, res_page);\n\t\tif (de)\n\t\t\tbreak;\n\t}\n\tif (!de && F2FS_I(dir)->chash != name_hash) {\n\t\tF2FS_I(dir)->chash = name_hash;\n\t\tF2FS_I(dir)->clevel = level - 1;\n\t}\n\treturn de;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_empty_dir",
          "args": [
            "new_inode"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_empty_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "678-714",
          "snippet": "bool f2fs_empty_dir(struct inode *dir)\n{\n\tunsigned long bidx;\n\tstruct page *dentry_page;\n\tunsigned int bit_pos;\n\tstruct f2fs_dentry_block *dentry_blk;\n\tunsigned long nblock = dir_blocks(dir);\n\n\tif (f2fs_has_inline_dentry(dir))\n\t\treturn f2fs_empty_inline_dir(dir);\n\n\tfor (bidx = 0; bidx < nblock; bidx++) {\n\t\tdentry_page = get_lock_data_page(dir, bidx);\n\t\tif (IS_ERR(dentry_page)) {\n\t\t\tif (PTR_ERR(dentry_page) == -ENOENT)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\n\t\tdentry_blk = kmap_atomic(dentry_page);\n\t\tif (bidx == 0)\n\t\t\tbit_pos = 2;\n\t\telse\n\t\t\tbit_pos = 0;\n\t\tbit_pos = find_next_bit_le(&dentry_blk->dentry_bitmap,\n\t\t\t\t\t\tNR_DENTRY_IN_BLOCK,\n\t\t\t\t\t\tbit_pos);\n\t\tkunmap_atomic(dentry_blk);\n\n\t\tf2fs_put_page(dentry_page, 1);\n\n\t\tif (bit_pos < NR_DENTRY_IN_BLOCK)\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nbool f2fs_empty_dir(struct inode *dir)\n{\n\tunsigned long bidx;\n\tstruct page *dentry_page;\n\tunsigned int bit_pos;\n\tstruct f2fs_dentry_block *dentry_blk;\n\tunsigned long nblock = dir_blocks(dir);\n\n\tif (f2fs_has_inline_dentry(dir))\n\t\treturn f2fs_empty_inline_dir(dir);\n\n\tfor (bidx = 0; bidx < nblock; bidx++) {\n\t\tdentry_page = get_lock_data_page(dir, bidx);\n\t\tif (IS_ERR(dentry_page)) {\n\t\t\tif (PTR_ERR(dentry_page) == -ENOENT)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\n\t\tdentry_blk = kmap_atomic(dentry_page);\n\t\tif (bidx == 0)\n\t\t\tbit_pos = 2;\n\t\telse\n\t\t\tbit_pos = 0;\n\t\tbit_pos = find_next_bit_le(&dentry_blk->dentry_bitmap,\n\t\t\t\t\t\tNR_DENTRY_IN_BLOCK,\n\t\t\t\t\t\tbit_pos);\n\t\tkunmap_atomic(dentry_blk);\n\n\t\tf2fs_put_page(dentry_page, 1);\n\n\t\tif (bit_pos < NR_DENTRY_IN_BLOCK)\n\t\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_parent_dir",
          "args": [
            "old_inode",
            "&old_dir_page"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_parent_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "245-263",
          "snippet": "struct f2fs_dir_entry *f2fs_parent_dir(struct inode *dir, struct page **p)\n{\n\tstruct page *page;\n\tstruct f2fs_dir_entry *de;\n\tstruct f2fs_dentry_block *dentry_blk;\n\n\tif (f2fs_has_inline_dentry(dir))\n\t\treturn f2fs_parent_inline_dir(dir, p);\n\n\tpage = get_lock_data_page(dir, 0);\n\tif (IS_ERR(page))\n\t\treturn NULL;\n\n\tdentry_blk = kmap(page);\n\tde = &dentry_blk->dentry[1];\n\t*p = page;\n\tunlock_page(page);\n\treturn de;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct f2fs_dir_entry *f2fs_parent_dir(struct inode *dir, struct page **p)\n{\n\tstruct page *page;\n\tstruct f2fs_dir_entry *de;\n\tstruct f2fs_dentry_block *dentry_blk;\n\n\tif (f2fs_has_inline_dentry(dir))\n\t\treturn f2fs_parent_inline_dir(dir, p);\n\n\tpage = get_lock_data_page(dir, 0);\n\tif (IS_ERR(page))\n\t\treturn NULL;\n\n\tdentry_blk = kmap(page);\n\tde = &dentry_blk->dentry[1];\n\t*p = page;\n\tunlock_page(page);\n\treturn de;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "old_inode->i_mode"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_balance_fs",
          "args": [
            "sbi"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_balance_fs_bg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "278-285",
          "snippet": "void f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "old_dir"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int f2fs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\tstruct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(old_dir);\n\tstruct inode *old_inode = old_dentry->d_inode;\n\tstruct inode *new_inode = new_dentry->d_inode;\n\tstruct page *old_dir_page;\n\tstruct page *old_page, *new_page;\n\tstruct f2fs_dir_entry *old_dir_entry = NULL;\n\tstruct f2fs_dir_entry *old_entry;\n\tstruct f2fs_dir_entry *new_entry;\n\tint err = -ENOENT;\n\n\tf2fs_balance_fs(sbi);\n\n\told_entry = f2fs_find_entry(old_dir, &old_dentry->d_name, &old_page);\n\tif (!old_entry)\n\t\tgoto out;\n\n\tif (S_ISDIR(old_inode->i_mode)) {\n\t\terr = -EIO;\n\t\told_dir_entry = f2fs_parent_dir(old_inode, &old_dir_page);\n\t\tif (!old_dir_entry)\n\t\t\tgoto out_old;\n\t}\n\n\tif (new_inode) {\n\n\t\terr = -ENOTEMPTY;\n\t\tif (old_dir_entry && !f2fs_empty_dir(new_inode))\n\t\t\tgoto out_dir;\n\n\t\terr = -ENOENT;\n\t\tnew_entry = f2fs_find_entry(new_dir, &new_dentry->d_name,\n\t\t\t\t\t\t&new_page);\n\t\tif (!new_entry)\n\t\t\tgoto out_dir;\n\n\t\tf2fs_lock_op(sbi);\n\n\t\terr = acquire_orphan_inode(sbi);\n\t\tif (err)\n\t\t\tgoto put_out_dir;\n\n\t\tif (update_dent_inode(old_inode, &new_dentry->d_name)) {\n\t\t\trelease_orphan_inode(sbi);\n\t\t\tgoto put_out_dir;\n\t\t}\n\n\t\tf2fs_set_link(new_dir, new_entry, new_page, old_inode);\n\n\t\tnew_inode->i_ctime = CURRENT_TIME;\n\t\tdown_write(&F2FS_I(new_inode)->i_sem);\n\t\tif (old_dir_entry)\n\t\t\tdrop_nlink(new_inode);\n\t\tdrop_nlink(new_inode);\n\t\tup_write(&F2FS_I(new_inode)->i_sem);\n\n\t\tmark_inode_dirty(new_inode);\n\n\t\tif (!new_inode->i_nlink)\n\t\t\tadd_orphan_inode(sbi, new_inode->i_ino);\n\t\telse\n\t\t\trelease_orphan_inode(sbi);\n\n\t\tupdate_inode_page(old_inode);\n\t\tupdate_inode_page(new_inode);\n\t} else {\n\t\tf2fs_lock_op(sbi);\n\n\t\terr = f2fs_add_link(new_dentry, old_inode);\n\t\tif (err) {\n\t\t\tf2fs_unlock_op(sbi);\n\t\t\tgoto out_dir;\n\t\t}\n\n\t\tif (old_dir_entry) {\n\t\t\tinc_nlink(new_dir);\n\t\t\tupdate_inode_page(new_dir);\n\t\t}\n\t}\n\n\tdown_write(&F2FS_I(old_inode)->i_sem);\n\tfile_lost_pino(old_inode);\n\tup_write(&F2FS_I(old_inode)->i_sem);\n\n\told_inode->i_ctime = CURRENT_TIME;\n\tmark_inode_dirty(old_inode);\n\n\tf2fs_delete_entry(old_entry, old_page, old_dir, NULL);\n\n\tif (old_dir_entry) {\n\t\tif (old_dir != new_dir) {\n\t\t\tf2fs_set_link(old_inode, old_dir_entry,\n\t\t\t\t\t\told_dir_page, new_dir);\n\t\t\tupdate_inode_page(old_inode);\n\t\t} else {\n\t\t\tf2fs_dentry_kunmap(old_inode, old_dir_page);\n\t\t\tf2fs_put_page(old_dir_page, 0);\n\t\t}\n\t\tdrop_nlink(old_dir);\n\t\tmark_inode_dirty(old_dir);\n\t\tupdate_inode_page(old_dir);\n\t}\n\n\tf2fs_unlock_op(sbi);\n\n\tif (IS_DIRSYNC(old_dir) || IS_DIRSYNC(new_dir))\n\t\tf2fs_sync_fs(sbi->sb, 1);\n\treturn 0;\n\nput_out_dir:\n\tf2fs_unlock_op(sbi);\n\tf2fs_dentry_kunmap(new_dir, new_page);\n\tf2fs_put_page(new_page, 0);\nout_dir:\n\tif (old_dir_entry) {\n\t\tf2fs_dentry_kunmap(old_inode, old_dir_page);\n\t\tf2fs_put_page(old_dir_page, 0);\n\t}\nout_old:\n\tf2fs_dentry_kunmap(old_dir, old_page);\n\tf2fs_put_page(old_page, 0);\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "f2fs_mknod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/namei.c",
    "lines": "335-371",
    "snippet": "static int f2fs_mknod(struct inode *dir, struct dentry *dentry,\n\t\t\t\tumode_t mode, dev_t rdev)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tstruct inode *inode;\n\tint err = 0;\n\n\tif (!new_valid_dev(rdev))\n\t\treturn -EINVAL;\n\n\tf2fs_balance_fs(sbi);\n\n\tinode = f2fs_new_inode(dir, mode);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tinit_special_inode(inode, inode->i_mode, rdev);\n\tinode->i_op = &f2fs_special_inode_operations;\n\n\tf2fs_lock_op(sbi);\n\terr = f2fs_add_link(dentry, inode);\n\tif (err)\n\t\tgoto out;\n\tf2fs_unlock_op(sbi);\n\n\talloc_nid_done(sbi, inode->i_ino);\n\n\td_instantiate(dentry, inode);\n\tunlock_new_inode(inode);\n\n\tif (IS_DIRSYNC(dir))\n\t\tf2fs_sync_fs(sbi->sb, 1);\n\treturn 0;\nout:\n\thandle_failed_inode(inode);\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/dcache.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct inode_operations f2fs_special_inode_operations = {\n\t.getattr\t= f2fs_getattr,\n\t.setattr        = f2fs_setattr,\n\t.get_acl\t= f2fs_get_acl,\n\t.set_acl\t= f2fs_set_acl,\n#ifdef CONFIG_F2FS_FS_XATTR\n\t.setxattr       = generic_setxattr,\n\t.getxattr       = generic_getxattr,\n\t.listxattr\t= f2fs_listxattr,\n\t.removexattr    = generic_removexattr,\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "handle_failed_inode",
          "args": [
            "inode"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "handle_failed_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
          "lines": "343-364",
          "snippet": "void handle_failed_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\n\tclear_nlink(inode);\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\n\ti_size_write(inode, 0);\n\tif (F2FS_HAS_BLOCKS(inode))\n\t\tf2fs_truncate(inode);\n\n\tremove_inode_page(inode);\n\n\tclear_inode_flag(F2FS_I(inode), FI_INLINE_DATA);\n\tclear_inode_flag(F2FS_I(inode), FI_INLINE_DENTRY);\n\talloc_nid_failed(sbi, inode->i_ino);\n\tf2fs_unlock_op(sbi);\n\n\t/* iput will drop the inode object */\n\tiput(inode);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid handle_failed_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\n\tclear_nlink(inode);\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\n\ti_size_write(inode, 0);\n\tif (F2FS_HAS_BLOCKS(inode))\n\t\tf2fs_truncate(inode);\n\n\tremove_inode_page(inode);\n\n\tclear_inode_flag(F2FS_I(inode), FI_INLINE_DATA);\n\tclear_inode_flag(F2FS_I(inode), FI_INLINE_DENTRY);\n\talloc_nid_failed(sbi, inode->i_ino);\n\tf2fs_unlock_op(sbi);\n\n\t/* iput will drop the inode object */\n\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_sync_fs",
          "args": [
            "sbi->sb",
            "1"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_sync_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
          "lines": "496-516",
          "snippet": "int f2fs_sync_fs(struct super_block *sb, int sync)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\n\ttrace_f2fs_sync_fs(sb, sync);\n\n\tif (sync) {\n\t\tstruct cp_control cpc;\n\n\t\tcpc.reason = __get_cp_reason(sbi);\n\n\t\tmutex_lock(&sbi->gc_mutex);\n\t\twrite_checkpoint(sbi, &cpc);\n\t\tmutex_unlock(&sbi->gc_mutex);\n\t} else {\n\t\tf2fs_balance_fs(sbi);\n\t}\n\tf2fs_trace_ios(NULL, NULL, 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"gc.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/random.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/parser.h>",
            "#include <linux/kthread.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nint f2fs_sync_fs(struct super_block *sb, int sync)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\n\ttrace_f2fs_sync_fs(sb, sync);\n\n\tif (sync) {\n\t\tstruct cp_control cpc;\n\n\t\tcpc.reason = __get_cp_reason(sbi);\n\n\t\tmutex_lock(&sbi->gc_mutex);\n\t\twrite_checkpoint(sbi, &cpc);\n\t\tmutex_unlock(&sbi->gc_mutex);\n\t} else {\n\t\tf2fs_balance_fs(sbi);\n\t}\n\tf2fs_trace_ios(NULL, NULL, 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "dir"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_nid_done",
          "args": [
            "sbi",
            "inode->i_ino"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_nid_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1582-1594",
          "snippet": "void alloc_nid_done(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\n\tspin_lock(&nm_i->free_nid_list_lock);\n\ti = __lookup_free_nid_list(nm_i, nid);\n\tf2fs_bug_on(sbi, !i || i->state != NID_ALLOC);\n\t__del_from_free_nid_list(nm_i, i);\n\tspin_unlock(&nm_i->free_nid_list_lock);\n\n\tkmem_cache_free(free_nid_slab, i);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *free_nid_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *free_nid_slab;\n\nvoid alloc_nid_done(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\n\tspin_lock(&nm_i->free_nid_list_lock);\n\ti = __lookup_free_nid_list(nm_i, nid);\n\tf2fs_bug_on(sbi, !i || i->state != NID_ALLOC);\n\t__del_from_free_nid_list(nm_i, i);\n\tspin_unlock(&nm_i->free_nid_list_lock);\n\n\tkmem_cache_free(free_nid_slab, i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_unlock_op",
          "args": [
            "sbi"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_unlock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "760-763",
          "snippet": "static inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_add_link",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_add_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1392-1396",
          "snippet": "static inline int f2fs_add_link(struct dentry *dentry, struct inode *inode)\n{\n\treturn __f2fs_add_link(dentry->d_parent->d_inode, &dentry->d_name,\n\t\t\t\tinode);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_add_link(struct dentry *dentry, struct inode *inode)\n{\n\treturn __f2fs_add_link(dentry->d_parent->d_inode, &dentry->d_name,\n\t\t\t\tinode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_lock_op",
          "args": [
            "sbi"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_lock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "755-758",
          "snippet": "static inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tdown_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tdown_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_special_inode",
          "args": [
            "inode",
            "inode->i_mode",
            "rdev"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "init_special_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1854-1871",
          "snippet": "void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_new_inode",
          "args": [
            "dir",
            "mode"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/namei.c",
          "lines": "24-77",
          "snippet": "static struct inode *f2fs_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tnid_t ino;\n\tstruct inode *inode;\n\tbool nid_free = false;\n\tint err;\n\n\tinode = new_inode(dir->i_sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tf2fs_lock_op(sbi);\n\tif (!alloc_nid(sbi, &ino)) {\n\t\tf2fs_unlock_op(sbi);\n\t\terr = -ENOSPC;\n\t\tgoto fail;\n\t}\n\tf2fs_unlock_op(sbi);\n\n\tinode_init_owner(inode, dir, mode);\n\n\tinode->i_ino = ino;\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_generation = sbi->s_next_generation++;\n\n\terr = insert_inode_locked(inode);\n\tif (err) {\n\t\terr = -EINVAL;\n\t\tnid_free = true;\n\t\tgoto out;\n\t}\n\n\tif (f2fs_may_inline(inode))\n\t\tset_inode_flag(F2FS_I(inode), FI_INLINE_DATA);\n\tif (test_opt(sbi, INLINE_DENTRY) && S_ISDIR(inode->i_mode))\n\t\tset_inode_flag(F2FS_I(inode), FI_INLINE_DENTRY);\n\n\ttrace_f2fs_new_inode(inode, 0);\n\tmark_inode_dirty(inode);\n\treturn inode;\n\nout:\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\nfail:\n\ttrace_f2fs_new_inode(inode, err);\n\tmake_bad_inode(inode);\n\tiput(inode);\n\tif (nid_free)\n\t\talloc_nid_failed(sbi, ino);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/dcache.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct inode *f2fs_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tnid_t ino;\n\tstruct inode *inode;\n\tbool nid_free = false;\n\tint err;\n\n\tinode = new_inode(dir->i_sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tf2fs_lock_op(sbi);\n\tif (!alloc_nid(sbi, &ino)) {\n\t\tf2fs_unlock_op(sbi);\n\t\terr = -ENOSPC;\n\t\tgoto fail;\n\t}\n\tf2fs_unlock_op(sbi);\n\n\tinode_init_owner(inode, dir, mode);\n\n\tinode->i_ino = ino;\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_generation = sbi->s_next_generation++;\n\n\terr = insert_inode_locked(inode);\n\tif (err) {\n\t\terr = -EINVAL;\n\t\tnid_free = true;\n\t\tgoto out;\n\t}\n\n\tif (f2fs_may_inline(inode))\n\t\tset_inode_flag(F2FS_I(inode), FI_INLINE_DATA);\n\tif (test_opt(sbi, INLINE_DENTRY) && S_ISDIR(inode->i_mode))\n\t\tset_inode_flag(F2FS_I(inode), FI_INLINE_DENTRY);\n\n\ttrace_f2fs_new_inode(inode, 0);\n\tmark_inode_dirty(inode);\n\treturn inode;\n\nout:\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\nfail:\n\ttrace_f2fs_new_inode(inode, err);\n\tmake_bad_inode(inode);\n\tiput(inode);\n\tif (nid_free)\n\t\talloc_nid_failed(sbi, ino);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_balance_fs",
          "args": [
            "sbi"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_balance_fs_bg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "278-285",
          "snippet": "void f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_valid_dev",
          "args": [
            "rdev"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "dir"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nconst struct inode_operations f2fs_special_inode_operations = {\n\t.getattr\t= f2fs_getattr,\n\t.setattr        = f2fs_setattr,\n\t.get_acl\t= f2fs_get_acl,\n\t.set_acl\t= f2fs_set_acl,\n#ifdef CONFIG_F2FS_FS_XATTR\n\t.setxattr       = generic_setxattr,\n\t.getxattr       = generic_getxattr,\n\t.listxattr\t= f2fs_listxattr,\n\t.removexattr    = generic_removexattr,\n#endif\n};\n\nstatic int f2fs_mknod(struct inode *dir, struct dentry *dentry,\n\t\t\t\tumode_t mode, dev_t rdev)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tstruct inode *inode;\n\tint err = 0;\n\n\tif (!new_valid_dev(rdev))\n\t\treturn -EINVAL;\n\n\tf2fs_balance_fs(sbi);\n\n\tinode = f2fs_new_inode(dir, mode);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tinit_special_inode(inode, inode->i_mode, rdev);\n\tinode->i_op = &f2fs_special_inode_operations;\n\n\tf2fs_lock_op(sbi);\n\terr = f2fs_add_link(dentry, inode);\n\tif (err)\n\t\tgoto out;\n\tf2fs_unlock_op(sbi);\n\n\talloc_nid_done(sbi, inode->i_ino);\n\n\td_instantiate(dentry, inode);\n\tunlock_new_inode(inode);\n\n\tif (IS_DIRSYNC(dir))\n\t\tf2fs_sync_fs(sbi->sb, 1);\n\treturn 0;\nout:\n\thandle_failed_inode(inode);\n\treturn err;\n}"
  },
  {
    "function_name": "f2fs_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/namei.c",
    "lines": "327-333",
    "snippet": "static int f2fs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (f2fs_empty_dir(inode))\n\t\treturn f2fs_unlink(dir, dentry);\n\treturn -ENOTEMPTY;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/dcache.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_unlink",
          "args": [
            "dir",
            "dentry"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/namei.c",
          "lines": "214-248",
          "snippet": "static int f2fs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tstruct inode *inode = dentry->d_inode;\n\tstruct f2fs_dir_entry *de;\n\tstruct page *page;\n\tint err = -ENOENT;\n\n\ttrace_f2fs_unlink_enter(dir, dentry);\n\tf2fs_balance_fs(sbi);\n\n\tde = f2fs_find_entry(dir, &dentry->d_name, &page);\n\tif (!de)\n\t\tgoto fail;\n\n\tf2fs_lock_op(sbi);\n\terr = acquire_orphan_inode(sbi);\n\tif (err) {\n\t\tf2fs_unlock_op(sbi);\n\t\tf2fs_dentry_kunmap(dir, page);\n\t\tf2fs_put_page(page, 0);\n\t\tgoto fail;\n\t}\n\tf2fs_delete_entry(de, page, dir, inode);\n\tf2fs_unlock_op(sbi);\n\n\t/* In order to evict this inode, we set it dirty */\n\tmark_inode_dirty(inode);\n\n\tif (IS_DIRSYNC(dir))\n\t\tf2fs_sync_fs(sbi->sb, 1);\nfail:\n\ttrace_f2fs_unlink_exit(inode, err);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/dcache.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int f2fs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tstruct inode *inode = dentry->d_inode;\n\tstruct f2fs_dir_entry *de;\n\tstruct page *page;\n\tint err = -ENOENT;\n\n\ttrace_f2fs_unlink_enter(dir, dentry);\n\tf2fs_balance_fs(sbi);\n\n\tde = f2fs_find_entry(dir, &dentry->d_name, &page);\n\tif (!de)\n\t\tgoto fail;\n\n\tf2fs_lock_op(sbi);\n\terr = acquire_orphan_inode(sbi);\n\tif (err) {\n\t\tf2fs_unlock_op(sbi);\n\t\tf2fs_dentry_kunmap(dir, page);\n\t\tf2fs_put_page(page, 0);\n\t\tgoto fail;\n\t}\n\tf2fs_delete_entry(de, page, dir, inode);\n\tf2fs_unlock_op(sbi);\n\n\t/* In order to evict this inode, we set it dirty */\n\tmark_inode_dirty(inode);\n\n\tif (IS_DIRSYNC(dir))\n\t\tf2fs_sync_fs(sbi->sb, 1);\nfail:\n\ttrace_f2fs_unlink_exit(inode, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_empty_dir",
          "args": [
            "inode"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_empty_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "678-714",
          "snippet": "bool f2fs_empty_dir(struct inode *dir)\n{\n\tunsigned long bidx;\n\tstruct page *dentry_page;\n\tunsigned int bit_pos;\n\tstruct f2fs_dentry_block *dentry_blk;\n\tunsigned long nblock = dir_blocks(dir);\n\n\tif (f2fs_has_inline_dentry(dir))\n\t\treturn f2fs_empty_inline_dir(dir);\n\n\tfor (bidx = 0; bidx < nblock; bidx++) {\n\t\tdentry_page = get_lock_data_page(dir, bidx);\n\t\tif (IS_ERR(dentry_page)) {\n\t\t\tif (PTR_ERR(dentry_page) == -ENOENT)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\n\t\tdentry_blk = kmap_atomic(dentry_page);\n\t\tif (bidx == 0)\n\t\t\tbit_pos = 2;\n\t\telse\n\t\t\tbit_pos = 0;\n\t\tbit_pos = find_next_bit_le(&dentry_blk->dentry_bitmap,\n\t\t\t\t\t\tNR_DENTRY_IN_BLOCK,\n\t\t\t\t\t\tbit_pos);\n\t\tkunmap_atomic(dentry_blk);\n\n\t\tf2fs_put_page(dentry_page, 1);\n\n\t\tif (bit_pos < NR_DENTRY_IN_BLOCK)\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nbool f2fs_empty_dir(struct inode *dir)\n{\n\tunsigned long bidx;\n\tstruct page *dentry_page;\n\tunsigned int bit_pos;\n\tstruct f2fs_dentry_block *dentry_blk;\n\tunsigned long nblock = dir_blocks(dir);\n\n\tif (f2fs_has_inline_dentry(dir))\n\t\treturn f2fs_empty_inline_dir(dir);\n\n\tfor (bidx = 0; bidx < nblock; bidx++) {\n\t\tdentry_page = get_lock_data_page(dir, bidx);\n\t\tif (IS_ERR(dentry_page)) {\n\t\t\tif (PTR_ERR(dentry_page) == -ENOENT)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\n\t\tdentry_blk = kmap_atomic(dentry_page);\n\t\tif (bidx == 0)\n\t\t\tbit_pos = 2;\n\t\telse\n\t\t\tbit_pos = 0;\n\t\tbit_pos = find_next_bit_le(&dentry_blk->dentry_bitmap,\n\t\t\t\t\t\tNR_DENTRY_IN_BLOCK,\n\t\t\t\t\t\tbit_pos);\n\t\tkunmap_atomic(dentry_blk);\n\n\t\tf2fs_put_page(dentry_page, 1);\n\n\t\tif (bit_pos < NR_DENTRY_IN_BLOCK)\n\t\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int f2fs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (f2fs_empty_dir(inode))\n\t\treturn f2fs_unlink(dir, dentry);\n\treturn -ENOTEMPTY;\n}"
  },
  {
    "function_name": "f2fs_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/namei.c",
    "lines": "287-325",
    "snippet": "static int f2fs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tstruct inode *inode;\n\tint err;\n\n\tf2fs_balance_fs(sbi);\n\n\tinode = f2fs_new_inode(dir, S_IFDIR | mode);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tinode->i_op = &f2fs_dir_inode_operations;\n\tinode->i_fop = &f2fs_dir_operations;\n\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_HIGH_ZERO);\n\n\tset_inode_flag(F2FS_I(inode), FI_INC_LINK);\n\tf2fs_lock_op(sbi);\n\terr = f2fs_add_link(dentry, inode);\n\tif (err)\n\t\tgoto out_fail;\n\tf2fs_unlock_op(sbi);\n\n\tstat_inc_inline_dir(inode);\n\talloc_nid_done(sbi, inode->i_ino);\n\n\td_instantiate(dentry, inode);\n\tunlock_new_inode(inode);\n\n\tif (IS_DIRSYNC(dir))\n\t\tf2fs_sync_fs(sbi->sb, 1);\n\treturn 0;\n\nout_fail:\n\tclear_inode_flag(F2FS_I(inode), FI_INC_LINK);\n\thandle_failed_inode(inode);\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/dcache.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct inode_operations f2fs_dir_inode_operations = {\n\t.create\t\t= f2fs_create,\n\t.lookup\t\t= f2fs_lookup,\n\t.link\t\t= f2fs_link,\n\t.unlink\t\t= f2fs_unlink,\n\t.symlink\t= f2fs_symlink,\n\t.mkdir\t\t= f2fs_mkdir,\n\t.rmdir\t\t= f2fs_rmdir,\n\t.mknod\t\t= f2fs_mknod,\n\t.rename2\t= f2fs_rename2,\n\t.tmpfile\t= f2fs_tmpfile,\n\t.getattr\t= f2fs_getattr,\n\t.setattr\t= f2fs_setattr,\n\t.get_acl\t= f2fs_get_acl,\n\t.set_acl\t= f2fs_set_acl,\n#ifdef CONFIG_F2FS_FS_XATTR\n\t.setxattr\t= generic_setxattr,\n\t.getxattr\t= generic_getxattr,\n\t.listxattr\t= f2fs_listxattr,\n\t.removexattr\t= generic_removexattr,\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "handle_failed_inode",
          "args": [
            "inode"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "handle_failed_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
          "lines": "343-364",
          "snippet": "void handle_failed_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\n\tclear_nlink(inode);\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\n\ti_size_write(inode, 0);\n\tif (F2FS_HAS_BLOCKS(inode))\n\t\tf2fs_truncate(inode);\n\n\tremove_inode_page(inode);\n\n\tclear_inode_flag(F2FS_I(inode), FI_INLINE_DATA);\n\tclear_inode_flag(F2FS_I(inode), FI_INLINE_DENTRY);\n\talloc_nid_failed(sbi, inode->i_ino);\n\tf2fs_unlock_op(sbi);\n\n\t/* iput will drop the inode object */\n\tiput(inode);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid handle_failed_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\n\tclear_nlink(inode);\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\n\ti_size_write(inode, 0);\n\tif (F2FS_HAS_BLOCKS(inode))\n\t\tf2fs_truncate(inode);\n\n\tremove_inode_page(inode);\n\n\tclear_inode_flag(F2FS_I(inode), FI_INLINE_DATA);\n\tclear_inode_flag(F2FS_I(inode), FI_INLINE_DENTRY);\n\talloc_nid_failed(sbi, inode->i_ino);\n\tf2fs_unlock_op(sbi);\n\n\t/* iput will drop the inode object */\n\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_inode_flag",
          "args": [
            "F2FS_I(inode)",
            "FI_INC_LINK"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1184-1188",
          "snippet": "static inline void clear_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (test_bit(flag, &fi->flags))\n\t\tclear_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void clear_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (test_bit(flag, &fi->flags))\n\t\tclear_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_sync_fs",
          "args": [
            "sbi->sb",
            "1"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_sync_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
          "lines": "496-516",
          "snippet": "int f2fs_sync_fs(struct super_block *sb, int sync)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\n\ttrace_f2fs_sync_fs(sb, sync);\n\n\tif (sync) {\n\t\tstruct cp_control cpc;\n\n\t\tcpc.reason = __get_cp_reason(sbi);\n\n\t\tmutex_lock(&sbi->gc_mutex);\n\t\twrite_checkpoint(sbi, &cpc);\n\t\tmutex_unlock(&sbi->gc_mutex);\n\t} else {\n\t\tf2fs_balance_fs(sbi);\n\t}\n\tf2fs_trace_ios(NULL, NULL, 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"gc.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/random.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/parser.h>",
            "#include <linux/kthread.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nint f2fs_sync_fs(struct super_block *sb, int sync)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\n\ttrace_f2fs_sync_fs(sb, sync);\n\n\tif (sync) {\n\t\tstruct cp_control cpc;\n\n\t\tcpc.reason = __get_cp_reason(sbi);\n\n\t\tmutex_lock(&sbi->gc_mutex);\n\t\twrite_checkpoint(sbi, &cpc);\n\t\tmutex_unlock(&sbi->gc_mutex);\n\t} else {\n\t\tf2fs_balance_fs(sbi);\n\t}\n\tf2fs_trace_ios(NULL, NULL, 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "dir"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_nid_done",
          "args": [
            "sbi",
            "inode->i_ino"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_nid_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1582-1594",
          "snippet": "void alloc_nid_done(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\n\tspin_lock(&nm_i->free_nid_list_lock);\n\ti = __lookup_free_nid_list(nm_i, nid);\n\tf2fs_bug_on(sbi, !i || i->state != NID_ALLOC);\n\t__del_from_free_nid_list(nm_i, i);\n\tspin_unlock(&nm_i->free_nid_list_lock);\n\n\tkmem_cache_free(free_nid_slab, i);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *free_nid_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *free_nid_slab;\n\nvoid alloc_nid_done(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\n\tspin_lock(&nm_i->free_nid_list_lock);\n\ti = __lookup_free_nid_list(nm_i, nid);\n\tf2fs_bug_on(sbi, !i || i->state != NID_ALLOC);\n\t__del_from_free_nid_list(nm_i, i);\n\tspin_unlock(&nm_i->free_nid_list_lock);\n\n\tkmem_cache_free(free_nid_slab, i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat_inc_inline_dir",
          "args": [
            "inode"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_unlock_op",
          "args": [
            "sbi"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_unlock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "760-763",
          "snippet": "static inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_add_link",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_add_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1392-1396",
          "snippet": "static inline int f2fs_add_link(struct dentry *dentry, struct inode *inode)\n{\n\treturn __f2fs_add_link(dentry->d_parent->d_inode, &dentry->d_name,\n\t\t\t\tinode);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_add_link(struct dentry *dentry, struct inode *inode)\n{\n\treturn __f2fs_add_link(dentry->d_parent->d_inode, &dentry->d_name,\n\t\t\t\tinode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_lock_op",
          "args": [
            "sbi"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_lock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "755-758",
          "snippet": "static inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tdown_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tdown_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_inode_flag",
          "args": [
            "F2FS_I(inode)",
            "FI_INC_LINK"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "set_inode_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1173-1177",
          "snippet": "static inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (!test_bit(flag, &fi->flags))\n\t\tset_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (!test_bit(flag, &fi->flags))\n\t\tset_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_set_gfp_mask",
          "args": [
            "inode->i_mapping",
            "GFP_F2FS_HIGH_ZERO"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_new_inode",
          "args": [
            "dir",
            "S_IFDIR | mode"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/namei.c",
          "lines": "24-77",
          "snippet": "static struct inode *f2fs_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tnid_t ino;\n\tstruct inode *inode;\n\tbool nid_free = false;\n\tint err;\n\n\tinode = new_inode(dir->i_sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tf2fs_lock_op(sbi);\n\tif (!alloc_nid(sbi, &ino)) {\n\t\tf2fs_unlock_op(sbi);\n\t\terr = -ENOSPC;\n\t\tgoto fail;\n\t}\n\tf2fs_unlock_op(sbi);\n\n\tinode_init_owner(inode, dir, mode);\n\n\tinode->i_ino = ino;\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_generation = sbi->s_next_generation++;\n\n\terr = insert_inode_locked(inode);\n\tif (err) {\n\t\terr = -EINVAL;\n\t\tnid_free = true;\n\t\tgoto out;\n\t}\n\n\tif (f2fs_may_inline(inode))\n\t\tset_inode_flag(F2FS_I(inode), FI_INLINE_DATA);\n\tif (test_opt(sbi, INLINE_DENTRY) && S_ISDIR(inode->i_mode))\n\t\tset_inode_flag(F2FS_I(inode), FI_INLINE_DENTRY);\n\n\ttrace_f2fs_new_inode(inode, 0);\n\tmark_inode_dirty(inode);\n\treturn inode;\n\nout:\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\nfail:\n\ttrace_f2fs_new_inode(inode, err);\n\tmake_bad_inode(inode);\n\tiput(inode);\n\tif (nid_free)\n\t\talloc_nid_failed(sbi, ino);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/dcache.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct inode *f2fs_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tnid_t ino;\n\tstruct inode *inode;\n\tbool nid_free = false;\n\tint err;\n\n\tinode = new_inode(dir->i_sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tf2fs_lock_op(sbi);\n\tif (!alloc_nid(sbi, &ino)) {\n\t\tf2fs_unlock_op(sbi);\n\t\terr = -ENOSPC;\n\t\tgoto fail;\n\t}\n\tf2fs_unlock_op(sbi);\n\n\tinode_init_owner(inode, dir, mode);\n\n\tinode->i_ino = ino;\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_generation = sbi->s_next_generation++;\n\n\terr = insert_inode_locked(inode);\n\tif (err) {\n\t\terr = -EINVAL;\n\t\tnid_free = true;\n\t\tgoto out;\n\t}\n\n\tif (f2fs_may_inline(inode))\n\t\tset_inode_flag(F2FS_I(inode), FI_INLINE_DATA);\n\tif (test_opt(sbi, INLINE_DENTRY) && S_ISDIR(inode->i_mode))\n\t\tset_inode_flag(F2FS_I(inode), FI_INLINE_DENTRY);\n\n\ttrace_f2fs_new_inode(inode, 0);\n\tmark_inode_dirty(inode);\n\treturn inode;\n\nout:\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\nfail:\n\ttrace_f2fs_new_inode(inode, err);\n\tmake_bad_inode(inode);\n\tiput(inode);\n\tif (nid_free)\n\t\talloc_nid_failed(sbi, ino);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_balance_fs",
          "args": [
            "sbi"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_balance_fs_bg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "278-285",
          "snippet": "void f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "dir"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nconst struct inode_operations f2fs_dir_inode_operations = {\n\t.create\t\t= f2fs_create,\n\t.lookup\t\t= f2fs_lookup,\n\t.link\t\t= f2fs_link,\n\t.unlink\t\t= f2fs_unlink,\n\t.symlink\t= f2fs_symlink,\n\t.mkdir\t\t= f2fs_mkdir,\n\t.rmdir\t\t= f2fs_rmdir,\n\t.mknod\t\t= f2fs_mknod,\n\t.rename2\t= f2fs_rename2,\n\t.tmpfile\t= f2fs_tmpfile,\n\t.getattr\t= f2fs_getattr,\n\t.setattr\t= f2fs_setattr,\n\t.get_acl\t= f2fs_get_acl,\n\t.set_acl\t= f2fs_set_acl,\n#ifdef CONFIG_F2FS_FS_XATTR\n\t.setxattr\t= generic_setxattr,\n\t.getxattr\t= generic_getxattr,\n\t.listxattr\t= f2fs_listxattr,\n\t.removexattr\t= generic_removexattr,\n#endif\n};\n\nstatic int f2fs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tstruct inode *inode;\n\tint err;\n\n\tf2fs_balance_fs(sbi);\n\n\tinode = f2fs_new_inode(dir, S_IFDIR | mode);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tinode->i_op = &f2fs_dir_inode_operations;\n\tinode->i_fop = &f2fs_dir_operations;\n\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_HIGH_ZERO);\n\n\tset_inode_flag(F2FS_I(inode), FI_INC_LINK);\n\tf2fs_lock_op(sbi);\n\terr = f2fs_add_link(dentry, inode);\n\tif (err)\n\t\tgoto out_fail;\n\tf2fs_unlock_op(sbi);\n\n\tstat_inc_inline_dir(inode);\n\talloc_nid_done(sbi, inode->i_ino);\n\n\td_instantiate(dentry, inode);\n\tunlock_new_inode(inode);\n\n\tif (IS_DIRSYNC(dir))\n\t\tf2fs_sync_fs(sbi->sb, 1);\n\treturn 0;\n\nout_fail:\n\tclear_inode_flag(F2FS_I(inode), FI_INC_LINK);\n\thandle_failed_inode(inode);\n\treturn err;\n}"
  },
  {
    "function_name": "f2fs_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/namei.c",
    "lines": "250-285",
    "snippet": "static int f2fs_symlink(struct inode *dir, struct dentry *dentry,\n\t\t\t\t\tconst char *symname)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tstruct inode *inode;\n\tsize_t symlen = strlen(symname) + 1;\n\tint err;\n\n\tf2fs_balance_fs(sbi);\n\n\tinode = f2fs_new_inode(dir, S_IFLNK | S_IRWXUGO);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tinode->i_op = &f2fs_symlink_inode_operations;\n\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\n\tf2fs_lock_op(sbi);\n\terr = f2fs_add_link(dentry, inode);\n\tif (err)\n\t\tgoto out;\n\tf2fs_unlock_op(sbi);\n\n\terr = page_symlink(inode, symname, symlen);\n\talloc_nid_done(sbi, inode->i_ino);\n\n\td_instantiate(dentry, inode);\n\tunlock_new_inode(inode);\n\n\tif (IS_DIRSYNC(dir))\n\t\tf2fs_sync_fs(sbi->sb, 1);\n\treturn err;\nout:\n\thandle_failed_inode(inode);\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/dcache.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct inode_operations f2fs_symlink_inode_operations = {\n\t.readlink       = generic_readlink,\n\t.follow_link    = page_follow_link_light,\n\t.put_link       = page_put_link,\n\t.getattr\t= f2fs_getattr,\n\t.setattr\t= f2fs_setattr,\n#ifdef CONFIG_F2FS_FS_XATTR\n\t.setxattr\t= generic_setxattr,\n\t.getxattr\t= generic_getxattr,\n\t.listxattr\t= f2fs_listxattr,\n\t.removexattr\t= generic_removexattr,\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "handle_failed_inode",
          "args": [
            "inode"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "handle_failed_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
          "lines": "343-364",
          "snippet": "void handle_failed_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\n\tclear_nlink(inode);\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\n\ti_size_write(inode, 0);\n\tif (F2FS_HAS_BLOCKS(inode))\n\t\tf2fs_truncate(inode);\n\n\tremove_inode_page(inode);\n\n\tclear_inode_flag(F2FS_I(inode), FI_INLINE_DATA);\n\tclear_inode_flag(F2FS_I(inode), FI_INLINE_DENTRY);\n\talloc_nid_failed(sbi, inode->i_ino);\n\tf2fs_unlock_op(sbi);\n\n\t/* iput will drop the inode object */\n\tiput(inode);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid handle_failed_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\n\tclear_nlink(inode);\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\n\ti_size_write(inode, 0);\n\tif (F2FS_HAS_BLOCKS(inode))\n\t\tf2fs_truncate(inode);\n\n\tremove_inode_page(inode);\n\n\tclear_inode_flag(F2FS_I(inode), FI_INLINE_DATA);\n\tclear_inode_flag(F2FS_I(inode), FI_INLINE_DENTRY);\n\talloc_nid_failed(sbi, inode->i_ino);\n\tf2fs_unlock_op(sbi);\n\n\t/* iput will drop the inode object */\n\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_sync_fs",
          "args": [
            "sbi->sb",
            "1"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_sync_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
          "lines": "496-516",
          "snippet": "int f2fs_sync_fs(struct super_block *sb, int sync)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\n\ttrace_f2fs_sync_fs(sb, sync);\n\n\tif (sync) {\n\t\tstruct cp_control cpc;\n\n\t\tcpc.reason = __get_cp_reason(sbi);\n\n\t\tmutex_lock(&sbi->gc_mutex);\n\t\twrite_checkpoint(sbi, &cpc);\n\t\tmutex_unlock(&sbi->gc_mutex);\n\t} else {\n\t\tf2fs_balance_fs(sbi);\n\t}\n\tf2fs_trace_ios(NULL, NULL, 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"gc.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/random.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/parser.h>",
            "#include <linux/kthread.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nint f2fs_sync_fs(struct super_block *sb, int sync)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\n\ttrace_f2fs_sync_fs(sb, sync);\n\n\tif (sync) {\n\t\tstruct cp_control cpc;\n\n\t\tcpc.reason = __get_cp_reason(sbi);\n\n\t\tmutex_lock(&sbi->gc_mutex);\n\t\twrite_checkpoint(sbi, &cpc);\n\t\tmutex_unlock(&sbi->gc_mutex);\n\t} else {\n\t\tf2fs_balance_fs(sbi);\n\t}\n\tf2fs_trace_ios(NULL, NULL, 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "dir"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_nid_done",
          "args": [
            "sbi",
            "inode->i_ino"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_nid_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1582-1594",
          "snippet": "void alloc_nid_done(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\n\tspin_lock(&nm_i->free_nid_list_lock);\n\ti = __lookup_free_nid_list(nm_i, nid);\n\tf2fs_bug_on(sbi, !i || i->state != NID_ALLOC);\n\t__del_from_free_nid_list(nm_i, i);\n\tspin_unlock(&nm_i->free_nid_list_lock);\n\n\tkmem_cache_free(free_nid_slab, i);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *free_nid_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *free_nid_slab;\n\nvoid alloc_nid_done(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\n\tspin_lock(&nm_i->free_nid_list_lock);\n\ti = __lookup_free_nid_list(nm_i, nid);\n\tf2fs_bug_on(sbi, !i || i->state != NID_ALLOC);\n\t__del_from_free_nid_list(nm_i, i);\n\tspin_unlock(&nm_i->free_nid_list_lock);\n\n\tkmem_cache_free(free_nid_slab, i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_symlink",
          "args": [
            "inode",
            "symname",
            "symlen"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "page_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "4532-4536",
          "snippet": "int page_symlink(struct inode *inode, const char *symname, int len)\n{\n\treturn __page_symlink(inode, symname, len,\n\t\t\t!(mapping_gfp_mask(inode->i_mapping) & __GFP_FS));\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint page_symlink(struct inode *inode, const char *symname, int len)\n{\n\treturn __page_symlink(inode, symname, len,\n\t\t\t!(mapping_gfp_mask(inode->i_mapping) & __GFP_FS));\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_unlock_op",
          "args": [
            "sbi"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_unlock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "760-763",
          "snippet": "static inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_add_link",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_add_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1392-1396",
          "snippet": "static inline int f2fs_add_link(struct dentry *dentry, struct inode *inode)\n{\n\treturn __f2fs_add_link(dentry->d_parent->d_inode, &dentry->d_name,\n\t\t\t\tinode);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_add_link(struct dentry *dentry, struct inode *inode)\n{\n\treturn __f2fs_add_link(dentry->d_parent->d_inode, &dentry->d_name,\n\t\t\t\tinode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_lock_op",
          "args": [
            "sbi"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_lock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "755-758",
          "snippet": "static inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tdown_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tdown_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_new_inode",
          "args": [
            "dir",
            "S_IFLNK | S_IRWXUGO"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/namei.c",
          "lines": "24-77",
          "snippet": "static struct inode *f2fs_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tnid_t ino;\n\tstruct inode *inode;\n\tbool nid_free = false;\n\tint err;\n\n\tinode = new_inode(dir->i_sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tf2fs_lock_op(sbi);\n\tif (!alloc_nid(sbi, &ino)) {\n\t\tf2fs_unlock_op(sbi);\n\t\terr = -ENOSPC;\n\t\tgoto fail;\n\t}\n\tf2fs_unlock_op(sbi);\n\n\tinode_init_owner(inode, dir, mode);\n\n\tinode->i_ino = ino;\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_generation = sbi->s_next_generation++;\n\n\terr = insert_inode_locked(inode);\n\tif (err) {\n\t\terr = -EINVAL;\n\t\tnid_free = true;\n\t\tgoto out;\n\t}\n\n\tif (f2fs_may_inline(inode))\n\t\tset_inode_flag(F2FS_I(inode), FI_INLINE_DATA);\n\tif (test_opt(sbi, INLINE_DENTRY) && S_ISDIR(inode->i_mode))\n\t\tset_inode_flag(F2FS_I(inode), FI_INLINE_DENTRY);\n\n\ttrace_f2fs_new_inode(inode, 0);\n\tmark_inode_dirty(inode);\n\treturn inode;\n\nout:\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\nfail:\n\ttrace_f2fs_new_inode(inode, err);\n\tmake_bad_inode(inode);\n\tiput(inode);\n\tif (nid_free)\n\t\talloc_nid_failed(sbi, ino);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/dcache.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct inode *f2fs_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tnid_t ino;\n\tstruct inode *inode;\n\tbool nid_free = false;\n\tint err;\n\n\tinode = new_inode(dir->i_sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tf2fs_lock_op(sbi);\n\tif (!alloc_nid(sbi, &ino)) {\n\t\tf2fs_unlock_op(sbi);\n\t\terr = -ENOSPC;\n\t\tgoto fail;\n\t}\n\tf2fs_unlock_op(sbi);\n\n\tinode_init_owner(inode, dir, mode);\n\n\tinode->i_ino = ino;\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_generation = sbi->s_next_generation++;\n\n\terr = insert_inode_locked(inode);\n\tif (err) {\n\t\terr = -EINVAL;\n\t\tnid_free = true;\n\t\tgoto out;\n\t}\n\n\tif (f2fs_may_inline(inode))\n\t\tset_inode_flag(F2FS_I(inode), FI_INLINE_DATA);\n\tif (test_opt(sbi, INLINE_DENTRY) && S_ISDIR(inode->i_mode))\n\t\tset_inode_flag(F2FS_I(inode), FI_INLINE_DENTRY);\n\n\ttrace_f2fs_new_inode(inode, 0);\n\tmark_inode_dirty(inode);\n\treturn inode;\n\nout:\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\nfail:\n\ttrace_f2fs_new_inode(inode, err);\n\tmake_bad_inode(inode);\n\tiput(inode);\n\tif (nid_free)\n\t\talloc_nid_failed(sbi, ino);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_balance_fs",
          "args": [
            "sbi"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_balance_fs_bg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "278-285",
          "snippet": "void f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "symname"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "dir"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nconst struct inode_operations f2fs_symlink_inode_operations = {\n\t.readlink       = generic_readlink,\n\t.follow_link    = page_follow_link_light,\n\t.put_link       = page_put_link,\n\t.getattr\t= f2fs_getattr,\n\t.setattr\t= f2fs_setattr,\n#ifdef CONFIG_F2FS_FS_XATTR\n\t.setxattr\t= generic_setxattr,\n\t.getxattr\t= generic_getxattr,\n\t.listxattr\t= f2fs_listxattr,\n\t.removexattr\t= generic_removexattr,\n#endif\n};\n\nstatic int f2fs_symlink(struct inode *dir, struct dentry *dentry,\n\t\t\t\t\tconst char *symname)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tstruct inode *inode;\n\tsize_t symlen = strlen(symname) + 1;\n\tint err;\n\n\tf2fs_balance_fs(sbi);\n\n\tinode = f2fs_new_inode(dir, S_IFLNK | S_IRWXUGO);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tinode->i_op = &f2fs_symlink_inode_operations;\n\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\n\tf2fs_lock_op(sbi);\n\terr = f2fs_add_link(dentry, inode);\n\tif (err)\n\t\tgoto out;\n\tf2fs_unlock_op(sbi);\n\n\terr = page_symlink(inode, symname, symlen);\n\talloc_nid_done(sbi, inode->i_ino);\n\n\td_instantiate(dentry, inode);\n\tunlock_new_inode(inode);\n\n\tif (IS_DIRSYNC(dir))\n\t\tf2fs_sync_fs(sbi->sb, 1);\n\treturn err;\nout:\n\thandle_failed_inode(inode);\n\treturn err;\n}"
  },
  {
    "function_name": "f2fs_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/namei.c",
    "lines": "214-248",
    "snippet": "static int f2fs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tstruct inode *inode = dentry->d_inode;\n\tstruct f2fs_dir_entry *de;\n\tstruct page *page;\n\tint err = -ENOENT;\n\n\ttrace_f2fs_unlink_enter(dir, dentry);\n\tf2fs_balance_fs(sbi);\n\n\tde = f2fs_find_entry(dir, &dentry->d_name, &page);\n\tif (!de)\n\t\tgoto fail;\n\n\tf2fs_lock_op(sbi);\n\terr = acquire_orphan_inode(sbi);\n\tif (err) {\n\t\tf2fs_unlock_op(sbi);\n\t\tf2fs_dentry_kunmap(dir, page);\n\t\tf2fs_put_page(page, 0);\n\t\tgoto fail;\n\t}\n\tf2fs_delete_entry(de, page, dir, inode);\n\tf2fs_unlock_op(sbi);\n\n\t/* In order to evict this inode, we set it dirty */\n\tmark_inode_dirty(inode);\n\n\tif (IS_DIRSYNC(dir))\n\t\tf2fs_sync_fs(sbi->sb, 1);\nfail:\n\ttrace_f2fs_unlink_exit(inode, err);\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/dcache.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_f2fs_unlink_exit",
          "args": [
            "inode",
            "err"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_sync_fs",
          "args": [
            "sbi->sb",
            "1"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_sync_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
          "lines": "496-516",
          "snippet": "int f2fs_sync_fs(struct super_block *sb, int sync)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\n\ttrace_f2fs_sync_fs(sb, sync);\n\n\tif (sync) {\n\t\tstruct cp_control cpc;\n\n\t\tcpc.reason = __get_cp_reason(sbi);\n\n\t\tmutex_lock(&sbi->gc_mutex);\n\t\twrite_checkpoint(sbi, &cpc);\n\t\tmutex_unlock(&sbi->gc_mutex);\n\t} else {\n\t\tf2fs_balance_fs(sbi);\n\t}\n\tf2fs_trace_ios(NULL, NULL, 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"gc.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/random.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/parser.h>",
            "#include <linux/kthread.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nint f2fs_sync_fs(struct super_block *sb, int sync)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\n\ttrace_f2fs_sync_fs(sb, sync);\n\n\tif (sync) {\n\t\tstruct cp_control cpc;\n\n\t\tcpc.reason = __get_cp_reason(sbi);\n\n\t\tmutex_lock(&sbi->gc_mutex);\n\t\twrite_checkpoint(sbi, &cpc);\n\t\tmutex_unlock(&sbi->gc_mutex);\n\t} else {\n\t\tf2fs_balance_fs(sbi);\n\t}\n\tf2fs_trace_ios(NULL, NULL, 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "dir"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_unlock_op",
          "args": [
            "sbi"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_unlock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "760-763",
          "snippet": "static inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_delete_entry",
          "args": [
            "de",
            "page",
            "dir",
            "inode"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_delete_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "638-676",
          "snippet": "void f2fs_delete_entry(struct f2fs_dir_entry *dentry, struct page *page,\n\t\t\t\t\tstruct inode *dir, struct inode *inode)\n{\n\tstruct\tf2fs_dentry_block *dentry_blk;\n\tunsigned int bit_pos;\n\tint slots = GET_DENTRY_SLOTS(le16_to_cpu(dentry->name_len));\n\tint i;\n\n\tif (f2fs_has_inline_dentry(dir))\n\t\treturn f2fs_delete_inline_entry(dentry, page, dir, inode);\n\n\tlock_page(page);\n\tf2fs_wait_on_page_writeback(page, DATA);\n\n\tdentry_blk = page_address(page);\n\tbit_pos = dentry - dentry_blk->dentry;\n\tfor (i = 0; i < slots; i++)\n\t\tclear_bit_le(bit_pos + i, &dentry_blk->dentry_bitmap);\n\n\t/* Let's check and deallocate this dentry page */\n\tbit_pos = find_next_bit_le(&dentry_blk->dentry_bitmap,\n\t\t\tNR_DENTRY_IN_BLOCK,\n\t\t\t0);\n\tkunmap(page); /* kunmap - pair of f2fs_find_entry */\n\tset_page_dirty(page);\n\n\tdir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\n\tif (inode)\n\t\tf2fs_drop_nlink(dir, inode, NULL);\n\n\tif (bit_pos == NR_DENTRY_IN_BLOCK) {\n\t\ttruncate_hole(dir, page->index, page->index + 1);\n\t\tclear_page_dirty_for_io(page);\n\t\tClearPageUptodate(page);\n\t\tinode_dec_dirty_pages(dir);\n\t}\n\tf2fs_put_page(page, 1);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_delete_entry(struct f2fs_dir_entry *dentry, struct page *page,\n\t\t\t\t\tstruct inode *dir, struct inode *inode)\n{\n\tstruct\tf2fs_dentry_block *dentry_blk;\n\tunsigned int bit_pos;\n\tint slots = GET_DENTRY_SLOTS(le16_to_cpu(dentry->name_len));\n\tint i;\n\n\tif (f2fs_has_inline_dentry(dir))\n\t\treturn f2fs_delete_inline_entry(dentry, page, dir, inode);\n\n\tlock_page(page);\n\tf2fs_wait_on_page_writeback(page, DATA);\n\n\tdentry_blk = page_address(page);\n\tbit_pos = dentry - dentry_blk->dentry;\n\tfor (i = 0; i < slots; i++)\n\t\tclear_bit_le(bit_pos + i, &dentry_blk->dentry_bitmap);\n\n\t/* Let's check and deallocate this dentry page */\n\tbit_pos = find_next_bit_le(&dentry_blk->dentry_bitmap,\n\t\t\tNR_DENTRY_IN_BLOCK,\n\t\t\t0);\n\tkunmap(page); /* kunmap - pair of f2fs_find_entry */\n\tset_page_dirty(page);\n\n\tdir->i_ctime = dir->i_mtime = CURRENT_TIME;\n\n\tif (inode)\n\t\tf2fs_drop_nlink(dir, inode, NULL);\n\n\tif (bit_pos == NR_DENTRY_IN_BLOCK) {\n\t\ttruncate_hole(dir, page->index, page->index + 1);\n\t\tclear_page_dirty_for_io(page);\n\t\tClearPageUptodate(page);\n\t\tinode_dec_dirty_pages(dir);\n\t}\n\tf2fs_put_page(page, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "page",
            "0"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_dentry_kunmap",
          "args": [
            "dir",
            "page"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_dentry_kunmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1299-1303",
          "snippet": "static inline void f2fs_dentry_kunmap(struct inode *dir, struct page *page)\n{\n\tif (!f2fs_has_inline_dentry(dir))\n\t\tkunmap(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_dentry_kunmap(struct inode *dir, struct page *page)\n{\n\tif (!f2fs_has_inline_dentry(dir))\n\t\tkunmap(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "acquire_orphan_inode",
          "args": [
            "sbi"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "acquire_orphan_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/checkpoint.c",
          "lines": "418-431",
          "snippet": "int acquire_orphan_inode(struct f2fs_sb_info *sbi)\n{\n\tstruct inode_management *im = &sbi->im[ORPHAN_INO];\n\tint err = 0;\n\n\tspin_lock(&im->ino_lock);\n\tif (unlikely(im->ino_num >= sbi->max_orphans))\n\t\terr = -ENOSPC;\n\telse\n\t\tim->ino_num++;\n\tspin_unlock(&im->ino_lock);\n\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n\nint acquire_orphan_inode(struct f2fs_sb_info *sbi)\n{\n\tstruct inode_management *im = &sbi->im[ORPHAN_INO];\n\tint err = 0;\n\n\tspin_lock(&im->ino_lock);\n\tif (unlikely(im->ino_num >= sbi->max_orphans))\n\t\terr = -ENOSPC;\n\telse\n\t\tim->ino_num++;\n\tspin_unlock(&im->ino_lock);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_lock_op",
          "args": [
            "sbi"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_lock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "755-758",
          "snippet": "static inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tdown_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tdown_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_find_entry",
          "args": [
            "dir",
            "&dentry->d_name",
            "&page"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "213-243",
          "snippet": "struct f2fs_dir_entry *f2fs_find_entry(struct inode *dir,\n\t\t\tstruct qstr *child, struct page **res_page)\n{\n\tunsigned long npages = dir_blocks(dir);\n\tstruct f2fs_dir_entry *de = NULL;\n\tf2fs_hash_t name_hash;\n\tunsigned int max_depth;\n\tunsigned int level;\n\n\tif (f2fs_has_inline_dentry(dir))\n\t\treturn find_in_inline_dir(dir, child, res_page);\n\n\tif (npages == 0)\n\t\treturn NULL;\n\n\t*res_page = NULL;\n\n\tname_hash = f2fs_dentry_hash(child);\n\tmax_depth = F2FS_I(dir)->i_current_depth;\n\n\tfor (level = 0; level < max_depth; level++) {\n\t\tde = find_in_level(dir, level, child, name_hash, res_page);\n\t\tif (de)\n\t\t\tbreak;\n\t}\n\tif (!de && F2FS_I(dir)->chash != name_hash) {\n\t\tF2FS_I(dir)->chash = name_hash;\n\t\tF2FS_I(dir)->clevel = level - 1;\n\t}\n\treturn de;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct f2fs_dir_entry *f2fs_find_entry(struct inode *dir,\n\t\t\tstruct qstr *child, struct page **res_page)\n{\n\tunsigned long npages = dir_blocks(dir);\n\tstruct f2fs_dir_entry *de = NULL;\n\tf2fs_hash_t name_hash;\n\tunsigned int max_depth;\n\tunsigned int level;\n\n\tif (f2fs_has_inline_dentry(dir))\n\t\treturn find_in_inline_dir(dir, child, res_page);\n\n\tif (npages == 0)\n\t\treturn NULL;\n\n\t*res_page = NULL;\n\n\tname_hash = f2fs_dentry_hash(child);\n\tmax_depth = F2FS_I(dir)->i_current_depth;\n\n\tfor (level = 0; level < max_depth; level++) {\n\t\tde = find_in_level(dir, level, child, name_hash, res_page);\n\t\tif (de)\n\t\t\tbreak;\n\t}\n\tif (!de && F2FS_I(dir)->chash != name_hash) {\n\t\tF2FS_I(dir)->chash = name_hash;\n\t\tF2FS_I(dir)->clevel = level - 1;\n\t}\n\treturn de;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_balance_fs",
          "args": [
            "sbi"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_balance_fs_bg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "278-285",
          "snippet": "void f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_f2fs_unlink_enter",
          "args": [
            "dir",
            "dentry"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "dir"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int f2fs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tstruct inode *inode = dentry->d_inode;\n\tstruct f2fs_dir_entry *de;\n\tstruct page *page;\n\tint err = -ENOENT;\n\n\ttrace_f2fs_unlink_enter(dir, dentry);\n\tf2fs_balance_fs(sbi);\n\n\tde = f2fs_find_entry(dir, &dentry->d_name, &page);\n\tif (!de)\n\t\tgoto fail;\n\n\tf2fs_lock_op(sbi);\n\terr = acquire_orphan_inode(sbi);\n\tif (err) {\n\t\tf2fs_unlock_op(sbi);\n\t\tf2fs_dentry_kunmap(dir, page);\n\t\tf2fs_put_page(page, 0);\n\t\tgoto fail;\n\t}\n\tf2fs_delete_entry(de, page, dir, inode);\n\tf2fs_unlock_op(sbi);\n\n\t/* In order to evict this inode, we set it dirty */\n\tmark_inode_dirty(inode);\n\n\tif (IS_DIRSYNC(dir))\n\t\tf2fs_sync_fs(sbi->sb, 1);\nfail:\n\ttrace_f2fs_unlink_exit(inode, err);\n\treturn err;\n}"
  },
  {
    "function_name": "f2fs_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/namei.c",
    "lines": "190-212",
    "snippet": "static struct dentry *f2fs_lookup(struct inode *dir, struct dentry *dentry,\n\t\tunsigned int flags)\n{\n\tstruct inode *inode = NULL;\n\tstruct f2fs_dir_entry *de;\n\tstruct page *page;\n\n\tif (dentry->d_name.len > F2FS_NAME_LEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tde = f2fs_find_entry(dir, &dentry->d_name, &page);\n\tif (de) {\n\t\tnid_t ino = le32_to_cpu(de->ino);\n\t\tf2fs_dentry_kunmap(dir, page);\n\t\tf2fs_put_page(page, 0);\n\n\t\tinode = f2fs_iget(dir->i_sb, ino);\n\t\tif (IS_ERR(inode))\n\t\t\treturn ERR_CAST(inode);\n\t}\n\n\treturn d_splice_alias(inode, dentry);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/dcache.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_splice_alias",
          "args": [
            "inode",
            "dentry"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "d_splice_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2741-2792",
          "snippet": "struct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nstruct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "inode"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_iget",
          "args": [
            "dir->i_sb",
            "ino"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
          "lines": "151-206",
          "snippet": "struct inode *f2fs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tstruct inode *inode;\n\tint ret = 0;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!(inode->i_state & I_NEW)) {\n\t\ttrace_f2fs_iget(inode);\n\t\treturn inode;\n\t}\n\tif (ino == F2FS_NODE_INO(sbi) || ino == F2FS_META_INO(sbi))\n\t\tgoto make_now;\n\n\tret = do_read_inode(inode);\n\tif (ret)\n\t\tgoto bad_inode;\nmake_now:\n\tif (ino == F2FS_NODE_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_node_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_ZERO);\n\t} else if (ino == F2FS_META_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_meta_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_ZERO);\n\t} else if (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_file_inode_operations;\n\t\tinode->i_fop = &f2fs_file_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_dir_inode_operations;\n\t\tinode->i_fop = &f2fs_dir_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_HIGH_ZERO);\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) ||\n\t\t\tS_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_special_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t} else {\n\t\tret = -EIO;\n\t\tgoto bad_inode;\n\t}\n\tunlock_new_inode(inode);\n\ttrace_f2fs_iget(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\ttrace_f2fs_iget_exit(inode, ret);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct inode *f2fs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tstruct inode *inode;\n\tint ret = 0;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!(inode->i_state & I_NEW)) {\n\t\ttrace_f2fs_iget(inode);\n\t\treturn inode;\n\t}\n\tif (ino == F2FS_NODE_INO(sbi) || ino == F2FS_META_INO(sbi))\n\t\tgoto make_now;\n\n\tret = do_read_inode(inode);\n\tif (ret)\n\t\tgoto bad_inode;\nmake_now:\n\tif (ino == F2FS_NODE_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_node_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_ZERO);\n\t} else if (ino == F2FS_META_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_meta_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_ZERO);\n\t} else if (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_file_inode_operations;\n\t\tinode->i_fop = &f2fs_file_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_dir_inode_operations;\n\t\tinode->i_fop = &f2fs_dir_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_HIGH_ZERO);\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) ||\n\t\t\tS_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_special_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t} else {\n\t\tret = -EIO;\n\t\tgoto bad_inode;\n\t}\n\tunlock_new_inode(inode);\n\ttrace_f2fs_iget(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\ttrace_f2fs_iget_exit(inode, ret);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_put_page",
          "args": [
            "page",
            "0"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1036-1046",
          "snippet": "static inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_put_page(struct page *page, int unlock)\n{\n\tif (!page)\n\t\treturn;\n\n\tif (unlock) {\n\t\tf2fs_bug_on(F2FS_P_SB(page), !PageLocked(page));\n\t\tunlock_page(page);\n\t}\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_dentry_kunmap",
          "args": [
            "dir",
            "page"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_dentry_kunmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1299-1303",
          "snippet": "static inline void f2fs_dentry_kunmap(struct inode *dir, struct page *page)\n{\n\tif (!f2fs_has_inline_dentry(dir))\n\t\tkunmap(page);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_dentry_kunmap(struct inode *dir, struct page *page)\n{\n\tif (!f2fs_has_inline_dentry(dir))\n\t\tkunmap(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "de->ino"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_find_entry",
          "args": [
            "dir",
            "&dentry->d_name",
            "&page"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "213-243",
          "snippet": "struct f2fs_dir_entry *f2fs_find_entry(struct inode *dir,\n\t\t\tstruct qstr *child, struct page **res_page)\n{\n\tunsigned long npages = dir_blocks(dir);\n\tstruct f2fs_dir_entry *de = NULL;\n\tf2fs_hash_t name_hash;\n\tunsigned int max_depth;\n\tunsigned int level;\n\n\tif (f2fs_has_inline_dentry(dir))\n\t\treturn find_in_inline_dir(dir, child, res_page);\n\n\tif (npages == 0)\n\t\treturn NULL;\n\n\t*res_page = NULL;\n\n\tname_hash = f2fs_dentry_hash(child);\n\tmax_depth = F2FS_I(dir)->i_current_depth;\n\n\tfor (level = 0; level < max_depth; level++) {\n\t\tde = find_in_level(dir, level, child, name_hash, res_page);\n\t\tif (de)\n\t\t\tbreak;\n\t}\n\tif (!de && F2FS_I(dir)->chash != name_hash) {\n\t\tF2FS_I(dir)->chash = name_hash;\n\t\tF2FS_I(dir)->clevel = level - 1;\n\t}\n\treturn de;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct f2fs_dir_entry *f2fs_find_entry(struct inode *dir,\n\t\t\tstruct qstr *child, struct page **res_page)\n{\n\tunsigned long npages = dir_blocks(dir);\n\tstruct f2fs_dir_entry *de = NULL;\n\tf2fs_hash_t name_hash;\n\tunsigned int max_depth;\n\tunsigned int level;\n\n\tif (f2fs_has_inline_dentry(dir))\n\t\treturn find_in_inline_dir(dir, child, res_page);\n\n\tif (npages == 0)\n\t\treturn NULL;\n\n\t*res_page = NULL;\n\n\tname_hash = f2fs_dentry_hash(child);\n\tmax_depth = F2FS_I(dir)->i_current_depth;\n\n\tfor (level = 0; level < max_depth; level++) {\n\t\tde = find_in_level(dir, level, child, name_hash, res_page);\n\t\tif (de)\n\t\t\tbreak;\n\t}\n\tif (!de && F2FS_I(dir)->chash != name_hash) {\n\t\tF2FS_I(dir)->chash = name_hash;\n\t\tF2FS_I(dir)->clevel = level - 1;\n\t}\n\treturn de;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENAMETOOLONG"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct dentry *f2fs_lookup(struct inode *dir, struct dentry *dentry,\n\t\tunsigned int flags)\n{\n\tstruct inode *inode = NULL;\n\tstruct f2fs_dir_entry *de;\n\tstruct page *page;\n\n\tif (dentry->d_name.len > F2FS_NAME_LEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tde = f2fs_find_entry(dir, &dentry->d_name, &page);\n\tif (de) {\n\t\tnid_t ino = le32_to_cpu(de->ino);\n\t\tf2fs_dentry_kunmap(dir, page);\n\t\tf2fs_put_page(page, 0);\n\n\t\tinode = f2fs_iget(dir->i_sb, ino);\n\t\tif (IS_ERR(inode))\n\t\t\treturn ERR_CAST(inode);\n\t}\n\n\treturn d_splice_alias(inode, dentry);\n}"
  },
  {
    "function_name": "f2fs_get_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/namei.c",
    "lines": "181-188",
    "snippet": "struct dentry *f2fs_get_parent(struct dentry *child)\n{\n\tstruct qstr dotdot = QSTR_INIT(\"..\", 2);\n\tunsigned long ino = f2fs_inode_by_name(child->d_inode, &dotdot);\n\tif (!ino)\n\t\treturn ERR_PTR(-ENOENT);\n\treturn d_obtain_alias(f2fs_iget(child->d_inode->i_sb, ino));\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/dcache.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_obtain_alias",
          "args": [
            "f2fs_iget(child->d_inode->i_sb, ino)"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "d_obtain_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1977-1980",
          "snippet": "struct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_iget",
          "args": [
            "child->d_inode->i_sb",
            "ino"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
          "lines": "151-206",
          "snippet": "struct inode *f2fs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tstruct inode *inode;\n\tint ret = 0;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!(inode->i_state & I_NEW)) {\n\t\ttrace_f2fs_iget(inode);\n\t\treturn inode;\n\t}\n\tif (ino == F2FS_NODE_INO(sbi) || ino == F2FS_META_INO(sbi))\n\t\tgoto make_now;\n\n\tret = do_read_inode(inode);\n\tif (ret)\n\t\tgoto bad_inode;\nmake_now:\n\tif (ino == F2FS_NODE_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_node_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_ZERO);\n\t} else if (ino == F2FS_META_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_meta_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_ZERO);\n\t} else if (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_file_inode_operations;\n\t\tinode->i_fop = &f2fs_file_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_dir_inode_operations;\n\t\tinode->i_fop = &f2fs_dir_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_HIGH_ZERO);\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) ||\n\t\t\tS_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_special_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t} else {\n\t\tret = -EIO;\n\t\tgoto bad_inode;\n\t}\n\tunlock_new_inode(inode);\n\ttrace_f2fs_iget(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\ttrace_f2fs_iget_exit(inode, ret);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct inode *f2fs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tstruct inode *inode;\n\tint ret = 0;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!(inode->i_state & I_NEW)) {\n\t\ttrace_f2fs_iget(inode);\n\t\treturn inode;\n\t}\n\tif (ino == F2FS_NODE_INO(sbi) || ino == F2FS_META_INO(sbi))\n\t\tgoto make_now;\n\n\tret = do_read_inode(inode);\n\tif (ret)\n\t\tgoto bad_inode;\nmake_now:\n\tif (ino == F2FS_NODE_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_node_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_ZERO);\n\t} else if (ino == F2FS_META_INO(sbi)) {\n\t\tinode->i_mapping->a_ops = &f2fs_meta_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_ZERO);\n\t} else if (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_file_inode_operations;\n\t\tinode->i_fop = &f2fs_file_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_dir_inode_operations;\n\t\tinode->i_fop = &f2fs_dir_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t\tmapping_set_gfp_mask(inode->i_mapping, GFP_F2FS_HIGH_ZERO);\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\t} else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) ||\n\t\t\tS_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\tinode->i_op = &f2fs_special_inode_operations;\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t} else {\n\t\tret = -EIO;\n\t\tgoto bad_inode;\n\t}\n\tunlock_new_inode(inode);\n\ttrace_f2fs_iget(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\ttrace_f2fs_iget_exit(inode, ret);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_inode_by_name",
          "args": [
            "child->d_inode",
            "&dotdot"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_inode_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/dir.c",
          "lines": "265-279",
          "snippet": "ino_t f2fs_inode_by_name(struct inode *dir, struct qstr *qstr)\n{\n\tino_t res = 0;\n\tstruct f2fs_dir_entry *de;\n\tstruct page *page;\n\n\tde = f2fs_find_entry(dir, qstr, &page);\n\tif (de) {\n\t\tres = le32_to_cpu(de->ino);\n\t\tf2fs_dentry_kunmap(dir, page);\n\t\tf2fs_put_page(page, 0);\n\t}\n\n\treturn res;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nino_t f2fs_inode_by_name(struct inode *dir, struct qstr *qstr)\n{\n\tino_t res = 0;\n\tstruct f2fs_dir_entry *de;\n\tstruct page *page;\n\n\tde = f2fs_find_entry(dir, qstr, &page);\n\tif (de) {\n\t\tres = le32_to_cpu(de->ino);\n\t\tf2fs_dentry_kunmap(dir, page);\n\t\tf2fs_put_page(page, 0);\n\t}\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QSTR_INIT",
          "args": [
            "\"..\"",
            "2"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstruct dentry *f2fs_get_parent(struct dentry *child)\n{\n\tstruct qstr dotdot = QSTR_INIT(\"..\", 2);\n\tunsigned long ino = f2fs_inode_by_name(child->d_inode, &dotdot);\n\tif (!ino)\n\t\treturn ERR_PTR(-ENOENT);\n\treturn d_obtain_alias(f2fs_iget(child->d_inode->i_sb, ino));\n}"
  },
  {
    "function_name": "f2fs_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/namei.c",
    "lines": "150-179",
    "snippet": "static int f2fs_link(struct dentry *old_dentry, struct inode *dir,\n\t\tstruct dentry *dentry)\n{\n\tstruct inode *inode = old_dentry->d_inode;\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tint err;\n\n\tf2fs_balance_fs(sbi);\n\n\tinode->i_ctime = CURRENT_TIME;\n\tihold(inode);\n\n\tset_inode_flag(F2FS_I(inode), FI_INC_LINK);\n\tf2fs_lock_op(sbi);\n\terr = f2fs_add_link(dentry, inode);\n\tif (err)\n\t\tgoto out;\n\tf2fs_unlock_op(sbi);\n\n\td_instantiate(dentry, inode);\n\n\tif (IS_DIRSYNC(dir))\n\t\tf2fs_sync_fs(sbi->sb, 1);\n\treturn 0;\nout:\n\tclear_inode_flag(F2FS_I(inode), FI_INC_LINK);\n\tiput(inode);\n\tf2fs_unlock_op(sbi);\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/dcache.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "f2fs_unlock_op",
          "args": [
            "sbi"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_unlock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "760-763",
          "snippet": "static inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_inode_flag",
          "args": [
            "F2FS_I(inode)",
            "FI_INC_LINK"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1184-1188",
          "snippet": "static inline void clear_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (test_bit(flag, &fi->flags))\n\t\tclear_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void clear_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (test_bit(flag, &fi->flags))\n\t\tclear_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_sync_fs",
          "args": [
            "sbi->sb",
            "1"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_sync_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
          "lines": "496-516",
          "snippet": "int f2fs_sync_fs(struct super_block *sb, int sync)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\n\ttrace_f2fs_sync_fs(sb, sync);\n\n\tif (sync) {\n\t\tstruct cp_control cpc;\n\n\t\tcpc.reason = __get_cp_reason(sbi);\n\n\t\tmutex_lock(&sbi->gc_mutex);\n\t\twrite_checkpoint(sbi, &cpc);\n\t\tmutex_unlock(&sbi->gc_mutex);\n\t} else {\n\t\tf2fs_balance_fs(sbi);\n\t}\n\tf2fs_trace_ios(NULL, NULL, 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"gc.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/random.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/parser.h>",
            "#include <linux/kthread.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nint f2fs_sync_fs(struct super_block *sb, int sync)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\n\ttrace_f2fs_sync_fs(sb, sync);\n\n\tif (sync) {\n\t\tstruct cp_control cpc;\n\n\t\tcpc.reason = __get_cp_reason(sbi);\n\n\t\tmutex_lock(&sbi->gc_mutex);\n\t\twrite_checkpoint(sbi, &cpc);\n\t\tmutex_unlock(&sbi->gc_mutex);\n\t} else {\n\t\tf2fs_balance_fs(sbi);\n\t}\n\tf2fs_trace_ios(NULL, NULL, 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "dir"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_add_link",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_add_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1392-1396",
          "snippet": "static inline int f2fs_add_link(struct dentry *dentry, struct inode *inode)\n{\n\treturn __f2fs_add_link(dentry->d_parent->d_inode, &dentry->d_name,\n\t\t\t\tinode);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_add_link(struct dentry *dentry, struct inode *inode)\n{\n\treturn __f2fs_add_link(dentry->d_parent->d_inode, &dentry->d_name,\n\t\t\t\tinode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_lock_op",
          "args": [
            "sbi"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_lock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "755-758",
          "snippet": "static inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tdown_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tdown_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_inode_flag",
          "args": [
            "F2FS_I(inode)",
            "FI_INC_LINK"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "set_inode_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1173-1177",
          "snippet": "static inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (!test_bit(flag, &fi->flags))\n\t\tset_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (!test_bit(flag, &fi->flags))\n\t\tset_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "inode"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_balance_fs",
          "args": [
            "sbi"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_balance_fs_bg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "278-285",
          "snippet": "void f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "dir"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int f2fs_link(struct dentry *old_dentry, struct inode *dir,\n\t\tstruct dentry *dentry)\n{\n\tstruct inode *inode = old_dentry->d_inode;\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tint err;\n\n\tf2fs_balance_fs(sbi);\n\n\tinode->i_ctime = CURRENT_TIME;\n\tihold(inode);\n\n\tset_inode_flag(F2FS_I(inode), FI_INC_LINK);\n\tf2fs_lock_op(sbi);\n\terr = f2fs_add_link(dentry, inode);\n\tif (err)\n\t\tgoto out;\n\tf2fs_unlock_op(sbi);\n\n\td_instantiate(dentry, inode);\n\n\tif (IS_DIRSYNC(dir))\n\t\tf2fs_sync_fs(sbi->sb, 1);\n\treturn 0;\nout:\n\tclear_inode_flag(F2FS_I(inode), FI_INC_LINK);\n\tiput(inode);\n\tf2fs_unlock_op(sbi);\n\treturn err;\n}"
  },
  {
    "function_name": "f2fs_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/namei.c",
    "lines": "108-148",
    "snippet": "static int f2fs_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t\t\t\t\tbool excl)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tstruct inode *inode;\n\tnid_t ino = 0;\n\tint err;\n\n\tf2fs_balance_fs(sbi);\n\n\tinode = f2fs_new_inode(dir, mode);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tif (!test_opt(sbi, DISABLE_EXT_IDENTIFY))\n\t\tset_cold_files(sbi, inode, dentry->d_name.name);\n\n\tinode->i_op = &f2fs_file_inode_operations;\n\tinode->i_fop = &f2fs_file_operations;\n\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\tino = inode->i_ino;\n\n\tf2fs_lock_op(sbi);\n\terr = f2fs_add_link(dentry, inode);\n\tif (err)\n\t\tgoto out;\n\tf2fs_unlock_op(sbi);\n\n\talloc_nid_done(sbi, ino);\n\n\tstat_inc_inline_inode(inode);\n\td_instantiate(dentry, inode);\n\tunlock_new_inode(inode);\n\n\tif (IS_DIRSYNC(dir))\n\t\tf2fs_sync_fs(sbi->sb, 1);\n\treturn 0;\nout:\n\thandle_failed_inode(inode);\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/dcache.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "handle_failed_inode",
          "args": [
            "inode"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "handle_failed_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inode.c",
          "lines": "343-364",
          "snippet": "void handle_failed_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\n\tclear_nlink(inode);\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\n\ti_size_write(inode, 0);\n\tif (F2FS_HAS_BLOCKS(inode))\n\t\tf2fs_truncate(inode);\n\n\tremove_inode_page(inode);\n\n\tclear_inode_flag(F2FS_I(inode), FI_INLINE_DATA);\n\tclear_inode_flag(F2FS_I(inode), FI_INLINE_DENTRY);\n\talloc_nid_failed(sbi, inode->i_ino);\n\tf2fs_unlock_op(sbi);\n\n\t/* iput will drop the inode object */\n\tiput(inode);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid handle_failed_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\n\tclear_nlink(inode);\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\n\ti_size_write(inode, 0);\n\tif (F2FS_HAS_BLOCKS(inode))\n\t\tf2fs_truncate(inode);\n\n\tremove_inode_page(inode);\n\n\tclear_inode_flag(F2FS_I(inode), FI_INLINE_DATA);\n\tclear_inode_flag(F2FS_I(inode), FI_INLINE_DENTRY);\n\talloc_nid_failed(sbi, inode->i_ino);\n\tf2fs_unlock_op(sbi);\n\n\t/* iput will drop the inode object */\n\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_sync_fs",
          "args": [
            "sbi->sb",
            "1"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_sync_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/super.c",
          "lines": "496-516",
          "snippet": "int f2fs_sync_fs(struct super_block *sb, int sync)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\n\ttrace_f2fs_sync_fs(sb, sync);\n\n\tif (sync) {\n\t\tstruct cp_control cpc;\n\n\t\tcpc.reason = __get_cp_reason(sbi);\n\n\t\tmutex_lock(&sbi->gc_mutex);\n\t\twrite_checkpoint(sbi, &cpc);\n\t\tmutex_unlock(&sbi->gc_mutex);\n\t} else {\n\t\tf2fs_balance_fs(sbi);\n\t}\n\tf2fs_trace_ios(NULL, NULL, 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"gc.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/random.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/parser.h>",
            "#include <linux/kthread.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/statfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"gc.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/sysfs.h>\n#include <linux/f2fs_fs.h>\n#include <linux/blkdev.h>\n#include <linux/exportfs.h>\n#include <linux/random.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/parser.h>\n#include <linux/kthread.h>\n#include <linux/backing-dev.h>\n#include <linux/buffer_head.h>\n#include <linux/statfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nint f2fs_sync_fs(struct super_block *sb, int sync)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\n\ttrace_f2fs_sync_fs(sb, sync);\n\n\tif (sync) {\n\t\tstruct cp_control cpc;\n\n\t\tcpc.reason = __get_cp_reason(sbi);\n\n\t\tmutex_lock(&sbi->gc_mutex);\n\t\twrite_checkpoint(sbi, &cpc);\n\t\tmutex_unlock(&sbi->gc_mutex);\n\t} else {\n\t\tf2fs_balance_fs(sbi);\n\t}\n\tf2fs_trace_ios(NULL, NULL, 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "dir"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat_inc_inline_inode",
          "args": [
            "inode"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_nid_done",
          "args": [
            "sbi",
            "ino"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_nid_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1582-1594",
          "snippet": "void alloc_nid_done(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\n\tspin_lock(&nm_i->free_nid_list_lock);\n\ti = __lookup_free_nid_list(nm_i, nid);\n\tf2fs_bug_on(sbi, !i || i->state != NID_ALLOC);\n\t__del_from_free_nid_list(nm_i, i);\n\tspin_unlock(&nm_i->free_nid_list_lock);\n\n\tkmem_cache_free(free_nid_slab, i);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *free_nid_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *free_nid_slab;\n\nvoid alloc_nid_done(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\n\tspin_lock(&nm_i->free_nid_list_lock);\n\ti = __lookup_free_nid_list(nm_i, nid);\n\tf2fs_bug_on(sbi, !i || i->state != NID_ALLOC);\n\t__del_from_free_nid_list(nm_i, i);\n\tspin_unlock(&nm_i->free_nid_list_lock);\n\n\tkmem_cache_free(free_nid_slab, i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_unlock_op",
          "args": [
            "sbi"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_unlock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "760-763",
          "snippet": "static inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_add_link",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_add_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1392-1396",
          "snippet": "static inline int f2fs_add_link(struct dentry *dentry, struct inode *inode)\n{\n\treturn __f2fs_add_link(dentry->d_parent->d_inode, &dentry->d_name,\n\t\t\t\tinode);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_add_link(struct dentry *dentry, struct inode *inode)\n{\n\treturn __f2fs_add_link(dentry->d_parent->d_inode, &dentry->d_name,\n\t\t\t\tinode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_lock_op",
          "args": [
            "sbi"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_lock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "755-758",
          "snippet": "static inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tdown_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tdown_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_cold_files",
          "args": [
            "sbi",
            "inode",
            "dentry->d_name.name"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "set_cold_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/namei.c",
          "lines": "93-106",
          "snippet": "static inline void set_cold_files(struct f2fs_sb_info *sbi, struct inode *inode,\n\t\tconst unsigned char *name)\n{\n\tint i;\n\t__u8 (*extlist)[8] = sbi->raw_super->extension_list;\n\n\tint count = le32_to_cpu(sbi->raw_super->extension_count);\n\tfor (i = 0; i < count; i++) {\n\t\tif (is_multimedia_file(name, extlist[i])) {\n\t\t\tfile_set_cold(inode);\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/dcache.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic inline void set_cold_files(struct f2fs_sb_info *sbi, struct inode *inode,\n\t\tconst unsigned char *name)\n{\n\tint i;\n\t__u8 (*extlist)[8] = sbi->raw_super->extension_list;\n\n\tint count = le32_to_cpu(sbi->raw_super->extension_count);\n\tfor (i = 0; i < count; i++) {\n\t\tif (is_multimedia_file(name, extlist[i])) {\n\t\t\tfile_set_cold(inode);\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sbi",
            "DISABLE_EXT_IDENTIFY"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_new_inode",
          "args": [
            "dir",
            "mode"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/namei.c",
          "lines": "24-77",
          "snippet": "static struct inode *f2fs_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tnid_t ino;\n\tstruct inode *inode;\n\tbool nid_free = false;\n\tint err;\n\n\tinode = new_inode(dir->i_sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tf2fs_lock_op(sbi);\n\tif (!alloc_nid(sbi, &ino)) {\n\t\tf2fs_unlock_op(sbi);\n\t\terr = -ENOSPC;\n\t\tgoto fail;\n\t}\n\tf2fs_unlock_op(sbi);\n\n\tinode_init_owner(inode, dir, mode);\n\n\tinode->i_ino = ino;\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_generation = sbi->s_next_generation++;\n\n\terr = insert_inode_locked(inode);\n\tif (err) {\n\t\terr = -EINVAL;\n\t\tnid_free = true;\n\t\tgoto out;\n\t}\n\n\tif (f2fs_may_inline(inode))\n\t\tset_inode_flag(F2FS_I(inode), FI_INLINE_DATA);\n\tif (test_opt(sbi, INLINE_DENTRY) && S_ISDIR(inode->i_mode))\n\t\tset_inode_flag(F2FS_I(inode), FI_INLINE_DENTRY);\n\n\ttrace_f2fs_new_inode(inode, 0);\n\tmark_inode_dirty(inode);\n\treturn inode;\n\nout:\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\nfail:\n\ttrace_f2fs_new_inode(inode, err);\n\tmake_bad_inode(inode);\n\tiput(inode);\n\tif (nid_free)\n\t\talloc_nid_failed(sbi, ino);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/dcache.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct inode *f2fs_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tnid_t ino;\n\tstruct inode *inode;\n\tbool nid_free = false;\n\tint err;\n\n\tinode = new_inode(dir->i_sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tf2fs_lock_op(sbi);\n\tif (!alloc_nid(sbi, &ino)) {\n\t\tf2fs_unlock_op(sbi);\n\t\terr = -ENOSPC;\n\t\tgoto fail;\n\t}\n\tf2fs_unlock_op(sbi);\n\n\tinode_init_owner(inode, dir, mode);\n\n\tinode->i_ino = ino;\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_generation = sbi->s_next_generation++;\n\n\terr = insert_inode_locked(inode);\n\tif (err) {\n\t\terr = -EINVAL;\n\t\tnid_free = true;\n\t\tgoto out;\n\t}\n\n\tif (f2fs_may_inline(inode))\n\t\tset_inode_flag(F2FS_I(inode), FI_INLINE_DATA);\n\tif (test_opt(sbi, INLINE_DENTRY) && S_ISDIR(inode->i_mode))\n\t\tset_inode_flag(F2FS_I(inode), FI_INLINE_DENTRY);\n\n\ttrace_f2fs_new_inode(inode, 0);\n\tmark_inode_dirty(inode);\n\treturn inode;\n\nout:\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\nfail:\n\ttrace_f2fs_new_inode(inode, err);\n\tmake_bad_inode(inode);\n\tiput(inode);\n\tif (nid_free)\n\t\talloc_nid_failed(sbi, ino);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_balance_fs",
          "args": [
            "sbi"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_balance_fs_bg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/segment.c",
          "lines": "278-285",
          "snippet": "void f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"node.h\"",
            "#include \"segment.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kthread.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"node.h\"\n#include \"segment.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/kthread.h>\n#include <linux/prefetch.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid f2fs_balance_fs_bg(struct f2fs_sb_info *sbi)\n{\n\t/* check the # of cached NAT entries and prefree segments */\n\tif (try_to_free_nats(sbi, NAT_ENTRY_PER_BLOCK) ||\n\t\t\texcess_prefree_segs(sbi) ||\n\t\t\t!available_free_memory(sbi, INO_ENTRIES))\n\t\tf2fs_sync_fs(sbi->sb, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "dir"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int f2fs_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t\t\t\t\tbool excl)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tstruct inode *inode;\n\tnid_t ino = 0;\n\tint err;\n\n\tf2fs_balance_fs(sbi);\n\n\tinode = f2fs_new_inode(dir, mode);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tif (!test_opt(sbi, DISABLE_EXT_IDENTIFY))\n\t\tset_cold_files(sbi, inode, dentry->d_name.name);\n\n\tinode->i_op = &f2fs_file_inode_operations;\n\tinode->i_fop = &f2fs_file_operations;\n\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\tino = inode->i_ino;\n\n\tf2fs_lock_op(sbi);\n\terr = f2fs_add_link(dentry, inode);\n\tif (err)\n\t\tgoto out;\n\tf2fs_unlock_op(sbi);\n\n\talloc_nid_done(sbi, ino);\n\n\tstat_inc_inline_inode(inode);\n\td_instantiate(dentry, inode);\n\tunlock_new_inode(inode);\n\n\tif (IS_DIRSYNC(dir))\n\t\tf2fs_sync_fs(sbi->sb, 1);\n\treturn 0;\nout:\n\thandle_failed_inode(inode);\n\treturn err;\n}"
  },
  {
    "function_name": "set_cold_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/namei.c",
    "lines": "93-106",
    "snippet": "static inline void set_cold_files(struct f2fs_sb_info *sbi, struct inode *inode,\n\t\tconst unsigned char *name)\n{\n\tint i;\n\t__u8 (*extlist)[8] = sbi->raw_super->extension_list;\n\n\tint count = le32_to_cpu(sbi->raw_super->extension_count);\n\tfor (i = 0; i < count; i++) {\n\t\tif (is_multimedia_file(name, extlist[i])) {\n\t\t\tfile_set_cold(inode);\n\t\t\tbreak;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/dcache.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "file_set_cold",
          "args": [
            "inode"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_multimedia_file",
          "args": [
            "name",
            "extlist[i]"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "is_multimedia_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/namei.c",
          "lines": "79-88",
          "snippet": "static int is_multimedia_file(const unsigned char *s, const char *sub)\n{\n\tsize_t slen = strlen(s);\n\tsize_t sublen = strlen(sub);\n\n\tif (sublen > slen)\n\t\treturn 0;\n\n\treturn !strncasecmp(s + slen - sublen, sub, sublen);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/dcache.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int is_multimedia_file(const unsigned char *s, const char *sub)\n{\n\tsize_t slen = strlen(s);\n\tsize_t sublen = strlen(sub);\n\n\tif (sublen > slen)\n\t\treturn 0;\n\n\treturn !strncasecmp(s + slen - sublen, sub, sublen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "sbi->raw_super->extension_count"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__u8",
          "args": [
            "*extlist"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic inline void set_cold_files(struct f2fs_sb_info *sbi, struct inode *inode,\n\t\tconst unsigned char *name)\n{\n\tint i;\n\t__u8 (*extlist)[8] = sbi->raw_super->extension_list;\n\n\tint count = le32_to_cpu(sbi->raw_super->extension_count);\n\tfor (i = 0; i < count; i++) {\n\t\tif (is_multimedia_file(name, extlist[i])) {\n\t\t\tfile_set_cold(inode);\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "is_multimedia_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/namei.c",
    "lines": "79-88",
    "snippet": "static int is_multimedia_file(const unsigned char *s, const char *sub)\n{\n\tsize_t slen = strlen(s);\n\tsize_t sublen = strlen(sub);\n\n\tif (sublen > slen)\n\t\treturn 0;\n\n\treturn !strncasecmp(s + slen - sublen, sub, sublen);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/dcache.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "s + slen - sublen",
            "sub",
            "sublen"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "sub"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic int is_multimedia_file(const unsigned char *s, const char *sub)\n{\n\tsize_t slen = strlen(s);\n\tsize_t sublen = strlen(sub);\n\n\tif (sublen > slen)\n\t\treturn 0;\n\n\treturn !strncasecmp(s + slen - sublen, sub, sublen);\n}"
  },
  {
    "function_name": "f2fs_new_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/namei.c",
    "lines": "24-77",
    "snippet": "static struct inode *f2fs_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tnid_t ino;\n\tstruct inode *inode;\n\tbool nid_free = false;\n\tint err;\n\n\tinode = new_inode(dir->i_sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tf2fs_lock_op(sbi);\n\tif (!alloc_nid(sbi, &ino)) {\n\t\tf2fs_unlock_op(sbi);\n\t\terr = -ENOSPC;\n\t\tgoto fail;\n\t}\n\tf2fs_unlock_op(sbi);\n\n\tinode_init_owner(inode, dir, mode);\n\n\tinode->i_ino = ino;\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_generation = sbi->s_next_generation++;\n\n\terr = insert_inode_locked(inode);\n\tif (err) {\n\t\terr = -EINVAL;\n\t\tnid_free = true;\n\t\tgoto out;\n\t}\n\n\tif (f2fs_may_inline(inode))\n\t\tset_inode_flag(F2FS_I(inode), FI_INLINE_DATA);\n\tif (test_opt(sbi, INLINE_DENTRY) && S_ISDIR(inode->i_mode))\n\t\tset_inode_flag(F2FS_I(inode), FI_INLINE_DENTRY);\n\n\ttrace_f2fs_new_inode(inode, 0);\n\tmark_inode_dirty(inode);\n\treturn inode;\n\nout:\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\nfail:\n\ttrace_f2fs_new_inode(inode, err);\n\tmake_bad_inode(inode);\n\tiput(inode);\n\tif (nid_free)\n\t\talloc_nid_failed(sbi, ino);\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include <trace/events/f2fs.h>",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"node.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/dcache.h>",
      "#include <linux/ctype.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/f2fs_fs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_nid_failed",
          "args": [
            "sbi",
            "ino"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_nid_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/node.c",
          "lines": "1599-1622",
          "snippet": "void alloc_nid_failed(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\tbool need_free = false;\n\n\tif (!nid)\n\t\treturn;\n\n\tspin_lock(&nm_i->free_nid_list_lock);\n\ti = __lookup_free_nid_list(nm_i, nid);\n\tf2fs_bug_on(sbi, !i || i->state != NID_ALLOC);\n\tif (!available_free_memory(sbi, FREE_NIDS)) {\n\t\t__del_from_free_nid_list(nm_i, i);\n\t\tneed_free = true;\n\t} else {\n\t\ti->state = NID_NEW;\n\t\tnm_i->fcnt++;\n\t}\n\tspin_unlock(&nm_i->free_nid_list_lock);\n\n\tif (need_free)\n\t\tkmem_cache_free(free_nid_slab, i);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mpage.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *free_nid_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/blkdev.h>\n#include <linux/backing-dev.h>\n#include <linux/mpage.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *free_nid_slab;\n\nvoid alloc_nid_failed(struct f2fs_sb_info *sbi, nid_t nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\tbool need_free = false;\n\n\tif (!nid)\n\t\treturn;\n\n\tspin_lock(&nm_i->free_nid_list_lock);\n\ti = __lookup_free_nid_list(nm_i, nid);\n\tf2fs_bug_on(sbi, !i || i->state != NID_ALLOC);\n\tif (!available_free_memory(sbi, FREE_NIDS)) {\n\t\t__del_from_free_nid_list(nm_i, i);\n\t\tneed_free = true;\n\t} else {\n\t\ti->state = NID_NEW;\n\t\tnm_i->fcnt++;\n\t}\n\tspin_unlock(&nm_i->free_nid_list_lock);\n\n\tif (need_free)\n\t\tkmem_cache_free(free_nid_slab, i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_bad_inode",
          "args": [
            "inode"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "make_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "170-179",
          "snippet": "void make_bad_inode(struct inode *inode)\n{\n\tremove_inode_hash(inode);\n\n\tinode->i_mode = S_IFREG;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime =\n\t\tcurrent_fs_time(inode->i_sb);\n\tinode->i_op = &bad_inode_ops;\t\n\tinode->i_fop = &bad_file_ops;\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations bad_file_ops =\n{\n\t.open\t\t= bad_file_open,\n};",
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct file_operations bad_file_ops =\n{\n\t.open\t\t= bad_file_open,\n};\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nvoid make_bad_inode(struct inode *inode)\n{\n\tremove_inode_hash(inode);\n\n\tinode->i_mode = S_IFREG;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime =\n\t\tcurrent_fs_time(inode->i_sb);\n\tinode->i_op = &bad_inode_ops;\t\n\tinode->i_fop = &bad_file_ops;\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_f2fs_new_inode",
          "args": [
            "inode",
            "err"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "inode"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_f2fs_new_inode",
          "args": [
            "inode",
            "0"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_inode_flag",
          "args": [
            "F2FS_I(inode)",
            "FI_INLINE_DENTRY"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "set_inode_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1173-1177",
          "snippet": "static inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (!test_bit(flag, &fi->flags))\n\t\tset_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (!test_bit(flag, &fi->flags))\n\t\tset_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sbi",
            "INLINE_DENTRY"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_may_inline",
          "args": [
            "inode"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_may_inline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/inline.c",
          "lines": "16-31",
          "snippet": "bool f2fs_may_inline(struct inode *inode)\n{\n\tif (!test_opt(F2FS_I_SB(inode), INLINE_DATA))\n\t\treturn false;\n\n\tif (f2fs_is_atomic_file(inode))\n\t\treturn false;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn false;\n\n\tif (i_size_read(inode) > MAX_INLINE_DATA)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nbool f2fs_may_inline(struct inode *inode)\n{\n\tif (!test_opt(F2FS_I_SB(inode), INLINE_DATA))\n\t\treturn false;\n\n\tif (f2fs_is_atomic_file(inode))\n\t\treturn false;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn false;\n\n\tif (i_size_read(inode) > MAX_INLINE_DATA)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_inode_locked",
          "args": [
            "inode"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "insert_inode_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1323-1362",
          "snippet": "int insert_inode_locked(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_ino != ino)\n\t\t\t\tcontinue;\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint insert_inode_locked(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_ino != ino)\n\t\t\t\tcontinue;\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_init_owner",
          "args": [
            "inode",
            "dir",
            "mode"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "inode_init_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1880-1891",
          "snippet": "void inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_unlock_op",
          "args": [
            "sbi"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_unlock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "760-763",
          "snippet": "static inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_unlock_op(struct f2fs_sb_info *sbi)\n{\n\tup_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_lock_op",
          "args": [
            "sbi"
          ],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_lock_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "755-758",
          "snippet": "static inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tdown_read(&sbi->cp_rwsem);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_lock_op(struct f2fs_sb_info *sbi)\n{\n\tdown_read(&sbi->cp_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "dir->i_sb"
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "drop_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
          "lines": "588-595",
          "snippet": "static int drop_new_inode(struct inode *inode)\n{\n\tdquot_drop(inode);\n\tmake_bad_inode(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tiput(inode);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic int drop_new_inode(struct inode *inode)\n{\n\tdquot_drop(inode);\n\tmake_bad_inode(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tiput(inode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I_SB",
          "args": [
            "dir"
          ],
          "line": 26
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_I_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "645-648",
          "snippet": "static inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_sb_info *F2FS_I_SB(struct inode *inode)\n{\n\treturn F2FS_SB(inode->i_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/dcache.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nstatic struct inode *f2fs_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tnid_t ino;\n\tstruct inode *inode;\n\tbool nid_free = false;\n\tint err;\n\n\tinode = new_inode(dir->i_sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tf2fs_lock_op(sbi);\n\tif (!alloc_nid(sbi, &ino)) {\n\t\tf2fs_unlock_op(sbi);\n\t\terr = -ENOSPC;\n\t\tgoto fail;\n\t}\n\tf2fs_unlock_op(sbi);\n\n\tinode_init_owner(inode, dir, mode);\n\n\tinode->i_ino = ino;\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_generation = sbi->s_next_generation++;\n\n\terr = insert_inode_locked(inode);\n\tif (err) {\n\t\terr = -EINVAL;\n\t\tnid_free = true;\n\t\tgoto out;\n\t}\n\n\tif (f2fs_may_inline(inode))\n\t\tset_inode_flag(F2FS_I(inode), FI_INLINE_DATA);\n\tif (test_opt(sbi, INLINE_DENTRY) && S_ISDIR(inode->i_mode))\n\t\tset_inode_flag(F2FS_I(inode), FI_INLINE_DENTRY);\n\n\ttrace_f2fs_new_inode(inode, 0);\n\tmark_inode_dirty(inode);\n\treturn inode;\n\nout:\n\tclear_nlink(inode);\n\tunlock_new_inode(inode);\nfail:\n\ttrace_f2fs_new_inode(inode, err);\n\tmake_bad_inode(inode);\n\tiput(inode);\n\tif (nid_free)\n\t\talloc_nid_failed(sbi, ino);\n\treturn ERR_PTR(err);\n}"
  }
]