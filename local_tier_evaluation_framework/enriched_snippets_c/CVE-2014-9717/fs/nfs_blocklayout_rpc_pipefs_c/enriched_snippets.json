[
  {
    "function_name": "bl_cleanup_pipefs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/rpc_pipefs.c",
    "lines": "284-288",
    "snippet": "void __exit bl_cleanup_pipefs(void)\n{\n\trpc_pipefs_notifier_unregister(&nfs4blocklayout_block);\n\tunregister_pernet_subsys(&nfs4blocklayout_net_ops);\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct notifier_block nfs4blocklayout_block = {\n\t.notifier_call = rpc_pipefs_event,\n};",
      "static struct pernet_operations nfs4blocklayout_net_ops = {\n\t.init = nfs4blocklayout_net_init,\n\t.exit = nfs4blocklayout_net_exit,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_pernet_subsys",
          "args": [
            "&nfs4blocklayout_net_ops"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_pipefs_notifier_unregister",
          "args": [
            "&nfs4blocklayout_block"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/module.h>\n\nstatic struct notifier_block nfs4blocklayout_block = {\n\t.notifier_call = rpc_pipefs_event,\n};\nstatic struct pernet_operations nfs4blocklayout_net_ops = {\n\t.init = nfs4blocklayout_net_init,\n\t.exit = nfs4blocklayout_net_exit,\n};\n\nvoid __exit bl_cleanup_pipefs(void)\n{\n\trpc_pipefs_notifier_unregister(&nfs4blocklayout_block);\n\tunregister_pernet_subsys(&nfs4blocklayout_net_ops);\n}"
  },
  {
    "function_name": "bl_init_pipefs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/rpc_pipefs.c",
    "lines": "266-282",
    "snippet": "int __init bl_init_pipefs(void)\n{\n\tint ret;\n\n\tret = rpc_pipefs_notifier_register(&nfs4blocklayout_block);\n\tif (ret)\n\t\tgoto out;\n\tret = register_pernet_subsys(&nfs4blocklayout_net_ops);\n\tif (ret)\n\t\tgoto out_unregister_notifier;\n\treturn 0;\n\nout_unregister_notifier:\n\trpc_pipefs_notifier_unregister(&nfs4blocklayout_block);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct notifier_block nfs4blocklayout_block = {\n\t.notifier_call = rpc_pipefs_event,\n};",
      "static struct pernet_operations nfs4blocklayout_net_ops = {\n\t.init = nfs4blocklayout_net_init,\n\t.exit = nfs4blocklayout_net_exit,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_pipefs_notifier_unregister",
          "args": [
            "&nfs4blocklayout_block"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_pernet_subsys",
          "args": [
            "&nfs4blocklayout_net_ops"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_pipefs_notifier_register",
          "args": [
            "&nfs4blocklayout_block"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/module.h>\n\nstatic struct notifier_block nfs4blocklayout_block = {\n\t.notifier_call = rpc_pipefs_event,\n};\nstatic struct pernet_operations nfs4blocklayout_net_ops = {\n\t.init = nfs4blocklayout_net_init,\n\t.exit = nfs4blocklayout_net_exit,\n};\n\nint __init bl_init_pipefs(void)\n{\n\tint ret;\n\n\tret = rpc_pipefs_notifier_register(&nfs4blocklayout_block);\n\tif (ret)\n\t\tgoto out;\n\tret = register_pernet_subsys(&nfs4blocklayout_net_ops);\n\tif (ret)\n\t\tgoto out_unregister_notifier;\n\treturn 0;\n\nout_unregister_notifier:\n\trpc_pipefs_notifier_unregister(&nfs4blocklayout_block);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "nfs4blocklayout_net_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/rpc_pipefs.c",
    "lines": "252-259",
    "snippet": "static void nfs4blocklayout_net_exit(struct net *net)\n{\n\tstruct nfs_net *nn = net_generic(net, nfs_net_id);\n\n\tnfs4blocklayout_unregister_net(net, nn->bl_device_pipe);\n\trpc_destroy_pipe_data(nn->bl_device_pipe);\n\tnn->bl_device_pipe = NULL;\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_destroy_pipe_data",
          "args": [
            "nn->bl_device_pipe"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4blocklayout_unregister_net",
          "args": [
            "net",
            "nn->bl_device_pipe"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4blocklayout_unregister_net",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/rpc_pipefs.c",
          "lines": "221-231",
          "snippet": "static void nfs4blocklayout_unregister_net(struct net *net,\n\t\t\t\t\t   struct rpc_pipe *pipe)\n{\n\tstruct super_block *pipefs_sb;\n\n\tpipefs_sb = rpc_get_sb_net(net);\n\tif (pipefs_sb) {\n\t\tnfs4blocklayout_unregister_sb(pipefs_sb, pipe);\n\t\trpc_put_sb_net(net);\n\t}\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/module.h>\n\nstatic void nfs4blocklayout_unregister_net(struct net *net,\n\t\t\t\t\t   struct rpc_pipe *pipe)\n{\n\tstruct super_block *pipefs_sb;\n\n\tpipefs_sb = rpc_get_sb_net(net);\n\tif (pipefs_sb) {\n\t\tnfs4blocklayout_unregister_sb(pipefs_sb, pipe);\n\t\trpc_put_sb_net(net);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfs_net_id"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/module.h>\n\nstatic void nfs4blocklayout_net_exit(struct net *net)\n{\n\tstruct nfs_net *nn = net_generic(net, nfs_net_id);\n\n\tnfs4blocklayout_unregister_net(net, nn->bl_device_pipe);\n\trpc_destroy_pipe_data(nn->bl_device_pipe);\n\tnn->bl_device_pipe = NULL;\n}"
  },
  {
    "function_name": "nfs4blocklayout_net_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/rpc_pipefs.c",
    "lines": "233-250",
    "snippet": "static int nfs4blocklayout_net_init(struct net *net)\n{\n\tstruct nfs_net *nn = net_generic(net, nfs_net_id);\n\tstruct dentry *dentry;\n\n\tmutex_init(&nn->bl_mutex);\n\tinit_waitqueue_head(&nn->bl_wq);\n\tnn->bl_device_pipe = rpc_mkpipe_data(&bl_upcall_ops, 0);\n\tif (IS_ERR(nn->bl_device_pipe))\n\t\treturn PTR_ERR(nn->bl_device_pipe);\n\tdentry = nfs4blocklayout_register_net(net, nn->bl_device_pipe);\n\tif (IS_ERR(dentry)) {\n\t\trpc_destroy_pipe_data(nn->bl_device_pipe);\n\t\treturn PTR_ERR(dentry);\n\t}\n\tnn->bl_device_pipe->dentry = dentry;\n\treturn 0;\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct rpc_pipe_ops bl_upcall_ops = {\n\t.upcall\t\t= rpc_pipe_generic_upcall,\n\t.downcall\t= bl_pipe_downcall,\n\t.destroy_msg\t= bl_pipe_destroy_msg,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dentry"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_destroy_pipe_data",
          "args": [
            "nn->bl_device_pipe"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4blocklayout_register_net",
          "args": [
            "net",
            "nn->bl_device_pipe"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4blocklayout_register_net",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/rpc_pipefs.c",
          "lines": "207-219",
          "snippet": "static struct dentry *nfs4blocklayout_register_net(struct net *net,\n\t\t\t\t\t\t   struct rpc_pipe *pipe)\n{\n\tstruct super_block *pipefs_sb;\n\tstruct dentry *dentry;\n\n\tpipefs_sb = rpc_get_sb_net(net);\n\tif (!pipefs_sb)\n\t\treturn NULL;\n\tdentry = nfs4blocklayout_register_sb(pipefs_sb, pipe);\n\trpc_put_sb_net(net);\n\treturn dentry;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/module.h>\n\nstatic struct dentry *nfs4blocklayout_register_net(struct net *net,\n\t\t\t\t\t\t   struct rpc_pipe *pipe)\n{\n\tstruct super_block *pipefs_sb;\n\tstruct dentry *dentry;\n\n\tpipefs_sb = rpc_get_sb_net(net);\n\tif (!pipefs_sb)\n\t\treturn NULL;\n\tdentry = nfs4blocklayout_register_sb(pipefs_sb, pipe);\n\trpc_put_sb_net(net);\n\treturn dentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "nn->bl_device_pipe"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "nn->bl_device_pipe"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_mkpipe_data",
          "args": [
            "&bl_upcall_ops",
            "0"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&nn->bl_wq"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&nn->bl_mutex"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfs_net_id"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/module.h>\n\nstatic const struct rpc_pipe_ops bl_upcall_ops = {\n\t.upcall\t\t= rpc_pipe_generic_upcall,\n\t.downcall\t= bl_pipe_downcall,\n\t.destroy_msg\t= bl_pipe_destroy_msg,\n};\n\nstatic int nfs4blocklayout_net_init(struct net *net)\n{\n\tstruct nfs_net *nn = net_generic(net, nfs_net_id);\n\tstruct dentry *dentry;\n\n\tmutex_init(&nn->bl_mutex);\n\tinit_waitqueue_head(&nn->bl_wq);\n\tnn->bl_device_pipe = rpc_mkpipe_data(&bl_upcall_ops, 0);\n\tif (IS_ERR(nn->bl_device_pipe))\n\t\treturn PTR_ERR(nn->bl_device_pipe);\n\tdentry = nfs4blocklayout_register_net(net, nn->bl_device_pipe);\n\tif (IS_ERR(dentry)) {\n\t\trpc_destroy_pipe_data(nn->bl_device_pipe);\n\t\treturn PTR_ERR(dentry);\n\t}\n\tnn->bl_device_pipe->dentry = dentry;\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs4blocklayout_unregister_net",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/rpc_pipefs.c",
    "lines": "221-231",
    "snippet": "static void nfs4blocklayout_unregister_net(struct net *net,\n\t\t\t\t\t   struct rpc_pipe *pipe)\n{\n\tstruct super_block *pipefs_sb;\n\n\tpipefs_sb = rpc_get_sb_net(net);\n\tif (pipefs_sb) {\n\t\tnfs4blocklayout_unregister_sb(pipefs_sb, pipe);\n\t\trpc_put_sb_net(net);\n\t}\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_put_sb_net",
          "args": [
            "net"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4blocklayout_unregister_sb",
          "args": [
            "pipefs_sb",
            "pipe"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4blocklayout_unregister_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/rpc_pipefs.c",
          "lines": "158-163",
          "snippet": "static void nfs4blocklayout_unregister_sb(struct super_block *sb,\n\t\t\t\t\t  struct rpc_pipe *pipe)\n{\n\tif (pipe->dentry)\n\t\trpc_unlink(pipe->dentry);\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/module.h>\n\nstatic void nfs4blocklayout_unregister_sb(struct super_block *sb,\n\t\t\t\t\t  struct rpc_pipe *pipe)\n{\n\tif (pipe->dentry)\n\t\trpc_unlink(pipe->dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rpc_get_sb_net",
          "args": [
            "net"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/module.h>\n\nstatic void nfs4blocklayout_unregister_net(struct net *net,\n\t\t\t\t\t   struct rpc_pipe *pipe)\n{\n\tstruct super_block *pipefs_sb;\n\n\tpipefs_sb = rpc_get_sb_net(net);\n\tif (pipefs_sb) {\n\t\tnfs4blocklayout_unregister_sb(pipefs_sb, pipe);\n\t\trpc_put_sb_net(net);\n\t}\n}"
  },
  {
    "function_name": "nfs4blocklayout_register_net",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/rpc_pipefs.c",
    "lines": "207-219",
    "snippet": "static struct dentry *nfs4blocklayout_register_net(struct net *net,\n\t\t\t\t\t\t   struct rpc_pipe *pipe)\n{\n\tstruct super_block *pipefs_sb;\n\tstruct dentry *dentry;\n\n\tpipefs_sb = rpc_get_sb_net(net);\n\tif (!pipefs_sb)\n\t\treturn NULL;\n\tdentry = nfs4blocklayout_register_sb(pipefs_sb, pipe);\n\trpc_put_sb_net(net);\n\treturn dentry;\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_put_sb_net",
          "args": [
            "net"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4blocklayout_register_sb",
          "args": [
            "pipefs_sb",
            "pipe"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4blocklayout_register_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/rpc_pipefs.c",
          "lines": "145-156",
          "snippet": "static struct dentry *nfs4blocklayout_register_sb(struct super_block *sb,\n\t\t\t\t\t    struct rpc_pipe *pipe)\n{\n\tstruct dentry *dir, *dentry;\n\n\tdir = rpc_d_lookup_sb(sb, NFS_PIPE_DIRNAME);\n\tif (dir == NULL)\n\t\treturn ERR_PTR(-ENOENT);\n\tdentry = rpc_mkpipe_dentry(dir, \"blocklayout\", NULL, pipe);\n\tdput(dir);\n\treturn dentry;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/module.h>\n\nstatic struct dentry *nfs4blocklayout_register_sb(struct super_block *sb,\n\t\t\t\t\t    struct rpc_pipe *pipe)\n{\n\tstruct dentry *dir, *dentry;\n\n\tdir = rpc_d_lookup_sb(sb, NFS_PIPE_DIRNAME);\n\tif (dir == NULL)\n\t\treturn ERR_PTR(-ENOENT);\n\tdentry = rpc_mkpipe_dentry(dir, \"blocklayout\", NULL, pipe);\n\tdput(dir);\n\treturn dentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rpc_get_sb_net",
          "args": [
            "net"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/module.h>\n\nstatic struct dentry *nfs4blocklayout_register_net(struct net *net,\n\t\t\t\t\t\t   struct rpc_pipe *pipe)\n{\n\tstruct super_block *pipefs_sb;\n\tstruct dentry *dentry;\n\n\tpipefs_sb = rpc_get_sb_net(net);\n\tif (!pipefs_sb)\n\t\treturn NULL;\n\tdentry = nfs4blocklayout_register_sb(pipefs_sb, pipe);\n\trpc_put_sb_net(net);\n\treturn dentry;\n}"
  },
  {
    "function_name": "rpc_pipefs_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/rpc_pipefs.c",
    "lines": "165-201",
    "snippet": "static int rpc_pipefs_event(struct notifier_block *nb, unsigned long event,\n\t\t\t   void *ptr)\n{\n\tstruct super_block *sb = ptr;\n\tstruct net *net = sb->s_fs_info;\n\tstruct nfs_net *nn = net_generic(net, nfs_net_id);\n\tstruct dentry *dentry;\n\tint ret = 0;\n\n\tif (!try_module_get(THIS_MODULE))\n\t\treturn 0;\n\n\tif (nn->bl_device_pipe == NULL) {\n\t\tmodule_put(THIS_MODULE);\n\t\treturn 0;\n\t}\n\n\tswitch (event) {\n\tcase RPC_PIPEFS_MOUNT:\n\t\tdentry = nfs4blocklayout_register_sb(sb, nn->bl_device_pipe);\n\t\tif (IS_ERR(dentry)) {\n\t\t\tret = PTR_ERR(dentry);\n\t\t\tbreak;\n\t\t}\n\t\tnn->bl_device_pipe->dentry = dentry;\n\t\tbreak;\n\tcase RPC_PIPEFS_UMOUNT:\n\t\tif (nn->bl_device_pipe->dentry)\n\t\t\tnfs4blocklayout_unregister_sb(sb, nn->bl_device_pipe);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOTSUPP;\n\t\tbreak;\n\t}\n\tmodule_put(THIS_MODULE);\n\treturn ret;\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "THIS_MODULE"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4blocklayout_unregister_sb",
          "args": [
            "sb",
            "nn->bl_device_pipe"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4blocklayout_unregister_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/rpc_pipefs.c",
          "lines": "158-163",
          "snippet": "static void nfs4blocklayout_unregister_sb(struct super_block *sb,\n\t\t\t\t\t  struct rpc_pipe *pipe)\n{\n\tif (pipe->dentry)\n\t\trpc_unlink(pipe->dentry);\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/module.h>\n\nstatic void nfs4blocklayout_unregister_sb(struct super_block *sb,\n\t\t\t\t\t  struct rpc_pipe *pipe)\n{\n\tif (pipe->dentry)\n\t\trpc_unlink(pipe->dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dentry"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4blocklayout_register_sb",
          "args": [
            "sb",
            "nn->bl_device_pipe"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4blocklayout_register_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/rpc_pipefs.c",
          "lines": "145-156",
          "snippet": "static struct dentry *nfs4blocklayout_register_sb(struct super_block *sb,\n\t\t\t\t\t    struct rpc_pipe *pipe)\n{\n\tstruct dentry *dir, *dentry;\n\n\tdir = rpc_d_lookup_sb(sb, NFS_PIPE_DIRNAME);\n\tif (dir == NULL)\n\t\treturn ERR_PTR(-ENOENT);\n\tdentry = rpc_mkpipe_dentry(dir, \"blocklayout\", NULL, pipe);\n\tdput(dir);\n\treturn dentry;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/module.h>\n\nstatic struct dentry *nfs4blocklayout_register_sb(struct super_block *sb,\n\t\t\t\t\t    struct rpc_pipe *pipe)\n{\n\tstruct dentry *dir, *dentry;\n\n\tdir = rpc_d_lookup_sb(sb, NFS_PIPE_DIRNAME);\n\tif (dir == NULL)\n\t\treturn ERR_PTR(-ENOENT);\n\tdentry = rpc_mkpipe_dentry(dir, \"blocklayout\", NULL, pipe);\n\tdput(dir);\n\treturn dentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "THIS_MODULE"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_module_get",
          "args": [
            "THIS_MODULE"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfs_net_id"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/module.h>\n\nstatic int rpc_pipefs_event(struct notifier_block *nb, unsigned long event,\n\t\t\t   void *ptr)\n{\n\tstruct super_block *sb = ptr;\n\tstruct net *net = sb->s_fs_info;\n\tstruct nfs_net *nn = net_generic(net, nfs_net_id);\n\tstruct dentry *dentry;\n\tint ret = 0;\n\n\tif (!try_module_get(THIS_MODULE))\n\t\treturn 0;\n\n\tif (nn->bl_device_pipe == NULL) {\n\t\tmodule_put(THIS_MODULE);\n\t\treturn 0;\n\t}\n\n\tswitch (event) {\n\tcase RPC_PIPEFS_MOUNT:\n\t\tdentry = nfs4blocklayout_register_sb(sb, nn->bl_device_pipe);\n\t\tif (IS_ERR(dentry)) {\n\t\t\tret = PTR_ERR(dentry);\n\t\t\tbreak;\n\t\t}\n\t\tnn->bl_device_pipe->dentry = dentry;\n\t\tbreak;\n\tcase RPC_PIPEFS_UMOUNT:\n\t\tif (nn->bl_device_pipe->dentry)\n\t\t\tnfs4blocklayout_unregister_sb(sb, nn->bl_device_pipe);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOTSUPP;\n\t\tbreak;\n\t}\n\tmodule_put(THIS_MODULE);\n\treturn ret;\n}"
  },
  {
    "function_name": "nfs4blocklayout_unregister_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/rpc_pipefs.c",
    "lines": "158-163",
    "snippet": "static void nfs4blocklayout_unregister_sb(struct super_block *sb,\n\t\t\t\t\t  struct rpc_pipe *pipe)\n{\n\tif (pipe->dentry)\n\t\trpc_unlink(pipe->dentry);\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_unlink",
          "args": [
            "pipe->dentry"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/module.h>\n\nstatic void nfs4blocklayout_unregister_sb(struct super_block *sb,\n\t\t\t\t\t  struct rpc_pipe *pipe)\n{\n\tif (pipe->dentry)\n\t\trpc_unlink(pipe->dentry);\n}"
  },
  {
    "function_name": "nfs4blocklayout_register_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/rpc_pipefs.c",
    "lines": "145-156",
    "snippet": "static struct dentry *nfs4blocklayout_register_sb(struct super_block *sb,\n\t\t\t\t\t    struct rpc_pipe *pipe)\n{\n\tstruct dentry *dir, *dentry;\n\n\tdir = rpc_d_lookup_sb(sb, NFS_PIPE_DIRNAME);\n\tif (dir == NULL)\n\t\treturn ERR_PTR(-ENOENT);\n\tdentry = rpc_mkpipe_dentry(dir, \"blocklayout\", NULL, pipe);\n\tdput(dir);\n\treturn dentry;\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dir"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rpc_mkpipe_dentry",
          "args": [
            "dir",
            "\"blocklayout\"",
            "NULL",
            "pipe"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_d_lookup_sb",
          "args": [
            "sb",
            "NFS_PIPE_DIRNAME"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/module.h>\n\nstatic struct dentry *nfs4blocklayout_register_sb(struct super_block *sb,\n\t\t\t\t\t    struct rpc_pipe *pipe)\n{\n\tstruct dentry *dir, *dentry;\n\n\tdir = rpc_d_lookup_sb(sb, NFS_PIPE_DIRNAME);\n\tif (dir == NULL)\n\t\treturn ERR_PTR(-ENOENT);\n\tdentry = rpc_mkpipe_dentry(dir, \"blocklayout\", NULL, pipe);\n\tdput(dir);\n\treturn dentry;\n}"
  },
  {
    "function_name": "bl_pipe_destroy_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/rpc_pipefs.c",
    "lines": "129-137",
    "snippet": "static void bl_pipe_destroy_msg(struct rpc_pipe_msg *msg)\n{\n\tstruct bl_pipe_msg *bl_pipe_msg =\n\t\tcontainer_of(msg, struct bl_pipe_msg, msg);\n\n\tif (msg->errno >= 0)\n\t\treturn;\n\twake_up(bl_pipe_msg->bl_wq);\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "bl_pipe_msg->bl_wq"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "msg",
            "structbl_pipe_msg",
            "msg"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/module.h>\n\nstatic void bl_pipe_destroy_msg(struct rpc_pipe_msg *msg)\n{\n\tstruct bl_pipe_msg *bl_pipe_msg =\n\t\tcontainer_of(msg, struct bl_pipe_msg, msg);\n\n\tif (msg->errno >= 0)\n\t\treturn;\n\twake_up(bl_pipe_msg->bl_wq);\n}"
  },
  {
    "function_name": "bl_pipe_downcall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/rpc_pipefs.c",
    "lines": "112-127",
    "snippet": "static ssize_t bl_pipe_downcall(struct file *filp, const char __user *src,\n\t\t\t size_t mlen)\n{\n\tstruct nfs_net *nn = net_generic(file_inode(filp)->i_sb->s_fs_info,\n\t\t\t\t\t nfs_net_id);\n\n\tif (mlen != sizeof (struct bl_dev_msg))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&nn->bl_mount_reply, src, mlen) != 0)\n\t\treturn -EFAULT;\n\n\twake_up(&nn->bl_wq);\n\n\treturn mlen;\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&nn->bl_wq"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&nn->bl_mount_reply",
            "src",
            "mlen"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "file_inode(filp)->i_sb->s_fs_info",
            "nfs_net_id"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/module.h>\n\nstatic ssize_t bl_pipe_downcall(struct file *filp, const char __user *src,\n\t\t\t size_t mlen)\n{\n\tstruct nfs_net *nn = net_generic(file_inode(filp)->i_sb->s_fs_info,\n\t\t\t\t\t nfs_net_id);\n\n\tif (mlen != sizeof (struct bl_dev_msg))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&nn->bl_mount_reply, src, mlen) != 0)\n\t\treturn -EFAULT;\n\n\twake_up(&nn->bl_wq);\n\n\treturn mlen;\n}"
  },
  {
    "function_name": "bl_resolve_deviceid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/rpc_pipefs.c",
    "lines": "52-110",
    "snippet": "dev_t\nbl_resolve_deviceid(struct nfs_server *server, struct pnfs_block_volume *b,\n\t\tgfp_t gfp_mask)\n{\n\tstruct net *net = server->nfs_client->cl_net;\n\tstruct nfs_net *nn = net_generic(net, nfs_net_id);\n\tstruct bl_dev_msg *reply = &nn->bl_mount_reply;\n\tstruct bl_pipe_msg bl_pipe_msg;\n\tstruct rpc_pipe_msg *msg = &bl_pipe_msg.msg;\n\tstruct bl_msg_hdr *bl_msg;\n\tDECLARE_WAITQUEUE(wq, current);\n\tdev_t dev = 0;\n\tint rc;\n\n\tdprintk(\"%s CREATING PIPEFS MESSAGE\\n\", __func__);\n\n\tmutex_lock(&nn->bl_mutex);\n\tbl_pipe_msg.bl_wq = &nn->bl_wq;\n\n\tb->simple.len += 4;\t/* single volume */\n\tif (b->simple.len > PAGE_SIZE)\n\t\tgoto out_unlock;\n\n\tmemset(msg, 0, sizeof(*msg));\n\tmsg->len = sizeof(*bl_msg) + b->simple.len;\n\tmsg->data = kzalloc(msg->len, gfp_mask);\n\tif (!msg->data)\n\t\tgoto out_free_data;\n\n\tbl_msg = msg->data;\n\tbl_msg->type = BL_DEVICE_MOUNT,\n\tbl_msg->totallen = b->simple.len;\n\tnfs4_encode_simple(msg->data + sizeof(*bl_msg), b);\n\n\tdprintk(\"%s CALLING USERSPACE DAEMON\\n\", __func__);\n\tadd_wait_queue(&nn->bl_wq, &wq);\n\trc = rpc_queue_upcall(nn->bl_device_pipe, msg);\n\tif (rc < 0) {\n\t\tremove_wait_queue(&nn->bl_wq, &wq);\n\t\tgoto out_free_data;\n\t}\n\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tschedule();\n\tremove_wait_queue(&nn->bl_wq, &wq);\n\n\tif (reply->status != BL_DEVICE_REQUEST_PROC) {\n\t\tprintk(KERN_WARNING \"%s failed to decode device: %d\\n\",\n\t\t\t__func__, reply->status);\n\t\tgoto out_free_data;\n\t}\n\n\tdev = MKDEV(reply->major, reply->minor);\nout_free_data:\n\tkfree(msg->data);\nout_unlock:\n\tmutex_unlock(&nn->bl_mutex);\n\treturn dev;\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&nn->bl_mutex"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "msg->data"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MKDEV",
          "args": [
            "reply->major",
            "reply->minor"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"%s failed to decode device: %d\\n\"",
            "__func__",
            "reply->status"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_wait_queue",
          "args": [
            "&nn->bl_wq",
            "&wq"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_wait_queue",
          "args": [
            "&nn->bl_wq",
            "&wq"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_queue_upcall",
          "args": [
            "nn->bl_device_pipe",
            "msg"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_wait_queue",
          "args": [
            "&nn->bl_wq",
            "&wq"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s CALLING USERSPACE DAEMON\\n\"",
            "__func__"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_encode_simple",
          "args": [
            "msg->data + sizeof(*bl_msg)",
            "b"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_encode_simple",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/rpc_pipefs.c",
          "lines": "37-50",
          "snippet": "static void\nnfs4_encode_simple(__be32 *p, struct pnfs_block_volume *b)\n{\n\tint i;\n\n\t*p++ = cpu_to_be32(1);\n\t*p++ = cpu_to_be32(b->type);\n\t*p++ = cpu_to_be32(b->simple.nr_sigs);\n\tfor (i = 0; i < b->simple.nr_sigs; i++) {\n\t\tp = xdr_encode_hyper(p, b->simple.sigs[i].offset);\n\t\tp = xdr_encode_opaque(p, b->simple.sigs[i].sig,\n\t\t\t\t\t b->simple.sigs[i].sig_len);\n\t}\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/module.h>\n\nstatic void\nnfs4_encode_simple(__be32 *p, struct pnfs_block_volume *b)\n{\n\tint i;\n\n\t*p++ = cpu_to_be32(1);\n\t*p++ = cpu_to_be32(b->type);\n\t*p++ = cpu_to_be32(b->simple.nr_sigs);\n\tfor (i = 0; i < b->simple.nr_sigs; i++) {\n\t\tp = xdr_encode_hyper(p, b->simple.sigs[i].offset);\n\t\tp = xdr_encode_opaque(p, b->simple.sigs[i].sig,\n\t\t\t\t\t b->simple.sigs[i].sig_len);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "msg->len",
            "gfp_mask"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "msg",
            "0",
            "sizeof(*msg)"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&nn->bl_mutex"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s CREATING PIPEFS MESSAGE\\n\"",
            "__func__"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_WAITQUEUE",
          "args": [
            "wq",
            "current"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfs_net_id"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/module.h>\n\ndev_t\nbl_resolve_deviceid(struct nfs_server *server, struct pnfs_block_volume *b,\n\t\tgfp_t gfp_mask)\n{\n\tstruct net *net = server->nfs_client->cl_net;\n\tstruct nfs_net *nn = net_generic(net, nfs_net_id);\n\tstruct bl_dev_msg *reply = &nn->bl_mount_reply;\n\tstruct bl_pipe_msg bl_pipe_msg;\n\tstruct rpc_pipe_msg *msg = &bl_pipe_msg.msg;\n\tstruct bl_msg_hdr *bl_msg;\n\tDECLARE_WAITQUEUE(wq, current);\n\tdev_t dev = 0;\n\tint rc;\n\n\tdprintk(\"%s CREATING PIPEFS MESSAGE\\n\", __func__);\n\n\tmutex_lock(&nn->bl_mutex);\n\tbl_pipe_msg.bl_wq = &nn->bl_wq;\n\n\tb->simple.len += 4;\t/* single volume */\n\tif (b->simple.len > PAGE_SIZE)\n\t\tgoto out_unlock;\n\n\tmemset(msg, 0, sizeof(*msg));\n\tmsg->len = sizeof(*bl_msg) + b->simple.len;\n\tmsg->data = kzalloc(msg->len, gfp_mask);\n\tif (!msg->data)\n\t\tgoto out_free_data;\n\n\tbl_msg = msg->data;\n\tbl_msg->type = BL_DEVICE_MOUNT,\n\tbl_msg->totallen = b->simple.len;\n\tnfs4_encode_simple(msg->data + sizeof(*bl_msg), b);\n\n\tdprintk(\"%s CALLING USERSPACE DAEMON\\n\", __func__);\n\tadd_wait_queue(&nn->bl_wq, &wq);\n\trc = rpc_queue_upcall(nn->bl_device_pipe, msg);\n\tif (rc < 0) {\n\t\tremove_wait_queue(&nn->bl_wq, &wq);\n\t\tgoto out_free_data;\n\t}\n\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tschedule();\n\tremove_wait_queue(&nn->bl_wq, &wq);\n\n\tif (reply->status != BL_DEVICE_REQUEST_PROC) {\n\t\tprintk(KERN_WARNING \"%s failed to decode device: %d\\n\",\n\t\t\t__func__, reply->status);\n\t\tgoto out_free_data;\n\t}\n\n\tdev = MKDEV(reply->major, reply->minor);\nout_free_data:\n\tkfree(msg->data);\nout_unlock:\n\tmutex_unlock(&nn->bl_mutex);\n\treturn dev;\n}"
  },
  {
    "function_name": "nfs4_encode_simple",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/rpc_pipefs.c",
    "lines": "37-50",
    "snippet": "static void\nnfs4_encode_simple(__be32 *p, struct pnfs_block_volume *b)\n{\n\tint i;\n\n\t*p++ = cpu_to_be32(1);\n\t*p++ = cpu_to_be32(b->type);\n\t*p++ = cpu_to_be32(b->simple.nr_sigs);\n\tfor (i = 0; i < b->simple.nr_sigs; i++) {\n\t\tp = xdr_encode_hyper(p, b->simple.sigs[i].offset);\n\t\tp = xdr_encode_opaque(p, b->simple.sigs[i].sig,\n\t\t\t\t\t b->simple.sigs[i].sig_len);\n\t}\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/genhd.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_encode_opaque",
          "args": [
            "p",
            "b->simple.sigs[i].sig",
            "b->simple.sigs[i].sig_len"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "b->simple.sigs[i].offset"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "b->simple.nr_sigs"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "b->type"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "1"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/module.h>\n\nstatic void\nnfs4_encode_simple(__be32 *p, struct pnfs_block_volume *b)\n{\n\tint i;\n\n\t*p++ = cpu_to_be32(1);\n\t*p++ = cpu_to_be32(b->type);\n\t*p++ = cpu_to_be32(b->simple.nr_sigs);\n\tfor (i = 0; i < b->simple.nr_sigs; i++) {\n\t\tp = xdr_encode_hyper(p, b->simple.sigs[i].offset);\n\t\tp = xdr_encode_opaque(p, b->simple.sigs[i].sig,\n\t\t\t\t\t b->simple.sigs[i].sig_len);\n\t}\n}"
  }
]