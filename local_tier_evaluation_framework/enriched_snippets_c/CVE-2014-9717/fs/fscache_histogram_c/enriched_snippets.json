[
  {
    "function_name": "fscache_histogram_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/histogram.c",
    "lines": "96-99",
    "snippet": "static int fscache_histogram_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &fscache_histogram_ops);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct seq_operations fscache_histogram_ops = {\n\t.start\t\t= fscache_histogram_start,\n\t.stop\t\t= fscache_histogram_stop,\n\t.next\t\t= fscache_histogram_next,\n\t.show\t\t= fscache_histogram_show,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&fscache_histogram_ops"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "52-87",
          "snippet": "int seq_open(struct file *file, const struct seq_operations *op)\n{\n\tstruct seq_file *p = file->private_data;\n\n\tif (!p) {\n\t\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\tfile->private_data = p;\n\t}\n\tmemset(p, 0, sizeof(*p));\n\tmutex_init(&p->lock);\n\tp->op = op;\n#ifdef CONFIG_USER_NS\n\tp->user_ns = file->f_cred->user_ns;\n#endif\n\n\t/*\n\t * Wrappers around seq_open(e.g. swaps_open) need to be\n\t * aware of this. If they set f_version themselves, they\n\t * should call seq_open first and then set f_version.\n\t */\n\tfile->f_version = 0;\n\n\t/*\n\t * seq_files support lseek() and pread().  They do not implement\n\t * write() at all, but we clear FMODE_PWRITE here for historical\n\t * reasons.\n\t *\n\t * If a client of seq_files a) implements file.write() and b) wishes to\n\t * support pwrite() then that client will need to implement its own\n\t * file.open() which calls seq_open() and then sets FMODE_PWRITE.\n\t */\n\tfile->f_mode &= ~FMODE_PWRITE;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_open(struct file *file, const struct seq_operations *op)\n{\n\tstruct seq_file *p = file->private_data;\n\n\tif (!p) {\n\t\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\tfile->private_data = p;\n\t}\n\tmemset(p, 0, sizeof(*p));\n\tmutex_init(&p->lock);\n\tp->op = op;\n#ifdef CONFIG_USER_NS\n\tp->user_ns = file->f_cred->user_ns;\n#endif\n\n\t/*\n\t * Wrappers around seq_open(e.g. swaps_open) need to be\n\t * aware of this. If they set f_version themselves, they\n\t * should call seq_open first and then set f_version.\n\t */\n\tfile->f_version = 0;\n\n\t/*\n\t * seq_files support lseek() and pread().  They do not implement\n\t * write() at all, but we clear FMODE_PWRITE here for historical\n\t * reasons.\n\t *\n\t * If a client of seq_files a) implements file.write() and b) wishes to\n\t * support pwrite() then that client will need to implement its own\n\t * file.open() which calls seq_open() and then sets FMODE_PWRITE.\n\t */\n\tfile->f_mode &= ~FMODE_PWRITE;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n\nstatic const struct seq_operations fscache_histogram_ops = {\n\t.start\t\t= fscache_histogram_start,\n\t.stop\t\t= fscache_histogram_stop,\n\t.next\t\t= fscache_histogram_next,\n\t.show\t\t= fscache_histogram_show,\n};\n\nstatic int fscache_histogram_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &fscache_histogram_ops);\n}"
  },
  {
    "function_name": "fscache_histogram_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/histogram.c",
    "lines": "82-84",
    "snippet": "static void fscache_histogram_stop(struct seq_file *m, void *v)\n{\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n\nstatic void fscache_histogram_stop(struct seq_file *m, void *v)\n{\n}"
  },
  {
    "function_name": "fscache_histogram_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/histogram.c",
    "lines": "72-77",
    "snippet": "static void *fscache_histogram_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\t(*pos)++;\n\treturn (unsigned long long)*pos > HZ + 2 ?\n\t\tNULL : (void *)(unsigned long) *pos;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n\nstatic void *fscache_histogram_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\t(*pos)++;\n\treturn (unsigned long long)*pos > HZ + 2 ?\n\t\tNULL : (void *)(unsigned long) *pos;\n}"
  },
  {
    "function_name": "fscache_histogram_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/histogram.c",
    "lines": "60-67",
    "snippet": "static void *fscache_histogram_start(struct seq_file *m, loff_t *_pos)\n{\n\tif ((unsigned long long)*_pos >= HZ + 2)\n\t\treturn NULL;\n\tif (*_pos == 0)\n\t\t*_pos = 1;\n\treturn (void *)(unsigned long) *_pos;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n\nstatic void *fscache_histogram_start(struct seq_file *m, loff_t *_pos)\n{\n\tif ((unsigned long long)*_pos >= HZ + 2)\n\t\treturn NULL;\n\tif (*_pos == 0)\n\t\t*_pos = 1;\n\treturn (void *)(unsigned long) *_pos;\n}"
  },
  {
    "function_name": "fscache_histogram_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/histogram.c",
    "lines": "27-55",
    "snippet": "static int fscache_histogram_show(struct seq_file *m, void *v)\n{\n\tunsigned long index;\n\tunsigned n[5], t;\n\n\tswitch ((unsigned long) v) {\n\tcase 1:\n\t\tseq_puts(m, \"JIFS  SECS  OBJ INST  OP RUNS   OBJ RUNS  RETRV DLY RETRIEVLS\\n\");\n\t\treturn 0;\n\tcase 2:\n\t\tseq_puts(m, \"===== ===== ========= ========= ========= ========= =========\\n\");\n\t\treturn 0;\n\tdefault:\n\t\tindex = (unsigned long) v - 3;\n\t\tn[0] = atomic_read(&fscache_obj_instantiate_histogram[index]);\n\t\tn[1] = atomic_read(&fscache_ops_histogram[index]);\n\t\tn[2] = atomic_read(&fscache_objs_histogram[index]);\n\t\tn[3] = atomic_read(&fscache_retrieval_delay_histogram[index]);\n\t\tn[4] = atomic_read(&fscache_retrieval_histogram[index]);\n\t\tif (!(n[0] | n[1] | n[2] | n[3] | n[4]))\n\t\t\treturn 0;\n\n\t\tt = (index * 1000) / HZ;\n\n\t\tseq_printf(m, \"%4lu  0.%03u %9u %9u %9u %9u %9u\\n\",\n\t\t\t   index, t, n[0], n[1], n[2], n[3], n[4]);\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "atomic_t fscache_obj_instantiate_histogram[HZ];",
      "atomic_t fscache_objs_histogram[HZ];",
      "atomic_t fscache_ops_histogram[HZ];",
      "atomic_t fscache_retrieval_delay_histogram[HZ];",
      "atomic_t fscache_retrieval_histogram[HZ];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%4lu  0.%03u %9u %9u %9u %9u %9u\\n\"",
            "index",
            "t",
            "n[0]",
            "n[1]",
            "n[2]",
            "n[3]",
            "n[4]"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&fscache_retrieval_histogram[index]"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&fscache_retrieval_delay_histogram[index]"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&fscache_objs_histogram[index]"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&fscache_ops_histogram[index]"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&fscache_obj_instantiate_histogram[index]"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"===== ===== ========= ========= ========= ========= =========\\n\""
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n\natomic_t fscache_obj_instantiate_histogram[HZ];\natomic_t fscache_objs_histogram[HZ];\natomic_t fscache_ops_histogram[HZ];\natomic_t fscache_retrieval_delay_histogram[HZ];\natomic_t fscache_retrieval_histogram[HZ];\n\nstatic int fscache_histogram_show(struct seq_file *m, void *v)\n{\n\tunsigned long index;\n\tunsigned n[5], t;\n\n\tswitch ((unsigned long) v) {\n\tcase 1:\n\t\tseq_puts(m, \"JIFS  SECS  OBJ INST  OP RUNS   OBJ RUNS  RETRV DLY RETRIEVLS\\n\");\n\t\treturn 0;\n\tcase 2:\n\t\tseq_puts(m, \"===== ===== ========= ========= ========= ========= =========\\n\");\n\t\treturn 0;\n\tdefault:\n\t\tindex = (unsigned long) v - 3;\n\t\tn[0] = atomic_read(&fscache_obj_instantiate_histogram[index]);\n\t\tn[1] = atomic_read(&fscache_ops_histogram[index]);\n\t\tn[2] = atomic_read(&fscache_objs_histogram[index]);\n\t\tn[3] = atomic_read(&fscache_retrieval_delay_histogram[index]);\n\t\tn[4] = atomic_read(&fscache_retrieval_histogram[index]);\n\t\tif (!(n[0] | n[1] | n[2] | n[3] | n[4]))\n\t\t\treturn 0;\n\n\t\tt = (index * 1000) / HZ;\n\n\t\tseq_printf(m, \"%4lu  0.%03u %9u %9u %9u %9u %9u\\n\",\n\t\t\t   index, t, n[0], n[1], n[2], n[3], n[4]);\n\t\treturn 0;\n\t}\n}"
  }
]