[
  {
    "function_name": "squashfs_read_xattr_id_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/xattr_id.c",
    "lines": "66-95",
    "snippet": "__le64 *squashfs_read_xattr_id_table(struct super_block *sb, u64 start,\n\t\tu64 *xattr_table_start, int *xattr_ids)\n{\n\tunsigned int len;\n\tstruct squashfs_xattr_id_table *id_table;\n\n\tid_table = squashfs_read_table(sb, start, sizeof(*id_table));\n\tif (IS_ERR(id_table))\n\t\treturn (__le64 *) id_table;\n\n\t*xattr_table_start = le64_to_cpu(id_table->xattr_table_start);\n\t*xattr_ids = le32_to_cpu(id_table->xattr_ids);\n\tkfree(id_table);\n\n\t/* Sanity check values */\n\n\t/* there is always at least one xattr id */\n\tif (*xattr_ids == 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* xattr_table should be less than start */\n\tif (*xattr_table_start >= start)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tlen = SQUASHFS_XATTR_BLOCK_BYTES(*xattr_ids);\n\n\tTRACE(\"In read_xattr_index_table, length %d\\n\", len);\n\n\treturn squashfs_read_table(sb, start + sizeof(*id_table), len);\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "squashfs_read_table",
          "args": [
            "sb",
            "start + sizeof(*id_table)",
            "len"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_read_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/cache.c",
          "lines": "416-458",
          "snippet": "void *squashfs_read_table(struct super_block *sb, u64 block, int length)\n{\n\tint pages = (length + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n\tint i, res;\n\tvoid *table, *buffer, **data;\n\tstruct squashfs_page_actor *actor;\n\n\ttable = buffer = kmalloc(length, GFP_KERNEL);\n\tif (table == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdata = kcalloc(pages, sizeof(void *), GFP_KERNEL);\n\tif (data == NULL) {\n\t\tres = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\tactor = squashfs_page_actor_init(data, pages, length);\n\tif (actor == NULL) {\n\t\tres = -ENOMEM;\n\t\tgoto failed2;\n\t}\n\n\tfor (i = 0; i < pages; i++, buffer += PAGE_CACHE_SIZE)\n\t\tdata[i] = buffer;\n\n\tres = squashfs_read_data(sb, block, length |\n\t\tSQUASHFS_COMPRESSED_BIT_BLOCK, NULL, actor);\n\n\tkfree(data);\n\tkfree(actor);\n\n\tif (res < 0)\n\t\tgoto failed;\n\n\treturn table;\n\nfailed2:\n\tkfree(data);\nfailed:\n\tkfree(table);\n\treturn ERR_PTR(res);\n}",
          "includes": [
            "#include \"page_actor.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/wait.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nvoid *squashfs_read_table(struct super_block *sb, u64 block, int length)\n{\n\tint pages = (length + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n\tint i, res;\n\tvoid *table, *buffer, **data;\n\tstruct squashfs_page_actor *actor;\n\n\ttable = buffer = kmalloc(length, GFP_KERNEL);\n\tif (table == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdata = kcalloc(pages, sizeof(void *), GFP_KERNEL);\n\tif (data == NULL) {\n\t\tres = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\tactor = squashfs_page_actor_init(data, pages, length);\n\tif (actor == NULL) {\n\t\tres = -ENOMEM;\n\t\tgoto failed2;\n\t}\n\n\tfor (i = 0; i < pages; i++, buffer += PAGE_CACHE_SIZE)\n\t\tdata[i] = buffer;\n\n\tres = squashfs_read_data(sb, block, length |\n\t\tSQUASHFS_COMPRESSED_BIT_BLOCK, NULL, actor);\n\n\tkfree(data);\n\tkfree(actor);\n\n\tif (res < 0)\n\t\tgoto failed;\n\n\treturn table;\n\nfailed2:\n\tkfree(data);\nfailed:\n\tkfree(table);\n\treturn ERR_PTR(res);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRACE",
          "args": [
            "\"In read_xattr_index_table, length %d\\n\"",
            "len"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SQUASHFS_XATTR_BLOCK_BYTES",
          "args": [
            "*xattr_ids"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "id_table"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "id_table->xattr_ids"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "id_table->xattr_table_start"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "id_table"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\n__le64 *squashfs_read_xattr_id_table(struct super_block *sb, u64 start,\n\t\tu64 *xattr_table_start, int *xattr_ids)\n{\n\tunsigned int len;\n\tstruct squashfs_xattr_id_table *id_table;\n\n\tid_table = squashfs_read_table(sb, start, sizeof(*id_table));\n\tif (IS_ERR(id_table))\n\t\treturn (__le64 *) id_table;\n\n\t*xattr_table_start = le64_to_cpu(id_table->xattr_table_start);\n\t*xattr_ids = le32_to_cpu(id_table->xattr_ids);\n\tkfree(id_table);\n\n\t/* Sanity check values */\n\n\t/* there is always at least one xattr id */\n\tif (*xattr_ids == 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* xattr_table should be less than start */\n\tif (*xattr_table_start >= start)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tlen = SQUASHFS_XATTR_BLOCK_BYTES(*xattr_ids);\n\n\tTRACE(\"In read_xattr_index_table, length %d\\n\", len);\n\n\treturn squashfs_read_table(sb, start + sizeof(*id_table), len);\n}"
  },
  {
    "function_name": "squashfs_xattr_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/xattr_id.c",
    "lines": "41-60",
    "snippet": "int squashfs_xattr_lookup(struct super_block *sb, unsigned int index,\n\t\tint *count, unsigned int *size, unsigned long long *xattr)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tint block = SQUASHFS_XATTR_BLOCK(index);\n\tint offset = SQUASHFS_XATTR_BLOCK_OFFSET(index);\n\tu64 start_block = le64_to_cpu(msblk->xattr_id_table[block]);\n\tstruct squashfs_xattr_id id;\n\tint err;\n\n\terr = squashfs_read_metadata(sb, &id, &start_block, &offset,\n\t\t\t\t\t\t\tsizeof(id));\n\tif (err < 0)\n\t\treturn err;\n\n\t*xattr = le64_to_cpu(id.xattr);\n\t*size = le32_to_cpu(id.size);\n\t*count = le32_to_cpu(id.count);\n\treturn 0;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "id.count"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "id.xattr"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "squashfs_read_metadata",
          "args": [
            "sb",
            "&id",
            "&start_block",
            "&offset",
            "sizeof(id)"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_read_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/cache.c",
          "lines": "344-382",
          "snippet": "int squashfs_read_metadata(struct super_block *sb, void *buffer,\n\t\tu64 *block, int *offset, int length)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tint bytes, res = length;\n\tstruct squashfs_cache_entry *entry;\n\n\tTRACE(\"Entered squashfs_read_metadata [%llx:%x]\\n\", *block, *offset);\n\n\twhile (length) {\n\t\tentry = squashfs_cache_get(sb, msblk->block_cache, *block, 0);\n\t\tif (entry->error) {\n\t\t\tres = entry->error;\n\t\t\tgoto error;\n\t\t} else if (*offset >= entry->length) {\n\t\t\tres = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\tbytes = squashfs_copy_data(buffer, entry, *offset, length);\n\t\tif (buffer)\n\t\t\tbuffer += bytes;\n\t\tlength -= bytes;\n\t\t*offset += bytes;\n\n\t\tif (*offset == entry->length) {\n\t\t\t*block = entry->next_index;\n\t\t\t*offset = 0;\n\t\t}\n\n\t\tsquashfs_cache_put(entry);\n\t}\n\n\treturn res;\n\nerror:\n\tsquashfs_cache_put(entry);\n\treturn res;\n}",
          "includes": [
            "#include \"page_actor.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/wait.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nint squashfs_read_metadata(struct super_block *sb, void *buffer,\n\t\tu64 *block, int *offset, int length)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tint bytes, res = length;\n\tstruct squashfs_cache_entry *entry;\n\n\tTRACE(\"Entered squashfs_read_metadata [%llx:%x]\\n\", *block, *offset);\n\n\twhile (length) {\n\t\tentry = squashfs_cache_get(sb, msblk->block_cache, *block, 0);\n\t\tif (entry->error) {\n\t\t\tres = entry->error;\n\t\t\tgoto error;\n\t\t} else if (*offset >= entry->length) {\n\t\t\tres = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\tbytes = squashfs_copy_data(buffer, entry, *offset, length);\n\t\tif (buffer)\n\t\t\tbuffer += bytes;\n\t\tlength -= bytes;\n\t\t*offset += bytes;\n\n\t\tif (*offset == entry->length) {\n\t\t\t*block = entry->next_index;\n\t\t\t*offset = 0;\n\t\t}\n\n\t\tsquashfs_cache_put(entry);\n\t}\n\n\treturn res;\n\nerror:\n\tsquashfs_cache_put(entry);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SQUASHFS_XATTR_BLOCK_OFFSET",
          "args": [
            "index"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SQUASHFS_XATTR_BLOCK",
          "args": [
            "index"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nint squashfs_xattr_lookup(struct super_block *sb, unsigned int index,\n\t\tint *count, unsigned int *size, unsigned long long *xattr)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tint block = SQUASHFS_XATTR_BLOCK(index);\n\tint offset = SQUASHFS_XATTR_BLOCK_OFFSET(index);\n\tu64 start_block = le64_to_cpu(msblk->xattr_id_table[block]);\n\tstruct squashfs_xattr_id id;\n\tint err;\n\n\terr = squashfs_read_metadata(sb, &id, &start_block, &offset,\n\t\t\t\t\t\t\tsizeof(id));\n\tif (err < 0)\n\t\treturn err;\n\n\t*xattr = le64_to_cpu(id.xattr);\n\t*size = le32_to_cpu(id.size);\n\t*count = le32_to_cpu(id.count);\n\treturn 0;\n}"
  }
]