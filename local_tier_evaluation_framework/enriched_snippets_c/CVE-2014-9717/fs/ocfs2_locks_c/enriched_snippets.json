[
  {
    "function_name": "ocfs2_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/locks.c",
    "lines": "130-141",
    "snippet": "int ocfs2_lock(struct file *file, int cmd, struct file_lock *fl)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (!(fl->fl_flags & FL_POSIX))\n\t\treturn -ENOLCK;\n\tif (__mandatory_lock(inode) && fl->fl_type != F_UNLCK)\n\t\treturn -ENOLCK;\n\n\treturn ocfs2_plock(osb->cconn, OCFS2_I(inode)->ip_blkno, file, cmd, fl);\n}",
    "includes": [
      "#include \"locks.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_plock",
          "args": [
            "osb->cconn",
            "OCFS2_I(inode)->ip_blkno",
            "file",
            "cmd",
            "fl"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_plock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "301-308",
          "snippet": "int ocfs2_plock(struct ocfs2_cluster_connection *conn, u64 ino,\n\t\tstruct file *file, int cmd, struct file_lock *fl)\n{\n\tWARN_ON_ONCE(active_stack->sp_ops->plock == NULL);\n\tif (active_stack->sp_ops->plock)\n\t\treturn active_stack->sp_ops->plock(conn, ino, file, cmd, fl);\n\treturn -EOPNOTSUPP;\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_stack_plugin *active_stack;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic struct ocfs2_stack_plugin *active_stack;\n\nint ocfs2_plock(struct ocfs2_cluster_connection *conn, u64 ino,\n\t\tstruct file *file, int cmd, struct file_lock *fl)\n{\n\tWARN_ON_ONCE(active_stack->sp_ops->plock == NULL);\n\tif (active_stack->sp_ops->plock)\n\t\treturn active_stack->sp_ops->plock(conn, ino, file, cmd, fl);\n\treturn -EOPNOTSUPP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__mandatory_lock",
          "args": [
            "inode"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locks.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n\nint ocfs2_lock(struct file *file, int cmd, struct file_lock *fl)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (!(fl->fl_flags & FL_POSIX))\n\t\treturn -ENOLCK;\n\tif (__mandatory_lock(inode) && fl->fl_type != F_UNLCK)\n\t\treturn -ENOLCK;\n\n\treturn ocfs2_plock(osb->cconn, OCFS2_I(inode)->ip_blkno, file, cmd, fl);\n}"
  },
  {
    "function_name": "ocfs2_flock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/locks.c",
    "lines": "110-128",
    "snippet": "int ocfs2_flock(struct file *file, int cmd, struct file_lock *fl)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (!(fl->fl_flags & FL_FLOCK))\n\t\treturn -ENOLCK;\n\tif (__mandatory_lock(inode))\n\t\treturn -ENOLCK;\n\n\tif ((osb->s_mount_opt & OCFS2_MOUNT_LOCALFLOCKS) ||\n\t    ocfs2_mount_local(osb))\n\t\treturn flock_lock_file_wait(file, fl);\n\n\tif (fl->fl_type == F_UNLCK)\n\t\treturn ocfs2_do_funlock(file, cmd, fl);\n\telse\n\t\treturn ocfs2_do_flock(file, inode, cmd, fl);\n}",
    "includes": [
      "#include \"locks.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_do_flock",
          "args": [
            "file",
            "inode",
            "cmd",
            "fl"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_do_flock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/locks.c",
          "lines": "38-92",
          "snippet": "static int ocfs2_do_flock(struct file *file, struct inode *inode,\n\t\t\t  int cmd, struct file_lock *fl)\n{\n\tint ret = 0, level = 0, trylock = 0;\n\tstruct ocfs2_file_private *fp = file->private_data;\n\tstruct ocfs2_lock_res *lockres = &fp->fp_flock;\n\n\tif (fl->fl_type == F_WRLCK)\n\t\tlevel = 1;\n\tif (!IS_SETLKW(cmd))\n\t\ttrylock = 1;\n\n\tmutex_lock(&fp->fp_mutex);\n\n\tif (lockres->l_flags & OCFS2_LOCK_ATTACHED &&\n\t    lockres->l_level > LKM_NLMODE) {\n\t\tint old_level = 0;\n\n\t\tif (lockres->l_level == LKM_EXMODE)\n\t\t\told_level = 1;\n\n\t\tif (level == old_level)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Converting an existing lock is not guaranteed to be\n\t\t * atomic, so we can get away with simply unlocking\n\t\t * here and allowing the lock code to try at the new\n\t\t * level.\n\t\t */\n\n\t\tflock_lock_file_wait(file,\n\t\t\t\t     &(struct file_lock){.fl_type = F_UNLCK});\n\n\t\tocfs2_file_unlock(file);\n\t}\n\n\tret = ocfs2_file_lock(file, level, trylock);\n\tif (ret) {\n\t\tif (ret == -EAGAIN && trylock)\n\t\t\tret = -EWOULDBLOCK;\n\t\telse\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = flock_lock_file_wait(file, fl);\n\tif (ret)\n\t\tocfs2_file_unlock(file);\n\nout:\n\tmutex_unlock(&fp->fp_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locks.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locks.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_do_flock(struct file *file, struct inode *inode,\n\t\t\t  int cmd, struct file_lock *fl)\n{\n\tint ret = 0, level = 0, trylock = 0;\n\tstruct ocfs2_file_private *fp = file->private_data;\n\tstruct ocfs2_lock_res *lockres = &fp->fp_flock;\n\n\tif (fl->fl_type == F_WRLCK)\n\t\tlevel = 1;\n\tif (!IS_SETLKW(cmd))\n\t\ttrylock = 1;\n\n\tmutex_lock(&fp->fp_mutex);\n\n\tif (lockres->l_flags & OCFS2_LOCK_ATTACHED &&\n\t    lockres->l_level > LKM_NLMODE) {\n\t\tint old_level = 0;\n\n\t\tif (lockres->l_level == LKM_EXMODE)\n\t\t\told_level = 1;\n\n\t\tif (level == old_level)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Converting an existing lock is not guaranteed to be\n\t\t * atomic, so we can get away with simply unlocking\n\t\t * here and allowing the lock code to try at the new\n\t\t * level.\n\t\t */\n\n\t\tflock_lock_file_wait(file,\n\t\t\t\t     &(struct file_lock){.fl_type = F_UNLCK});\n\n\t\tocfs2_file_unlock(file);\n\t}\n\n\tret = ocfs2_file_lock(file, level, trylock);\n\tif (ret) {\n\t\tif (ret == -EAGAIN && trylock)\n\t\t\tret = -EWOULDBLOCK;\n\t\telse\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = flock_lock_file_wait(file, fl);\n\tif (ret)\n\t\tocfs2_file_unlock(file);\n\nout:\n\tmutex_unlock(&fp->fp_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_do_funlock",
          "args": [
            "file",
            "cmd",
            "fl"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_do_funlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/locks.c",
          "lines": "94-105",
          "snippet": "static int ocfs2_do_funlock(struct file *file, int cmd, struct file_lock *fl)\n{\n\tint ret;\n\tstruct ocfs2_file_private *fp = file->private_data;\n\n\tmutex_lock(&fp->fp_mutex);\n\tocfs2_file_unlock(file);\n\tret = flock_lock_file_wait(file, fl);\n\tmutex_unlock(&fp->fp_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locks.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locks.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_do_funlock(struct file *file, int cmd, struct file_lock *fl)\n{\n\tint ret;\n\tstruct ocfs2_file_private *fp = file->private_data;\n\n\tmutex_lock(&fp->fp_mutex);\n\tocfs2_file_unlock(file);\n\tret = flock_lock_file_wait(file, fl);\n\tmutex_unlock(&fp->fp_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flock_lock_file_wait",
          "args": [
            "file",
            "fl"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "flock_lock_file_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1858-1874",
          "snippet": "int flock_lock_file_wait(struct file *filp, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep();\n\tfor (;;) {\n\t\terror = flock_lock_file(filp, fl);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint flock_lock_file_wait(struct file *filp, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep();\n\tfor (;;) {\n\t\terror = flock_lock_file(filp, fl);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_mount_local",
          "args": [
            "osb"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mount_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "668-671",
          "snippet": "static inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_mount_local(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_LOCAL_MOUNT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__mandatory_lock",
          "args": [
            "inode"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locks.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n\nint ocfs2_flock(struct file *file, int cmd, struct file_lock *fl)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (!(fl->fl_flags & FL_FLOCK))\n\t\treturn -ENOLCK;\n\tif (__mandatory_lock(inode))\n\t\treturn -ENOLCK;\n\n\tif ((osb->s_mount_opt & OCFS2_MOUNT_LOCALFLOCKS) ||\n\t    ocfs2_mount_local(osb))\n\t\treturn flock_lock_file_wait(file, fl);\n\n\tif (fl->fl_type == F_UNLCK)\n\t\treturn ocfs2_do_funlock(file, cmd, fl);\n\telse\n\t\treturn ocfs2_do_flock(file, inode, cmd, fl);\n}"
  },
  {
    "function_name": "ocfs2_do_funlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/locks.c",
    "lines": "94-105",
    "snippet": "static int ocfs2_do_funlock(struct file *file, int cmd, struct file_lock *fl)\n{\n\tint ret;\n\tstruct ocfs2_file_private *fp = file->private_data;\n\n\tmutex_lock(&fp->fp_mutex);\n\tocfs2_file_unlock(file);\n\tret = flock_lock_file_wait(file, fl);\n\tmutex_unlock(&fp->fp_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"locks.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fp->fp_mutex"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flock_lock_file_wait",
          "args": [
            "file",
            "fl"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "flock_lock_file_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1858-1874",
          "snippet": "int flock_lock_file_wait(struct file *filp, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep();\n\tfor (;;) {\n\t\terror = flock_lock_file(filp, fl);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint flock_lock_file_wait(struct file *filp, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep();\n\tfor (;;) {\n\t\terror = flock_lock_file(filp, fl);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_file_unlock",
          "args": [
            "file"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_file_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1961-2003",
          "snippet": "void ocfs2_file_unlock(struct file *file)\n{\n\tint ret;\n\tunsigned int gen;\n\tunsigned long flags;\n\tstruct ocfs2_file_private *fp = file->private_data;\n\tstruct ocfs2_lock_res *lockres = &fp->fp_flock;\n\tstruct ocfs2_super *osb = OCFS2_SB(file->f_mapping->host->i_sb);\n\tstruct ocfs2_mask_waiter mw;\n\n\tocfs2_init_mask_waiter(&mw);\n\n\tif (!(lockres->l_flags & OCFS2_LOCK_ATTACHED))\n\t\treturn;\n\n\tif (lockres->l_level == DLM_LOCK_NL)\n\t\treturn;\n\n\tmlog(0, \"Unlock: \\\"%s\\\" flags: 0x%lx, level: %d, act: %d\\n\",\n\t     lockres->l_name, lockres->l_flags, lockres->l_level,\n\t     lockres->l_action);\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\t/*\n\t * Fake a blocking ast for the downconvert code.\n\t */\n\tlockres_or_flags(lockres, OCFS2_LOCK_BLOCKED);\n\tlockres->l_blocking = DLM_LOCK_EX;\n\n\tgen = ocfs2_prepare_downconvert(lockres, DLM_LOCK_NL);\n\tlockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_BUSY, 0);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tret = ocfs2_downconvert_lock(osb, lockres, DLM_LOCK_NL, 0, gen);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn;\n\t}\n\n\tret = ocfs2_wait_for_mask(&mw);\n\tif (ret)\n\t\tmlog_errno(ret);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_data_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int blocking);",
            "static int ocfs2_dentry_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t       int blocking);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_refcount_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t int blocking);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_data_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int blocking);\nstatic int ocfs2_dentry_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t       int blocking);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_refcount_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t int blocking);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_file_unlock(struct file *file)\n{\n\tint ret;\n\tunsigned int gen;\n\tunsigned long flags;\n\tstruct ocfs2_file_private *fp = file->private_data;\n\tstruct ocfs2_lock_res *lockres = &fp->fp_flock;\n\tstruct ocfs2_super *osb = OCFS2_SB(file->f_mapping->host->i_sb);\n\tstruct ocfs2_mask_waiter mw;\n\n\tocfs2_init_mask_waiter(&mw);\n\n\tif (!(lockres->l_flags & OCFS2_LOCK_ATTACHED))\n\t\treturn;\n\n\tif (lockres->l_level == DLM_LOCK_NL)\n\t\treturn;\n\n\tmlog(0, \"Unlock: \\\"%s\\\" flags: 0x%lx, level: %d, act: %d\\n\",\n\t     lockres->l_name, lockres->l_flags, lockres->l_level,\n\t     lockres->l_action);\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\t/*\n\t * Fake a blocking ast for the downconvert code.\n\t */\n\tlockres_or_flags(lockres, OCFS2_LOCK_BLOCKED);\n\tlockres->l_blocking = DLM_LOCK_EX;\n\n\tgen = ocfs2_prepare_downconvert(lockres, DLM_LOCK_NL);\n\tlockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_BUSY, 0);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tret = ocfs2_downconvert_lock(osb, lockres, DLM_LOCK_NL, 0, gen);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn;\n\t}\n\n\tret = ocfs2_wait_for_mask(&mw);\n\tif (ret)\n\t\tmlog_errno(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fp->fp_mutex"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locks.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_do_funlock(struct file *file, int cmd, struct file_lock *fl)\n{\n\tint ret;\n\tstruct ocfs2_file_private *fp = file->private_data;\n\n\tmutex_lock(&fp->fp_mutex);\n\tocfs2_file_unlock(file);\n\tret = flock_lock_file_wait(file, fl);\n\tmutex_unlock(&fp->fp_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_do_flock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/locks.c",
    "lines": "38-92",
    "snippet": "static int ocfs2_do_flock(struct file *file, struct inode *inode,\n\t\t\t  int cmd, struct file_lock *fl)\n{\n\tint ret = 0, level = 0, trylock = 0;\n\tstruct ocfs2_file_private *fp = file->private_data;\n\tstruct ocfs2_lock_res *lockres = &fp->fp_flock;\n\n\tif (fl->fl_type == F_WRLCK)\n\t\tlevel = 1;\n\tif (!IS_SETLKW(cmd))\n\t\ttrylock = 1;\n\n\tmutex_lock(&fp->fp_mutex);\n\n\tif (lockres->l_flags & OCFS2_LOCK_ATTACHED &&\n\t    lockres->l_level > LKM_NLMODE) {\n\t\tint old_level = 0;\n\n\t\tif (lockres->l_level == LKM_EXMODE)\n\t\t\told_level = 1;\n\n\t\tif (level == old_level)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Converting an existing lock is not guaranteed to be\n\t\t * atomic, so we can get away with simply unlocking\n\t\t * here and allowing the lock code to try at the new\n\t\t * level.\n\t\t */\n\n\t\tflock_lock_file_wait(file,\n\t\t\t\t     &(struct file_lock){.fl_type = F_UNLCK});\n\n\t\tocfs2_file_unlock(file);\n\t}\n\n\tret = ocfs2_file_lock(file, level, trylock);\n\tif (ret) {\n\t\tif (ret == -EAGAIN && trylock)\n\t\t\tret = -EWOULDBLOCK;\n\t\telse\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = flock_lock_file_wait(file, fl);\n\tif (ret)\n\t\tocfs2_file_unlock(file);\n\nout:\n\tmutex_unlock(&fp->fp_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"locks.h\"",
      "#include \"inode.h\"",
      "#include \"file.h\"",
      "#include \"dlmglue.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fp->fp_mutex"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_file_unlock",
          "args": [
            "file"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_file_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1961-2003",
          "snippet": "void ocfs2_file_unlock(struct file *file)\n{\n\tint ret;\n\tunsigned int gen;\n\tunsigned long flags;\n\tstruct ocfs2_file_private *fp = file->private_data;\n\tstruct ocfs2_lock_res *lockres = &fp->fp_flock;\n\tstruct ocfs2_super *osb = OCFS2_SB(file->f_mapping->host->i_sb);\n\tstruct ocfs2_mask_waiter mw;\n\n\tocfs2_init_mask_waiter(&mw);\n\n\tif (!(lockres->l_flags & OCFS2_LOCK_ATTACHED))\n\t\treturn;\n\n\tif (lockres->l_level == DLM_LOCK_NL)\n\t\treturn;\n\n\tmlog(0, \"Unlock: \\\"%s\\\" flags: 0x%lx, level: %d, act: %d\\n\",\n\t     lockres->l_name, lockres->l_flags, lockres->l_level,\n\t     lockres->l_action);\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\t/*\n\t * Fake a blocking ast for the downconvert code.\n\t */\n\tlockres_or_flags(lockres, OCFS2_LOCK_BLOCKED);\n\tlockres->l_blocking = DLM_LOCK_EX;\n\n\tgen = ocfs2_prepare_downconvert(lockres, DLM_LOCK_NL);\n\tlockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_BUSY, 0);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tret = ocfs2_downconvert_lock(osb, lockres, DLM_LOCK_NL, 0, gen);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn;\n\t}\n\n\tret = ocfs2_wait_for_mask(&mw);\n\tif (ret)\n\t\tmlog_errno(ret);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_data_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int blocking);",
            "static int ocfs2_dentry_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t       int blocking);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_refcount_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t int blocking);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_data_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t     int blocking);\nstatic int ocfs2_dentry_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t       int blocking);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_refcount_convert_worker(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t int blocking);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_file_unlock(struct file *file)\n{\n\tint ret;\n\tunsigned int gen;\n\tunsigned long flags;\n\tstruct ocfs2_file_private *fp = file->private_data;\n\tstruct ocfs2_lock_res *lockres = &fp->fp_flock;\n\tstruct ocfs2_super *osb = OCFS2_SB(file->f_mapping->host->i_sb);\n\tstruct ocfs2_mask_waiter mw;\n\n\tocfs2_init_mask_waiter(&mw);\n\n\tif (!(lockres->l_flags & OCFS2_LOCK_ATTACHED))\n\t\treturn;\n\n\tif (lockres->l_level == DLM_LOCK_NL)\n\t\treturn;\n\n\tmlog(0, \"Unlock: \\\"%s\\\" flags: 0x%lx, level: %d, act: %d\\n\",\n\t     lockres->l_name, lockres->l_flags, lockres->l_level,\n\t     lockres->l_action);\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\t/*\n\t * Fake a blocking ast for the downconvert code.\n\t */\n\tlockres_or_flags(lockres, OCFS2_LOCK_BLOCKED);\n\tlockres->l_blocking = DLM_LOCK_EX;\n\n\tgen = ocfs2_prepare_downconvert(lockres, DLM_LOCK_NL);\n\tlockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_BUSY, 0);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tret = ocfs2_downconvert_lock(osb, lockres, DLM_LOCK_NL, 0, gen);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn;\n\t}\n\n\tret = ocfs2_wait_for_mask(&mw);\n\tif (ret)\n\t\tmlog_errno(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flock_lock_file_wait",
          "args": [
            "file",
            "fl"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "flock_lock_file_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "1858-1874",
          "snippet": "int flock_lock_file_wait(struct file *filp, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep();\n\tfor (;;) {\n\t\terror = flock_lock_file(filp, fl);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nint flock_lock_file_wait(struct file *filp, struct file_lock *fl)\n{\n\tint error;\n\tmight_sleep();\n\tfor (;;) {\n\t\terror = flock_lock_file(filp, fl);\n\t\tif (error != FILE_LOCK_DEFERRED)\n\t\t\tbreak;\n\t\terror = wait_event_interruptible(fl->fl_wait, !fl->fl_next);\n\t\tif (!error)\n\t\t\tcontinue;\n\n\t\tlocks_delete_block(fl);\n\t\tbreak;\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_file_lock",
          "args": [
            "file",
            "level",
            "trylock"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_file_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1865-1959",
          "snippet": "int ocfs2_file_lock(struct file *file, int ex, int trylock)\n{\n\tint ret, level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tunsigned int lkm_flags = trylock ? DLM_LKF_NOQUEUE : 0;\n\tunsigned long flags;\n\tstruct ocfs2_file_private *fp = file->private_data;\n\tstruct ocfs2_lock_res *lockres = &fp->fp_flock;\n\tstruct ocfs2_super *osb = OCFS2_SB(file->f_mapping->host->i_sb);\n\tstruct ocfs2_mask_waiter mw;\n\n\tocfs2_init_mask_waiter(&mw);\n\n\tif ((lockres->l_flags & OCFS2_LOCK_BUSY) ||\n\t    (lockres->l_level > DLM_LOCK_NL)) {\n\t\tmlog(ML_ERROR,\n\t\t     \"File lock \\\"%s\\\" has busy or locked state: flags: 0x%lx, \"\n\t\t     \"level: %u\\n\", lockres->l_name, lockres->l_flags,\n\t\t     lockres->l_level);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tif (!(lockres->l_flags & OCFS2_LOCK_ATTACHED)) {\n\t\tlockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_BUSY, 0);\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\t\t/*\n\t\t * Get the lock at NLMODE to start - that way we\n\t\t * can cancel the upconvert request if need be.\n\t\t */\n\t\tret = ocfs2_lock_create(osb, lockres, DLM_LOCK_NL, 0);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_wait_for_mask(&mw);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tspin_lock_irqsave(&lockres->l_lock, flags);\n\t}\n\n\tlockres->l_action = OCFS2_AST_CONVERT;\n\tlkm_flags |= DLM_LKF_CONVERT;\n\tlockres->l_requested = level;\n\tlockres_or_flags(lockres, OCFS2_LOCK_BUSY);\n\n\tlockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_BUSY, 0);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tret = ocfs2_dlm_lock(osb->cconn, level, &lockres->l_lksb, lkm_flags,\n\t\t\t     lockres->l_name, OCFS2_LOCK_ID_MAX_LEN - 1);\n\tif (ret) {\n\t\tif (!trylock || (ret != -EAGAIN)) {\n\t\t\tocfs2_log_dlm_error(\"ocfs2_dlm_lock\", ret, lockres);\n\t\t\tret = -EINVAL;\n\t\t}\n\n\t\tocfs2_recover_from_dlm_error(lockres, 1);\n\t\tlockres_remove_mask_waiter(lockres, &mw);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_wait_for_mask_interruptible(&mw, lockres);\n\tif (ret == -ERESTARTSYS) {\n\t\t/*\n\t\t * Userspace can cause deadlock itself with\n\t\t * flock(). Current behavior locally is to allow the\n\t\t * deadlock, but abort the system call if a signal is\n\t\t * received. We follow this example, otherwise a\n\t\t * poorly written program could sit in kernel until\n\t\t * reboot.\n\t\t *\n\t\t * Handling this is a bit more complicated for Ocfs2\n\t\t * though. We can't exit this function with an\n\t\t * outstanding lock request, so a cancel convert is\n\t\t * required. We intentionally overwrite 'ret' - if the\n\t\t * cancel fails and the lock was granted, it's easier\n\t\t * to just bubble success back up to the user.\n\t\t */\n\t\tret = ocfs2_flock_handle_signal(lockres, level);\n\t} else if (!ret && (level > lockres->l_level)) {\n\t\t/* Trylock failed asynchronously */\n\t\tBUG_ON(!trylock);\n\t\tret = -EAGAIN;\n\t}\n\nout:\n\n\tmlog(0, \"Lock: \\\"%s\\\" ex: %d, trylock: %d, returns: %d\\n\",\n\t     lockres->l_name, ex, trylock, ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_recover_from_dlm_error(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\tint convert);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_recover_from_dlm_error(struct ocfs2_lock_res *lockres,\n\t\t\t\t\t\tint convert);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nint ocfs2_file_lock(struct file *file, int ex, int trylock)\n{\n\tint ret, level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tunsigned int lkm_flags = trylock ? DLM_LKF_NOQUEUE : 0;\n\tunsigned long flags;\n\tstruct ocfs2_file_private *fp = file->private_data;\n\tstruct ocfs2_lock_res *lockres = &fp->fp_flock;\n\tstruct ocfs2_super *osb = OCFS2_SB(file->f_mapping->host->i_sb);\n\tstruct ocfs2_mask_waiter mw;\n\n\tocfs2_init_mask_waiter(&mw);\n\n\tif ((lockres->l_flags & OCFS2_LOCK_BUSY) ||\n\t    (lockres->l_level > DLM_LOCK_NL)) {\n\t\tmlog(ML_ERROR,\n\t\t     \"File lock \\\"%s\\\" has busy or locked state: flags: 0x%lx, \"\n\t\t     \"level: %u\\n\", lockres->l_name, lockres->l_flags,\n\t\t     lockres->l_level);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&lockres->l_lock, flags);\n\tif (!(lockres->l_flags & OCFS2_LOCK_ATTACHED)) {\n\t\tlockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_BUSY, 0);\n\t\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\t\t/*\n\t\t * Get the lock at NLMODE to start - that way we\n\t\t * can cancel the upconvert request if need be.\n\t\t */\n\t\tret = ocfs2_lock_create(osb, lockres, DLM_LOCK_NL, 0);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_wait_for_mask(&mw);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tspin_lock_irqsave(&lockres->l_lock, flags);\n\t}\n\n\tlockres->l_action = OCFS2_AST_CONVERT;\n\tlkm_flags |= DLM_LKF_CONVERT;\n\tlockres->l_requested = level;\n\tlockres_or_flags(lockres, OCFS2_LOCK_BUSY);\n\n\tlockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_BUSY, 0);\n\tspin_unlock_irqrestore(&lockres->l_lock, flags);\n\n\tret = ocfs2_dlm_lock(osb->cconn, level, &lockres->l_lksb, lkm_flags,\n\t\t\t     lockres->l_name, OCFS2_LOCK_ID_MAX_LEN - 1);\n\tif (ret) {\n\t\tif (!trylock || (ret != -EAGAIN)) {\n\t\t\tocfs2_log_dlm_error(\"ocfs2_dlm_lock\", ret, lockres);\n\t\t\tret = -EINVAL;\n\t\t}\n\n\t\tocfs2_recover_from_dlm_error(lockres, 1);\n\t\tlockres_remove_mask_waiter(lockres, &mw);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_wait_for_mask_interruptible(&mw, lockres);\n\tif (ret == -ERESTARTSYS) {\n\t\t/*\n\t\t * Userspace can cause deadlock itself with\n\t\t * flock(). Current behavior locally is to allow the\n\t\t * deadlock, but abort the system call if a signal is\n\t\t * received. We follow this example, otherwise a\n\t\t * poorly written program could sit in kernel until\n\t\t * reboot.\n\t\t *\n\t\t * Handling this is a bit more complicated for Ocfs2\n\t\t * though. We can't exit this function with an\n\t\t * outstanding lock request, so a cancel convert is\n\t\t * required. We intentionally overwrite 'ret' - if the\n\t\t * cancel fails and the lock was granted, it's easier\n\t\t * to just bubble success back up to the user.\n\t\t */\n\t\tret = ocfs2_flock_handle_signal(lockres, level);\n\t} else if (!ret && (level > lockres->l_level)) {\n\t\t/* Trylock failed asynchronously */\n\t\tBUG_ON(!trylock);\n\t\tret = -EAGAIN;\n\t}\n\nout:\n\n\tmlog(0, \"Lock: \\\"%s\\\" ex: %d, trylock: %d, returns: %d\\n\",\n\t     lockres->l_name, ex, trylock, ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fp->fp_mutex"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SETLKW",
          "args": [
            "cmd"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locks.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_do_flock(struct file *file, struct inode *inode,\n\t\t\t  int cmd, struct file_lock *fl)\n{\n\tint ret = 0, level = 0, trylock = 0;\n\tstruct ocfs2_file_private *fp = file->private_data;\n\tstruct ocfs2_lock_res *lockres = &fp->fp_flock;\n\n\tif (fl->fl_type == F_WRLCK)\n\t\tlevel = 1;\n\tif (!IS_SETLKW(cmd))\n\t\ttrylock = 1;\n\n\tmutex_lock(&fp->fp_mutex);\n\n\tif (lockres->l_flags & OCFS2_LOCK_ATTACHED &&\n\t    lockres->l_level > LKM_NLMODE) {\n\t\tint old_level = 0;\n\n\t\tif (lockres->l_level == LKM_EXMODE)\n\t\t\told_level = 1;\n\n\t\tif (level == old_level)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * Converting an existing lock is not guaranteed to be\n\t\t * atomic, so we can get away with simply unlocking\n\t\t * here and allowing the lock code to try at the new\n\t\t * level.\n\t\t */\n\n\t\tflock_lock_file_wait(file,\n\t\t\t\t     &(struct file_lock){.fl_type = F_UNLCK});\n\n\t\tocfs2_file_unlock(file);\n\t}\n\n\tret = ocfs2_file_lock(file, level, trylock);\n\tif (ret) {\n\t\tif (ret == -EAGAIN && trylock)\n\t\t\tret = -EWOULDBLOCK;\n\t\telse\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = flock_lock_file_wait(file, fl);\n\tif (ret)\n\t\tocfs2_file_unlock(file);\n\nout:\n\tmutex_unlock(&fp->fp_mutex);\n\n\treturn ret;\n}"
  }
]