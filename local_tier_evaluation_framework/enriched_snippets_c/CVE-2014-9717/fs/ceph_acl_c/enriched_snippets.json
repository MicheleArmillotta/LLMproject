[
  {
    "function_name": "ceph_release_acls_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/acl.c",
    "lines": "257-263",
    "snippet": "void ceph_release_acls_info(struct ceph_acls_info *info)\n{\n\tposix_acl_release(info->acl);\n\tposix_acl_release(info->default_acl);\n\tif (info->pagelist)\n\t\tceph_pagelist_release(info->pagelist);\n}",
    "includes": [
      "#include \"super.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_pagelist_release",
          "args": [
            "info->pagelist"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "info->default_acl"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "info->acl"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/posix_acl.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_release_acls_info(struct ceph_acls_info *info)\n{\n\tposix_acl_release(info->acl);\n\tposix_acl_release(info->default_acl);\n\tif (info->pagelist)\n\t\tceph_pagelist_release(info->pagelist);\n}"
  },
  {
    "function_name": "ceph_init_inode_acls",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/acl.c",
    "lines": "249-255",
    "snippet": "void ceph_init_inode_acls(struct inode* inode, struct ceph_acls_info *info)\n{\n\tif (!inode)\n\t\treturn;\n\tceph_set_cached_acl(inode, ACL_TYPE_ACCESS, info->acl);\n\tceph_set_cached_acl(inode, ACL_TYPE_DEFAULT, info->default_acl);\n}",
    "includes": [
      "#include \"super.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_set_cached_acl",
          "args": [
            "inode",
            "ACL_TYPE_DEFAULT",
            "info->default_acl"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_set_cached_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/acl.c",
          "lines": "32-41",
          "snippet": "static inline void ceph_set_cached_acl(struct inode *inode,\n\t\t\t\t\tint type, struct posix_acl *acl)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (__ceph_caps_issued_mask(ci, CEPH_CAP_XATTR_SHARED, 0))\n\t\tset_cached_acl(inode, type, acl);\n\tspin_unlock(&ci->i_ceph_lock);\n}",
          "includes": [
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/posix_acl.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline void ceph_set_cached_acl(struct inode *inode,\n\t\t\t\t\tint type, struct posix_acl *acl)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (__ceph_caps_issued_mask(ci, CEPH_CAP_XATTR_SHARED, 0))\n\t\tset_cached_acl(inode, type, acl);\n\tspin_unlock(&ci->i_ceph_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/posix_acl.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_init_inode_acls(struct inode* inode, struct ceph_acls_info *info)\n{\n\tif (!inode)\n\t\treturn;\n\tceph_set_cached_acl(inode, ACL_TYPE_ACCESS, info->acl);\n\tceph_set_cached_acl(inode, ACL_TYPE_DEFAULT, info->default_acl);\n}"
  },
  {
    "function_name": "ceph_pre_init_acls",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/acl.c",
    "lines": "158-247",
    "snippet": "int ceph_pre_init_acls(struct inode *dir, umode_t *mode,\n\t\t       struct ceph_acls_info *info)\n{\n\tstruct posix_acl *acl, *default_acl;\n\tsize_t val_size1 = 0, val_size2 = 0;\n\tstruct ceph_pagelist *pagelist = NULL;\n\tvoid *tmp_buf = NULL;\n\tint err;\n\n\terr = posix_acl_create(dir, mode, &default_acl, &acl);\n\tif (err)\n\t\treturn err;\n\n\tif (acl) {\n\t\tint ret = posix_acl_equiv_mode(acl, mode);\n\t\tif (ret < 0)\n\t\t\tgoto out_err;\n\t\tif (ret == 0) {\n\t\t\tposix_acl_release(acl);\n\t\t\tacl = NULL;\n\t\t}\n\t}\n\n\tif (!default_acl && !acl)\n\t\treturn 0;\n\n\tif (acl)\n\t\tval_size1 = posix_acl_xattr_size(acl->a_count);\n\tif (default_acl)\n\t\tval_size2 = posix_acl_xattr_size(default_acl->a_count);\n\n\terr = -ENOMEM;\n\ttmp_buf = kmalloc(max(val_size1, val_size2), GFP_NOFS);\n\tif (!tmp_buf)\n\t\tgoto out_err;\n\tpagelist = kmalloc(sizeof(struct ceph_pagelist), GFP_NOFS);\n\tif (!pagelist)\n\t\tgoto out_err;\n\tceph_pagelist_init(pagelist);\n\n\terr = ceph_pagelist_reserve(pagelist, PAGE_SIZE);\n\tif (err)\n\t\tgoto out_err;\n\n\tceph_pagelist_encode_32(pagelist, acl && default_acl ? 2 : 1);\n\n\tif (acl) {\n\t\tsize_t len = strlen(POSIX_ACL_XATTR_ACCESS);\n\t\terr = ceph_pagelist_reserve(pagelist, len + val_size1 + 8);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t\tceph_pagelist_encode_string(pagelist, POSIX_ACL_XATTR_ACCESS,\n\t\t\t\t\t    len);\n\t\terr = posix_acl_to_xattr(&init_user_ns, acl,\n\t\t\t\t\t tmp_buf, val_size1);\n\t\tif (err < 0)\n\t\t\tgoto out_err;\n\t\tceph_pagelist_encode_32(pagelist, val_size1);\n\t\tceph_pagelist_append(pagelist, tmp_buf, val_size1);\n\t}\n\tif (default_acl) {\n\t\tsize_t len = strlen(POSIX_ACL_XATTR_DEFAULT);\n\t\terr = ceph_pagelist_reserve(pagelist, len + val_size2 + 8);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t\terr = ceph_pagelist_encode_string(pagelist,\n\t\t\t\t\t\t  POSIX_ACL_XATTR_DEFAULT, len);\n\t\terr = posix_acl_to_xattr(&init_user_ns, default_acl,\n\t\t\t\t\t tmp_buf, val_size2);\n\t\tif (err < 0)\n\t\t\tgoto out_err;\n\t\tceph_pagelist_encode_32(pagelist, val_size2);\n\t\tceph_pagelist_append(pagelist, tmp_buf, val_size2);\n\t}\n\n\tkfree(tmp_buf);\n\n\tinfo->acl = acl;\n\tinfo->default_acl = default_acl;\n\tinfo->pagelist = pagelist;\n\treturn 0;\n\nout_err:\n\tposix_acl_release(acl);\n\tposix_acl_release(default_acl);\n\tkfree(tmp_buf);\n\tif (pagelist)\n\t\tceph_pagelist_release(pagelist);\n\treturn err;\n}",
    "includes": [
      "#include \"super.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_pagelist_release",
          "args": [
            "pagelist"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tmp_buf"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "default_acl"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "acl"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tmp_buf"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_pagelist_append",
          "args": [
            "pagelist",
            "tmp_buf",
            "val_size2"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_pagelist_encode_32",
          "args": [
            "pagelist",
            "val_size2"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_to_xattr",
          "args": [
            "&init_user_ns",
            "default_acl",
            "tmp_buf",
            "val_size2"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_to_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "731-767",
          "snippet": "int\nposix_acl_to_xattr(struct user_namespace *user_ns, const struct posix_acl *acl,\n\t\t   void *buffer, size_t size)\n{\n\tposix_acl_xattr_header *ext_acl = (posix_acl_xattr_header *)buffer;\n\tposix_acl_xattr_entry *ext_entry;\n\tint real_size, n;\n\n\treal_size = posix_acl_xattr_size(acl->a_count);\n\tif (!buffer)\n\t\treturn real_size;\n\tif (real_size > size)\n\t\treturn -ERANGE;\n\n\text_entry = ext_acl->a_entries;\n\text_acl->a_version = cpu_to_le32(POSIX_ACL_XATTR_VERSION);\n\n\tfor (n=0; n < acl->a_count; n++, ext_entry++) {\n\t\tconst struct posix_acl_entry *acl_e = &acl->a_entries[n];\n\t\text_entry->e_tag  = cpu_to_le16(acl_e->e_tag);\n\t\text_entry->e_perm = cpu_to_le16(acl_e->e_perm);\n\t\tswitch(acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\text_entry->e_id =\n\t\t\t\tcpu_to_le32(from_kuid(user_ns, acl_e->e_uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\text_entry->e_id =\n\t\t\t\tcpu_to_le32(from_kgid(user_ns, acl_e->e_gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\text_entry->e_id = cpu_to_le32(ACL_UNDEFINED_ID);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn real_size;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nposix_acl_to_xattr(struct user_namespace *user_ns, const struct posix_acl *acl,\n\t\t   void *buffer, size_t size)\n{\n\tposix_acl_xattr_header *ext_acl = (posix_acl_xattr_header *)buffer;\n\tposix_acl_xattr_entry *ext_entry;\n\tint real_size, n;\n\n\treal_size = posix_acl_xattr_size(acl->a_count);\n\tif (!buffer)\n\t\treturn real_size;\n\tif (real_size > size)\n\t\treturn -ERANGE;\n\n\text_entry = ext_acl->a_entries;\n\text_acl->a_version = cpu_to_le32(POSIX_ACL_XATTR_VERSION);\n\n\tfor (n=0; n < acl->a_count; n++, ext_entry++) {\n\t\tconst struct posix_acl_entry *acl_e = &acl->a_entries[n];\n\t\text_entry->e_tag  = cpu_to_le16(acl_e->e_tag);\n\t\text_entry->e_perm = cpu_to_le16(acl_e->e_perm);\n\t\tswitch(acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\text_entry->e_id =\n\t\t\t\tcpu_to_le32(from_kuid(user_ns, acl_e->e_uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\text_entry->e_id =\n\t\t\t\tcpu_to_le32(from_kgid(user_ns, acl_e->e_gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\text_entry->e_id = cpu_to_le32(ACL_UNDEFINED_ID);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn real_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_pagelist_encode_string",
          "args": [
            "pagelist",
            "POSIX_ACL_XATTR_DEFAULT",
            "len"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_pagelist_reserve",
          "args": [
            "pagelist",
            "len + val_size2 + 8"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "POSIX_ACL_XATTR_DEFAULT"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_pagelist_append",
          "args": [
            "pagelist",
            "tmp_buf",
            "val_size1"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_pagelist_encode_32",
          "args": [
            "pagelist",
            "val_size1"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_pagelist_encode_string",
          "args": [
            "pagelist",
            "POSIX_ACL_XATTR_ACCESS",
            "len"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_pagelist_reserve",
          "args": [
            "pagelist",
            "len + val_size1 + 8"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_pagelist_encode_32",
          "args": [
            "pagelist",
            "acl && default_acl ? 2 : 1"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_pagelist_reserve",
          "args": [
            "pagelist",
            "PAGE_SIZE"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_pagelist_init",
          "args": [
            "pagelist"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct ceph_pagelist)",
            "GFP_NOFS"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "val_size1",
            "val_size2"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "check_max_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "2175-2196",
          "snippet": "static void check_max_size(struct inode *inode, loff_t endoff)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint check = 0;\n\n\t/* do we need to explicitly request a larger max_size? */\n\tspin_lock(&ci->i_ceph_lock);\n\tif (endoff >= ci->i_max_size && endoff > ci->i_wanted_max_size) {\n\t\tdout(\"write %p at large endoff %llu, req max_size\\n\",\n\t\t     inode, endoff);\n\t\tci->i_wanted_max_size = endoff;\n\t}\n\t/* duplicate ceph_check_caps()'s logic */\n\tif (ci->i_auth_cap &&\n\t    (ci->i_auth_cap->issued & CEPH_CAP_FILE_WR) &&\n\t    ci->i_wanted_max_size > ci->i_max_size &&\n\t    ci->i_wanted_max_size > ci->i_requested_max_size)\n\t\tcheck = 1;\n\tspin_unlock(&ci->i_ceph_lock);\n\tif (check)\n\t\tceph_check_caps(ci, CHECK_CAPS_AUTHONLY, NULL);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void check_max_size(struct inode *inode, loff_t endoff)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint check = 0;\n\n\t/* do we need to explicitly request a larger max_size? */\n\tspin_lock(&ci->i_ceph_lock);\n\tif (endoff >= ci->i_max_size && endoff > ci->i_wanted_max_size) {\n\t\tdout(\"write %p at large endoff %llu, req max_size\\n\",\n\t\t     inode, endoff);\n\t\tci->i_wanted_max_size = endoff;\n\t}\n\t/* duplicate ceph_check_caps()'s logic */\n\tif (ci->i_auth_cap &&\n\t    (ci->i_auth_cap->issued & CEPH_CAP_FILE_WR) &&\n\t    ci->i_wanted_max_size > ci->i_max_size &&\n\t    ci->i_wanted_max_size > ci->i_requested_max_size)\n\t\tcheck = 1;\n\tspin_unlock(&ci->i_ceph_lock);\n\tif (check)\n\t\tceph_check_caps(ci, CHECK_CAPS_AUTHONLY, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_xattr_size",
          "args": [
            "default_acl->a_count"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_xattr_size",
          "args": [
            "acl->a_count"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "acl"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_equiv_mode",
          "args": [
            "acl",
            "mode"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_equiv_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "242-282",
          "snippet": "int\nposix_acl_equiv_mode(const struct posix_acl *acl, umode_t *mode_p)\n{\n\tconst struct posix_acl_entry *pa, *pe;\n\tumode_t mode = 0;\n\tint not_equiv = 0;\n\n\t/*\n\t * A null ACL can always be presented as mode bits.\n\t */\n\tif (!acl)\n\t\treturn 0;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch (pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 6;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 3;\n\t\t\t\tbreak;\n\t\t\tcase ACL_OTHER:\n\t\t\t\tmode |= pa->e_perm & S_IRWXO;\n\t\t\t\tbreak;\n\t\t\tcase ACL_MASK:\n\t\t\t\tmode = (mode & ~S_IRWXG) |\n\t\t\t\t       ((pa->e_perm & S_IRWXO) << 3);\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n        if (mode_p)\n                *mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nposix_acl_equiv_mode(const struct posix_acl *acl, umode_t *mode_p)\n{\n\tconst struct posix_acl_entry *pa, *pe;\n\tumode_t mode = 0;\n\tint not_equiv = 0;\n\n\t/*\n\t * A null ACL can always be presented as mode bits.\n\t */\n\tif (!acl)\n\t\treturn 0;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch (pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 6;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 3;\n\t\t\t\tbreak;\n\t\t\tcase ACL_OTHER:\n\t\t\t\tmode |= pa->e_perm & S_IRWXO;\n\t\t\t\tbreak;\n\t\t\tcase ACL_MASK:\n\t\t\t\tmode = (mode & ~S_IRWXG) |\n\t\t\t\t       ((pa->e_perm & S_IRWXO) << 3);\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n        if (mode_p)\n                *mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_create",
          "args": [
            "dir",
            "mode",
            "&default_acl",
            "&acl"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "545-598",
          "snippet": "int\nposix_acl_create(struct inode *dir, umode_t *mode,\n\t\tstruct posix_acl **default_acl, struct posix_acl **acl)\n{\n\tstruct posix_acl *p;\n\tint ret;\n\n\tif (S_ISLNK(*mode) || !IS_POSIXACL(dir))\n\t\tgoto no_acl;\n\n\tp = get_acl(dir, ACL_TYPE_DEFAULT);\n\tif (IS_ERR(p)) {\n\t\tif (p == ERR_PTR(-EOPNOTSUPP))\n\t\t\tgoto apply_umask;\n\t\treturn PTR_ERR(p);\n\t}\n\n\tif (!p)\n\t\tgoto apply_umask;\n\n\t*acl = posix_acl_clone(p, GFP_NOFS);\n\tif (!*acl)\n\t\tgoto no_mem;\n\n\tret = posix_acl_create_masq(*acl, mode);\n\tif (ret < 0)\n\t\tgoto no_mem_clone;\n\n\tif (ret == 0) {\n\t\tposix_acl_release(*acl);\n\t\t*acl = NULL;\n\t}\n\n\tif (!S_ISDIR(*mode)) {\n\t\tposix_acl_release(p);\n\t\t*default_acl = NULL;\n\t} else {\n\t\t*default_acl = p;\n\t}\n\treturn 0;\n\napply_umask:\n\t*mode &= ~current_umask();\nno_acl:\n\t*default_acl = NULL;\n\t*acl = NULL;\n\treturn 0;\n\nno_mem_clone:\n\tposix_acl_release(*acl);\nno_mem:\n\tposix_acl_release(p);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nposix_acl_create(struct inode *dir, umode_t *mode,\n\t\tstruct posix_acl **default_acl, struct posix_acl **acl)\n{\n\tstruct posix_acl *p;\n\tint ret;\n\n\tif (S_ISLNK(*mode) || !IS_POSIXACL(dir))\n\t\tgoto no_acl;\n\n\tp = get_acl(dir, ACL_TYPE_DEFAULT);\n\tif (IS_ERR(p)) {\n\t\tif (p == ERR_PTR(-EOPNOTSUPP))\n\t\t\tgoto apply_umask;\n\t\treturn PTR_ERR(p);\n\t}\n\n\tif (!p)\n\t\tgoto apply_umask;\n\n\t*acl = posix_acl_clone(p, GFP_NOFS);\n\tif (!*acl)\n\t\tgoto no_mem;\n\n\tret = posix_acl_create_masq(*acl, mode);\n\tif (ret < 0)\n\t\tgoto no_mem_clone;\n\n\tif (ret == 0) {\n\t\tposix_acl_release(*acl);\n\t\t*acl = NULL;\n\t}\n\n\tif (!S_ISDIR(*mode)) {\n\t\tposix_acl_release(p);\n\t\t*default_acl = NULL;\n\t} else {\n\t\t*default_acl = p;\n\t}\n\treturn 0;\n\napply_umask:\n\t*mode &= ~current_umask();\nno_acl:\n\t*default_acl = NULL;\n\t*acl = NULL;\n\treturn 0;\n\nno_mem_clone:\n\tposix_acl_release(*acl);\nno_mem:\n\tposix_acl_release(p);\n\treturn -ENOMEM;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/posix_acl.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_pre_init_acls(struct inode *dir, umode_t *mode,\n\t\t       struct ceph_acls_info *info)\n{\n\tstruct posix_acl *acl, *default_acl;\n\tsize_t val_size1 = 0, val_size2 = 0;\n\tstruct ceph_pagelist *pagelist = NULL;\n\tvoid *tmp_buf = NULL;\n\tint err;\n\n\terr = posix_acl_create(dir, mode, &default_acl, &acl);\n\tif (err)\n\t\treturn err;\n\n\tif (acl) {\n\t\tint ret = posix_acl_equiv_mode(acl, mode);\n\t\tif (ret < 0)\n\t\t\tgoto out_err;\n\t\tif (ret == 0) {\n\t\t\tposix_acl_release(acl);\n\t\t\tacl = NULL;\n\t\t}\n\t}\n\n\tif (!default_acl && !acl)\n\t\treturn 0;\n\n\tif (acl)\n\t\tval_size1 = posix_acl_xattr_size(acl->a_count);\n\tif (default_acl)\n\t\tval_size2 = posix_acl_xattr_size(default_acl->a_count);\n\n\terr = -ENOMEM;\n\ttmp_buf = kmalloc(max(val_size1, val_size2), GFP_NOFS);\n\tif (!tmp_buf)\n\t\tgoto out_err;\n\tpagelist = kmalloc(sizeof(struct ceph_pagelist), GFP_NOFS);\n\tif (!pagelist)\n\t\tgoto out_err;\n\tceph_pagelist_init(pagelist);\n\n\terr = ceph_pagelist_reserve(pagelist, PAGE_SIZE);\n\tif (err)\n\t\tgoto out_err;\n\n\tceph_pagelist_encode_32(pagelist, acl && default_acl ? 2 : 1);\n\n\tif (acl) {\n\t\tsize_t len = strlen(POSIX_ACL_XATTR_ACCESS);\n\t\terr = ceph_pagelist_reserve(pagelist, len + val_size1 + 8);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t\tceph_pagelist_encode_string(pagelist, POSIX_ACL_XATTR_ACCESS,\n\t\t\t\t\t    len);\n\t\terr = posix_acl_to_xattr(&init_user_ns, acl,\n\t\t\t\t\t tmp_buf, val_size1);\n\t\tif (err < 0)\n\t\t\tgoto out_err;\n\t\tceph_pagelist_encode_32(pagelist, val_size1);\n\t\tceph_pagelist_append(pagelist, tmp_buf, val_size1);\n\t}\n\tif (default_acl) {\n\t\tsize_t len = strlen(POSIX_ACL_XATTR_DEFAULT);\n\t\terr = ceph_pagelist_reserve(pagelist, len + val_size2 + 8);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t\terr = ceph_pagelist_encode_string(pagelist,\n\t\t\t\t\t\t  POSIX_ACL_XATTR_DEFAULT, len);\n\t\terr = posix_acl_to_xattr(&init_user_ns, default_acl,\n\t\t\t\t\t tmp_buf, val_size2);\n\t\tif (err < 0)\n\t\t\tgoto out_err;\n\t\tceph_pagelist_encode_32(pagelist, val_size2);\n\t\tceph_pagelist_append(pagelist, tmp_buf, val_size2);\n\t}\n\n\tkfree(tmp_buf);\n\n\tinfo->acl = acl;\n\tinfo->default_acl = default_acl;\n\tinfo->pagelist = pagelist;\n\treturn 0;\n\nout_err:\n\tposix_acl_release(acl);\n\tposix_acl_release(default_acl);\n\tkfree(tmp_buf);\n\tif (pagelist)\n\t\tceph_pagelist_release(pagelist);\n\treturn err;\n}"
  },
  {
    "function_name": "ceph_set_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/acl.c",
    "lines": "84-156",
    "snippet": "int ceph_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint ret = 0, size = 0;\n\tconst char *name = NULL;\n\tchar *value = NULL;\n\tstruct iattr newattrs;\n\tumode_t new_mode = inode->i_mode, old_mode = inode->i_mode;\n\tstruct dentry *dentry;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = POSIX_ACL_XATTR_ACCESS;\n\t\tif (acl) {\n\t\t\tret = posix_acl_equiv_mode(acl, &new_mode);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode)) {\n\t\t\tret = acl ? -EINVAL : 0;\n\t\t\tgoto out;\n\t\t}\n\t\tname = POSIX_ACL_XATTR_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_NOFS);\n\t\tif (!value) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (ret < 0)\n\t\t\tgoto out_free;\n\t}\n\n\tdentry = d_find_alias(inode);\n\tif (new_mode != old_mode) {\n\t\tnewattrs.ia_mode = new_mode;\n\t\tnewattrs.ia_valid = ATTR_MODE;\n\t\tret = ceph_setattr(dentry, &newattrs);\n\t\tif (ret)\n\t\t\tgoto out_dput;\n\t}\n\n\tret = __ceph_setxattr(dentry, name, value, size, 0);\n\tif (ret) {\n\t\tif (new_mode != old_mode) {\n\t\t\tnewattrs.ia_mode = old_mode;\n\t\t\tnewattrs.ia_valid = ATTR_MODE;\n\t\t\tceph_setattr(dentry, &newattrs);\n\t\t}\n\t\tgoto out_dput;\n\t}\n\n\tceph_set_cached_acl(inode, type, acl);\n\nout_dput:\n\tdput(dentry);\nout_free:\n\tkfree(value);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"super.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "value"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_set_cached_acl",
          "args": [
            "inode",
            "type",
            "acl"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_set_cached_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/acl.c",
          "lines": "32-41",
          "snippet": "static inline void ceph_set_cached_acl(struct inode *inode,\n\t\t\t\t\tint type, struct posix_acl *acl)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (__ceph_caps_issued_mask(ci, CEPH_CAP_XATTR_SHARED, 0))\n\t\tset_cached_acl(inode, type, acl);\n\tspin_unlock(&ci->i_ceph_lock);\n}",
          "includes": [
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/posix_acl.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline void ceph_set_cached_acl(struct inode *inode,\n\t\t\t\t\tint type, struct posix_acl *acl)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (__ceph_caps_issued_mask(ci, CEPH_CAP_XATTR_SHARED, 0))\n\t\tset_cached_acl(inode, type, acl);\n\tspin_unlock(&ci->i_ceph_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_setattr",
          "args": [
            "dentry",
            "&newattrs"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_setattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
          "lines": "1715-1918",
          "snippet": "int ceph_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tconst unsigned int ia_valid = attr->ia_valid;\n\tstruct ceph_mds_request *req;\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(dentry->d_sb)->mdsc;\n\tint issued;\n\tint release = 0, dirtied = 0;\n\tint mask = 0;\n\tint err = 0;\n\tint inode_dirty_flags = 0;\n\n\tif (ceph_snap(inode) != CEPH_NOSNAP)\n\t\treturn -EROFS;\n\n\terr = inode_change_ok(inode, attr);\n\tif (err != 0)\n\t\treturn err;\n\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_SETATTR,\n\t\t\t\t       USE_AUTH_MDS);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tissued = __ceph_caps_issued(ci, NULL);\n\tdout(\"setattr %p issued %s\\n\", inode, ceph_cap_string(issued));\n\n\tif (ia_valid & ATTR_UID) {\n\t\tdout(\"setattr %p uid %d -> %d\\n\", inode,\n\t\t     from_kuid(&init_user_ns, inode->i_uid),\n\t\t     from_kuid(&init_user_ns, attr->ia_uid));\n\t\tif (issued & CEPH_CAP_AUTH_EXCL) {\n\t\t\tinode->i_uid = attr->ia_uid;\n\t\t\tdirtied |= CEPH_CAP_AUTH_EXCL;\n\t\t} else if ((issued & CEPH_CAP_AUTH_SHARED) == 0 ||\n\t\t\t   !uid_eq(attr->ia_uid, inode->i_uid)) {\n\t\t\treq->r_args.setattr.uid = cpu_to_le32(\n\t\t\t\tfrom_kuid(&init_user_ns, attr->ia_uid));\n\t\t\tmask |= CEPH_SETATTR_UID;\n\t\t\trelease |= CEPH_CAP_AUTH_SHARED;\n\t\t}\n\t}\n\tif (ia_valid & ATTR_GID) {\n\t\tdout(\"setattr %p gid %d -> %d\\n\", inode,\n\t\t     from_kgid(&init_user_ns, inode->i_gid),\n\t\t     from_kgid(&init_user_ns, attr->ia_gid));\n\t\tif (issued & CEPH_CAP_AUTH_EXCL) {\n\t\t\tinode->i_gid = attr->ia_gid;\n\t\t\tdirtied |= CEPH_CAP_AUTH_EXCL;\n\t\t} else if ((issued & CEPH_CAP_AUTH_SHARED) == 0 ||\n\t\t\t   !gid_eq(attr->ia_gid, inode->i_gid)) {\n\t\t\treq->r_args.setattr.gid = cpu_to_le32(\n\t\t\t\tfrom_kgid(&init_user_ns, attr->ia_gid));\n\t\t\tmask |= CEPH_SETATTR_GID;\n\t\t\trelease |= CEPH_CAP_AUTH_SHARED;\n\t\t}\n\t}\n\tif (ia_valid & ATTR_MODE) {\n\t\tdout(\"setattr %p mode 0%o -> 0%o\\n\", inode, inode->i_mode,\n\t\t     attr->ia_mode);\n\t\tif (issued & CEPH_CAP_AUTH_EXCL) {\n\t\t\tinode->i_mode = attr->ia_mode;\n\t\t\tdirtied |= CEPH_CAP_AUTH_EXCL;\n\t\t} else if ((issued & CEPH_CAP_AUTH_SHARED) == 0 ||\n\t\t\t   attr->ia_mode != inode->i_mode) {\n\t\t\tinode->i_mode = attr->ia_mode;\n\t\t\treq->r_args.setattr.mode = cpu_to_le32(attr->ia_mode);\n\t\t\tmask |= CEPH_SETATTR_MODE;\n\t\t\trelease |= CEPH_CAP_AUTH_SHARED;\n\t\t}\n\t}\n\n\tif (ia_valid & ATTR_ATIME) {\n\t\tdout(\"setattr %p atime %ld.%ld -> %ld.%ld\\n\", inode,\n\t\t     inode->i_atime.tv_sec, inode->i_atime.tv_nsec,\n\t\t     attr->ia_atime.tv_sec, attr->ia_atime.tv_nsec);\n\t\tif (issued & CEPH_CAP_FILE_EXCL) {\n\t\t\tci->i_time_warp_seq++;\n\t\t\tinode->i_atime = attr->ia_atime;\n\t\t\tdirtied |= CEPH_CAP_FILE_EXCL;\n\t\t} else if ((issued & CEPH_CAP_FILE_WR) &&\n\t\t\t   timespec_compare(&inode->i_atime,\n\t\t\t\t\t    &attr->ia_atime) < 0) {\n\t\t\tinode->i_atime = attr->ia_atime;\n\t\t\tdirtied |= CEPH_CAP_FILE_WR;\n\t\t} else if ((issued & CEPH_CAP_FILE_SHARED) == 0 ||\n\t\t\t   !timespec_equal(&inode->i_atime, &attr->ia_atime)) {\n\t\t\tceph_encode_timespec(&req->r_args.setattr.atime,\n\t\t\t\t\t     &attr->ia_atime);\n\t\t\tmask |= CEPH_SETATTR_ATIME;\n\t\t\trelease |= CEPH_CAP_FILE_CACHE | CEPH_CAP_FILE_RD |\n\t\t\t\tCEPH_CAP_FILE_WR;\n\t\t}\n\t}\n\tif (ia_valid & ATTR_MTIME) {\n\t\tdout(\"setattr %p mtime %ld.%ld -> %ld.%ld\\n\", inode,\n\t\t     inode->i_mtime.tv_sec, inode->i_mtime.tv_nsec,\n\t\t     attr->ia_mtime.tv_sec, attr->ia_mtime.tv_nsec);\n\t\tif (issued & CEPH_CAP_FILE_EXCL) {\n\t\t\tci->i_time_warp_seq++;\n\t\t\tinode->i_mtime = attr->ia_mtime;\n\t\t\tdirtied |= CEPH_CAP_FILE_EXCL;\n\t\t} else if ((issued & CEPH_CAP_FILE_WR) &&\n\t\t\t   timespec_compare(&inode->i_mtime,\n\t\t\t\t\t    &attr->ia_mtime) < 0) {\n\t\t\tinode->i_mtime = attr->ia_mtime;\n\t\t\tdirtied |= CEPH_CAP_FILE_WR;\n\t\t} else if ((issued & CEPH_CAP_FILE_SHARED) == 0 ||\n\t\t\t   !timespec_equal(&inode->i_mtime, &attr->ia_mtime)) {\n\t\t\tceph_encode_timespec(&req->r_args.setattr.mtime,\n\t\t\t\t\t     &attr->ia_mtime);\n\t\t\tmask |= CEPH_SETATTR_MTIME;\n\t\t\trelease |= CEPH_CAP_FILE_SHARED | CEPH_CAP_FILE_RD |\n\t\t\t\tCEPH_CAP_FILE_WR;\n\t\t}\n\t}\n\tif (ia_valid & ATTR_SIZE) {\n\t\tdout(\"setattr %p size %lld -> %lld\\n\", inode,\n\t\t     inode->i_size, attr->ia_size);\n\t\tif ((issued & CEPH_CAP_FILE_EXCL) &&\n\t\t    attr->ia_size > inode->i_size) {\n\t\t\tinode->i_size = attr->ia_size;\n\t\t\tinode->i_blocks =\n\t\t\t\t(attr->ia_size + (1 << 9) - 1) >> 9;\n\t\t\tinode->i_ctime = attr->ia_ctime;\n\t\t\tci->i_reported_size = attr->ia_size;\n\t\t\tdirtied |= CEPH_CAP_FILE_EXCL;\n\t\t} else if ((issued & CEPH_CAP_FILE_SHARED) == 0 ||\n\t\t\t   attr->ia_size != inode->i_size) {\n\t\t\treq->r_args.setattr.size = cpu_to_le64(attr->ia_size);\n\t\t\treq->r_args.setattr.old_size =\n\t\t\t\tcpu_to_le64(inode->i_size);\n\t\t\tmask |= CEPH_SETATTR_SIZE;\n\t\t\trelease |= CEPH_CAP_FILE_SHARED | CEPH_CAP_FILE_RD |\n\t\t\t\tCEPH_CAP_FILE_WR;\n\t\t}\n\t}\n\n\t/* these do nothing */\n\tif (ia_valid & ATTR_CTIME) {\n\t\tbool only = (ia_valid & (ATTR_SIZE|ATTR_MTIME|ATTR_ATIME|\n\t\t\t\t\t ATTR_MODE|ATTR_UID|ATTR_GID)) == 0;\n\t\tdout(\"setattr %p ctime %ld.%ld -> %ld.%ld (%s)\\n\", inode,\n\t\t     inode->i_ctime.tv_sec, inode->i_ctime.tv_nsec,\n\t\t     attr->ia_ctime.tv_sec, attr->ia_ctime.tv_nsec,\n\t\t     only ? \"ctime only\" : \"ignored\");\n\t\tinode->i_ctime = attr->ia_ctime;\n\t\tif (only) {\n\t\t\t/*\n\t\t\t * if kernel wants to dirty ctime but nothing else,\n\t\t\t * we need to choose a cap to dirty under, or do\n\t\t\t * a almost-no-op setattr\n\t\t\t */\n\t\t\tif (issued & CEPH_CAP_AUTH_EXCL)\n\t\t\t\tdirtied |= CEPH_CAP_AUTH_EXCL;\n\t\t\telse if (issued & CEPH_CAP_FILE_EXCL)\n\t\t\t\tdirtied |= CEPH_CAP_FILE_EXCL;\n\t\t\telse if (issued & CEPH_CAP_XATTR_EXCL)\n\t\t\t\tdirtied |= CEPH_CAP_XATTR_EXCL;\n\t\t\telse\n\t\t\t\tmask |= CEPH_SETATTR_CTIME;\n\t\t}\n\t}\n\tif (ia_valid & ATTR_FILE)\n\t\tdout(\"setattr %p ATTR_FILE ... hrm!\\n\", inode);\n\n\tif (dirtied) {\n\t\tinode_dirty_flags = __ceph_mark_dirty_caps(ci, dirtied);\n\t\tinode->i_ctime = CURRENT_TIME;\n\t}\n\n\trelease &= issued;\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (inode_dirty_flags)\n\t\t__mark_inode_dirty(inode, inode_dirty_flags);\n\n\tif (ia_valid & ATTR_MODE) {\n\t\terr = posix_acl_chmod(inode, attr->ia_mode);\n\t\tif (err)\n\t\t\tgoto out_put;\n\t}\n\n\tif (mask) {\n\t\treq->r_inode = inode;\n\t\tihold(inode);\n\t\treq->r_inode_drop = release;\n\t\treq->r_args.setattr.mask = cpu_to_le32(mask);\n\t\treq->r_num_caps = 1;\n\t\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\t}\n\tdout(\"setattr %p result=%d (%s locally, %d remote)\\n\", inode, err,\n\t     ceph_cap_string(dirtied), mask);\n\n\tceph_mdsc_put_request(req);\n\tif (mask & CEPH_SETATTR_SIZE)\n\t\t__ceph_do_pending_vmtruncate(inode);\n\treturn err;\nout_put:\n\tceph_mdsc_put_request(req);\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tconst unsigned int ia_valid = attr->ia_valid;\n\tstruct ceph_mds_request *req;\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(dentry->d_sb)->mdsc;\n\tint issued;\n\tint release = 0, dirtied = 0;\n\tint mask = 0;\n\tint err = 0;\n\tint inode_dirty_flags = 0;\n\n\tif (ceph_snap(inode) != CEPH_NOSNAP)\n\t\treturn -EROFS;\n\n\terr = inode_change_ok(inode, attr);\n\tif (err != 0)\n\t\treturn err;\n\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_SETATTR,\n\t\t\t\t       USE_AUTH_MDS);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tissued = __ceph_caps_issued(ci, NULL);\n\tdout(\"setattr %p issued %s\\n\", inode, ceph_cap_string(issued));\n\n\tif (ia_valid & ATTR_UID) {\n\t\tdout(\"setattr %p uid %d -> %d\\n\", inode,\n\t\t     from_kuid(&init_user_ns, inode->i_uid),\n\t\t     from_kuid(&init_user_ns, attr->ia_uid));\n\t\tif (issued & CEPH_CAP_AUTH_EXCL) {\n\t\t\tinode->i_uid = attr->ia_uid;\n\t\t\tdirtied |= CEPH_CAP_AUTH_EXCL;\n\t\t} else if ((issued & CEPH_CAP_AUTH_SHARED) == 0 ||\n\t\t\t   !uid_eq(attr->ia_uid, inode->i_uid)) {\n\t\t\treq->r_args.setattr.uid = cpu_to_le32(\n\t\t\t\tfrom_kuid(&init_user_ns, attr->ia_uid));\n\t\t\tmask |= CEPH_SETATTR_UID;\n\t\t\trelease |= CEPH_CAP_AUTH_SHARED;\n\t\t}\n\t}\n\tif (ia_valid & ATTR_GID) {\n\t\tdout(\"setattr %p gid %d -> %d\\n\", inode,\n\t\t     from_kgid(&init_user_ns, inode->i_gid),\n\t\t     from_kgid(&init_user_ns, attr->ia_gid));\n\t\tif (issued & CEPH_CAP_AUTH_EXCL) {\n\t\t\tinode->i_gid = attr->ia_gid;\n\t\t\tdirtied |= CEPH_CAP_AUTH_EXCL;\n\t\t} else if ((issued & CEPH_CAP_AUTH_SHARED) == 0 ||\n\t\t\t   !gid_eq(attr->ia_gid, inode->i_gid)) {\n\t\t\treq->r_args.setattr.gid = cpu_to_le32(\n\t\t\t\tfrom_kgid(&init_user_ns, attr->ia_gid));\n\t\t\tmask |= CEPH_SETATTR_GID;\n\t\t\trelease |= CEPH_CAP_AUTH_SHARED;\n\t\t}\n\t}\n\tif (ia_valid & ATTR_MODE) {\n\t\tdout(\"setattr %p mode 0%o -> 0%o\\n\", inode, inode->i_mode,\n\t\t     attr->ia_mode);\n\t\tif (issued & CEPH_CAP_AUTH_EXCL) {\n\t\t\tinode->i_mode = attr->ia_mode;\n\t\t\tdirtied |= CEPH_CAP_AUTH_EXCL;\n\t\t} else if ((issued & CEPH_CAP_AUTH_SHARED) == 0 ||\n\t\t\t   attr->ia_mode != inode->i_mode) {\n\t\t\tinode->i_mode = attr->ia_mode;\n\t\t\treq->r_args.setattr.mode = cpu_to_le32(attr->ia_mode);\n\t\t\tmask |= CEPH_SETATTR_MODE;\n\t\t\trelease |= CEPH_CAP_AUTH_SHARED;\n\t\t}\n\t}\n\n\tif (ia_valid & ATTR_ATIME) {\n\t\tdout(\"setattr %p atime %ld.%ld -> %ld.%ld\\n\", inode,\n\t\t     inode->i_atime.tv_sec, inode->i_atime.tv_nsec,\n\t\t     attr->ia_atime.tv_sec, attr->ia_atime.tv_nsec);\n\t\tif (issued & CEPH_CAP_FILE_EXCL) {\n\t\t\tci->i_time_warp_seq++;\n\t\t\tinode->i_atime = attr->ia_atime;\n\t\t\tdirtied |= CEPH_CAP_FILE_EXCL;\n\t\t} else if ((issued & CEPH_CAP_FILE_WR) &&\n\t\t\t   timespec_compare(&inode->i_atime,\n\t\t\t\t\t    &attr->ia_atime) < 0) {\n\t\t\tinode->i_atime = attr->ia_atime;\n\t\t\tdirtied |= CEPH_CAP_FILE_WR;\n\t\t} else if ((issued & CEPH_CAP_FILE_SHARED) == 0 ||\n\t\t\t   !timespec_equal(&inode->i_atime, &attr->ia_atime)) {\n\t\t\tceph_encode_timespec(&req->r_args.setattr.atime,\n\t\t\t\t\t     &attr->ia_atime);\n\t\t\tmask |= CEPH_SETATTR_ATIME;\n\t\t\trelease |= CEPH_CAP_FILE_CACHE | CEPH_CAP_FILE_RD |\n\t\t\t\tCEPH_CAP_FILE_WR;\n\t\t}\n\t}\n\tif (ia_valid & ATTR_MTIME) {\n\t\tdout(\"setattr %p mtime %ld.%ld -> %ld.%ld\\n\", inode,\n\t\t     inode->i_mtime.tv_sec, inode->i_mtime.tv_nsec,\n\t\t     attr->ia_mtime.tv_sec, attr->ia_mtime.tv_nsec);\n\t\tif (issued & CEPH_CAP_FILE_EXCL) {\n\t\t\tci->i_time_warp_seq++;\n\t\t\tinode->i_mtime = attr->ia_mtime;\n\t\t\tdirtied |= CEPH_CAP_FILE_EXCL;\n\t\t} else if ((issued & CEPH_CAP_FILE_WR) &&\n\t\t\t   timespec_compare(&inode->i_mtime,\n\t\t\t\t\t    &attr->ia_mtime) < 0) {\n\t\t\tinode->i_mtime = attr->ia_mtime;\n\t\t\tdirtied |= CEPH_CAP_FILE_WR;\n\t\t} else if ((issued & CEPH_CAP_FILE_SHARED) == 0 ||\n\t\t\t   !timespec_equal(&inode->i_mtime, &attr->ia_mtime)) {\n\t\t\tceph_encode_timespec(&req->r_args.setattr.mtime,\n\t\t\t\t\t     &attr->ia_mtime);\n\t\t\tmask |= CEPH_SETATTR_MTIME;\n\t\t\trelease |= CEPH_CAP_FILE_SHARED | CEPH_CAP_FILE_RD |\n\t\t\t\tCEPH_CAP_FILE_WR;\n\t\t}\n\t}\n\tif (ia_valid & ATTR_SIZE) {\n\t\tdout(\"setattr %p size %lld -> %lld\\n\", inode,\n\t\t     inode->i_size, attr->ia_size);\n\t\tif ((issued & CEPH_CAP_FILE_EXCL) &&\n\t\t    attr->ia_size > inode->i_size) {\n\t\t\tinode->i_size = attr->ia_size;\n\t\t\tinode->i_blocks =\n\t\t\t\t(attr->ia_size + (1 << 9) - 1) >> 9;\n\t\t\tinode->i_ctime = attr->ia_ctime;\n\t\t\tci->i_reported_size = attr->ia_size;\n\t\t\tdirtied |= CEPH_CAP_FILE_EXCL;\n\t\t} else if ((issued & CEPH_CAP_FILE_SHARED) == 0 ||\n\t\t\t   attr->ia_size != inode->i_size) {\n\t\t\treq->r_args.setattr.size = cpu_to_le64(attr->ia_size);\n\t\t\treq->r_args.setattr.old_size =\n\t\t\t\tcpu_to_le64(inode->i_size);\n\t\t\tmask |= CEPH_SETATTR_SIZE;\n\t\t\trelease |= CEPH_CAP_FILE_SHARED | CEPH_CAP_FILE_RD |\n\t\t\t\tCEPH_CAP_FILE_WR;\n\t\t}\n\t}\n\n\t/* these do nothing */\n\tif (ia_valid & ATTR_CTIME) {\n\t\tbool only = (ia_valid & (ATTR_SIZE|ATTR_MTIME|ATTR_ATIME|\n\t\t\t\t\t ATTR_MODE|ATTR_UID|ATTR_GID)) == 0;\n\t\tdout(\"setattr %p ctime %ld.%ld -> %ld.%ld (%s)\\n\", inode,\n\t\t     inode->i_ctime.tv_sec, inode->i_ctime.tv_nsec,\n\t\t     attr->ia_ctime.tv_sec, attr->ia_ctime.tv_nsec,\n\t\t     only ? \"ctime only\" : \"ignored\");\n\t\tinode->i_ctime = attr->ia_ctime;\n\t\tif (only) {\n\t\t\t/*\n\t\t\t * if kernel wants to dirty ctime but nothing else,\n\t\t\t * we need to choose a cap to dirty under, or do\n\t\t\t * a almost-no-op setattr\n\t\t\t */\n\t\t\tif (issued & CEPH_CAP_AUTH_EXCL)\n\t\t\t\tdirtied |= CEPH_CAP_AUTH_EXCL;\n\t\t\telse if (issued & CEPH_CAP_FILE_EXCL)\n\t\t\t\tdirtied |= CEPH_CAP_FILE_EXCL;\n\t\t\telse if (issued & CEPH_CAP_XATTR_EXCL)\n\t\t\t\tdirtied |= CEPH_CAP_XATTR_EXCL;\n\t\t\telse\n\t\t\t\tmask |= CEPH_SETATTR_CTIME;\n\t\t}\n\t}\n\tif (ia_valid & ATTR_FILE)\n\t\tdout(\"setattr %p ATTR_FILE ... hrm!\\n\", inode);\n\n\tif (dirtied) {\n\t\tinode_dirty_flags = __ceph_mark_dirty_caps(ci, dirtied);\n\t\tinode->i_ctime = CURRENT_TIME;\n\t}\n\n\trelease &= issued;\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (inode_dirty_flags)\n\t\t__mark_inode_dirty(inode, inode_dirty_flags);\n\n\tif (ia_valid & ATTR_MODE) {\n\t\terr = posix_acl_chmod(inode, attr->ia_mode);\n\t\tif (err)\n\t\t\tgoto out_put;\n\t}\n\n\tif (mask) {\n\t\treq->r_inode = inode;\n\t\tihold(inode);\n\t\treq->r_inode_drop = release;\n\t\treq->r_args.setattr.mask = cpu_to_le32(mask);\n\t\treq->r_num_caps = 1;\n\t\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\t}\n\tdout(\"setattr %p result=%d (%s locally, %d remote)\\n\", inode, err,\n\t     ceph_cap_string(dirtied), mask);\n\n\tceph_mdsc_put_request(req);\n\tif (mask & CEPH_SETATTR_SIZE)\n\t\t__ceph_do_pending_vmtruncate(inode);\n\treturn err;\nout_put:\n\tceph_mdsc_put_request(req);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_setxattr",
          "args": [
            "dentry",
            "name",
            "value",
            "size",
            "0"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_setxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "901-993",
          "snippet": "int __ceph_setxattr(struct dentry *dentry, const char *name,\n\t\t\tconst void *value, size_t size, int flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ceph_vxattr *vxattr;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint issued;\n\tint err;\n\tint dirty = 0;\n\tint name_len = strlen(name);\n\tint val_len = size;\n\tchar *newname = NULL;\n\tchar *newval = NULL;\n\tstruct ceph_inode_xattr *xattr = NULL;\n\tint required_blob_size;\n\n\tif (!ceph_is_valid_xattr(name))\n\t\treturn -EOPNOTSUPP;\n\n\tvxattr = ceph_match_vxattr(inode, name);\n\tif (vxattr && vxattr->readonly)\n\t\treturn -EOPNOTSUPP;\n\n\t/* pass any unhandled ceph.* xattrs through to the MDS */\n\tif (!strncmp(name, XATTR_CEPH_PREFIX, XATTR_CEPH_PREFIX_LEN))\n\t\tgoto do_sync_unlocked;\n\n\t/* preallocate memory for xattr name, value, index node */\n\terr = -ENOMEM;\n\tnewname = kmemdup(name, name_len + 1, GFP_NOFS);\n\tif (!newname)\n\t\tgoto out;\n\n\tif (val_len) {\n\t\tnewval = kmemdup(value, val_len, GFP_NOFS);\n\t\tif (!newval)\n\t\t\tgoto out;\n\t}\n\n\txattr = kmalloc(sizeof(struct ceph_inode_xattr), GFP_NOFS);\n\tif (!xattr)\n\t\tgoto out;\n\n\tspin_lock(&ci->i_ceph_lock);\nretry:\n\tissued = __ceph_caps_issued(ci, NULL);\n\tdout(\"setxattr %p issued %s\\n\", inode, ceph_cap_string(issued));\n\tif (ci->i_xattrs.version == 0 || !(issued & CEPH_CAP_XATTR_EXCL))\n\t\tgoto do_sync;\n\t__build_xattrs(inode);\n\n\trequired_blob_size = __get_required_blob_size(ci, name_len, val_len);\n\n\tif (!ci->i_xattrs.prealloc_blob ||\n\t    required_blob_size > ci->i_xattrs.prealloc_blob->alloc_len) {\n\t\tstruct ceph_buffer *blob;\n\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tdout(\" preaallocating new blob size=%d\\n\", required_blob_size);\n\t\tblob = ceph_buffer_new(required_blob_size, GFP_NOFS);\n\t\tif (!blob)\n\t\t\tgoto out;\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tif (ci->i_xattrs.prealloc_blob)\n\t\t\tceph_buffer_put(ci->i_xattrs.prealloc_blob);\n\t\tci->i_xattrs.prealloc_blob = blob;\n\t\tgoto retry;\n\t}\n\n\terr = __set_xattr(ci, newname, name_len, newval, val_len,\n\t\t\t  flags, value ? 1 : -1, &xattr);\n\n\tif (!err) {\n\t\tdirty = __ceph_mark_dirty_caps(ci, CEPH_CAP_XATTR_EXCL);\n\t\tci->i_xattrs.dirty = true;\n\t\tinode->i_ctime = CURRENT_TIME;\n\t}\n\n\tspin_unlock(&ci->i_ceph_lock);\n\tif (dirty)\n\t\t__mark_inode_dirty(inode, dirty);\n\treturn err;\n\ndo_sync:\n\tspin_unlock(&ci->i_ceph_lock);\ndo_sync_unlocked:\n\terr = ceph_sync_setxattr(dentry, name, value, size, flags);\nout:\n\tkfree(newname);\n\tkfree(newval);\n\tkfree(xattr);\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [
            "#define XATTR_CEPH_PREFIX_LEN (sizeof (XATTR_CEPH_PREFIX) - 1)",
            "#define XATTR_CEPH_PREFIX \"ceph.\""
          ],
          "globals_used": [
            "static int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\n#define XATTR_CEPH_PREFIX_LEN (sizeof (XATTR_CEPH_PREFIX) - 1)\n#define XATTR_CEPH_PREFIX \"ceph.\"\n\nstatic int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);\n\nint __ceph_setxattr(struct dentry *dentry, const char *name,\n\t\t\tconst void *value, size_t size, int flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ceph_vxattr *vxattr;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint issued;\n\tint err;\n\tint dirty = 0;\n\tint name_len = strlen(name);\n\tint val_len = size;\n\tchar *newname = NULL;\n\tchar *newval = NULL;\n\tstruct ceph_inode_xattr *xattr = NULL;\n\tint required_blob_size;\n\n\tif (!ceph_is_valid_xattr(name))\n\t\treturn -EOPNOTSUPP;\n\n\tvxattr = ceph_match_vxattr(inode, name);\n\tif (vxattr && vxattr->readonly)\n\t\treturn -EOPNOTSUPP;\n\n\t/* pass any unhandled ceph.* xattrs through to the MDS */\n\tif (!strncmp(name, XATTR_CEPH_PREFIX, XATTR_CEPH_PREFIX_LEN))\n\t\tgoto do_sync_unlocked;\n\n\t/* preallocate memory for xattr name, value, index node */\n\terr = -ENOMEM;\n\tnewname = kmemdup(name, name_len + 1, GFP_NOFS);\n\tif (!newname)\n\t\tgoto out;\n\n\tif (val_len) {\n\t\tnewval = kmemdup(value, val_len, GFP_NOFS);\n\t\tif (!newval)\n\t\t\tgoto out;\n\t}\n\n\txattr = kmalloc(sizeof(struct ceph_inode_xattr), GFP_NOFS);\n\tif (!xattr)\n\t\tgoto out;\n\n\tspin_lock(&ci->i_ceph_lock);\nretry:\n\tissued = __ceph_caps_issued(ci, NULL);\n\tdout(\"setxattr %p issued %s\\n\", inode, ceph_cap_string(issued));\n\tif (ci->i_xattrs.version == 0 || !(issued & CEPH_CAP_XATTR_EXCL))\n\t\tgoto do_sync;\n\t__build_xattrs(inode);\n\n\trequired_blob_size = __get_required_blob_size(ci, name_len, val_len);\n\n\tif (!ci->i_xattrs.prealloc_blob ||\n\t    required_blob_size > ci->i_xattrs.prealloc_blob->alloc_len) {\n\t\tstruct ceph_buffer *blob;\n\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tdout(\" preaallocating new blob size=%d\\n\", required_blob_size);\n\t\tblob = ceph_buffer_new(required_blob_size, GFP_NOFS);\n\t\tif (!blob)\n\t\t\tgoto out;\n\t\tspin_lock(&ci->i_ceph_lock);\n\t\tif (ci->i_xattrs.prealloc_blob)\n\t\t\tceph_buffer_put(ci->i_xattrs.prealloc_blob);\n\t\tci->i_xattrs.prealloc_blob = blob;\n\t\tgoto retry;\n\t}\n\n\terr = __set_xattr(ci, newname, name_len, newval, val_len,\n\t\t\t  flags, value ? 1 : -1, &xattr);\n\n\tif (!err) {\n\t\tdirty = __ceph_mark_dirty_caps(ci, CEPH_CAP_XATTR_EXCL);\n\t\tci->i_xattrs.dirty = true;\n\t\tinode->i_ctime = CURRENT_TIME;\n\t}\n\n\tspin_unlock(&ci->i_ceph_lock);\n\tif (dirty)\n\t\t__mark_inode_dirty(inode, dirty);\n\treturn err;\n\ndo_sync:\n\tspin_unlock(&ci->i_ceph_lock);\ndo_sync_unlocked:\n\terr = ceph_sync_setxattr(dentry, name, value, size, flags);\nout:\n\tkfree(newname);\n\tkfree(newval);\n\tkfree(xattr);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_find_alias",
          "args": [
            "inode"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "d_find_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "865-875",
          "snippet": "struct dentry *d_find_alias(struct inode *inode)\n{\n\tstruct dentry *de = NULL;\n\n\tif (!hlist_empty(&inode->i_dentry)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tde = __d_find_alias(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\treturn de;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_find_alias(struct inode *inode)\n{\n\tstruct dentry *de = NULL;\n\n\tif (!hlist_empty(&inode->i_dentry)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tde = __d_find_alias(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\treturn de;\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_to_xattr",
          "args": [
            "&init_user_ns",
            "acl",
            "value",
            "size"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_to_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "731-767",
          "snippet": "int\nposix_acl_to_xattr(struct user_namespace *user_ns, const struct posix_acl *acl,\n\t\t   void *buffer, size_t size)\n{\n\tposix_acl_xattr_header *ext_acl = (posix_acl_xattr_header *)buffer;\n\tposix_acl_xattr_entry *ext_entry;\n\tint real_size, n;\n\n\treal_size = posix_acl_xattr_size(acl->a_count);\n\tif (!buffer)\n\t\treturn real_size;\n\tif (real_size > size)\n\t\treturn -ERANGE;\n\n\text_entry = ext_acl->a_entries;\n\text_acl->a_version = cpu_to_le32(POSIX_ACL_XATTR_VERSION);\n\n\tfor (n=0; n < acl->a_count; n++, ext_entry++) {\n\t\tconst struct posix_acl_entry *acl_e = &acl->a_entries[n];\n\t\text_entry->e_tag  = cpu_to_le16(acl_e->e_tag);\n\t\text_entry->e_perm = cpu_to_le16(acl_e->e_perm);\n\t\tswitch(acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\text_entry->e_id =\n\t\t\t\tcpu_to_le32(from_kuid(user_ns, acl_e->e_uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\text_entry->e_id =\n\t\t\t\tcpu_to_le32(from_kgid(user_ns, acl_e->e_gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\text_entry->e_id = cpu_to_le32(ACL_UNDEFINED_ID);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn real_size;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nposix_acl_to_xattr(struct user_namespace *user_ns, const struct posix_acl *acl,\n\t\t   void *buffer, size_t size)\n{\n\tposix_acl_xattr_header *ext_acl = (posix_acl_xattr_header *)buffer;\n\tposix_acl_xattr_entry *ext_entry;\n\tint real_size, n;\n\n\treal_size = posix_acl_xattr_size(acl->a_count);\n\tif (!buffer)\n\t\treturn real_size;\n\tif (real_size > size)\n\t\treturn -ERANGE;\n\n\text_entry = ext_acl->a_entries;\n\text_acl->a_version = cpu_to_le32(POSIX_ACL_XATTR_VERSION);\n\n\tfor (n=0; n < acl->a_count; n++, ext_entry++) {\n\t\tconst struct posix_acl_entry *acl_e = &acl->a_entries[n];\n\t\text_entry->e_tag  = cpu_to_le16(acl_e->e_tag);\n\t\text_entry->e_perm = cpu_to_le16(acl_e->e_perm);\n\t\tswitch(acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\text_entry->e_id =\n\t\t\t\tcpu_to_le32(from_kuid(user_ns, acl_e->e_uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\text_entry->e_id =\n\t\t\t\tcpu_to_le32(from_kgid(user_ns, acl_e->e_gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\text_entry->e_id = cpu_to_le32(ACL_UNDEFINED_ID);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn real_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "size",
            "GFP_NOFS"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_xattr_size",
          "args": [
            "acl->a_count"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_equiv_mode",
          "args": [
            "acl",
            "&new_mode"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_equiv_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "242-282",
          "snippet": "int\nposix_acl_equiv_mode(const struct posix_acl *acl, umode_t *mode_p)\n{\n\tconst struct posix_acl_entry *pa, *pe;\n\tumode_t mode = 0;\n\tint not_equiv = 0;\n\n\t/*\n\t * A null ACL can always be presented as mode bits.\n\t */\n\tif (!acl)\n\t\treturn 0;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch (pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 6;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 3;\n\t\t\t\tbreak;\n\t\t\tcase ACL_OTHER:\n\t\t\t\tmode |= pa->e_perm & S_IRWXO;\n\t\t\t\tbreak;\n\t\t\tcase ACL_MASK:\n\t\t\t\tmode = (mode & ~S_IRWXG) |\n\t\t\t\t       ((pa->e_perm & S_IRWXO) << 3);\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n        if (mode_p)\n                *mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nposix_acl_equiv_mode(const struct posix_acl *acl, umode_t *mode_p)\n{\n\tconst struct posix_acl_entry *pa, *pe;\n\tumode_t mode = 0;\n\tint not_equiv = 0;\n\n\t/*\n\t * A null ACL can always be presented as mode bits.\n\t */\n\tif (!acl)\n\t\treturn 0;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch (pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 6;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 3;\n\t\t\t\tbreak;\n\t\t\tcase ACL_OTHER:\n\t\t\t\tmode |= pa->e_perm & S_IRWXO;\n\t\t\t\tbreak;\n\t\t\tcase ACL_MASK:\n\t\t\t\tmode = (mode & ~S_IRWXG) |\n\t\t\t\t       ((pa->e_perm & S_IRWXO) << 3);\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n        if (mode_p)\n                *mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/posix_acl.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint ret = 0, size = 0;\n\tconst char *name = NULL;\n\tchar *value = NULL;\n\tstruct iattr newattrs;\n\tumode_t new_mode = inode->i_mode, old_mode = inode->i_mode;\n\tstruct dentry *dentry;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = POSIX_ACL_XATTR_ACCESS;\n\t\tif (acl) {\n\t\t\tret = posix_acl_equiv_mode(acl, &new_mode);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode)) {\n\t\t\tret = acl ? -EINVAL : 0;\n\t\t\tgoto out;\n\t\t}\n\t\tname = POSIX_ACL_XATTR_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_NOFS);\n\t\tif (!value) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (ret < 0)\n\t\t\tgoto out_free;\n\t}\n\n\tdentry = d_find_alias(inode);\n\tif (new_mode != old_mode) {\n\t\tnewattrs.ia_mode = new_mode;\n\t\tnewattrs.ia_valid = ATTR_MODE;\n\t\tret = ceph_setattr(dentry, &newattrs);\n\t\tif (ret)\n\t\t\tgoto out_dput;\n\t}\n\n\tret = __ceph_setxattr(dentry, name, value, size, 0);\n\tif (ret) {\n\t\tif (new_mode != old_mode) {\n\t\t\tnewattrs.ia_mode = old_mode;\n\t\t\tnewattrs.ia_valid = ATTR_MODE;\n\t\t\tceph_setattr(dentry, &newattrs);\n\t\t}\n\t\tgoto out_dput;\n\t}\n\n\tceph_set_cached_acl(inode, type, acl);\n\nout_dput:\n\tdput(dentry);\nout_free:\n\tkfree(value);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ceph_get_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/acl.c",
    "lines": "43-82",
    "snippet": "struct posix_acl *ceph_get_acl(struct inode *inode, int type)\n{\n\tint size;\n\tconst char *name;\n\tchar *value = NULL;\n\tstruct posix_acl *acl;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = POSIX_ACL_XATTR_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = POSIX_ACL_XATTR_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tsize = __ceph_getxattr(inode, name, \"\", 0);\n\tif (size > 0) {\n\t\tvalue = kzalloc(size, GFP_NOFS);\n\t\tif (!value)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tsize = __ceph_getxattr(inode, name, value, size);\n\t}\n\n\tif (size > 0)\n\t\tacl = posix_acl_from_xattr(&init_user_ns, value, size);\n\telse if (size == -ERANGE || size == -ENODATA || size == 0)\n\t\tacl = NULL;\n\telse\n\t\tacl = ERR_PTR(-EIO);\n\n\tkfree(value);\n\n\tif (!IS_ERR(acl))\n\t\tceph_set_cached_acl(inode, type, acl);\n\n\treturn acl;\n}",
    "includes": [
      "#include \"super.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_set_cached_acl",
          "args": [
            "inode",
            "type",
            "acl"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_set_cached_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/acl.c",
          "lines": "32-41",
          "snippet": "static inline void ceph_set_cached_acl(struct inode *inode,\n\t\t\t\t\tint type, struct posix_acl *acl)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (__ceph_caps_issued_mask(ci, CEPH_CAP_XATTR_SHARED, 0))\n\t\tset_cached_acl(inode, type, acl);\n\tspin_unlock(&ci->i_ceph_lock);\n}",
          "includes": [
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/posix_acl.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline void ceph_set_cached_acl(struct inode *inode,\n\t\t\t\t\tint type, struct posix_acl *acl)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (__ceph_caps_issued_mask(ci, CEPH_CAP_XATTR_SHARED, 0))\n\t\tset_cached_acl(inode, type, acl);\n\tspin_unlock(&ci->i_ceph_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "acl"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "value"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_from_xattr",
          "args": [
            "&init_user_ns",
            "value",
            "size"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_from_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "662-725",
          "snippet": "struct posix_acl *\nposix_acl_from_xattr(struct user_namespace *user_ns,\n\t\t     const void *value, size_t size)\n{\n\tposix_acl_xattr_header *header = (posix_acl_xattr_header *)value;\n\tposix_acl_xattr_entry *entry = (posix_acl_xattr_entry *)(header+1), *end;\n\tint count;\n\tstruct posix_acl *acl;\n\tstruct posix_acl_entry *acl_e;\n\n\tif (!value)\n\t\treturn NULL;\n\tif (size < sizeof(posix_acl_xattr_header))\n\t\t return ERR_PTR(-EINVAL);\n\tif (header->a_version != cpu_to_le32(POSIX_ACL_XATTR_VERSION))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tcount = posix_acl_xattr_count(size);\n\tif (count < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (count == 0)\n\t\treturn NULL;\n\t\n\tacl = posix_acl_alloc(count, GFP_NOFS);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tacl_e = acl->a_entries;\n\t\n\tfor (end = entry + count; entry != end; acl_e++, entry++) {\n\t\tacl_e->e_tag  = le16_to_cpu(entry->e_tag);\n\t\tacl_e->e_perm = le16_to_cpu(entry->e_perm);\n\n\t\tswitch(acl_e->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\tcase ACL_MASK:\n\t\t\tcase ACL_OTHER:\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\t\tacl_e->e_uid =\n\t\t\t\t\tmake_kuid(user_ns,\n\t\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\t\tif (!uid_valid(acl_e->e_uid))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP:\n\t\t\t\tacl_e->e_gid =\n\t\t\t\t\tmake_kgid(user_ns,\n\t\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\t\tif (!gid_valid(acl_e->e_gid))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct posix_acl *\nposix_acl_from_xattr(struct user_namespace *user_ns,\n\t\t     const void *value, size_t size)\n{\n\tposix_acl_xattr_header *header = (posix_acl_xattr_header *)value;\n\tposix_acl_xattr_entry *entry = (posix_acl_xattr_entry *)(header+1), *end;\n\tint count;\n\tstruct posix_acl *acl;\n\tstruct posix_acl_entry *acl_e;\n\n\tif (!value)\n\t\treturn NULL;\n\tif (size < sizeof(posix_acl_xattr_header))\n\t\t return ERR_PTR(-EINVAL);\n\tif (header->a_version != cpu_to_le32(POSIX_ACL_XATTR_VERSION))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tcount = posix_acl_xattr_count(size);\n\tif (count < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (count == 0)\n\t\treturn NULL;\n\t\n\tacl = posix_acl_alloc(count, GFP_NOFS);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tacl_e = acl->a_entries;\n\t\n\tfor (end = entry + count; entry != end; acl_e++, entry++) {\n\t\tacl_e->e_tag  = le16_to_cpu(entry->e_tag);\n\t\tacl_e->e_perm = le16_to_cpu(entry->e_perm);\n\n\t\tswitch(acl_e->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\tcase ACL_MASK:\n\t\t\tcase ACL_OTHER:\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\t\tacl_e->e_uid =\n\t\t\t\t\tmake_kuid(user_ns,\n\t\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\t\tif (!uid_valid(acl_e->e_uid))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP:\n\t\t\t\tacl_e->e_gid =\n\t\t\t\t\tmake_kgid(user_ns,\n\t\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\t\tif (!gid_valid(acl_e->e_gid))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_getxattr",
          "args": [
            "inode",
            "name",
            "value",
            "size"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_getxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "717-771",
          "snippet": "ssize_t __ceph_getxattr(struct inode *inode, const char *name, void *value,\n\t\t      size_t size)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint err;\n\tstruct ceph_inode_xattr *xattr;\n\tstruct ceph_vxattr *vxattr = NULL;\n\n\tif (!ceph_is_valid_xattr(name))\n\t\treturn -ENODATA;\n\n\t/* let's see if a virtual xattr was requested */\n\tvxattr = ceph_match_vxattr(inode, name);\n\tif (vxattr && !(vxattr->exists_cb && !vxattr->exists_cb(ci))) {\n\t\terr = vxattr->getxattr_cb(ci, value, size);\n\t\treturn err;\n\t}\n\n\tspin_lock(&ci->i_ceph_lock);\n\tdout(\"getxattr %p ver=%lld index_ver=%lld\\n\", inode,\n\t     ci->i_xattrs.version, ci->i_xattrs.index_version);\n\n\tif (ci->i_xattrs.version == 0 ||\n\t    !__ceph_caps_issued_mask(ci, CEPH_CAP_XATTR_SHARED, 1)) {\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t/* get xattrs from mds (if we don't already have them) */\n\t\terr = ceph_do_getattr(inode, CEPH_STAT_CAP_XATTR, true);\n\t\tif (err)\n\t\t\treturn err;\n\t\tspin_lock(&ci->i_ceph_lock);\n\t}\n\n\terr = __build_xattrs(inode);\n\tif (err < 0)\n\t\tgoto out;\n\n\terr = -ENODATA;  /* == ENOATTR */\n\txattr = __get_xattr(ci, name);\n\tif (!xattr)\n\t\tgoto out;\n\n\terr = -ERANGE;\n\tif (size && size < xattr->val_len)\n\t\tgoto out;\n\n\terr = xattr->val_len;\n\tif (size == 0)\n\t\tgoto out;\n\n\tmemcpy(value, xattr->val, xattr->val_len);\n\nout:\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn err;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);\n\nssize_t __ceph_getxattr(struct inode *inode, const char *name, void *value,\n\t\t      size_t size)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint err;\n\tstruct ceph_inode_xattr *xattr;\n\tstruct ceph_vxattr *vxattr = NULL;\n\n\tif (!ceph_is_valid_xattr(name))\n\t\treturn -ENODATA;\n\n\t/* let's see if a virtual xattr was requested */\n\tvxattr = ceph_match_vxattr(inode, name);\n\tif (vxattr && !(vxattr->exists_cb && !vxattr->exists_cb(ci))) {\n\t\terr = vxattr->getxattr_cb(ci, value, size);\n\t\treturn err;\n\t}\n\n\tspin_lock(&ci->i_ceph_lock);\n\tdout(\"getxattr %p ver=%lld index_ver=%lld\\n\", inode,\n\t     ci->i_xattrs.version, ci->i_xattrs.index_version);\n\n\tif (ci->i_xattrs.version == 0 ||\n\t    !__ceph_caps_issued_mask(ci, CEPH_CAP_XATTR_SHARED, 1)) {\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t/* get xattrs from mds (if we don't already have them) */\n\t\terr = ceph_do_getattr(inode, CEPH_STAT_CAP_XATTR, true);\n\t\tif (err)\n\t\t\treturn err;\n\t\tspin_lock(&ci->i_ceph_lock);\n\t}\n\n\terr = __build_xattrs(inode);\n\tif (err < 0)\n\t\tgoto out;\n\n\terr = -ENODATA;  /* == ENOATTR */\n\txattr = __get_xattr(ci, name);\n\tif (!xattr)\n\t\tgoto out;\n\n\terr = -ERANGE;\n\tif (size && size < xattr->val_len)\n\t\tgoto out;\n\n\terr = xattr->val_len;\n\tif (size == 0)\n\t\tgoto out;\n\n\tmemcpy(value, xattr->val, xattr->val_len);\n\nout:\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "size",
            "GFP_NOFS"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/posix_acl.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct posix_acl *ceph_get_acl(struct inode *inode, int type)\n{\n\tint size;\n\tconst char *name;\n\tchar *value = NULL;\n\tstruct posix_acl *acl;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = POSIX_ACL_XATTR_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = POSIX_ACL_XATTR_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tsize = __ceph_getxattr(inode, name, \"\", 0);\n\tif (size > 0) {\n\t\tvalue = kzalloc(size, GFP_NOFS);\n\t\tif (!value)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tsize = __ceph_getxattr(inode, name, value, size);\n\t}\n\n\tif (size > 0)\n\t\tacl = posix_acl_from_xattr(&init_user_ns, value, size);\n\telse if (size == -ERANGE || size == -ENODATA || size == 0)\n\t\tacl = NULL;\n\telse\n\t\tacl = ERR_PTR(-EIO);\n\n\tkfree(value);\n\n\tif (!IS_ERR(acl))\n\t\tceph_set_cached_acl(inode, type, acl);\n\n\treturn acl;\n}"
  },
  {
    "function_name": "ceph_set_cached_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/acl.c",
    "lines": "32-41",
    "snippet": "static inline void ceph_set_cached_acl(struct inode *inode,\n\t\t\t\t\tint type, struct posix_acl *acl)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (__ceph_caps_issued_mask(ci, CEPH_CAP_XATTR_SHARED, 0))\n\t\tset_cached_acl(inode, type, acl);\n\tspin_unlock(&ci->i_ceph_lock);\n}",
    "includes": [
      "#include \"super.h\"",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/xattr.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_cached_acl",
          "args": [
            "inode",
            "type",
            "acl"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_set_cached_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/acl.c",
          "lines": "32-41",
          "snippet": "static inline void ceph_set_cached_acl(struct inode *inode,\n\t\t\t\t\tint type, struct posix_acl *acl)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (__ceph_caps_issued_mask(ci, CEPH_CAP_XATTR_SHARED, 0))\n\t\tset_cached_acl(inode, type, acl);\n\tspin_unlock(&ci->i_ceph_lock);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_caps_issued_mask",
          "args": [
            "ci",
            "CEPH_CAP_XATTR_SHARED",
            "0"
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_caps_issued_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "742-796",
          "snippet": "int __ceph_caps_issued_mask(struct ceph_inode_info *ci, int mask, int touch)\n{\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\tint have = ci->i_snap_caps;\n\n\tif ((have & mask) == mask) {\n\t\tdout(\"__ceph_caps_issued_mask %p snap issued %s\"\n\t\t     \" (mask %s)\\n\", &ci->vfs_inode,\n\t\t     ceph_cap_string(have),\n\t\t     ceph_cap_string(mask));\n\t\treturn 1;\n\t}\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (!__cap_is_valid(cap))\n\t\t\tcontinue;\n\t\tif ((cap->issued & mask) == mask) {\n\t\t\tdout(\"__ceph_caps_issued_mask %p cap %p issued %s\"\n\t\t\t     \" (mask %s)\\n\", &ci->vfs_inode, cap,\n\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t     ceph_cap_string(mask));\n\t\t\tif (touch)\n\t\t\t\t__touch_cap(cap);\n\t\t\treturn 1;\n\t\t}\n\n\t\t/* does a combination of caps satisfy mask? */\n\t\thave |= cap->issued;\n\t\tif ((have & mask) == mask) {\n\t\t\tdout(\"__ceph_caps_issued_mask %p combo issued %s\"\n\t\t\t     \" (mask %s)\\n\", &ci->vfs_inode,\n\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t     ceph_cap_string(mask));\n\t\t\tif (touch) {\n\t\t\t\tstruct rb_node *q;\n\n\t\t\t\t/* touch this + preceding caps */\n\t\t\t\t__touch_cap(cap);\n\t\t\t\tfor (q = rb_first(&ci->i_caps); q != p;\n\t\t\t\t     q = rb_next(q)) {\n\t\t\t\t\tcap = rb_entry(q, struct ceph_cap,\n\t\t\t\t\t\t       ci_node);\n\t\t\t\t\tif (!__cap_is_valid(cap))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t__touch_cap(cap);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_caps_issued_mask(struct ceph_inode_info *ci, int mask, int touch)\n{\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\tint have = ci->i_snap_caps;\n\n\tif ((have & mask) == mask) {\n\t\tdout(\"__ceph_caps_issued_mask %p snap issued %s\"\n\t\t     \" (mask %s)\\n\", &ci->vfs_inode,\n\t\t     ceph_cap_string(have),\n\t\t     ceph_cap_string(mask));\n\t\treturn 1;\n\t}\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (!__cap_is_valid(cap))\n\t\t\tcontinue;\n\t\tif ((cap->issued & mask) == mask) {\n\t\t\tdout(\"__ceph_caps_issued_mask %p cap %p issued %s\"\n\t\t\t     \" (mask %s)\\n\", &ci->vfs_inode, cap,\n\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t     ceph_cap_string(mask));\n\t\t\tif (touch)\n\t\t\t\t__touch_cap(cap);\n\t\t\treturn 1;\n\t\t}\n\n\t\t/* does a combination of caps satisfy mask? */\n\t\thave |= cap->issued;\n\t\tif ((have & mask) == mask) {\n\t\t\tdout(\"__ceph_caps_issued_mask %p combo issued %s\"\n\t\t\t     \" (mask %s)\\n\", &ci->vfs_inode,\n\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t     ceph_cap_string(mask));\n\t\t\tif (touch) {\n\t\t\t\tstruct rb_node *q;\n\n\t\t\t\t/* touch this + preceding caps */\n\t\t\t\t__touch_cap(cap);\n\t\t\t\tfor (q = rb_first(&ci->i_caps); q != p;\n\t\t\t\t     q = rb_next(q)) {\n\t\t\t\t\tcap = rb_entry(q, struct ceph_cap,\n\t\t\t\t\t\t       ci_node);\n\t\t\t\t\tif (!__cap_is_valid(cap))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t__touch_cap(cap);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/posix_acl.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline void ceph_set_cached_acl(struct inode *inode,\n\t\t\t\t\tint type, struct posix_acl *acl)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (__ceph_caps_issued_mask(ci, CEPH_CAP_XATTR_SHARED, 0))\n\t\tset_cached_acl(inode, type, acl);\n\tspin_unlock(&ci->i_ceph_lock);\n}"
  }
]