[
  {
    "function_name": "ext4_xattr_destroy_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
    "lines": "1724-1728",
    "snippet": "void ext4_xattr_destroy_cache(struct mb_cache *cache)\n{\n\tif (cache)\n\t\tmb_cache_destroy(cache);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mb_cache_destroy",
          "args": [
            "cache"
          ],
          "line": 1727
        },
        "resolved": true,
        "details": {
          "function_name": "mb_cache_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "451-491",
          "snippet": "void\nmb_cache_destroy(struct mb_cache *cache)\n{\n\tLIST_HEAD(free_list);\n\tstruct mb_cache_entry *ce, *tmp;\n\n\tspin_lock(&mb_cache_spinlock);\n\tlist_for_each_entry_safe(ce, tmp, &mb_cache_lru_list, e_lru_list) {\n\t\tif (ce->e_cache == cache)\n\t\t\tlist_move_tail(&ce->e_lru_list, &free_list);\n\t}\n\tlist_del(&cache->c_cache_list);\n\tspin_unlock(&mb_cache_spinlock);\n\n\tlist_for_each_entry_safe(ce, tmp, &free_list, e_lru_list) {\n\t\tlist_del_init(&ce->e_lru_list);\n\t\t/*\n\t\t * Prevent any find or get operation on the entry.\n\t\t */\n\t\thlist_bl_lock(ce->e_block_hash_p);\n\t\thlist_bl_lock(ce->e_index_hash_p);\n\t\tmb_assert(!(ce->e_used || ce->e_queued ||\n\t\t\tatomic_read(&ce->e_refcnt)));\n\t\t__mb_cache_entry_unhash_unlock(ce);\n\t\t__mb_cache_entry_forget(ce, GFP_KERNEL);\n\t}\n\n\tif (atomic_read(&cache->c_entry_count) > 0) {\n\t\tmb_error(\"cache %s: %d orphaned entries\",\n\t\t\t  cache->c_name,\n\t\t\t  atomic_read(&cache->c_entry_count));\n\t}\n\n\tif (list_empty(&mb_cache_list)) {\n\t\tkmem_cache_destroy(mb_cache_kmem_cache);\n\t\tmb_cache_kmem_cache = NULL;\n\t}\n\tkfree(cache->c_index_hash);\n\tkfree(cache->c_block_hash);\n\tkfree(cache);\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *mb_cache_kmem_cache;",
            "static LIST_HEAD(mb_cache_list);",
            "static LIST_HEAD(mb_cache_lru_list);",
            "static DEFINE_SPINLOCK(mb_cache_spinlock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *mb_cache_kmem_cache;\nstatic LIST_HEAD(mb_cache_list);\nstatic LIST_HEAD(mb_cache_lru_list);\nstatic DEFINE_SPINLOCK(mb_cache_spinlock);\n\nvoid\nmb_cache_destroy(struct mb_cache *cache)\n{\n\tLIST_HEAD(free_list);\n\tstruct mb_cache_entry *ce, *tmp;\n\n\tspin_lock(&mb_cache_spinlock);\n\tlist_for_each_entry_safe(ce, tmp, &mb_cache_lru_list, e_lru_list) {\n\t\tif (ce->e_cache == cache)\n\t\t\tlist_move_tail(&ce->e_lru_list, &free_list);\n\t}\n\tlist_del(&cache->c_cache_list);\n\tspin_unlock(&mb_cache_spinlock);\n\n\tlist_for_each_entry_safe(ce, tmp, &free_list, e_lru_list) {\n\t\tlist_del_init(&ce->e_lru_list);\n\t\t/*\n\t\t * Prevent any find or get operation on the entry.\n\t\t */\n\t\thlist_bl_lock(ce->e_block_hash_p);\n\t\thlist_bl_lock(ce->e_index_hash_p);\n\t\tmb_assert(!(ce->e_used || ce->e_queued ||\n\t\t\tatomic_read(&ce->e_refcnt)));\n\t\t__mb_cache_entry_unhash_unlock(ce);\n\t\t__mb_cache_entry_forget(ce, GFP_KERNEL);\n\t}\n\n\tif (atomic_read(&cache->c_entry_count) > 0) {\n\t\tmb_error(\"cache %s: %d orphaned entries\",\n\t\t\t  cache->c_name,\n\t\t\t  atomic_read(&cache->c_entry_count));\n\t}\n\n\tif (list_empty(&mb_cache_list)) {\n\t\tkmem_cache_destroy(mb_cache_kmem_cache);\n\t\tmb_cache_kmem_cache = NULL;\n\t}\n\tkfree(cache->c_index_hash);\n\tkfree(cache->c_block_hash);\n\tkfree(cache);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nvoid ext4_xattr_destroy_cache(struct mb_cache *cache)\n{\n\tif (cache)\n\t\tmb_cache_destroy(cache);\n}"
  },
  {
    "function_name": "ext4_xattr_create_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
    "lines": "1718-1722",
    "snippet": "struct mb_cache *\next4_xattr_create_cache(char *name)\n{\n\treturn mb_cache_create(name, HASH_BUCKET_BITS);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define\tHASH_BUCKET_BITS\t10"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mb_cache_create",
          "args": [
            "name",
            "HASH_BUCKET_BITS"
          ],
          "line": 1721
        },
        "resolved": true,
        "details": {
          "function_name": "mb_cache_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "324-383",
          "snippet": "struct mb_cache *\nmb_cache_create(const char *name, int bucket_bits)\n{\n\tint n, bucket_count = 1 << bucket_bits;\n\tstruct mb_cache *cache = NULL;\n\n\tif (!mb_cache_bg_lock) {\n\t\tmb_cache_bg_lock = kmalloc(sizeof(struct blockgroup_lock),\n\t\t\tGFP_KERNEL);\n\t\tif (!mb_cache_bg_lock)\n\t\t\treturn NULL;\n\t\tbgl_lock_init(mb_cache_bg_lock);\n\t}\n\n\tcache = kmalloc(sizeof(struct mb_cache), GFP_KERNEL);\n\tif (!cache)\n\t\treturn NULL;\n\tcache->c_name = name;\n\tatomic_set(&cache->c_entry_count, 0);\n\tcache->c_bucket_bits = bucket_bits;\n\tcache->c_block_hash = kmalloc(bucket_count *\n\t\tsizeof(struct hlist_bl_head), GFP_KERNEL);\n\tif (!cache->c_block_hash)\n\t\tgoto fail;\n\tfor (n=0; n<bucket_count; n++)\n\t\tINIT_HLIST_BL_HEAD(&cache->c_block_hash[n]);\n\tcache->c_index_hash = kmalloc(bucket_count *\n\t\tsizeof(struct hlist_bl_head), GFP_KERNEL);\n\tif (!cache->c_index_hash)\n\t\tgoto fail;\n\tfor (n=0; n<bucket_count; n++)\n\t\tINIT_HLIST_BL_HEAD(&cache->c_index_hash[n]);\n\tif (!mb_cache_kmem_cache) {\n\t\tmb_cache_kmem_cache = kmem_cache_create(name,\n\t\t\tsizeof(struct mb_cache_entry), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD, NULL);\n\t\tif (!mb_cache_kmem_cache)\n\t\t\tgoto fail2;\n\t}\n\tcache->c_entry_cache = mb_cache_kmem_cache;\n\n\t/*\n\t * Set an upper limit on the number of cache entries so that the hash\n\t * chains won't grow too long.\n\t */\n\tcache->c_max_entries = bucket_count << 4;\n\n\tspin_lock(&mb_cache_spinlock);\n\tlist_add(&cache->c_cache_list, &mb_cache_list);\n\tspin_unlock(&mb_cache_spinlock);\n\treturn cache;\n\nfail2:\n\tkfree(cache->c_index_hash);\n\nfail:\n\tkfree(cache->c_block_hash);\n\tkfree(cache);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;",
            "static struct kmem_cache *mb_cache_kmem_cache;",
            "static LIST_HEAD(mb_cache_list);",
            "static DEFINE_SPINLOCK(mb_cache_spinlock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\nstatic struct kmem_cache *mb_cache_kmem_cache;\nstatic LIST_HEAD(mb_cache_list);\nstatic DEFINE_SPINLOCK(mb_cache_spinlock);\n\nstruct mb_cache *\nmb_cache_create(const char *name, int bucket_bits)\n{\n\tint n, bucket_count = 1 << bucket_bits;\n\tstruct mb_cache *cache = NULL;\n\n\tif (!mb_cache_bg_lock) {\n\t\tmb_cache_bg_lock = kmalloc(sizeof(struct blockgroup_lock),\n\t\t\tGFP_KERNEL);\n\t\tif (!mb_cache_bg_lock)\n\t\t\treturn NULL;\n\t\tbgl_lock_init(mb_cache_bg_lock);\n\t}\n\n\tcache = kmalloc(sizeof(struct mb_cache), GFP_KERNEL);\n\tif (!cache)\n\t\treturn NULL;\n\tcache->c_name = name;\n\tatomic_set(&cache->c_entry_count, 0);\n\tcache->c_bucket_bits = bucket_bits;\n\tcache->c_block_hash = kmalloc(bucket_count *\n\t\tsizeof(struct hlist_bl_head), GFP_KERNEL);\n\tif (!cache->c_block_hash)\n\t\tgoto fail;\n\tfor (n=0; n<bucket_count; n++)\n\t\tINIT_HLIST_BL_HEAD(&cache->c_block_hash[n]);\n\tcache->c_index_hash = kmalloc(bucket_count *\n\t\tsizeof(struct hlist_bl_head), GFP_KERNEL);\n\tif (!cache->c_index_hash)\n\t\tgoto fail;\n\tfor (n=0; n<bucket_count; n++)\n\t\tINIT_HLIST_BL_HEAD(&cache->c_index_hash[n]);\n\tif (!mb_cache_kmem_cache) {\n\t\tmb_cache_kmem_cache = kmem_cache_create(name,\n\t\t\tsizeof(struct mb_cache_entry), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD, NULL);\n\t\tif (!mb_cache_kmem_cache)\n\t\t\tgoto fail2;\n\t}\n\tcache->c_entry_cache = mb_cache_kmem_cache;\n\n\t/*\n\t * Set an upper limit on the number of cache entries so that the hash\n\t * chains won't grow too long.\n\t */\n\tcache->c_max_entries = bucket_count << 4;\n\n\tspin_lock(&mb_cache_spinlock);\n\tlist_add(&cache->c_cache_list, &mb_cache_list);\n\tspin_unlock(&mb_cache_spinlock);\n\treturn cache;\n\nfail2:\n\tkfree(cache->c_index_hash);\n\nfail:\n\tkfree(cache->c_block_hash);\n\tkfree(cache);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\n#define\tHASH_BUCKET_BITS\t10\n\nstruct mb_cache *\next4_xattr_create_cache(char *name)\n{\n\treturn mb_cache_create(name, HASH_BUCKET_BITS);\n}"
  },
  {
    "function_name": "ext4_xattr_rehash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
    "lines": "1692-1712",
    "snippet": "static void ext4_xattr_rehash(struct ext4_xattr_header *header,\n\t\t\t      struct ext4_xattr_entry *entry)\n{\n\tstruct ext4_xattr_entry *here;\n\t__u32 hash = 0;\n\n\text4_xattr_hash_entry(header, entry);\n\there = ENTRY(header+1);\n\twhile (!IS_LAST_ENTRY(here)) {\n\t\tif (!here->e_hash) {\n\t\t\t/* Block is not shared if an entry's hash value == 0 */\n\t\t\thash = 0;\n\t\t\tbreak;\n\t\t}\n\t\thash = (hash << BLOCK_HASH_SHIFT) ^\n\t\t       (hash >> (8*sizeof(hash) - BLOCK_HASH_SHIFT)) ^\n\t\t       le32_to_cpu(here->e_hash);\n\t\there = EXT4_XATTR_NEXT(here);\n\t}\n\theader->h_hash = cpu_to_le32(hash);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define BLOCK_HASH_SHIFT 16"
    ],
    "globals_used": [
      "static void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "hash"
          ],
          "line": 1711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_XATTR_NEXT",
          "args": [
            "here"
          ],
          "line": 1709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "here->e_hash"
          ],
          "line": 1708
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_LAST_ENTRY",
          "args": [
            "here"
          ],
          "line": 1700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY",
          "args": [
            "header+1"
          ],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_xattr_hash_entry",
          "args": [
            "header",
            "entry"
          ],
          "line": 1698
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_hash_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "1656-1680",
          "snippet": "static inline void ext4_xattr_hash_entry(struct ext4_xattr_header *header,\n\t\t\t\t\t struct ext4_xattr_entry *entry)\n{\n\t__u32 hash = 0;\n\tchar *name = entry->e_name;\n\tint n;\n\n\tfor (n = 0; n < entry->e_name_len; n++) {\n\t\thash = (hash << NAME_HASH_SHIFT) ^\n\t\t       (hash >> (8*sizeof(hash) - NAME_HASH_SHIFT)) ^\n\t\t       *name++;\n\t}\n\n\tif (entry->e_value_block == 0 && entry->e_value_size != 0) {\n\t\t__le32 *value = (__le32 *)((char *)header +\n\t\t\tle16_to_cpu(entry->e_value_offs));\n\t\tfor (n = (le32_to_cpu(entry->e_value_size) +\n\t\t     EXT4_XATTR_ROUND) >> EXT4_XATTR_PAD_BITS; n; n--) {\n\t\t\thash = (hash << VALUE_HASH_SHIFT) ^\n\t\t\t       (hash >> (8*sizeof(hash) - VALUE_HASH_SHIFT)) ^\n\t\t\t       le32_to_cpu(*value++);\n\t\t}\n\t}\n\tentry->e_hash = cpu_to_le32(hash);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define VALUE_HASH_SHIFT 16",
            "#define NAME_HASH_SHIFT 5"
          ],
          "globals_used": [
            "static void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\n#define VALUE_HASH_SHIFT 16\n#define NAME_HASH_SHIFT 5\n\nstatic void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);\n\nstatic inline void ext4_xattr_hash_entry(struct ext4_xattr_header *header,\n\t\t\t\t\t struct ext4_xattr_entry *entry)\n{\n\t__u32 hash = 0;\n\tchar *name = entry->e_name;\n\tint n;\n\n\tfor (n = 0; n < entry->e_name_len; n++) {\n\t\thash = (hash << NAME_HASH_SHIFT) ^\n\t\t       (hash >> (8*sizeof(hash) - NAME_HASH_SHIFT)) ^\n\t\t       *name++;\n\t}\n\n\tif (entry->e_value_block == 0 && entry->e_value_size != 0) {\n\t\t__le32 *value = (__le32 *)((char *)header +\n\t\t\tle16_to_cpu(entry->e_value_offs));\n\t\tfor (n = (le32_to_cpu(entry->e_value_size) +\n\t\t     EXT4_XATTR_ROUND) >> EXT4_XATTR_PAD_BITS; n; n--) {\n\t\t\thash = (hash << VALUE_HASH_SHIFT) ^\n\t\t\t       (hash >> (8*sizeof(hash) - VALUE_HASH_SHIFT)) ^\n\t\t\t       le32_to_cpu(*value++);\n\t\t}\n\t}\n\tentry->e_hash = cpu_to_le32(hash);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\n#define BLOCK_HASH_SHIFT 16\n\nstatic void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);\n\nstatic void ext4_xattr_rehash(struct ext4_xattr_header *header,\n\t\t\t      struct ext4_xattr_entry *entry)\n{\n\tstruct ext4_xattr_entry *here;\n\t__u32 hash = 0;\n\n\text4_xattr_hash_entry(header, entry);\n\there = ENTRY(header+1);\n\twhile (!IS_LAST_ENTRY(here)) {\n\t\tif (!here->e_hash) {\n\t\t\t/* Block is not shared if an entry's hash value == 0 */\n\t\t\thash = 0;\n\t\t\tbreak;\n\t\t}\n\t\thash = (hash << BLOCK_HASH_SHIFT) ^\n\t\t       (hash >> (8*sizeof(hash) - BLOCK_HASH_SHIFT)) ^\n\t\t       le32_to_cpu(here->e_hash);\n\t\there = EXT4_XATTR_NEXT(here);\n\t}\n\theader->h_hash = cpu_to_le32(hash);\n}"
  },
  {
    "function_name": "ext4_xattr_hash_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
    "lines": "1656-1680",
    "snippet": "static inline void ext4_xattr_hash_entry(struct ext4_xattr_header *header,\n\t\t\t\t\t struct ext4_xattr_entry *entry)\n{\n\t__u32 hash = 0;\n\tchar *name = entry->e_name;\n\tint n;\n\n\tfor (n = 0; n < entry->e_name_len; n++) {\n\t\thash = (hash << NAME_HASH_SHIFT) ^\n\t\t       (hash >> (8*sizeof(hash) - NAME_HASH_SHIFT)) ^\n\t\t       *name++;\n\t}\n\n\tif (entry->e_value_block == 0 && entry->e_value_size != 0) {\n\t\t__le32 *value = (__le32 *)((char *)header +\n\t\t\tle16_to_cpu(entry->e_value_offs));\n\t\tfor (n = (le32_to_cpu(entry->e_value_size) +\n\t\t     EXT4_XATTR_ROUND) >> EXT4_XATTR_PAD_BITS; n; n--) {\n\t\t\thash = (hash << VALUE_HASH_SHIFT) ^\n\t\t\t       (hash >> (8*sizeof(hash) - VALUE_HASH_SHIFT)) ^\n\t\t\t       le32_to_cpu(*value++);\n\t\t}\n\t}\n\tentry->e_hash = cpu_to_le32(hash);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define VALUE_HASH_SHIFT 16",
      "#define NAME_HASH_SHIFT 5"
    ],
    "globals_used": [
      "static void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "hash"
          ],
          "line": 1679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "*value++"
          ],
          "line": 1676
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "entry->e_value_offs"
          ],
          "line": 1671
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\n#define VALUE_HASH_SHIFT 16\n#define NAME_HASH_SHIFT 5\n\nstatic void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);\n\nstatic inline void ext4_xattr_hash_entry(struct ext4_xattr_header *header,\n\t\t\t\t\t struct ext4_xattr_entry *entry)\n{\n\t__u32 hash = 0;\n\tchar *name = entry->e_name;\n\tint n;\n\n\tfor (n = 0; n < entry->e_name_len; n++) {\n\t\thash = (hash << NAME_HASH_SHIFT) ^\n\t\t       (hash >> (8*sizeof(hash) - NAME_HASH_SHIFT)) ^\n\t\t       *name++;\n\t}\n\n\tif (entry->e_value_block == 0 && entry->e_value_size != 0) {\n\t\t__le32 *value = (__le32 *)((char *)header +\n\t\t\tle16_to_cpu(entry->e_value_offs));\n\t\tfor (n = (le32_to_cpu(entry->e_value_size) +\n\t\t     EXT4_XATTR_ROUND) >> EXT4_XATTR_PAD_BITS; n; n--) {\n\t\t\thash = (hash << VALUE_HASH_SHIFT) ^\n\t\t\t       (hash >> (8*sizeof(hash) - VALUE_HASH_SHIFT)) ^\n\t\t\t       le32_to_cpu(*value++);\n\t\t}\n\t}\n\tentry->e_hash = cpu_to_le32(hash);\n}"
  },
  {
    "function_name": "ext4_xattr_cache_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
    "lines": "1606-1646",
    "snippet": "static struct buffer_head *\next4_xattr_cache_find(struct inode *inode, struct ext4_xattr_header *header,\n\t\t      struct mb_cache_entry **pce)\n{\n\t__u32 hash = le32_to_cpu(header->h_hash);\n\tstruct mb_cache_entry *ce;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\n\tif (!header->h_hash)\n\t\treturn NULL;  /* never share */\n\tea_idebug(inode, \"looking for cached blocks [%x]\", (int)hash);\nagain:\n\tce = mb_cache_entry_find_first(ext4_mb_cache, inode->i_sb->s_bdev,\n\t\t\t\t       hash);\n\twhile (ce) {\n\t\tstruct buffer_head *bh;\n\n\t\tif (IS_ERR(ce)) {\n\t\t\tif (PTR_ERR(ce) == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tbreak;\n\t\t}\n\t\tbh = sb_bread(inode->i_sb, ce->e_block);\n\t\tif (!bh) {\n\t\t\tEXT4_ERROR_INODE(inode, \"block %lu read error\",\n\t\t\t\t\t (unsigned long) ce->e_block);\n\t\t} else if (le32_to_cpu(BHDR(bh)->h_refcount) >=\n\t\t\t\tEXT4_XATTR_REFCOUNT_MAX) {\n\t\t\tea_idebug(inode, \"block %lu refcount %d>=%d\",\n\t\t\t\t  (unsigned long) ce->e_block,\n\t\t\t\t  le32_to_cpu(BHDR(bh)->h_refcount),\n\t\t\t\t\t  EXT4_XATTR_REFCOUNT_MAX);\n\t\t} else if (ext4_xattr_cmp(header, BHDR(bh)) == 0) {\n\t\t\t*pce = ce;\n\t\t\treturn bh;\n\t\t}\n\t\tbrelse(bh);\n\t\tce = mb_cache_entry_find_next(ce, inode->i_sb->s_bdev, hash);\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);",
      "static struct buffer_head *ext4_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext4_xattr_header *,\n\t\t\t\t\t\t struct mb_cache_entry **);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mb_cache_entry_find_next",
          "args": [
            "ce",
            "inode->i_sb->s_bdev",
            "hash"
          ],
          "line": 1643
        },
        "resolved": true,
        "details": {
          "function_name": "mb_cache_entry_find_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "823-841",
          "snippet": "struct mb_cache_entry *\nmb_cache_entry_find_next(struct mb_cache_entry *prev,\n\t\t\t struct block_device *bdev, unsigned int key)\n{\n\tstruct mb_cache *cache = prev->e_cache;\n\tunsigned int bucket = hash_long(key, cache->c_bucket_bits);\n\tstruct hlist_bl_node *l;\n\tstruct mb_cache_entry *ce;\n\tstruct hlist_bl_head *index_hash_p;\n\n\tindex_hash_p = &cache->c_index_hash[bucket];\n\tmb_assert(prev->e_index_hash_p == index_hash_p);\n\thlist_bl_lock(index_hash_p);\n\tmb_assert(!hlist_bl_empty(index_hash_p));\n\tl = prev->e_index.o_list.next;\n\tce = __mb_cache_entry_find(l, index_hash_p, bdev, key);\n\t__mb_cache_entry_release(prev);\n\treturn ce;\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstruct mb_cache_entry *\nmb_cache_entry_find_next(struct mb_cache_entry *prev,\n\t\t\t struct block_device *bdev, unsigned int key)\n{\n\tstruct mb_cache *cache = prev->e_cache;\n\tunsigned int bucket = hash_long(key, cache->c_bucket_bits);\n\tstruct hlist_bl_node *l;\n\tstruct mb_cache_entry *ce;\n\tstruct hlist_bl_head *index_hash_p;\n\n\tindex_hash_p = &cache->c_index_hash[bucket];\n\tmb_assert(prev->e_index_hash_p == index_hash_p);\n\thlist_bl_lock(index_hash_p);\n\tmb_assert(!hlist_bl_empty(index_hash_p));\n\tl = prev->e_index.o_list.next;\n\tce = __mb_cache_entry_find(l, index_hash_p, bdev, key);\n\t__mb_cache_entry_release(prev);\n\treturn ce;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1642
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_xattr_cmp",
          "args": [
            "header",
            "BHDR(bh)"
          ],
          "line": 1638
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "1566-1596",
          "snippet": "static int\next4_xattr_cmp(struct ext4_xattr_header *header1,\n\t       struct ext4_xattr_header *header2)\n{\n\tstruct ext4_xattr_entry *entry1, *entry2;\n\n\tentry1 = ENTRY(header1+1);\n\tentry2 = ENTRY(header2+1);\n\twhile (!IS_LAST_ENTRY(entry1)) {\n\t\tif (IS_LAST_ENTRY(entry2))\n\t\t\treturn 1;\n\t\tif (entry1->e_hash != entry2->e_hash ||\n\t\t    entry1->e_name_index != entry2->e_name_index ||\n\t\t    entry1->e_name_len != entry2->e_name_len ||\n\t\t    entry1->e_value_size != entry2->e_value_size ||\n\t\t    memcmp(entry1->e_name, entry2->e_name, entry1->e_name_len))\n\t\t\treturn 1;\n\t\tif (entry1->e_value_block != 0 || entry2->e_value_block != 0)\n\t\t\treturn -EIO;\n\t\tif (memcmp((char *)header1 + le16_to_cpu(entry1->e_value_offs),\n\t\t\t   (char *)header2 + le16_to_cpu(entry2->e_value_offs),\n\t\t\t   le32_to_cpu(entry1->e_value_size)))\n\t\t\treturn 1;\n\n\t\tentry1 = EXT4_XATTR_NEXT(entry1);\n\t\tentry2 = EXT4_XATTR_NEXT(entry2);\n\t}\n\tif (!IS_LAST_ENTRY(entry2))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);\n\nstatic int\next4_xattr_cmp(struct ext4_xattr_header *header1,\n\t       struct ext4_xattr_header *header2)\n{\n\tstruct ext4_xattr_entry *entry1, *entry2;\n\n\tentry1 = ENTRY(header1+1);\n\tentry2 = ENTRY(header2+1);\n\twhile (!IS_LAST_ENTRY(entry1)) {\n\t\tif (IS_LAST_ENTRY(entry2))\n\t\t\treturn 1;\n\t\tif (entry1->e_hash != entry2->e_hash ||\n\t\t    entry1->e_name_index != entry2->e_name_index ||\n\t\t    entry1->e_name_len != entry2->e_name_len ||\n\t\t    entry1->e_value_size != entry2->e_value_size ||\n\t\t    memcmp(entry1->e_name, entry2->e_name, entry1->e_name_len))\n\t\t\treturn 1;\n\t\tif (entry1->e_value_block != 0 || entry2->e_value_block != 0)\n\t\t\treturn -EIO;\n\t\tif (memcmp((char *)header1 + le16_to_cpu(entry1->e_value_offs),\n\t\t\t   (char *)header2 + le16_to_cpu(entry2->e_value_offs),\n\t\t\t   le32_to_cpu(entry1->e_value_size)))\n\t\t\treturn 1;\n\n\t\tentry1 = EXT4_XATTR_NEXT(entry1);\n\t\tentry2 = EXT4_XATTR_NEXT(entry2);\n\t}\n\tif (!IS_LAST_ENTRY(entry2))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BHDR",
          "args": [
            "bh"
          ],
          "line": 1638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_idebug",
          "args": [
            "inode",
            "\"block %lu refcount %d>=%d\"",
            "(unsigned long) ce->e_block",
            "le32_to_cpu(BHDR(bh)->h_refcount)",
            "EXT4_XATTR_REFCOUNT_MAX"
          ],
          "line": 1634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "BHDR(bh)->h_refcount"
          ],
          "line": 1636
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BHDR",
          "args": [
            "bh"
          ],
          "line": 1636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BHDR",
          "args": [
            "bh"
          ],
          "line": 1632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_ERROR_INODE",
          "args": [
            "inode",
            "\"block %lu read error\"",
            "(unsigned long) ce->e_block"
          ],
          "line": 1630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "inode->i_sb",
            "ce->e_block"
          ],
          "line": 1628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ce"
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ce"
          ],
          "line": 1623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_cache_entry_find_first",
          "args": [
            "ext4_mb_cache",
            "inode->i_sb->s_bdev",
            "hash"
          ],
          "line": 1618
        },
        "resolved": true,
        "details": {
          "function_name": "mb_cache_entry_find_first",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "785-802",
          "snippet": "struct mb_cache_entry *\nmb_cache_entry_find_first(struct mb_cache *cache, struct block_device *bdev,\n\t\t\t  unsigned int key)\n{\n\tunsigned int bucket = hash_long(key, cache->c_bucket_bits);\n\tstruct hlist_bl_node *l;\n\tstruct mb_cache_entry *ce = NULL;\n\tstruct hlist_bl_head *index_hash_p;\n\n\tindex_hash_p = &cache->c_index_hash[bucket];\n\thlist_bl_lock(index_hash_p);\n\tif (!hlist_bl_empty(index_hash_p)) {\n\t\tl = hlist_bl_first(index_hash_p);\n\t\tce = __mb_cache_entry_find(l, index_hash_p, bdev, key);\n\t} else\n\t\thlist_bl_unlock(index_hash_p);\n\treturn ce;\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstruct mb_cache_entry *\nmb_cache_entry_find_first(struct mb_cache *cache, struct block_device *bdev,\n\t\t\t  unsigned int key)\n{\n\tunsigned int bucket = hash_long(key, cache->c_bucket_bits);\n\tstruct hlist_bl_node *l;\n\tstruct mb_cache_entry *ce = NULL;\n\tstruct hlist_bl_head *index_hash_p;\n\n\tindex_hash_p = &cache->c_index_hash[bucket];\n\thlist_bl_lock(index_hash_p);\n\tif (!hlist_bl_empty(index_hash_p)) {\n\t\tl = hlist_bl_first(index_hash_p);\n\t\tce = __mb_cache_entry_find(l, index_hash_p, bdev, key);\n\t} else\n\t\thlist_bl_unlock(index_hash_p);\n\treturn ce;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_idebug",
          "args": [
            "inode",
            "\"looking for cached blocks [%x]\"",
            "(int)hash"
          ],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_GET_MB_CACHE",
          "args": [
            "inode"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);\nstatic struct buffer_head *ext4_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext4_xattr_header *,\n\t\t\t\t\t\t struct mb_cache_entry **);\n\nstatic struct buffer_head *\next4_xattr_cache_find(struct inode *inode, struct ext4_xattr_header *header,\n\t\t      struct mb_cache_entry **pce)\n{\n\t__u32 hash = le32_to_cpu(header->h_hash);\n\tstruct mb_cache_entry *ce;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\n\tif (!header->h_hash)\n\t\treturn NULL;  /* never share */\n\tea_idebug(inode, \"looking for cached blocks [%x]\", (int)hash);\nagain:\n\tce = mb_cache_entry_find_first(ext4_mb_cache, inode->i_sb->s_bdev,\n\t\t\t\t       hash);\n\twhile (ce) {\n\t\tstruct buffer_head *bh;\n\n\t\tif (IS_ERR(ce)) {\n\t\t\tif (PTR_ERR(ce) == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tbreak;\n\t\t}\n\t\tbh = sb_bread(inode->i_sb, ce->e_block);\n\t\tif (!bh) {\n\t\t\tEXT4_ERROR_INODE(inode, \"block %lu read error\",\n\t\t\t\t\t (unsigned long) ce->e_block);\n\t\t} else if (le32_to_cpu(BHDR(bh)->h_refcount) >=\n\t\t\t\tEXT4_XATTR_REFCOUNT_MAX) {\n\t\t\tea_idebug(inode, \"block %lu refcount %d>=%d\",\n\t\t\t\t  (unsigned long) ce->e_block,\n\t\t\t\t  le32_to_cpu(BHDR(bh)->h_refcount),\n\t\t\t\t\t  EXT4_XATTR_REFCOUNT_MAX);\n\t\t} else if (ext4_xattr_cmp(header, BHDR(bh)) == 0) {\n\t\t\t*pce = ce;\n\t\t\treturn bh;\n\t\t}\n\t\tbrelse(bh);\n\t\tce = mb_cache_entry_find_next(ce, inode->i_sb->s_bdev, hash);\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "ext4_xattr_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
    "lines": "1566-1596",
    "snippet": "static int\next4_xattr_cmp(struct ext4_xattr_header *header1,\n\t       struct ext4_xattr_header *header2)\n{\n\tstruct ext4_xattr_entry *entry1, *entry2;\n\n\tentry1 = ENTRY(header1+1);\n\tentry2 = ENTRY(header2+1);\n\twhile (!IS_LAST_ENTRY(entry1)) {\n\t\tif (IS_LAST_ENTRY(entry2))\n\t\t\treturn 1;\n\t\tif (entry1->e_hash != entry2->e_hash ||\n\t\t    entry1->e_name_index != entry2->e_name_index ||\n\t\t    entry1->e_name_len != entry2->e_name_len ||\n\t\t    entry1->e_value_size != entry2->e_value_size ||\n\t\t    memcmp(entry1->e_name, entry2->e_name, entry1->e_name_len))\n\t\t\treturn 1;\n\t\tif (entry1->e_value_block != 0 || entry2->e_value_block != 0)\n\t\t\treturn -EIO;\n\t\tif (memcmp((char *)header1 + le16_to_cpu(entry1->e_value_offs),\n\t\t\t   (char *)header2 + le16_to_cpu(entry2->e_value_offs),\n\t\t\t   le32_to_cpu(entry1->e_value_size)))\n\t\t\treturn 1;\n\n\t\tentry1 = EXT4_XATTR_NEXT(entry1);\n\t\tentry2 = EXT4_XATTR_NEXT(entry2);\n\t}\n\tif (!IS_LAST_ENTRY(entry2))\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_LAST_ENTRY",
          "args": [
            "entry2"
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_XATTR_NEXT",
          "args": [
            "entry2"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_XATTR_NEXT",
          "args": [
            "entry1"
          ],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "(char *)header1 + le16_to_cpu(entry1->e_value_offs)",
            "(char *)header2 + le16_to_cpu(entry2->e_value_offs)",
            "le32_to_cpu(entry1->e_value_size)"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "entry1->e_value_size"
          ],
          "line": 1587
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "entry2->e_value_offs"
          ],
          "line": 1586
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "entry1->e_name",
            "entry2->e_name",
            "entry1->e_name_len"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LAST_ENTRY",
          "args": [
            "entry2"
          ],
          "line": 1575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LAST_ENTRY",
          "args": [
            "entry1"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY",
          "args": [
            "header2+1"
          ],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY",
          "args": [
            "header1+1"
          ],
          "line": 1572
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);\n\nstatic int\next4_xattr_cmp(struct ext4_xattr_header *header1,\n\t       struct ext4_xattr_header *header2)\n{\n\tstruct ext4_xattr_entry *entry1, *entry2;\n\n\tentry1 = ENTRY(header1+1);\n\tentry2 = ENTRY(header2+1);\n\twhile (!IS_LAST_ENTRY(entry1)) {\n\t\tif (IS_LAST_ENTRY(entry2))\n\t\t\treturn 1;\n\t\tif (entry1->e_hash != entry2->e_hash ||\n\t\t    entry1->e_name_index != entry2->e_name_index ||\n\t\t    entry1->e_name_len != entry2->e_name_len ||\n\t\t    entry1->e_value_size != entry2->e_value_size ||\n\t\t    memcmp(entry1->e_name, entry2->e_name, entry1->e_name_len))\n\t\t\treturn 1;\n\t\tif (entry1->e_value_block != 0 || entry2->e_value_block != 0)\n\t\t\treturn -EIO;\n\t\tif (memcmp((char *)header1 + le16_to_cpu(entry1->e_value_offs),\n\t\t\t   (char *)header2 + le16_to_cpu(entry2->e_value_offs),\n\t\t\t   le32_to_cpu(entry1->e_value_size)))\n\t\t\treturn 1;\n\n\t\tentry1 = EXT4_XATTR_NEXT(entry1);\n\t\tentry2 = EXT4_XATTR_NEXT(entry2);\n\t}\n\tif (!IS_LAST_ENTRY(entry2))\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_xattr_cache_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
    "lines": "1533-1556",
    "snippet": "static void\next4_xattr_cache_insert(struct mb_cache *ext4_mb_cache, struct buffer_head *bh)\n{\n\t__u32 hash = le32_to_cpu(BHDR(bh)->h_hash);\n\tstruct mb_cache_entry *ce;\n\tint error;\n\n\tce = mb_cache_entry_alloc(ext4_mb_cache, GFP_NOFS);\n\tif (!ce) {\n\t\tea_bdebug(bh, \"out of memory\");\n\t\treturn;\n\t}\n\terror = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, hash);\n\tif (error) {\n\t\tmb_cache_entry_free(ce);\n\t\tif (error == -EBUSY) {\n\t\t\tea_bdebug(bh, \"already in cache\");\n\t\t\terror = 0;\n\t\t}\n\t} else {\n\t\tea_bdebug(bh, \"inserting [%x]\", (int)hash);\n\t\tmb_cache_entry_release(ce);\n\t}\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);",
      "static struct buffer_head *ext4_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext4_xattr_header *,\n\t\t\t\t\t\t struct mb_cache_entry **);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mb_cache_entry_release",
          "args": [
            "ce"
          ],
          "line": 1554
        },
        "resolved": true,
        "details": {
          "function_name": "mb_cache_entry_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "626-630",
          "snippet": "void\nmb_cache_entry_release(struct mb_cache_entry *ce)\n{\n\t__mb_cache_entry_release(ce);\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid\nmb_cache_entry_release(struct mb_cache_entry *ce)\n{\n\t__mb_cache_entry_release(ce);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_bdebug",
          "args": [
            "bh",
            "\"inserting [%x]\"",
            "(int)hash"
          ],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_bdebug",
          "args": [
            "bh",
            "\"already in cache\""
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_cache_entry_free",
          "args": [
            "ce"
          ],
          "line": 1547
        },
        "resolved": true,
        "details": {
          "function_name": "mb_cache_entry_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "637-649",
          "snippet": "void\nmb_cache_entry_free(struct mb_cache_entry *ce)\n{\n\tmb_assert(ce);\n\tmb_assert(list_empty(&ce->e_lru_list));\n\thlist_bl_lock(ce->e_index_hash_p);\n\t__mb_cache_entry_unhash_index(ce);\n\thlist_bl_unlock(ce->e_index_hash_p);\n\thlist_bl_lock(ce->e_block_hash_p);\n\t__mb_cache_entry_unhash_block(ce);\n\thlist_bl_unlock(ce->e_block_hash_p);\n\t__mb_cache_entry_release(ce);\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid\nmb_cache_entry_free(struct mb_cache_entry *ce)\n{\n\tmb_assert(ce);\n\tmb_assert(list_empty(&ce->e_lru_list));\n\thlist_bl_lock(ce->e_index_hash_p);\n\t__mb_cache_entry_unhash_index(ce);\n\thlist_bl_unlock(ce->e_index_hash_p);\n\thlist_bl_lock(ce->e_block_hash_p);\n\t__mb_cache_entry_unhash_block(ce);\n\thlist_bl_unlock(ce->e_block_hash_p);\n\t__mb_cache_entry_release(ce);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_cache_entry_insert",
          "args": [
            "ce",
            "bh->b_bdev",
            "bh->b_blocknr",
            "hash"
          ],
          "line": 1545
        },
        "resolved": true,
        "details": {
          "function_name": "mb_cache_entry_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "578-616",
          "snippet": "int\nmb_cache_entry_insert(struct mb_cache_entry *ce, struct block_device *bdev,\n\t\t      sector_t block, unsigned int key)\n{\n\tstruct mb_cache *cache = ce->e_cache;\n\tunsigned int bucket;\n\tstruct hlist_bl_node *l;\n\tstruct hlist_bl_head *block_hash_p;\n\tstruct hlist_bl_head *index_hash_p;\n\tstruct mb_cache_entry *lce;\n\n\tmb_assert(ce);\n\tbucket = hash_long((unsigned long)bdev + (block & 0xffffffff), \n\t\t\t   cache->c_bucket_bits);\n\tblock_hash_p = &cache->c_block_hash[bucket];\n\thlist_bl_lock(block_hash_p);\n\thlist_bl_for_each_entry(lce, l, block_hash_p, e_block_list) {\n\t\tif (lce->e_bdev == bdev && lce->e_block == block) {\n\t\t\thlist_bl_unlock(block_hash_p);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\tmb_assert(!__mb_cache_entry_is_block_hashed(ce));\n\t__mb_cache_entry_unhash_block(ce);\n\t__mb_cache_entry_unhash_index(ce);\n\tce->e_bdev = bdev;\n\tce->e_block = block;\n\tce->e_block_hash_p = block_hash_p;\n\tce->e_index.o_key = key;\n\thlist_bl_add_head(&ce->e_block_list, block_hash_p);\n\thlist_bl_unlock(block_hash_p);\n\tbucket = hash_long(key, cache->c_bucket_bits);\n\tindex_hash_p = &cache->c_index_hash[bucket];\n\thlist_bl_lock(index_hash_p);\n\tce->e_index_hash_p = index_hash_p;\n\thlist_bl_add_head(&ce->e_index.o_list, index_hash_p);\n\thlist_bl_unlock(index_hash_p);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint\nmb_cache_entry_insert(struct mb_cache_entry *ce, struct block_device *bdev,\n\t\t      sector_t block, unsigned int key)\n{\n\tstruct mb_cache *cache = ce->e_cache;\n\tunsigned int bucket;\n\tstruct hlist_bl_node *l;\n\tstruct hlist_bl_head *block_hash_p;\n\tstruct hlist_bl_head *index_hash_p;\n\tstruct mb_cache_entry *lce;\n\n\tmb_assert(ce);\n\tbucket = hash_long((unsigned long)bdev + (block & 0xffffffff), \n\t\t\t   cache->c_bucket_bits);\n\tblock_hash_p = &cache->c_block_hash[bucket];\n\thlist_bl_lock(block_hash_p);\n\thlist_bl_for_each_entry(lce, l, block_hash_p, e_block_list) {\n\t\tif (lce->e_bdev == bdev && lce->e_block == block) {\n\t\t\thlist_bl_unlock(block_hash_p);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\tmb_assert(!__mb_cache_entry_is_block_hashed(ce));\n\t__mb_cache_entry_unhash_block(ce);\n\t__mb_cache_entry_unhash_index(ce);\n\tce->e_bdev = bdev;\n\tce->e_block = block;\n\tce->e_block_hash_p = block_hash_p;\n\tce->e_index.o_key = key;\n\thlist_bl_add_head(&ce->e_block_list, block_hash_p);\n\thlist_bl_unlock(block_hash_p);\n\tbucket = hash_long(key, cache->c_bucket_bits);\n\tindex_hash_p = &cache->c_index_hash[bucket];\n\thlist_bl_lock(index_hash_p);\n\tce->e_index_hash_p = index_hash_p;\n\thlist_bl_add_head(&ce->e_index.o_list, index_hash_p);\n\thlist_bl_unlock(index_hash_p);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_bdebug",
          "args": [
            "bh",
            "\"out of memory\""
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_cache_entry_alloc",
          "args": [
            "ext4_mb_cache",
            "GFP_NOFS"
          ],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "mb_cache_entry_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "501-561",
          "snippet": "struct mb_cache_entry *\nmb_cache_entry_alloc(struct mb_cache *cache, gfp_t gfp_flags)\n{\n\tstruct mb_cache_entry *ce;\n\n\tif (atomic_read(&cache->c_entry_count) >= cache->c_max_entries) {\n\t\tstruct list_head *l;\n\n\t\tl = &mb_cache_lru_list;\n\t\tspin_lock(&mb_cache_spinlock);\n\t\twhile (!list_is_last(l, &mb_cache_lru_list)) {\n\t\t\tl = l->next;\n\t\t\tce = list_entry(l, struct mb_cache_entry, e_lru_list);\n\t\t\tif (ce->e_cache == cache) {\n\t\t\t\tlist_del_init(&ce->e_lru_list);\n\t\t\t\tif (ce->e_used || ce->e_queued ||\n\t\t\t\t\tatomic_read(&ce->e_refcnt))\n\t\t\t\t\tcontinue;\n\t\t\t\tspin_unlock(&mb_cache_spinlock);\n\t\t\t\t/*\n\t\t\t\t * Prevent any find or get operation on the\n\t\t\t\t * entry.\n\t\t\t\t */\n\t\t\t\thlist_bl_lock(ce->e_block_hash_p);\n\t\t\t\thlist_bl_lock(ce->e_index_hash_p);\n\t\t\t\t/* Ignore if it is touched by a find/get */\n\t\t\t\tif (ce->e_used || ce->e_queued ||\n\t\t\t\t\tatomic_read(&ce->e_refcnt) ||\n\t\t\t\t\t!list_empty(&ce->e_lru_list)) {\n\t\t\t\t\thlist_bl_unlock(ce->e_index_hash_p);\n\t\t\t\t\thlist_bl_unlock(ce->e_block_hash_p);\n\t\t\t\t\tl = &mb_cache_lru_list;\n\t\t\t\t\tspin_lock(&mb_cache_spinlock);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tmb_assert(list_empty(&ce->e_lru_list));\n\t\t\t\tmb_assert(!(ce->e_used || ce->e_queued ||\n\t\t\t\t\tatomic_read(&ce->e_refcnt)));\n\t\t\t\t__mb_cache_entry_unhash_unlock(ce);\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&mb_cache_spinlock);\n\t}\n\n\tce = kmem_cache_alloc(cache->c_entry_cache, gfp_flags);\n\tif (!ce)\n\t\treturn NULL;\n\tatomic_inc(&cache->c_entry_count);\n\tINIT_LIST_HEAD(&ce->e_lru_list);\n\tINIT_HLIST_BL_NODE(&ce->e_block_list);\n\tINIT_HLIST_BL_NODE(&ce->e_index.o_list);\n\tce->e_cache = cache;\n\tce->e_queued = 0;\n\tatomic_set(&ce->e_refcnt, 0);\nfound:\n\tce->e_block_hash_p = &cache->c_block_hash[0];\n\tce->e_index_hash_p = &cache->c_index_hash[0];\n\tce->e_used = 1 + MB_CACHE_WRITER;\n\treturn ce;\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MB_CACHE_WRITER ((unsigned short)~0U >> 1)"
          ],
          "globals_used": [
            "static LIST_HEAD(mb_cache_lru_list);",
            "static DEFINE_SPINLOCK(mb_cache_spinlock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\n#define MB_CACHE_WRITER ((unsigned short)~0U >> 1)\n\nstatic LIST_HEAD(mb_cache_lru_list);\nstatic DEFINE_SPINLOCK(mb_cache_spinlock);\n\nstruct mb_cache_entry *\nmb_cache_entry_alloc(struct mb_cache *cache, gfp_t gfp_flags)\n{\n\tstruct mb_cache_entry *ce;\n\n\tif (atomic_read(&cache->c_entry_count) >= cache->c_max_entries) {\n\t\tstruct list_head *l;\n\n\t\tl = &mb_cache_lru_list;\n\t\tspin_lock(&mb_cache_spinlock);\n\t\twhile (!list_is_last(l, &mb_cache_lru_list)) {\n\t\t\tl = l->next;\n\t\t\tce = list_entry(l, struct mb_cache_entry, e_lru_list);\n\t\t\tif (ce->e_cache == cache) {\n\t\t\t\tlist_del_init(&ce->e_lru_list);\n\t\t\t\tif (ce->e_used || ce->e_queued ||\n\t\t\t\t\tatomic_read(&ce->e_refcnt))\n\t\t\t\t\tcontinue;\n\t\t\t\tspin_unlock(&mb_cache_spinlock);\n\t\t\t\t/*\n\t\t\t\t * Prevent any find or get operation on the\n\t\t\t\t * entry.\n\t\t\t\t */\n\t\t\t\thlist_bl_lock(ce->e_block_hash_p);\n\t\t\t\thlist_bl_lock(ce->e_index_hash_p);\n\t\t\t\t/* Ignore if it is touched by a find/get */\n\t\t\t\tif (ce->e_used || ce->e_queued ||\n\t\t\t\t\tatomic_read(&ce->e_refcnt) ||\n\t\t\t\t\t!list_empty(&ce->e_lru_list)) {\n\t\t\t\t\thlist_bl_unlock(ce->e_index_hash_p);\n\t\t\t\t\thlist_bl_unlock(ce->e_block_hash_p);\n\t\t\t\t\tl = &mb_cache_lru_list;\n\t\t\t\t\tspin_lock(&mb_cache_spinlock);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tmb_assert(list_empty(&ce->e_lru_list));\n\t\t\t\tmb_assert(!(ce->e_used || ce->e_queued ||\n\t\t\t\t\tatomic_read(&ce->e_refcnt)));\n\t\t\t\t__mb_cache_entry_unhash_unlock(ce);\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&mb_cache_spinlock);\n\t}\n\n\tce = kmem_cache_alloc(cache->c_entry_cache, gfp_flags);\n\tif (!ce)\n\t\treturn NULL;\n\tatomic_inc(&cache->c_entry_count);\n\tINIT_LIST_HEAD(&ce->e_lru_list);\n\tINIT_HLIST_BL_NODE(&ce->e_block_list);\n\tINIT_HLIST_BL_NODE(&ce->e_index.o_list);\n\tce->e_cache = cache;\n\tce->e_queued = 0;\n\tatomic_set(&ce->e_refcnt, 0);\nfound:\n\tce->e_block_hash_p = &cache->c_block_hash[0];\n\tce->e_index_hash_p = &cache->c_index_hash[0];\n\tce->e_used = 1 + MB_CACHE_WRITER;\n\treturn ce;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "BHDR(bh)->h_hash"
          ],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BHDR",
          "args": [
            "bh"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);\nstatic struct buffer_head *ext4_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext4_xattr_header *,\n\t\t\t\t\t\t struct mb_cache_entry **);\n\nstatic void\next4_xattr_cache_insert(struct mb_cache *ext4_mb_cache, struct buffer_head *bh)\n{\n\t__u32 hash = le32_to_cpu(BHDR(bh)->h_hash);\n\tstruct mb_cache_entry *ce;\n\tint error;\n\n\tce = mb_cache_entry_alloc(ext4_mb_cache, GFP_NOFS);\n\tif (!ce) {\n\t\tea_bdebug(bh, \"out of memory\");\n\t\treturn;\n\t}\n\terror = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, hash);\n\tif (error) {\n\t\tmb_cache_entry_free(ce);\n\t\tif (error == -EBUSY) {\n\t\t\tea_bdebug(bh, \"already in cache\");\n\t\t\terror = 0;\n\t\t}\n\t} else {\n\t\tea_bdebug(bh, \"inserting [%x]\", (int)hash);\n\t\tmb_cache_entry_release(ce);\n\t}\n}"
  },
  {
    "function_name": "ext4_xattr_put_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
    "lines": "1519-1523",
    "snippet": "void\next4_xattr_put_super(struct super_block *sb)\n{\n\tmb_cache_shrink(sb->s_bdev);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mb_cache_shrink",
          "args": [
            "sb->s_bdev"
          ],
          "line": 1522
        },
        "resolved": true,
        "details": {
          "function_name": "mb_cache_shrink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "395-441",
          "snippet": "void\nmb_cache_shrink(struct block_device *bdev)\n{\n\tLIST_HEAD(free_list);\n\tstruct list_head *l;\n\tstruct mb_cache_entry *ce, *tmp;\n\n\tl = &mb_cache_lru_list;\n\tspin_lock(&mb_cache_spinlock);\n\twhile (!list_is_last(l, &mb_cache_lru_list)) {\n\t\tl = l->next;\n\t\tce = list_entry(l, struct mb_cache_entry, e_lru_list);\n\t\tif (ce->e_bdev == bdev) {\n\t\t\tlist_del_init(&ce->e_lru_list);\n\t\t\tif (ce->e_used || ce->e_queued ||\n\t\t\t\tatomic_read(&ce->e_refcnt))\n\t\t\t\tcontinue;\n\t\t\tspin_unlock(&mb_cache_spinlock);\n\t\t\t/*\n\t\t\t * Prevent any find or get operation on the entry.\n\t\t\t */\n\t\t\thlist_bl_lock(ce->e_block_hash_p);\n\t\t\thlist_bl_lock(ce->e_index_hash_p);\n\t\t\t/* Ignore if it is touched by a find/get */\n\t\t\tif (ce->e_used || ce->e_queued ||\n\t\t\t\tatomic_read(&ce->e_refcnt) ||\n\t\t\t\t!list_empty(&ce->e_lru_list)) {\n\t\t\t\thlist_bl_unlock(ce->e_index_hash_p);\n\t\t\t\thlist_bl_unlock(ce->e_block_hash_p);\n\t\t\t\tl = &mb_cache_lru_list;\n\t\t\t\tspin_lock(&mb_cache_spinlock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t__mb_cache_entry_unhash_unlock(ce);\n\t\t\tmb_assert(!(ce->e_used || ce->e_queued ||\n\t\t\t\tatomic_read(&ce->e_refcnt)));\n\t\t\tlist_add_tail(&ce->e_lru_list, &free_list);\n\t\t\tl = &mb_cache_lru_list;\n\t\t\tspin_lock(&mb_cache_spinlock);\n\t\t}\n\t}\n\tspin_unlock(&mb_cache_spinlock);\n\n\tlist_for_each_entry_safe(ce, tmp, &free_list, e_lru_list) {\n\t\t__mb_cache_entry_forget(ce, GFP_KERNEL);\n\t}\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(mb_cache_lru_list);",
            "static DEFINE_SPINLOCK(mb_cache_spinlock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(mb_cache_lru_list);\nstatic DEFINE_SPINLOCK(mb_cache_spinlock);\n\nvoid\nmb_cache_shrink(struct block_device *bdev)\n{\n\tLIST_HEAD(free_list);\n\tstruct list_head *l;\n\tstruct mb_cache_entry *ce, *tmp;\n\n\tl = &mb_cache_lru_list;\n\tspin_lock(&mb_cache_spinlock);\n\twhile (!list_is_last(l, &mb_cache_lru_list)) {\n\t\tl = l->next;\n\t\tce = list_entry(l, struct mb_cache_entry, e_lru_list);\n\t\tif (ce->e_bdev == bdev) {\n\t\t\tlist_del_init(&ce->e_lru_list);\n\t\t\tif (ce->e_used || ce->e_queued ||\n\t\t\t\tatomic_read(&ce->e_refcnt))\n\t\t\t\tcontinue;\n\t\t\tspin_unlock(&mb_cache_spinlock);\n\t\t\t/*\n\t\t\t * Prevent any find or get operation on the entry.\n\t\t\t */\n\t\t\thlist_bl_lock(ce->e_block_hash_p);\n\t\t\thlist_bl_lock(ce->e_index_hash_p);\n\t\t\t/* Ignore if it is touched by a find/get */\n\t\t\tif (ce->e_used || ce->e_queued ||\n\t\t\t\tatomic_read(&ce->e_refcnt) ||\n\t\t\t\t!list_empty(&ce->e_lru_list)) {\n\t\t\t\thlist_bl_unlock(ce->e_index_hash_p);\n\t\t\t\thlist_bl_unlock(ce->e_block_hash_p);\n\t\t\t\tl = &mb_cache_lru_list;\n\t\t\t\tspin_lock(&mb_cache_spinlock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t__mb_cache_entry_unhash_unlock(ce);\n\t\t\tmb_assert(!(ce->e_used || ce->e_queued ||\n\t\t\t\tatomic_read(&ce->e_refcnt)));\n\t\t\tlist_add_tail(&ce->e_lru_list, &free_list);\n\t\t\tl = &mb_cache_lru_list;\n\t\t\tspin_lock(&mb_cache_spinlock);\n\t\t}\n\t}\n\tspin_unlock(&mb_cache_spinlock);\n\n\tlist_for_each_entry_safe(ce, tmp, &free_list, e_lru_list) {\n\t\t__mb_cache_entry_forget(ce, GFP_KERNEL);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nvoid\next4_xattr_put_super(struct super_block *sb)\n{\n\tmb_cache_shrink(sb->s_bdev);\n}"
  },
  {
    "function_name": "ext4_xattr_delete_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
    "lines": "1488-1512",
    "snippet": "void\next4_xattr_delete_inode(handle_t *handle, struct inode *inode)\n{\n\tstruct buffer_head *bh = NULL;\n\n\tif (!EXT4_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tbh = sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl);\n\tif (!bh) {\n\t\tEXT4_ERROR_INODE(inode, \"block %llu read error\",\n\t\t\t\t EXT4_I(inode)->i_file_acl);\n\t\tgoto cleanup;\n\t}\n\tif (BHDR(bh)->h_magic != cpu_to_le32(EXT4_XATTR_MAGIC) ||\n\t    BHDR(bh)->h_blocks != cpu_to_le32(1)) {\n\t\tEXT4_ERROR_INODE(inode, \"bad block %llu\",\n\t\t\t\t EXT4_I(inode)->i_file_acl);\n\t\tgoto cleanup;\n\t}\n\text4_xattr_release_block(handle, inode, bh);\n\tEXT4_I(inode)->i_file_acl = 0;\n\ncleanup:\n\tbrelse(bh);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1511
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 1508
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_xattr_release_block",
          "args": [
            "handle",
            "inode",
            "bh"
          ],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_release_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "543-597",
          "snippet": "static void\next4_xattr_release_block(handle_t *handle, struct inode *inode,\n\t\t\t struct buffer_head *bh)\n{\n\tstruct mb_cache_entry *ce = NULL;\n\tint error = 0;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\n\tce = mb_cache_entry_get(ext4_mb_cache, bh->b_bdev, bh->b_blocknr);\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terror = ext4_journal_get_write_access(handle, bh);\n\tif (error)\n\t\tgoto out;\n\n\tlock_buffer(bh);\n\tif (BHDR(bh)->h_refcount == cpu_to_le32(1)) {\n\t\tea_bdebug(bh, \"refcount now=0; freeing\");\n\t\tif (ce)\n\t\t\tmb_cache_entry_free(ce);\n\t\tget_bh(bh);\n\t\tunlock_buffer(bh);\n\t\text4_free_blocks(handle, inode, bh, 0, 1,\n\t\t\t\t EXT4_FREE_BLOCKS_METADATA |\n\t\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\t} else {\n\t\tle32_add_cpu(&BHDR(bh)->h_refcount, -1);\n\t\tif (ce)\n\t\t\tmb_cache_entry_release(ce);\n\t\t/*\n\t\t * Beware of this ugliness: Releasing of xattr block references\n\t\t * from different inodes can race and so we have to protect\n\t\t * from a race where someone else frees the block (and releases\n\t\t * its journal_head) before we are done dirtying the buffer. In\n\t\t * nojournal mode this race is harmless and we actually cannot\n\t\t * call ext4_handle_dirty_xattr_block() with locked buffer as\n\t\t * that function can call sync_dirty_buffer() so for that case\n\t\t * we handle the dirtying after unlocking the buffer.\n\t\t */\n\t\tif (ext4_handle_valid(handle))\n\t\t\terror = ext4_handle_dirty_xattr_block(handle, inode,\n\t\t\t\t\t\t\t      bh);\n\t\tunlock_buffer(bh);\n\t\tif (!ext4_handle_valid(handle))\n\t\t\terror = ext4_handle_dirty_xattr_block(handle, inode,\n\t\t\t\t\t\t\t      bh);\n\t\tif (IS_SYNC(inode))\n\t\t\text4_handle_sync(handle);\n\t\tdquot_free_block(inode, EXT4_C2B(EXT4_SB(inode->i_sb), 1));\n\t\tea_bdebug(bh, \"refcount now=%d; releasing\",\n\t\t\t  le32_to_cpu(BHDR(bh)->h_refcount));\n\t}\nout:\n\text4_std_error(inode->i_sb, error);\n\treturn;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);",
            "static struct buffer_head *ext4_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext4_xattr_header *,\n\t\t\t\t\t\t struct mb_cache_entry **);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);\nstatic struct buffer_head *ext4_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext4_xattr_header *,\n\t\t\t\t\t\t struct mb_cache_entry **);\n\nstatic void\next4_xattr_release_block(handle_t *handle, struct inode *inode,\n\t\t\t struct buffer_head *bh)\n{\n\tstruct mb_cache_entry *ce = NULL;\n\tint error = 0;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\n\tce = mb_cache_entry_get(ext4_mb_cache, bh->b_bdev, bh->b_blocknr);\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terror = ext4_journal_get_write_access(handle, bh);\n\tif (error)\n\t\tgoto out;\n\n\tlock_buffer(bh);\n\tif (BHDR(bh)->h_refcount == cpu_to_le32(1)) {\n\t\tea_bdebug(bh, \"refcount now=0; freeing\");\n\t\tif (ce)\n\t\t\tmb_cache_entry_free(ce);\n\t\tget_bh(bh);\n\t\tunlock_buffer(bh);\n\t\text4_free_blocks(handle, inode, bh, 0, 1,\n\t\t\t\t EXT4_FREE_BLOCKS_METADATA |\n\t\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\t} else {\n\t\tle32_add_cpu(&BHDR(bh)->h_refcount, -1);\n\t\tif (ce)\n\t\t\tmb_cache_entry_release(ce);\n\t\t/*\n\t\t * Beware of this ugliness: Releasing of xattr block references\n\t\t * from different inodes can race and so we have to protect\n\t\t * from a race where someone else frees the block (and releases\n\t\t * its journal_head) before we are done dirtying the buffer. In\n\t\t * nojournal mode this race is harmless and we actually cannot\n\t\t * call ext4_handle_dirty_xattr_block() with locked buffer as\n\t\t * that function can call sync_dirty_buffer() so for that case\n\t\t * we handle the dirtying after unlocking the buffer.\n\t\t */\n\t\tif (ext4_handle_valid(handle))\n\t\t\terror = ext4_handle_dirty_xattr_block(handle, inode,\n\t\t\t\t\t\t\t      bh);\n\t\tunlock_buffer(bh);\n\t\tif (!ext4_handle_valid(handle))\n\t\t\terror = ext4_handle_dirty_xattr_block(handle, inode,\n\t\t\t\t\t\t\t      bh);\n\t\tif (IS_SYNC(inode))\n\t\t\text4_handle_sync(handle);\n\t\tdquot_free_block(inode, EXT4_C2B(EXT4_SB(inode->i_sb), 1));\n\t\tea_bdebug(bh, \"refcount now=%d; releasing\",\n\t\t\t  le32_to_cpu(BHDR(bh)->h_refcount));\n\t}\nout:\n\text4_std_error(inode->i_sb, error);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_ERROR_INODE",
          "args": [
            "inode",
            "\"bad block %llu\"",
            "EXT4_I(inode)->i_file_acl"
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "1"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BHDR",
          "args": [
            "bh"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "EXT4_XATTR_MAGIC"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BHDR",
          "args": [
            "bh"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_ERROR_INODE",
          "args": [
            "inode",
            "\"block %llu read error\"",
            "EXT4_I(inode)->i_file_acl"
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "inode->i_sb",
            "EXT4_I(inode)->i_file_acl"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);\n\nvoid\next4_xattr_delete_inode(handle_t *handle, struct inode *inode)\n{\n\tstruct buffer_head *bh = NULL;\n\n\tif (!EXT4_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tbh = sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl);\n\tif (!bh) {\n\t\tEXT4_ERROR_INODE(inode, \"block %llu read error\",\n\t\t\t\t EXT4_I(inode)->i_file_acl);\n\t\tgoto cleanup;\n\t}\n\tif (BHDR(bh)->h_magic != cpu_to_le32(EXT4_XATTR_MAGIC) ||\n\t    BHDR(bh)->h_blocks != cpu_to_le32(1)) {\n\t\tEXT4_ERROR_INODE(inode, \"bad block %llu\",\n\t\t\t\t EXT4_I(inode)->i_file_acl);\n\t\tgoto cleanup;\n\t}\n\text4_xattr_release_block(handle, inode, bh);\n\tEXT4_I(inode)->i_file_acl = 0;\n\ncleanup:\n\tbrelse(bh);\n}"
  },
  {
    "function_name": "ext4_expand_extra_isize_ea",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
    "lines": "1258-1477",
    "snippet": "int ext4_expand_extra_isize_ea(struct inode *inode, int new_extra_isize,\n\t\t\t       struct ext4_inode *raw_inode, handle_t *handle)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_xattr_entry *entry, *last, *first;\n\tstruct buffer_head *bh = NULL;\n\tstruct ext4_xattr_ibody_find *is = NULL;\n\tstruct ext4_xattr_block_find *bs = NULL;\n\tchar *buffer = NULL, *b_entry_name = NULL;\n\tsize_t min_offs, free;\n\tint total_ino;\n\tvoid *base, *start, *end;\n\tint extra_isize = 0, error = 0, tried_min_extra_isize = 0;\n\tint s_min_extra_isize = le16_to_cpu(EXT4_SB(inode->i_sb)->s_es->s_min_extra_isize);\n\n\tdown_write(&EXT4_I(inode)->xattr_sem);\nretry:\n\tif (EXT4_I(inode)->i_extra_isize >= new_extra_isize) {\n\t\tup_write(&EXT4_I(inode)->xattr_sem);\n\t\treturn 0;\n\t}\n\n\theader = IHDR(inode, raw_inode);\n\tentry = IFIRST(header);\n\n\t/*\n\t * Check if enough free space is available in the inode to shift the\n\t * entries ahead by new_extra_isize.\n\t */\n\n\tbase = start = entry;\n\tend = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;\n\tmin_offs = end - base;\n\tlast = entry;\n\ttotal_ino = sizeof(struct ext4_xattr_ibody_header);\n\n\tfree = ext4_xattr_free_space(last, &min_offs, base, &total_ino);\n\tif (free >= new_extra_isize) {\n\t\tentry = IFIRST(header);\n\t\text4_xattr_shift_entries(entry,\tEXT4_I(inode)->i_extra_isize\n\t\t\t\t- new_extra_isize, (void *)raw_inode +\n\t\t\t\tEXT4_GOOD_OLD_INODE_SIZE + new_extra_isize,\n\t\t\t\t(void *)header, total_ino,\n\t\t\t\tinode->i_sb->s_blocksize);\n\t\tEXT4_I(inode)->i_extra_isize = new_extra_isize;\n\t\terror = 0;\n\t\tgoto cleanup;\n\t}\n\n\t/*\n\t * Enough free space isn't available in the inode, check if\n\t * EA block can hold new_extra_isize bytes.\n\t */\n\tif (EXT4_I(inode)->i_file_acl) {\n\t\tbh = sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tif (!bh)\n\t\t\tgoto cleanup;\n\t\tif (ext4_xattr_check_block(inode, bh)) {\n\t\t\tEXT4_ERROR_INODE(inode, \"bad block %llu\",\n\t\t\t\t\t EXT4_I(inode)->i_file_acl);\n\t\t\terror = -EIO;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tbase = BHDR(bh);\n\t\tfirst = BFIRST(bh);\n\t\tend = bh->b_data + bh->b_size;\n\t\tmin_offs = end - base;\n\t\tfree = ext4_xattr_free_space(first, &min_offs, base, NULL);\n\t\tif (free < new_extra_isize) {\n\t\t\tif (!tried_min_extra_isize && s_min_extra_isize) {\n\t\t\t\ttried_min_extra_isize++;\n\t\t\t\tnew_extra_isize = s_min_extra_isize;\n\t\t\t\tbrelse(bh);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\terror = -1;\n\t\t\tgoto cleanup;\n\t\t}\n\t} else {\n\t\tfree = inode->i_sb->s_blocksize;\n\t}\n\n\twhile (new_extra_isize > 0) {\n\t\tsize_t offs, size, entry_size;\n\t\tstruct ext4_xattr_entry *small_entry = NULL;\n\t\tstruct ext4_xattr_info i = {\n\t\t\t.value = NULL,\n\t\t\t.value_len = 0,\n\t\t};\n\t\tunsigned int total_size;  /* EA entry size + value size */\n\t\tunsigned int shift_bytes; /* No. of bytes to shift EAs by? */\n\t\tunsigned int min_total_size = ~0U;\n\n\t\tis = kzalloc(sizeof(struct ext4_xattr_ibody_find), GFP_NOFS);\n\t\tbs = kzalloc(sizeof(struct ext4_xattr_block_find), GFP_NOFS);\n\t\tif (!is || !bs) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tis->s.not_found = -ENODATA;\n\t\tbs->s.not_found = -ENODATA;\n\t\tis->iloc.bh = NULL;\n\t\tbs->bh = NULL;\n\n\t\tlast = IFIRST(header);\n\t\t/* Find the entry best suited to be pushed into EA block */\n\t\tentry = NULL;\n\t\tfor (; !IS_LAST_ENTRY(last); last = EXT4_XATTR_NEXT(last)) {\n\t\t\ttotal_size =\n\t\t\tEXT4_XATTR_SIZE(le32_to_cpu(last->e_value_size)) +\n\t\t\t\t\tEXT4_XATTR_LEN(last->e_name_len);\n\t\t\tif (total_size <= free && total_size < min_total_size) {\n\t\t\t\tif (total_size < new_extra_isize) {\n\t\t\t\t\tsmall_entry = last;\n\t\t\t\t} else {\n\t\t\t\t\tentry = last;\n\t\t\t\t\tmin_total_size = total_size;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (entry == NULL) {\n\t\t\tif (small_entry) {\n\t\t\t\tentry = small_entry;\n\t\t\t} else {\n\t\t\t\tif (!tried_min_extra_isize &&\n\t\t\t\t    s_min_extra_isize) {\n\t\t\t\t\ttried_min_extra_isize++;\n\t\t\t\t\tnew_extra_isize = s_min_extra_isize;\n\t\t\t\t\tkfree(is); is = NULL;\n\t\t\t\t\tkfree(bs); bs = NULL;\n\t\t\t\t\tbrelse(bh);\n\t\t\t\t\tgoto retry;\n\t\t\t\t}\n\t\t\t\terror = -1;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\t\toffs = le16_to_cpu(entry->e_value_offs);\n\t\tsize = le32_to_cpu(entry->e_value_size);\n\t\tentry_size = EXT4_XATTR_LEN(entry->e_name_len);\n\t\ti.name_index = entry->e_name_index,\n\t\tbuffer = kmalloc(EXT4_XATTR_SIZE(size), GFP_NOFS);\n\t\tb_entry_name = kmalloc(entry->e_name_len + 1, GFP_NOFS);\n\t\tif (!buffer || !b_entry_name) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto cleanup;\n\t\t}\n\t\t/* Save the entry name and the entry value */\n\t\tmemcpy(buffer, (void *)IFIRST(header) + offs,\n\t\t       EXT4_XATTR_SIZE(size));\n\t\tmemcpy(b_entry_name, entry->e_name, entry->e_name_len);\n\t\tb_entry_name[entry->e_name_len] = '\\0';\n\t\ti.name = b_entry_name;\n\n\t\terror = ext4_get_inode_loc(inode, &is->iloc);\n\t\tif (error)\n\t\t\tgoto cleanup;\n\n\t\terror = ext4_xattr_ibody_find(inode, &i, is);\n\t\tif (error)\n\t\t\tgoto cleanup;\n\n\t\t/* Remove the chosen entry from the inode */\n\t\terror = ext4_xattr_ibody_set(handle, inode, &i, is);\n\t\tif (error)\n\t\t\tgoto cleanup;\n\n\t\tentry = IFIRST(header);\n\t\tif (entry_size + EXT4_XATTR_SIZE(size) >= new_extra_isize)\n\t\t\tshift_bytes = new_extra_isize;\n\t\telse\n\t\t\tshift_bytes = entry_size + size;\n\t\t/* Adjust the offsets and shift the remaining entries ahead */\n\t\text4_xattr_shift_entries(entry, EXT4_I(inode)->i_extra_isize -\n\t\t\tshift_bytes, (void *)raw_inode +\n\t\t\tEXT4_GOOD_OLD_INODE_SIZE + extra_isize + shift_bytes,\n\t\t\t(void *)header, total_ino - entry_size,\n\t\t\tinode->i_sb->s_blocksize);\n\n\t\textra_isize += shift_bytes;\n\t\tnew_extra_isize -= shift_bytes;\n\t\tEXT4_I(inode)->i_extra_isize = extra_isize;\n\n\t\ti.name = b_entry_name;\n\t\ti.value = buffer;\n\t\ti.value_len = size;\n\t\terror = ext4_xattr_block_find(inode, &i, bs);\n\t\tif (error)\n\t\t\tgoto cleanup;\n\n\t\t/* Add entry which was removed from the inode into the block */\n\t\terror = ext4_xattr_block_set(handle, inode, &i, bs);\n\t\tif (error)\n\t\t\tgoto cleanup;\n\t\tkfree(b_entry_name);\n\t\tkfree(buffer);\n\t\tb_entry_name = NULL;\n\t\tbuffer = NULL;\n\t\tbrelse(is->iloc.bh);\n\t\tkfree(is);\n\t\tkfree(bs);\n\t}\n\tbrelse(bh);\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\treturn 0;\n\ncleanup:\n\tkfree(b_entry_name);\n\tkfree(buffer);\n\tif (is)\n\t\tbrelse(is->iloc.bh);\n\tkfree(is);\n\tkfree(bs);\n\tbrelse(bh);\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\treturn error;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);",
      "static void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&EXT4_I(inode)->xattr_sem"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1474
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bs"
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "is"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buffer"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "b_entry_name"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&EXT4_I(inode)->xattr_sem"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bs"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "is"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buffer"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "b_entry_name"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_xattr_block_set",
          "args": [
            "handle",
            "inode",
            "&i",
            "bs"
          ],
          "line": 1452
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_block_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "776-979",
          "snippet": "static int\next4_xattr_block_set(handle_t *handle, struct inode *inode,\n\t\t     struct ext4_xattr_info *i,\n\t\t     struct ext4_xattr_block_find *bs)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ext4_xattr_search *s = &bs->s;\n\tstruct mb_cache_entry *ce = NULL;\n\tint error = 0;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\n#define header(x) ((struct ext4_xattr_header *)(x))\n\n\tif (i->value && i->value_len > sb->s_blocksize)\n\t\treturn -ENOSPC;\n\tif (s->base) {\n\t\tce = mb_cache_entry_get(ext4_mb_cache, bs->bh->b_bdev,\n\t\t\t\t\tbs->bh->b_blocknr);\n\t\tBUFFER_TRACE(bs->bh, \"get_write_access\");\n\t\terror = ext4_journal_get_write_access(handle, bs->bh);\n\t\tif (error)\n\t\t\tgoto cleanup;\n\t\tlock_buffer(bs->bh);\n\n\t\tif (header(s->base)->h_refcount == cpu_to_le32(1)) {\n\t\t\tif (ce) {\n\t\t\t\tmb_cache_entry_free(ce);\n\t\t\t\tce = NULL;\n\t\t\t}\n\t\t\tea_bdebug(bs->bh, \"modifying in-place\");\n\t\t\terror = ext4_xattr_set_entry(i, s);\n\t\t\tif (!error) {\n\t\t\t\tif (!IS_LAST_ENTRY(s->first))\n\t\t\t\t\text4_xattr_rehash(header(s->base),\n\t\t\t\t\t\t\t  s->here);\n\t\t\t\text4_xattr_cache_insert(ext4_mb_cache,\n\t\t\t\t\tbs->bh);\n\t\t\t}\n\t\t\tunlock_buffer(bs->bh);\n\t\t\tif (error == -EIO)\n\t\t\t\tgoto bad_block;\n\t\t\tif (!error)\n\t\t\t\terror = ext4_handle_dirty_xattr_block(handle,\n\t\t\t\t\t\t\t\t      inode,\n\t\t\t\t\t\t\t\t      bs->bh);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t\tgoto inserted;\n\t\t} else {\n\t\t\tint offset = (char *)s->here - bs->bh->b_data;\n\n\t\t\tunlock_buffer(bs->bh);\n\t\t\tif (ce) {\n\t\t\t\tmb_cache_entry_release(ce);\n\t\t\t\tce = NULL;\n\t\t\t}\n\t\t\tea_bdebug(bs->bh, \"cloning\");\n\t\t\ts->base = kmalloc(bs->bh->b_size, GFP_NOFS);\n\t\t\terror = -ENOMEM;\n\t\t\tif (s->base == NULL)\n\t\t\t\tgoto cleanup;\n\t\t\tmemcpy(s->base, BHDR(bs->bh), bs->bh->b_size);\n\t\t\ts->first = ENTRY(header(s->base)+1);\n\t\t\theader(s->base)->h_refcount = cpu_to_le32(1);\n\t\t\ts->here = ENTRY(s->base + offset);\n\t\t\ts->end = s->base + bs->bh->b_size;\n\t\t}\n\t} else {\n\t\t/* Allocate a buffer where we construct the new block. */\n\t\ts->base = kzalloc(sb->s_blocksize, GFP_NOFS);\n\t\t/* assert(header == s->base) */\n\t\terror = -ENOMEM;\n\t\tif (s->base == NULL)\n\t\t\tgoto cleanup;\n\t\theader(s->base)->h_magic = cpu_to_le32(EXT4_XATTR_MAGIC);\n\t\theader(s->base)->h_blocks = cpu_to_le32(1);\n\t\theader(s->base)->h_refcount = cpu_to_le32(1);\n\t\ts->first = ENTRY(header(s->base)+1);\n\t\ts->here = ENTRY(header(s->base)+1);\n\t\ts->end = s->base + sb->s_blocksize;\n\t}\n\n\terror = ext4_xattr_set_entry(i, s);\n\tif (error == -EIO)\n\t\tgoto bad_block;\n\tif (error)\n\t\tgoto cleanup;\n\tif (!IS_LAST_ENTRY(s->first))\n\t\text4_xattr_rehash(header(s->base), s->here);\n\ninserted:\n\tif (!IS_LAST_ENTRY(s->first)) {\n\t\tnew_bh = ext4_xattr_cache_find(inode, header(s->base), &ce);\n\t\tif (new_bh) {\n\t\t\t/* We found an identical block in the cache. */\n\t\t\tif (new_bh == bs->bh)\n\t\t\t\tea_bdebug(new_bh, \"keeping\");\n\t\t\telse {\n\t\t\t\t/* The old block is released after updating\n\t\t\t\t   the inode. */\n\t\t\t\terror = dquot_alloc_block(inode,\n\t\t\t\t\t\tEXT4_C2B(EXT4_SB(sb), 1));\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup;\n\t\t\t\tBUFFER_TRACE(new_bh, \"get_write_access\");\n\t\t\t\terror = ext4_journal_get_write_access(handle,\n\t\t\t\t\t\t\t\t      new_bh);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup_dquot;\n\t\t\t\tlock_buffer(new_bh);\n\t\t\t\tle32_add_cpu(&BHDR(new_bh)->h_refcount, 1);\n\t\t\t\tea_bdebug(new_bh, \"reusing; refcount now=%d\",\n\t\t\t\t\tle32_to_cpu(BHDR(new_bh)->h_refcount));\n\t\t\t\tunlock_buffer(new_bh);\n\t\t\t\terror = ext4_handle_dirty_xattr_block(handle,\n\t\t\t\t\t\t\t\t      inode,\n\t\t\t\t\t\t\t\t      new_bh);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup_dquot;\n\t\t\t}\n\t\t\tmb_cache_entry_release(ce);\n\t\t\tce = NULL;\n\t\t} else if (bs->bh && s->base == bs->bh->b_data) {\n\t\t\t/* We were modifying this block in-place. */\n\t\t\tea_bdebug(bs->bh, \"keeping this block\");\n\t\t\tnew_bh = bs->bh;\n\t\t\tget_bh(new_bh);\n\t\t} else {\n\t\t\t/* We need to allocate a new block */\n\t\t\text4_fsblk_t goal, block;\n\n\t\t\tgoal = ext4_group_first_block_no(sb,\n\t\t\t\t\t\tEXT4_I(inode)->i_block_group);\n\n\t\t\t/* non-extent files can't have physical blocks past 2^32 */\n\t\t\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\t\t\tgoal = goal & EXT4_MAX_BLOCK_FILE_PHYS;\n\n\t\t\tblock = ext4_new_meta_blocks(handle, inode, goal, 0,\n\t\t\t\t\t\t     NULL, &error);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\n\t\t\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\t\t\tBUG_ON(block > EXT4_MAX_BLOCK_FILE_PHYS);\n\n\t\t\tea_idebug(inode, \"creating block %llu\",\n\t\t\t\t  (unsigned long long)block);\n\n\t\t\tnew_bh = sb_getblk(sb, block);\n\t\t\tif (unlikely(!new_bh)) {\n\t\t\t\terror = -ENOMEM;\ngetblk_failed:\n\t\t\t\text4_free_blocks(handle, inode, NULL, block, 1,\n\t\t\t\t\t\t EXT4_FREE_BLOCKS_METADATA);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tlock_buffer(new_bh);\n\t\t\terror = ext4_journal_get_create_access(handle, new_bh);\n\t\t\tif (error) {\n\t\t\t\tunlock_buffer(new_bh);\n\t\t\t\terror = -EIO;\n\t\t\t\tgoto getblk_failed;\n\t\t\t}\n\t\t\tmemcpy(new_bh->b_data, s->base, new_bh->b_size);\n\t\t\tset_buffer_uptodate(new_bh);\n\t\t\tunlock_buffer(new_bh);\n\t\t\text4_xattr_cache_insert(ext4_mb_cache, new_bh);\n\t\t\terror = ext4_handle_dirty_xattr_block(handle,\n\t\t\t\t\t\t\t      inode, new_bh);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t/* Update the inode. */\n\tEXT4_I(inode)->i_file_acl = new_bh ? new_bh->b_blocknr : 0;\n\n\t/* Drop the previous xattr block. */\n\tif (bs->bh && bs->bh != new_bh)\n\t\text4_xattr_release_block(handle, inode, bs->bh);\n\terror = 0;\n\ncleanup:\n\tif (ce)\n\t\tmb_cache_entry_release(ce);\n\tbrelse(new_bh);\n\tif (!(bs->bh && s->base == bs->bh->b_data))\n\t\tkfree(s->base);\n\n\treturn error;\n\ncleanup_dquot:\n\tdquot_free_block(inode, EXT4_C2B(EXT4_SB(sb), 1));\n\tgoto cleanup;\n\nbad_block:\n\tEXT4_ERROR_INODE(inode, \"bad block %llu\",\n\t\t\t EXT4_I(inode)->i_file_acl);\n\tgoto cleanup;\n\n#undef header\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);",
            "static struct buffer_head *ext4_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext4_xattr_header *,\n\t\t\t\t\t\t struct mb_cache_entry **);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);\nstatic struct buffer_head *ext4_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext4_xattr_header *,\n\t\t\t\t\t\t struct mb_cache_entry **);\n\nstatic int\next4_xattr_block_set(handle_t *handle, struct inode *inode,\n\t\t     struct ext4_xattr_info *i,\n\t\t     struct ext4_xattr_block_find *bs)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ext4_xattr_search *s = &bs->s;\n\tstruct mb_cache_entry *ce = NULL;\n\tint error = 0;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\n#define header(x) ((struct ext4_xattr_header *)(x))\n\n\tif (i->value && i->value_len > sb->s_blocksize)\n\t\treturn -ENOSPC;\n\tif (s->base) {\n\t\tce = mb_cache_entry_get(ext4_mb_cache, bs->bh->b_bdev,\n\t\t\t\t\tbs->bh->b_blocknr);\n\t\tBUFFER_TRACE(bs->bh, \"get_write_access\");\n\t\terror = ext4_journal_get_write_access(handle, bs->bh);\n\t\tif (error)\n\t\t\tgoto cleanup;\n\t\tlock_buffer(bs->bh);\n\n\t\tif (header(s->base)->h_refcount == cpu_to_le32(1)) {\n\t\t\tif (ce) {\n\t\t\t\tmb_cache_entry_free(ce);\n\t\t\t\tce = NULL;\n\t\t\t}\n\t\t\tea_bdebug(bs->bh, \"modifying in-place\");\n\t\t\terror = ext4_xattr_set_entry(i, s);\n\t\t\tif (!error) {\n\t\t\t\tif (!IS_LAST_ENTRY(s->first))\n\t\t\t\t\text4_xattr_rehash(header(s->base),\n\t\t\t\t\t\t\t  s->here);\n\t\t\t\text4_xattr_cache_insert(ext4_mb_cache,\n\t\t\t\t\tbs->bh);\n\t\t\t}\n\t\t\tunlock_buffer(bs->bh);\n\t\t\tif (error == -EIO)\n\t\t\t\tgoto bad_block;\n\t\t\tif (!error)\n\t\t\t\terror = ext4_handle_dirty_xattr_block(handle,\n\t\t\t\t\t\t\t\t      inode,\n\t\t\t\t\t\t\t\t      bs->bh);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t\tgoto inserted;\n\t\t} else {\n\t\t\tint offset = (char *)s->here - bs->bh->b_data;\n\n\t\t\tunlock_buffer(bs->bh);\n\t\t\tif (ce) {\n\t\t\t\tmb_cache_entry_release(ce);\n\t\t\t\tce = NULL;\n\t\t\t}\n\t\t\tea_bdebug(bs->bh, \"cloning\");\n\t\t\ts->base = kmalloc(bs->bh->b_size, GFP_NOFS);\n\t\t\terror = -ENOMEM;\n\t\t\tif (s->base == NULL)\n\t\t\t\tgoto cleanup;\n\t\t\tmemcpy(s->base, BHDR(bs->bh), bs->bh->b_size);\n\t\t\ts->first = ENTRY(header(s->base)+1);\n\t\t\theader(s->base)->h_refcount = cpu_to_le32(1);\n\t\t\ts->here = ENTRY(s->base + offset);\n\t\t\ts->end = s->base + bs->bh->b_size;\n\t\t}\n\t} else {\n\t\t/* Allocate a buffer where we construct the new block. */\n\t\ts->base = kzalloc(sb->s_blocksize, GFP_NOFS);\n\t\t/* assert(header == s->base) */\n\t\terror = -ENOMEM;\n\t\tif (s->base == NULL)\n\t\t\tgoto cleanup;\n\t\theader(s->base)->h_magic = cpu_to_le32(EXT4_XATTR_MAGIC);\n\t\theader(s->base)->h_blocks = cpu_to_le32(1);\n\t\theader(s->base)->h_refcount = cpu_to_le32(1);\n\t\ts->first = ENTRY(header(s->base)+1);\n\t\ts->here = ENTRY(header(s->base)+1);\n\t\ts->end = s->base + sb->s_blocksize;\n\t}\n\n\terror = ext4_xattr_set_entry(i, s);\n\tif (error == -EIO)\n\t\tgoto bad_block;\n\tif (error)\n\t\tgoto cleanup;\n\tif (!IS_LAST_ENTRY(s->first))\n\t\text4_xattr_rehash(header(s->base), s->here);\n\ninserted:\n\tif (!IS_LAST_ENTRY(s->first)) {\n\t\tnew_bh = ext4_xattr_cache_find(inode, header(s->base), &ce);\n\t\tif (new_bh) {\n\t\t\t/* We found an identical block in the cache. */\n\t\t\tif (new_bh == bs->bh)\n\t\t\t\tea_bdebug(new_bh, \"keeping\");\n\t\t\telse {\n\t\t\t\t/* The old block is released after updating\n\t\t\t\t   the inode. */\n\t\t\t\terror = dquot_alloc_block(inode,\n\t\t\t\t\t\tEXT4_C2B(EXT4_SB(sb), 1));\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup;\n\t\t\t\tBUFFER_TRACE(new_bh, \"get_write_access\");\n\t\t\t\terror = ext4_journal_get_write_access(handle,\n\t\t\t\t\t\t\t\t      new_bh);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup_dquot;\n\t\t\t\tlock_buffer(new_bh);\n\t\t\t\tle32_add_cpu(&BHDR(new_bh)->h_refcount, 1);\n\t\t\t\tea_bdebug(new_bh, \"reusing; refcount now=%d\",\n\t\t\t\t\tle32_to_cpu(BHDR(new_bh)->h_refcount));\n\t\t\t\tunlock_buffer(new_bh);\n\t\t\t\terror = ext4_handle_dirty_xattr_block(handle,\n\t\t\t\t\t\t\t\t      inode,\n\t\t\t\t\t\t\t\t      new_bh);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup_dquot;\n\t\t\t}\n\t\t\tmb_cache_entry_release(ce);\n\t\t\tce = NULL;\n\t\t} else if (bs->bh && s->base == bs->bh->b_data) {\n\t\t\t/* We were modifying this block in-place. */\n\t\t\tea_bdebug(bs->bh, \"keeping this block\");\n\t\t\tnew_bh = bs->bh;\n\t\t\tget_bh(new_bh);\n\t\t} else {\n\t\t\t/* We need to allocate a new block */\n\t\t\text4_fsblk_t goal, block;\n\n\t\t\tgoal = ext4_group_first_block_no(sb,\n\t\t\t\t\t\tEXT4_I(inode)->i_block_group);\n\n\t\t\t/* non-extent files can't have physical blocks past 2^32 */\n\t\t\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\t\t\tgoal = goal & EXT4_MAX_BLOCK_FILE_PHYS;\n\n\t\t\tblock = ext4_new_meta_blocks(handle, inode, goal, 0,\n\t\t\t\t\t\t     NULL, &error);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\n\t\t\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\t\t\tBUG_ON(block > EXT4_MAX_BLOCK_FILE_PHYS);\n\n\t\t\tea_idebug(inode, \"creating block %llu\",\n\t\t\t\t  (unsigned long long)block);\n\n\t\t\tnew_bh = sb_getblk(sb, block);\n\t\t\tif (unlikely(!new_bh)) {\n\t\t\t\terror = -ENOMEM;\ngetblk_failed:\n\t\t\t\text4_free_blocks(handle, inode, NULL, block, 1,\n\t\t\t\t\t\t EXT4_FREE_BLOCKS_METADATA);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tlock_buffer(new_bh);\n\t\t\terror = ext4_journal_get_create_access(handle, new_bh);\n\t\t\tif (error) {\n\t\t\t\tunlock_buffer(new_bh);\n\t\t\t\terror = -EIO;\n\t\t\t\tgoto getblk_failed;\n\t\t\t}\n\t\t\tmemcpy(new_bh->b_data, s->base, new_bh->b_size);\n\t\t\tset_buffer_uptodate(new_bh);\n\t\t\tunlock_buffer(new_bh);\n\t\t\text4_xattr_cache_insert(ext4_mb_cache, new_bh);\n\t\t\terror = ext4_handle_dirty_xattr_block(handle,\n\t\t\t\t\t\t\t      inode, new_bh);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t/* Update the inode. */\n\tEXT4_I(inode)->i_file_acl = new_bh ? new_bh->b_blocknr : 0;\n\n\t/* Drop the previous xattr block. */\n\tif (bs->bh && bs->bh != new_bh)\n\t\text4_xattr_release_block(handle, inode, bs->bh);\n\terror = 0;\n\ncleanup:\n\tif (ce)\n\t\tmb_cache_entry_release(ce);\n\tbrelse(new_bh);\n\tif (!(bs->bh && s->base == bs->bh->b_data))\n\t\tkfree(s->base);\n\n\treturn error;\n\ncleanup_dquot:\n\tdquot_free_block(inode, EXT4_C2B(EXT4_SB(sb), 1));\n\tgoto cleanup;\n\nbad_block:\n\tEXT4_ERROR_INODE(inode, \"bad block %llu\",\n\t\t\t EXT4_I(inode)->i_file_acl);\n\tgoto cleanup;\n\n#undef header\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_xattr_block_find",
          "args": [
            "inode",
            "&i",
            "bs"
          ],
          "line": 1447
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_block_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "734-774",
          "snippet": "static int\next4_xattr_block_find(struct inode *inode, struct ext4_xattr_info *i,\n\t\t      struct ext4_xattr_block_find *bs)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint error;\n\n\tea_idebug(inode, \"name=%d.%s, value=%p, value_len=%ld\",\n\t\t  i->name_index, i->name, i->value, (long)i->value_len);\n\n\tif (EXT4_I(inode)->i_file_acl) {\n\t\t/* The inode already has an extended attribute block. */\n\t\tbs->bh = sb_bread(sb, EXT4_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tif (!bs->bh)\n\t\t\tgoto cleanup;\n\t\tea_bdebug(bs->bh, \"b_count=%d, refcount=%d\",\n\t\t\tatomic_read(&(bs->bh->b_count)),\n\t\t\tle32_to_cpu(BHDR(bs->bh)->h_refcount));\n\t\tif (ext4_xattr_check_block(inode, bs->bh)) {\n\t\t\tEXT4_ERROR_INODE(inode, \"bad block %llu\",\n\t\t\t\t\t EXT4_I(inode)->i_file_acl);\n\t\t\terror = -EIO;\n\t\t\tgoto cleanup;\n\t\t}\n\t\t/* Find the named attribute. */\n\t\tbs->s.base = BHDR(bs->bh);\n\t\tbs->s.first = BFIRST(bs->bh);\n\t\tbs->s.end = bs->bh->b_data + bs->bh->b_size;\n\t\tbs->s.here = bs->s.first;\n\t\terror = ext4_xattr_find_entry(&bs->s.here, i->name_index,\n\t\t\t\t\t      i->name, bs->bh->b_size, 1);\n\t\tif (error && error != -ENODATA)\n\t\t\tgoto cleanup;\n\t\tbs->s.not_found = error;\n\t}\n\terror = 0;\n\ncleanup:\n\treturn error;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic int\next4_xattr_block_find(struct inode *inode, struct ext4_xattr_info *i,\n\t\t      struct ext4_xattr_block_find *bs)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint error;\n\n\tea_idebug(inode, \"name=%d.%s, value=%p, value_len=%ld\",\n\t\t  i->name_index, i->name, i->value, (long)i->value_len);\n\n\tif (EXT4_I(inode)->i_file_acl) {\n\t\t/* The inode already has an extended attribute block. */\n\t\tbs->bh = sb_bread(sb, EXT4_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tif (!bs->bh)\n\t\t\tgoto cleanup;\n\t\tea_bdebug(bs->bh, \"b_count=%d, refcount=%d\",\n\t\t\tatomic_read(&(bs->bh->b_count)),\n\t\t\tle32_to_cpu(BHDR(bs->bh)->h_refcount));\n\t\tif (ext4_xattr_check_block(inode, bs->bh)) {\n\t\t\tEXT4_ERROR_INODE(inode, \"bad block %llu\",\n\t\t\t\t\t EXT4_I(inode)->i_file_acl);\n\t\t\terror = -EIO;\n\t\t\tgoto cleanup;\n\t\t}\n\t\t/* Find the named attribute. */\n\t\tbs->s.base = BHDR(bs->bh);\n\t\tbs->s.first = BFIRST(bs->bh);\n\t\tbs->s.end = bs->bh->b_data + bs->bh->b_size;\n\t\tbs->s.here = bs->s.first;\n\t\terror = ext4_xattr_find_entry(&bs->s.here, i->name_index,\n\t\t\t\t\t      i->name, bs->bh->b_size, 1);\n\t\tif (error && error != -ENODATA)\n\t\t\tgoto cleanup;\n\t\tbs->s.not_found = error;\n\t}\n\terror = 0;\n\ncleanup:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_xattr_shift_entries",
          "args": [
            "entry",
            "EXT4_I(inode)->i_extra_isize -\n\t\t\tshift_bytes",
            "(void *)raw_inode +\n\t\t\tEXT4_GOOD_OLD_INODE_SIZE + extra_isize + shift_bytes",
            "(void *)header",
            "total_ino - entry_size",
            "inode->i_sb->s_blocksize"
          ],
          "line": 1434
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_shift_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "1233-1252",
          "snippet": "static void ext4_xattr_shift_entries(struct ext4_xattr_entry *entry,\n\t\t\t\t     int value_offs_shift, void *to,\n\t\t\t\t     void *from, size_t n, int blocksize)\n{\n\tstruct ext4_xattr_entry *last = entry;\n\tint new_offs;\n\n\t/* Adjust the value offsets of the entries */\n\tfor (; !IS_LAST_ENTRY(last); last = EXT4_XATTR_NEXT(last)) {\n\t\tif (!last->e_value_block && last->e_value_size) {\n\t\t\tnew_offs = le16_to_cpu(last->e_value_offs) +\n\t\t\t\t\t\t\tvalue_offs_shift;\n\t\t\tBUG_ON(new_offs + le32_to_cpu(last->e_value_size)\n\t\t\t\t > blocksize);\n\t\t\tlast->e_value_offs = cpu_to_le16(new_offs);\n\t\t}\n\t}\n\t/* Shift the entries by n bytes */\n\tmemmove(to, from, n);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);\n\nstatic void ext4_xattr_shift_entries(struct ext4_xattr_entry *entry,\n\t\t\t\t     int value_offs_shift, void *to,\n\t\t\t\t     void *from, size_t n, int blocksize)\n{\n\tstruct ext4_xattr_entry *last = entry;\n\tint new_offs;\n\n\t/* Adjust the value offsets of the entries */\n\tfor (; !IS_LAST_ENTRY(last); last = EXT4_XATTR_NEXT(last)) {\n\t\tif (!last->e_value_block && last->e_value_size) {\n\t\t\tnew_offs = le16_to_cpu(last->e_value_offs) +\n\t\t\t\t\t\t\tvalue_offs_shift;\n\t\t\tBUG_ON(new_offs + le32_to_cpu(last->e_value_size)\n\t\t\t\t > blocksize);\n\t\t\tlast->e_value_offs = cpu_to_le16(new_offs);\n\t\t}\n\t}\n\t/* Shift the entries by n bytes */\n\tmemmove(to, from, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_XATTR_SIZE",
          "args": [
            "size"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFIRST",
          "args": [
            "header"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_xattr_ibody_set",
          "args": [
            "handle",
            "inode",
            "&i",
            "is"
          ],
          "line": 1424
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_ibody_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "1049-1071",
          "snippet": "static int ext4_xattr_ibody_set(handle_t *handle, struct inode *inode,\n\t\t\t\tstruct ext4_xattr_info *i,\n\t\t\t\tstruct ext4_xattr_ibody_find *is)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_xattr_search *s = &is->s;\n\tint error;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn -ENOSPC;\n\terror = ext4_xattr_set_entry(i, s);\n\tif (error)\n\t\treturn error;\n\theader = IHDR(inode, ext4_raw_inode(&is->iloc));\n\tif (!IS_LAST_ENTRY(s->first)) {\n\t\theader->h_magic = cpu_to_le32(EXT4_XATTR_MAGIC);\n\t\text4_set_inode_state(inode, EXT4_STATE_XATTR);\n\t} else {\n\t\theader->h_magic = cpu_to_le32(0);\n\t\text4_clear_inode_state(inode, EXT4_STATE_XATTR);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic int ext4_xattr_ibody_set(handle_t *handle, struct inode *inode,\n\t\t\t\tstruct ext4_xattr_info *i,\n\t\t\t\tstruct ext4_xattr_ibody_find *is)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_xattr_search *s = &is->s;\n\tint error;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn -ENOSPC;\n\terror = ext4_xattr_set_entry(i, s);\n\tif (error)\n\t\treturn error;\n\theader = IHDR(inode, ext4_raw_inode(&is->iloc));\n\tif (!IS_LAST_ENTRY(s->first)) {\n\t\theader->h_magic = cpu_to_le32(EXT4_XATTR_MAGIC);\n\t\text4_set_inode_state(inode, EXT4_STATE_XATTR);\n\t} else {\n\t\theader->h_magic = cpu_to_le32(0);\n\t\text4_clear_inode_state(inode, EXT4_STATE_XATTR);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_xattr_ibody_find",
          "args": [
            "inode",
            "&i",
            "is"
          ],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_ibody_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "981-1009",
          "snippet": "int ext4_xattr_ibody_find(struct inode *inode, struct ext4_xattr_info *i,\n\t\t\t  struct ext4_xattr_ibody_find *is)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_inode *raw_inode;\n\tint error;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn 0;\n\traw_inode = ext4_raw_inode(&is->iloc);\n\theader = IHDR(inode, raw_inode);\n\tis->s.base = is->s.first = IFIRST(header);\n\tis->s.here = is->s.first;\n\tis->s.end = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;\n\tif (ext4_test_inode_state(inode, EXT4_STATE_XATTR)) {\n\t\terror = ext4_xattr_check_names(IFIRST(header), is->s.end,\n\t\t\t\t\t       IFIRST(header));\n\t\tif (error)\n\t\t\treturn error;\n\t\t/* Find the named attribute. */\n\t\terror = ext4_xattr_find_entry(&is->s.here, i->name_index,\n\t\t\t\t\t      i->name, is->s.end -\n\t\t\t\t\t      (void *)is->s.base, 0);\n\t\tif (error && error != -ENODATA)\n\t\t\treturn error;\n\t\tis->s.not_found = error;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nint ext4_xattr_ibody_find(struct inode *inode, struct ext4_xattr_info *i,\n\t\t\t  struct ext4_xattr_ibody_find *is)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_inode *raw_inode;\n\tint error;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn 0;\n\traw_inode = ext4_raw_inode(&is->iloc);\n\theader = IHDR(inode, raw_inode);\n\tis->s.base = is->s.first = IFIRST(header);\n\tis->s.here = is->s.first;\n\tis->s.end = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;\n\tif (ext4_test_inode_state(inode, EXT4_STATE_XATTR)) {\n\t\terror = ext4_xattr_check_names(IFIRST(header), is->s.end,\n\t\t\t\t\t       IFIRST(header));\n\t\tif (error)\n\t\t\treturn error;\n\t\t/* Find the named attribute. */\n\t\terror = ext4_xattr_find_entry(&is->s.here, i->name_index,\n\t\t\t\t\t      i->name, is->s.end -\n\t\t\t\t\t      (void *)is->s.base, 0);\n\t\tif (error && error != -ENODATA)\n\t\t\treturn error;\n\t\tis->s.not_found = error;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_inode_loc",
          "args": [
            "inode",
            "&is->iloc"
          ],
          "line": 1415
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_inode_loc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3816-3821",
          "snippet": "int ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "b_entry_name",
            "entry->e_name",
            "entry->e_name_len"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer",
            "(void *)IFIRST(header) + offs",
            "EXT4_XATTR_SIZE(size)"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_XATTR_SIZE",
          "args": [
            "size"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFIRST",
          "args": [
            "header"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "entry->e_name_len + 1",
            "GFP_NOFS"
          ],
          "line": 1403
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_XATTR_SIZE",
          "args": [
            "size"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_XATTR_LEN",
          "args": [
            "entry->e_name_len"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "entry->e_value_size"
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "entry->e_value_offs"
          ],
          "line": 1398
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bs"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "is"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_XATTR_LEN",
          "args": [
            "last->e_name_len"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_XATTR_SIZE",
          "args": [
            "le32_to_cpu(last->e_value_size)"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_XATTR_NEXT",
          "args": [
            "last"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LAST_ENTRY",
          "args": [
            "last"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFIRST",
          "args": [
            "header"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct ext4_xattr_block_find)",
            "GFP_NOFS"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct ext4_xattr_ibody_find)",
            "GFP_NOFS"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_xattr_free_space",
          "args": [
            "first",
            "&min_offs",
            "base",
            "NULL"
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "603-616",
          "snippet": "static size_t ext4_xattr_free_space(struct ext4_xattr_entry *last,\n\t\t\t\t    size_t *min_offs, void *base, int *total)\n{\n\tfor (; !IS_LAST_ENTRY(last); last = EXT4_XATTR_NEXT(last)) {\n\t\tif (!last->e_value_block && last->e_value_size) {\n\t\t\tsize_t offs = le16_to_cpu(last->e_value_offs);\n\t\t\tif (offs < *min_offs)\n\t\t\t\t*min_offs = offs;\n\t\t}\n\t\tif (total)\n\t\t\t*total += EXT4_XATTR_LEN(last->e_name_len);\n\t}\n\treturn (*min_offs - ((void *)last - base) - sizeof(__u32));\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);\n\nstatic size_t ext4_xattr_free_space(struct ext4_xattr_entry *last,\n\t\t\t\t    size_t *min_offs, void *base, int *total)\n{\n\tfor (; !IS_LAST_ENTRY(last); last = EXT4_XATTR_NEXT(last)) {\n\t\tif (!last->e_value_block && last->e_value_size) {\n\t\t\tsize_t offs = le16_to_cpu(last->e_value_offs);\n\t\t\tif (offs < *min_offs)\n\t\t\t\t*min_offs = offs;\n\t\t}\n\t\tif (total)\n\t\t\t*total += EXT4_XATTR_LEN(last->e_name_len);\n\t}\n\treturn (*min_offs - ((void *)last - base) - sizeof(__u32));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BFIRST",
          "args": [
            "bh"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BHDR",
          "args": [
            "bh"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_ERROR_INODE",
          "args": [
            "inode",
            "\"bad block %llu\"",
            "EXT4_I(inode)->i_file_acl"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_xattr_check_block",
          "args": [
            "inode",
            "bh"
          ],
          "line": 1316
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_check_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "216-234",
          "snippet": "static inline int\next4_xattr_check_block(struct inode *inode, struct buffer_head *bh)\n{\n\tint error;\n\n\tif (buffer_verified(bh))\n\t\treturn 0;\n\n\tif (BHDR(bh)->h_magic != cpu_to_le32(EXT4_XATTR_MAGIC) ||\n\t    BHDR(bh)->h_blocks != cpu_to_le32(1))\n\t\treturn -EIO;\n\tif (!ext4_xattr_block_csum_verify(inode, bh->b_blocknr, BHDR(bh)))\n\t\treturn -EIO;\n\terror = ext4_xattr_check_names(BFIRST(bh), bh->b_data + bh->b_size,\n\t\t\t\t       bh->b_data);\n\tif (!error)\n\t\tset_buffer_verified(bh);\n\treturn error;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);\n\nstatic inline int\next4_xattr_check_block(struct inode *inode, struct buffer_head *bh)\n{\n\tint error;\n\n\tif (buffer_verified(bh))\n\t\treturn 0;\n\n\tif (BHDR(bh)->h_magic != cpu_to_le32(EXT4_XATTR_MAGIC) ||\n\t    BHDR(bh)->h_blocks != cpu_to_le32(1))\n\t\treturn -EIO;\n\tif (!ext4_xattr_block_csum_verify(inode, bh->b_blocknr, BHDR(bh)))\n\t\treturn -EIO;\n\terror = ext4_xattr_check_names(BFIRST(bh), bh->b_data + bh->b_size,\n\t\t\t\t       bh->b_data);\n\tif (!error)\n\t\tset_buffer_verified(bh);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "inode->i_sb",
            "EXT4_I(inode)->i_file_acl"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFIRST",
          "args": [
            "header"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1289
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IFIRST",
          "args": [
            "header"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IHDR",
          "args": [
            "inode",
            "raw_inode"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&EXT4_I(inode)->xattr_sem"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&EXT4_I(inode)->xattr_sem"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);\nstatic void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);\n\nint ext4_expand_extra_isize_ea(struct inode *inode, int new_extra_isize,\n\t\t\t       struct ext4_inode *raw_inode, handle_t *handle)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_xattr_entry *entry, *last, *first;\n\tstruct buffer_head *bh = NULL;\n\tstruct ext4_xattr_ibody_find *is = NULL;\n\tstruct ext4_xattr_block_find *bs = NULL;\n\tchar *buffer = NULL, *b_entry_name = NULL;\n\tsize_t min_offs, free;\n\tint total_ino;\n\tvoid *base, *start, *end;\n\tint extra_isize = 0, error = 0, tried_min_extra_isize = 0;\n\tint s_min_extra_isize = le16_to_cpu(EXT4_SB(inode->i_sb)->s_es->s_min_extra_isize);\n\n\tdown_write(&EXT4_I(inode)->xattr_sem);\nretry:\n\tif (EXT4_I(inode)->i_extra_isize >= new_extra_isize) {\n\t\tup_write(&EXT4_I(inode)->xattr_sem);\n\t\treturn 0;\n\t}\n\n\theader = IHDR(inode, raw_inode);\n\tentry = IFIRST(header);\n\n\t/*\n\t * Check if enough free space is available in the inode to shift the\n\t * entries ahead by new_extra_isize.\n\t */\n\n\tbase = start = entry;\n\tend = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;\n\tmin_offs = end - base;\n\tlast = entry;\n\ttotal_ino = sizeof(struct ext4_xattr_ibody_header);\n\n\tfree = ext4_xattr_free_space(last, &min_offs, base, &total_ino);\n\tif (free >= new_extra_isize) {\n\t\tentry = IFIRST(header);\n\t\text4_xattr_shift_entries(entry,\tEXT4_I(inode)->i_extra_isize\n\t\t\t\t- new_extra_isize, (void *)raw_inode +\n\t\t\t\tEXT4_GOOD_OLD_INODE_SIZE + new_extra_isize,\n\t\t\t\t(void *)header, total_ino,\n\t\t\t\tinode->i_sb->s_blocksize);\n\t\tEXT4_I(inode)->i_extra_isize = new_extra_isize;\n\t\terror = 0;\n\t\tgoto cleanup;\n\t}\n\n\t/*\n\t * Enough free space isn't available in the inode, check if\n\t * EA block can hold new_extra_isize bytes.\n\t */\n\tif (EXT4_I(inode)->i_file_acl) {\n\t\tbh = sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tif (!bh)\n\t\t\tgoto cleanup;\n\t\tif (ext4_xattr_check_block(inode, bh)) {\n\t\t\tEXT4_ERROR_INODE(inode, \"bad block %llu\",\n\t\t\t\t\t EXT4_I(inode)->i_file_acl);\n\t\t\terror = -EIO;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tbase = BHDR(bh);\n\t\tfirst = BFIRST(bh);\n\t\tend = bh->b_data + bh->b_size;\n\t\tmin_offs = end - base;\n\t\tfree = ext4_xattr_free_space(first, &min_offs, base, NULL);\n\t\tif (free < new_extra_isize) {\n\t\t\tif (!tried_min_extra_isize && s_min_extra_isize) {\n\t\t\t\ttried_min_extra_isize++;\n\t\t\t\tnew_extra_isize = s_min_extra_isize;\n\t\t\t\tbrelse(bh);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\terror = -1;\n\t\t\tgoto cleanup;\n\t\t}\n\t} else {\n\t\tfree = inode->i_sb->s_blocksize;\n\t}\n\n\twhile (new_extra_isize > 0) {\n\t\tsize_t offs, size, entry_size;\n\t\tstruct ext4_xattr_entry *small_entry = NULL;\n\t\tstruct ext4_xattr_info i = {\n\t\t\t.value = NULL,\n\t\t\t.value_len = 0,\n\t\t};\n\t\tunsigned int total_size;  /* EA entry size + value size */\n\t\tunsigned int shift_bytes; /* No. of bytes to shift EAs by? */\n\t\tunsigned int min_total_size = ~0U;\n\n\t\tis = kzalloc(sizeof(struct ext4_xattr_ibody_find), GFP_NOFS);\n\t\tbs = kzalloc(sizeof(struct ext4_xattr_block_find), GFP_NOFS);\n\t\tif (!is || !bs) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tis->s.not_found = -ENODATA;\n\t\tbs->s.not_found = -ENODATA;\n\t\tis->iloc.bh = NULL;\n\t\tbs->bh = NULL;\n\n\t\tlast = IFIRST(header);\n\t\t/* Find the entry best suited to be pushed into EA block */\n\t\tentry = NULL;\n\t\tfor (; !IS_LAST_ENTRY(last); last = EXT4_XATTR_NEXT(last)) {\n\t\t\ttotal_size =\n\t\t\tEXT4_XATTR_SIZE(le32_to_cpu(last->e_value_size)) +\n\t\t\t\t\tEXT4_XATTR_LEN(last->e_name_len);\n\t\t\tif (total_size <= free && total_size < min_total_size) {\n\t\t\t\tif (total_size < new_extra_isize) {\n\t\t\t\t\tsmall_entry = last;\n\t\t\t\t} else {\n\t\t\t\t\tentry = last;\n\t\t\t\t\tmin_total_size = total_size;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (entry == NULL) {\n\t\t\tif (small_entry) {\n\t\t\t\tentry = small_entry;\n\t\t\t} else {\n\t\t\t\tif (!tried_min_extra_isize &&\n\t\t\t\t    s_min_extra_isize) {\n\t\t\t\t\ttried_min_extra_isize++;\n\t\t\t\t\tnew_extra_isize = s_min_extra_isize;\n\t\t\t\t\tkfree(is); is = NULL;\n\t\t\t\t\tkfree(bs); bs = NULL;\n\t\t\t\t\tbrelse(bh);\n\t\t\t\t\tgoto retry;\n\t\t\t\t}\n\t\t\t\terror = -1;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\t\toffs = le16_to_cpu(entry->e_value_offs);\n\t\tsize = le32_to_cpu(entry->e_value_size);\n\t\tentry_size = EXT4_XATTR_LEN(entry->e_name_len);\n\t\ti.name_index = entry->e_name_index,\n\t\tbuffer = kmalloc(EXT4_XATTR_SIZE(size), GFP_NOFS);\n\t\tb_entry_name = kmalloc(entry->e_name_len + 1, GFP_NOFS);\n\t\tif (!buffer || !b_entry_name) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto cleanup;\n\t\t}\n\t\t/* Save the entry name and the entry value */\n\t\tmemcpy(buffer, (void *)IFIRST(header) + offs,\n\t\t       EXT4_XATTR_SIZE(size));\n\t\tmemcpy(b_entry_name, entry->e_name, entry->e_name_len);\n\t\tb_entry_name[entry->e_name_len] = '\\0';\n\t\ti.name = b_entry_name;\n\n\t\terror = ext4_get_inode_loc(inode, &is->iloc);\n\t\tif (error)\n\t\t\tgoto cleanup;\n\n\t\terror = ext4_xattr_ibody_find(inode, &i, is);\n\t\tif (error)\n\t\t\tgoto cleanup;\n\n\t\t/* Remove the chosen entry from the inode */\n\t\terror = ext4_xattr_ibody_set(handle, inode, &i, is);\n\t\tif (error)\n\t\t\tgoto cleanup;\n\n\t\tentry = IFIRST(header);\n\t\tif (entry_size + EXT4_XATTR_SIZE(size) >= new_extra_isize)\n\t\t\tshift_bytes = new_extra_isize;\n\t\telse\n\t\t\tshift_bytes = entry_size + size;\n\t\t/* Adjust the offsets and shift the remaining entries ahead */\n\t\text4_xattr_shift_entries(entry, EXT4_I(inode)->i_extra_isize -\n\t\t\tshift_bytes, (void *)raw_inode +\n\t\t\tEXT4_GOOD_OLD_INODE_SIZE + extra_isize + shift_bytes,\n\t\t\t(void *)header, total_ino - entry_size,\n\t\t\tinode->i_sb->s_blocksize);\n\n\t\textra_isize += shift_bytes;\n\t\tnew_extra_isize -= shift_bytes;\n\t\tEXT4_I(inode)->i_extra_isize = extra_isize;\n\n\t\ti.name = b_entry_name;\n\t\ti.value = buffer;\n\t\ti.value_len = size;\n\t\terror = ext4_xattr_block_find(inode, &i, bs);\n\t\tif (error)\n\t\t\tgoto cleanup;\n\n\t\t/* Add entry which was removed from the inode into the block */\n\t\terror = ext4_xattr_block_set(handle, inode, &i, bs);\n\t\tif (error)\n\t\t\tgoto cleanup;\n\t\tkfree(b_entry_name);\n\t\tkfree(buffer);\n\t\tb_entry_name = NULL;\n\t\tbuffer = NULL;\n\t\tbrelse(is->iloc.bh);\n\t\tkfree(is);\n\t\tkfree(bs);\n\t}\n\tbrelse(bh);\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\treturn 0;\n\ncleanup:\n\tkfree(b_entry_name);\n\tkfree(buffer);\n\tif (is)\n\t\tbrelse(is->iloc.bh);\n\tkfree(is);\n\tkfree(bs);\n\tbrelse(bh);\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\treturn error;\n}"
  },
  {
    "function_name": "ext4_xattr_shift_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
    "lines": "1233-1252",
    "snippet": "static void ext4_xattr_shift_entries(struct ext4_xattr_entry *entry,\n\t\t\t\t     int value_offs_shift, void *to,\n\t\t\t\t     void *from, size_t n, int blocksize)\n{\n\tstruct ext4_xattr_entry *last = entry;\n\tint new_offs;\n\n\t/* Adjust the value offsets of the entries */\n\tfor (; !IS_LAST_ENTRY(last); last = EXT4_XATTR_NEXT(last)) {\n\t\tif (!last->e_value_block && last->e_value_size) {\n\t\t\tnew_offs = le16_to_cpu(last->e_value_offs) +\n\t\t\t\t\t\t\tvalue_offs_shift;\n\t\t\tBUG_ON(new_offs + le32_to_cpu(last->e_value_size)\n\t\t\t\t > blocksize);\n\t\t\tlast->e_value_offs = cpu_to_le16(new_offs);\n\t\t}\n\t}\n\t/* Shift the entries by n bytes */\n\tmemmove(to, from, n);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "to",
            "from",
            "n"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "new_offs"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "new_offs + le32_to_cpu(last->e_value_size)\n\t\t\t\t > blocksize"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "last->e_value_size"
          ],
          "line": 1245
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "last->e_value_offs"
          ],
          "line": 1243
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_XATTR_NEXT",
          "args": [
            "last"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LAST_ENTRY",
          "args": [
            "last"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);\n\nstatic void ext4_xattr_shift_entries(struct ext4_xattr_entry *entry,\n\t\t\t\t     int value_offs_shift, void *to,\n\t\t\t\t     void *from, size_t n, int blocksize)\n{\n\tstruct ext4_xattr_entry *last = entry;\n\tint new_offs;\n\n\t/* Adjust the value offsets of the entries */\n\tfor (; !IS_LAST_ENTRY(last); last = EXT4_XATTR_NEXT(last)) {\n\t\tif (!last->e_value_block && last->e_value_size) {\n\t\t\tnew_offs = le16_to_cpu(last->e_value_offs) +\n\t\t\t\t\t\t\tvalue_offs_shift;\n\t\t\tBUG_ON(new_offs + le32_to_cpu(last->e_value_size)\n\t\t\t\t > blocksize);\n\t\t\tlast->e_value_offs = cpu_to_le16(new_offs);\n\t\t}\n\t}\n\t/* Shift the entries by n bytes */\n\tmemmove(to, from, n);\n}"
  },
  {
    "function_name": "ext4_xattr_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
    "lines": "1201-1227",
    "snippet": "int\next4_xattr_set(struct inode *inode, int name_index, const char *name,\n\t       const void *value, size_t value_len, int flags)\n{\n\thandle_t *handle;\n\tint error, retries = 0;\n\tint credits = ext4_jbd2_credits_xattr(inode);\n\nretry:\n\thandle = ext4_journal_start(inode, EXT4_HT_XATTR, credits);\n\tif (IS_ERR(handle)) {\n\t\terror = PTR_ERR(handle);\n\t} else {\n\t\tint error2;\n\n\t\terror = ext4_xattr_set_handle(handle, inode, name_index, name,\n\t\t\t\t\t      value, value_len, flags);\n\t\terror2 = ext4_journal_stop(handle);\n\t\tif (error == -ENOSPC &&\n\t\t    ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\t\tgoto retry;\n\t\tif (error == 0)\n\t\t\terror = error2;\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_should_retry_alloc",
          "args": [
            "inode->i_sb",
            "&retries"
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_should_retry_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "598-608",
          "snippet": "int ext4_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext4_has_free_clusters(EXT4_SB(sb), 1, 0) ||\n\t    (*retries)++ > 3 ||\n\t    !EXT4_SB(sb)->s_journal)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn jbd2_journal_force_commit_nested(EXT4_SB(sb)->s_journal);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nint ext4_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext4_has_free_clusters(EXT4_SB(sb), 1, 0) ||\n\t    (*retries)++ > 3 ||\n\t    !EXT4_SB(sb)->s_journal)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn jbd2_journal_force_commit_nested(EXT4_SB(sb)->s_journal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_xattr_set_handle",
          "args": [
            "handle",
            "inode",
            "name_index",
            "name",
            "value",
            "value_len",
            "flags"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_set_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "1085-1191",
          "snippet": "int\next4_xattr_set_handle(handle_t *handle, struct inode *inode, int name_index,\n\t\t      const char *name, const void *value, size_t value_len,\n\t\t      int flags)\n{\n\tstruct ext4_xattr_info i = {\n\t\t.name_index = name_index,\n\t\t.name = name,\n\t\t.value = value,\n\t\t.value_len = value_len,\n\n\t};\n\tstruct ext4_xattr_ibody_find is = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tstruct ext4_xattr_block_find bs = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tunsigned long no_expand;\n\tint error;\n\n\tif (!name)\n\t\treturn -EINVAL;\n\tif (strlen(name) > 255)\n\t\treturn -ERANGE;\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\tno_expand = ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND);\n\text4_set_inode_state(inode, EXT4_STATE_NO_EXPAND);\n\n\terror = ext4_reserve_inode_write(handle, inode, &is.iloc);\n\tif (error)\n\t\tgoto cleanup;\n\n\tif (ext4_test_inode_state(inode, EXT4_STATE_NEW)) {\n\t\tstruct ext4_inode *raw_inode = ext4_raw_inode(&is.iloc);\n\t\tmemset(raw_inode, 0, EXT4_SB(inode->i_sb)->s_inode_size);\n\t\text4_clear_inode_state(inode, EXT4_STATE_NEW);\n\t}\n\n\terror = ext4_xattr_ibody_find(inode, &i, &is);\n\tif (error)\n\t\tgoto cleanup;\n\tif (is.s.not_found)\n\t\terror = ext4_xattr_block_find(inode, &i, &bs);\n\tif (error)\n\t\tgoto cleanup;\n\tif (is.s.not_found && bs.s.not_found) {\n\t\terror = -ENODATA;\n\t\tif (flags & XATTR_REPLACE)\n\t\t\tgoto cleanup;\n\t\terror = 0;\n\t\tif (!value)\n\t\t\tgoto cleanup;\n\t} else {\n\t\terror = -EEXIST;\n\t\tif (flags & XATTR_CREATE)\n\t\t\tgoto cleanup;\n\t}\n\tif (!value) {\n\t\tif (!is.s.not_found)\n\t\t\terror = ext4_xattr_ibody_set(handle, inode, &i, &is);\n\t\telse if (!bs.s.not_found)\n\t\t\terror = ext4_xattr_block_set(handle, inode, &i, &bs);\n\t} else {\n\t\terror = ext4_xattr_ibody_set(handle, inode, &i, &is);\n\t\tif (!error && !bs.s.not_found) {\n\t\t\ti.value = NULL;\n\t\t\terror = ext4_xattr_block_set(handle, inode, &i, &bs);\n\t\t} else if (error == -ENOSPC) {\n\t\t\tif (EXT4_I(inode)->i_file_acl && !bs.s.base) {\n\t\t\t\terror = ext4_xattr_block_find(inode, &i, &bs);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\terror = ext4_xattr_block_set(handle, inode, &i, &bs);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t\tif (!is.s.not_found) {\n\t\t\t\ti.value = NULL;\n\t\t\t\terror = ext4_xattr_ibody_set(handle, inode, &i,\n\t\t\t\t\t\t\t     &is);\n\t\t\t}\n\t\t}\n\t}\n\tif (!error) {\n\t\text4_xattr_update_super_block(handle, inode->i_sb);\n\t\tinode->i_ctime = ext4_current_time(inode);\n\t\tif (!value)\n\t\t\text4_clear_inode_state(inode, EXT4_STATE_NO_EXPAND);\n\t\terror = ext4_mark_iloc_dirty(handle, inode, &is.iloc);\n\t\t/*\n\t\t * The bh is consumed by ext4_mark_iloc_dirty, even with\n\t\t * error != 0.\n\t\t */\n\t\tis.iloc.bh = NULL;\n\t\tif (IS_SYNC(inode))\n\t\t\text4_handle_sync(handle);\n\t}\n\ncleanup:\n\tbrelse(is.iloc.bh);\n\tbrelse(bs.bh);\n\tif (no_expand == 0)\n\t\text4_clear_inode_state(inode, EXT4_STATE_NO_EXPAND);\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\treturn error;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nint\next4_xattr_set_handle(handle_t *handle, struct inode *inode, int name_index,\n\t\t      const char *name, const void *value, size_t value_len,\n\t\t      int flags)\n{\n\tstruct ext4_xattr_info i = {\n\t\t.name_index = name_index,\n\t\t.name = name,\n\t\t.value = value,\n\t\t.value_len = value_len,\n\n\t};\n\tstruct ext4_xattr_ibody_find is = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tstruct ext4_xattr_block_find bs = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tunsigned long no_expand;\n\tint error;\n\n\tif (!name)\n\t\treturn -EINVAL;\n\tif (strlen(name) > 255)\n\t\treturn -ERANGE;\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\tno_expand = ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND);\n\text4_set_inode_state(inode, EXT4_STATE_NO_EXPAND);\n\n\terror = ext4_reserve_inode_write(handle, inode, &is.iloc);\n\tif (error)\n\t\tgoto cleanup;\n\n\tif (ext4_test_inode_state(inode, EXT4_STATE_NEW)) {\n\t\tstruct ext4_inode *raw_inode = ext4_raw_inode(&is.iloc);\n\t\tmemset(raw_inode, 0, EXT4_SB(inode->i_sb)->s_inode_size);\n\t\text4_clear_inode_state(inode, EXT4_STATE_NEW);\n\t}\n\n\terror = ext4_xattr_ibody_find(inode, &i, &is);\n\tif (error)\n\t\tgoto cleanup;\n\tif (is.s.not_found)\n\t\terror = ext4_xattr_block_find(inode, &i, &bs);\n\tif (error)\n\t\tgoto cleanup;\n\tif (is.s.not_found && bs.s.not_found) {\n\t\terror = -ENODATA;\n\t\tif (flags & XATTR_REPLACE)\n\t\t\tgoto cleanup;\n\t\terror = 0;\n\t\tif (!value)\n\t\t\tgoto cleanup;\n\t} else {\n\t\terror = -EEXIST;\n\t\tif (flags & XATTR_CREATE)\n\t\t\tgoto cleanup;\n\t}\n\tif (!value) {\n\t\tif (!is.s.not_found)\n\t\t\terror = ext4_xattr_ibody_set(handle, inode, &i, &is);\n\t\telse if (!bs.s.not_found)\n\t\t\terror = ext4_xattr_block_set(handle, inode, &i, &bs);\n\t} else {\n\t\terror = ext4_xattr_ibody_set(handle, inode, &i, &is);\n\t\tif (!error && !bs.s.not_found) {\n\t\t\ti.value = NULL;\n\t\t\terror = ext4_xattr_block_set(handle, inode, &i, &bs);\n\t\t} else if (error == -ENOSPC) {\n\t\t\tif (EXT4_I(inode)->i_file_acl && !bs.s.base) {\n\t\t\t\terror = ext4_xattr_block_find(inode, &i, &bs);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\terror = ext4_xattr_block_set(handle, inode, &i, &bs);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t\tif (!is.s.not_found) {\n\t\t\t\ti.value = NULL;\n\t\t\t\terror = ext4_xattr_ibody_set(handle, inode, &i,\n\t\t\t\t\t\t\t     &is);\n\t\t\t}\n\t\t}\n\t}\n\tif (!error) {\n\t\text4_xattr_update_super_block(handle, inode->i_sb);\n\t\tinode->i_ctime = ext4_current_time(inode);\n\t\tif (!value)\n\t\t\text4_clear_inode_state(inode, EXT4_STATE_NO_EXPAND);\n\t\terror = ext4_mark_iloc_dirty(handle, inode, &is.iloc);\n\t\t/*\n\t\t * The bh is consumed by ext4_mark_iloc_dirty, even with\n\t\t * error != 0.\n\t\t */\n\t\tis.iloc.bh = NULL;\n\t\tif (IS_SYNC(inode))\n\t\t\text4_handle_sync(handle);\n\t}\n\ncleanup:\n\tbrelse(is.iloc.bh);\n\tbrelse(bs.bh);\n\tif (no_expand == 0)\n\t\text4_clear_inode_state(inode, EXT4_STATE_NO_EXPAND);\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_start",
          "args": [
            "inode",
            "EXT4_HT_XATTR",
            "credits"
          ],
          "line": 1210
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_journal_start_reserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
          "lines": "101-123",
          "snippet": "handle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nhandle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_jbd2_credits_xattr",
          "args": [
            "inode"
          ],
          "line": 1207
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_jbd2_credits_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "109-120",
          "snippet": "static inline int ext4_jbd2_credits_xattr(struct inode *inode)\n{\n\tint credits = EXT4_DATA_TRANS_BLOCKS(inode->i_sb);\n\n\t/*\n\t * In case of inline data, we may push out the data to a block,\n\t * so we need to reserve credits for this eventuality\n\t */\n\tif (ext4_has_inline_data(inode))\n\t\tcredits += ext4_writepage_trans_blocks(inode) + 1;\n\treturn credits;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int ext4_jbd2_credits_xattr(struct inode *inode)\n{\n\tint credits = EXT4_DATA_TRANS_BLOCKS(inode->i_sb);\n\n\t/*\n\t * In case of inline data, we may push out the data to a block,\n\t * so we need to reserve credits for this eventuality\n\t */\n\tif (ext4_has_inline_data(inode))\n\t\tcredits += ext4_writepage_trans_blocks(inode) + 1;\n\treturn credits;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nint\next4_xattr_set(struct inode *inode, int name_index, const char *name,\n\t       const void *value, size_t value_len, int flags)\n{\n\thandle_t *handle;\n\tint error, retries = 0;\n\tint credits = ext4_jbd2_credits_xattr(inode);\n\nretry:\n\thandle = ext4_journal_start(inode, EXT4_HT_XATTR, credits);\n\tif (IS_ERR(handle)) {\n\t\terror = PTR_ERR(handle);\n\t} else {\n\t\tint error2;\n\n\t\terror = ext4_xattr_set_handle(handle, inode, name_index, name,\n\t\t\t\t\t      value, value_len, flags);\n\t\terror2 = ext4_journal_stop(handle);\n\t\tif (error == -ENOSPC &&\n\t\t    ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\t\tgoto retry;\n\t\tif (error == 0)\n\t\t\terror = error2;\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "ext4_xattr_set_handle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
    "lines": "1085-1191",
    "snippet": "int\next4_xattr_set_handle(handle_t *handle, struct inode *inode, int name_index,\n\t\t      const char *name, const void *value, size_t value_len,\n\t\t      int flags)\n{\n\tstruct ext4_xattr_info i = {\n\t\t.name_index = name_index,\n\t\t.name = name,\n\t\t.value = value,\n\t\t.value_len = value_len,\n\n\t};\n\tstruct ext4_xattr_ibody_find is = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tstruct ext4_xattr_block_find bs = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tunsigned long no_expand;\n\tint error;\n\n\tif (!name)\n\t\treturn -EINVAL;\n\tif (strlen(name) > 255)\n\t\treturn -ERANGE;\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\tno_expand = ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND);\n\text4_set_inode_state(inode, EXT4_STATE_NO_EXPAND);\n\n\terror = ext4_reserve_inode_write(handle, inode, &is.iloc);\n\tif (error)\n\t\tgoto cleanup;\n\n\tif (ext4_test_inode_state(inode, EXT4_STATE_NEW)) {\n\t\tstruct ext4_inode *raw_inode = ext4_raw_inode(&is.iloc);\n\t\tmemset(raw_inode, 0, EXT4_SB(inode->i_sb)->s_inode_size);\n\t\text4_clear_inode_state(inode, EXT4_STATE_NEW);\n\t}\n\n\terror = ext4_xattr_ibody_find(inode, &i, &is);\n\tif (error)\n\t\tgoto cleanup;\n\tif (is.s.not_found)\n\t\terror = ext4_xattr_block_find(inode, &i, &bs);\n\tif (error)\n\t\tgoto cleanup;\n\tif (is.s.not_found && bs.s.not_found) {\n\t\terror = -ENODATA;\n\t\tif (flags & XATTR_REPLACE)\n\t\t\tgoto cleanup;\n\t\terror = 0;\n\t\tif (!value)\n\t\t\tgoto cleanup;\n\t} else {\n\t\terror = -EEXIST;\n\t\tif (flags & XATTR_CREATE)\n\t\t\tgoto cleanup;\n\t}\n\tif (!value) {\n\t\tif (!is.s.not_found)\n\t\t\terror = ext4_xattr_ibody_set(handle, inode, &i, &is);\n\t\telse if (!bs.s.not_found)\n\t\t\terror = ext4_xattr_block_set(handle, inode, &i, &bs);\n\t} else {\n\t\terror = ext4_xattr_ibody_set(handle, inode, &i, &is);\n\t\tif (!error && !bs.s.not_found) {\n\t\t\ti.value = NULL;\n\t\t\terror = ext4_xattr_block_set(handle, inode, &i, &bs);\n\t\t} else if (error == -ENOSPC) {\n\t\t\tif (EXT4_I(inode)->i_file_acl && !bs.s.base) {\n\t\t\t\terror = ext4_xattr_block_find(inode, &i, &bs);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\terror = ext4_xattr_block_set(handle, inode, &i, &bs);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t\tif (!is.s.not_found) {\n\t\t\t\ti.value = NULL;\n\t\t\t\terror = ext4_xattr_ibody_set(handle, inode, &i,\n\t\t\t\t\t\t\t     &is);\n\t\t\t}\n\t\t}\n\t}\n\tif (!error) {\n\t\text4_xattr_update_super_block(handle, inode->i_sb);\n\t\tinode->i_ctime = ext4_current_time(inode);\n\t\tif (!value)\n\t\t\text4_clear_inode_state(inode, EXT4_STATE_NO_EXPAND);\n\t\terror = ext4_mark_iloc_dirty(handle, inode, &is.iloc);\n\t\t/*\n\t\t * The bh is consumed by ext4_mark_iloc_dirty, even with\n\t\t * error != 0.\n\t\t */\n\t\tis.iloc.bh = NULL;\n\t\tif (IS_SYNC(inode))\n\t\t\text4_handle_sync(handle);\n\t}\n\ncleanup:\n\tbrelse(is.iloc.bh);\n\tbrelse(bs.bh);\n\tif (no_expand == 0)\n\t\text4_clear_inode_state(inode, EXT4_STATE_NO_EXPAND);\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\treturn error;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&EXT4_I(inode)->xattr_sem"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_clear_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_NO_EXPAND"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bs.bh"
          ],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_handle_sync",
          "args": [
            "handle"
          ],
          "line": 1181
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "279-283",
          "snippet": "static inline void ext4_handle_sync(handle_t *handle)\n{\n\tif (ext4_handle_valid(handle))\n\t\thandle->h_sync = 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ext4_handle_sync(handle_t *handle)\n{\n\tif (ext4_handle_valid(handle))\n\t\thandle->h_sync = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_SYNC",
          "args": [
            "inode"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mark_iloc_dirty",
          "args": [
            "handle",
            "inode",
            "&is.iloc"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_iloc_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4800-4815",
          "snippet": "int ext4_mark_iloc_dirty(handle_t *handle,\n\t\t\t struct inode *inode, struct ext4_iloc *iloc)\n{\n\tint err = 0;\n\n\tif (IS_I_VERSION(inode))\n\t\tinode_inc_iversion(inode);\n\n\t/* the do_update_inode consumes one bh->b_count */\n\tget_bh(iloc->bh);\n\n\t/* ext4_do_update_inode() does jbd2_journal_dirty_metadata */\n\terr = ext4_do_update_inode(handle, inode, iloc);\n\tput_bh(iloc->bh);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nint ext4_mark_iloc_dirty(handle_t *handle,\n\t\t\t struct inode *inode, struct ext4_iloc *iloc)\n{\n\tint err = 0;\n\n\tif (IS_I_VERSION(inode))\n\t\tinode_inc_iversion(inode);\n\n\t/* the do_update_inode consumes one bh->b_count */\n\tget_bh(iloc->bh);\n\n\t/* ext4_do_update_inode() does jbd2_journal_dirty_metadata */\n\terr = ext4_do_update_inode(handle, inode, iloc);\n\tput_bh(iloc->bh);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_clear_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_NO_EXPAND"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_current_time",
          "args": [
            "inode"
          ],
          "line": 1171
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_current_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1365-1369",
          "snippet": "static inline struct timespec ext4_current_time(struct inode *inode)\n{\n\treturn (inode->i_sb->s_time_gran < NSEC_PER_SEC) ?\n\t\tcurrent_fs_time(inode->i_sb) : CURRENT_TIME_SEC;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct timespec ext4_current_time(struct inode *inode)\n{\n\treturn (inode->i_sb->s_time_gran < NSEC_PER_SEC) ?\n\t\tcurrent_fs_time(inode->i_sb) : CURRENT_TIME_SEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_xattr_update_super_block",
          "args": [
            "handle",
            "inode->i_sb"
          ],
          "line": 1170
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_update_super_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "526-537",
          "snippet": "static void ext4_xattr_update_super_block(handle_t *handle,\n\t\t\t\t\t  struct super_block *sb)\n{\n\tif (EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_EXT_ATTR))\n\t\treturn;\n\n\tBUFFER_TRACE(EXT4_SB(sb)->s_sbh, \"get_write_access\");\n\tif (ext4_journal_get_write_access(handle, EXT4_SB(sb)->s_sbh) == 0) {\n\t\tEXT4_SET_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_EXT_ATTR);\n\t\text4_handle_dirty_super(handle, sb);\n\t}\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_update_super_block(handle_t *handle,\n\t\t\t\t\t  struct super_block *sb)\n{\n\tif (EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_EXT_ATTR))\n\t\treturn;\n\n\tBUFFER_TRACE(EXT4_SB(sb)->s_sbh, \"get_write_access\");\n\tif (ext4_journal_get_write_access(handle, EXT4_SB(sb)->s_sbh) == 0) {\n\t\tEXT4_SET_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_EXT_ATTR);\n\t\text4_handle_dirty_super(handle, sb);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_xattr_ibody_set",
          "args": [
            "handle",
            "inode",
            "&i",
            "&is"
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_ibody_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "1049-1071",
          "snippet": "static int ext4_xattr_ibody_set(handle_t *handle, struct inode *inode,\n\t\t\t\tstruct ext4_xattr_info *i,\n\t\t\t\tstruct ext4_xattr_ibody_find *is)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_xattr_search *s = &is->s;\n\tint error;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn -ENOSPC;\n\terror = ext4_xattr_set_entry(i, s);\n\tif (error)\n\t\treturn error;\n\theader = IHDR(inode, ext4_raw_inode(&is->iloc));\n\tif (!IS_LAST_ENTRY(s->first)) {\n\t\theader->h_magic = cpu_to_le32(EXT4_XATTR_MAGIC);\n\t\text4_set_inode_state(inode, EXT4_STATE_XATTR);\n\t} else {\n\t\theader->h_magic = cpu_to_le32(0);\n\t\text4_clear_inode_state(inode, EXT4_STATE_XATTR);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic int ext4_xattr_ibody_set(handle_t *handle, struct inode *inode,\n\t\t\t\tstruct ext4_xattr_info *i,\n\t\t\t\tstruct ext4_xattr_ibody_find *is)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_xattr_search *s = &is->s;\n\tint error;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn -ENOSPC;\n\terror = ext4_xattr_set_entry(i, s);\n\tif (error)\n\t\treturn error;\n\theader = IHDR(inode, ext4_raw_inode(&is->iloc));\n\tif (!IS_LAST_ENTRY(s->first)) {\n\t\theader->h_magic = cpu_to_le32(EXT4_XATTR_MAGIC);\n\t\text4_set_inode_state(inode, EXT4_STATE_XATTR);\n\t} else {\n\t\theader->h_magic = cpu_to_le32(0);\n\t\text4_clear_inode_state(inode, EXT4_STATE_XATTR);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_xattr_block_set",
          "args": [
            "handle",
            "inode",
            "&i",
            "&bs"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_block_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "776-979",
          "snippet": "static int\next4_xattr_block_set(handle_t *handle, struct inode *inode,\n\t\t     struct ext4_xattr_info *i,\n\t\t     struct ext4_xattr_block_find *bs)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ext4_xattr_search *s = &bs->s;\n\tstruct mb_cache_entry *ce = NULL;\n\tint error = 0;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\n#define header(x) ((struct ext4_xattr_header *)(x))\n\n\tif (i->value && i->value_len > sb->s_blocksize)\n\t\treturn -ENOSPC;\n\tif (s->base) {\n\t\tce = mb_cache_entry_get(ext4_mb_cache, bs->bh->b_bdev,\n\t\t\t\t\tbs->bh->b_blocknr);\n\t\tBUFFER_TRACE(bs->bh, \"get_write_access\");\n\t\terror = ext4_journal_get_write_access(handle, bs->bh);\n\t\tif (error)\n\t\t\tgoto cleanup;\n\t\tlock_buffer(bs->bh);\n\n\t\tif (header(s->base)->h_refcount == cpu_to_le32(1)) {\n\t\t\tif (ce) {\n\t\t\t\tmb_cache_entry_free(ce);\n\t\t\t\tce = NULL;\n\t\t\t}\n\t\t\tea_bdebug(bs->bh, \"modifying in-place\");\n\t\t\terror = ext4_xattr_set_entry(i, s);\n\t\t\tif (!error) {\n\t\t\t\tif (!IS_LAST_ENTRY(s->first))\n\t\t\t\t\text4_xattr_rehash(header(s->base),\n\t\t\t\t\t\t\t  s->here);\n\t\t\t\text4_xattr_cache_insert(ext4_mb_cache,\n\t\t\t\t\tbs->bh);\n\t\t\t}\n\t\t\tunlock_buffer(bs->bh);\n\t\t\tif (error == -EIO)\n\t\t\t\tgoto bad_block;\n\t\t\tif (!error)\n\t\t\t\terror = ext4_handle_dirty_xattr_block(handle,\n\t\t\t\t\t\t\t\t      inode,\n\t\t\t\t\t\t\t\t      bs->bh);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t\tgoto inserted;\n\t\t} else {\n\t\t\tint offset = (char *)s->here - bs->bh->b_data;\n\n\t\t\tunlock_buffer(bs->bh);\n\t\t\tif (ce) {\n\t\t\t\tmb_cache_entry_release(ce);\n\t\t\t\tce = NULL;\n\t\t\t}\n\t\t\tea_bdebug(bs->bh, \"cloning\");\n\t\t\ts->base = kmalloc(bs->bh->b_size, GFP_NOFS);\n\t\t\terror = -ENOMEM;\n\t\t\tif (s->base == NULL)\n\t\t\t\tgoto cleanup;\n\t\t\tmemcpy(s->base, BHDR(bs->bh), bs->bh->b_size);\n\t\t\ts->first = ENTRY(header(s->base)+1);\n\t\t\theader(s->base)->h_refcount = cpu_to_le32(1);\n\t\t\ts->here = ENTRY(s->base + offset);\n\t\t\ts->end = s->base + bs->bh->b_size;\n\t\t}\n\t} else {\n\t\t/* Allocate a buffer where we construct the new block. */\n\t\ts->base = kzalloc(sb->s_blocksize, GFP_NOFS);\n\t\t/* assert(header == s->base) */\n\t\terror = -ENOMEM;\n\t\tif (s->base == NULL)\n\t\t\tgoto cleanup;\n\t\theader(s->base)->h_magic = cpu_to_le32(EXT4_XATTR_MAGIC);\n\t\theader(s->base)->h_blocks = cpu_to_le32(1);\n\t\theader(s->base)->h_refcount = cpu_to_le32(1);\n\t\ts->first = ENTRY(header(s->base)+1);\n\t\ts->here = ENTRY(header(s->base)+1);\n\t\ts->end = s->base + sb->s_blocksize;\n\t}\n\n\terror = ext4_xattr_set_entry(i, s);\n\tif (error == -EIO)\n\t\tgoto bad_block;\n\tif (error)\n\t\tgoto cleanup;\n\tif (!IS_LAST_ENTRY(s->first))\n\t\text4_xattr_rehash(header(s->base), s->here);\n\ninserted:\n\tif (!IS_LAST_ENTRY(s->first)) {\n\t\tnew_bh = ext4_xattr_cache_find(inode, header(s->base), &ce);\n\t\tif (new_bh) {\n\t\t\t/* We found an identical block in the cache. */\n\t\t\tif (new_bh == bs->bh)\n\t\t\t\tea_bdebug(new_bh, \"keeping\");\n\t\t\telse {\n\t\t\t\t/* The old block is released after updating\n\t\t\t\t   the inode. */\n\t\t\t\terror = dquot_alloc_block(inode,\n\t\t\t\t\t\tEXT4_C2B(EXT4_SB(sb), 1));\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup;\n\t\t\t\tBUFFER_TRACE(new_bh, \"get_write_access\");\n\t\t\t\terror = ext4_journal_get_write_access(handle,\n\t\t\t\t\t\t\t\t      new_bh);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup_dquot;\n\t\t\t\tlock_buffer(new_bh);\n\t\t\t\tle32_add_cpu(&BHDR(new_bh)->h_refcount, 1);\n\t\t\t\tea_bdebug(new_bh, \"reusing; refcount now=%d\",\n\t\t\t\t\tle32_to_cpu(BHDR(new_bh)->h_refcount));\n\t\t\t\tunlock_buffer(new_bh);\n\t\t\t\terror = ext4_handle_dirty_xattr_block(handle,\n\t\t\t\t\t\t\t\t      inode,\n\t\t\t\t\t\t\t\t      new_bh);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup_dquot;\n\t\t\t}\n\t\t\tmb_cache_entry_release(ce);\n\t\t\tce = NULL;\n\t\t} else if (bs->bh && s->base == bs->bh->b_data) {\n\t\t\t/* We were modifying this block in-place. */\n\t\t\tea_bdebug(bs->bh, \"keeping this block\");\n\t\t\tnew_bh = bs->bh;\n\t\t\tget_bh(new_bh);\n\t\t} else {\n\t\t\t/* We need to allocate a new block */\n\t\t\text4_fsblk_t goal, block;\n\n\t\t\tgoal = ext4_group_first_block_no(sb,\n\t\t\t\t\t\tEXT4_I(inode)->i_block_group);\n\n\t\t\t/* non-extent files can't have physical blocks past 2^32 */\n\t\t\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\t\t\tgoal = goal & EXT4_MAX_BLOCK_FILE_PHYS;\n\n\t\t\tblock = ext4_new_meta_blocks(handle, inode, goal, 0,\n\t\t\t\t\t\t     NULL, &error);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\n\t\t\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\t\t\tBUG_ON(block > EXT4_MAX_BLOCK_FILE_PHYS);\n\n\t\t\tea_idebug(inode, \"creating block %llu\",\n\t\t\t\t  (unsigned long long)block);\n\n\t\t\tnew_bh = sb_getblk(sb, block);\n\t\t\tif (unlikely(!new_bh)) {\n\t\t\t\terror = -ENOMEM;\ngetblk_failed:\n\t\t\t\text4_free_blocks(handle, inode, NULL, block, 1,\n\t\t\t\t\t\t EXT4_FREE_BLOCKS_METADATA);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tlock_buffer(new_bh);\n\t\t\terror = ext4_journal_get_create_access(handle, new_bh);\n\t\t\tif (error) {\n\t\t\t\tunlock_buffer(new_bh);\n\t\t\t\terror = -EIO;\n\t\t\t\tgoto getblk_failed;\n\t\t\t}\n\t\t\tmemcpy(new_bh->b_data, s->base, new_bh->b_size);\n\t\t\tset_buffer_uptodate(new_bh);\n\t\t\tunlock_buffer(new_bh);\n\t\t\text4_xattr_cache_insert(ext4_mb_cache, new_bh);\n\t\t\terror = ext4_handle_dirty_xattr_block(handle,\n\t\t\t\t\t\t\t      inode, new_bh);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t/* Update the inode. */\n\tEXT4_I(inode)->i_file_acl = new_bh ? new_bh->b_blocknr : 0;\n\n\t/* Drop the previous xattr block. */\n\tif (bs->bh && bs->bh != new_bh)\n\t\text4_xattr_release_block(handle, inode, bs->bh);\n\terror = 0;\n\ncleanup:\n\tif (ce)\n\t\tmb_cache_entry_release(ce);\n\tbrelse(new_bh);\n\tif (!(bs->bh && s->base == bs->bh->b_data))\n\t\tkfree(s->base);\n\n\treturn error;\n\ncleanup_dquot:\n\tdquot_free_block(inode, EXT4_C2B(EXT4_SB(sb), 1));\n\tgoto cleanup;\n\nbad_block:\n\tEXT4_ERROR_INODE(inode, \"bad block %llu\",\n\t\t\t EXT4_I(inode)->i_file_acl);\n\tgoto cleanup;\n\n#undef header\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);",
            "static struct buffer_head *ext4_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext4_xattr_header *,\n\t\t\t\t\t\t struct mb_cache_entry **);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);\nstatic struct buffer_head *ext4_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext4_xattr_header *,\n\t\t\t\t\t\t struct mb_cache_entry **);\n\nstatic int\next4_xattr_block_set(handle_t *handle, struct inode *inode,\n\t\t     struct ext4_xattr_info *i,\n\t\t     struct ext4_xattr_block_find *bs)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ext4_xattr_search *s = &bs->s;\n\tstruct mb_cache_entry *ce = NULL;\n\tint error = 0;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\n#define header(x) ((struct ext4_xattr_header *)(x))\n\n\tif (i->value && i->value_len > sb->s_blocksize)\n\t\treturn -ENOSPC;\n\tif (s->base) {\n\t\tce = mb_cache_entry_get(ext4_mb_cache, bs->bh->b_bdev,\n\t\t\t\t\tbs->bh->b_blocknr);\n\t\tBUFFER_TRACE(bs->bh, \"get_write_access\");\n\t\terror = ext4_journal_get_write_access(handle, bs->bh);\n\t\tif (error)\n\t\t\tgoto cleanup;\n\t\tlock_buffer(bs->bh);\n\n\t\tif (header(s->base)->h_refcount == cpu_to_le32(1)) {\n\t\t\tif (ce) {\n\t\t\t\tmb_cache_entry_free(ce);\n\t\t\t\tce = NULL;\n\t\t\t}\n\t\t\tea_bdebug(bs->bh, \"modifying in-place\");\n\t\t\terror = ext4_xattr_set_entry(i, s);\n\t\t\tif (!error) {\n\t\t\t\tif (!IS_LAST_ENTRY(s->first))\n\t\t\t\t\text4_xattr_rehash(header(s->base),\n\t\t\t\t\t\t\t  s->here);\n\t\t\t\text4_xattr_cache_insert(ext4_mb_cache,\n\t\t\t\t\tbs->bh);\n\t\t\t}\n\t\t\tunlock_buffer(bs->bh);\n\t\t\tif (error == -EIO)\n\t\t\t\tgoto bad_block;\n\t\t\tif (!error)\n\t\t\t\terror = ext4_handle_dirty_xattr_block(handle,\n\t\t\t\t\t\t\t\t      inode,\n\t\t\t\t\t\t\t\t      bs->bh);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t\tgoto inserted;\n\t\t} else {\n\t\t\tint offset = (char *)s->here - bs->bh->b_data;\n\n\t\t\tunlock_buffer(bs->bh);\n\t\t\tif (ce) {\n\t\t\t\tmb_cache_entry_release(ce);\n\t\t\t\tce = NULL;\n\t\t\t}\n\t\t\tea_bdebug(bs->bh, \"cloning\");\n\t\t\ts->base = kmalloc(bs->bh->b_size, GFP_NOFS);\n\t\t\terror = -ENOMEM;\n\t\t\tif (s->base == NULL)\n\t\t\t\tgoto cleanup;\n\t\t\tmemcpy(s->base, BHDR(bs->bh), bs->bh->b_size);\n\t\t\ts->first = ENTRY(header(s->base)+1);\n\t\t\theader(s->base)->h_refcount = cpu_to_le32(1);\n\t\t\ts->here = ENTRY(s->base + offset);\n\t\t\ts->end = s->base + bs->bh->b_size;\n\t\t}\n\t} else {\n\t\t/* Allocate a buffer where we construct the new block. */\n\t\ts->base = kzalloc(sb->s_blocksize, GFP_NOFS);\n\t\t/* assert(header == s->base) */\n\t\terror = -ENOMEM;\n\t\tif (s->base == NULL)\n\t\t\tgoto cleanup;\n\t\theader(s->base)->h_magic = cpu_to_le32(EXT4_XATTR_MAGIC);\n\t\theader(s->base)->h_blocks = cpu_to_le32(1);\n\t\theader(s->base)->h_refcount = cpu_to_le32(1);\n\t\ts->first = ENTRY(header(s->base)+1);\n\t\ts->here = ENTRY(header(s->base)+1);\n\t\ts->end = s->base + sb->s_blocksize;\n\t}\n\n\terror = ext4_xattr_set_entry(i, s);\n\tif (error == -EIO)\n\t\tgoto bad_block;\n\tif (error)\n\t\tgoto cleanup;\n\tif (!IS_LAST_ENTRY(s->first))\n\t\text4_xattr_rehash(header(s->base), s->here);\n\ninserted:\n\tif (!IS_LAST_ENTRY(s->first)) {\n\t\tnew_bh = ext4_xattr_cache_find(inode, header(s->base), &ce);\n\t\tif (new_bh) {\n\t\t\t/* We found an identical block in the cache. */\n\t\t\tif (new_bh == bs->bh)\n\t\t\t\tea_bdebug(new_bh, \"keeping\");\n\t\t\telse {\n\t\t\t\t/* The old block is released after updating\n\t\t\t\t   the inode. */\n\t\t\t\terror = dquot_alloc_block(inode,\n\t\t\t\t\t\tEXT4_C2B(EXT4_SB(sb), 1));\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup;\n\t\t\t\tBUFFER_TRACE(new_bh, \"get_write_access\");\n\t\t\t\terror = ext4_journal_get_write_access(handle,\n\t\t\t\t\t\t\t\t      new_bh);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup_dquot;\n\t\t\t\tlock_buffer(new_bh);\n\t\t\t\tle32_add_cpu(&BHDR(new_bh)->h_refcount, 1);\n\t\t\t\tea_bdebug(new_bh, \"reusing; refcount now=%d\",\n\t\t\t\t\tle32_to_cpu(BHDR(new_bh)->h_refcount));\n\t\t\t\tunlock_buffer(new_bh);\n\t\t\t\terror = ext4_handle_dirty_xattr_block(handle,\n\t\t\t\t\t\t\t\t      inode,\n\t\t\t\t\t\t\t\t      new_bh);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup_dquot;\n\t\t\t}\n\t\t\tmb_cache_entry_release(ce);\n\t\t\tce = NULL;\n\t\t} else if (bs->bh && s->base == bs->bh->b_data) {\n\t\t\t/* We were modifying this block in-place. */\n\t\t\tea_bdebug(bs->bh, \"keeping this block\");\n\t\t\tnew_bh = bs->bh;\n\t\t\tget_bh(new_bh);\n\t\t} else {\n\t\t\t/* We need to allocate a new block */\n\t\t\text4_fsblk_t goal, block;\n\n\t\t\tgoal = ext4_group_first_block_no(sb,\n\t\t\t\t\t\tEXT4_I(inode)->i_block_group);\n\n\t\t\t/* non-extent files can't have physical blocks past 2^32 */\n\t\t\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\t\t\tgoal = goal & EXT4_MAX_BLOCK_FILE_PHYS;\n\n\t\t\tblock = ext4_new_meta_blocks(handle, inode, goal, 0,\n\t\t\t\t\t\t     NULL, &error);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\n\t\t\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\t\t\tBUG_ON(block > EXT4_MAX_BLOCK_FILE_PHYS);\n\n\t\t\tea_idebug(inode, \"creating block %llu\",\n\t\t\t\t  (unsigned long long)block);\n\n\t\t\tnew_bh = sb_getblk(sb, block);\n\t\t\tif (unlikely(!new_bh)) {\n\t\t\t\terror = -ENOMEM;\ngetblk_failed:\n\t\t\t\text4_free_blocks(handle, inode, NULL, block, 1,\n\t\t\t\t\t\t EXT4_FREE_BLOCKS_METADATA);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tlock_buffer(new_bh);\n\t\t\terror = ext4_journal_get_create_access(handle, new_bh);\n\t\t\tif (error) {\n\t\t\t\tunlock_buffer(new_bh);\n\t\t\t\terror = -EIO;\n\t\t\t\tgoto getblk_failed;\n\t\t\t}\n\t\t\tmemcpy(new_bh->b_data, s->base, new_bh->b_size);\n\t\t\tset_buffer_uptodate(new_bh);\n\t\t\tunlock_buffer(new_bh);\n\t\t\text4_xattr_cache_insert(ext4_mb_cache, new_bh);\n\t\t\terror = ext4_handle_dirty_xattr_block(handle,\n\t\t\t\t\t\t\t      inode, new_bh);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t/* Update the inode. */\n\tEXT4_I(inode)->i_file_acl = new_bh ? new_bh->b_blocknr : 0;\n\n\t/* Drop the previous xattr block. */\n\tif (bs->bh && bs->bh != new_bh)\n\t\text4_xattr_release_block(handle, inode, bs->bh);\n\terror = 0;\n\ncleanup:\n\tif (ce)\n\t\tmb_cache_entry_release(ce);\n\tbrelse(new_bh);\n\tif (!(bs->bh && s->base == bs->bh->b_data))\n\t\tkfree(s->base);\n\n\treturn error;\n\ncleanup_dquot:\n\tdquot_free_block(inode, EXT4_C2B(EXT4_SB(sb), 1));\n\tgoto cleanup;\n\nbad_block:\n\tEXT4_ERROR_INODE(inode, \"bad block %llu\",\n\t\t\t EXT4_I(inode)->i_file_acl);\n\tgoto cleanup;\n\n#undef header\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_xattr_block_find",
          "args": [
            "inode",
            "&i",
            "&bs"
          ],
          "line": 1155
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_block_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "734-774",
          "snippet": "static int\next4_xattr_block_find(struct inode *inode, struct ext4_xattr_info *i,\n\t\t      struct ext4_xattr_block_find *bs)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint error;\n\n\tea_idebug(inode, \"name=%d.%s, value=%p, value_len=%ld\",\n\t\t  i->name_index, i->name, i->value, (long)i->value_len);\n\n\tif (EXT4_I(inode)->i_file_acl) {\n\t\t/* The inode already has an extended attribute block. */\n\t\tbs->bh = sb_bread(sb, EXT4_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tif (!bs->bh)\n\t\t\tgoto cleanup;\n\t\tea_bdebug(bs->bh, \"b_count=%d, refcount=%d\",\n\t\t\tatomic_read(&(bs->bh->b_count)),\n\t\t\tle32_to_cpu(BHDR(bs->bh)->h_refcount));\n\t\tif (ext4_xattr_check_block(inode, bs->bh)) {\n\t\t\tEXT4_ERROR_INODE(inode, \"bad block %llu\",\n\t\t\t\t\t EXT4_I(inode)->i_file_acl);\n\t\t\terror = -EIO;\n\t\t\tgoto cleanup;\n\t\t}\n\t\t/* Find the named attribute. */\n\t\tbs->s.base = BHDR(bs->bh);\n\t\tbs->s.first = BFIRST(bs->bh);\n\t\tbs->s.end = bs->bh->b_data + bs->bh->b_size;\n\t\tbs->s.here = bs->s.first;\n\t\terror = ext4_xattr_find_entry(&bs->s.here, i->name_index,\n\t\t\t\t\t      i->name, bs->bh->b_size, 1);\n\t\tif (error && error != -ENODATA)\n\t\t\tgoto cleanup;\n\t\tbs->s.not_found = error;\n\t}\n\terror = 0;\n\ncleanup:\n\treturn error;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic int\next4_xattr_block_find(struct inode *inode, struct ext4_xattr_info *i,\n\t\t      struct ext4_xattr_block_find *bs)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint error;\n\n\tea_idebug(inode, \"name=%d.%s, value=%p, value_len=%ld\",\n\t\t  i->name_index, i->name, i->value, (long)i->value_len);\n\n\tif (EXT4_I(inode)->i_file_acl) {\n\t\t/* The inode already has an extended attribute block. */\n\t\tbs->bh = sb_bread(sb, EXT4_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tif (!bs->bh)\n\t\t\tgoto cleanup;\n\t\tea_bdebug(bs->bh, \"b_count=%d, refcount=%d\",\n\t\t\tatomic_read(&(bs->bh->b_count)),\n\t\t\tle32_to_cpu(BHDR(bs->bh)->h_refcount));\n\t\tif (ext4_xattr_check_block(inode, bs->bh)) {\n\t\t\tEXT4_ERROR_INODE(inode, \"bad block %llu\",\n\t\t\t\t\t EXT4_I(inode)->i_file_acl);\n\t\t\terror = -EIO;\n\t\t\tgoto cleanup;\n\t\t}\n\t\t/* Find the named attribute. */\n\t\tbs->s.base = BHDR(bs->bh);\n\t\tbs->s.first = BFIRST(bs->bh);\n\t\tbs->s.end = bs->bh->b_data + bs->bh->b_size;\n\t\tbs->s.here = bs->s.first;\n\t\terror = ext4_xattr_find_entry(&bs->s.here, i->name_index,\n\t\t\t\t\t      i->name, bs->bh->b_size, 1);\n\t\tif (error && error != -ENODATA)\n\t\t\tgoto cleanup;\n\t\tbs->s.not_found = error;\n\t}\n\terror = 0;\n\ncleanup:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_xattr_ibody_find",
          "args": [
            "inode",
            "&i",
            "&is"
          ],
          "line": 1124
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_ibody_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "981-1009",
          "snippet": "int ext4_xattr_ibody_find(struct inode *inode, struct ext4_xattr_info *i,\n\t\t\t  struct ext4_xattr_ibody_find *is)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_inode *raw_inode;\n\tint error;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn 0;\n\traw_inode = ext4_raw_inode(&is->iloc);\n\theader = IHDR(inode, raw_inode);\n\tis->s.base = is->s.first = IFIRST(header);\n\tis->s.here = is->s.first;\n\tis->s.end = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;\n\tif (ext4_test_inode_state(inode, EXT4_STATE_XATTR)) {\n\t\terror = ext4_xattr_check_names(IFIRST(header), is->s.end,\n\t\t\t\t\t       IFIRST(header));\n\t\tif (error)\n\t\t\treturn error;\n\t\t/* Find the named attribute. */\n\t\terror = ext4_xattr_find_entry(&is->s.here, i->name_index,\n\t\t\t\t\t      i->name, is->s.end -\n\t\t\t\t\t      (void *)is->s.base, 0);\n\t\tif (error && error != -ENODATA)\n\t\t\treturn error;\n\t\tis->s.not_found = error;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nint ext4_xattr_ibody_find(struct inode *inode, struct ext4_xattr_info *i,\n\t\t\t  struct ext4_xattr_ibody_find *is)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_inode *raw_inode;\n\tint error;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn 0;\n\traw_inode = ext4_raw_inode(&is->iloc);\n\theader = IHDR(inode, raw_inode);\n\tis->s.base = is->s.first = IFIRST(header);\n\tis->s.here = is->s.first;\n\tis->s.end = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;\n\tif (ext4_test_inode_state(inode, EXT4_STATE_XATTR)) {\n\t\terror = ext4_xattr_check_names(IFIRST(header), is->s.end,\n\t\t\t\t\t       IFIRST(header));\n\t\tif (error)\n\t\t\treturn error;\n\t\t/* Find the named attribute. */\n\t\terror = ext4_xattr_find_entry(&is->s.here, i->name_index,\n\t\t\t\t\t      i->name, is->s.end -\n\t\t\t\t\t      (void *)is->s.base, 0);\n\t\tif (error && error != -ENODATA)\n\t\t\treturn error;\n\t\tis->s.not_found = error;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_clear_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_NEW"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "raw_inode",
            "0",
            "EXT4_SB(inode->i_sb)->s_inode_size"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_raw_inode",
          "args": [
            "&is.iloc"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_raw_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1810-1813",
          "snippet": "static inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_NEW"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_reserve_inode_write",
          "args": [
            "handle",
            "inode",
            "&is.iloc"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_reserve_inode_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4822-4839",
          "snippet": "int\next4_reserve_inode_write(handle_t *handle, struct inode *inode,\n\t\t\t struct ext4_iloc *iloc)\n{\n\tint err;\n\n\terr = ext4_get_inode_loc(inode, iloc);\n\tif (!err) {\n\t\tBUFFER_TRACE(iloc->bh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, iloc->bh);\n\t\tif (err) {\n\t\t\tbrelse(iloc->bh);\n\t\t\tiloc->bh = NULL;\n\t\t}\n\t}\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\n\nint\next4_reserve_inode_write(handle_t *handle, struct inode *inode,\n\t\t\t struct ext4_iloc *iloc)\n{\n\tint err;\n\n\terr = ext4_get_inode_loc(inode, iloc);\n\tif (!err) {\n\t\tBUFFER_TRACE(iloc->bh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, iloc->bh);\n\t\tif (err) {\n\t\t\tbrelse(iloc->bh);\n\t\t\tiloc->bh = NULL;\n\t\t}\n\t}\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_set_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_NO_EXPAND"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_NO_EXPAND"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&EXT4_I(inode)->xattr_sem"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nint\next4_xattr_set_handle(handle_t *handle, struct inode *inode, int name_index,\n\t\t      const char *name, const void *value, size_t value_len,\n\t\t      int flags)\n{\n\tstruct ext4_xattr_info i = {\n\t\t.name_index = name_index,\n\t\t.name = name,\n\t\t.value = value,\n\t\t.value_len = value_len,\n\n\t};\n\tstruct ext4_xattr_ibody_find is = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tstruct ext4_xattr_block_find bs = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tunsigned long no_expand;\n\tint error;\n\n\tif (!name)\n\t\treturn -EINVAL;\n\tif (strlen(name) > 255)\n\t\treturn -ERANGE;\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\tno_expand = ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND);\n\text4_set_inode_state(inode, EXT4_STATE_NO_EXPAND);\n\n\terror = ext4_reserve_inode_write(handle, inode, &is.iloc);\n\tif (error)\n\t\tgoto cleanup;\n\n\tif (ext4_test_inode_state(inode, EXT4_STATE_NEW)) {\n\t\tstruct ext4_inode *raw_inode = ext4_raw_inode(&is.iloc);\n\t\tmemset(raw_inode, 0, EXT4_SB(inode->i_sb)->s_inode_size);\n\t\text4_clear_inode_state(inode, EXT4_STATE_NEW);\n\t}\n\n\terror = ext4_xattr_ibody_find(inode, &i, &is);\n\tif (error)\n\t\tgoto cleanup;\n\tif (is.s.not_found)\n\t\terror = ext4_xattr_block_find(inode, &i, &bs);\n\tif (error)\n\t\tgoto cleanup;\n\tif (is.s.not_found && bs.s.not_found) {\n\t\terror = -ENODATA;\n\t\tif (flags & XATTR_REPLACE)\n\t\t\tgoto cleanup;\n\t\terror = 0;\n\t\tif (!value)\n\t\t\tgoto cleanup;\n\t} else {\n\t\terror = -EEXIST;\n\t\tif (flags & XATTR_CREATE)\n\t\t\tgoto cleanup;\n\t}\n\tif (!value) {\n\t\tif (!is.s.not_found)\n\t\t\terror = ext4_xattr_ibody_set(handle, inode, &i, &is);\n\t\telse if (!bs.s.not_found)\n\t\t\terror = ext4_xattr_block_set(handle, inode, &i, &bs);\n\t} else {\n\t\terror = ext4_xattr_ibody_set(handle, inode, &i, &is);\n\t\tif (!error && !bs.s.not_found) {\n\t\t\ti.value = NULL;\n\t\t\terror = ext4_xattr_block_set(handle, inode, &i, &bs);\n\t\t} else if (error == -ENOSPC) {\n\t\t\tif (EXT4_I(inode)->i_file_acl && !bs.s.base) {\n\t\t\t\terror = ext4_xattr_block_find(inode, &i, &bs);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\terror = ext4_xattr_block_set(handle, inode, &i, &bs);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t\tif (!is.s.not_found) {\n\t\t\t\ti.value = NULL;\n\t\t\t\terror = ext4_xattr_ibody_set(handle, inode, &i,\n\t\t\t\t\t\t\t     &is);\n\t\t\t}\n\t\t}\n\t}\n\tif (!error) {\n\t\text4_xattr_update_super_block(handle, inode->i_sb);\n\t\tinode->i_ctime = ext4_current_time(inode);\n\t\tif (!value)\n\t\t\text4_clear_inode_state(inode, EXT4_STATE_NO_EXPAND);\n\t\terror = ext4_mark_iloc_dirty(handle, inode, &is.iloc);\n\t\t/*\n\t\t * The bh is consumed by ext4_mark_iloc_dirty, even with\n\t\t * error != 0.\n\t\t */\n\t\tis.iloc.bh = NULL;\n\t\tif (IS_SYNC(inode))\n\t\t\text4_handle_sync(handle);\n\t}\n\ncleanup:\n\tbrelse(is.iloc.bh);\n\tbrelse(bs.bh);\n\tif (no_expand == 0)\n\t\text4_clear_inode_state(inode, EXT4_STATE_NO_EXPAND);\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\treturn error;\n}"
  },
  {
    "function_name": "ext4_xattr_ibody_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
    "lines": "1049-1071",
    "snippet": "static int ext4_xattr_ibody_set(handle_t *handle, struct inode *inode,\n\t\t\t\tstruct ext4_xattr_info *i,\n\t\t\t\tstruct ext4_xattr_ibody_find *is)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_xattr_search *s = &is->s;\n\tint error;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn -ENOSPC;\n\terror = ext4_xattr_set_entry(i, s);\n\tif (error)\n\t\treturn error;\n\theader = IHDR(inode, ext4_raw_inode(&is->iloc));\n\tif (!IS_LAST_ENTRY(s->first)) {\n\t\theader->h_magic = cpu_to_le32(EXT4_XATTR_MAGIC);\n\t\text4_set_inode_state(inode, EXT4_STATE_XATTR);\n\t} else {\n\t\theader->h_magic = cpu_to_le32(0);\n\t\text4_clear_inode_state(inode, EXT4_STATE_XATTR);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_clear_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_XATTR"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "0"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_set_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_XATTR"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "EXT4_XATTR_MAGIC"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LAST_ENTRY",
          "args": [
            "s->first"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IHDR",
          "args": [
            "inode",
            "ext4_raw_inode(&is->iloc)"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_raw_inode",
          "args": [
            "&is->iloc"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_raw_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1810-1813",
          "snippet": "static inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_xattr_set_entry",
          "args": [
            "i",
            "s"
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_set_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "618-727",
          "snippet": "static int\next4_xattr_set_entry(struct ext4_xattr_info *i, struct ext4_xattr_search *s)\n{\n\tstruct ext4_xattr_entry *last;\n\tsize_t free, min_offs = s->end - s->base, name_len = strlen(i->name);\n\n\t/* Compute min_offs and last. */\n\tlast = s->first;\n\tfor (; !IS_LAST_ENTRY(last); last = EXT4_XATTR_NEXT(last)) {\n\t\tif (!last->e_value_block && last->e_value_size) {\n\t\t\tsize_t offs = le16_to_cpu(last->e_value_offs);\n\t\t\tif (offs < min_offs)\n\t\t\t\tmin_offs = offs;\n\t\t}\n\t}\n\tfree = min_offs - ((void *)last - s->base) - sizeof(__u32);\n\tif (!s->not_found) {\n\t\tif (!s->here->e_value_block && s->here->e_value_size) {\n\t\t\tsize_t size = le32_to_cpu(s->here->e_value_size);\n\t\t\tfree += EXT4_XATTR_SIZE(size);\n\t\t}\n\t\tfree += EXT4_XATTR_LEN(name_len);\n\t}\n\tif (i->value) {\n\t\tif (free < EXT4_XATTR_SIZE(i->value_len) ||\n\t\t    free < EXT4_XATTR_LEN(name_len) +\n\t\t\t   EXT4_XATTR_SIZE(i->value_len))\n\t\t\treturn -ENOSPC;\n\t}\n\n\tif (i->value && s->not_found) {\n\t\t/* Insert the new name. */\n\t\tsize_t size = EXT4_XATTR_LEN(name_len);\n\t\tsize_t rest = (void *)last - (void *)s->here + sizeof(__u32);\n\t\tmemmove((void *)s->here + size, s->here, rest);\n\t\tmemset(s->here, 0, size);\n\t\ts->here->e_name_index = i->name_index;\n\t\ts->here->e_name_len = name_len;\n\t\tmemcpy(s->here->e_name, i->name, name_len);\n\t} else {\n\t\tif (!s->here->e_value_block && s->here->e_value_size) {\n\t\t\tvoid *first_val = s->base + min_offs;\n\t\t\tsize_t offs = le16_to_cpu(s->here->e_value_offs);\n\t\t\tvoid *val = s->base + offs;\n\t\t\tsize_t size = EXT4_XATTR_SIZE(\n\t\t\t\tle32_to_cpu(s->here->e_value_size));\n\n\t\t\tif (i->value && size == EXT4_XATTR_SIZE(i->value_len)) {\n\t\t\t\t/* The old and the new value have the same\n\t\t\t\t   size. Just replace. */\n\t\t\t\ts->here->e_value_size =\n\t\t\t\t\tcpu_to_le32(i->value_len);\n\t\t\t\tif (i->value == EXT4_ZERO_XATTR_VALUE) {\n\t\t\t\t\tmemset(val, 0, size);\n\t\t\t\t} else {\n\t\t\t\t\t/* Clear pad bytes first. */\n\t\t\t\t\tmemset(val + size - EXT4_XATTR_PAD, 0,\n\t\t\t\t\t       EXT4_XATTR_PAD);\n\t\t\t\t\tmemcpy(val, i->value, i->value_len);\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* Remove the old value. */\n\t\t\tmemmove(first_val + size, first_val, val - first_val);\n\t\t\tmemset(first_val, 0, size);\n\t\t\ts->here->e_value_size = 0;\n\t\t\ts->here->e_value_offs = 0;\n\t\t\tmin_offs += size;\n\n\t\t\t/* Adjust all value offsets. */\n\t\t\tlast = s->first;\n\t\t\twhile (!IS_LAST_ENTRY(last)) {\n\t\t\t\tsize_t o = le16_to_cpu(last->e_value_offs);\n\t\t\t\tif (!last->e_value_block &&\n\t\t\t\t    last->e_value_size && o < offs)\n\t\t\t\t\tlast->e_value_offs =\n\t\t\t\t\t\tcpu_to_le16(o + size);\n\t\t\t\tlast = EXT4_XATTR_NEXT(last);\n\t\t\t}\n\t\t}\n\t\tif (!i->value) {\n\t\t\t/* Remove the old name. */\n\t\t\tsize_t size = EXT4_XATTR_LEN(name_len);\n\t\t\tlast = ENTRY((void *)last - size);\n\t\t\tmemmove(s->here, (void *)s->here + size,\n\t\t\t\t(void *)last - (void *)s->here + sizeof(__u32));\n\t\t\tmemset(last, 0, size);\n\t\t}\n\t}\n\n\tif (i->value) {\n\t\t/* Insert the new value. */\n\t\ts->here->e_value_size = cpu_to_le32(i->value_len);\n\t\tif (i->value_len) {\n\t\t\tsize_t size = EXT4_XATTR_SIZE(i->value_len);\n\t\t\tvoid *val = s->base + min_offs - size;\n\t\t\ts->here->e_value_offs = cpu_to_le16(min_offs - size);\n\t\t\tif (i->value == EXT4_ZERO_XATTR_VALUE) {\n\t\t\t\tmemset(val, 0, size);\n\t\t\t} else {\n\t\t\t\t/* Clear the pad bytes first. */\n\t\t\t\tmemset(val + size - EXT4_XATTR_PAD, 0,\n\t\t\t\t       EXT4_XATTR_PAD);\n\t\t\t\tmemcpy(val, i->value, i->value_len);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);\n\nstatic int\next4_xattr_set_entry(struct ext4_xattr_info *i, struct ext4_xattr_search *s)\n{\n\tstruct ext4_xattr_entry *last;\n\tsize_t free, min_offs = s->end - s->base, name_len = strlen(i->name);\n\n\t/* Compute min_offs and last. */\n\tlast = s->first;\n\tfor (; !IS_LAST_ENTRY(last); last = EXT4_XATTR_NEXT(last)) {\n\t\tif (!last->e_value_block && last->e_value_size) {\n\t\t\tsize_t offs = le16_to_cpu(last->e_value_offs);\n\t\t\tif (offs < min_offs)\n\t\t\t\tmin_offs = offs;\n\t\t}\n\t}\n\tfree = min_offs - ((void *)last - s->base) - sizeof(__u32);\n\tif (!s->not_found) {\n\t\tif (!s->here->e_value_block && s->here->e_value_size) {\n\t\t\tsize_t size = le32_to_cpu(s->here->e_value_size);\n\t\t\tfree += EXT4_XATTR_SIZE(size);\n\t\t}\n\t\tfree += EXT4_XATTR_LEN(name_len);\n\t}\n\tif (i->value) {\n\t\tif (free < EXT4_XATTR_SIZE(i->value_len) ||\n\t\t    free < EXT4_XATTR_LEN(name_len) +\n\t\t\t   EXT4_XATTR_SIZE(i->value_len))\n\t\t\treturn -ENOSPC;\n\t}\n\n\tif (i->value && s->not_found) {\n\t\t/* Insert the new name. */\n\t\tsize_t size = EXT4_XATTR_LEN(name_len);\n\t\tsize_t rest = (void *)last - (void *)s->here + sizeof(__u32);\n\t\tmemmove((void *)s->here + size, s->here, rest);\n\t\tmemset(s->here, 0, size);\n\t\ts->here->e_name_index = i->name_index;\n\t\ts->here->e_name_len = name_len;\n\t\tmemcpy(s->here->e_name, i->name, name_len);\n\t} else {\n\t\tif (!s->here->e_value_block && s->here->e_value_size) {\n\t\t\tvoid *first_val = s->base + min_offs;\n\t\t\tsize_t offs = le16_to_cpu(s->here->e_value_offs);\n\t\t\tvoid *val = s->base + offs;\n\t\t\tsize_t size = EXT4_XATTR_SIZE(\n\t\t\t\tle32_to_cpu(s->here->e_value_size));\n\n\t\t\tif (i->value && size == EXT4_XATTR_SIZE(i->value_len)) {\n\t\t\t\t/* The old and the new value have the same\n\t\t\t\t   size. Just replace. */\n\t\t\t\ts->here->e_value_size =\n\t\t\t\t\tcpu_to_le32(i->value_len);\n\t\t\t\tif (i->value == EXT4_ZERO_XATTR_VALUE) {\n\t\t\t\t\tmemset(val, 0, size);\n\t\t\t\t} else {\n\t\t\t\t\t/* Clear pad bytes first. */\n\t\t\t\t\tmemset(val + size - EXT4_XATTR_PAD, 0,\n\t\t\t\t\t       EXT4_XATTR_PAD);\n\t\t\t\t\tmemcpy(val, i->value, i->value_len);\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* Remove the old value. */\n\t\t\tmemmove(first_val + size, first_val, val - first_val);\n\t\t\tmemset(first_val, 0, size);\n\t\t\ts->here->e_value_size = 0;\n\t\t\ts->here->e_value_offs = 0;\n\t\t\tmin_offs += size;\n\n\t\t\t/* Adjust all value offsets. */\n\t\t\tlast = s->first;\n\t\t\twhile (!IS_LAST_ENTRY(last)) {\n\t\t\t\tsize_t o = le16_to_cpu(last->e_value_offs);\n\t\t\t\tif (!last->e_value_block &&\n\t\t\t\t    last->e_value_size && o < offs)\n\t\t\t\t\tlast->e_value_offs =\n\t\t\t\t\t\tcpu_to_le16(o + size);\n\t\t\t\tlast = EXT4_XATTR_NEXT(last);\n\t\t\t}\n\t\t}\n\t\tif (!i->value) {\n\t\t\t/* Remove the old name. */\n\t\t\tsize_t size = EXT4_XATTR_LEN(name_len);\n\t\t\tlast = ENTRY((void *)last - size);\n\t\t\tmemmove(s->here, (void *)s->here + size,\n\t\t\t\t(void *)last - (void *)s->here + sizeof(__u32));\n\t\t\tmemset(last, 0, size);\n\t\t}\n\t}\n\n\tif (i->value) {\n\t\t/* Insert the new value. */\n\t\ts->here->e_value_size = cpu_to_le32(i->value_len);\n\t\tif (i->value_len) {\n\t\t\tsize_t size = EXT4_XATTR_SIZE(i->value_len);\n\t\t\tvoid *val = s->base + min_offs - size;\n\t\t\ts->here->e_value_offs = cpu_to_le16(min_offs - size);\n\t\t\tif (i->value == EXT4_ZERO_XATTR_VALUE) {\n\t\t\t\tmemset(val, 0, size);\n\t\t\t} else {\n\t\t\t\t/* Clear the pad bytes first. */\n\t\t\t\tmemset(val + size - EXT4_XATTR_PAD, 0,\n\t\t\t\t       EXT4_XATTR_PAD);\n\t\t\t\tmemcpy(val, i->value, i->value_len);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic int ext4_xattr_ibody_set(handle_t *handle, struct inode *inode,\n\t\t\t\tstruct ext4_xattr_info *i,\n\t\t\t\tstruct ext4_xattr_ibody_find *is)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_xattr_search *s = &is->s;\n\tint error;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn -ENOSPC;\n\terror = ext4_xattr_set_entry(i, s);\n\tif (error)\n\t\treturn error;\n\theader = IHDR(inode, ext4_raw_inode(&is->iloc));\n\tif (!IS_LAST_ENTRY(s->first)) {\n\t\theader->h_magic = cpu_to_le32(EXT4_XATTR_MAGIC);\n\t\text4_set_inode_state(inode, EXT4_STATE_XATTR);\n\t} else {\n\t\theader->h_magic = cpu_to_le32(0);\n\t\text4_clear_inode_state(inode, EXT4_STATE_XATTR);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_xattr_ibody_inline_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
    "lines": "1011-1047",
    "snippet": "int ext4_xattr_ibody_inline_set(handle_t *handle, struct inode *inode,\n\t\t\t\tstruct ext4_xattr_info *i,\n\t\t\t\tstruct ext4_xattr_ibody_find *is)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_xattr_search *s = &is->s;\n\tint error;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn -ENOSPC;\n\terror = ext4_xattr_set_entry(i, s);\n\tif (error) {\n\t\tif (error == -ENOSPC &&\n\t\t    ext4_has_inline_data(inode)) {\n\t\t\terror = ext4_try_to_evict_inline_data(handle, inode,\n\t\t\t\t\tEXT4_XATTR_LEN(strlen(i->name) +\n\t\t\t\t\tEXT4_XATTR_SIZE(i->value_len)));\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\terror = ext4_xattr_ibody_find(inode, i, is);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\terror = ext4_xattr_set_entry(i, s);\n\t\t}\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\theader = IHDR(inode, ext4_raw_inode(&is->iloc));\n\tif (!IS_LAST_ENTRY(s->first)) {\n\t\theader->h_magic = cpu_to_le32(EXT4_XATTR_MAGIC);\n\t\text4_set_inode_state(inode, EXT4_STATE_XATTR);\n\t} else {\n\t\theader->h_magic = cpu_to_le32(0);\n\t\text4_clear_inode_state(inode, EXT4_STATE_XATTR);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_clear_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_XATTR"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "0"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_set_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_XATTR"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "EXT4_XATTR_MAGIC"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LAST_ENTRY",
          "args": [
            "s->first"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IHDR",
          "args": [
            "inode",
            "ext4_raw_inode(&is->iloc)"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_raw_inode",
          "args": [
            "&is->iloc"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_raw_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1810-1813",
          "snippet": "static inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_xattr_set_entry",
          "args": [
            "i",
            "s"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_set_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "618-727",
          "snippet": "static int\next4_xattr_set_entry(struct ext4_xattr_info *i, struct ext4_xattr_search *s)\n{\n\tstruct ext4_xattr_entry *last;\n\tsize_t free, min_offs = s->end - s->base, name_len = strlen(i->name);\n\n\t/* Compute min_offs and last. */\n\tlast = s->first;\n\tfor (; !IS_LAST_ENTRY(last); last = EXT4_XATTR_NEXT(last)) {\n\t\tif (!last->e_value_block && last->e_value_size) {\n\t\t\tsize_t offs = le16_to_cpu(last->e_value_offs);\n\t\t\tif (offs < min_offs)\n\t\t\t\tmin_offs = offs;\n\t\t}\n\t}\n\tfree = min_offs - ((void *)last - s->base) - sizeof(__u32);\n\tif (!s->not_found) {\n\t\tif (!s->here->e_value_block && s->here->e_value_size) {\n\t\t\tsize_t size = le32_to_cpu(s->here->e_value_size);\n\t\t\tfree += EXT4_XATTR_SIZE(size);\n\t\t}\n\t\tfree += EXT4_XATTR_LEN(name_len);\n\t}\n\tif (i->value) {\n\t\tif (free < EXT4_XATTR_SIZE(i->value_len) ||\n\t\t    free < EXT4_XATTR_LEN(name_len) +\n\t\t\t   EXT4_XATTR_SIZE(i->value_len))\n\t\t\treturn -ENOSPC;\n\t}\n\n\tif (i->value && s->not_found) {\n\t\t/* Insert the new name. */\n\t\tsize_t size = EXT4_XATTR_LEN(name_len);\n\t\tsize_t rest = (void *)last - (void *)s->here + sizeof(__u32);\n\t\tmemmove((void *)s->here + size, s->here, rest);\n\t\tmemset(s->here, 0, size);\n\t\ts->here->e_name_index = i->name_index;\n\t\ts->here->e_name_len = name_len;\n\t\tmemcpy(s->here->e_name, i->name, name_len);\n\t} else {\n\t\tif (!s->here->e_value_block && s->here->e_value_size) {\n\t\t\tvoid *first_val = s->base + min_offs;\n\t\t\tsize_t offs = le16_to_cpu(s->here->e_value_offs);\n\t\t\tvoid *val = s->base + offs;\n\t\t\tsize_t size = EXT4_XATTR_SIZE(\n\t\t\t\tle32_to_cpu(s->here->e_value_size));\n\n\t\t\tif (i->value && size == EXT4_XATTR_SIZE(i->value_len)) {\n\t\t\t\t/* The old and the new value have the same\n\t\t\t\t   size. Just replace. */\n\t\t\t\ts->here->e_value_size =\n\t\t\t\t\tcpu_to_le32(i->value_len);\n\t\t\t\tif (i->value == EXT4_ZERO_XATTR_VALUE) {\n\t\t\t\t\tmemset(val, 0, size);\n\t\t\t\t} else {\n\t\t\t\t\t/* Clear pad bytes first. */\n\t\t\t\t\tmemset(val + size - EXT4_XATTR_PAD, 0,\n\t\t\t\t\t       EXT4_XATTR_PAD);\n\t\t\t\t\tmemcpy(val, i->value, i->value_len);\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* Remove the old value. */\n\t\t\tmemmove(first_val + size, first_val, val - first_val);\n\t\t\tmemset(first_val, 0, size);\n\t\t\ts->here->e_value_size = 0;\n\t\t\ts->here->e_value_offs = 0;\n\t\t\tmin_offs += size;\n\n\t\t\t/* Adjust all value offsets. */\n\t\t\tlast = s->first;\n\t\t\twhile (!IS_LAST_ENTRY(last)) {\n\t\t\t\tsize_t o = le16_to_cpu(last->e_value_offs);\n\t\t\t\tif (!last->e_value_block &&\n\t\t\t\t    last->e_value_size && o < offs)\n\t\t\t\t\tlast->e_value_offs =\n\t\t\t\t\t\tcpu_to_le16(o + size);\n\t\t\t\tlast = EXT4_XATTR_NEXT(last);\n\t\t\t}\n\t\t}\n\t\tif (!i->value) {\n\t\t\t/* Remove the old name. */\n\t\t\tsize_t size = EXT4_XATTR_LEN(name_len);\n\t\t\tlast = ENTRY((void *)last - size);\n\t\t\tmemmove(s->here, (void *)s->here + size,\n\t\t\t\t(void *)last - (void *)s->here + sizeof(__u32));\n\t\t\tmemset(last, 0, size);\n\t\t}\n\t}\n\n\tif (i->value) {\n\t\t/* Insert the new value. */\n\t\ts->here->e_value_size = cpu_to_le32(i->value_len);\n\t\tif (i->value_len) {\n\t\t\tsize_t size = EXT4_XATTR_SIZE(i->value_len);\n\t\t\tvoid *val = s->base + min_offs - size;\n\t\t\ts->here->e_value_offs = cpu_to_le16(min_offs - size);\n\t\t\tif (i->value == EXT4_ZERO_XATTR_VALUE) {\n\t\t\t\tmemset(val, 0, size);\n\t\t\t} else {\n\t\t\t\t/* Clear the pad bytes first. */\n\t\t\t\tmemset(val + size - EXT4_XATTR_PAD, 0,\n\t\t\t\t       EXT4_XATTR_PAD);\n\t\t\t\tmemcpy(val, i->value, i->value_len);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);\n\nstatic int\next4_xattr_set_entry(struct ext4_xattr_info *i, struct ext4_xattr_search *s)\n{\n\tstruct ext4_xattr_entry *last;\n\tsize_t free, min_offs = s->end - s->base, name_len = strlen(i->name);\n\n\t/* Compute min_offs and last. */\n\tlast = s->first;\n\tfor (; !IS_LAST_ENTRY(last); last = EXT4_XATTR_NEXT(last)) {\n\t\tif (!last->e_value_block && last->e_value_size) {\n\t\t\tsize_t offs = le16_to_cpu(last->e_value_offs);\n\t\t\tif (offs < min_offs)\n\t\t\t\tmin_offs = offs;\n\t\t}\n\t}\n\tfree = min_offs - ((void *)last - s->base) - sizeof(__u32);\n\tif (!s->not_found) {\n\t\tif (!s->here->e_value_block && s->here->e_value_size) {\n\t\t\tsize_t size = le32_to_cpu(s->here->e_value_size);\n\t\t\tfree += EXT4_XATTR_SIZE(size);\n\t\t}\n\t\tfree += EXT4_XATTR_LEN(name_len);\n\t}\n\tif (i->value) {\n\t\tif (free < EXT4_XATTR_SIZE(i->value_len) ||\n\t\t    free < EXT4_XATTR_LEN(name_len) +\n\t\t\t   EXT4_XATTR_SIZE(i->value_len))\n\t\t\treturn -ENOSPC;\n\t}\n\n\tif (i->value && s->not_found) {\n\t\t/* Insert the new name. */\n\t\tsize_t size = EXT4_XATTR_LEN(name_len);\n\t\tsize_t rest = (void *)last - (void *)s->here + sizeof(__u32);\n\t\tmemmove((void *)s->here + size, s->here, rest);\n\t\tmemset(s->here, 0, size);\n\t\ts->here->e_name_index = i->name_index;\n\t\ts->here->e_name_len = name_len;\n\t\tmemcpy(s->here->e_name, i->name, name_len);\n\t} else {\n\t\tif (!s->here->e_value_block && s->here->e_value_size) {\n\t\t\tvoid *first_val = s->base + min_offs;\n\t\t\tsize_t offs = le16_to_cpu(s->here->e_value_offs);\n\t\t\tvoid *val = s->base + offs;\n\t\t\tsize_t size = EXT4_XATTR_SIZE(\n\t\t\t\tle32_to_cpu(s->here->e_value_size));\n\n\t\t\tif (i->value && size == EXT4_XATTR_SIZE(i->value_len)) {\n\t\t\t\t/* The old and the new value have the same\n\t\t\t\t   size. Just replace. */\n\t\t\t\ts->here->e_value_size =\n\t\t\t\t\tcpu_to_le32(i->value_len);\n\t\t\t\tif (i->value == EXT4_ZERO_XATTR_VALUE) {\n\t\t\t\t\tmemset(val, 0, size);\n\t\t\t\t} else {\n\t\t\t\t\t/* Clear pad bytes first. */\n\t\t\t\t\tmemset(val + size - EXT4_XATTR_PAD, 0,\n\t\t\t\t\t       EXT4_XATTR_PAD);\n\t\t\t\t\tmemcpy(val, i->value, i->value_len);\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* Remove the old value. */\n\t\t\tmemmove(first_val + size, first_val, val - first_val);\n\t\t\tmemset(first_val, 0, size);\n\t\t\ts->here->e_value_size = 0;\n\t\t\ts->here->e_value_offs = 0;\n\t\t\tmin_offs += size;\n\n\t\t\t/* Adjust all value offsets. */\n\t\t\tlast = s->first;\n\t\t\twhile (!IS_LAST_ENTRY(last)) {\n\t\t\t\tsize_t o = le16_to_cpu(last->e_value_offs);\n\t\t\t\tif (!last->e_value_block &&\n\t\t\t\t    last->e_value_size && o < offs)\n\t\t\t\t\tlast->e_value_offs =\n\t\t\t\t\t\tcpu_to_le16(o + size);\n\t\t\t\tlast = EXT4_XATTR_NEXT(last);\n\t\t\t}\n\t\t}\n\t\tif (!i->value) {\n\t\t\t/* Remove the old name. */\n\t\t\tsize_t size = EXT4_XATTR_LEN(name_len);\n\t\t\tlast = ENTRY((void *)last - size);\n\t\t\tmemmove(s->here, (void *)s->here + size,\n\t\t\t\t(void *)last - (void *)s->here + sizeof(__u32));\n\t\t\tmemset(last, 0, size);\n\t\t}\n\t}\n\n\tif (i->value) {\n\t\t/* Insert the new value. */\n\t\ts->here->e_value_size = cpu_to_le32(i->value_len);\n\t\tif (i->value_len) {\n\t\t\tsize_t size = EXT4_XATTR_SIZE(i->value_len);\n\t\t\tvoid *val = s->base + min_offs - size;\n\t\t\ts->here->e_value_offs = cpu_to_le16(min_offs - size);\n\t\t\tif (i->value == EXT4_ZERO_XATTR_VALUE) {\n\t\t\t\tmemset(val, 0, size);\n\t\t\t} else {\n\t\t\t\t/* Clear the pad bytes first. */\n\t\t\t\tmemset(val + size - EXT4_XATTR_PAD, 0,\n\t\t\t\t       EXT4_XATTR_PAD);\n\t\t\t\tmemcpy(val, i->value, i->value_len);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_xattr_ibody_find",
          "args": [
            "inode",
            "i",
            "is"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_ibody_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "981-1009",
          "snippet": "int ext4_xattr_ibody_find(struct inode *inode, struct ext4_xattr_info *i,\n\t\t\t  struct ext4_xattr_ibody_find *is)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_inode *raw_inode;\n\tint error;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn 0;\n\traw_inode = ext4_raw_inode(&is->iloc);\n\theader = IHDR(inode, raw_inode);\n\tis->s.base = is->s.first = IFIRST(header);\n\tis->s.here = is->s.first;\n\tis->s.end = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;\n\tif (ext4_test_inode_state(inode, EXT4_STATE_XATTR)) {\n\t\terror = ext4_xattr_check_names(IFIRST(header), is->s.end,\n\t\t\t\t\t       IFIRST(header));\n\t\tif (error)\n\t\t\treturn error;\n\t\t/* Find the named attribute. */\n\t\terror = ext4_xattr_find_entry(&is->s.here, i->name_index,\n\t\t\t\t\t      i->name, is->s.end -\n\t\t\t\t\t      (void *)is->s.base, 0);\n\t\tif (error && error != -ENODATA)\n\t\t\treturn error;\n\t\tis->s.not_found = error;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nint ext4_xattr_ibody_find(struct inode *inode, struct ext4_xattr_info *i,\n\t\t\t  struct ext4_xattr_ibody_find *is)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_inode *raw_inode;\n\tint error;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn 0;\n\traw_inode = ext4_raw_inode(&is->iloc);\n\theader = IHDR(inode, raw_inode);\n\tis->s.base = is->s.first = IFIRST(header);\n\tis->s.here = is->s.first;\n\tis->s.end = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;\n\tif (ext4_test_inode_state(inode, EXT4_STATE_XATTR)) {\n\t\terror = ext4_xattr_check_names(IFIRST(header), is->s.end,\n\t\t\t\t\t       IFIRST(header));\n\t\tif (error)\n\t\t\treturn error;\n\t\t/* Find the named attribute. */\n\t\terror = ext4_xattr_find_entry(&is->s.here, i->name_index,\n\t\t\t\t\t      i->name, is->s.end -\n\t\t\t\t\t      (void *)is->s.base, 0);\n\t\tif (error && error != -ENODATA)\n\t\t\treturn error;\n\t\tis->s.not_found = error;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_try_to_evict_inline_data",
          "args": [
            "handle",
            "inode",
            "EXT4_XATTR_LEN(strlen(i->name) +\n\t\t\t\t\tEXT4_XATTR_SIZE(i->value_len))"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_try_to_evict_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inline.c",
          "lines": "1861-1887",
          "snippet": "int ext4_try_to_evict_inline_data(handle_t *handle,\n\t\t\t\t  struct inode *inode,\n\t\t\t\t  int needed)\n{\n\tint error;\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_inode *raw_inode;\n\tstruct ext4_iloc iloc;\n\n\terror = ext4_get_inode_loc(inode, &iloc);\n\tif (error)\n\t\treturn error;\n\n\traw_inode = ext4_raw_inode(&iloc);\n\tentry = (struct ext4_xattr_entry *)((void *)raw_inode +\n\t\t\t\t\t    EXT4_I(inode)->i_inline_off);\n\tif (EXT4_XATTR_LEN(entry->e_name_len) +\n\t    EXT4_XATTR_SIZE(le32_to_cpu(entry->e_value_size)) < needed) {\n\t\terror = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\terror = ext4_convert_inline_data_nolock(handle, inode, &iloc);\nout:\n\tbrelse(iloc.bh);\n\treturn error;\n}",
          "includes": [
            "#include <linux/fiemap.h>",
            "#include \"truncate.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fiemap.h>\n#include \"truncate.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n\nint ext4_try_to_evict_inline_data(handle_t *handle,\n\t\t\t\t  struct inode *inode,\n\t\t\t\t  int needed)\n{\n\tint error;\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_inode *raw_inode;\n\tstruct ext4_iloc iloc;\n\n\terror = ext4_get_inode_loc(inode, &iloc);\n\tif (error)\n\t\treturn error;\n\n\traw_inode = ext4_raw_inode(&iloc);\n\tentry = (struct ext4_xattr_entry *)((void *)raw_inode +\n\t\t\t\t\t    EXT4_I(inode)->i_inline_off);\n\tif (EXT4_XATTR_LEN(entry->e_name_len) +\n\t    EXT4_XATTR_SIZE(le32_to_cpu(entry->e_value_size)) < needed) {\n\t\terror = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\terror = ext4_convert_inline_data_nolock(handle, inode, &iloc);\nout:\n\tbrelse(iloc.bh);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_XATTR_LEN",
          "args": [
            "strlen(i->name) +\n\t\t\t\t\tEXT4_XATTR_SIZE(i->value_len)"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_XATTR_SIZE",
          "args": [
            "i->value_len"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "i->name"
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_has_inline_data",
          "args": [
            "inode"
          ],
          "line": 1024
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_has_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "2665-2669",
          "snippet": "static inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline int ext4_has_inline_data(struct inode *inode)\n{\n\treturn ext4_test_inode_flag(inode, EXT4_INODE_INLINE_DATA) &&\n\t       EXT4_I(inode)->i_inline_off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nint ext4_xattr_ibody_inline_set(handle_t *handle, struct inode *inode,\n\t\t\t\tstruct ext4_xattr_info *i,\n\t\t\t\tstruct ext4_xattr_ibody_find *is)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_xattr_search *s = &is->s;\n\tint error;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn -ENOSPC;\n\terror = ext4_xattr_set_entry(i, s);\n\tif (error) {\n\t\tif (error == -ENOSPC &&\n\t\t    ext4_has_inline_data(inode)) {\n\t\t\terror = ext4_try_to_evict_inline_data(handle, inode,\n\t\t\t\t\tEXT4_XATTR_LEN(strlen(i->name) +\n\t\t\t\t\tEXT4_XATTR_SIZE(i->value_len)));\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\terror = ext4_xattr_ibody_find(inode, i, is);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\terror = ext4_xattr_set_entry(i, s);\n\t\t}\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\theader = IHDR(inode, ext4_raw_inode(&is->iloc));\n\tif (!IS_LAST_ENTRY(s->first)) {\n\t\theader->h_magic = cpu_to_le32(EXT4_XATTR_MAGIC);\n\t\text4_set_inode_state(inode, EXT4_STATE_XATTR);\n\t} else {\n\t\theader->h_magic = cpu_to_le32(0);\n\t\text4_clear_inode_state(inode, EXT4_STATE_XATTR);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_xattr_ibody_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
    "lines": "981-1009",
    "snippet": "int ext4_xattr_ibody_find(struct inode *inode, struct ext4_xattr_info *i,\n\t\t\t  struct ext4_xattr_ibody_find *is)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_inode *raw_inode;\n\tint error;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn 0;\n\traw_inode = ext4_raw_inode(&is->iloc);\n\theader = IHDR(inode, raw_inode);\n\tis->s.base = is->s.first = IFIRST(header);\n\tis->s.here = is->s.first;\n\tis->s.end = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;\n\tif (ext4_test_inode_state(inode, EXT4_STATE_XATTR)) {\n\t\terror = ext4_xattr_check_names(IFIRST(header), is->s.end,\n\t\t\t\t\t       IFIRST(header));\n\t\tif (error)\n\t\t\treturn error;\n\t\t/* Find the named attribute. */\n\t\terror = ext4_xattr_find_entry(&is->s.here, i->name_index,\n\t\t\t\t\t      i->name, is->s.end -\n\t\t\t\t\t      (void *)is->s.base, 0);\n\t\tif (error && error != -ENODATA)\n\t\t\treturn error;\n\t\tis->s.not_found = error;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_xattr_find_entry",
          "args": [
            "&is->s.here",
            "i->name_index",
            "i->name",
            "is->s.end -\n\t\t\t\t\t      (void *)is->s.base",
            "0"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "247-272",
          "snippet": "static int\next4_xattr_find_entry(struct ext4_xattr_entry **pentry, int name_index,\n\t\t      const char *name, size_t size, int sorted)\n{\n\tstruct ext4_xattr_entry *entry;\n\tsize_t name_len;\n\tint cmp = 1;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\tname_len = strlen(name);\n\tentry = *pentry;\n\tfor (; !IS_LAST_ENTRY(entry); entry = EXT4_XATTR_NEXT(entry)) {\n\t\tcmp = name_index - entry->e_name_index;\n\t\tif (!cmp)\n\t\t\tcmp = name_len - entry->e_name_len;\n\t\tif (!cmp)\n\t\t\tcmp = memcmp(name, entry->e_name, name_len);\n\t\tif (cmp <= 0 && (sorted || cmp == 0))\n\t\t\tbreak;\n\t}\n\t*pentry = entry;\n\tif (!cmp && ext4_xattr_check_entry(entry, size))\n\t\t\treturn -EIO;\n\treturn cmp ? -ENODATA : 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);\n\nstatic int\next4_xattr_find_entry(struct ext4_xattr_entry **pentry, int name_index,\n\t\t      const char *name, size_t size, int sorted)\n{\n\tstruct ext4_xattr_entry *entry;\n\tsize_t name_len;\n\tint cmp = 1;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\tname_len = strlen(name);\n\tentry = *pentry;\n\tfor (; !IS_LAST_ENTRY(entry); entry = EXT4_XATTR_NEXT(entry)) {\n\t\tcmp = name_index - entry->e_name_index;\n\t\tif (!cmp)\n\t\t\tcmp = name_len - entry->e_name_len;\n\t\tif (!cmp)\n\t\t\tcmp = memcmp(name, entry->e_name, name_len);\n\t\tif (cmp <= 0 && (sorted || cmp == 0))\n\t\t\tbreak;\n\t}\n\t*pentry = entry;\n\tif (!cmp && ext4_xattr_check_entry(entry, size))\n\t\t\treturn -EIO;\n\treturn cmp ? -ENODATA : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_xattr_check_names",
          "args": [
            "IFIRST(header)",
            "is->s.end",
            "IFIRST(header)"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_check_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "190-214",
          "snippet": "static int\next4_xattr_check_names(struct ext4_xattr_entry *entry, void *end,\n\t\t       void *value_start)\n{\n\tstruct ext4_xattr_entry *e = entry;\n\n\twhile (!IS_LAST_ENTRY(e)) {\n\t\tstruct ext4_xattr_entry *next = EXT4_XATTR_NEXT(e);\n\t\tif ((void *)next >= end)\n\t\t\treturn -EIO;\n\t\te = next;\n\t}\n\n\twhile (!IS_LAST_ENTRY(entry)) {\n\t\tif (entry->e_value_size != 0 &&\n\t\t    (value_start + le16_to_cpu(entry->e_value_offs) <\n\t\t     (void *)e + sizeof(__u32) ||\n\t\t     value_start + le16_to_cpu(entry->e_value_offs) +\n\t\t    le32_to_cpu(entry->e_value_size) > end))\n\t\t\treturn -EIO;\n\t\tentry = EXT4_XATTR_NEXT(entry);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);\n\nstatic int\next4_xattr_check_names(struct ext4_xattr_entry *entry, void *end,\n\t\t       void *value_start)\n{\n\tstruct ext4_xattr_entry *e = entry;\n\n\twhile (!IS_LAST_ENTRY(e)) {\n\t\tstruct ext4_xattr_entry *next = EXT4_XATTR_NEXT(e);\n\t\tif ((void *)next >= end)\n\t\t\treturn -EIO;\n\t\te = next;\n\t}\n\n\twhile (!IS_LAST_ENTRY(entry)) {\n\t\tif (entry->e_value_size != 0 &&\n\t\t    (value_start + le16_to_cpu(entry->e_value_offs) <\n\t\t     (void *)e + sizeof(__u32) ||\n\t\t     value_start + le16_to_cpu(entry->e_value_offs) +\n\t\t    le32_to_cpu(entry->e_value_size) > end))\n\t\t\treturn -EIO;\n\t\tentry = EXT4_XATTR_NEXT(entry);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IFIRST",
          "args": [
            "header"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFIRST",
          "args": [
            "header"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_XATTR"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IFIRST",
          "args": [
            "header"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IHDR",
          "args": [
            "inode",
            "raw_inode"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_raw_inode",
          "args": [
            "&is->iloc"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_raw_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1810-1813",
          "snippet": "static inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nint ext4_xattr_ibody_find(struct inode *inode, struct ext4_xattr_info *i,\n\t\t\t  struct ext4_xattr_ibody_find *is)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_inode *raw_inode;\n\tint error;\n\n\tif (EXT4_I(inode)->i_extra_isize == 0)\n\t\treturn 0;\n\traw_inode = ext4_raw_inode(&is->iloc);\n\theader = IHDR(inode, raw_inode);\n\tis->s.base = is->s.first = IFIRST(header);\n\tis->s.here = is->s.first;\n\tis->s.end = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;\n\tif (ext4_test_inode_state(inode, EXT4_STATE_XATTR)) {\n\t\terror = ext4_xattr_check_names(IFIRST(header), is->s.end,\n\t\t\t\t\t       IFIRST(header));\n\t\tif (error)\n\t\t\treturn error;\n\t\t/* Find the named attribute. */\n\t\terror = ext4_xattr_find_entry(&is->s.here, i->name_index,\n\t\t\t\t\t      i->name, is->s.end -\n\t\t\t\t\t      (void *)is->s.base, 0);\n\t\tif (error && error != -ENODATA)\n\t\t\treturn error;\n\t\tis->s.not_found = error;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_xattr_block_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
    "lines": "776-979",
    "snippet": "static int\next4_xattr_block_set(handle_t *handle, struct inode *inode,\n\t\t     struct ext4_xattr_info *i,\n\t\t     struct ext4_xattr_block_find *bs)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ext4_xattr_search *s = &bs->s;\n\tstruct mb_cache_entry *ce = NULL;\n\tint error = 0;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\n#define header(x) ((struct ext4_xattr_header *)(x))\n\n\tif (i->value && i->value_len > sb->s_blocksize)\n\t\treturn -ENOSPC;\n\tif (s->base) {\n\t\tce = mb_cache_entry_get(ext4_mb_cache, bs->bh->b_bdev,\n\t\t\t\t\tbs->bh->b_blocknr);\n\t\tBUFFER_TRACE(bs->bh, \"get_write_access\");\n\t\terror = ext4_journal_get_write_access(handle, bs->bh);\n\t\tif (error)\n\t\t\tgoto cleanup;\n\t\tlock_buffer(bs->bh);\n\n\t\tif (header(s->base)->h_refcount == cpu_to_le32(1)) {\n\t\t\tif (ce) {\n\t\t\t\tmb_cache_entry_free(ce);\n\t\t\t\tce = NULL;\n\t\t\t}\n\t\t\tea_bdebug(bs->bh, \"modifying in-place\");\n\t\t\terror = ext4_xattr_set_entry(i, s);\n\t\t\tif (!error) {\n\t\t\t\tif (!IS_LAST_ENTRY(s->first))\n\t\t\t\t\text4_xattr_rehash(header(s->base),\n\t\t\t\t\t\t\t  s->here);\n\t\t\t\text4_xattr_cache_insert(ext4_mb_cache,\n\t\t\t\t\tbs->bh);\n\t\t\t}\n\t\t\tunlock_buffer(bs->bh);\n\t\t\tif (error == -EIO)\n\t\t\t\tgoto bad_block;\n\t\t\tif (!error)\n\t\t\t\terror = ext4_handle_dirty_xattr_block(handle,\n\t\t\t\t\t\t\t\t      inode,\n\t\t\t\t\t\t\t\t      bs->bh);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t\tgoto inserted;\n\t\t} else {\n\t\t\tint offset = (char *)s->here - bs->bh->b_data;\n\n\t\t\tunlock_buffer(bs->bh);\n\t\t\tif (ce) {\n\t\t\t\tmb_cache_entry_release(ce);\n\t\t\t\tce = NULL;\n\t\t\t}\n\t\t\tea_bdebug(bs->bh, \"cloning\");\n\t\t\ts->base = kmalloc(bs->bh->b_size, GFP_NOFS);\n\t\t\terror = -ENOMEM;\n\t\t\tif (s->base == NULL)\n\t\t\t\tgoto cleanup;\n\t\t\tmemcpy(s->base, BHDR(bs->bh), bs->bh->b_size);\n\t\t\ts->first = ENTRY(header(s->base)+1);\n\t\t\theader(s->base)->h_refcount = cpu_to_le32(1);\n\t\t\ts->here = ENTRY(s->base + offset);\n\t\t\ts->end = s->base + bs->bh->b_size;\n\t\t}\n\t} else {\n\t\t/* Allocate a buffer where we construct the new block. */\n\t\ts->base = kzalloc(sb->s_blocksize, GFP_NOFS);\n\t\t/* assert(header == s->base) */\n\t\terror = -ENOMEM;\n\t\tif (s->base == NULL)\n\t\t\tgoto cleanup;\n\t\theader(s->base)->h_magic = cpu_to_le32(EXT4_XATTR_MAGIC);\n\t\theader(s->base)->h_blocks = cpu_to_le32(1);\n\t\theader(s->base)->h_refcount = cpu_to_le32(1);\n\t\ts->first = ENTRY(header(s->base)+1);\n\t\ts->here = ENTRY(header(s->base)+1);\n\t\ts->end = s->base + sb->s_blocksize;\n\t}\n\n\terror = ext4_xattr_set_entry(i, s);\n\tif (error == -EIO)\n\t\tgoto bad_block;\n\tif (error)\n\t\tgoto cleanup;\n\tif (!IS_LAST_ENTRY(s->first))\n\t\text4_xattr_rehash(header(s->base), s->here);\n\ninserted:\n\tif (!IS_LAST_ENTRY(s->first)) {\n\t\tnew_bh = ext4_xattr_cache_find(inode, header(s->base), &ce);\n\t\tif (new_bh) {\n\t\t\t/* We found an identical block in the cache. */\n\t\t\tif (new_bh == bs->bh)\n\t\t\t\tea_bdebug(new_bh, \"keeping\");\n\t\t\telse {\n\t\t\t\t/* The old block is released after updating\n\t\t\t\t   the inode. */\n\t\t\t\terror = dquot_alloc_block(inode,\n\t\t\t\t\t\tEXT4_C2B(EXT4_SB(sb), 1));\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup;\n\t\t\t\tBUFFER_TRACE(new_bh, \"get_write_access\");\n\t\t\t\terror = ext4_journal_get_write_access(handle,\n\t\t\t\t\t\t\t\t      new_bh);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup_dquot;\n\t\t\t\tlock_buffer(new_bh);\n\t\t\t\tle32_add_cpu(&BHDR(new_bh)->h_refcount, 1);\n\t\t\t\tea_bdebug(new_bh, \"reusing; refcount now=%d\",\n\t\t\t\t\tle32_to_cpu(BHDR(new_bh)->h_refcount));\n\t\t\t\tunlock_buffer(new_bh);\n\t\t\t\terror = ext4_handle_dirty_xattr_block(handle,\n\t\t\t\t\t\t\t\t      inode,\n\t\t\t\t\t\t\t\t      new_bh);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup_dquot;\n\t\t\t}\n\t\t\tmb_cache_entry_release(ce);\n\t\t\tce = NULL;\n\t\t} else if (bs->bh && s->base == bs->bh->b_data) {\n\t\t\t/* We were modifying this block in-place. */\n\t\t\tea_bdebug(bs->bh, \"keeping this block\");\n\t\t\tnew_bh = bs->bh;\n\t\t\tget_bh(new_bh);\n\t\t} else {\n\t\t\t/* We need to allocate a new block */\n\t\t\text4_fsblk_t goal, block;\n\n\t\t\tgoal = ext4_group_first_block_no(sb,\n\t\t\t\t\t\tEXT4_I(inode)->i_block_group);\n\n\t\t\t/* non-extent files can't have physical blocks past 2^32 */\n\t\t\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\t\t\tgoal = goal & EXT4_MAX_BLOCK_FILE_PHYS;\n\n\t\t\tblock = ext4_new_meta_blocks(handle, inode, goal, 0,\n\t\t\t\t\t\t     NULL, &error);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\n\t\t\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\t\t\tBUG_ON(block > EXT4_MAX_BLOCK_FILE_PHYS);\n\n\t\t\tea_idebug(inode, \"creating block %llu\",\n\t\t\t\t  (unsigned long long)block);\n\n\t\t\tnew_bh = sb_getblk(sb, block);\n\t\t\tif (unlikely(!new_bh)) {\n\t\t\t\terror = -ENOMEM;\ngetblk_failed:\n\t\t\t\text4_free_blocks(handle, inode, NULL, block, 1,\n\t\t\t\t\t\t EXT4_FREE_BLOCKS_METADATA);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tlock_buffer(new_bh);\n\t\t\terror = ext4_journal_get_create_access(handle, new_bh);\n\t\t\tif (error) {\n\t\t\t\tunlock_buffer(new_bh);\n\t\t\t\terror = -EIO;\n\t\t\t\tgoto getblk_failed;\n\t\t\t}\n\t\t\tmemcpy(new_bh->b_data, s->base, new_bh->b_size);\n\t\t\tset_buffer_uptodate(new_bh);\n\t\t\tunlock_buffer(new_bh);\n\t\t\text4_xattr_cache_insert(ext4_mb_cache, new_bh);\n\t\t\terror = ext4_handle_dirty_xattr_block(handle,\n\t\t\t\t\t\t\t      inode, new_bh);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t/* Update the inode. */\n\tEXT4_I(inode)->i_file_acl = new_bh ? new_bh->b_blocknr : 0;\n\n\t/* Drop the previous xattr block. */\n\tif (bs->bh && bs->bh != new_bh)\n\t\text4_xattr_release_block(handle, inode, bs->bh);\n\terror = 0;\n\ncleanup:\n\tif (ce)\n\t\tmb_cache_entry_release(ce);\n\tbrelse(new_bh);\n\tif (!(bs->bh && s->base == bs->bh->b_data))\n\t\tkfree(s->base);\n\n\treturn error;\n\ncleanup_dquot:\n\tdquot_free_block(inode, EXT4_C2B(EXT4_SB(sb), 1));\n\tgoto cleanup;\n\nbad_block:\n\tEXT4_ERROR_INODE(inode, \"bad block %llu\",\n\t\t\t EXT4_I(inode)->i_file_acl);\n\tgoto cleanup;\n\n#undef header\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);",
      "static struct buffer_head *ext4_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext4_xattr_header *,\n\t\t\t\t\t\t struct mb_cache_entry **);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT4_ERROR_INODE",
          "args": [
            "inode",
            "\"bad block %llu\"",
            "EXT4_I(inode)->i_file_acl"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_free_block",
          "args": [
            "inode",
            "EXT4_C2B(EXT4_SB(sb), 1)"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_C2B",
          "args": [
            "EXT4_SB(sb)",
            "1"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "s->base"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "new_bh"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_cache_entry_release",
          "args": [
            "ce"
          ],
          "line": 962
        },
        "resolved": true,
        "details": {
          "function_name": "mb_cache_entry_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "626-630",
          "snippet": "void\nmb_cache_entry_release(struct mb_cache_entry *ce)\n{\n\t__mb_cache_entry_release(ce);\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid\nmb_cache_entry_release(struct mb_cache_entry *ce)\n{\n\t__mb_cache_entry_release(ce);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_xattr_release_block",
          "args": [
            "handle",
            "inode",
            "bs->bh"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_release_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "543-597",
          "snippet": "static void\next4_xattr_release_block(handle_t *handle, struct inode *inode,\n\t\t\t struct buffer_head *bh)\n{\n\tstruct mb_cache_entry *ce = NULL;\n\tint error = 0;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\n\tce = mb_cache_entry_get(ext4_mb_cache, bh->b_bdev, bh->b_blocknr);\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terror = ext4_journal_get_write_access(handle, bh);\n\tif (error)\n\t\tgoto out;\n\n\tlock_buffer(bh);\n\tif (BHDR(bh)->h_refcount == cpu_to_le32(1)) {\n\t\tea_bdebug(bh, \"refcount now=0; freeing\");\n\t\tif (ce)\n\t\t\tmb_cache_entry_free(ce);\n\t\tget_bh(bh);\n\t\tunlock_buffer(bh);\n\t\text4_free_blocks(handle, inode, bh, 0, 1,\n\t\t\t\t EXT4_FREE_BLOCKS_METADATA |\n\t\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\t} else {\n\t\tle32_add_cpu(&BHDR(bh)->h_refcount, -1);\n\t\tif (ce)\n\t\t\tmb_cache_entry_release(ce);\n\t\t/*\n\t\t * Beware of this ugliness: Releasing of xattr block references\n\t\t * from different inodes can race and so we have to protect\n\t\t * from a race where someone else frees the block (and releases\n\t\t * its journal_head) before we are done dirtying the buffer. In\n\t\t * nojournal mode this race is harmless and we actually cannot\n\t\t * call ext4_handle_dirty_xattr_block() with locked buffer as\n\t\t * that function can call sync_dirty_buffer() so for that case\n\t\t * we handle the dirtying after unlocking the buffer.\n\t\t */\n\t\tif (ext4_handle_valid(handle))\n\t\t\terror = ext4_handle_dirty_xattr_block(handle, inode,\n\t\t\t\t\t\t\t      bh);\n\t\tunlock_buffer(bh);\n\t\tif (!ext4_handle_valid(handle))\n\t\t\terror = ext4_handle_dirty_xattr_block(handle, inode,\n\t\t\t\t\t\t\t      bh);\n\t\tif (IS_SYNC(inode))\n\t\t\text4_handle_sync(handle);\n\t\tdquot_free_block(inode, EXT4_C2B(EXT4_SB(inode->i_sb), 1));\n\t\tea_bdebug(bh, \"refcount now=%d; releasing\",\n\t\t\t  le32_to_cpu(BHDR(bh)->h_refcount));\n\t}\nout:\n\text4_std_error(inode->i_sb, error);\n\treturn;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);",
            "static struct buffer_head *ext4_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext4_xattr_header *,\n\t\t\t\t\t\t struct mb_cache_entry **);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);\nstatic struct buffer_head *ext4_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext4_xattr_header *,\n\t\t\t\t\t\t struct mb_cache_entry **);\n\nstatic void\next4_xattr_release_block(handle_t *handle, struct inode *inode,\n\t\t\t struct buffer_head *bh)\n{\n\tstruct mb_cache_entry *ce = NULL;\n\tint error = 0;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\n\tce = mb_cache_entry_get(ext4_mb_cache, bh->b_bdev, bh->b_blocknr);\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terror = ext4_journal_get_write_access(handle, bh);\n\tif (error)\n\t\tgoto out;\n\n\tlock_buffer(bh);\n\tif (BHDR(bh)->h_refcount == cpu_to_le32(1)) {\n\t\tea_bdebug(bh, \"refcount now=0; freeing\");\n\t\tif (ce)\n\t\t\tmb_cache_entry_free(ce);\n\t\tget_bh(bh);\n\t\tunlock_buffer(bh);\n\t\text4_free_blocks(handle, inode, bh, 0, 1,\n\t\t\t\t EXT4_FREE_BLOCKS_METADATA |\n\t\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\t} else {\n\t\tle32_add_cpu(&BHDR(bh)->h_refcount, -1);\n\t\tif (ce)\n\t\t\tmb_cache_entry_release(ce);\n\t\t/*\n\t\t * Beware of this ugliness: Releasing of xattr block references\n\t\t * from different inodes can race and so we have to protect\n\t\t * from a race where someone else frees the block (and releases\n\t\t * its journal_head) before we are done dirtying the buffer. In\n\t\t * nojournal mode this race is harmless and we actually cannot\n\t\t * call ext4_handle_dirty_xattr_block() with locked buffer as\n\t\t * that function can call sync_dirty_buffer() so for that case\n\t\t * we handle the dirtying after unlocking the buffer.\n\t\t */\n\t\tif (ext4_handle_valid(handle))\n\t\t\terror = ext4_handle_dirty_xattr_block(handle, inode,\n\t\t\t\t\t\t\t      bh);\n\t\tunlock_buffer(bh);\n\t\tif (!ext4_handle_valid(handle))\n\t\t\terror = ext4_handle_dirty_xattr_block(handle, inode,\n\t\t\t\t\t\t\t      bh);\n\t\tif (IS_SYNC(inode))\n\t\t\text4_handle_sync(handle);\n\t\tdquot_free_block(inode, EXT4_C2B(EXT4_SB(inode->i_sb), 1));\n\t\tea_bdebug(bh, \"refcount now=%d; releasing\",\n\t\t\t  le32_to_cpu(BHDR(bh)->h_refcount));\n\t}\nout:\n\text4_std_error(inode->i_sb, error);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_xattr_block",
          "args": [
            "handle",
            "inode",
            "new_bh"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_dirty_xattr_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "161-167",
          "snippet": "static inline int ext4_handle_dirty_xattr_block(handle_t *handle,\n\t\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\t\tstruct buffer_head *bh)\n{\n\text4_xattr_block_csum_set(inode, bh->b_blocknr, BHDR(bh));\n\treturn ext4_handle_dirty_metadata(handle, inode, bh);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);\n\nstatic inline int ext4_handle_dirty_xattr_block(handle_t *handle,\n\t\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\t\tstruct buffer_head *bh)\n{\n\text4_xattr_block_csum_set(inode, bh->b_blocknr, BHDR(bh));\n\treturn ext4_handle_dirty_metadata(handle, inode, bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_xattr_cache_insert",
          "args": [
            "ext4_mb_cache",
            "new_bh"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_cache_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "1533-1556",
          "snippet": "static void\next4_xattr_cache_insert(struct mb_cache *ext4_mb_cache, struct buffer_head *bh)\n{\n\t__u32 hash = le32_to_cpu(BHDR(bh)->h_hash);\n\tstruct mb_cache_entry *ce;\n\tint error;\n\n\tce = mb_cache_entry_alloc(ext4_mb_cache, GFP_NOFS);\n\tif (!ce) {\n\t\tea_bdebug(bh, \"out of memory\");\n\t\treturn;\n\t}\n\terror = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, hash);\n\tif (error) {\n\t\tmb_cache_entry_free(ce);\n\t\tif (error == -EBUSY) {\n\t\t\tea_bdebug(bh, \"already in cache\");\n\t\t\terror = 0;\n\t\t}\n\t} else {\n\t\tea_bdebug(bh, \"inserting [%x]\", (int)hash);\n\t\tmb_cache_entry_release(ce);\n\t}\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);",
            "static struct buffer_head *ext4_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext4_xattr_header *,\n\t\t\t\t\t\t struct mb_cache_entry **);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);\nstatic struct buffer_head *ext4_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext4_xattr_header *,\n\t\t\t\t\t\t struct mb_cache_entry **);\n\nstatic void\next4_xattr_cache_insert(struct mb_cache *ext4_mb_cache, struct buffer_head *bh)\n{\n\t__u32 hash = le32_to_cpu(BHDR(bh)->h_hash);\n\tstruct mb_cache_entry *ce;\n\tint error;\n\n\tce = mb_cache_entry_alloc(ext4_mb_cache, GFP_NOFS);\n\tif (!ce) {\n\t\tea_bdebug(bh, \"out of memory\");\n\t\treturn;\n\t}\n\terror = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, hash);\n\tif (error) {\n\t\tmb_cache_entry_free(ce);\n\t\tif (error == -EBUSY) {\n\t\t\tea_bdebug(bh, \"already in cache\");\n\t\t\terror = 0;\n\t\t}\n\t} else {\n\t\tea_bdebug(bh, \"inserting [%x]\", (int)hash);\n\t\tmb_cache_entry_release(ce);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "new_bh"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "new_bh"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new_bh->b_data",
            "s->base",
            "new_bh->b_size"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_create_access",
          "args": [
            "handle",
            "new_bh"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_free_blocks",
          "args": [
            "handle",
            "inode",
            "NULL",
            "block",
            "1",
            "EXT4_FREE_BLOCKS_METADATA"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "4633-4881",
          "snippet": "void ext4_free_blocks(handle_t *handle, struct inode *inode,\n\t\t      struct buffer_head *bh, ext4_fsblk_t block,\n\t\t      unsigned long count, int flags)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_group_desc *gdp;\n\tunsigned int overflow;\n\text4_grpblk_t bit;\n\tstruct buffer_head *gd_bh;\n\text4_group_t block_group;\n\tstruct ext4_sb_info *sbi;\n\tstruct ext4_buddy e4b;\n\tunsigned int count_clusters;\n\tint err = 0;\n\tint ret;\n\n\tmight_sleep();\n\tif (bh) {\n\t\tif (block)\n\t\t\tBUG_ON(block != bh->b_blocknr);\n\t\telse\n\t\t\tblock = bh->b_blocknr;\n\t}\n\n\tsbi = EXT4_SB(sb);\n\tif (!(flags & EXT4_FREE_BLOCKS_VALIDATED) &&\n\t    !ext4_data_block_valid(sbi, block, count)) {\n\t\text4_error(sb, \"Freeing blocks not in datazone - \"\n\t\t\t   \"block = %llu, count = %lu\", block, count);\n\t\tgoto error_return;\n\t}\n\n\text4_debug(\"freeing block %llu\\n\", block);\n\ttrace_ext4_free_blocks(inode, block, count, flags);\n\n\tif (flags & EXT4_FREE_BLOCKS_FORGET) {\n\t\tstruct buffer_head *tbh = bh;\n\t\tint i;\n\n\t\tBUG_ON(bh && (count > 1));\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tcond_resched();\n\t\t\tif (!bh)\n\t\t\t\ttbh = sb_find_get_block(inode->i_sb,\n\t\t\t\t\t\t\tblock + i);\n\t\t\tif (!tbh)\n\t\t\t\tcontinue;\n\t\t\text4_forget(handle, flags & EXT4_FREE_BLOCKS_METADATA,\n\t\t\t\t    inode, tbh, block + i);\n\t\t}\n\t}\n\n\t/*\n\t * We need to make sure we don't reuse the freed block until\n\t * after the transaction is committed, which we can do by\n\t * treating the block as metadata, below.  We make an\n\t * exception if the inode is to be written in writeback mode\n\t * since writeback mode has weak data consistency guarantees.\n\t */\n\tif (!ext4_should_writeback_data(inode))\n\t\tflags |= EXT4_FREE_BLOCKS_METADATA;\n\n\t/*\n\t * If the extent to be freed does not begin on a cluster\n\t * boundary, we need to deal with partial clusters at the\n\t * beginning and end of the extent.  Normally we will free\n\t * blocks at the beginning or the end unless we are explicitly\n\t * requested to avoid doing so.\n\t */\n\toverflow = EXT4_PBLK_COFF(sbi, block);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_FIRST_CLUSTER) {\n\t\t\toverflow = sbi->s_cluster_ratio - overflow;\n\t\t\tblock += overflow;\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else {\n\t\t\tblock -= overflow;\n\t\t\tcount += overflow;\n\t\t}\n\t}\n\toverflow = EXT4_LBLK_COFF(sbi, count);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_LAST_CLUSTER) {\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else\n\t\t\tcount += sbi->s_cluster_ratio - overflow;\n\t}\n\ndo_more:\n\toverflow = 0;\n\text4_get_group_no_and_offset(sb, block, &block_group, &bit);\n\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(\n\t\t\text4_get_group_info(sb, block_group))))\n\t\treturn;\n\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (EXT4_C2B(sbi, bit) + count > EXT4_BLOCKS_PER_GROUP(sb)) {\n\t\toverflow = EXT4_C2B(sbi, bit) + count -\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb);\n\t\tcount -= overflow;\n\t}\n\tcount_clusters = EXT4_NUM_B2C(sbi, count);\n\tbitmap_bh = ext4_read_block_bitmap(sb, block_group);\n\tif (!bitmap_bh) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\tgdp = ext4_get_group_desc(sb, block_group, &gd_bh);\n\tif (!gdp) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\n\tif (in_range(ext4_block_bitmap(sb, gdp), block, count) ||\n\t    in_range(ext4_inode_bitmap(sb, gdp), block, count) ||\n\t    in_range(block, ext4_inode_table(sb, gdp),\n\t\t     EXT4_SB(sb)->s_itb_per_group) ||\n\t    in_range(block + count - 1, ext4_inode_table(sb, gdp),\n\t\t     EXT4_SB(sb)->s_itb_per_group)) {\n\n\t\text4_error(sb, \"Freeing blocks in system zone - \"\n\t\t\t   \"Block = %llu, count = %lu\", block, count);\n\t\t/* err = 0. ext4_std_error should be a no op */\n\t\tgoto error_return;\n\t}\n\n\tBUFFER_TRACE(bitmap_bh, \"getting write access\");\n\terr = ext4_journal_get_write_access(handle, bitmap_bh);\n\tif (err)\n\t\tgoto error_return;\n\n\t/*\n\t * We are about to modify some metadata.  Call the journal APIs\n\t * to unshare ->b_data if a currently-committing transaction is\n\t * using it\n\t */\n\tBUFFER_TRACE(gd_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, gd_bh);\n\tif (err)\n\t\tgoto error_return;\n#ifdef AGGRESSIVE_CHECK\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < count_clusters; i++)\n\t\t\tBUG_ON(!mb_test_bit(bit + i, bitmap_bh->b_data));\n\t}\n#endif\n\ttrace_ext4_mballoc_free(sb, inode, block_group, bit, count_clusters);\n\n\terr = ext4_mb_load_buddy(sb, block_group, &e4b);\n\tif (err)\n\t\tgoto error_return;\n\n\tif ((flags & EXT4_FREE_BLOCKS_METADATA) && ext4_handle_valid(handle)) {\n\t\tstruct ext4_free_data *new_entry;\n\t\t/*\n\t\t * blocks being freed are metadata. these blocks shouldn't\n\t\t * be used until this transaction is committed\n\t\t */\n\tretry:\n\t\tnew_entry = kmem_cache_alloc(ext4_free_data_cachep, GFP_NOFS);\n\t\tif (!new_entry) {\n\t\t\t/*\n\t\t\t * We use a retry loop because\n\t\t\t * ext4_free_blocks() is not allowed to fail.\n\t\t\t */\n\t\t\tcond_resched();\n\t\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t\t\tgoto retry;\n\t\t}\n\t\tnew_entry->efd_start_cluster = bit;\n\t\tnew_entry->efd_group = block_group;\n\t\tnew_entry->efd_count = count_clusters;\n\t\tnew_entry->efd_tid = handle->h_transaction->t_tid;\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\text4_mb_free_metadata(handle, &e4b, new_entry);\n\t} else {\n\t\t/* need to update group_info->bb_free and bitmap\n\t\t * with group lock held. generate_buddy look at\n\t\t * them with group lock_held\n\t\t */\n\t\tif (test_opt(sb, DISCARD)) {\n\t\t\terr = ext4_issue_discard(sb, block_group, bit, count);\n\t\t\tif (err && err != -EOPNOTSUPP)\n\t\t\t\text4_msg(sb, KERN_WARNING, \"discard request in\"\n\t\t\t\t\t \" group:%d block:%d count:%lu failed\"\n\t\t\t\t\t \" with %d\", block_group, bit, count,\n\t\t\t\t\t err);\n\t\t} else\n\t\t\tEXT4_MB_GRP_CLEAR_TRIMMED(e4b.bd_info);\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\tmb_free_blocks(inode, &e4b, bit, count_clusters);\n\t}\n\n\tret = ext4_free_group_clusters(sb, gdp) + count_clusters;\n\text4_free_group_clusters_set(sb, gdp, ret);\n\text4_block_bitmap_csum_set(sb, block_group, gdp, bitmap_bh);\n\text4_group_desc_csum_set(sb, block_group, gdp);\n\text4_unlock_group(sb, block_group);\n\n\tif (sbi->s_log_groups_per_flex) {\n\t\text4_group_t flex_group = ext4_flex_group(sbi, block_group);\n\t\tatomic64_add(count_clusters,\n\t\t\t     &sbi->s_flex_groups[flex_group].free_clusters);\n\t}\n\n\tif (!(flags & EXT4_FREE_BLOCKS_NO_QUOT_UPDATE))\n\t\tdquot_free_block(inode, EXT4_C2B(sbi, count_clusters));\n\tpercpu_counter_add(&sbi->s_freeclusters_counter, count_clusters);\n\n\text4_mb_unload_buddy(&e4b);\n\n\t/* We dirtied the bitmap block */\n\tBUFFER_TRACE(bitmap_bh, \"dirtied bitmap block\");\n\terr = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);\n\n\t/* And the group descriptor block */\n\tBUFFER_TRACE(gd_bh, \"dirtied group descriptor block\");\n\tret = ext4_handle_dirty_metadata(handle, NULL, gd_bh);\n\tif (!err)\n\t\terr = ret;\n\n\tif (overflow && !err) {\n\t\tblock += count;\n\t\tcount = overflow;\n\t\tput_bh(bitmap_bh);\n\t\tgoto do_more;\n\t}\nerror_return:\n\tbrelse(bitmap_bh);\n\text4_std_error(sb, err);\n\treturn;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ext4_free_data_cachep;",
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic struct kmem_cache *ext4_free_data_cachep;\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nvoid ext4_free_blocks(handle_t *handle, struct inode *inode,\n\t\t      struct buffer_head *bh, ext4_fsblk_t block,\n\t\t      unsigned long count, int flags)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_group_desc *gdp;\n\tunsigned int overflow;\n\text4_grpblk_t bit;\n\tstruct buffer_head *gd_bh;\n\text4_group_t block_group;\n\tstruct ext4_sb_info *sbi;\n\tstruct ext4_buddy e4b;\n\tunsigned int count_clusters;\n\tint err = 0;\n\tint ret;\n\n\tmight_sleep();\n\tif (bh) {\n\t\tif (block)\n\t\t\tBUG_ON(block != bh->b_blocknr);\n\t\telse\n\t\t\tblock = bh->b_blocknr;\n\t}\n\n\tsbi = EXT4_SB(sb);\n\tif (!(flags & EXT4_FREE_BLOCKS_VALIDATED) &&\n\t    !ext4_data_block_valid(sbi, block, count)) {\n\t\text4_error(sb, \"Freeing blocks not in datazone - \"\n\t\t\t   \"block = %llu, count = %lu\", block, count);\n\t\tgoto error_return;\n\t}\n\n\text4_debug(\"freeing block %llu\\n\", block);\n\ttrace_ext4_free_blocks(inode, block, count, flags);\n\n\tif (flags & EXT4_FREE_BLOCKS_FORGET) {\n\t\tstruct buffer_head *tbh = bh;\n\t\tint i;\n\n\t\tBUG_ON(bh && (count > 1));\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tcond_resched();\n\t\t\tif (!bh)\n\t\t\t\ttbh = sb_find_get_block(inode->i_sb,\n\t\t\t\t\t\t\tblock + i);\n\t\t\tif (!tbh)\n\t\t\t\tcontinue;\n\t\t\text4_forget(handle, flags & EXT4_FREE_BLOCKS_METADATA,\n\t\t\t\t    inode, tbh, block + i);\n\t\t}\n\t}\n\n\t/*\n\t * We need to make sure we don't reuse the freed block until\n\t * after the transaction is committed, which we can do by\n\t * treating the block as metadata, below.  We make an\n\t * exception if the inode is to be written in writeback mode\n\t * since writeback mode has weak data consistency guarantees.\n\t */\n\tif (!ext4_should_writeback_data(inode))\n\t\tflags |= EXT4_FREE_BLOCKS_METADATA;\n\n\t/*\n\t * If the extent to be freed does not begin on a cluster\n\t * boundary, we need to deal with partial clusters at the\n\t * beginning and end of the extent.  Normally we will free\n\t * blocks at the beginning or the end unless we are explicitly\n\t * requested to avoid doing so.\n\t */\n\toverflow = EXT4_PBLK_COFF(sbi, block);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_FIRST_CLUSTER) {\n\t\t\toverflow = sbi->s_cluster_ratio - overflow;\n\t\t\tblock += overflow;\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else {\n\t\t\tblock -= overflow;\n\t\t\tcount += overflow;\n\t\t}\n\t}\n\toverflow = EXT4_LBLK_COFF(sbi, count);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_LAST_CLUSTER) {\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else\n\t\t\tcount += sbi->s_cluster_ratio - overflow;\n\t}\n\ndo_more:\n\toverflow = 0;\n\text4_get_group_no_and_offset(sb, block, &block_group, &bit);\n\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(\n\t\t\text4_get_group_info(sb, block_group))))\n\t\treturn;\n\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (EXT4_C2B(sbi, bit) + count > EXT4_BLOCKS_PER_GROUP(sb)) {\n\t\toverflow = EXT4_C2B(sbi, bit) + count -\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb);\n\t\tcount -= overflow;\n\t}\n\tcount_clusters = EXT4_NUM_B2C(sbi, count);\n\tbitmap_bh = ext4_read_block_bitmap(sb, block_group);\n\tif (!bitmap_bh) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\tgdp = ext4_get_group_desc(sb, block_group, &gd_bh);\n\tif (!gdp) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\n\tif (in_range(ext4_block_bitmap(sb, gdp), block, count) ||\n\t    in_range(ext4_inode_bitmap(sb, gdp), block, count) ||\n\t    in_range(block, ext4_inode_table(sb, gdp),\n\t\t     EXT4_SB(sb)->s_itb_per_group) ||\n\t    in_range(block + count - 1, ext4_inode_table(sb, gdp),\n\t\t     EXT4_SB(sb)->s_itb_per_group)) {\n\n\t\text4_error(sb, \"Freeing blocks in system zone - \"\n\t\t\t   \"Block = %llu, count = %lu\", block, count);\n\t\t/* err = 0. ext4_std_error should be a no op */\n\t\tgoto error_return;\n\t}\n\n\tBUFFER_TRACE(bitmap_bh, \"getting write access\");\n\terr = ext4_journal_get_write_access(handle, bitmap_bh);\n\tif (err)\n\t\tgoto error_return;\n\n\t/*\n\t * We are about to modify some metadata.  Call the journal APIs\n\t * to unshare ->b_data if a currently-committing transaction is\n\t * using it\n\t */\n\tBUFFER_TRACE(gd_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, gd_bh);\n\tif (err)\n\t\tgoto error_return;\n#ifdef AGGRESSIVE_CHECK\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < count_clusters; i++)\n\t\t\tBUG_ON(!mb_test_bit(bit + i, bitmap_bh->b_data));\n\t}\n#endif\n\ttrace_ext4_mballoc_free(sb, inode, block_group, bit, count_clusters);\n\n\terr = ext4_mb_load_buddy(sb, block_group, &e4b);\n\tif (err)\n\t\tgoto error_return;\n\n\tif ((flags & EXT4_FREE_BLOCKS_METADATA) && ext4_handle_valid(handle)) {\n\t\tstruct ext4_free_data *new_entry;\n\t\t/*\n\t\t * blocks being freed are metadata. these blocks shouldn't\n\t\t * be used until this transaction is committed\n\t\t */\n\tretry:\n\t\tnew_entry = kmem_cache_alloc(ext4_free_data_cachep, GFP_NOFS);\n\t\tif (!new_entry) {\n\t\t\t/*\n\t\t\t * We use a retry loop because\n\t\t\t * ext4_free_blocks() is not allowed to fail.\n\t\t\t */\n\t\t\tcond_resched();\n\t\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t\t\tgoto retry;\n\t\t}\n\t\tnew_entry->efd_start_cluster = bit;\n\t\tnew_entry->efd_group = block_group;\n\t\tnew_entry->efd_count = count_clusters;\n\t\tnew_entry->efd_tid = handle->h_transaction->t_tid;\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\text4_mb_free_metadata(handle, &e4b, new_entry);\n\t} else {\n\t\t/* need to update group_info->bb_free and bitmap\n\t\t * with group lock held. generate_buddy look at\n\t\t * them with group lock_held\n\t\t */\n\t\tif (test_opt(sb, DISCARD)) {\n\t\t\terr = ext4_issue_discard(sb, block_group, bit, count);\n\t\t\tif (err && err != -EOPNOTSUPP)\n\t\t\t\text4_msg(sb, KERN_WARNING, \"discard request in\"\n\t\t\t\t\t \" group:%d block:%d count:%lu failed\"\n\t\t\t\t\t \" with %d\", block_group, bit, count,\n\t\t\t\t\t err);\n\t\t} else\n\t\t\tEXT4_MB_GRP_CLEAR_TRIMMED(e4b.bd_info);\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\tmb_free_blocks(inode, &e4b, bit, count_clusters);\n\t}\n\n\tret = ext4_free_group_clusters(sb, gdp) + count_clusters;\n\text4_free_group_clusters_set(sb, gdp, ret);\n\text4_block_bitmap_csum_set(sb, block_group, gdp, bitmap_bh);\n\text4_group_desc_csum_set(sb, block_group, gdp);\n\text4_unlock_group(sb, block_group);\n\n\tif (sbi->s_log_groups_per_flex) {\n\t\text4_group_t flex_group = ext4_flex_group(sbi, block_group);\n\t\tatomic64_add(count_clusters,\n\t\t\t     &sbi->s_flex_groups[flex_group].free_clusters);\n\t}\n\n\tif (!(flags & EXT4_FREE_BLOCKS_NO_QUOT_UPDATE))\n\t\tdquot_free_block(inode, EXT4_C2B(sbi, count_clusters));\n\tpercpu_counter_add(&sbi->s_freeclusters_counter, count_clusters);\n\n\text4_mb_unload_buddy(&e4b);\n\n\t/* We dirtied the bitmap block */\n\tBUFFER_TRACE(bitmap_bh, \"dirtied bitmap block\");\n\terr = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);\n\n\t/* And the group descriptor block */\n\tBUFFER_TRACE(gd_bh, \"dirtied group descriptor block\");\n\tret = ext4_handle_dirty_metadata(handle, NULL, gd_bh);\n\tif (!err)\n\t\terr = ret;\n\n\tif (overflow && !err) {\n\t\tblock += count;\n\t\tcount = overflow;\n\t\tput_bh(bitmap_bh);\n\t\tgoto do_more;\n\t}\nerror_return:\n\tbrelse(bitmap_bh);\n\text4_std_error(sb, err);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!new_bh"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "block"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_idebug",
          "args": [
            "inode",
            "\"creating block %llu\"",
            "(unsigned long long)block"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "block > EXT4_MAX_BLOCK_FILE_PHYS"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_flag",
          "args": [
            "inode",
            "EXT4_INODE_EXTENTS"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_new_meta_blocks",
          "args": [
            "handle",
            "inode",
            "goal",
            "0",
            "NULL",
            "&error"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_new_meta_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "622-650",
          "snippet": "ext4_fsblk_t ext4_new_meta_blocks(handle_t *handle, struct inode *inode,\n\t\t\t\t  ext4_fsblk_t goal, unsigned int flags,\n\t\t\t\t  unsigned long *count, int *errp)\n{\n\tstruct ext4_allocation_request ar;\n\text4_fsblk_t ret;\n\n\tmemset(&ar, 0, sizeof(ar));\n\t/* Fill with neighbour allocated blocks */\n\tar.inode = inode;\n\tar.goal = goal;\n\tar.len = count ? *count : 1;\n\tar.flags = flags;\n\n\tret = ext4_mb_new_blocks(handle, &ar, errp);\n\tif (count)\n\t\t*count = ar.len;\n\t/*\n\t * Account for the allocated meta blocks.  We will never\n\t * fail EDQUOT for metdata, but we do account for it.\n\t */\n\tif (!(*errp) && (flags & EXT4_MB_DELALLOC_RESERVED)) {\n\t\tspin_lock(&EXT4_I(inode)->i_block_reservation_lock);\n\t\tspin_unlock(&EXT4_I(inode)->i_block_reservation_lock);\n\t\tdquot_alloc_block_nofail(inode,\n\t\t\t\tEXT4_C2B(EXT4_SB(inode->i_sb), ar.len));\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\next4_fsblk_t ext4_new_meta_blocks(handle_t *handle, struct inode *inode,\n\t\t\t\t  ext4_fsblk_t goal, unsigned int flags,\n\t\t\t\t  unsigned long *count, int *errp)\n{\n\tstruct ext4_allocation_request ar;\n\text4_fsblk_t ret;\n\n\tmemset(&ar, 0, sizeof(ar));\n\t/* Fill with neighbour allocated blocks */\n\tar.inode = inode;\n\tar.goal = goal;\n\tar.len = count ? *count : 1;\n\tar.flags = flags;\n\n\tret = ext4_mb_new_blocks(handle, &ar, errp);\n\tif (count)\n\t\t*count = ar.len;\n\t/*\n\t * Account for the allocated meta blocks.  We will never\n\t * fail EDQUOT for metdata, but we do account for it.\n\t */\n\tif (!(*errp) && (flags & EXT4_MB_DELALLOC_RESERVED)) {\n\t\tspin_lock(&EXT4_I(inode)->i_block_reservation_lock);\n\t\tspin_unlock(&EXT4_I(inode)->i_block_reservation_lock);\n\t\tdquot_alloc_block_nofail(inode,\n\t\t\t\tEXT4_C2B(EXT4_SB(inode->i_sb), ar.len));\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_flag",
          "args": [
            "inode",
            "EXT4_INODE_EXTENTS"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_group_first_block_no",
          "args": [
            "sb",
            "EXT4_I(inode)->i_block_group"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_group_first_block_no",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1831-1836",
          "snippet": "static inline ext4_fsblk_t\next4_group_first_block_no(struct super_block *sb, ext4_group_t group_no)\n{\n\treturn group_no * (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline ext4_fsblk_t\next4_group_first_block_no(struct super_block *sb, ext4_group_t group_no)\n{\n\treturn group_no * (ext4_fsblk_t)EXT4_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_first_data_block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "new_bh"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_bdebug",
          "args": [
            "bs->bh",
            "\"keeping this block\""
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_bdebug",
          "args": [
            "new_bh",
            "\"reusing; refcount now=%d\"",
            "le32_to_cpu(BHDR(new_bh)->h_refcount)"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "BHDR(new_bh)->h_refcount"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BHDR",
          "args": [
            "new_bh"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&BHDR(new_bh)->h_refcount",
            "1"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BHDR",
          "args": [
            "new_bh"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "new_bh"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "new_bh",
            "\"get_write_access\""
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_alloc_block",
          "args": [
            "inode",
            "EXT4_C2B(EXT4_SB(sb), 1)"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_C2B",
          "args": [
            "EXT4_SB(sb)",
            "1"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_bdebug",
          "args": [
            "new_bh",
            "\"keeping\""
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_xattr_cache_find",
          "args": [
            "inode",
            "header(s->base)",
            "&ce"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_cache_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "1606-1646",
          "snippet": "static struct buffer_head *\next4_xattr_cache_find(struct inode *inode, struct ext4_xattr_header *header,\n\t\t      struct mb_cache_entry **pce)\n{\n\t__u32 hash = le32_to_cpu(header->h_hash);\n\tstruct mb_cache_entry *ce;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\n\tif (!header->h_hash)\n\t\treturn NULL;  /* never share */\n\tea_idebug(inode, \"looking for cached blocks [%x]\", (int)hash);\nagain:\n\tce = mb_cache_entry_find_first(ext4_mb_cache, inode->i_sb->s_bdev,\n\t\t\t\t       hash);\n\twhile (ce) {\n\t\tstruct buffer_head *bh;\n\n\t\tif (IS_ERR(ce)) {\n\t\t\tif (PTR_ERR(ce) == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tbreak;\n\t\t}\n\t\tbh = sb_bread(inode->i_sb, ce->e_block);\n\t\tif (!bh) {\n\t\t\tEXT4_ERROR_INODE(inode, \"block %lu read error\",\n\t\t\t\t\t (unsigned long) ce->e_block);\n\t\t} else if (le32_to_cpu(BHDR(bh)->h_refcount) >=\n\t\t\t\tEXT4_XATTR_REFCOUNT_MAX) {\n\t\t\tea_idebug(inode, \"block %lu refcount %d>=%d\",\n\t\t\t\t  (unsigned long) ce->e_block,\n\t\t\t\t  le32_to_cpu(BHDR(bh)->h_refcount),\n\t\t\t\t\t  EXT4_XATTR_REFCOUNT_MAX);\n\t\t} else if (ext4_xattr_cmp(header, BHDR(bh)) == 0) {\n\t\t\t*pce = ce;\n\t\t\treturn bh;\n\t\t}\n\t\tbrelse(bh);\n\t\tce = mb_cache_entry_find_next(ce, inode->i_sb->s_bdev, hash);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);",
            "static struct buffer_head *ext4_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext4_xattr_header *,\n\t\t\t\t\t\t struct mb_cache_entry **);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);\nstatic struct buffer_head *ext4_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext4_xattr_header *,\n\t\t\t\t\t\t struct mb_cache_entry **);\n\nstatic struct buffer_head *\next4_xattr_cache_find(struct inode *inode, struct ext4_xattr_header *header,\n\t\t      struct mb_cache_entry **pce)\n{\n\t__u32 hash = le32_to_cpu(header->h_hash);\n\tstruct mb_cache_entry *ce;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\n\tif (!header->h_hash)\n\t\treturn NULL;  /* never share */\n\tea_idebug(inode, \"looking for cached blocks [%x]\", (int)hash);\nagain:\n\tce = mb_cache_entry_find_first(ext4_mb_cache, inode->i_sb->s_bdev,\n\t\t\t\t       hash);\n\twhile (ce) {\n\t\tstruct buffer_head *bh;\n\n\t\tif (IS_ERR(ce)) {\n\t\t\tif (PTR_ERR(ce) == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tbreak;\n\t\t}\n\t\tbh = sb_bread(inode->i_sb, ce->e_block);\n\t\tif (!bh) {\n\t\t\tEXT4_ERROR_INODE(inode, \"block %lu read error\",\n\t\t\t\t\t (unsigned long) ce->e_block);\n\t\t} else if (le32_to_cpu(BHDR(bh)->h_refcount) >=\n\t\t\t\tEXT4_XATTR_REFCOUNT_MAX) {\n\t\t\tea_idebug(inode, \"block %lu refcount %d>=%d\",\n\t\t\t\t  (unsigned long) ce->e_block,\n\t\t\t\t  le32_to_cpu(BHDR(bh)->h_refcount),\n\t\t\t\t\t  EXT4_XATTR_REFCOUNT_MAX);\n\t\t} else if (ext4_xattr_cmp(header, BHDR(bh)) == 0) {\n\t\t\t*pce = ce;\n\t\t\treturn bh;\n\t\t}\n\t\tbrelse(bh);\n\t\tce = mb_cache_entry_find_next(ce, inode->i_sb->s_bdev, hash);\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "header",
          "args": [
            "s->base"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "header_in",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/util.c",
          "lines": "33-39",
          "snippet": "static void header_in(struct dlm_header *hd)\n{\n\thd->h_version\t\t= le32_to_cpu(hd->h_version);\n\thd->h_lockspace\t\t= le32_to_cpu(hd->h_lockspace);\n\thd->h_nodeid\t\t= le32_to_cpu(hd->h_nodeid);\n\thd->h_length\t\t= le16_to_cpu(hd->h_length);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"rcom.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"rcom.h\"\n#include \"dlm_internal.h\"\n\nstatic void header_in(struct dlm_header *hd)\n{\n\thd->h_version\t\t= le32_to_cpu(hd->h_version);\n\thd->h_lockspace\t\t= le32_to_cpu(hd->h_lockspace);\n\thd->h_nodeid\t\t= le32_to_cpu(hd->h_nodeid);\n\thd->h_length\t\t= le16_to_cpu(hd->h_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_LAST_ENTRY",
          "args": [
            "s->first"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_xattr_rehash",
          "args": [
            "header(s->base)",
            "s->here"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_rehash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "1692-1712",
          "snippet": "static void ext4_xattr_rehash(struct ext4_xattr_header *header,\n\t\t\t      struct ext4_xattr_entry *entry)\n{\n\tstruct ext4_xattr_entry *here;\n\t__u32 hash = 0;\n\n\text4_xattr_hash_entry(header, entry);\n\there = ENTRY(header+1);\n\twhile (!IS_LAST_ENTRY(here)) {\n\t\tif (!here->e_hash) {\n\t\t\t/* Block is not shared if an entry's hash value == 0 */\n\t\t\thash = 0;\n\t\t\tbreak;\n\t\t}\n\t\thash = (hash << BLOCK_HASH_SHIFT) ^\n\t\t       (hash >> (8*sizeof(hash) - BLOCK_HASH_SHIFT)) ^\n\t\t       le32_to_cpu(here->e_hash);\n\t\there = EXT4_XATTR_NEXT(here);\n\t}\n\theader->h_hash = cpu_to_le32(hash);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define BLOCK_HASH_SHIFT 16"
          ],
          "globals_used": [
            "static void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\n#define BLOCK_HASH_SHIFT 16\n\nstatic void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);\n\nstatic void ext4_xattr_rehash(struct ext4_xattr_header *header,\n\t\t\t      struct ext4_xattr_entry *entry)\n{\n\tstruct ext4_xattr_entry *here;\n\t__u32 hash = 0;\n\n\text4_xattr_hash_entry(header, entry);\n\there = ENTRY(header+1);\n\twhile (!IS_LAST_ENTRY(here)) {\n\t\tif (!here->e_hash) {\n\t\t\t/* Block is not shared if an entry's hash value == 0 */\n\t\t\thash = 0;\n\t\t\tbreak;\n\t\t}\n\t\thash = (hash << BLOCK_HASH_SHIFT) ^\n\t\t       (hash >> (8*sizeof(hash) - BLOCK_HASH_SHIFT)) ^\n\t\t       le32_to_cpu(here->e_hash);\n\t\there = EXT4_XATTR_NEXT(here);\n\t}\n\theader->h_hash = cpu_to_le32(hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_LAST_ENTRY",
          "args": [
            "s->first"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_xattr_set_entry",
          "args": [
            "i",
            "s"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_set_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "618-727",
          "snippet": "static int\next4_xattr_set_entry(struct ext4_xattr_info *i, struct ext4_xattr_search *s)\n{\n\tstruct ext4_xattr_entry *last;\n\tsize_t free, min_offs = s->end - s->base, name_len = strlen(i->name);\n\n\t/* Compute min_offs and last. */\n\tlast = s->first;\n\tfor (; !IS_LAST_ENTRY(last); last = EXT4_XATTR_NEXT(last)) {\n\t\tif (!last->e_value_block && last->e_value_size) {\n\t\t\tsize_t offs = le16_to_cpu(last->e_value_offs);\n\t\t\tif (offs < min_offs)\n\t\t\t\tmin_offs = offs;\n\t\t}\n\t}\n\tfree = min_offs - ((void *)last - s->base) - sizeof(__u32);\n\tif (!s->not_found) {\n\t\tif (!s->here->e_value_block && s->here->e_value_size) {\n\t\t\tsize_t size = le32_to_cpu(s->here->e_value_size);\n\t\t\tfree += EXT4_XATTR_SIZE(size);\n\t\t}\n\t\tfree += EXT4_XATTR_LEN(name_len);\n\t}\n\tif (i->value) {\n\t\tif (free < EXT4_XATTR_SIZE(i->value_len) ||\n\t\t    free < EXT4_XATTR_LEN(name_len) +\n\t\t\t   EXT4_XATTR_SIZE(i->value_len))\n\t\t\treturn -ENOSPC;\n\t}\n\n\tif (i->value && s->not_found) {\n\t\t/* Insert the new name. */\n\t\tsize_t size = EXT4_XATTR_LEN(name_len);\n\t\tsize_t rest = (void *)last - (void *)s->here + sizeof(__u32);\n\t\tmemmove((void *)s->here + size, s->here, rest);\n\t\tmemset(s->here, 0, size);\n\t\ts->here->e_name_index = i->name_index;\n\t\ts->here->e_name_len = name_len;\n\t\tmemcpy(s->here->e_name, i->name, name_len);\n\t} else {\n\t\tif (!s->here->e_value_block && s->here->e_value_size) {\n\t\t\tvoid *first_val = s->base + min_offs;\n\t\t\tsize_t offs = le16_to_cpu(s->here->e_value_offs);\n\t\t\tvoid *val = s->base + offs;\n\t\t\tsize_t size = EXT4_XATTR_SIZE(\n\t\t\t\tle32_to_cpu(s->here->e_value_size));\n\n\t\t\tif (i->value && size == EXT4_XATTR_SIZE(i->value_len)) {\n\t\t\t\t/* The old and the new value have the same\n\t\t\t\t   size. Just replace. */\n\t\t\t\ts->here->e_value_size =\n\t\t\t\t\tcpu_to_le32(i->value_len);\n\t\t\t\tif (i->value == EXT4_ZERO_XATTR_VALUE) {\n\t\t\t\t\tmemset(val, 0, size);\n\t\t\t\t} else {\n\t\t\t\t\t/* Clear pad bytes first. */\n\t\t\t\t\tmemset(val + size - EXT4_XATTR_PAD, 0,\n\t\t\t\t\t       EXT4_XATTR_PAD);\n\t\t\t\t\tmemcpy(val, i->value, i->value_len);\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* Remove the old value. */\n\t\t\tmemmove(first_val + size, first_val, val - first_val);\n\t\t\tmemset(first_val, 0, size);\n\t\t\ts->here->e_value_size = 0;\n\t\t\ts->here->e_value_offs = 0;\n\t\t\tmin_offs += size;\n\n\t\t\t/* Adjust all value offsets. */\n\t\t\tlast = s->first;\n\t\t\twhile (!IS_LAST_ENTRY(last)) {\n\t\t\t\tsize_t o = le16_to_cpu(last->e_value_offs);\n\t\t\t\tif (!last->e_value_block &&\n\t\t\t\t    last->e_value_size && o < offs)\n\t\t\t\t\tlast->e_value_offs =\n\t\t\t\t\t\tcpu_to_le16(o + size);\n\t\t\t\tlast = EXT4_XATTR_NEXT(last);\n\t\t\t}\n\t\t}\n\t\tif (!i->value) {\n\t\t\t/* Remove the old name. */\n\t\t\tsize_t size = EXT4_XATTR_LEN(name_len);\n\t\t\tlast = ENTRY((void *)last - size);\n\t\t\tmemmove(s->here, (void *)s->here + size,\n\t\t\t\t(void *)last - (void *)s->here + sizeof(__u32));\n\t\t\tmemset(last, 0, size);\n\t\t}\n\t}\n\n\tif (i->value) {\n\t\t/* Insert the new value. */\n\t\ts->here->e_value_size = cpu_to_le32(i->value_len);\n\t\tif (i->value_len) {\n\t\t\tsize_t size = EXT4_XATTR_SIZE(i->value_len);\n\t\t\tvoid *val = s->base + min_offs - size;\n\t\t\ts->here->e_value_offs = cpu_to_le16(min_offs - size);\n\t\t\tif (i->value == EXT4_ZERO_XATTR_VALUE) {\n\t\t\t\tmemset(val, 0, size);\n\t\t\t} else {\n\t\t\t\t/* Clear the pad bytes first. */\n\t\t\t\tmemset(val + size - EXT4_XATTR_PAD, 0,\n\t\t\t\t       EXT4_XATTR_PAD);\n\t\t\t\tmemcpy(val, i->value, i->value_len);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);\n\nstatic int\next4_xattr_set_entry(struct ext4_xattr_info *i, struct ext4_xattr_search *s)\n{\n\tstruct ext4_xattr_entry *last;\n\tsize_t free, min_offs = s->end - s->base, name_len = strlen(i->name);\n\n\t/* Compute min_offs and last. */\n\tlast = s->first;\n\tfor (; !IS_LAST_ENTRY(last); last = EXT4_XATTR_NEXT(last)) {\n\t\tif (!last->e_value_block && last->e_value_size) {\n\t\t\tsize_t offs = le16_to_cpu(last->e_value_offs);\n\t\t\tif (offs < min_offs)\n\t\t\t\tmin_offs = offs;\n\t\t}\n\t}\n\tfree = min_offs - ((void *)last - s->base) - sizeof(__u32);\n\tif (!s->not_found) {\n\t\tif (!s->here->e_value_block && s->here->e_value_size) {\n\t\t\tsize_t size = le32_to_cpu(s->here->e_value_size);\n\t\t\tfree += EXT4_XATTR_SIZE(size);\n\t\t}\n\t\tfree += EXT4_XATTR_LEN(name_len);\n\t}\n\tif (i->value) {\n\t\tif (free < EXT4_XATTR_SIZE(i->value_len) ||\n\t\t    free < EXT4_XATTR_LEN(name_len) +\n\t\t\t   EXT4_XATTR_SIZE(i->value_len))\n\t\t\treturn -ENOSPC;\n\t}\n\n\tif (i->value && s->not_found) {\n\t\t/* Insert the new name. */\n\t\tsize_t size = EXT4_XATTR_LEN(name_len);\n\t\tsize_t rest = (void *)last - (void *)s->here + sizeof(__u32);\n\t\tmemmove((void *)s->here + size, s->here, rest);\n\t\tmemset(s->here, 0, size);\n\t\ts->here->e_name_index = i->name_index;\n\t\ts->here->e_name_len = name_len;\n\t\tmemcpy(s->here->e_name, i->name, name_len);\n\t} else {\n\t\tif (!s->here->e_value_block && s->here->e_value_size) {\n\t\t\tvoid *first_val = s->base + min_offs;\n\t\t\tsize_t offs = le16_to_cpu(s->here->e_value_offs);\n\t\t\tvoid *val = s->base + offs;\n\t\t\tsize_t size = EXT4_XATTR_SIZE(\n\t\t\t\tle32_to_cpu(s->here->e_value_size));\n\n\t\t\tif (i->value && size == EXT4_XATTR_SIZE(i->value_len)) {\n\t\t\t\t/* The old and the new value have the same\n\t\t\t\t   size. Just replace. */\n\t\t\t\ts->here->e_value_size =\n\t\t\t\t\tcpu_to_le32(i->value_len);\n\t\t\t\tif (i->value == EXT4_ZERO_XATTR_VALUE) {\n\t\t\t\t\tmemset(val, 0, size);\n\t\t\t\t} else {\n\t\t\t\t\t/* Clear pad bytes first. */\n\t\t\t\t\tmemset(val + size - EXT4_XATTR_PAD, 0,\n\t\t\t\t\t       EXT4_XATTR_PAD);\n\t\t\t\t\tmemcpy(val, i->value, i->value_len);\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* Remove the old value. */\n\t\t\tmemmove(first_val + size, first_val, val - first_val);\n\t\t\tmemset(first_val, 0, size);\n\t\t\ts->here->e_value_size = 0;\n\t\t\ts->here->e_value_offs = 0;\n\t\t\tmin_offs += size;\n\n\t\t\t/* Adjust all value offsets. */\n\t\t\tlast = s->first;\n\t\t\twhile (!IS_LAST_ENTRY(last)) {\n\t\t\t\tsize_t o = le16_to_cpu(last->e_value_offs);\n\t\t\t\tif (!last->e_value_block &&\n\t\t\t\t    last->e_value_size && o < offs)\n\t\t\t\t\tlast->e_value_offs =\n\t\t\t\t\t\tcpu_to_le16(o + size);\n\t\t\t\tlast = EXT4_XATTR_NEXT(last);\n\t\t\t}\n\t\t}\n\t\tif (!i->value) {\n\t\t\t/* Remove the old name. */\n\t\t\tsize_t size = EXT4_XATTR_LEN(name_len);\n\t\t\tlast = ENTRY((void *)last - size);\n\t\t\tmemmove(s->here, (void *)s->here + size,\n\t\t\t\t(void *)last - (void *)s->here + sizeof(__u32));\n\t\t\tmemset(last, 0, size);\n\t\t}\n\t}\n\n\tif (i->value) {\n\t\t/* Insert the new value. */\n\t\ts->here->e_value_size = cpu_to_le32(i->value_len);\n\t\tif (i->value_len) {\n\t\t\tsize_t size = EXT4_XATTR_SIZE(i->value_len);\n\t\t\tvoid *val = s->base + min_offs - size;\n\t\t\ts->here->e_value_offs = cpu_to_le16(min_offs - size);\n\t\t\tif (i->value == EXT4_ZERO_XATTR_VALUE) {\n\t\t\t\tmemset(val, 0, size);\n\t\t\t} else {\n\t\t\t\t/* Clear the pad bytes first. */\n\t\t\t\tmemset(val + size - EXT4_XATTR_PAD, 0,\n\t\t\t\t       EXT4_XATTR_PAD);\n\t\t\t\tmemcpy(val, i->value, i->value_len);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ENTRY",
          "args": [
            "header(s->base)+1"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY",
          "args": [
            "header(s->base)+1"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "1"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "1"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "EXT4_XATTR_MAGIC"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sb->s_blocksize",
            "GFP_NOFS"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY",
          "args": [
            "s->base + offset"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "1"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY",
          "args": [
            "header(s->base)+1"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "s->base",
            "BHDR(bs->bh)",
            "bs->bh->b_size"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BHDR",
          "args": [
            "bs->bh"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "bs->bh->b_size",
            "GFP_NOFS"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_bdebug",
          "args": [
            "bs->bh",
            "\"cloning\""
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LAST_ENTRY",
          "args": [
            "s->first"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_bdebug",
          "args": [
            "bs->bh",
            "\"modifying in-place\""
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_cache_entry_free",
          "args": [
            "ce"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "mb_cache_entry_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "637-649",
          "snippet": "void\nmb_cache_entry_free(struct mb_cache_entry *ce)\n{\n\tmb_assert(ce);\n\tmb_assert(list_empty(&ce->e_lru_list));\n\thlist_bl_lock(ce->e_index_hash_p);\n\t__mb_cache_entry_unhash_index(ce);\n\thlist_bl_unlock(ce->e_index_hash_p);\n\thlist_bl_lock(ce->e_block_hash_p);\n\t__mb_cache_entry_unhash_block(ce);\n\thlist_bl_unlock(ce->e_block_hash_p);\n\t__mb_cache_entry_release(ce);\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid\nmb_cache_entry_free(struct mb_cache_entry *ce)\n{\n\tmb_assert(ce);\n\tmb_assert(list_empty(&ce->e_lru_list));\n\thlist_bl_lock(ce->e_index_hash_p);\n\t__mb_cache_entry_unhash_index(ce);\n\thlist_bl_unlock(ce->e_index_hash_p);\n\thlist_bl_lock(ce->e_block_hash_p);\n\t__mb_cache_entry_unhash_block(ce);\n\thlist_bl_unlock(ce->e_block_hash_p);\n\t__mb_cache_entry_release(ce);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "1"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "bs->bh"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bs->bh",
            "\"get_write_access\""
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_cache_entry_get",
          "args": [
            "ext4_mb_cache",
            "bs->bh->b_bdev",
            "bs->bh->b_blocknr"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "mb_cache_entry_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "660-714",
          "snippet": "struct mb_cache_entry *\nmb_cache_entry_get(struct mb_cache *cache, struct block_device *bdev,\n\t\t   sector_t block)\n{\n\tunsigned int bucket;\n\tstruct hlist_bl_node *l;\n\tstruct mb_cache_entry *ce;\n\tstruct hlist_bl_head *block_hash_p;\n\n\tbucket = hash_long((unsigned long)bdev + (block & 0xffffffff),\n\t\t\t   cache->c_bucket_bits);\n\tblock_hash_p = &cache->c_block_hash[bucket];\n\t/* First serialize access to the block corresponding hash chain. */\n\thlist_bl_lock(block_hash_p);\n\thlist_bl_for_each_entry(ce, l, block_hash_p, e_block_list) {\n\t\tmb_assert(ce->e_block_hash_p == block_hash_p);\n\t\tif (ce->e_bdev == bdev && ce->e_block == block) {\n\t\t\t/*\n\t\t\t * Prevent a free from removing the entry.\n\t\t\t */\n\t\t\tatomic_inc(&ce->e_refcnt);\n\t\t\thlist_bl_unlock(block_hash_p);\n\t\t\t__spin_lock_mb_cache_entry(ce);\n\t\t\tatomic_dec(&ce->e_refcnt);\n\t\t\tif (ce->e_used > 0) {\n\t\t\t\tDEFINE_WAIT(wait);\n\t\t\t\twhile (ce->e_used > 0) {\n\t\t\t\t\tce->e_queued++;\n\t\t\t\t\tprepare_to_wait(&mb_cache_queue, &wait,\n\t\t\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\t\t\t\t__spin_unlock_mb_cache_entry(ce);\n\t\t\t\t\tschedule();\n\t\t\t\t\t__spin_lock_mb_cache_entry(ce);\n\t\t\t\t\tce->e_queued--;\n\t\t\t\t}\n\t\t\t\tfinish_wait(&mb_cache_queue, &wait);\n\t\t\t}\n\t\t\tce->e_used += 1 + MB_CACHE_WRITER;\n\t\t\t__spin_unlock_mb_cache_entry(ce);\n\n\t\t\tif (!list_empty(&ce->e_lru_list)) {\n\t\t\t\tspin_lock(&mb_cache_spinlock);\n\t\t\t\tlist_del_init(&ce->e_lru_list);\n\t\t\t\tspin_unlock(&mb_cache_spinlock);\n\t\t\t}\n\t\t\tif (!__mb_cache_entry_is_block_hashed(ce)) {\n\t\t\t\t__mb_cache_entry_release(ce);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn ce;\n\t\t}\n\t}\n\thlist_bl_unlock(block_hash_p);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MB_CACHE_WRITER ((unsigned short)~0U >> 1)"
          ],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(mb_cache_queue);",
            "static DEFINE_SPINLOCK(mb_cache_spinlock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\n#define MB_CACHE_WRITER ((unsigned short)~0U >> 1)\n\nstatic DECLARE_WAIT_QUEUE_HEAD(mb_cache_queue);\nstatic DEFINE_SPINLOCK(mb_cache_spinlock);\n\nstruct mb_cache_entry *\nmb_cache_entry_get(struct mb_cache *cache, struct block_device *bdev,\n\t\t   sector_t block)\n{\n\tunsigned int bucket;\n\tstruct hlist_bl_node *l;\n\tstruct mb_cache_entry *ce;\n\tstruct hlist_bl_head *block_hash_p;\n\n\tbucket = hash_long((unsigned long)bdev + (block & 0xffffffff),\n\t\t\t   cache->c_bucket_bits);\n\tblock_hash_p = &cache->c_block_hash[bucket];\n\t/* First serialize access to the block corresponding hash chain. */\n\thlist_bl_lock(block_hash_p);\n\thlist_bl_for_each_entry(ce, l, block_hash_p, e_block_list) {\n\t\tmb_assert(ce->e_block_hash_p == block_hash_p);\n\t\tif (ce->e_bdev == bdev && ce->e_block == block) {\n\t\t\t/*\n\t\t\t * Prevent a free from removing the entry.\n\t\t\t */\n\t\t\tatomic_inc(&ce->e_refcnt);\n\t\t\thlist_bl_unlock(block_hash_p);\n\t\t\t__spin_lock_mb_cache_entry(ce);\n\t\t\tatomic_dec(&ce->e_refcnt);\n\t\t\tif (ce->e_used > 0) {\n\t\t\t\tDEFINE_WAIT(wait);\n\t\t\t\twhile (ce->e_used > 0) {\n\t\t\t\t\tce->e_queued++;\n\t\t\t\t\tprepare_to_wait(&mb_cache_queue, &wait,\n\t\t\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\t\t\t\t__spin_unlock_mb_cache_entry(ce);\n\t\t\t\t\tschedule();\n\t\t\t\t\t__spin_lock_mb_cache_entry(ce);\n\t\t\t\t\tce->e_queued--;\n\t\t\t\t}\n\t\t\t\tfinish_wait(&mb_cache_queue, &wait);\n\t\t\t}\n\t\t\tce->e_used += 1 + MB_CACHE_WRITER;\n\t\t\t__spin_unlock_mb_cache_entry(ce);\n\n\t\t\tif (!list_empty(&ce->e_lru_list)) {\n\t\t\t\tspin_lock(&mb_cache_spinlock);\n\t\t\t\tlist_del_init(&ce->e_lru_list);\n\t\t\t\tspin_unlock(&mb_cache_spinlock);\n\t\t\t}\n\t\t\tif (!__mb_cache_entry_is_block_hashed(ce)) {\n\t\t\t\t__mb_cache_entry_release(ce);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn ce;\n\t\t}\n\t}\n\thlist_bl_unlock(block_hash_p);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_GET_MB_CACHE",
          "args": [
            "inode"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);\nstatic struct buffer_head *ext4_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext4_xattr_header *,\n\t\t\t\t\t\t struct mb_cache_entry **);\n\nstatic int\next4_xattr_block_set(handle_t *handle, struct inode *inode,\n\t\t     struct ext4_xattr_info *i,\n\t\t     struct ext4_xattr_block_find *bs)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ext4_xattr_search *s = &bs->s;\n\tstruct mb_cache_entry *ce = NULL;\n\tint error = 0;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\n#define header(x) ((struct ext4_xattr_header *)(x))\n\n\tif (i->value && i->value_len > sb->s_blocksize)\n\t\treturn -ENOSPC;\n\tif (s->base) {\n\t\tce = mb_cache_entry_get(ext4_mb_cache, bs->bh->b_bdev,\n\t\t\t\t\tbs->bh->b_blocknr);\n\t\tBUFFER_TRACE(bs->bh, \"get_write_access\");\n\t\terror = ext4_journal_get_write_access(handle, bs->bh);\n\t\tif (error)\n\t\t\tgoto cleanup;\n\t\tlock_buffer(bs->bh);\n\n\t\tif (header(s->base)->h_refcount == cpu_to_le32(1)) {\n\t\t\tif (ce) {\n\t\t\t\tmb_cache_entry_free(ce);\n\t\t\t\tce = NULL;\n\t\t\t}\n\t\t\tea_bdebug(bs->bh, \"modifying in-place\");\n\t\t\terror = ext4_xattr_set_entry(i, s);\n\t\t\tif (!error) {\n\t\t\t\tif (!IS_LAST_ENTRY(s->first))\n\t\t\t\t\text4_xattr_rehash(header(s->base),\n\t\t\t\t\t\t\t  s->here);\n\t\t\t\text4_xattr_cache_insert(ext4_mb_cache,\n\t\t\t\t\tbs->bh);\n\t\t\t}\n\t\t\tunlock_buffer(bs->bh);\n\t\t\tif (error == -EIO)\n\t\t\t\tgoto bad_block;\n\t\t\tif (!error)\n\t\t\t\terror = ext4_handle_dirty_xattr_block(handle,\n\t\t\t\t\t\t\t\t      inode,\n\t\t\t\t\t\t\t\t      bs->bh);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t\tgoto inserted;\n\t\t} else {\n\t\t\tint offset = (char *)s->here - bs->bh->b_data;\n\n\t\t\tunlock_buffer(bs->bh);\n\t\t\tif (ce) {\n\t\t\t\tmb_cache_entry_release(ce);\n\t\t\t\tce = NULL;\n\t\t\t}\n\t\t\tea_bdebug(bs->bh, \"cloning\");\n\t\t\ts->base = kmalloc(bs->bh->b_size, GFP_NOFS);\n\t\t\terror = -ENOMEM;\n\t\t\tif (s->base == NULL)\n\t\t\t\tgoto cleanup;\n\t\t\tmemcpy(s->base, BHDR(bs->bh), bs->bh->b_size);\n\t\t\ts->first = ENTRY(header(s->base)+1);\n\t\t\theader(s->base)->h_refcount = cpu_to_le32(1);\n\t\t\ts->here = ENTRY(s->base + offset);\n\t\t\ts->end = s->base + bs->bh->b_size;\n\t\t}\n\t} else {\n\t\t/* Allocate a buffer where we construct the new block. */\n\t\ts->base = kzalloc(sb->s_blocksize, GFP_NOFS);\n\t\t/* assert(header == s->base) */\n\t\terror = -ENOMEM;\n\t\tif (s->base == NULL)\n\t\t\tgoto cleanup;\n\t\theader(s->base)->h_magic = cpu_to_le32(EXT4_XATTR_MAGIC);\n\t\theader(s->base)->h_blocks = cpu_to_le32(1);\n\t\theader(s->base)->h_refcount = cpu_to_le32(1);\n\t\ts->first = ENTRY(header(s->base)+1);\n\t\ts->here = ENTRY(header(s->base)+1);\n\t\ts->end = s->base + sb->s_blocksize;\n\t}\n\n\terror = ext4_xattr_set_entry(i, s);\n\tif (error == -EIO)\n\t\tgoto bad_block;\n\tif (error)\n\t\tgoto cleanup;\n\tif (!IS_LAST_ENTRY(s->first))\n\t\text4_xattr_rehash(header(s->base), s->here);\n\ninserted:\n\tif (!IS_LAST_ENTRY(s->first)) {\n\t\tnew_bh = ext4_xattr_cache_find(inode, header(s->base), &ce);\n\t\tif (new_bh) {\n\t\t\t/* We found an identical block in the cache. */\n\t\t\tif (new_bh == bs->bh)\n\t\t\t\tea_bdebug(new_bh, \"keeping\");\n\t\t\telse {\n\t\t\t\t/* The old block is released after updating\n\t\t\t\t   the inode. */\n\t\t\t\terror = dquot_alloc_block(inode,\n\t\t\t\t\t\tEXT4_C2B(EXT4_SB(sb), 1));\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup;\n\t\t\t\tBUFFER_TRACE(new_bh, \"get_write_access\");\n\t\t\t\terror = ext4_journal_get_write_access(handle,\n\t\t\t\t\t\t\t\t      new_bh);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup_dquot;\n\t\t\t\tlock_buffer(new_bh);\n\t\t\t\tle32_add_cpu(&BHDR(new_bh)->h_refcount, 1);\n\t\t\t\tea_bdebug(new_bh, \"reusing; refcount now=%d\",\n\t\t\t\t\tle32_to_cpu(BHDR(new_bh)->h_refcount));\n\t\t\t\tunlock_buffer(new_bh);\n\t\t\t\terror = ext4_handle_dirty_xattr_block(handle,\n\t\t\t\t\t\t\t\t      inode,\n\t\t\t\t\t\t\t\t      new_bh);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup_dquot;\n\t\t\t}\n\t\t\tmb_cache_entry_release(ce);\n\t\t\tce = NULL;\n\t\t} else if (bs->bh && s->base == bs->bh->b_data) {\n\t\t\t/* We were modifying this block in-place. */\n\t\t\tea_bdebug(bs->bh, \"keeping this block\");\n\t\t\tnew_bh = bs->bh;\n\t\t\tget_bh(new_bh);\n\t\t} else {\n\t\t\t/* We need to allocate a new block */\n\t\t\text4_fsblk_t goal, block;\n\n\t\t\tgoal = ext4_group_first_block_no(sb,\n\t\t\t\t\t\tEXT4_I(inode)->i_block_group);\n\n\t\t\t/* non-extent files can't have physical blocks past 2^32 */\n\t\t\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\t\t\tgoal = goal & EXT4_MAX_BLOCK_FILE_PHYS;\n\n\t\t\tblock = ext4_new_meta_blocks(handle, inode, goal, 0,\n\t\t\t\t\t\t     NULL, &error);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\n\t\t\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\t\t\tBUG_ON(block > EXT4_MAX_BLOCK_FILE_PHYS);\n\n\t\t\tea_idebug(inode, \"creating block %llu\",\n\t\t\t\t  (unsigned long long)block);\n\n\t\t\tnew_bh = sb_getblk(sb, block);\n\t\t\tif (unlikely(!new_bh)) {\n\t\t\t\terror = -ENOMEM;\ngetblk_failed:\n\t\t\t\text4_free_blocks(handle, inode, NULL, block, 1,\n\t\t\t\t\t\t EXT4_FREE_BLOCKS_METADATA);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tlock_buffer(new_bh);\n\t\t\terror = ext4_journal_get_create_access(handle, new_bh);\n\t\t\tif (error) {\n\t\t\t\tunlock_buffer(new_bh);\n\t\t\t\terror = -EIO;\n\t\t\t\tgoto getblk_failed;\n\t\t\t}\n\t\t\tmemcpy(new_bh->b_data, s->base, new_bh->b_size);\n\t\t\tset_buffer_uptodate(new_bh);\n\t\t\tunlock_buffer(new_bh);\n\t\t\text4_xattr_cache_insert(ext4_mb_cache, new_bh);\n\t\t\terror = ext4_handle_dirty_xattr_block(handle,\n\t\t\t\t\t\t\t      inode, new_bh);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t/* Update the inode. */\n\tEXT4_I(inode)->i_file_acl = new_bh ? new_bh->b_blocknr : 0;\n\n\t/* Drop the previous xattr block. */\n\tif (bs->bh && bs->bh != new_bh)\n\t\text4_xattr_release_block(handle, inode, bs->bh);\n\terror = 0;\n\ncleanup:\n\tif (ce)\n\t\tmb_cache_entry_release(ce);\n\tbrelse(new_bh);\n\tif (!(bs->bh && s->base == bs->bh->b_data))\n\t\tkfree(s->base);\n\n\treturn error;\n\ncleanup_dquot:\n\tdquot_free_block(inode, EXT4_C2B(EXT4_SB(sb), 1));\n\tgoto cleanup;\n\nbad_block:\n\tEXT4_ERROR_INODE(inode, \"bad block %llu\",\n\t\t\t EXT4_I(inode)->i_file_acl);\n\tgoto cleanup;\n\n#undef header\n}"
  },
  {
    "function_name": "ext4_xattr_block_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
    "lines": "734-774",
    "snippet": "static int\next4_xattr_block_find(struct inode *inode, struct ext4_xattr_info *i,\n\t\t      struct ext4_xattr_block_find *bs)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint error;\n\n\tea_idebug(inode, \"name=%d.%s, value=%p, value_len=%ld\",\n\t\t  i->name_index, i->name, i->value, (long)i->value_len);\n\n\tif (EXT4_I(inode)->i_file_acl) {\n\t\t/* The inode already has an extended attribute block. */\n\t\tbs->bh = sb_bread(sb, EXT4_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tif (!bs->bh)\n\t\t\tgoto cleanup;\n\t\tea_bdebug(bs->bh, \"b_count=%d, refcount=%d\",\n\t\t\tatomic_read(&(bs->bh->b_count)),\n\t\t\tle32_to_cpu(BHDR(bs->bh)->h_refcount));\n\t\tif (ext4_xattr_check_block(inode, bs->bh)) {\n\t\t\tEXT4_ERROR_INODE(inode, \"bad block %llu\",\n\t\t\t\t\t EXT4_I(inode)->i_file_acl);\n\t\t\terror = -EIO;\n\t\t\tgoto cleanup;\n\t\t}\n\t\t/* Find the named attribute. */\n\t\tbs->s.base = BHDR(bs->bh);\n\t\tbs->s.first = BFIRST(bs->bh);\n\t\tbs->s.end = bs->bh->b_data + bs->bh->b_size;\n\t\tbs->s.here = bs->s.first;\n\t\terror = ext4_xattr_find_entry(&bs->s.here, i->name_index,\n\t\t\t\t\t      i->name, bs->bh->b_size, 1);\n\t\tif (error && error != -ENODATA)\n\t\t\tgoto cleanup;\n\t\tbs->s.not_found = error;\n\t}\n\terror = 0;\n\ncleanup:\n\treturn error;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_xattr_find_entry",
          "args": [
            "&bs->s.here",
            "i->name_index",
            "i->name",
            "bs->bh->b_size",
            "1"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "247-272",
          "snippet": "static int\next4_xattr_find_entry(struct ext4_xattr_entry **pentry, int name_index,\n\t\t      const char *name, size_t size, int sorted)\n{\n\tstruct ext4_xattr_entry *entry;\n\tsize_t name_len;\n\tint cmp = 1;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\tname_len = strlen(name);\n\tentry = *pentry;\n\tfor (; !IS_LAST_ENTRY(entry); entry = EXT4_XATTR_NEXT(entry)) {\n\t\tcmp = name_index - entry->e_name_index;\n\t\tif (!cmp)\n\t\t\tcmp = name_len - entry->e_name_len;\n\t\tif (!cmp)\n\t\t\tcmp = memcmp(name, entry->e_name, name_len);\n\t\tif (cmp <= 0 && (sorted || cmp == 0))\n\t\t\tbreak;\n\t}\n\t*pentry = entry;\n\tif (!cmp && ext4_xattr_check_entry(entry, size))\n\t\t\treturn -EIO;\n\treturn cmp ? -ENODATA : 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);\n\nstatic int\next4_xattr_find_entry(struct ext4_xattr_entry **pentry, int name_index,\n\t\t      const char *name, size_t size, int sorted)\n{\n\tstruct ext4_xattr_entry *entry;\n\tsize_t name_len;\n\tint cmp = 1;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\tname_len = strlen(name);\n\tentry = *pentry;\n\tfor (; !IS_LAST_ENTRY(entry); entry = EXT4_XATTR_NEXT(entry)) {\n\t\tcmp = name_index - entry->e_name_index;\n\t\tif (!cmp)\n\t\t\tcmp = name_len - entry->e_name_len;\n\t\tif (!cmp)\n\t\t\tcmp = memcmp(name, entry->e_name, name_len);\n\t\tif (cmp <= 0 && (sorted || cmp == 0))\n\t\t\tbreak;\n\t}\n\t*pentry = entry;\n\tif (!cmp && ext4_xattr_check_entry(entry, size))\n\t\t\treturn -EIO;\n\treturn cmp ? -ENODATA : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BFIRST",
          "args": [
            "bs->bh"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BHDR",
          "args": [
            "bs->bh"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_ERROR_INODE",
          "args": [
            "inode",
            "\"bad block %llu\"",
            "EXT4_I(inode)->i_file_acl"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_xattr_check_block",
          "args": [
            "inode",
            "bs->bh"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_check_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "216-234",
          "snippet": "static inline int\next4_xattr_check_block(struct inode *inode, struct buffer_head *bh)\n{\n\tint error;\n\n\tif (buffer_verified(bh))\n\t\treturn 0;\n\n\tif (BHDR(bh)->h_magic != cpu_to_le32(EXT4_XATTR_MAGIC) ||\n\t    BHDR(bh)->h_blocks != cpu_to_le32(1))\n\t\treturn -EIO;\n\tif (!ext4_xattr_block_csum_verify(inode, bh->b_blocknr, BHDR(bh)))\n\t\treturn -EIO;\n\terror = ext4_xattr_check_names(BFIRST(bh), bh->b_data + bh->b_size,\n\t\t\t\t       bh->b_data);\n\tif (!error)\n\t\tset_buffer_verified(bh);\n\treturn error;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);\n\nstatic inline int\next4_xattr_check_block(struct inode *inode, struct buffer_head *bh)\n{\n\tint error;\n\n\tif (buffer_verified(bh))\n\t\treturn 0;\n\n\tif (BHDR(bh)->h_magic != cpu_to_le32(EXT4_XATTR_MAGIC) ||\n\t    BHDR(bh)->h_blocks != cpu_to_le32(1))\n\t\treturn -EIO;\n\tif (!ext4_xattr_block_csum_verify(inode, bh->b_blocknr, BHDR(bh)))\n\t\treturn -EIO;\n\terror = ext4_xattr_check_names(BFIRST(bh), bh->b_data + bh->b_size,\n\t\t\t\t       bh->b_data);\n\tif (!error)\n\t\tset_buffer_verified(bh);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_bdebug",
          "args": [
            "bs->bh",
            "\"b_count=%d, refcount=%d\"",
            "atomic_read(&(bs->bh->b_count))",
            "le32_to_cpu(BHDR(bs->bh)->h_refcount)"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "BHDR(bs->bh)->h_refcount"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BHDR",
          "args": [
            "bs->bh"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&(bs->bh->b_count)"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "EXT4_I(inode)->i_file_acl"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_idebug",
          "args": [
            "inode",
            "\"name=%d.%s, value=%p, value_len=%ld\"",
            "i->name_index",
            "i->name",
            "i->value",
            "(long)i->value_len"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic int\next4_xattr_block_find(struct inode *inode, struct ext4_xattr_info *i,\n\t\t      struct ext4_xattr_block_find *bs)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint error;\n\n\tea_idebug(inode, \"name=%d.%s, value=%p, value_len=%ld\",\n\t\t  i->name_index, i->name, i->value, (long)i->value_len);\n\n\tif (EXT4_I(inode)->i_file_acl) {\n\t\t/* The inode already has an extended attribute block. */\n\t\tbs->bh = sb_bread(sb, EXT4_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tif (!bs->bh)\n\t\t\tgoto cleanup;\n\t\tea_bdebug(bs->bh, \"b_count=%d, refcount=%d\",\n\t\t\tatomic_read(&(bs->bh->b_count)),\n\t\t\tle32_to_cpu(BHDR(bs->bh)->h_refcount));\n\t\tif (ext4_xattr_check_block(inode, bs->bh)) {\n\t\t\tEXT4_ERROR_INODE(inode, \"bad block %llu\",\n\t\t\t\t\t EXT4_I(inode)->i_file_acl);\n\t\t\terror = -EIO;\n\t\t\tgoto cleanup;\n\t\t}\n\t\t/* Find the named attribute. */\n\t\tbs->s.base = BHDR(bs->bh);\n\t\tbs->s.first = BFIRST(bs->bh);\n\t\tbs->s.end = bs->bh->b_data + bs->bh->b_size;\n\t\tbs->s.here = bs->s.first;\n\t\terror = ext4_xattr_find_entry(&bs->s.here, i->name_index,\n\t\t\t\t\t      i->name, bs->bh->b_size, 1);\n\t\tif (error && error != -ENODATA)\n\t\t\tgoto cleanup;\n\t\tbs->s.not_found = error;\n\t}\n\terror = 0;\n\ncleanup:\n\treturn error;\n}"
  },
  {
    "function_name": "ext4_xattr_set_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
    "lines": "618-727",
    "snippet": "static int\next4_xattr_set_entry(struct ext4_xattr_info *i, struct ext4_xattr_search *s)\n{\n\tstruct ext4_xattr_entry *last;\n\tsize_t free, min_offs = s->end - s->base, name_len = strlen(i->name);\n\n\t/* Compute min_offs and last. */\n\tlast = s->first;\n\tfor (; !IS_LAST_ENTRY(last); last = EXT4_XATTR_NEXT(last)) {\n\t\tif (!last->e_value_block && last->e_value_size) {\n\t\t\tsize_t offs = le16_to_cpu(last->e_value_offs);\n\t\t\tif (offs < min_offs)\n\t\t\t\tmin_offs = offs;\n\t\t}\n\t}\n\tfree = min_offs - ((void *)last - s->base) - sizeof(__u32);\n\tif (!s->not_found) {\n\t\tif (!s->here->e_value_block && s->here->e_value_size) {\n\t\t\tsize_t size = le32_to_cpu(s->here->e_value_size);\n\t\t\tfree += EXT4_XATTR_SIZE(size);\n\t\t}\n\t\tfree += EXT4_XATTR_LEN(name_len);\n\t}\n\tif (i->value) {\n\t\tif (free < EXT4_XATTR_SIZE(i->value_len) ||\n\t\t    free < EXT4_XATTR_LEN(name_len) +\n\t\t\t   EXT4_XATTR_SIZE(i->value_len))\n\t\t\treturn -ENOSPC;\n\t}\n\n\tif (i->value && s->not_found) {\n\t\t/* Insert the new name. */\n\t\tsize_t size = EXT4_XATTR_LEN(name_len);\n\t\tsize_t rest = (void *)last - (void *)s->here + sizeof(__u32);\n\t\tmemmove((void *)s->here + size, s->here, rest);\n\t\tmemset(s->here, 0, size);\n\t\ts->here->e_name_index = i->name_index;\n\t\ts->here->e_name_len = name_len;\n\t\tmemcpy(s->here->e_name, i->name, name_len);\n\t} else {\n\t\tif (!s->here->e_value_block && s->here->e_value_size) {\n\t\t\tvoid *first_val = s->base + min_offs;\n\t\t\tsize_t offs = le16_to_cpu(s->here->e_value_offs);\n\t\t\tvoid *val = s->base + offs;\n\t\t\tsize_t size = EXT4_XATTR_SIZE(\n\t\t\t\tle32_to_cpu(s->here->e_value_size));\n\n\t\t\tif (i->value && size == EXT4_XATTR_SIZE(i->value_len)) {\n\t\t\t\t/* The old and the new value have the same\n\t\t\t\t   size. Just replace. */\n\t\t\t\ts->here->e_value_size =\n\t\t\t\t\tcpu_to_le32(i->value_len);\n\t\t\t\tif (i->value == EXT4_ZERO_XATTR_VALUE) {\n\t\t\t\t\tmemset(val, 0, size);\n\t\t\t\t} else {\n\t\t\t\t\t/* Clear pad bytes first. */\n\t\t\t\t\tmemset(val + size - EXT4_XATTR_PAD, 0,\n\t\t\t\t\t       EXT4_XATTR_PAD);\n\t\t\t\t\tmemcpy(val, i->value, i->value_len);\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* Remove the old value. */\n\t\t\tmemmove(first_val + size, first_val, val - first_val);\n\t\t\tmemset(first_val, 0, size);\n\t\t\ts->here->e_value_size = 0;\n\t\t\ts->here->e_value_offs = 0;\n\t\t\tmin_offs += size;\n\n\t\t\t/* Adjust all value offsets. */\n\t\t\tlast = s->first;\n\t\t\twhile (!IS_LAST_ENTRY(last)) {\n\t\t\t\tsize_t o = le16_to_cpu(last->e_value_offs);\n\t\t\t\tif (!last->e_value_block &&\n\t\t\t\t    last->e_value_size && o < offs)\n\t\t\t\t\tlast->e_value_offs =\n\t\t\t\t\t\tcpu_to_le16(o + size);\n\t\t\t\tlast = EXT4_XATTR_NEXT(last);\n\t\t\t}\n\t\t}\n\t\tif (!i->value) {\n\t\t\t/* Remove the old name. */\n\t\t\tsize_t size = EXT4_XATTR_LEN(name_len);\n\t\t\tlast = ENTRY((void *)last - size);\n\t\t\tmemmove(s->here, (void *)s->here + size,\n\t\t\t\t(void *)last - (void *)s->here + sizeof(__u32));\n\t\t\tmemset(last, 0, size);\n\t\t}\n\t}\n\n\tif (i->value) {\n\t\t/* Insert the new value. */\n\t\ts->here->e_value_size = cpu_to_le32(i->value_len);\n\t\tif (i->value_len) {\n\t\t\tsize_t size = EXT4_XATTR_SIZE(i->value_len);\n\t\t\tvoid *val = s->base + min_offs - size;\n\t\t\ts->here->e_value_offs = cpu_to_le16(min_offs - size);\n\t\t\tif (i->value == EXT4_ZERO_XATTR_VALUE) {\n\t\t\t\tmemset(val, 0, size);\n\t\t\t} else {\n\t\t\t\t/* Clear the pad bytes first. */\n\t\t\t\tmemset(val + size - EXT4_XATTR_PAD, 0,\n\t\t\t\t       EXT4_XATTR_PAD);\n\t\t\t\tmemcpy(val, i->value, i->value_len);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "val",
            "i->value",
            "i->value_len"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "val + size - EXT4_XATTR_PAD",
            "0",
            "EXT4_XATTR_PAD"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "val",
            "0",
            "size"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "min_offs - size"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_XATTR_SIZE",
          "args": [
            "i->value_len"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "i->value_len"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "last",
            "0",
            "size"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "s->here",
            "(void *)s->here + size",
            "(void *)last - (void *)s->here + sizeof(__u32)"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENTRY",
          "args": [
            "(void *)last - size"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_XATTR_LEN",
          "args": [
            "name_len"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_XATTR_NEXT",
          "args": [
            "last"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "o + size"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "last->e_value_offs"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_LAST_ENTRY",
          "args": [
            "last"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "first_val",
            "0",
            "size"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "first_val + size",
            "first_val",
            "val - first_val"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "val",
            "i->value",
            "i->value_len"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "val + size - EXT4_XATTR_PAD",
            "0",
            "EXT4_XATTR_PAD"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "val",
            "0",
            "size"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "i->value_len"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_XATTR_SIZE",
          "args": [
            "i->value_len"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_XATTR_SIZE",
          "args": [
            "le32_to_cpu(s->here->e_value_size)"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "s->here->e_value_size"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "s->here->e_name",
            "i->name",
            "name_len"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "s->here",
            "0",
            "size"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "(void *)s->here + size",
            "s->here",
            "rest"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_XATTR_LEN",
          "args": [
            "name_len"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_XATTR_SIZE",
          "args": [
            "i->value_len"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_XATTR_LEN",
          "args": [
            "name_len"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_XATTR_SIZE",
          "args": [
            "i->value_len"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_XATTR_LEN",
          "args": [
            "name_len"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_XATTR_SIZE",
          "args": [
            "size"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_XATTR_NEXT",
          "args": [
            "last"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LAST_ENTRY",
          "args": [
            "last"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "i->name"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);\n\nstatic int\next4_xattr_set_entry(struct ext4_xattr_info *i, struct ext4_xattr_search *s)\n{\n\tstruct ext4_xattr_entry *last;\n\tsize_t free, min_offs = s->end - s->base, name_len = strlen(i->name);\n\n\t/* Compute min_offs and last. */\n\tlast = s->first;\n\tfor (; !IS_LAST_ENTRY(last); last = EXT4_XATTR_NEXT(last)) {\n\t\tif (!last->e_value_block && last->e_value_size) {\n\t\t\tsize_t offs = le16_to_cpu(last->e_value_offs);\n\t\t\tif (offs < min_offs)\n\t\t\t\tmin_offs = offs;\n\t\t}\n\t}\n\tfree = min_offs - ((void *)last - s->base) - sizeof(__u32);\n\tif (!s->not_found) {\n\t\tif (!s->here->e_value_block && s->here->e_value_size) {\n\t\t\tsize_t size = le32_to_cpu(s->here->e_value_size);\n\t\t\tfree += EXT4_XATTR_SIZE(size);\n\t\t}\n\t\tfree += EXT4_XATTR_LEN(name_len);\n\t}\n\tif (i->value) {\n\t\tif (free < EXT4_XATTR_SIZE(i->value_len) ||\n\t\t    free < EXT4_XATTR_LEN(name_len) +\n\t\t\t   EXT4_XATTR_SIZE(i->value_len))\n\t\t\treturn -ENOSPC;\n\t}\n\n\tif (i->value && s->not_found) {\n\t\t/* Insert the new name. */\n\t\tsize_t size = EXT4_XATTR_LEN(name_len);\n\t\tsize_t rest = (void *)last - (void *)s->here + sizeof(__u32);\n\t\tmemmove((void *)s->here + size, s->here, rest);\n\t\tmemset(s->here, 0, size);\n\t\ts->here->e_name_index = i->name_index;\n\t\ts->here->e_name_len = name_len;\n\t\tmemcpy(s->here->e_name, i->name, name_len);\n\t} else {\n\t\tif (!s->here->e_value_block && s->here->e_value_size) {\n\t\t\tvoid *first_val = s->base + min_offs;\n\t\t\tsize_t offs = le16_to_cpu(s->here->e_value_offs);\n\t\t\tvoid *val = s->base + offs;\n\t\t\tsize_t size = EXT4_XATTR_SIZE(\n\t\t\t\tle32_to_cpu(s->here->e_value_size));\n\n\t\t\tif (i->value && size == EXT4_XATTR_SIZE(i->value_len)) {\n\t\t\t\t/* The old and the new value have the same\n\t\t\t\t   size. Just replace. */\n\t\t\t\ts->here->e_value_size =\n\t\t\t\t\tcpu_to_le32(i->value_len);\n\t\t\t\tif (i->value == EXT4_ZERO_XATTR_VALUE) {\n\t\t\t\t\tmemset(val, 0, size);\n\t\t\t\t} else {\n\t\t\t\t\t/* Clear pad bytes first. */\n\t\t\t\t\tmemset(val + size - EXT4_XATTR_PAD, 0,\n\t\t\t\t\t       EXT4_XATTR_PAD);\n\t\t\t\t\tmemcpy(val, i->value, i->value_len);\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* Remove the old value. */\n\t\t\tmemmove(first_val + size, first_val, val - first_val);\n\t\t\tmemset(first_val, 0, size);\n\t\t\ts->here->e_value_size = 0;\n\t\t\ts->here->e_value_offs = 0;\n\t\t\tmin_offs += size;\n\n\t\t\t/* Adjust all value offsets. */\n\t\t\tlast = s->first;\n\t\t\twhile (!IS_LAST_ENTRY(last)) {\n\t\t\t\tsize_t o = le16_to_cpu(last->e_value_offs);\n\t\t\t\tif (!last->e_value_block &&\n\t\t\t\t    last->e_value_size && o < offs)\n\t\t\t\t\tlast->e_value_offs =\n\t\t\t\t\t\tcpu_to_le16(o + size);\n\t\t\t\tlast = EXT4_XATTR_NEXT(last);\n\t\t\t}\n\t\t}\n\t\tif (!i->value) {\n\t\t\t/* Remove the old name. */\n\t\t\tsize_t size = EXT4_XATTR_LEN(name_len);\n\t\t\tlast = ENTRY((void *)last - size);\n\t\t\tmemmove(s->here, (void *)s->here + size,\n\t\t\t\t(void *)last - (void *)s->here + sizeof(__u32));\n\t\t\tmemset(last, 0, size);\n\t\t}\n\t}\n\n\tif (i->value) {\n\t\t/* Insert the new value. */\n\t\ts->here->e_value_size = cpu_to_le32(i->value_len);\n\t\tif (i->value_len) {\n\t\t\tsize_t size = EXT4_XATTR_SIZE(i->value_len);\n\t\t\tvoid *val = s->base + min_offs - size;\n\t\t\ts->here->e_value_offs = cpu_to_le16(min_offs - size);\n\t\t\tif (i->value == EXT4_ZERO_XATTR_VALUE) {\n\t\t\t\tmemset(val, 0, size);\n\t\t\t} else {\n\t\t\t\t/* Clear the pad bytes first. */\n\t\t\t\tmemset(val + size - EXT4_XATTR_PAD, 0,\n\t\t\t\t       EXT4_XATTR_PAD);\n\t\t\t\tmemcpy(val, i->value, i->value_len);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_xattr_free_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
    "lines": "603-616",
    "snippet": "static size_t ext4_xattr_free_space(struct ext4_xattr_entry *last,\n\t\t\t\t    size_t *min_offs, void *base, int *total)\n{\n\tfor (; !IS_LAST_ENTRY(last); last = EXT4_XATTR_NEXT(last)) {\n\t\tif (!last->e_value_block && last->e_value_size) {\n\t\t\tsize_t offs = le16_to_cpu(last->e_value_offs);\n\t\t\tif (offs < *min_offs)\n\t\t\t\t*min_offs = offs;\n\t\t}\n\t\tif (total)\n\t\t\t*total += EXT4_XATTR_LEN(last->e_name_len);\n\t}\n\treturn (*min_offs - ((void *)last - base) - sizeof(__u32));\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT4_XATTR_LEN",
          "args": [
            "last->e_name_len"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "last->e_value_offs"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_XATTR_NEXT",
          "args": [
            "last"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LAST_ENTRY",
          "args": [
            "last"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);\n\nstatic size_t ext4_xattr_free_space(struct ext4_xattr_entry *last,\n\t\t\t\t    size_t *min_offs, void *base, int *total)\n{\n\tfor (; !IS_LAST_ENTRY(last); last = EXT4_XATTR_NEXT(last)) {\n\t\tif (!last->e_value_block && last->e_value_size) {\n\t\t\tsize_t offs = le16_to_cpu(last->e_value_offs);\n\t\t\tif (offs < *min_offs)\n\t\t\t\t*min_offs = offs;\n\t\t}\n\t\tif (total)\n\t\t\t*total += EXT4_XATTR_LEN(last->e_name_len);\n\t}\n\treturn (*min_offs - ((void *)last - base) - sizeof(__u32));\n}"
  },
  {
    "function_name": "ext4_xattr_release_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
    "lines": "543-597",
    "snippet": "static void\next4_xattr_release_block(handle_t *handle, struct inode *inode,\n\t\t\t struct buffer_head *bh)\n{\n\tstruct mb_cache_entry *ce = NULL;\n\tint error = 0;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\n\tce = mb_cache_entry_get(ext4_mb_cache, bh->b_bdev, bh->b_blocknr);\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terror = ext4_journal_get_write_access(handle, bh);\n\tif (error)\n\t\tgoto out;\n\n\tlock_buffer(bh);\n\tif (BHDR(bh)->h_refcount == cpu_to_le32(1)) {\n\t\tea_bdebug(bh, \"refcount now=0; freeing\");\n\t\tif (ce)\n\t\t\tmb_cache_entry_free(ce);\n\t\tget_bh(bh);\n\t\tunlock_buffer(bh);\n\t\text4_free_blocks(handle, inode, bh, 0, 1,\n\t\t\t\t EXT4_FREE_BLOCKS_METADATA |\n\t\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\t} else {\n\t\tle32_add_cpu(&BHDR(bh)->h_refcount, -1);\n\t\tif (ce)\n\t\t\tmb_cache_entry_release(ce);\n\t\t/*\n\t\t * Beware of this ugliness: Releasing of xattr block references\n\t\t * from different inodes can race and so we have to protect\n\t\t * from a race where someone else frees the block (and releases\n\t\t * its journal_head) before we are done dirtying the buffer. In\n\t\t * nojournal mode this race is harmless and we actually cannot\n\t\t * call ext4_handle_dirty_xattr_block() with locked buffer as\n\t\t * that function can call sync_dirty_buffer() so for that case\n\t\t * we handle the dirtying after unlocking the buffer.\n\t\t */\n\t\tif (ext4_handle_valid(handle))\n\t\t\terror = ext4_handle_dirty_xattr_block(handle, inode,\n\t\t\t\t\t\t\t      bh);\n\t\tunlock_buffer(bh);\n\t\tif (!ext4_handle_valid(handle))\n\t\t\terror = ext4_handle_dirty_xattr_block(handle, inode,\n\t\t\t\t\t\t\t      bh);\n\t\tif (IS_SYNC(inode))\n\t\t\text4_handle_sync(handle);\n\t\tdquot_free_block(inode, EXT4_C2B(EXT4_SB(inode->i_sb), 1));\n\t\tea_bdebug(bh, \"refcount now=%d; releasing\",\n\t\t\t  le32_to_cpu(BHDR(bh)->h_refcount));\n\t}\nout:\n\text4_std_error(inode->i_sb, error);\n\treturn;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);",
      "static struct buffer_head *ext4_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext4_xattr_header *,\n\t\t\t\t\t\t struct mb_cache_entry **);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_std_error",
          "args": [
            "inode->i_sb",
            "error"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_bdebug",
          "args": [
            "bh",
            "\"refcount now=%d; releasing\"",
            "le32_to_cpu(BHDR(bh)->h_refcount)"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "BHDR(bh)->h_refcount"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BHDR",
          "args": [
            "bh"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_free_block",
          "args": [
            "inode",
            "EXT4_C2B(EXT4_SB(inode->i_sb), 1)"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_C2B",
          "args": [
            "EXT4_SB(inode->i_sb)",
            "1"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_handle_sync",
          "args": [
            "handle"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "279-283",
          "snippet": "static inline void ext4_handle_sync(handle_t *handle)\n{\n\tif (ext4_handle_valid(handle))\n\t\thandle->h_sync = 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ext4_handle_sync(handle_t *handle)\n{\n\tif (ext4_handle_valid(handle))\n\t\thandle->h_sync = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_SYNC",
          "args": [
            "inode"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_handle_dirty_xattr_block",
          "args": [
            "handle",
            "inode",
            "bh"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_dirty_xattr_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "161-167",
          "snippet": "static inline int ext4_handle_dirty_xattr_block(handle_t *handle,\n\t\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\t\tstruct buffer_head *bh)\n{\n\text4_xattr_block_csum_set(inode, bh->b_blocknr, BHDR(bh));\n\treturn ext4_handle_dirty_metadata(handle, inode, bh);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);\n\nstatic inline int ext4_handle_dirty_xattr_block(handle_t *handle,\n\t\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\t\tstruct buffer_head *bh)\n{\n\text4_xattr_block_csum_set(inode, bh->b_blocknr, BHDR(bh));\n\treturn ext4_handle_dirty_metadata(handle, inode, bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_handle_valid",
          "args": [
            "handle"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_handle_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "272-277",
          "snippet": "static inline int ext4_handle_valid(handle_t *handle)\n{\n\tif ((unsigned long)handle < EXT4_NOJOURNAL_MAX_REF_COUNT)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT4_NOJOURNAL_MAX_REF_COUNT ((unsigned long) 4096)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define EXT4_NOJOURNAL_MAX_REF_COUNT ((unsigned long) 4096)\n\nstatic inline int ext4_handle_valid(handle_t *handle)\n{\n\tif ((unsigned long)handle < EXT4_NOJOURNAL_MAX_REF_COUNT)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mb_cache_entry_release",
          "args": [
            "ce"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "mb_cache_entry_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "626-630",
          "snippet": "void\nmb_cache_entry_release(struct mb_cache_entry *ce)\n{\n\t__mb_cache_entry_release(ce);\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid\nmb_cache_entry_release(struct mb_cache_entry *ce)\n{\n\t__mb_cache_entry_release(ce);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&BHDR(bh)->h_refcount",
            "-1"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BHDR",
          "args": [
            "bh"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_free_blocks",
          "args": [
            "handle",
            "inode",
            "bh",
            "0",
            "1",
            "EXT4_FREE_BLOCKS_METADATA |\n\t\t\t\t EXT4_FREE_BLOCKS_FORGET"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "4633-4881",
          "snippet": "void ext4_free_blocks(handle_t *handle, struct inode *inode,\n\t\t      struct buffer_head *bh, ext4_fsblk_t block,\n\t\t      unsigned long count, int flags)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_group_desc *gdp;\n\tunsigned int overflow;\n\text4_grpblk_t bit;\n\tstruct buffer_head *gd_bh;\n\text4_group_t block_group;\n\tstruct ext4_sb_info *sbi;\n\tstruct ext4_buddy e4b;\n\tunsigned int count_clusters;\n\tint err = 0;\n\tint ret;\n\n\tmight_sleep();\n\tif (bh) {\n\t\tif (block)\n\t\t\tBUG_ON(block != bh->b_blocknr);\n\t\telse\n\t\t\tblock = bh->b_blocknr;\n\t}\n\n\tsbi = EXT4_SB(sb);\n\tif (!(flags & EXT4_FREE_BLOCKS_VALIDATED) &&\n\t    !ext4_data_block_valid(sbi, block, count)) {\n\t\text4_error(sb, \"Freeing blocks not in datazone - \"\n\t\t\t   \"block = %llu, count = %lu\", block, count);\n\t\tgoto error_return;\n\t}\n\n\text4_debug(\"freeing block %llu\\n\", block);\n\ttrace_ext4_free_blocks(inode, block, count, flags);\n\n\tif (flags & EXT4_FREE_BLOCKS_FORGET) {\n\t\tstruct buffer_head *tbh = bh;\n\t\tint i;\n\n\t\tBUG_ON(bh && (count > 1));\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tcond_resched();\n\t\t\tif (!bh)\n\t\t\t\ttbh = sb_find_get_block(inode->i_sb,\n\t\t\t\t\t\t\tblock + i);\n\t\t\tif (!tbh)\n\t\t\t\tcontinue;\n\t\t\text4_forget(handle, flags & EXT4_FREE_BLOCKS_METADATA,\n\t\t\t\t    inode, tbh, block + i);\n\t\t}\n\t}\n\n\t/*\n\t * We need to make sure we don't reuse the freed block until\n\t * after the transaction is committed, which we can do by\n\t * treating the block as metadata, below.  We make an\n\t * exception if the inode is to be written in writeback mode\n\t * since writeback mode has weak data consistency guarantees.\n\t */\n\tif (!ext4_should_writeback_data(inode))\n\t\tflags |= EXT4_FREE_BLOCKS_METADATA;\n\n\t/*\n\t * If the extent to be freed does not begin on a cluster\n\t * boundary, we need to deal with partial clusters at the\n\t * beginning and end of the extent.  Normally we will free\n\t * blocks at the beginning or the end unless we are explicitly\n\t * requested to avoid doing so.\n\t */\n\toverflow = EXT4_PBLK_COFF(sbi, block);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_FIRST_CLUSTER) {\n\t\t\toverflow = sbi->s_cluster_ratio - overflow;\n\t\t\tblock += overflow;\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else {\n\t\t\tblock -= overflow;\n\t\t\tcount += overflow;\n\t\t}\n\t}\n\toverflow = EXT4_LBLK_COFF(sbi, count);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_LAST_CLUSTER) {\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else\n\t\t\tcount += sbi->s_cluster_ratio - overflow;\n\t}\n\ndo_more:\n\toverflow = 0;\n\text4_get_group_no_and_offset(sb, block, &block_group, &bit);\n\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(\n\t\t\text4_get_group_info(sb, block_group))))\n\t\treturn;\n\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (EXT4_C2B(sbi, bit) + count > EXT4_BLOCKS_PER_GROUP(sb)) {\n\t\toverflow = EXT4_C2B(sbi, bit) + count -\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb);\n\t\tcount -= overflow;\n\t}\n\tcount_clusters = EXT4_NUM_B2C(sbi, count);\n\tbitmap_bh = ext4_read_block_bitmap(sb, block_group);\n\tif (!bitmap_bh) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\tgdp = ext4_get_group_desc(sb, block_group, &gd_bh);\n\tif (!gdp) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\n\tif (in_range(ext4_block_bitmap(sb, gdp), block, count) ||\n\t    in_range(ext4_inode_bitmap(sb, gdp), block, count) ||\n\t    in_range(block, ext4_inode_table(sb, gdp),\n\t\t     EXT4_SB(sb)->s_itb_per_group) ||\n\t    in_range(block + count - 1, ext4_inode_table(sb, gdp),\n\t\t     EXT4_SB(sb)->s_itb_per_group)) {\n\n\t\text4_error(sb, \"Freeing blocks in system zone - \"\n\t\t\t   \"Block = %llu, count = %lu\", block, count);\n\t\t/* err = 0. ext4_std_error should be a no op */\n\t\tgoto error_return;\n\t}\n\n\tBUFFER_TRACE(bitmap_bh, \"getting write access\");\n\terr = ext4_journal_get_write_access(handle, bitmap_bh);\n\tif (err)\n\t\tgoto error_return;\n\n\t/*\n\t * We are about to modify some metadata.  Call the journal APIs\n\t * to unshare ->b_data if a currently-committing transaction is\n\t * using it\n\t */\n\tBUFFER_TRACE(gd_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, gd_bh);\n\tif (err)\n\t\tgoto error_return;\n#ifdef AGGRESSIVE_CHECK\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < count_clusters; i++)\n\t\t\tBUG_ON(!mb_test_bit(bit + i, bitmap_bh->b_data));\n\t}\n#endif\n\ttrace_ext4_mballoc_free(sb, inode, block_group, bit, count_clusters);\n\n\terr = ext4_mb_load_buddy(sb, block_group, &e4b);\n\tif (err)\n\t\tgoto error_return;\n\n\tif ((flags & EXT4_FREE_BLOCKS_METADATA) && ext4_handle_valid(handle)) {\n\t\tstruct ext4_free_data *new_entry;\n\t\t/*\n\t\t * blocks being freed are metadata. these blocks shouldn't\n\t\t * be used until this transaction is committed\n\t\t */\n\tretry:\n\t\tnew_entry = kmem_cache_alloc(ext4_free_data_cachep, GFP_NOFS);\n\t\tif (!new_entry) {\n\t\t\t/*\n\t\t\t * We use a retry loop because\n\t\t\t * ext4_free_blocks() is not allowed to fail.\n\t\t\t */\n\t\t\tcond_resched();\n\t\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t\t\tgoto retry;\n\t\t}\n\t\tnew_entry->efd_start_cluster = bit;\n\t\tnew_entry->efd_group = block_group;\n\t\tnew_entry->efd_count = count_clusters;\n\t\tnew_entry->efd_tid = handle->h_transaction->t_tid;\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\text4_mb_free_metadata(handle, &e4b, new_entry);\n\t} else {\n\t\t/* need to update group_info->bb_free and bitmap\n\t\t * with group lock held. generate_buddy look at\n\t\t * them with group lock_held\n\t\t */\n\t\tif (test_opt(sb, DISCARD)) {\n\t\t\terr = ext4_issue_discard(sb, block_group, bit, count);\n\t\t\tif (err && err != -EOPNOTSUPP)\n\t\t\t\text4_msg(sb, KERN_WARNING, \"discard request in\"\n\t\t\t\t\t \" group:%d block:%d count:%lu failed\"\n\t\t\t\t\t \" with %d\", block_group, bit, count,\n\t\t\t\t\t err);\n\t\t} else\n\t\t\tEXT4_MB_GRP_CLEAR_TRIMMED(e4b.bd_info);\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\tmb_free_blocks(inode, &e4b, bit, count_clusters);\n\t}\n\n\tret = ext4_free_group_clusters(sb, gdp) + count_clusters;\n\text4_free_group_clusters_set(sb, gdp, ret);\n\text4_block_bitmap_csum_set(sb, block_group, gdp, bitmap_bh);\n\text4_group_desc_csum_set(sb, block_group, gdp);\n\text4_unlock_group(sb, block_group);\n\n\tif (sbi->s_log_groups_per_flex) {\n\t\text4_group_t flex_group = ext4_flex_group(sbi, block_group);\n\t\tatomic64_add(count_clusters,\n\t\t\t     &sbi->s_flex_groups[flex_group].free_clusters);\n\t}\n\n\tif (!(flags & EXT4_FREE_BLOCKS_NO_QUOT_UPDATE))\n\t\tdquot_free_block(inode, EXT4_C2B(sbi, count_clusters));\n\tpercpu_counter_add(&sbi->s_freeclusters_counter, count_clusters);\n\n\text4_mb_unload_buddy(&e4b);\n\n\t/* We dirtied the bitmap block */\n\tBUFFER_TRACE(bitmap_bh, \"dirtied bitmap block\");\n\terr = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);\n\n\t/* And the group descriptor block */\n\tBUFFER_TRACE(gd_bh, \"dirtied group descriptor block\");\n\tret = ext4_handle_dirty_metadata(handle, NULL, gd_bh);\n\tif (!err)\n\t\terr = ret;\n\n\tif (overflow && !err) {\n\t\tblock += count;\n\t\tcount = overflow;\n\t\tput_bh(bitmap_bh);\n\t\tgoto do_more;\n\t}\nerror_return:\n\tbrelse(bitmap_bh);\n\text4_std_error(sb, err);\n\treturn;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ext4_free_data_cachep;",
            "static void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);",
            "static void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic struct kmem_cache *ext4_free_data_cachep;\nstatic void ext4_mb_generate_from_pa(struct super_block *sb, void *bitmap,\n\t\t\t\t\text4_group_t group);\nstatic void ext4_mb_generate_from_freelist(struct super_block *sb, void *bitmap,\n\t\t\t\t\t\text4_group_t group);\n\nvoid ext4_free_blocks(handle_t *handle, struct inode *inode,\n\t\t      struct buffer_head *bh, ext4_fsblk_t block,\n\t\t      unsigned long count, int flags)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_group_desc *gdp;\n\tunsigned int overflow;\n\text4_grpblk_t bit;\n\tstruct buffer_head *gd_bh;\n\text4_group_t block_group;\n\tstruct ext4_sb_info *sbi;\n\tstruct ext4_buddy e4b;\n\tunsigned int count_clusters;\n\tint err = 0;\n\tint ret;\n\n\tmight_sleep();\n\tif (bh) {\n\t\tif (block)\n\t\t\tBUG_ON(block != bh->b_blocknr);\n\t\telse\n\t\t\tblock = bh->b_blocknr;\n\t}\n\n\tsbi = EXT4_SB(sb);\n\tif (!(flags & EXT4_FREE_BLOCKS_VALIDATED) &&\n\t    !ext4_data_block_valid(sbi, block, count)) {\n\t\text4_error(sb, \"Freeing blocks not in datazone - \"\n\t\t\t   \"block = %llu, count = %lu\", block, count);\n\t\tgoto error_return;\n\t}\n\n\text4_debug(\"freeing block %llu\\n\", block);\n\ttrace_ext4_free_blocks(inode, block, count, flags);\n\n\tif (flags & EXT4_FREE_BLOCKS_FORGET) {\n\t\tstruct buffer_head *tbh = bh;\n\t\tint i;\n\n\t\tBUG_ON(bh && (count > 1));\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tcond_resched();\n\t\t\tif (!bh)\n\t\t\t\ttbh = sb_find_get_block(inode->i_sb,\n\t\t\t\t\t\t\tblock + i);\n\t\t\tif (!tbh)\n\t\t\t\tcontinue;\n\t\t\text4_forget(handle, flags & EXT4_FREE_BLOCKS_METADATA,\n\t\t\t\t    inode, tbh, block + i);\n\t\t}\n\t}\n\n\t/*\n\t * We need to make sure we don't reuse the freed block until\n\t * after the transaction is committed, which we can do by\n\t * treating the block as metadata, below.  We make an\n\t * exception if the inode is to be written in writeback mode\n\t * since writeback mode has weak data consistency guarantees.\n\t */\n\tif (!ext4_should_writeback_data(inode))\n\t\tflags |= EXT4_FREE_BLOCKS_METADATA;\n\n\t/*\n\t * If the extent to be freed does not begin on a cluster\n\t * boundary, we need to deal with partial clusters at the\n\t * beginning and end of the extent.  Normally we will free\n\t * blocks at the beginning or the end unless we are explicitly\n\t * requested to avoid doing so.\n\t */\n\toverflow = EXT4_PBLK_COFF(sbi, block);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_FIRST_CLUSTER) {\n\t\t\toverflow = sbi->s_cluster_ratio - overflow;\n\t\t\tblock += overflow;\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else {\n\t\t\tblock -= overflow;\n\t\t\tcount += overflow;\n\t\t}\n\t}\n\toverflow = EXT4_LBLK_COFF(sbi, count);\n\tif (overflow) {\n\t\tif (flags & EXT4_FREE_BLOCKS_NOFREE_LAST_CLUSTER) {\n\t\t\tif (count > overflow)\n\t\t\t\tcount -= overflow;\n\t\t\telse\n\t\t\t\treturn;\n\t\t} else\n\t\t\tcount += sbi->s_cluster_ratio - overflow;\n\t}\n\ndo_more:\n\toverflow = 0;\n\text4_get_group_no_and_offset(sb, block, &block_group, &bit);\n\n\tif (unlikely(EXT4_MB_GRP_BBITMAP_CORRUPT(\n\t\t\text4_get_group_info(sb, block_group))))\n\t\treturn;\n\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (EXT4_C2B(sbi, bit) + count > EXT4_BLOCKS_PER_GROUP(sb)) {\n\t\toverflow = EXT4_C2B(sbi, bit) + count -\n\t\t\tEXT4_BLOCKS_PER_GROUP(sb);\n\t\tcount -= overflow;\n\t}\n\tcount_clusters = EXT4_NUM_B2C(sbi, count);\n\tbitmap_bh = ext4_read_block_bitmap(sb, block_group);\n\tif (!bitmap_bh) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\tgdp = ext4_get_group_desc(sb, block_group, &gd_bh);\n\tif (!gdp) {\n\t\terr = -EIO;\n\t\tgoto error_return;\n\t}\n\n\tif (in_range(ext4_block_bitmap(sb, gdp), block, count) ||\n\t    in_range(ext4_inode_bitmap(sb, gdp), block, count) ||\n\t    in_range(block, ext4_inode_table(sb, gdp),\n\t\t     EXT4_SB(sb)->s_itb_per_group) ||\n\t    in_range(block + count - 1, ext4_inode_table(sb, gdp),\n\t\t     EXT4_SB(sb)->s_itb_per_group)) {\n\n\t\text4_error(sb, \"Freeing blocks in system zone - \"\n\t\t\t   \"Block = %llu, count = %lu\", block, count);\n\t\t/* err = 0. ext4_std_error should be a no op */\n\t\tgoto error_return;\n\t}\n\n\tBUFFER_TRACE(bitmap_bh, \"getting write access\");\n\terr = ext4_journal_get_write_access(handle, bitmap_bh);\n\tif (err)\n\t\tgoto error_return;\n\n\t/*\n\t * We are about to modify some metadata.  Call the journal APIs\n\t * to unshare ->b_data if a currently-committing transaction is\n\t * using it\n\t */\n\tBUFFER_TRACE(gd_bh, \"get_write_access\");\n\terr = ext4_journal_get_write_access(handle, gd_bh);\n\tif (err)\n\t\tgoto error_return;\n#ifdef AGGRESSIVE_CHECK\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < count_clusters; i++)\n\t\t\tBUG_ON(!mb_test_bit(bit + i, bitmap_bh->b_data));\n\t}\n#endif\n\ttrace_ext4_mballoc_free(sb, inode, block_group, bit, count_clusters);\n\n\terr = ext4_mb_load_buddy(sb, block_group, &e4b);\n\tif (err)\n\t\tgoto error_return;\n\n\tif ((flags & EXT4_FREE_BLOCKS_METADATA) && ext4_handle_valid(handle)) {\n\t\tstruct ext4_free_data *new_entry;\n\t\t/*\n\t\t * blocks being freed are metadata. these blocks shouldn't\n\t\t * be used until this transaction is committed\n\t\t */\n\tretry:\n\t\tnew_entry = kmem_cache_alloc(ext4_free_data_cachep, GFP_NOFS);\n\t\tif (!new_entry) {\n\t\t\t/*\n\t\t\t * We use a retry loop because\n\t\t\t * ext4_free_blocks() is not allowed to fail.\n\t\t\t */\n\t\t\tcond_resched();\n\t\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t\t\tgoto retry;\n\t\t}\n\t\tnew_entry->efd_start_cluster = bit;\n\t\tnew_entry->efd_group = block_group;\n\t\tnew_entry->efd_count = count_clusters;\n\t\tnew_entry->efd_tid = handle->h_transaction->t_tid;\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\text4_mb_free_metadata(handle, &e4b, new_entry);\n\t} else {\n\t\t/* need to update group_info->bb_free and bitmap\n\t\t * with group lock held. generate_buddy look at\n\t\t * them with group lock_held\n\t\t */\n\t\tif (test_opt(sb, DISCARD)) {\n\t\t\terr = ext4_issue_discard(sb, block_group, bit, count);\n\t\t\tif (err && err != -EOPNOTSUPP)\n\t\t\t\text4_msg(sb, KERN_WARNING, \"discard request in\"\n\t\t\t\t\t \" group:%d block:%d count:%lu failed\"\n\t\t\t\t\t \" with %d\", block_group, bit, count,\n\t\t\t\t\t err);\n\t\t} else\n\t\t\tEXT4_MB_GRP_CLEAR_TRIMMED(e4b.bd_info);\n\n\t\text4_lock_group(sb, block_group);\n\t\tmb_clear_bits(bitmap_bh->b_data, bit, count_clusters);\n\t\tmb_free_blocks(inode, &e4b, bit, count_clusters);\n\t}\n\n\tret = ext4_free_group_clusters(sb, gdp) + count_clusters;\n\text4_free_group_clusters_set(sb, gdp, ret);\n\text4_block_bitmap_csum_set(sb, block_group, gdp, bitmap_bh);\n\text4_group_desc_csum_set(sb, block_group, gdp);\n\text4_unlock_group(sb, block_group);\n\n\tif (sbi->s_log_groups_per_flex) {\n\t\text4_group_t flex_group = ext4_flex_group(sbi, block_group);\n\t\tatomic64_add(count_clusters,\n\t\t\t     &sbi->s_flex_groups[flex_group].free_clusters);\n\t}\n\n\tif (!(flags & EXT4_FREE_BLOCKS_NO_QUOT_UPDATE))\n\t\tdquot_free_block(inode, EXT4_C2B(sbi, count_clusters));\n\tpercpu_counter_add(&sbi->s_freeclusters_counter, count_clusters);\n\n\text4_mb_unload_buddy(&e4b);\n\n\t/* We dirtied the bitmap block */\n\tBUFFER_TRACE(bitmap_bh, \"dirtied bitmap block\");\n\terr = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);\n\n\t/* And the group descriptor block */\n\tBUFFER_TRACE(gd_bh, \"dirtied group descriptor block\");\n\tret = ext4_handle_dirty_metadata(handle, NULL, gd_bh);\n\tif (!err)\n\t\terr = ret;\n\n\tif (overflow && !err) {\n\t\tblock += count;\n\t\tcount = overflow;\n\t\tput_bh(bitmap_bh);\n\t\tgoto do_more;\n\t}\nerror_return:\n\tbrelse(bitmap_bh);\n\text4_std_error(sb, err);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_cache_entry_free",
          "args": [
            "ce"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "mb_cache_entry_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "637-649",
          "snippet": "void\nmb_cache_entry_free(struct mb_cache_entry *ce)\n{\n\tmb_assert(ce);\n\tmb_assert(list_empty(&ce->e_lru_list));\n\thlist_bl_lock(ce->e_index_hash_p);\n\t__mb_cache_entry_unhash_index(ce);\n\thlist_bl_unlock(ce->e_index_hash_p);\n\thlist_bl_lock(ce->e_block_hash_p);\n\t__mb_cache_entry_unhash_block(ce);\n\thlist_bl_unlock(ce->e_block_hash_p);\n\t__mb_cache_entry_release(ce);\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid\nmb_cache_entry_free(struct mb_cache_entry *ce)\n{\n\tmb_assert(ce);\n\tmb_assert(list_empty(&ce->e_lru_list));\n\thlist_bl_lock(ce->e_index_hash_p);\n\t__mb_cache_entry_unhash_index(ce);\n\thlist_bl_unlock(ce->e_index_hash_p);\n\thlist_bl_lock(ce->e_block_hash_p);\n\t__mb_cache_entry_unhash_block(ce);\n\thlist_bl_unlock(ce->e_block_hash_p);\n\t__mb_cache_entry_release(ce);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_bdebug",
          "args": [
            "bh",
            "\"refcount now=0; freeing\""
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "1"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BHDR",
          "args": [
            "bh"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "bh"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"get_write_access\""
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb_cache_entry_get",
          "args": [
            "ext4_mb_cache",
            "bh->b_bdev",
            "bh->b_blocknr"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "mb_cache_entry_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "660-714",
          "snippet": "struct mb_cache_entry *\nmb_cache_entry_get(struct mb_cache *cache, struct block_device *bdev,\n\t\t   sector_t block)\n{\n\tunsigned int bucket;\n\tstruct hlist_bl_node *l;\n\tstruct mb_cache_entry *ce;\n\tstruct hlist_bl_head *block_hash_p;\n\n\tbucket = hash_long((unsigned long)bdev + (block & 0xffffffff),\n\t\t\t   cache->c_bucket_bits);\n\tblock_hash_p = &cache->c_block_hash[bucket];\n\t/* First serialize access to the block corresponding hash chain. */\n\thlist_bl_lock(block_hash_p);\n\thlist_bl_for_each_entry(ce, l, block_hash_p, e_block_list) {\n\t\tmb_assert(ce->e_block_hash_p == block_hash_p);\n\t\tif (ce->e_bdev == bdev && ce->e_block == block) {\n\t\t\t/*\n\t\t\t * Prevent a free from removing the entry.\n\t\t\t */\n\t\t\tatomic_inc(&ce->e_refcnt);\n\t\t\thlist_bl_unlock(block_hash_p);\n\t\t\t__spin_lock_mb_cache_entry(ce);\n\t\t\tatomic_dec(&ce->e_refcnt);\n\t\t\tif (ce->e_used > 0) {\n\t\t\t\tDEFINE_WAIT(wait);\n\t\t\t\twhile (ce->e_used > 0) {\n\t\t\t\t\tce->e_queued++;\n\t\t\t\t\tprepare_to_wait(&mb_cache_queue, &wait,\n\t\t\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\t\t\t\t__spin_unlock_mb_cache_entry(ce);\n\t\t\t\t\tschedule();\n\t\t\t\t\t__spin_lock_mb_cache_entry(ce);\n\t\t\t\t\tce->e_queued--;\n\t\t\t\t}\n\t\t\t\tfinish_wait(&mb_cache_queue, &wait);\n\t\t\t}\n\t\t\tce->e_used += 1 + MB_CACHE_WRITER;\n\t\t\t__spin_unlock_mb_cache_entry(ce);\n\n\t\t\tif (!list_empty(&ce->e_lru_list)) {\n\t\t\t\tspin_lock(&mb_cache_spinlock);\n\t\t\t\tlist_del_init(&ce->e_lru_list);\n\t\t\t\tspin_unlock(&mb_cache_spinlock);\n\t\t\t}\n\t\t\tif (!__mb_cache_entry_is_block_hashed(ce)) {\n\t\t\t\t__mb_cache_entry_release(ce);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn ce;\n\t\t}\n\t}\n\thlist_bl_unlock(block_hash_p);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MB_CACHE_WRITER ((unsigned short)~0U >> 1)"
          ],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(mb_cache_queue);",
            "static DEFINE_SPINLOCK(mb_cache_spinlock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\n#define MB_CACHE_WRITER ((unsigned short)~0U >> 1)\n\nstatic DECLARE_WAIT_QUEUE_HEAD(mb_cache_queue);\nstatic DEFINE_SPINLOCK(mb_cache_spinlock);\n\nstruct mb_cache_entry *\nmb_cache_entry_get(struct mb_cache *cache, struct block_device *bdev,\n\t\t   sector_t block)\n{\n\tunsigned int bucket;\n\tstruct hlist_bl_node *l;\n\tstruct mb_cache_entry *ce;\n\tstruct hlist_bl_head *block_hash_p;\n\n\tbucket = hash_long((unsigned long)bdev + (block & 0xffffffff),\n\t\t\t   cache->c_bucket_bits);\n\tblock_hash_p = &cache->c_block_hash[bucket];\n\t/* First serialize access to the block corresponding hash chain. */\n\thlist_bl_lock(block_hash_p);\n\thlist_bl_for_each_entry(ce, l, block_hash_p, e_block_list) {\n\t\tmb_assert(ce->e_block_hash_p == block_hash_p);\n\t\tif (ce->e_bdev == bdev && ce->e_block == block) {\n\t\t\t/*\n\t\t\t * Prevent a free from removing the entry.\n\t\t\t */\n\t\t\tatomic_inc(&ce->e_refcnt);\n\t\t\thlist_bl_unlock(block_hash_p);\n\t\t\t__spin_lock_mb_cache_entry(ce);\n\t\t\tatomic_dec(&ce->e_refcnt);\n\t\t\tif (ce->e_used > 0) {\n\t\t\t\tDEFINE_WAIT(wait);\n\t\t\t\twhile (ce->e_used > 0) {\n\t\t\t\t\tce->e_queued++;\n\t\t\t\t\tprepare_to_wait(&mb_cache_queue, &wait,\n\t\t\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\t\t\t\t__spin_unlock_mb_cache_entry(ce);\n\t\t\t\t\tschedule();\n\t\t\t\t\t__spin_lock_mb_cache_entry(ce);\n\t\t\t\t\tce->e_queued--;\n\t\t\t\t}\n\t\t\t\tfinish_wait(&mb_cache_queue, &wait);\n\t\t\t}\n\t\t\tce->e_used += 1 + MB_CACHE_WRITER;\n\t\t\t__spin_unlock_mb_cache_entry(ce);\n\n\t\t\tif (!list_empty(&ce->e_lru_list)) {\n\t\t\t\tspin_lock(&mb_cache_spinlock);\n\t\t\t\tlist_del_init(&ce->e_lru_list);\n\t\t\t\tspin_unlock(&mb_cache_spinlock);\n\t\t\t}\n\t\t\tif (!__mb_cache_entry_is_block_hashed(ce)) {\n\t\t\t\t__mb_cache_entry_release(ce);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn ce;\n\t\t}\n\t}\n\thlist_bl_unlock(block_hash_p);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_GET_MB_CACHE",
          "args": [
            "inode"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);\nstatic struct buffer_head *ext4_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext4_xattr_header *,\n\t\t\t\t\t\t struct mb_cache_entry **);\n\nstatic void\next4_xattr_release_block(handle_t *handle, struct inode *inode,\n\t\t\t struct buffer_head *bh)\n{\n\tstruct mb_cache_entry *ce = NULL;\n\tint error = 0;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\n\tce = mb_cache_entry_get(ext4_mb_cache, bh->b_bdev, bh->b_blocknr);\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terror = ext4_journal_get_write_access(handle, bh);\n\tif (error)\n\t\tgoto out;\n\n\tlock_buffer(bh);\n\tif (BHDR(bh)->h_refcount == cpu_to_le32(1)) {\n\t\tea_bdebug(bh, \"refcount now=0; freeing\");\n\t\tif (ce)\n\t\t\tmb_cache_entry_free(ce);\n\t\tget_bh(bh);\n\t\tunlock_buffer(bh);\n\t\text4_free_blocks(handle, inode, bh, 0, 1,\n\t\t\t\t EXT4_FREE_BLOCKS_METADATA |\n\t\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\t} else {\n\t\tle32_add_cpu(&BHDR(bh)->h_refcount, -1);\n\t\tif (ce)\n\t\t\tmb_cache_entry_release(ce);\n\t\t/*\n\t\t * Beware of this ugliness: Releasing of xattr block references\n\t\t * from different inodes can race and so we have to protect\n\t\t * from a race where someone else frees the block (and releases\n\t\t * its journal_head) before we are done dirtying the buffer. In\n\t\t * nojournal mode this race is harmless and we actually cannot\n\t\t * call ext4_handle_dirty_xattr_block() with locked buffer as\n\t\t * that function can call sync_dirty_buffer() so for that case\n\t\t * we handle the dirtying after unlocking the buffer.\n\t\t */\n\t\tif (ext4_handle_valid(handle))\n\t\t\terror = ext4_handle_dirty_xattr_block(handle, inode,\n\t\t\t\t\t\t\t      bh);\n\t\tunlock_buffer(bh);\n\t\tif (!ext4_handle_valid(handle))\n\t\t\terror = ext4_handle_dirty_xattr_block(handle, inode,\n\t\t\t\t\t\t\t      bh);\n\t\tif (IS_SYNC(inode))\n\t\t\text4_handle_sync(handle);\n\t\tdquot_free_block(inode, EXT4_C2B(EXT4_SB(inode->i_sb), 1));\n\t\tea_bdebug(bh, \"refcount now=%d; releasing\",\n\t\t\t  le32_to_cpu(BHDR(bh)->h_refcount));\n\t}\nout:\n\text4_std_error(inode->i_sb, error);\n\treturn;\n}"
  },
  {
    "function_name": "ext4_xattr_update_super_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
    "lines": "526-537",
    "snippet": "static void ext4_xattr_update_super_block(handle_t *handle,\n\t\t\t\t\t  struct super_block *sb)\n{\n\tif (EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_EXT_ATTR))\n\t\treturn;\n\n\tBUFFER_TRACE(EXT4_SB(sb)->s_sbh, \"get_write_access\");\n\tif (ext4_journal_get_write_access(handle, EXT4_SB(sb)->s_sbh) == 0) {\n\t\tEXT4_SET_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_EXT_ATTR);\n\t\text4_handle_dirty_super(handle, sb);\n\t}\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_handle_dirty_super",
          "args": [
            "handle",
            "sb"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SET_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_COMPAT_EXT_ATTR"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_get_write_access",
          "args": [
            "handle",
            "EXT4_SB(sb)->s_sbh"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "sb"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "EXT4_SB(sb)->s_sbh",
            "\"get_write_access\""
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_HAS_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT4_FEATURE_COMPAT_EXT_ATTR"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_update_super_block(handle_t *handle,\n\t\t\t\t\t  struct super_block *sb)\n{\n\tif (EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_EXT_ATTR))\n\t\treturn;\n\n\tBUFFER_TRACE(EXT4_SB(sb)->s_sbh, \"get_write_access\");\n\tif (ext4_journal_get_write_access(handle, EXT4_SB(sb)->s_sbh) == 0) {\n\t\tEXT4_SET_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_EXT_ATTR);\n\t\text4_handle_dirty_super(handle, sb);\n\t}\n}"
  },
  {
    "function_name": "ext4_xattr_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
    "lines": "500-520",
    "snippet": "static int\next4_xattr_list(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tint ret, ret2;\n\n\tdown_read(&EXT4_I(dentry->d_inode)->xattr_sem);\n\tret = ret2 = ext4_xattr_ibody_list(dentry, buffer, buffer_size);\n\tif (ret < 0)\n\t\tgoto errout;\n\tif (buffer) {\n\t\tbuffer += ret;\n\t\tbuffer_size -= ret;\n\t}\n\tret = ext4_xattr_block_list(dentry, buffer, buffer_size);\n\tif (ret < 0)\n\t\tgoto errout;\n\tret += ret2;\nerrout:\n\tup_read(&EXT4_I(dentry->d_inode)->xattr_sem);\n\treturn ret;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&EXT4_I(dentry->d_inode)->xattr_sem"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "dentry->d_inode"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_xattr_block_list",
          "args": [
            "dentry",
            "buffer",
            "buffer_size"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_block_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "424-459",
          "snippet": "static int\next4_xattr_block_list(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct buffer_head *bh = NULL;\n\tint error;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\n\tea_idebug(inode, \"buffer=%p, buffer_size=%ld\",\n\t\t  buffer, (long)buffer_size);\n\n\terror = 0;\n\tif (!EXT4_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tea_idebug(inode, \"reading block %llu\",\n\t\t  (unsigned long long)EXT4_I(inode)->i_file_acl);\n\tbh = sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl);\n\terror = -EIO;\n\tif (!bh)\n\t\tgoto cleanup;\n\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\tatomic_read(&(bh->b_count)), le32_to_cpu(BHDR(bh)->h_refcount));\n\tif (ext4_xattr_check_block(inode, bh)) {\n\t\tEXT4_ERROR_INODE(inode, \"bad block %llu\",\n\t\t\t\t EXT4_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tgoto cleanup;\n\t}\n\text4_xattr_cache_insert(ext4_mb_cache, bh);\n\terror = ext4_xattr_list_entries(dentry, BFIRST(bh), buffer, buffer_size);\n\ncleanup:\n\tbrelse(bh);\n\n\treturn error;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);",
            "static int ext4_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);\nstatic int ext4_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);\n\nstatic int\next4_xattr_block_list(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct buffer_head *bh = NULL;\n\tint error;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\n\tea_idebug(inode, \"buffer=%p, buffer_size=%ld\",\n\t\t  buffer, (long)buffer_size);\n\n\terror = 0;\n\tif (!EXT4_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tea_idebug(inode, \"reading block %llu\",\n\t\t  (unsigned long long)EXT4_I(inode)->i_file_acl);\n\tbh = sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl);\n\terror = -EIO;\n\tif (!bh)\n\t\tgoto cleanup;\n\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\tatomic_read(&(bh->b_count)), le32_to_cpu(BHDR(bh)->h_refcount));\n\tif (ext4_xattr_check_block(inode, bh)) {\n\t\tEXT4_ERROR_INODE(inode, \"bad block %llu\",\n\t\t\t\t EXT4_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tgoto cleanup;\n\t}\n\text4_xattr_cache_insert(ext4_mb_cache, bh);\n\terror = ext4_xattr_list_entries(dentry, BFIRST(bh), buffer, buffer_size);\n\ncleanup:\n\tbrelse(bh);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_xattr_ibody_list",
          "args": [
            "dentry",
            "buffer",
            "buffer_size"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_ibody_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "461-488",
          "snippet": "static int\next4_xattr_ibody_list(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_inode *raw_inode;\n\tstruct ext4_iloc iloc;\n\tvoid *end;\n\tint error;\n\n\tif (!ext4_test_inode_state(inode, EXT4_STATE_XATTR))\n\t\treturn 0;\n\terror = ext4_get_inode_loc(inode, &iloc);\n\tif (error)\n\t\treturn error;\n\traw_inode = ext4_raw_inode(&iloc);\n\theader = IHDR(inode, raw_inode);\n\tend = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;\n\terror = ext4_xattr_check_names(IFIRST(header), end, IFIRST(header));\n\tif (error)\n\t\tgoto cleanup;\n\terror = ext4_xattr_list_entries(dentry, IFIRST(header),\n\t\t\t\t\tbuffer, buffer_size);\n\ncleanup:\n\tbrelse(iloc.bh);\n\treturn error;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic int ext4_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);\n\nstatic int\next4_xattr_ibody_list(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_inode *raw_inode;\n\tstruct ext4_iloc iloc;\n\tvoid *end;\n\tint error;\n\n\tif (!ext4_test_inode_state(inode, EXT4_STATE_XATTR))\n\t\treturn 0;\n\terror = ext4_get_inode_loc(inode, &iloc);\n\tif (error)\n\t\treturn error;\n\traw_inode = ext4_raw_inode(&iloc);\n\theader = IHDR(inode, raw_inode);\n\tend = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;\n\terror = ext4_xattr_check_names(IFIRST(header), end, IFIRST(header));\n\tif (error)\n\t\tgoto cleanup;\n\terror = ext4_xattr_list_entries(dentry, IFIRST(header),\n\t\t\t\t\tbuffer, buffer_size);\n\ncleanup:\n\tbrelse(iloc.bh);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&EXT4_I(dentry->d_inode)->xattr_sem"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic int ext4_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);\n\nstatic int\next4_xattr_list(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tint ret, ret2;\n\n\tdown_read(&EXT4_I(dentry->d_inode)->xattr_sem);\n\tret = ret2 = ext4_xattr_ibody_list(dentry, buffer, buffer_size);\n\tif (ret < 0)\n\t\tgoto errout;\n\tif (buffer) {\n\t\tbuffer += ret;\n\t\tbuffer_size -= ret;\n\t}\n\tret = ext4_xattr_block_list(dentry, buffer, buffer_size);\n\tif (ret < 0)\n\t\tgoto errout;\n\tret += ret2;\nerrout:\n\tup_read(&EXT4_I(dentry->d_inode)->xattr_sem);\n\treturn ret;\n}"
  },
  {
    "function_name": "ext4_xattr_ibody_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
    "lines": "461-488",
    "snippet": "static int\next4_xattr_ibody_list(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_inode *raw_inode;\n\tstruct ext4_iloc iloc;\n\tvoid *end;\n\tint error;\n\n\tif (!ext4_test_inode_state(inode, EXT4_STATE_XATTR))\n\t\treturn 0;\n\terror = ext4_get_inode_loc(inode, &iloc);\n\tif (error)\n\t\treturn error;\n\traw_inode = ext4_raw_inode(&iloc);\n\theader = IHDR(inode, raw_inode);\n\tend = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;\n\terror = ext4_xattr_check_names(IFIRST(header), end, IFIRST(header));\n\tif (error)\n\t\tgoto cleanup;\n\terror = ext4_xattr_list_entries(dentry, IFIRST(header),\n\t\t\t\t\tbuffer, buffer_size);\n\ncleanup:\n\tbrelse(iloc.bh);\n\treturn error;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "iloc.bh"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_xattr_list_entries",
          "args": [
            "dentry",
            "IFIRST(header)",
            "buffer",
            "buffer_size"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_list_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "398-422",
          "snippet": "static int\next4_xattr_list_entries(struct dentry *dentry, struct ext4_xattr_entry *entry,\n\t\t\tchar *buffer, size_t buffer_size)\n{\n\tsize_t rest = buffer_size;\n\n\tfor (; !IS_LAST_ENTRY(entry); entry = EXT4_XATTR_NEXT(entry)) {\n\t\tconst struct xattr_handler *handler =\n\t\t\text4_xattr_handler(entry->e_name_index);\n\n\t\tif (handler) {\n\t\t\tsize_t size = handler->list(dentry, buffer, rest,\n\t\t\t\t\t\t    entry->e_name,\n\t\t\t\t\t\t    entry->e_name_len,\n\t\t\t\t\t\t    handler->flags);\n\t\t\tif (buffer) {\n\t\t\t\tif (size > rest)\n\t\t\t\t\treturn -ERANGE;\n\t\t\t\tbuffer += size;\n\t\t\t}\n\t\t\trest -= size;\n\t\t}\n\t}\n\treturn buffer_size - rest;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);",
            "static int ext4_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);\nstatic int ext4_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);\n\nstatic int\next4_xattr_list_entries(struct dentry *dentry, struct ext4_xattr_entry *entry,\n\t\t\tchar *buffer, size_t buffer_size)\n{\n\tsize_t rest = buffer_size;\n\n\tfor (; !IS_LAST_ENTRY(entry); entry = EXT4_XATTR_NEXT(entry)) {\n\t\tconst struct xattr_handler *handler =\n\t\t\text4_xattr_handler(entry->e_name_index);\n\n\t\tif (handler) {\n\t\t\tsize_t size = handler->list(dentry, buffer, rest,\n\t\t\t\t\t\t    entry->e_name,\n\t\t\t\t\t\t    entry->e_name_len,\n\t\t\t\t\t\t    handler->flags);\n\t\t\tif (buffer) {\n\t\t\t\tif (size > rest)\n\t\t\t\t\treturn -ERANGE;\n\t\t\t\tbuffer += size;\n\t\t\t}\n\t\t\trest -= size;\n\t\t}\n\t}\n\treturn buffer_size - rest;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IFIRST",
          "args": [
            "header"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_xattr_check_names",
          "args": [
            "IFIRST(header)",
            "end",
            "IFIRST(header)"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_check_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "190-214",
          "snippet": "static int\next4_xattr_check_names(struct ext4_xattr_entry *entry, void *end,\n\t\t       void *value_start)\n{\n\tstruct ext4_xattr_entry *e = entry;\n\n\twhile (!IS_LAST_ENTRY(e)) {\n\t\tstruct ext4_xattr_entry *next = EXT4_XATTR_NEXT(e);\n\t\tif ((void *)next >= end)\n\t\t\treturn -EIO;\n\t\te = next;\n\t}\n\n\twhile (!IS_LAST_ENTRY(entry)) {\n\t\tif (entry->e_value_size != 0 &&\n\t\t    (value_start + le16_to_cpu(entry->e_value_offs) <\n\t\t     (void *)e + sizeof(__u32) ||\n\t\t     value_start + le16_to_cpu(entry->e_value_offs) +\n\t\t    le32_to_cpu(entry->e_value_size) > end))\n\t\t\treturn -EIO;\n\t\tentry = EXT4_XATTR_NEXT(entry);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);\n\nstatic int\next4_xattr_check_names(struct ext4_xattr_entry *entry, void *end,\n\t\t       void *value_start)\n{\n\tstruct ext4_xattr_entry *e = entry;\n\n\twhile (!IS_LAST_ENTRY(e)) {\n\t\tstruct ext4_xattr_entry *next = EXT4_XATTR_NEXT(e);\n\t\tif ((void *)next >= end)\n\t\t\treturn -EIO;\n\t\te = next;\n\t}\n\n\twhile (!IS_LAST_ENTRY(entry)) {\n\t\tif (entry->e_value_size != 0 &&\n\t\t    (value_start + le16_to_cpu(entry->e_value_offs) <\n\t\t     (void *)e + sizeof(__u32) ||\n\t\t     value_start + le16_to_cpu(entry->e_value_offs) +\n\t\t    le32_to_cpu(entry->e_value_size) > end))\n\t\t\treturn -EIO;\n\t\tentry = EXT4_XATTR_NEXT(entry);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IFIRST",
          "args": [
            "header"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IFIRST",
          "args": [
            "header"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IHDR",
          "args": [
            "inode",
            "raw_inode"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_raw_inode",
          "args": [
            "&iloc"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_raw_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1810-1813",
          "snippet": "static inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_inode_loc",
          "args": [
            "inode",
            "&iloc"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_inode_loc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3816-3821",
          "snippet": "int ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_XATTR"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic int ext4_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);\n\nstatic int\next4_xattr_ibody_list(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_inode *raw_inode;\n\tstruct ext4_iloc iloc;\n\tvoid *end;\n\tint error;\n\n\tif (!ext4_test_inode_state(inode, EXT4_STATE_XATTR))\n\t\treturn 0;\n\terror = ext4_get_inode_loc(inode, &iloc);\n\tif (error)\n\t\treturn error;\n\traw_inode = ext4_raw_inode(&iloc);\n\theader = IHDR(inode, raw_inode);\n\tend = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;\n\terror = ext4_xattr_check_names(IFIRST(header), end, IFIRST(header));\n\tif (error)\n\t\tgoto cleanup;\n\terror = ext4_xattr_list_entries(dentry, IFIRST(header),\n\t\t\t\t\tbuffer, buffer_size);\n\ncleanup:\n\tbrelse(iloc.bh);\n\treturn error;\n}"
  },
  {
    "function_name": "ext4_xattr_block_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
    "lines": "424-459",
    "snippet": "static int\next4_xattr_block_list(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct buffer_head *bh = NULL;\n\tint error;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\n\tea_idebug(inode, \"buffer=%p, buffer_size=%ld\",\n\t\t  buffer, (long)buffer_size);\n\n\terror = 0;\n\tif (!EXT4_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tea_idebug(inode, \"reading block %llu\",\n\t\t  (unsigned long long)EXT4_I(inode)->i_file_acl);\n\tbh = sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl);\n\terror = -EIO;\n\tif (!bh)\n\t\tgoto cleanup;\n\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\tatomic_read(&(bh->b_count)), le32_to_cpu(BHDR(bh)->h_refcount));\n\tif (ext4_xattr_check_block(inode, bh)) {\n\t\tEXT4_ERROR_INODE(inode, \"bad block %llu\",\n\t\t\t\t EXT4_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tgoto cleanup;\n\t}\n\text4_xattr_cache_insert(ext4_mb_cache, bh);\n\terror = ext4_xattr_list_entries(dentry, BFIRST(bh), buffer, buffer_size);\n\ncleanup:\n\tbrelse(bh);\n\n\treturn error;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);",
      "static int ext4_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_xattr_list_entries",
          "args": [
            "dentry",
            "BFIRST(bh)",
            "buffer",
            "buffer_size"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_list_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "398-422",
          "snippet": "static int\next4_xattr_list_entries(struct dentry *dentry, struct ext4_xattr_entry *entry,\n\t\t\tchar *buffer, size_t buffer_size)\n{\n\tsize_t rest = buffer_size;\n\n\tfor (; !IS_LAST_ENTRY(entry); entry = EXT4_XATTR_NEXT(entry)) {\n\t\tconst struct xattr_handler *handler =\n\t\t\text4_xattr_handler(entry->e_name_index);\n\n\t\tif (handler) {\n\t\t\tsize_t size = handler->list(dentry, buffer, rest,\n\t\t\t\t\t\t    entry->e_name,\n\t\t\t\t\t\t    entry->e_name_len,\n\t\t\t\t\t\t    handler->flags);\n\t\t\tif (buffer) {\n\t\t\t\tif (size > rest)\n\t\t\t\t\treturn -ERANGE;\n\t\t\t\tbuffer += size;\n\t\t\t}\n\t\t\trest -= size;\n\t\t}\n\t}\n\treturn buffer_size - rest;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);",
            "static int ext4_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);\nstatic int ext4_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);\n\nstatic int\next4_xattr_list_entries(struct dentry *dentry, struct ext4_xattr_entry *entry,\n\t\t\tchar *buffer, size_t buffer_size)\n{\n\tsize_t rest = buffer_size;\n\n\tfor (; !IS_LAST_ENTRY(entry); entry = EXT4_XATTR_NEXT(entry)) {\n\t\tconst struct xattr_handler *handler =\n\t\t\text4_xattr_handler(entry->e_name_index);\n\n\t\tif (handler) {\n\t\t\tsize_t size = handler->list(dentry, buffer, rest,\n\t\t\t\t\t\t    entry->e_name,\n\t\t\t\t\t\t    entry->e_name_len,\n\t\t\t\t\t\t    handler->flags);\n\t\t\tif (buffer) {\n\t\t\t\tif (size > rest)\n\t\t\t\t\treturn -ERANGE;\n\t\t\t\tbuffer += size;\n\t\t\t}\n\t\t\trest -= size;\n\t\t}\n\t}\n\treturn buffer_size - rest;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BFIRST",
          "args": [
            "bh"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_xattr_cache_insert",
          "args": [
            "ext4_mb_cache",
            "bh"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_cache_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "1533-1556",
          "snippet": "static void\next4_xattr_cache_insert(struct mb_cache *ext4_mb_cache, struct buffer_head *bh)\n{\n\t__u32 hash = le32_to_cpu(BHDR(bh)->h_hash);\n\tstruct mb_cache_entry *ce;\n\tint error;\n\n\tce = mb_cache_entry_alloc(ext4_mb_cache, GFP_NOFS);\n\tif (!ce) {\n\t\tea_bdebug(bh, \"out of memory\");\n\t\treturn;\n\t}\n\terror = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, hash);\n\tif (error) {\n\t\tmb_cache_entry_free(ce);\n\t\tif (error == -EBUSY) {\n\t\t\tea_bdebug(bh, \"already in cache\");\n\t\t\terror = 0;\n\t\t}\n\t} else {\n\t\tea_bdebug(bh, \"inserting [%x]\", (int)hash);\n\t\tmb_cache_entry_release(ce);\n\t}\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);",
            "static struct buffer_head *ext4_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext4_xattr_header *,\n\t\t\t\t\t\t struct mb_cache_entry **);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);\nstatic struct buffer_head *ext4_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext4_xattr_header *,\n\t\t\t\t\t\t struct mb_cache_entry **);\n\nstatic void\next4_xattr_cache_insert(struct mb_cache *ext4_mb_cache, struct buffer_head *bh)\n{\n\t__u32 hash = le32_to_cpu(BHDR(bh)->h_hash);\n\tstruct mb_cache_entry *ce;\n\tint error;\n\n\tce = mb_cache_entry_alloc(ext4_mb_cache, GFP_NOFS);\n\tif (!ce) {\n\t\tea_bdebug(bh, \"out of memory\");\n\t\treturn;\n\t}\n\terror = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, hash);\n\tif (error) {\n\t\tmb_cache_entry_free(ce);\n\t\tif (error == -EBUSY) {\n\t\t\tea_bdebug(bh, \"already in cache\");\n\t\t\terror = 0;\n\t\t}\n\t} else {\n\t\tea_bdebug(bh, \"inserting [%x]\", (int)hash);\n\t\tmb_cache_entry_release(ce);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_ERROR_INODE",
          "args": [
            "inode",
            "\"bad block %llu\"",
            "EXT4_I(inode)->i_file_acl"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_xattr_check_block",
          "args": [
            "inode",
            "bh"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_check_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "216-234",
          "snippet": "static inline int\next4_xattr_check_block(struct inode *inode, struct buffer_head *bh)\n{\n\tint error;\n\n\tif (buffer_verified(bh))\n\t\treturn 0;\n\n\tif (BHDR(bh)->h_magic != cpu_to_le32(EXT4_XATTR_MAGIC) ||\n\t    BHDR(bh)->h_blocks != cpu_to_le32(1))\n\t\treturn -EIO;\n\tif (!ext4_xattr_block_csum_verify(inode, bh->b_blocknr, BHDR(bh)))\n\t\treturn -EIO;\n\terror = ext4_xattr_check_names(BFIRST(bh), bh->b_data + bh->b_size,\n\t\t\t\t       bh->b_data);\n\tif (!error)\n\t\tset_buffer_verified(bh);\n\treturn error;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);\n\nstatic inline int\next4_xattr_check_block(struct inode *inode, struct buffer_head *bh)\n{\n\tint error;\n\n\tif (buffer_verified(bh))\n\t\treturn 0;\n\n\tif (BHDR(bh)->h_magic != cpu_to_le32(EXT4_XATTR_MAGIC) ||\n\t    BHDR(bh)->h_blocks != cpu_to_le32(1))\n\t\treturn -EIO;\n\tif (!ext4_xattr_block_csum_verify(inode, bh->b_blocknr, BHDR(bh)))\n\t\treturn -EIO;\n\terror = ext4_xattr_check_names(BFIRST(bh), bh->b_data + bh->b_size,\n\t\t\t\t       bh->b_data);\n\tif (!error)\n\t\tset_buffer_verified(bh);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_bdebug",
          "args": [
            "bh",
            "\"b_count=%d, refcount=%d\"",
            "atomic_read(&(bh->b_count))",
            "le32_to_cpu(BHDR(bh)->h_refcount)"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "BHDR(bh)->h_refcount"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BHDR",
          "args": [
            "bh"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&(bh->b_count)"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "inode->i_sb",
            "EXT4_I(inode)->i_file_acl"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_idebug",
          "args": [
            "inode",
            "\"reading block %llu\"",
            "(unsigned long long)EXT4_I(inode)->i_file_acl"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_idebug",
          "args": [
            "inode",
            "\"buffer=%p, buffer_size=%ld\"",
            "buffer",
            "(long)buffer_size"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_GET_MB_CACHE",
          "args": [
            "inode"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);\nstatic int ext4_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);\n\nstatic int\next4_xattr_block_list(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct buffer_head *bh = NULL;\n\tint error;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\n\tea_idebug(inode, \"buffer=%p, buffer_size=%ld\",\n\t\t  buffer, (long)buffer_size);\n\n\terror = 0;\n\tif (!EXT4_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tea_idebug(inode, \"reading block %llu\",\n\t\t  (unsigned long long)EXT4_I(inode)->i_file_acl);\n\tbh = sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl);\n\terror = -EIO;\n\tif (!bh)\n\t\tgoto cleanup;\n\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\tatomic_read(&(bh->b_count)), le32_to_cpu(BHDR(bh)->h_refcount));\n\tif (ext4_xattr_check_block(inode, bh)) {\n\t\tEXT4_ERROR_INODE(inode, \"bad block %llu\",\n\t\t\t\t EXT4_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tgoto cleanup;\n\t}\n\text4_xattr_cache_insert(ext4_mb_cache, bh);\n\terror = ext4_xattr_list_entries(dentry, BFIRST(bh), buffer, buffer_size);\n\ncleanup:\n\tbrelse(bh);\n\n\treturn error;\n}"
  },
  {
    "function_name": "ext4_xattr_list_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
    "lines": "398-422",
    "snippet": "static int\next4_xattr_list_entries(struct dentry *dentry, struct ext4_xattr_entry *entry,\n\t\t\tchar *buffer, size_t buffer_size)\n{\n\tsize_t rest = buffer_size;\n\n\tfor (; !IS_LAST_ENTRY(entry); entry = EXT4_XATTR_NEXT(entry)) {\n\t\tconst struct xattr_handler *handler =\n\t\t\text4_xattr_handler(entry->e_name_index);\n\n\t\tif (handler) {\n\t\t\tsize_t size = handler->list(dentry, buffer, rest,\n\t\t\t\t\t\t    entry->e_name,\n\t\t\t\t\t\t    entry->e_name_len,\n\t\t\t\t\t\t    handler->flags);\n\t\t\tif (buffer) {\n\t\t\t\tif (size > rest)\n\t\t\t\t\treturn -ERANGE;\n\t\t\t\tbuffer += size;\n\t\t\t}\n\t\t\trest -= size;\n\t\t}\n\t}\n\treturn buffer_size - rest;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);",
      "static int ext4_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "handler->list",
          "args": [
            "dentry",
            "buffer",
            "rest",
            "entry->e_name",
            "entry->e_name_len",
            "handler->flags"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_xattr_handler",
          "args": [
            "entry->e_name_index"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "169-177",
          "snippet": "static inline const struct xattr_handler *\next4_xattr_handler(int name_index)\n{\n\tconst struct xattr_handler *handler = NULL;\n\n\tif (name_index > 0 && name_index < ARRAY_SIZE(ext4_xattr_handler_map))\n\t\thandler = ext4_xattr_handler_map[name_index];\n\treturn handler;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct xattr_handler *ext4_xattr_handler_map[] = {\n\t[EXT4_XATTR_INDEX_USER]\t\t     = &ext4_xattr_user_handler,\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\t[EXT4_XATTR_INDEX_POSIX_ACL_ACCESS]  = &posix_acl_access_xattr_handler,\n\t[EXT4_XATTR_INDEX_POSIX_ACL_DEFAULT] = &posix_acl_default_xattr_handler,\n#endif\n\t[EXT4_XATTR_INDEX_TRUSTED]\t     = &ext4_xattr_trusted_handler,\n#ifdef CONFIG_EXT4_FS_SECURITY\n\t[EXT4_XATTR_INDEX_SECURITY]\t     = &ext4_xattr_security_handler,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic const struct xattr_handler *ext4_xattr_handler_map[] = {\n\t[EXT4_XATTR_INDEX_USER]\t\t     = &ext4_xattr_user_handler,\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\t[EXT4_XATTR_INDEX_POSIX_ACL_ACCESS]  = &posix_acl_access_xattr_handler,\n\t[EXT4_XATTR_INDEX_POSIX_ACL_DEFAULT] = &posix_acl_default_xattr_handler,\n#endif\n\t[EXT4_XATTR_INDEX_TRUSTED]\t     = &ext4_xattr_trusted_handler,\n#ifdef CONFIG_EXT4_FS_SECURITY\n\t[EXT4_XATTR_INDEX_SECURITY]\t     = &ext4_xattr_security_handler,\n#endif\n};\n\nstatic inline const struct xattr_handler *\next4_xattr_handler(int name_index)\n{\n\tconst struct xattr_handler *handler = NULL;\n\n\tif (name_index > 0 && name_index < ARRAY_SIZE(ext4_xattr_handler_map))\n\t\thandler = ext4_xattr_handler_map[name_index];\n\treturn handler;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_XATTR_NEXT",
          "args": [
            "entry"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LAST_ENTRY",
          "args": [
            "entry"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);\nstatic int ext4_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);\n\nstatic int\next4_xattr_list_entries(struct dentry *dentry, struct ext4_xattr_entry *entry,\n\t\t\tchar *buffer, size_t buffer_size)\n{\n\tsize_t rest = buffer_size;\n\n\tfor (; !IS_LAST_ENTRY(entry); entry = EXT4_XATTR_NEXT(entry)) {\n\t\tconst struct xattr_handler *handler =\n\t\t\text4_xattr_handler(entry->e_name_index);\n\n\t\tif (handler) {\n\t\t\tsize_t size = handler->list(dentry, buffer, rest,\n\t\t\t\t\t\t    entry->e_name,\n\t\t\t\t\t\t    entry->e_name_len,\n\t\t\t\t\t\t    handler->flags);\n\t\t\tif (buffer) {\n\t\t\t\tif (size > rest)\n\t\t\t\t\treturn -ERANGE;\n\t\t\t\tbuffer += size;\n\t\t\t}\n\t\t\trest -= size;\n\t\t}\n\t}\n\treturn buffer_size - rest;\n}"
  },
  {
    "function_name": "ext4_xattr_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
    "lines": "379-396",
    "snippet": "int\next4_xattr_get(struct inode *inode, int name_index, const char *name,\n\t       void *buffer, size_t buffer_size)\n{\n\tint error;\n\n\tif (strlen(name) > 255)\n\t\treturn -ERANGE;\n\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\terror = ext4_xattr_ibody_get(inode, name_index, name, buffer,\n\t\t\t\t     buffer_size);\n\tif (error == -ENODATA)\n\t\terror = ext4_xattr_block_get(inode, name_index, name, buffer,\n\t\t\t\t\t     buffer_size);\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\treturn error;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext4_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&EXT4_I(inode)->xattr_sem"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_xattr_block_get",
          "args": [
            "inode",
            "name_index",
            "name",
            "buffer",
            "buffer_size"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_block_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "274-324",
          "snippet": "static int\next4_xattr_block_get(struct inode *inode, int name_index, const char *name,\n\t\t     void *buffer, size_t buffer_size)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct ext4_xattr_entry *entry;\n\tsize_t size;\n\tint error;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\n\tea_idebug(inode, \"name=%d.%s, buffer=%p, buffer_size=%ld\",\n\t\t  name_index, name, buffer, (long)buffer_size);\n\n\terror = -ENODATA;\n\tif (!EXT4_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tea_idebug(inode, \"reading block %llu\",\n\t\t  (unsigned long long)EXT4_I(inode)->i_file_acl);\n\tbh = sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl);\n\tif (!bh)\n\t\tgoto cleanup;\n\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\tatomic_read(&(bh->b_count)), le32_to_cpu(BHDR(bh)->h_refcount));\n\tif (ext4_xattr_check_block(inode, bh)) {\nbad_block:\n\t\tEXT4_ERROR_INODE(inode, \"bad block %llu\",\n\t\t\t\t EXT4_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tgoto cleanup;\n\t}\n\text4_xattr_cache_insert(ext4_mb_cache, bh);\n\tentry = BFIRST(bh);\n\terror = ext4_xattr_find_entry(&entry, name_index, name, bh->b_size, 1);\n\tif (error == -EIO)\n\t\tgoto bad_block;\n\tif (error)\n\t\tgoto cleanup;\n\tsize = le32_to_cpu(entry->e_value_size);\n\tif (buffer) {\n\t\terror = -ERANGE;\n\t\tif (size > buffer_size)\n\t\t\tgoto cleanup;\n\t\tmemcpy(buffer, bh->b_data + le16_to_cpu(entry->e_value_offs),\n\t\t       size);\n\t}\n\terror = size;\n\ncleanup:\n\tbrelse(bh);\n\treturn error;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);",
            "static void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);",
            "static int ext4_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);\nstatic void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);\nstatic int ext4_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);\n\nstatic int\next4_xattr_block_get(struct inode *inode, int name_index, const char *name,\n\t\t     void *buffer, size_t buffer_size)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct ext4_xattr_entry *entry;\n\tsize_t size;\n\tint error;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\n\tea_idebug(inode, \"name=%d.%s, buffer=%p, buffer_size=%ld\",\n\t\t  name_index, name, buffer, (long)buffer_size);\n\n\terror = -ENODATA;\n\tif (!EXT4_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tea_idebug(inode, \"reading block %llu\",\n\t\t  (unsigned long long)EXT4_I(inode)->i_file_acl);\n\tbh = sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl);\n\tif (!bh)\n\t\tgoto cleanup;\n\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\tatomic_read(&(bh->b_count)), le32_to_cpu(BHDR(bh)->h_refcount));\n\tif (ext4_xattr_check_block(inode, bh)) {\nbad_block:\n\t\tEXT4_ERROR_INODE(inode, \"bad block %llu\",\n\t\t\t\t EXT4_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tgoto cleanup;\n\t}\n\text4_xattr_cache_insert(ext4_mb_cache, bh);\n\tentry = BFIRST(bh);\n\terror = ext4_xattr_find_entry(&entry, name_index, name, bh->b_size, 1);\n\tif (error == -EIO)\n\t\tgoto bad_block;\n\tif (error)\n\t\tgoto cleanup;\n\tsize = le32_to_cpu(entry->e_value_size);\n\tif (buffer) {\n\t\terror = -ERANGE;\n\t\tif (size > buffer_size)\n\t\t\tgoto cleanup;\n\t\tmemcpy(buffer, bh->b_data + le16_to_cpu(entry->e_value_offs),\n\t\t       size);\n\t}\n\terror = size;\n\ncleanup:\n\tbrelse(bh);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_xattr_ibody_get",
          "args": [
            "inode",
            "name_index",
            "name",
            "buffer",
            "buffer_size"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_ibody_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "326-367",
          "snippet": "int\next4_xattr_ibody_get(struct inode *inode, int name_index, const char *name,\n\t\t     void *buffer, size_t buffer_size)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_inode *raw_inode;\n\tstruct ext4_iloc iloc;\n\tsize_t size;\n\tvoid *end;\n\tint error;\n\n\tif (!ext4_test_inode_state(inode, EXT4_STATE_XATTR))\n\t\treturn -ENODATA;\n\terror = ext4_get_inode_loc(inode, &iloc);\n\tif (error)\n\t\treturn error;\n\traw_inode = ext4_raw_inode(&iloc);\n\theader = IHDR(inode, raw_inode);\n\tentry = IFIRST(header);\n\tend = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;\n\terror = ext4_xattr_check_names(entry, end, entry);\n\tif (error)\n\t\tgoto cleanup;\n\terror = ext4_xattr_find_entry(&entry, name_index, name,\n\t\t\t\t      end - (void *)entry, 0);\n\tif (error)\n\t\tgoto cleanup;\n\tsize = le32_to_cpu(entry->e_value_size);\n\tif (buffer) {\n\t\terror = -ERANGE;\n\t\tif (size > buffer_size)\n\t\t\tgoto cleanup;\n\t\tmemcpy(buffer, (void *)IFIRST(header) +\n\t\t       le16_to_cpu(entry->e_value_offs), size);\n\t}\n\terror = size;\n\ncleanup:\n\tbrelse(iloc.bh);\n\treturn error;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);",
            "static int ext4_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);\nstatic int ext4_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);\n\nint\next4_xattr_ibody_get(struct inode *inode, int name_index, const char *name,\n\t\t     void *buffer, size_t buffer_size)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_inode *raw_inode;\n\tstruct ext4_iloc iloc;\n\tsize_t size;\n\tvoid *end;\n\tint error;\n\n\tif (!ext4_test_inode_state(inode, EXT4_STATE_XATTR))\n\t\treturn -ENODATA;\n\terror = ext4_get_inode_loc(inode, &iloc);\n\tif (error)\n\t\treturn error;\n\traw_inode = ext4_raw_inode(&iloc);\n\theader = IHDR(inode, raw_inode);\n\tentry = IFIRST(header);\n\tend = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;\n\terror = ext4_xattr_check_names(entry, end, entry);\n\tif (error)\n\t\tgoto cleanup;\n\terror = ext4_xattr_find_entry(&entry, name_index, name,\n\t\t\t\t      end - (void *)entry, 0);\n\tif (error)\n\t\tgoto cleanup;\n\tsize = le32_to_cpu(entry->e_value_size);\n\tif (buffer) {\n\t\terror = -ERANGE;\n\t\tif (size > buffer_size)\n\t\t\tgoto cleanup;\n\t\tmemcpy(buffer, (void *)IFIRST(header) +\n\t\t       le16_to_cpu(entry->e_value_offs), size);\n\t}\n\terror = size;\n\ncleanup:\n\tbrelse(iloc.bh);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&EXT4_I(inode)->xattr_sem"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic int ext4_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);\n\nint\next4_xattr_get(struct inode *inode, int name_index, const char *name,\n\t       void *buffer, size_t buffer_size)\n{\n\tint error;\n\n\tif (strlen(name) > 255)\n\t\treturn -ERANGE;\n\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\terror = ext4_xattr_ibody_get(inode, name_index, name, buffer,\n\t\t\t\t     buffer_size);\n\tif (error == -ENODATA)\n\t\terror = ext4_xattr_block_get(inode, name_index, name, buffer,\n\t\t\t\t\t     buffer_size);\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\treturn error;\n}"
  },
  {
    "function_name": "ext4_xattr_ibody_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
    "lines": "326-367",
    "snippet": "int\next4_xattr_ibody_get(struct inode *inode, int name_index, const char *name,\n\t\t     void *buffer, size_t buffer_size)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_inode *raw_inode;\n\tstruct ext4_iloc iloc;\n\tsize_t size;\n\tvoid *end;\n\tint error;\n\n\tif (!ext4_test_inode_state(inode, EXT4_STATE_XATTR))\n\t\treturn -ENODATA;\n\terror = ext4_get_inode_loc(inode, &iloc);\n\tif (error)\n\t\treturn error;\n\traw_inode = ext4_raw_inode(&iloc);\n\theader = IHDR(inode, raw_inode);\n\tentry = IFIRST(header);\n\tend = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;\n\terror = ext4_xattr_check_names(entry, end, entry);\n\tif (error)\n\t\tgoto cleanup;\n\terror = ext4_xattr_find_entry(&entry, name_index, name,\n\t\t\t\t      end - (void *)entry, 0);\n\tif (error)\n\t\tgoto cleanup;\n\tsize = le32_to_cpu(entry->e_value_size);\n\tif (buffer) {\n\t\terror = -ERANGE;\n\t\tif (size > buffer_size)\n\t\t\tgoto cleanup;\n\t\tmemcpy(buffer, (void *)IFIRST(header) +\n\t\t       le16_to_cpu(entry->e_value_offs), size);\n\t}\n\terror = size;\n\ncleanup:\n\tbrelse(iloc.bh);\n\treturn error;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);",
      "static int ext4_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "iloc.bh"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer",
            "(void *)IFIRST(header) +\n\t\t       le16_to_cpu(entry->e_value_offs)",
            "size"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "entry->e_value_offs"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IFIRST",
          "args": [
            "header"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "entry->e_value_size"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_xattr_find_entry",
          "args": [
            "&entry",
            "name_index",
            "name",
            "end - (void *)entry",
            "0"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "247-272",
          "snippet": "static int\next4_xattr_find_entry(struct ext4_xattr_entry **pentry, int name_index,\n\t\t      const char *name, size_t size, int sorted)\n{\n\tstruct ext4_xattr_entry *entry;\n\tsize_t name_len;\n\tint cmp = 1;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\tname_len = strlen(name);\n\tentry = *pentry;\n\tfor (; !IS_LAST_ENTRY(entry); entry = EXT4_XATTR_NEXT(entry)) {\n\t\tcmp = name_index - entry->e_name_index;\n\t\tif (!cmp)\n\t\t\tcmp = name_len - entry->e_name_len;\n\t\tif (!cmp)\n\t\t\tcmp = memcmp(name, entry->e_name, name_len);\n\t\tif (cmp <= 0 && (sorted || cmp == 0))\n\t\t\tbreak;\n\t}\n\t*pentry = entry;\n\tif (!cmp && ext4_xattr_check_entry(entry, size))\n\t\t\treturn -EIO;\n\treturn cmp ? -ENODATA : 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);\n\nstatic int\next4_xattr_find_entry(struct ext4_xattr_entry **pentry, int name_index,\n\t\t      const char *name, size_t size, int sorted)\n{\n\tstruct ext4_xattr_entry *entry;\n\tsize_t name_len;\n\tint cmp = 1;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\tname_len = strlen(name);\n\tentry = *pentry;\n\tfor (; !IS_LAST_ENTRY(entry); entry = EXT4_XATTR_NEXT(entry)) {\n\t\tcmp = name_index - entry->e_name_index;\n\t\tif (!cmp)\n\t\t\tcmp = name_len - entry->e_name_len;\n\t\tif (!cmp)\n\t\t\tcmp = memcmp(name, entry->e_name, name_len);\n\t\tif (cmp <= 0 && (sorted || cmp == 0))\n\t\t\tbreak;\n\t}\n\t*pentry = entry;\n\tif (!cmp && ext4_xattr_check_entry(entry, size))\n\t\t\treturn -EIO;\n\treturn cmp ? -ENODATA : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_xattr_check_names",
          "args": [
            "entry",
            "end",
            "entry"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_check_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "190-214",
          "snippet": "static int\next4_xattr_check_names(struct ext4_xattr_entry *entry, void *end,\n\t\t       void *value_start)\n{\n\tstruct ext4_xattr_entry *e = entry;\n\n\twhile (!IS_LAST_ENTRY(e)) {\n\t\tstruct ext4_xattr_entry *next = EXT4_XATTR_NEXT(e);\n\t\tif ((void *)next >= end)\n\t\t\treturn -EIO;\n\t\te = next;\n\t}\n\n\twhile (!IS_LAST_ENTRY(entry)) {\n\t\tif (entry->e_value_size != 0 &&\n\t\t    (value_start + le16_to_cpu(entry->e_value_offs) <\n\t\t     (void *)e + sizeof(__u32) ||\n\t\t     value_start + le16_to_cpu(entry->e_value_offs) +\n\t\t    le32_to_cpu(entry->e_value_size) > end))\n\t\t\treturn -EIO;\n\t\tentry = EXT4_XATTR_NEXT(entry);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);\n\nstatic int\next4_xattr_check_names(struct ext4_xattr_entry *entry, void *end,\n\t\t       void *value_start)\n{\n\tstruct ext4_xattr_entry *e = entry;\n\n\twhile (!IS_LAST_ENTRY(e)) {\n\t\tstruct ext4_xattr_entry *next = EXT4_XATTR_NEXT(e);\n\t\tif ((void *)next >= end)\n\t\t\treturn -EIO;\n\t\te = next;\n\t}\n\n\twhile (!IS_LAST_ENTRY(entry)) {\n\t\tif (entry->e_value_size != 0 &&\n\t\t    (value_start + le16_to_cpu(entry->e_value_offs) <\n\t\t     (void *)e + sizeof(__u32) ||\n\t\t     value_start + le16_to_cpu(entry->e_value_offs) +\n\t\t    le32_to_cpu(entry->e_value_size) > end))\n\t\t\treturn -EIO;\n\t\tentry = EXT4_XATTR_NEXT(entry);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IFIRST",
          "args": [
            "header"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IHDR",
          "args": [
            "inode",
            "raw_inode"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_raw_inode",
          "args": [
            "&iloc"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_raw_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1810-1813",
          "snippet": "static inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode *ext4_raw_inode(struct ext4_iloc *iloc)\n{\n\treturn (struct ext4_inode *) (iloc->bh->b_data + iloc->offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_get_inode_loc",
          "args": [
            "inode",
            "&iloc"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_get_inode_loc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "3816-3821",
          "snippet": "int ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_test_inode_state",
          "args": [
            "inode",
            "EXT4_STATE_XATTR"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);\nstatic int ext4_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);\n\nint\next4_xattr_ibody_get(struct inode *inode, int name_index, const char *name,\n\t\t     void *buffer, size_t buffer_size)\n{\n\tstruct ext4_xattr_ibody_header *header;\n\tstruct ext4_xattr_entry *entry;\n\tstruct ext4_inode *raw_inode;\n\tstruct ext4_iloc iloc;\n\tsize_t size;\n\tvoid *end;\n\tint error;\n\n\tif (!ext4_test_inode_state(inode, EXT4_STATE_XATTR))\n\t\treturn -ENODATA;\n\terror = ext4_get_inode_loc(inode, &iloc);\n\tif (error)\n\t\treturn error;\n\traw_inode = ext4_raw_inode(&iloc);\n\theader = IHDR(inode, raw_inode);\n\tentry = IFIRST(header);\n\tend = (void *)raw_inode + EXT4_SB(inode->i_sb)->s_inode_size;\n\terror = ext4_xattr_check_names(entry, end, entry);\n\tif (error)\n\t\tgoto cleanup;\n\terror = ext4_xattr_find_entry(&entry, name_index, name,\n\t\t\t\t      end - (void *)entry, 0);\n\tif (error)\n\t\tgoto cleanup;\n\tsize = le32_to_cpu(entry->e_value_size);\n\tif (buffer) {\n\t\terror = -ERANGE;\n\t\tif (size > buffer_size)\n\t\t\tgoto cleanup;\n\t\tmemcpy(buffer, (void *)IFIRST(header) +\n\t\t       le16_to_cpu(entry->e_value_offs), size);\n\t}\n\terror = size;\n\ncleanup:\n\tbrelse(iloc.bh);\n\treturn error;\n}"
  },
  {
    "function_name": "ext4_xattr_block_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
    "lines": "274-324",
    "snippet": "static int\next4_xattr_block_get(struct inode *inode, int name_index, const char *name,\n\t\t     void *buffer, size_t buffer_size)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct ext4_xattr_entry *entry;\n\tsize_t size;\n\tint error;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\n\tea_idebug(inode, \"name=%d.%s, buffer=%p, buffer_size=%ld\",\n\t\t  name_index, name, buffer, (long)buffer_size);\n\n\terror = -ENODATA;\n\tif (!EXT4_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tea_idebug(inode, \"reading block %llu\",\n\t\t  (unsigned long long)EXT4_I(inode)->i_file_acl);\n\tbh = sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl);\n\tif (!bh)\n\t\tgoto cleanup;\n\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\tatomic_read(&(bh->b_count)), le32_to_cpu(BHDR(bh)->h_refcount));\n\tif (ext4_xattr_check_block(inode, bh)) {\nbad_block:\n\t\tEXT4_ERROR_INODE(inode, \"bad block %llu\",\n\t\t\t\t EXT4_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tgoto cleanup;\n\t}\n\text4_xattr_cache_insert(ext4_mb_cache, bh);\n\tentry = BFIRST(bh);\n\terror = ext4_xattr_find_entry(&entry, name_index, name, bh->b_size, 1);\n\tif (error == -EIO)\n\t\tgoto bad_block;\n\tif (error)\n\t\tgoto cleanup;\n\tsize = le32_to_cpu(entry->e_value_size);\n\tif (buffer) {\n\t\terror = -ERANGE;\n\t\tif (size > buffer_size)\n\t\t\tgoto cleanup;\n\t\tmemcpy(buffer, bh->b_data + le16_to_cpu(entry->e_value_offs),\n\t\t       size);\n\t}\n\terror = size;\n\ncleanup:\n\tbrelse(bh);\n\treturn error;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);",
      "static void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);",
      "static int ext4_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer",
            "bh->b_data + le16_to_cpu(entry->e_value_offs)",
            "size"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "entry->e_value_offs"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "entry->e_value_size"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_xattr_find_entry",
          "args": [
            "&entry",
            "name_index",
            "name",
            "bh->b_size",
            "1"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "247-272",
          "snippet": "static int\next4_xattr_find_entry(struct ext4_xattr_entry **pentry, int name_index,\n\t\t      const char *name, size_t size, int sorted)\n{\n\tstruct ext4_xattr_entry *entry;\n\tsize_t name_len;\n\tint cmp = 1;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\tname_len = strlen(name);\n\tentry = *pentry;\n\tfor (; !IS_LAST_ENTRY(entry); entry = EXT4_XATTR_NEXT(entry)) {\n\t\tcmp = name_index - entry->e_name_index;\n\t\tif (!cmp)\n\t\t\tcmp = name_len - entry->e_name_len;\n\t\tif (!cmp)\n\t\t\tcmp = memcmp(name, entry->e_name, name_len);\n\t\tif (cmp <= 0 && (sorted || cmp == 0))\n\t\t\tbreak;\n\t}\n\t*pentry = entry;\n\tif (!cmp && ext4_xattr_check_entry(entry, size))\n\t\t\treturn -EIO;\n\treturn cmp ? -ENODATA : 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);\n\nstatic int\next4_xattr_find_entry(struct ext4_xattr_entry **pentry, int name_index,\n\t\t      const char *name, size_t size, int sorted)\n{\n\tstruct ext4_xattr_entry *entry;\n\tsize_t name_len;\n\tint cmp = 1;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\tname_len = strlen(name);\n\tentry = *pentry;\n\tfor (; !IS_LAST_ENTRY(entry); entry = EXT4_XATTR_NEXT(entry)) {\n\t\tcmp = name_index - entry->e_name_index;\n\t\tif (!cmp)\n\t\t\tcmp = name_len - entry->e_name_len;\n\t\tif (!cmp)\n\t\t\tcmp = memcmp(name, entry->e_name, name_len);\n\t\tif (cmp <= 0 && (sorted || cmp == 0))\n\t\t\tbreak;\n\t}\n\t*pentry = entry;\n\tif (!cmp && ext4_xattr_check_entry(entry, size))\n\t\t\treturn -EIO;\n\treturn cmp ? -ENODATA : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BFIRST",
          "args": [
            "bh"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_xattr_cache_insert",
          "args": [
            "ext4_mb_cache",
            "bh"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_cache_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "1533-1556",
          "snippet": "static void\next4_xattr_cache_insert(struct mb_cache *ext4_mb_cache, struct buffer_head *bh)\n{\n\t__u32 hash = le32_to_cpu(BHDR(bh)->h_hash);\n\tstruct mb_cache_entry *ce;\n\tint error;\n\n\tce = mb_cache_entry_alloc(ext4_mb_cache, GFP_NOFS);\n\tif (!ce) {\n\t\tea_bdebug(bh, \"out of memory\");\n\t\treturn;\n\t}\n\terror = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, hash);\n\tif (error) {\n\t\tmb_cache_entry_free(ce);\n\t\tif (error == -EBUSY) {\n\t\t\tea_bdebug(bh, \"already in cache\");\n\t\t\terror = 0;\n\t\t}\n\t} else {\n\t\tea_bdebug(bh, \"inserting [%x]\", (int)hash);\n\t\tmb_cache_entry_release(ce);\n\t}\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);",
            "static struct buffer_head *ext4_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext4_xattr_header *,\n\t\t\t\t\t\t struct mb_cache_entry **);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);\nstatic struct buffer_head *ext4_xattr_cache_find(struct inode *,\n\t\t\t\t\t\t struct ext4_xattr_header *,\n\t\t\t\t\t\t struct mb_cache_entry **);\n\nstatic void\next4_xattr_cache_insert(struct mb_cache *ext4_mb_cache, struct buffer_head *bh)\n{\n\t__u32 hash = le32_to_cpu(BHDR(bh)->h_hash);\n\tstruct mb_cache_entry *ce;\n\tint error;\n\n\tce = mb_cache_entry_alloc(ext4_mb_cache, GFP_NOFS);\n\tif (!ce) {\n\t\tea_bdebug(bh, \"out of memory\");\n\t\treturn;\n\t}\n\terror = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, hash);\n\tif (error) {\n\t\tmb_cache_entry_free(ce);\n\t\tif (error == -EBUSY) {\n\t\t\tea_bdebug(bh, \"already in cache\");\n\t\t\terror = 0;\n\t\t}\n\t} else {\n\t\tea_bdebug(bh, \"inserting [%x]\", (int)hash);\n\t\tmb_cache_entry_release(ce);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_ERROR_INODE",
          "args": [
            "inode",
            "\"bad block %llu\"",
            "EXT4_I(inode)->i_file_acl"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_I",
          "args": [
            "inode"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1360-1363",
          "snippet": "static inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_inode_info *EXT4_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext4_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_xattr_check_block",
          "args": [
            "inode",
            "bh"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_check_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "216-234",
          "snippet": "static inline int\next4_xattr_check_block(struct inode *inode, struct buffer_head *bh)\n{\n\tint error;\n\n\tif (buffer_verified(bh))\n\t\treturn 0;\n\n\tif (BHDR(bh)->h_magic != cpu_to_le32(EXT4_XATTR_MAGIC) ||\n\t    BHDR(bh)->h_blocks != cpu_to_le32(1))\n\t\treturn -EIO;\n\tif (!ext4_xattr_block_csum_verify(inode, bh->b_blocknr, BHDR(bh)))\n\t\treturn -EIO;\n\terror = ext4_xattr_check_names(BFIRST(bh), bh->b_data + bh->b_size,\n\t\t\t\t       bh->b_data);\n\tif (!error)\n\t\tset_buffer_verified(bh);\n\treturn error;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);\n\nstatic inline int\next4_xattr_check_block(struct inode *inode, struct buffer_head *bh)\n{\n\tint error;\n\n\tif (buffer_verified(bh))\n\t\treturn 0;\n\n\tif (BHDR(bh)->h_magic != cpu_to_le32(EXT4_XATTR_MAGIC) ||\n\t    BHDR(bh)->h_blocks != cpu_to_le32(1))\n\t\treturn -EIO;\n\tif (!ext4_xattr_block_csum_verify(inode, bh->b_blocknr, BHDR(bh)))\n\t\treturn -EIO;\n\terror = ext4_xattr_check_names(BFIRST(bh), bh->b_data + bh->b_size,\n\t\t\t\t       bh->b_data);\n\tif (!error)\n\t\tset_buffer_verified(bh);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ea_bdebug",
          "args": [
            "bh",
            "\"b_count=%d, refcount=%d\"",
            "atomic_read(&(bh->b_count))",
            "le32_to_cpu(BHDR(bh)->h_refcount)"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BHDR",
          "args": [
            "bh"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&(bh->b_count)"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "inode->i_sb",
            "EXT4_I(inode)->i_file_acl"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_idebug",
          "args": [
            "inode",
            "\"reading block %llu\"",
            "(unsigned long long)EXT4_I(inode)->i_file_acl"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ea_idebug",
          "args": [
            "inode",
            "\"name=%d.%s, buffer=%p, buffer_size=%ld\"",
            "name_index",
            "name",
            "buffer",
            "(long)buffer_size"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_GET_MB_CACHE",
          "args": [
            "inode"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);\nstatic void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);\nstatic int ext4_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);\n\nstatic int\next4_xattr_block_get(struct inode *inode, int name_index, const char *name,\n\t\t     void *buffer, size_t buffer_size)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct ext4_xattr_entry *entry;\n\tsize_t size;\n\tint error;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\n\tea_idebug(inode, \"name=%d.%s, buffer=%p, buffer_size=%ld\",\n\t\t  name_index, name, buffer, (long)buffer_size);\n\n\terror = -ENODATA;\n\tif (!EXT4_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tea_idebug(inode, \"reading block %llu\",\n\t\t  (unsigned long long)EXT4_I(inode)->i_file_acl);\n\tbh = sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl);\n\tif (!bh)\n\t\tgoto cleanup;\n\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\tatomic_read(&(bh->b_count)), le32_to_cpu(BHDR(bh)->h_refcount));\n\tif (ext4_xattr_check_block(inode, bh)) {\nbad_block:\n\t\tEXT4_ERROR_INODE(inode, \"bad block %llu\",\n\t\t\t\t EXT4_I(inode)->i_file_acl);\n\t\terror = -EIO;\n\t\tgoto cleanup;\n\t}\n\text4_xattr_cache_insert(ext4_mb_cache, bh);\n\tentry = BFIRST(bh);\n\terror = ext4_xattr_find_entry(&entry, name_index, name, bh->b_size, 1);\n\tif (error == -EIO)\n\t\tgoto bad_block;\n\tif (error)\n\t\tgoto cleanup;\n\tsize = le32_to_cpu(entry->e_value_size);\n\tif (buffer) {\n\t\terror = -ERANGE;\n\t\tif (size > buffer_size)\n\t\t\tgoto cleanup;\n\t\tmemcpy(buffer, bh->b_data + le16_to_cpu(entry->e_value_offs),\n\t\t       size);\n\t}\n\terror = size;\n\ncleanup:\n\tbrelse(bh);\n\treturn error;\n}"
  },
  {
    "function_name": "ext4_xattr_find_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
    "lines": "247-272",
    "snippet": "static int\next4_xattr_find_entry(struct ext4_xattr_entry **pentry, int name_index,\n\t\t      const char *name, size_t size, int sorted)\n{\n\tstruct ext4_xattr_entry *entry;\n\tsize_t name_len;\n\tint cmp = 1;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\tname_len = strlen(name);\n\tentry = *pentry;\n\tfor (; !IS_LAST_ENTRY(entry); entry = EXT4_XATTR_NEXT(entry)) {\n\t\tcmp = name_index - entry->e_name_index;\n\t\tif (!cmp)\n\t\t\tcmp = name_len - entry->e_name_len;\n\t\tif (!cmp)\n\t\t\tcmp = memcmp(name, entry->e_name, name_len);\n\t\tif (cmp <= 0 && (sorted || cmp == 0))\n\t\t\tbreak;\n\t}\n\t*pentry = entry;\n\tif (!cmp && ext4_xattr_check_entry(entry, size))\n\t\t\treturn -EIO;\n\treturn cmp ? -ENODATA : 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_xattr_check_entry",
          "args": [
            "entry",
            "size"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_check_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "236-245",
          "snippet": "static inline int\next4_xattr_check_entry(struct ext4_xattr_entry *entry, size_t size)\n{\n\tsize_t value_size = le32_to_cpu(entry->e_value_size);\n\n\tif (entry->e_value_block != 0 || value_size > size ||\n\t    le16_to_cpu(entry->e_value_offs) + value_size > size)\n\t\treturn -EIO;\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);\n\nstatic inline int\next4_xattr_check_entry(struct ext4_xattr_entry *entry, size_t size)\n{\n\tsize_t value_size = le32_to_cpu(entry->e_value_size);\n\n\tif (entry->e_value_block != 0 || value_size > size ||\n\t    le16_to_cpu(entry->e_value_offs) + value_size > size)\n\t\treturn -EIO;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "name",
            "entry->e_name",
            "name_len"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_XATTR_NEXT",
          "args": [
            "entry"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LAST_ENTRY",
          "args": [
            "entry"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);\n\nstatic int\next4_xattr_find_entry(struct ext4_xattr_entry **pentry, int name_index,\n\t\t      const char *name, size_t size, int sorted)\n{\n\tstruct ext4_xattr_entry *entry;\n\tsize_t name_len;\n\tint cmp = 1;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\tname_len = strlen(name);\n\tentry = *pentry;\n\tfor (; !IS_LAST_ENTRY(entry); entry = EXT4_XATTR_NEXT(entry)) {\n\t\tcmp = name_index - entry->e_name_index;\n\t\tif (!cmp)\n\t\t\tcmp = name_len - entry->e_name_len;\n\t\tif (!cmp)\n\t\t\tcmp = memcmp(name, entry->e_name, name_len);\n\t\tif (cmp <= 0 && (sorted || cmp == 0))\n\t\t\tbreak;\n\t}\n\t*pentry = entry;\n\tif (!cmp && ext4_xattr_check_entry(entry, size))\n\t\t\treturn -EIO;\n\treturn cmp ? -ENODATA : 0;\n}"
  },
  {
    "function_name": "ext4_xattr_check_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
    "lines": "236-245",
    "snippet": "static inline int\next4_xattr_check_entry(struct ext4_xattr_entry *entry, size_t size)\n{\n\tsize_t value_size = le32_to_cpu(entry->e_value_size);\n\n\tif (entry->e_value_block != 0 || value_size > size ||\n\t    le16_to_cpu(entry->e_value_offs) + value_size > size)\n\t\treturn -EIO;\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "entry->e_value_offs"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "entry->e_value_size"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);\n\nstatic inline int\next4_xattr_check_entry(struct ext4_xattr_entry *entry, size_t size)\n{\n\tsize_t value_size = le32_to_cpu(entry->e_value_size);\n\n\tif (entry->e_value_block != 0 || value_size > size ||\n\t    le16_to_cpu(entry->e_value_offs) + value_size > size)\n\t\treturn -EIO;\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_xattr_check_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
    "lines": "216-234",
    "snippet": "static inline int\next4_xattr_check_block(struct inode *inode, struct buffer_head *bh)\n{\n\tint error;\n\n\tif (buffer_verified(bh))\n\t\treturn 0;\n\n\tif (BHDR(bh)->h_magic != cpu_to_le32(EXT4_XATTR_MAGIC) ||\n\t    BHDR(bh)->h_blocks != cpu_to_le32(1))\n\t\treturn -EIO;\n\tif (!ext4_xattr_block_csum_verify(inode, bh->b_blocknr, BHDR(bh)))\n\t\treturn -EIO;\n\terror = ext4_xattr_check_names(BFIRST(bh), bh->b_data + bh->b_size,\n\t\t\t\t       bh->b_data);\n\tif (!error)\n\t\tset_buffer_verified(bh);\n\treturn error;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_buffer_verified",
          "args": [
            "bh"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_xattr_check_names",
          "args": [
            "BFIRST(bh)",
            "bh->b_data + bh->b_size",
            "bh->b_data"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_check_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "190-214",
          "snippet": "static int\next4_xattr_check_names(struct ext4_xattr_entry *entry, void *end,\n\t\t       void *value_start)\n{\n\tstruct ext4_xattr_entry *e = entry;\n\n\twhile (!IS_LAST_ENTRY(e)) {\n\t\tstruct ext4_xattr_entry *next = EXT4_XATTR_NEXT(e);\n\t\tif ((void *)next >= end)\n\t\t\treturn -EIO;\n\t\te = next;\n\t}\n\n\twhile (!IS_LAST_ENTRY(entry)) {\n\t\tif (entry->e_value_size != 0 &&\n\t\t    (value_start + le16_to_cpu(entry->e_value_offs) <\n\t\t     (void *)e + sizeof(__u32) ||\n\t\t     value_start + le16_to_cpu(entry->e_value_offs) +\n\t\t    le32_to_cpu(entry->e_value_size) > end))\n\t\t\treturn -EIO;\n\t\tentry = EXT4_XATTR_NEXT(entry);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);\n\nstatic int\next4_xattr_check_names(struct ext4_xattr_entry *entry, void *end,\n\t\t       void *value_start)\n{\n\tstruct ext4_xattr_entry *e = entry;\n\n\twhile (!IS_LAST_ENTRY(e)) {\n\t\tstruct ext4_xattr_entry *next = EXT4_XATTR_NEXT(e);\n\t\tif ((void *)next >= end)\n\t\t\treturn -EIO;\n\t\te = next;\n\t}\n\n\twhile (!IS_LAST_ENTRY(entry)) {\n\t\tif (entry->e_value_size != 0 &&\n\t\t    (value_start + le16_to_cpu(entry->e_value_offs) <\n\t\t     (void *)e + sizeof(__u32) ||\n\t\t     value_start + le16_to_cpu(entry->e_value_offs) +\n\t\t    le32_to_cpu(entry->e_value_size) > end))\n\t\t\treturn -EIO;\n\t\tentry = EXT4_XATTR_NEXT(entry);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BFIRST",
          "args": [
            "bh"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_xattr_block_csum_verify",
          "args": [
            "inode",
            "bh->b_blocknr",
            "BHDR(bh)"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_block_csum_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "141-149",
          "snippet": "static int ext4_xattr_block_csum_verify(struct inode *inode,\n\t\t\t\t\tsector_t block_nr,\n\t\t\t\t\tstruct ext4_xattr_header *hdr)\n{\n\tif (ext4_has_metadata_csum(inode->i_sb) &&\n\t    (hdr->h_checksum != ext4_xattr_block_csum(inode, block_nr, hdr)))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic int ext4_xattr_block_csum_verify(struct inode *inode,\n\t\t\t\t\tsector_t block_nr,\n\t\t\t\t\tstruct ext4_xattr_header *hdr)\n{\n\tif (ext4_has_metadata_csum(inode->i_sb) &&\n\t    (hdr->h_checksum != ext4_xattr_block_csum(inode, block_nr, hdr)))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BHDR",
          "args": [
            "bh"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "1"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BHDR",
          "args": [
            "bh"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "EXT4_XATTR_MAGIC"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BHDR",
          "args": [
            "bh"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_verified",
          "args": [
            "bh"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);\n\nstatic inline int\next4_xattr_check_block(struct inode *inode, struct buffer_head *bh)\n{\n\tint error;\n\n\tif (buffer_verified(bh))\n\t\treturn 0;\n\n\tif (BHDR(bh)->h_magic != cpu_to_le32(EXT4_XATTR_MAGIC) ||\n\t    BHDR(bh)->h_blocks != cpu_to_le32(1))\n\t\treturn -EIO;\n\tif (!ext4_xattr_block_csum_verify(inode, bh->b_blocknr, BHDR(bh)))\n\t\treturn -EIO;\n\terror = ext4_xattr_check_names(BFIRST(bh), bh->b_data + bh->b_size,\n\t\t\t\t       bh->b_data);\n\tif (!error)\n\t\tset_buffer_verified(bh);\n\treturn error;\n}"
  },
  {
    "function_name": "ext4_xattr_check_names",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
    "lines": "190-214",
    "snippet": "static int\next4_xattr_check_names(struct ext4_xattr_entry *entry, void *end,\n\t\t       void *value_start)\n{\n\tstruct ext4_xattr_entry *e = entry;\n\n\twhile (!IS_LAST_ENTRY(e)) {\n\t\tstruct ext4_xattr_entry *next = EXT4_XATTR_NEXT(e);\n\t\tif ((void *)next >= end)\n\t\t\treturn -EIO;\n\t\te = next;\n\t}\n\n\twhile (!IS_LAST_ENTRY(entry)) {\n\t\tif (entry->e_value_size != 0 &&\n\t\t    (value_start + le16_to_cpu(entry->e_value_offs) <\n\t\t     (void *)e + sizeof(__u32) ||\n\t\t     value_start + le16_to_cpu(entry->e_value_offs) +\n\t\t    le32_to_cpu(entry->e_value_size) > end))\n\t\t\treturn -EIO;\n\t\tentry = EXT4_XATTR_NEXT(entry);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT4_XATTR_NEXT",
          "args": [
            "entry"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "entry->e_value_size"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "entry->e_value_offs"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_LAST_ENTRY",
          "args": [
            "entry"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_XATTR_NEXT",
          "args": [
            "e"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_LAST_ENTRY",
          "args": [
            "e"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_rehash(struct ext4_xattr_header *,\n\t\t\t      struct ext4_xattr_entry *);\n\nstatic int\next4_xattr_check_names(struct ext4_xattr_entry *entry, void *end,\n\t\t       void *value_start)\n{\n\tstruct ext4_xattr_entry *e = entry;\n\n\twhile (!IS_LAST_ENTRY(e)) {\n\t\tstruct ext4_xattr_entry *next = EXT4_XATTR_NEXT(e);\n\t\tif ((void *)next >= end)\n\t\t\treturn -EIO;\n\t\te = next;\n\t}\n\n\twhile (!IS_LAST_ENTRY(entry)) {\n\t\tif (entry->e_value_size != 0 &&\n\t\t    (value_start + le16_to_cpu(entry->e_value_offs) <\n\t\t     (void *)e + sizeof(__u32) ||\n\t\t     value_start + le16_to_cpu(entry->e_value_offs) +\n\t\t    le32_to_cpu(entry->e_value_size) > end))\n\t\t\treturn -EIO;\n\t\tentry = EXT4_XATTR_NEXT(entry);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ext4_listxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
    "lines": "184-188",
    "snippet": "ssize_t\next4_listxattr(struct dentry *dentry, char *buffer, size_t size)\n{\n\treturn ext4_xattr_list(dentry, buffer, size);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_xattr_list",
          "args": [
            "dentry",
            "buffer",
            "size"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "500-520",
          "snippet": "static int\next4_xattr_list(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tint ret, ret2;\n\n\tdown_read(&EXT4_I(dentry->d_inode)->xattr_sem);\n\tret = ret2 = ext4_xattr_ibody_list(dentry, buffer, buffer_size);\n\tif (ret < 0)\n\t\tgoto errout;\n\tif (buffer) {\n\t\tbuffer += ret;\n\t\tbuffer_size -= ret;\n\t}\n\tret = ext4_xattr_block_list(dentry, buffer, buffer_size);\n\tif (ret < 0)\n\t\tgoto errout;\n\tret += ret2;\nerrout:\n\tup_read(&EXT4_I(dentry->d_inode)->xattr_sem);\n\treturn ret;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic int ext4_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);\n\nstatic int\next4_xattr_list(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tint ret, ret2;\n\n\tdown_read(&EXT4_I(dentry->d_inode)->xattr_sem);\n\tret = ret2 = ext4_xattr_ibody_list(dentry, buffer, buffer_size);\n\tif (ret < 0)\n\t\tgoto errout;\n\tif (buffer) {\n\t\tbuffer += ret;\n\t\tbuffer_size -= ret;\n\t}\n\tret = ext4_xattr_block_list(dentry, buffer, buffer_size);\n\tif (ret < 0)\n\t\tgoto errout;\n\tret += ret2;\nerrout:\n\tup_read(&EXT4_I(dentry->d_inode)->xattr_sem);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nssize_t\next4_listxattr(struct dentry *dentry, char *buffer, size_t size)\n{\n\treturn ext4_xattr_list(dentry, buffer, size);\n}"
  },
  {
    "function_name": "ext4_xattr_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
    "lines": "169-177",
    "snippet": "static inline const struct xattr_handler *\next4_xattr_handler(int name_index)\n{\n\tconst struct xattr_handler *handler = NULL;\n\n\tif (name_index > 0 && name_index < ARRAY_SIZE(ext4_xattr_handler_map))\n\t\thandler = ext4_xattr_handler_map[name_index];\n\treturn handler;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct xattr_handler *ext4_xattr_handler_map[] = {\n\t[EXT4_XATTR_INDEX_USER]\t\t     = &ext4_xattr_user_handler,\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\t[EXT4_XATTR_INDEX_POSIX_ACL_ACCESS]  = &posix_acl_access_xattr_handler,\n\t[EXT4_XATTR_INDEX_POSIX_ACL_DEFAULT] = &posix_acl_default_xattr_handler,\n#endif\n\t[EXT4_XATTR_INDEX_TRUSTED]\t     = &ext4_xattr_trusted_handler,\n#ifdef CONFIG_EXT4_FS_SECURITY\n\t[EXT4_XATTR_INDEX_SECURITY]\t     = &ext4_xattr_security_handler,\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "ext4_xattr_handler_map"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic const struct xattr_handler *ext4_xattr_handler_map[] = {\n\t[EXT4_XATTR_INDEX_USER]\t\t     = &ext4_xattr_user_handler,\n#ifdef CONFIG_EXT4_FS_POSIX_ACL\n\t[EXT4_XATTR_INDEX_POSIX_ACL_ACCESS]  = &posix_acl_access_xattr_handler,\n\t[EXT4_XATTR_INDEX_POSIX_ACL_DEFAULT] = &posix_acl_default_xattr_handler,\n#endif\n\t[EXT4_XATTR_INDEX_TRUSTED]\t     = &ext4_xattr_trusted_handler,\n#ifdef CONFIG_EXT4_FS_SECURITY\n\t[EXT4_XATTR_INDEX_SECURITY]\t     = &ext4_xattr_security_handler,\n#endif\n};\n\nstatic inline const struct xattr_handler *\next4_xattr_handler(int name_index)\n{\n\tconst struct xattr_handler *handler = NULL;\n\n\tif (name_index > 0 && name_index < ARRAY_SIZE(ext4_xattr_handler_map))\n\t\thandler = ext4_xattr_handler_map[name_index];\n\treturn handler;\n}"
  },
  {
    "function_name": "ext4_handle_dirty_xattr_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
    "lines": "161-167",
    "snippet": "static inline int ext4_handle_dirty_xattr_block(handle_t *handle,\n\t\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\t\tstruct buffer_head *bh)\n{\n\text4_xattr_block_csum_set(inode, bh->b_blocknr, BHDR(bh));\n\treturn ext4_handle_dirty_metadata(handle, inode, bh);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_handle_dirty_metadata",
          "args": [
            "handle",
            "inode",
            "bh"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_xattr_block_csum_set",
          "args": [
            "inode",
            "bh->b_blocknr",
            "BHDR(bh)"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_block_csum_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "151-159",
          "snippet": "static void ext4_xattr_block_csum_set(struct inode *inode,\n\t\t\t\t      sector_t block_nr,\n\t\t\t\t      struct ext4_xattr_header *hdr)\n{\n\tif (!ext4_has_metadata_csum(inode->i_sb))\n\t\treturn;\n\n\thdr->h_checksum = ext4_xattr_block_csum(inode, block_nr, hdr);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_block_csum_set(struct inode *inode,\n\t\t\t\t      sector_t block_nr,\n\t\t\t\t      struct ext4_xattr_header *hdr)\n{\n\tif (!ext4_has_metadata_csum(inode->i_sb))\n\t\treturn;\n\n\thdr->h_checksum = ext4_xattr_block_csum(inode, block_nr, hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BHDR",
          "args": [
            "bh"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_cache_insert(struct mb_cache *, struct buffer_head *);\n\nstatic inline int ext4_handle_dirty_xattr_block(handle_t *handle,\n\t\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\t\tstruct buffer_head *bh)\n{\n\text4_xattr_block_csum_set(inode, bh->b_blocknr, BHDR(bh));\n\treturn ext4_handle_dirty_metadata(handle, inode, bh);\n}"
  },
  {
    "function_name": "ext4_xattr_block_csum_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
    "lines": "151-159",
    "snippet": "static void ext4_xattr_block_csum_set(struct inode *inode,\n\t\t\t\t      sector_t block_nr,\n\t\t\t\t      struct ext4_xattr_header *hdr)\n{\n\tif (!ext4_has_metadata_csum(inode->i_sb))\n\t\treturn;\n\n\thdr->h_checksum = ext4_xattr_block_csum(inode, block_nr, hdr);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_xattr_block_csum",
          "args": [
            "inode",
            "block_nr",
            "hdr"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_block_csum_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "151-159",
          "snippet": "static void ext4_xattr_block_csum_set(struct inode *inode,\n\t\t\t\t      sector_t block_nr,\n\t\t\t\t      struct ext4_xattr_header *hdr)\n{\n\tif (!ext4_has_metadata_csum(inode->i_sb))\n\t\treturn;\n\n\thdr->h_checksum = ext4_xattr_block_csum(inode, block_nr, hdr);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "ext4_has_metadata_csum",
          "args": [
            "inode->i_sb"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_block_csum_set(struct inode *inode,\n\t\t\t\t      sector_t block_nr,\n\t\t\t\t      struct ext4_xattr_header *hdr)\n{\n\tif (!ext4_has_metadata_csum(inode->i_sb))\n\t\treturn;\n\n\thdr->h_checksum = ext4_xattr_block_csum(inode, block_nr, hdr);\n}"
  },
  {
    "function_name": "ext4_xattr_block_csum_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
    "lines": "141-149",
    "snippet": "static int ext4_xattr_block_csum_verify(struct inode *inode,\n\t\t\t\t\tsector_t block_nr,\n\t\t\t\t\tstruct ext4_xattr_header *hdr)\n{\n\tif (ext4_has_metadata_csum(inode->i_sb) &&\n\t    (hdr->h_checksum != ext4_xattr_block_csum(inode, block_nr, hdr)))\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_xattr_block_csum",
          "args": [
            "inode",
            "block_nr",
            "hdr"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_block_csum_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "151-159",
          "snippet": "static void ext4_xattr_block_csum_set(struct inode *inode,\n\t\t\t\t      sector_t block_nr,\n\t\t\t\t      struct ext4_xattr_header *hdr)\n{\n\tif (!ext4_has_metadata_csum(inode->i_sb))\n\t\treturn;\n\n\thdr->h_checksum = ext4_xattr_block_csum(inode, block_nr, hdr);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic void ext4_xattr_block_csum_set(struct inode *inode,\n\t\t\t\t      sector_t block_nr,\n\t\t\t\t      struct ext4_xattr_header *hdr)\n{\n\tif (!ext4_has_metadata_csum(inode->i_sb))\n\t\treturn;\n\n\thdr->h_checksum = ext4_xattr_block_csum(inode, block_nr, hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_has_metadata_csum",
          "args": [
            "inode->i_sb"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic int ext4_xattr_block_csum_verify(struct inode *inode,\n\t\t\t\t\tsector_t block_nr,\n\t\t\t\t\tstruct ext4_xattr_header *hdr)\n{\n\tif (ext4_has_metadata_csum(inode->i_sb) &&\n\t    (hdr->h_checksum != ext4_xattr_block_csum(inode, block_nr, hdr)))\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "ext4_xattr_block_csum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
    "lines": "121-139",
    "snippet": "static __le32 ext4_xattr_block_csum(struct inode *inode,\n\t\t\t\t    sector_t block_nr,\n\t\t\t\t    struct ext4_xattr_header *hdr)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\t__u32 csum;\n\t__le32 save_csum;\n\t__le64 dsk_block_nr = cpu_to_le64(block_nr);\n\n\tsave_csum = hdr->h_checksum;\n\thdr->h_checksum = 0;\n\tcsum = ext4_chksum(sbi, sbi->s_csum_seed, (__u8 *)&dsk_block_nr,\n\t\t\t   sizeof(dsk_block_nr));\n\tcsum = ext4_chksum(sbi, csum, (__u8 *)hdr,\n\t\t\t   EXT4_BLOCK_SIZE(inode->i_sb));\n\n\thdr->h_checksum = save_csum;\n\treturn cpu_to_le32(csum);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/rwsem.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/mbcache.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "csum"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_chksum",
          "args": [
            "sbi",
            "csum",
            "(__u8 *)hdr",
            "EXT4_BLOCK_SIZE(inode->i_sb)"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_chksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1756-1775",
          "snippet": "static inline u32 ext4_chksum(struct ext4_sb_info *sbi, u32 crc,\n\t\t\t      const void *address, unsigned int length)\n{\n\tstruct {\n\t\tstruct shash_desc shash;\n\t\tchar ctx[4];\n\t} desc;\n\tint err;\n\n\tBUG_ON(crypto_shash_descsize(sbi->s_chksum_driver)!=sizeof(desc.ctx));\n\n\tdesc.shash.tfm = sbi->s_chksum_driver;\n\tdesc.shash.flags = 0;\n\t*(u32 *)desc.ctx = crc;\n\n\terr = crypto_shash_update(&desc.shash, address, length);\n\tBUG_ON(err);\n\n\treturn *(u32 *)desc.ctx;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline u32 ext4_chksum(struct ext4_sb_info *sbi, u32 crc,\n\t\t\t      const void *address, unsigned int length)\n{\n\tstruct {\n\t\tstruct shash_desc shash;\n\t\tchar ctx[4];\n\t} desc;\n\tint err;\n\n\tBUG_ON(crypto_shash_descsize(sbi->s_chksum_driver)!=sizeof(desc.ctx));\n\n\tdesc.shash.tfm = sbi->s_chksum_driver;\n\tdesc.shash.flags = 0;\n\t*(u32 *)desc.ctx = crc;\n\n\terr = crypto_shash_update(&desc.shash, address, length);\n\tBUG_ON(err);\n\n\treturn *(u32 *)desc.ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT4_BLOCK_SIZE",
          "args": [
            "inode->i_sb"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "block_nr"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT4_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "EXT4_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1356-1359",
          "snippet": "static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic __le32 ext4_xattr_block_csum(struct inode *inode,\n\t\t\t\t    sector_t block_nr,\n\t\t\t\t    struct ext4_xattr_header *hdr)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\t__u32 csum;\n\t__le32 save_csum;\n\t__le64 dsk_block_nr = cpu_to_le64(block_nr);\n\n\tsave_csum = hdr->h_checksum;\n\thdr->h_checksum = 0;\n\tcsum = ext4_chksum(sbi, sbi->s_csum_seed, (__u8 *)&dsk_block_nr,\n\t\t\t   sizeof(dsk_block_nr));\n\tcsum = ext4_chksum(sbi, csum, (__u8 *)hdr,\n\t\t\t   EXT4_BLOCK_SIZE(inode->i_sb));\n\n\thdr->h_checksum = save_csum;\n\treturn cpu_to_le32(csum);\n}"
  }
]