[
  {
    "function_name": "xfs_dir2_node_trim_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
    "lines": "2212-2270",
    "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_node_trim_free(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\txfs_fileoff_t\t\tfo,\t\t/* free block number */\n\tint\t\t\t*rvalp)\t\t/* out: did something */\n{\n\tstruct xfs_buf\t\t*bp;\t\t/* freespace buffer */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return code */\n\txfs_dir2_free_t\t\t*free;\t\t/* freespace structure */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tstruct xfs_dir3_icfree_hdr freehdr;\n\n\tdp = args->dp;\n\ttp = args->trans;\n\t/*\n\t * Read the freespace block.\n\t */\n\terror = xfs_dir2_free_try_read(tp, dp, fo, &bp);\n\tif (error)\n\t\treturn error;\n\t/*\n\t * There can be holes in freespace.  If fo is a hole, there's\n\t * nothing to do.\n\t */\n\tif (!bp)\n\t\treturn 0;\n\tfree = bp->b_addr;\n\tdp->d_ops->free_hdr_from_disk(&freehdr, free);\n\n\t/*\n\t * If there are used entries, there's nothing to do.\n\t */\n\tif (freehdr.nused > 0) {\n\t\txfs_trans_brelse(tp, bp);\n\t\t*rvalp = 0;\n\t\treturn 0;\n\t}\n\t/*\n\t * Blow the block away.\n\t */\n\terror = xfs_dir2_shrink_inode(args,\n\t\t\txfs_dir2_da_to_db(args->geo, (xfs_dablk_t)fo), bp);\n\tif (error) {\n\t\t/*\n\t\t * Can't fail with ENOSPC since that only happens with no\n\t\t * space reservation, when breaking up an extent into two\n\t\t * pieces.  This is the last block of an extent.\n\t\t */\n\t\tASSERT(error != -ENOSPC);\n\t\txfs_trans_brelse(tp, bp);\n\t\treturn error;\n\t}\n\t/*\n\t * Return that we succeeded.\n\t */\n\t*rvalp = 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "tp",
            "bp"
          ],
          "line": 2262
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "error != -ENOSPC"
          ],
          "line": 2261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_shrink_inode",
          "args": [
            "args",
            "xfs_dir2_da_to_db(args->geo, (xfs_dablk_t)fo)",
            "bp"
          ],
          "line": 2253
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_shrink_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
          "lines": "657-731",
          "snippet": "int\nxfs_dir2_shrink_inode(\n\txfs_da_args_t\t*args,\n\txfs_dir2_db_t\tdb,\n\tstruct xfs_buf\t*bp)\n{\n\txfs_fileoff_t\tbno;\t\t/* directory file offset */\n\txfs_dablk_t\tda;\t\t/* directory file offset */\n\tint\t\tdone;\t\t/* bunmap is finished */\n\txfs_inode_t\t*dp;\n\tint\t\terror;\n\txfs_mount_t\t*mp;\n\txfs_trans_t\t*tp;\n\n\ttrace_xfs_dir2_shrink_inode(args, db);\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\ttp = args->trans;\n\tda = xfs_dir2_db_to_da(args->geo, db);\n\t/*\n\t * Unmap the fsblock(s).\n\t */\n\tif ((error = xfs_bunmapi(tp, dp, da, args->geo->fsbcount,\n\t\t\tXFS_BMAPI_METADATA, 0, args->firstblock, args->flist,\n\t\t\t&done))) {\n\t\t/*\n\t\t * ENOSPC actually can happen if we're in a removename with\n\t\t * no space reservation, and the resulting block removal\n\t\t * would cause a bmap btree split or conversion from extents\n\t\t * to btree.  This can only happen for un-fragmented\n\t\t * directory blocks, since you need to be punching out\n\t\t * the middle of an extent.\n\t\t * In this case we need to leave the block in the file,\n\t\t * and not binval it.\n\t\t * So the block has to be in a consistent empty state\n\t\t * and appropriately logged.\n\t\t * We don't free up the buffer, the caller can tell it\n\t\t * hasn't happened since it got an error back.\n\t\t */\n\t\treturn error;\n\t}\n\tASSERT(done);\n\t/*\n\t * Invalidate the buffer from the transaction.\n\t */\n\txfs_trans_binval(tp, bp);\n\t/*\n\t * If it's not a data block, we're done.\n\t */\n\tif (db >= xfs_dir2_byte_to_db(args->geo, XFS_DIR2_LEAF_OFFSET))\n\t\treturn 0;\n\t/*\n\t * If the block isn't the last one in the directory, we're done.\n\t */\n\tif (dp->i_d.di_size > xfs_dir2_db_off_to_byte(args->geo, db + 1, 0))\n\t\treturn 0;\n\tbno = da;\n\tif ((error = xfs_bmap_last_before(tp, dp, &bno, XFS_DATA_FORK))) {\n\t\t/*\n\t\t * This can't really happen unless there's kernel corruption.\n\t\t */\n\t\treturn error;\n\t}\n\tif (db == args->geo->datablk)\n\t\tASSERT(bno == 0);\n\telse\n\t\tASSERT(bno > 0);\n\t/*\n\t * Set the size to the new last block.\n\t */\n\tdp->i_d.di_size = XFS_FSB_TO_B(mp, bno);\n\txfs_trans_log_inode(tp, dp, XFS_ILOG_CORE);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir2_shrink_inode(\n\txfs_da_args_t\t*args,\n\txfs_dir2_db_t\tdb,\n\tstruct xfs_buf\t*bp)\n{\n\txfs_fileoff_t\tbno;\t\t/* directory file offset */\n\txfs_dablk_t\tda;\t\t/* directory file offset */\n\tint\t\tdone;\t\t/* bunmap is finished */\n\txfs_inode_t\t*dp;\n\tint\t\terror;\n\txfs_mount_t\t*mp;\n\txfs_trans_t\t*tp;\n\n\ttrace_xfs_dir2_shrink_inode(args, db);\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\ttp = args->trans;\n\tda = xfs_dir2_db_to_da(args->geo, db);\n\t/*\n\t * Unmap the fsblock(s).\n\t */\n\tif ((error = xfs_bunmapi(tp, dp, da, args->geo->fsbcount,\n\t\t\tXFS_BMAPI_METADATA, 0, args->firstblock, args->flist,\n\t\t\t&done))) {\n\t\t/*\n\t\t * ENOSPC actually can happen if we're in a removename with\n\t\t * no space reservation, and the resulting block removal\n\t\t * would cause a bmap btree split or conversion from extents\n\t\t * to btree.  This can only happen for un-fragmented\n\t\t * directory blocks, since you need to be punching out\n\t\t * the middle of an extent.\n\t\t * In this case we need to leave the block in the file,\n\t\t * and not binval it.\n\t\t * So the block has to be in a consistent empty state\n\t\t * and appropriately logged.\n\t\t * We don't free up the buffer, the caller can tell it\n\t\t * hasn't happened since it got an error back.\n\t\t */\n\t\treturn error;\n\t}\n\tASSERT(done);\n\t/*\n\t * Invalidate the buffer from the transaction.\n\t */\n\txfs_trans_binval(tp, bp);\n\t/*\n\t * If it's not a data block, we're done.\n\t */\n\tif (db >= xfs_dir2_byte_to_db(args->geo, XFS_DIR2_LEAF_OFFSET))\n\t\treturn 0;\n\t/*\n\t * If the block isn't the last one in the directory, we're done.\n\t */\n\tif (dp->i_d.di_size > xfs_dir2_db_off_to_byte(args->geo, db + 1, 0))\n\t\treturn 0;\n\tbno = da;\n\tif ((error = xfs_bmap_last_before(tp, dp, &bno, XFS_DATA_FORK))) {\n\t\t/*\n\t\t * This can't really happen unless there's kernel corruption.\n\t\t */\n\t\treturn error;\n\t}\n\tif (db == args->geo->datablk)\n\t\tASSERT(bno == 0);\n\telse\n\t\tASSERT(bno > 0);\n\t/*\n\t * Set the size to the new last block.\n\t */\n\tdp->i_d.di_size = XFS_FSB_TO_B(mp, bno);\n\txfs_trans_log_inode(tp, dp, XFS_ILOG_CORE);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_da_to_db",
          "args": [
            "args->geo",
            "(xfs_dablk_t)fo"
          ],
          "line": 2254
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_da_to_db",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "287-291",
          "snippet": "static inline xfs_dir2_db_t\nxfs_dir2_da_to_db(struct xfs_da_geometry *geo, xfs_dablk_t da)\n{\n\treturn (xfs_dir2_db_t)(da >> (geo->blklog - geo->fsblog));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_db_t\nxfs_dir2_da_to_db(struct xfs_da_geometry *geo, xfs_dablk_t da)\n{\n\treturn (xfs_dir2_db_t)(da >> (geo->blklog - geo->fsblog));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->free_hdr_from_disk",
          "args": [
            "&freehdr",
            "free"
          ],
          "line": 2240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_free_try_read",
          "args": [
            "tp",
            "dp",
            "fo",
            "&bp"
          ],
          "line": 2230
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_free_try_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
          "lines": "184-192",
          "snippet": "static int\nxfs_dir2_free_try_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tfbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\treturn __xfs_dir3_free_read(tp, dp, fbno, -2, bpp);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int\nxfs_dir2_free_try_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tfbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\treturn __xfs_dir3_free_read(tp, dp, fbno, -2, bpp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_node_trim_free(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\txfs_fileoff_t\t\tfo,\t\t/* free block number */\n\tint\t\t\t*rvalp)\t\t/* out: did something */\n{\n\tstruct xfs_buf\t\t*bp;\t\t/* freespace buffer */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return code */\n\txfs_dir2_free_t\t\t*free;\t\t/* freespace structure */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tstruct xfs_dir3_icfree_hdr freehdr;\n\n\tdp = args->dp;\n\ttp = args->trans;\n\t/*\n\t * Read the freespace block.\n\t */\n\terror = xfs_dir2_free_try_read(tp, dp, fo, &bp);\n\tif (error)\n\t\treturn error;\n\t/*\n\t * There can be holes in freespace.  If fo is a hole, there's\n\t * nothing to do.\n\t */\n\tif (!bp)\n\t\treturn 0;\n\tfree = bp->b_addr;\n\tdp->d_ops->free_hdr_from_disk(&freehdr, free);\n\n\t/*\n\t * If there are used entries, there's nothing to do.\n\t */\n\tif (freehdr.nused > 0) {\n\t\txfs_trans_brelse(tp, bp);\n\t\t*rvalp = 0;\n\t\treturn 0;\n\t}\n\t/*\n\t * Blow the block away.\n\t */\n\terror = xfs_dir2_shrink_inode(args,\n\t\t\txfs_dir2_da_to_db(args->geo, (xfs_dablk_t)fo), bp);\n\tif (error) {\n\t\t/*\n\t\t * Can't fail with ENOSPC since that only happens with no\n\t\t * space reservation, when breaking up an extent into two\n\t\t * pieces.  This is the last block of an extent.\n\t\t */\n\t\tASSERT(error != -ENOSPC);\n\t\txfs_trans_brelse(tp, bp);\n\t\treturn error;\n\t}\n\t/*\n\t * Return that we succeeded.\n\t */\n\t*rvalp = 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_dir2_node_replace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
    "lines": "2125-2206",
    "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_node_replace(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\txfs_da_state_blk_t\t*blk;\t\t/* leaf block */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry changed */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\ti;\t\t/* btree level */\n\txfs_ino_t\t\tinum;\t\t/* new inode number */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry being changed */\n\tint\t\t\trval;\t\t/* internal return value */\n\txfs_da_state_t\t\t*state;\t\t/* btree cursor */\n\n\ttrace_xfs_dir2_node_replace(args);\n\n\t/*\n\t * Allocate and initialize the btree cursor.\n\t */\n\tstate = xfs_da_state_alloc();\n\tstate->args = args;\n\tstate->mp = args->dp->i_mount;\n\tinum = args->inumber;\n\t/*\n\t * Lookup the entry to change in the btree.\n\t */\n\terror = xfs_da3_node_lookup_int(state, &rval);\n\tif (error) {\n\t\trval = error;\n\t}\n\t/*\n\t * It should be found, since the vnodeops layer has looked it up\n\t * and locked it.  But paranoia is good.\n\t */\n\tif (rval == -EEXIST) {\n\t\tstruct xfs_dir2_leaf_entry *ents;\n\t\t/*\n\t\t * Find the leaf entry.\n\t\t */\n\t\tblk = &state->path.blk[state->path.active - 1];\n\t\tASSERT(blk->magic == XFS_DIR2_LEAFN_MAGIC);\n\t\tleaf = blk->bp->b_addr;\n\t\tents = args->dp->d_ops->leaf_ents_p(leaf);\n\t\tlep = &ents[blk->index];\n\t\tASSERT(state->extravalid);\n\t\t/*\n\t\t * Point to the data entry.\n\t\t */\n\t\thdr = state->extrablk.bp->b_addr;\n\t\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC));\n\t\tdep = (xfs_dir2_data_entry_t *)\n\t\t      ((char *)hdr +\n\t\t       xfs_dir2_dataptr_to_off(args->geo,\n\t\t\t\t\t       be32_to_cpu(lep->address)));\n\t\tASSERT(inum != be64_to_cpu(dep->inumber));\n\t\t/*\n\t\t * Fill in the new inode number and log the entry.\n\t\t */\n\t\tdep->inumber = cpu_to_be64(inum);\n\t\targs->dp->d_ops->data_put_ftype(dep, args->filetype);\n\t\txfs_dir2_data_log_entry(args, state->extrablk.bp, dep);\n\t\trval = 0;\n\t}\n\t/*\n\t * Didn't find it, and we're holding a data block.  Drop it.\n\t */\n\telse if (state->extravalid) {\n\t\txfs_trans_brelse(args->trans, state->extrablk.bp);\n\t\tstate->extrablk.bp = NULL;\n\t}\n\t/*\n\t * Release all the buffers in the cursor.\n\t */\n\tfor (i = 0; i < state->path.active; i++) {\n\t\txfs_trans_brelse(args->trans, state->path.blk[i].bp);\n\t\tstate->path.blk[i].bp = NULL;\n\t}\n\txfs_da_state_free(state);\n\treturn rval;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);",
      "static int xfs_dir2_leafn_remove(xfs_da_args_t *args, struct xfs_buf *bp,\n\t\t\t\t int index, xfs_da_state_blk_t *dblk,\n\t\t\t\t int *rval);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_da_state_free",
          "args": [
            "state"
          ],
          "line": 2204
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_state_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "120-128",
          "snippet": "void\nxfs_da_state_free(xfs_da_state_t *state)\n{\n\txfs_da_state_kill_altpath(state);\n#ifdef DEBUG\n\tmemset((char *)state, 0, sizeof(*state));\n#endif /* DEBUG */\n\tkmem_zone_free(xfs_da_state_zone, state);\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t *xfs_da_state_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t *xfs_da_state_zone;\n\nvoid\nxfs_da_state_free(xfs_da_state_t *state)\n{\n\txfs_da_state_kill_altpath(state);\n#ifdef DEBUG\n\tmemset((char *)state, 0, sizeof(*state));\n#endif /* DEBUG */\n\tkmem_zone_free(xfs_da_state_zone, state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "args->trans",
            "state->path.blk[i].bp"
          ],
          "line": 2201
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_log_entry",
          "args": [
            "args",
            "state->extrablk.bp",
            "dep"
          ],
          "line": 2187
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_log_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "640-656",
          "snippet": "void\nxfs_dir2_data_log_entry(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_entry_t\t*dep)\t\t/* data entry pointer */\n{\n\tstruct xfs_dir2_data_hdr *hdr = bp->b_addr;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\txfs_trans_log_buf(args->trans, bp, (uint)((char *)dep - (char *)hdr),\n\t\t(uint)((char *)(args->dp->d_ops->data_entry_tag_p(dep) + 1) -\n\t\t       (char *)hdr - 1));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dir2_data_log_entry(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_entry_t\t*dep)\t\t/* data entry pointer */\n{\n\tstruct xfs_dir2_data_hdr *hdr = bp->b_addr;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\txfs_trans_log_buf(args->trans, bp, (uint)((char *)dep - (char *)hdr),\n\t\t(uint)((char *)(args->dp->d_ops->data_entry_tag_p(dep) + 1) -\n\t\t       (char *)hdr - 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "args->dp->d_ops->data_put_ftype",
          "args": [
            "dep",
            "args->filetype"
          ],
          "line": 2186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "inum"
          ],
          "line": 2185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "inum != be64_to_cpu(dep->inumber)"
          ],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dep->inumber"
          ],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_dataptr_to_off",
          "args": [
            "args->geo",
            "be32_to_cpu(lep->address)"
          ],
          "line": 2179
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_dataptr_to_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "240-244",
          "snippet": "static inline xfs_dir2_data_aoff_t\nxfs_dir2_dataptr_to_off(struct xfs_da_geometry *geo, xfs_dir2_dataptr_t dp)\n{\n\treturn xfs_dir2_byte_to_off(geo, xfs_dir2_dataptr_to_byte(dp));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_data_aoff_t\nxfs_dir2_dataptr_to_off(struct xfs_da_geometry *geo, xfs_dir2_dataptr_t dp)\n{\n\treturn xfs_dir2_byte_to_off(geo, xfs_dir2_dataptr_to_byte(dp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "lep->address"
          ],
          "line": 2180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC)"
          ],
          "line": 2175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR3_DATA_MAGIC"
          ],
          "line": 2176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_DATA_MAGIC"
          ],
          "line": 2175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "state->extravalid"
          ],
          "line": 2170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "args->dp->d_ops->leaf_ents_p",
          "args": [
            "leaf"
          ],
          "line": 2168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "blk->magic == XFS_DIR2_LEAFN_MAGIC"
          ],
          "line": 2166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_da3_node_lookup_int",
          "args": [
            "state",
            "&rval"
          ],
          "line": 2152
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_node_lookup_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "1445-1597",
          "snippet": "int\t\t\t\t\t\t\t/* error */\nxfs_da3_node_lookup_int(\n\tstruct xfs_da_state\t*state,\n\tint\t\t\t*result)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_blkinfo\t*curr;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\tstruct xfs_da_args\t*args;\n\txfs_dablk_t\t\tblkno;\n\txfs_dahash_t\t\thashval;\n\txfs_dahash_t\t\tbtreehashval;\n\tint\t\t\tprobe;\n\tint\t\t\tspan;\n\tint\t\t\tmax;\n\tint\t\t\terror;\n\tint\t\t\tretval;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\targs = state->args;\n\n\t/*\n\t * Descend thru the B-tree searching each level for the right\n\t * node to use, until the right hashval is found.\n\t */\n\tblkno = (args->whichfork == XFS_DATA_FORK)? args->geo->leafblk : 0;\n\tfor (blk = &state->path.blk[0], state->path.active = 1;\n\t\t\t state->path.active <= XFS_DA_NODE_MAXDEPTH;\n\t\t\t blk++, state->path.active++) {\n\t\t/*\n\t\t * Read the next node down in the tree.\n\t\t */\n\t\tblk->blkno = blkno;\n\t\terror = xfs_da3_node_read(args->trans, args->dp, blkno,\n\t\t\t\t\t-1, &blk->bp, args->whichfork);\n\t\tif (error) {\n\t\t\tblk->blkno = 0;\n\t\t\tstate->path.active--;\n\t\t\treturn error;\n\t\t}\n\t\tcurr = blk->bp->b_addr;\n\t\tblk->magic = be16_to_cpu(curr->magic);\n\n\t\tif (blk->magic == XFS_ATTR_LEAF_MAGIC ||\n\t\t    blk->magic == XFS_ATTR3_LEAF_MAGIC) {\n\t\t\tblk->magic = XFS_ATTR_LEAF_MAGIC;\n\t\t\tblk->hashval = xfs_attr_leaf_lasthash(blk->bp, NULL);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (blk->magic == XFS_DIR2_LEAFN_MAGIC ||\n\t\t    blk->magic == XFS_DIR3_LEAFN_MAGIC) {\n\t\t\tblk->magic = XFS_DIR2_LEAFN_MAGIC;\n\t\t\tblk->hashval = xfs_dir2_leafn_lasthash(args->dp,\n\t\t\t\t\t\t\t       blk->bp, NULL);\n\t\t\tbreak;\n\t\t}\n\n\t\tblk->magic = XFS_DA_NODE_MAGIC;\n\n\n\t\t/*\n\t\t * Search an intermediate node for a match.\n\t\t */\n\t\tnode = blk->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\tbtree = dp->d_ops->node_tree_p(node);\n\n\t\tmax = nodehdr.count;\n\t\tblk->hashval = be32_to_cpu(btree[max - 1].hashval);\n\n\t\t/*\n\t\t * Binary search.  (note: small blocks will skip loop)\n\t\t */\n\t\tprobe = span = max / 2;\n\t\thashval = args->hashval;\n\t\twhile (span > 4) {\n\t\t\tspan /= 2;\n\t\t\tbtreehashval = be32_to_cpu(btree[probe].hashval);\n\t\t\tif (btreehashval < hashval)\n\t\t\t\tprobe += span;\n\t\t\telse if (btreehashval > hashval)\n\t\t\t\tprobe -= span;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tASSERT((probe >= 0) && (probe < max));\n\t\tASSERT((span <= 4) ||\n\t\t\t(be32_to_cpu(btree[probe].hashval) == hashval));\n\n\t\t/*\n\t\t * Since we may have duplicate hashval's, find the first\n\t\t * matching hashval in the node.\n\t\t */\n\t\twhile (probe > 0 &&\n\t\t       be32_to_cpu(btree[probe].hashval) >= hashval) {\n\t\t\tprobe--;\n\t\t}\n\t\twhile (probe < max &&\n\t\t       be32_to_cpu(btree[probe].hashval) < hashval) {\n\t\t\tprobe++;\n\t\t}\n\n\t\t/*\n\t\t * Pick the right block to descend on.\n\t\t */\n\t\tif (probe == max) {\n\t\t\tblk->index = max - 1;\n\t\t\tblkno = be32_to_cpu(btree[max - 1].before);\n\t\t} else {\n\t\t\tblk->index = probe;\n\t\t\tblkno = be32_to_cpu(btree[probe].before);\n\t\t}\n\t}\n\n\t/*\n\t * A leaf block that ends in the hashval that we are interested in\n\t * (final hashval == search hashval) means that the next block may\n\t * contain more entries with the same hashval, shift upward to the\n\t * next leaf and keep searching.\n\t */\n\tfor (;;) {\n\t\tif (blk->magic == XFS_DIR2_LEAFN_MAGIC) {\n\t\t\tretval = xfs_dir2_leafn_lookup_int(blk->bp, args,\n\t\t\t\t\t\t\t&blk->index, state);\n\t\t} else if (blk->magic == XFS_ATTR_LEAF_MAGIC) {\n\t\t\tretval = xfs_attr3_leaf_lookup_int(blk->bp, args);\n\t\t\tblk->index = args->index;\n\t\t\targs->blkno = blk->blkno;\n\t\t} else {\n\t\t\tASSERT(0);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tif (((retval == -ENOENT) || (retval == -ENOATTR)) &&\n\t\t    (blk->hashval == args->hashval)) {\n\t\t\terror = xfs_da3_path_shift(state, &state->path, 1, 1,\n\t\t\t\t\t\t\t &retval);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (retval == 0) {\n\t\t\t\tcontinue;\n\t\t\t} else if (blk->magic == XFS_ATTR_LEAF_MAGIC) {\n\t\t\t\t/* path_shift() gives ENOENT */\n\t\t\t\tretval = -ENOATTR;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\t*result = retval;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_da3_node_split(xfs_da_state_t *state,\n\t\t\t\t\t    xfs_da_state_blk_t *existing_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *split_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *blk_to_add,\n\t\t\t\t\t    int treelevel,\n\t\t\t\t\t    int *result);",
            "STATIC int xfs_da3_node_toosmall(xfs_da_state_t *state, int *retval);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_da3_node_split(xfs_da_state_t *state,\n\t\t\t\t\t    xfs_da_state_blk_t *existing_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *split_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *blk_to_add,\n\t\t\t\t\t    int treelevel,\n\t\t\t\t\t    int *result);\nSTATIC int xfs_da3_node_toosmall(xfs_da_state_t *state, int *retval);\n\nint\t\t\t\t\t\t\t/* error */\nxfs_da3_node_lookup_int(\n\tstruct xfs_da_state\t*state,\n\tint\t\t\t*result)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_blkinfo\t*curr;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\tstruct xfs_da_args\t*args;\n\txfs_dablk_t\t\tblkno;\n\txfs_dahash_t\t\thashval;\n\txfs_dahash_t\t\tbtreehashval;\n\tint\t\t\tprobe;\n\tint\t\t\tspan;\n\tint\t\t\tmax;\n\tint\t\t\terror;\n\tint\t\t\tretval;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\targs = state->args;\n\n\t/*\n\t * Descend thru the B-tree searching each level for the right\n\t * node to use, until the right hashval is found.\n\t */\n\tblkno = (args->whichfork == XFS_DATA_FORK)? args->geo->leafblk : 0;\n\tfor (blk = &state->path.blk[0], state->path.active = 1;\n\t\t\t state->path.active <= XFS_DA_NODE_MAXDEPTH;\n\t\t\t blk++, state->path.active++) {\n\t\t/*\n\t\t * Read the next node down in the tree.\n\t\t */\n\t\tblk->blkno = blkno;\n\t\terror = xfs_da3_node_read(args->trans, args->dp, blkno,\n\t\t\t\t\t-1, &blk->bp, args->whichfork);\n\t\tif (error) {\n\t\t\tblk->blkno = 0;\n\t\t\tstate->path.active--;\n\t\t\treturn error;\n\t\t}\n\t\tcurr = blk->bp->b_addr;\n\t\tblk->magic = be16_to_cpu(curr->magic);\n\n\t\tif (blk->magic == XFS_ATTR_LEAF_MAGIC ||\n\t\t    blk->magic == XFS_ATTR3_LEAF_MAGIC) {\n\t\t\tblk->magic = XFS_ATTR_LEAF_MAGIC;\n\t\t\tblk->hashval = xfs_attr_leaf_lasthash(blk->bp, NULL);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (blk->magic == XFS_DIR2_LEAFN_MAGIC ||\n\t\t    blk->magic == XFS_DIR3_LEAFN_MAGIC) {\n\t\t\tblk->magic = XFS_DIR2_LEAFN_MAGIC;\n\t\t\tblk->hashval = xfs_dir2_leafn_lasthash(args->dp,\n\t\t\t\t\t\t\t       blk->bp, NULL);\n\t\t\tbreak;\n\t\t}\n\n\t\tblk->magic = XFS_DA_NODE_MAGIC;\n\n\n\t\t/*\n\t\t * Search an intermediate node for a match.\n\t\t */\n\t\tnode = blk->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\tbtree = dp->d_ops->node_tree_p(node);\n\n\t\tmax = nodehdr.count;\n\t\tblk->hashval = be32_to_cpu(btree[max - 1].hashval);\n\n\t\t/*\n\t\t * Binary search.  (note: small blocks will skip loop)\n\t\t */\n\t\tprobe = span = max / 2;\n\t\thashval = args->hashval;\n\t\twhile (span > 4) {\n\t\t\tspan /= 2;\n\t\t\tbtreehashval = be32_to_cpu(btree[probe].hashval);\n\t\t\tif (btreehashval < hashval)\n\t\t\t\tprobe += span;\n\t\t\telse if (btreehashval > hashval)\n\t\t\t\tprobe -= span;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tASSERT((probe >= 0) && (probe < max));\n\t\tASSERT((span <= 4) ||\n\t\t\t(be32_to_cpu(btree[probe].hashval) == hashval));\n\n\t\t/*\n\t\t * Since we may have duplicate hashval's, find the first\n\t\t * matching hashval in the node.\n\t\t */\n\t\twhile (probe > 0 &&\n\t\t       be32_to_cpu(btree[probe].hashval) >= hashval) {\n\t\t\tprobe--;\n\t\t}\n\t\twhile (probe < max &&\n\t\t       be32_to_cpu(btree[probe].hashval) < hashval) {\n\t\t\tprobe++;\n\t\t}\n\n\t\t/*\n\t\t * Pick the right block to descend on.\n\t\t */\n\t\tif (probe == max) {\n\t\t\tblk->index = max - 1;\n\t\t\tblkno = be32_to_cpu(btree[max - 1].before);\n\t\t} else {\n\t\t\tblk->index = probe;\n\t\t\tblkno = be32_to_cpu(btree[probe].before);\n\t\t}\n\t}\n\n\t/*\n\t * A leaf block that ends in the hashval that we are interested in\n\t * (final hashval == search hashval) means that the next block may\n\t * contain more entries with the same hashval, shift upward to the\n\t * next leaf and keep searching.\n\t */\n\tfor (;;) {\n\t\tif (blk->magic == XFS_DIR2_LEAFN_MAGIC) {\n\t\t\tretval = xfs_dir2_leafn_lookup_int(blk->bp, args,\n\t\t\t\t\t\t\t&blk->index, state);\n\t\t} else if (blk->magic == XFS_ATTR_LEAF_MAGIC) {\n\t\t\tretval = xfs_attr3_leaf_lookup_int(blk->bp, args);\n\t\t\tblk->index = args->index;\n\t\t\targs->blkno = blk->blkno;\n\t\t} else {\n\t\t\tASSERT(0);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tif (((retval == -ENOENT) || (retval == -ENOATTR)) &&\n\t\t    (blk->hashval == args->hashval)) {\n\t\t\terror = xfs_da3_path_shift(state, &state->path, 1, 1,\n\t\t\t\t\t\t\t &retval);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (retval == 0) {\n\t\t\t\tcontinue;\n\t\t\t} else if (blk->magic == XFS_ATTR_LEAF_MAGIC) {\n\t\t\t\t/* path_shift() gives ENOENT */\n\t\t\t\tretval = -ENOATTR;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\t*result = retval;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da_state_alloc",
          "args": [],
          "line": 2145
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_state_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "98-102",
          "snippet": "xfs_da_state_t *\nxfs_da_state_alloc(void)\n{\n\treturn kmem_zone_zalloc(xfs_da_state_zone, KM_NOFS);\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t *xfs_da_state_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t *xfs_da_state_zone;\n\nxfs_da_state_t *\nxfs_da_state_alloc(void)\n{\n\treturn kmem_zone_zalloc(xfs_da_state_zone, KM_NOFS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_dir2_node_replace",
          "args": [
            "args"
          ],
          "line": 2140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);\nstatic int xfs_dir2_leafn_remove(xfs_da_args_t *args, struct xfs_buf *bp,\n\t\t\t\t int index, xfs_da_state_blk_t *dblk,\n\t\t\t\t int *rval);\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_node_replace(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\txfs_da_state_blk_t\t*blk;\t\t/* leaf block */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry changed */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\ti;\t\t/* btree level */\n\txfs_ino_t\t\tinum;\t\t/* new inode number */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry being changed */\n\tint\t\t\trval;\t\t/* internal return value */\n\txfs_da_state_t\t\t*state;\t\t/* btree cursor */\n\n\ttrace_xfs_dir2_node_replace(args);\n\n\t/*\n\t * Allocate and initialize the btree cursor.\n\t */\n\tstate = xfs_da_state_alloc();\n\tstate->args = args;\n\tstate->mp = args->dp->i_mount;\n\tinum = args->inumber;\n\t/*\n\t * Lookup the entry to change in the btree.\n\t */\n\terror = xfs_da3_node_lookup_int(state, &rval);\n\tif (error) {\n\t\trval = error;\n\t}\n\t/*\n\t * It should be found, since the vnodeops layer has looked it up\n\t * and locked it.  But paranoia is good.\n\t */\n\tif (rval == -EEXIST) {\n\t\tstruct xfs_dir2_leaf_entry *ents;\n\t\t/*\n\t\t * Find the leaf entry.\n\t\t */\n\t\tblk = &state->path.blk[state->path.active - 1];\n\t\tASSERT(blk->magic == XFS_DIR2_LEAFN_MAGIC);\n\t\tleaf = blk->bp->b_addr;\n\t\tents = args->dp->d_ops->leaf_ents_p(leaf);\n\t\tlep = &ents[blk->index];\n\t\tASSERT(state->extravalid);\n\t\t/*\n\t\t * Point to the data entry.\n\t\t */\n\t\thdr = state->extrablk.bp->b_addr;\n\t\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC));\n\t\tdep = (xfs_dir2_data_entry_t *)\n\t\t      ((char *)hdr +\n\t\t       xfs_dir2_dataptr_to_off(args->geo,\n\t\t\t\t\t       be32_to_cpu(lep->address)));\n\t\tASSERT(inum != be64_to_cpu(dep->inumber));\n\t\t/*\n\t\t * Fill in the new inode number and log the entry.\n\t\t */\n\t\tdep->inumber = cpu_to_be64(inum);\n\t\targs->dp->d_ops->data_put_ftype(dep, args->filetype);\n\t\txfs_dir2_data_log_entry(args, state->extrablk.bp, dep);\n\t\trval = 0;\n\t}\n\t/*\n\t * Didn't find it, and we're holding a data block.  Drop it.\n\t */\n\telse if (state->extravalid) {\n\t\txfs_trans_brelse(args->trans, state->extrablk.bp);\n\t\tstate->extrablk.bp = NULL;\n\t}\n\t/*\n\t * Release all the buffers in the cursor.\n\t */\n\tfor (i = 0; i < state->path.active; i++) {\n\t\txfs_trans_brelse(args->trans, state->path.blk[i].bp);\n\t\tstate->path.blk[i].bp = NULL;\n\t}\n\txfs_da_state_free(state);\n\treturn rval;\n}"
  },
  {
    "function_name": "xfs_dir2_node_removename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
    "lines": "2063-2120",
    "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_node_removename(\n\tstruct xfs_da_args\t*args)\t\t/* operation arguments */\n{\n\tstruct xfs_da_state_blk\t*blk;\t\t/* leaf block */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\trval;\t\t/* operation return value */\n\tstruct xfs_da_state\t*state;\t\t/* btree cursor */\n\n\ttrace_xfs_dir2_node_removename(args);\n\n\t/*\n\t * Allocate and initialize the btree cursor.\n\t */\n\tstate = xfs_da_state_alloc();\n\tstate->args = args;\n\tstate->mp = args->dp->i_mount;\n\n\t/* Look up the entry we're deleting, set up the cursor. */\n\terror = xfs_da3_node_lookup_int(state, &rval);\n\tif (error)\n\t\tgoto out_free;\n\n\t/* Didn't find it, upper layer screwed up. */\n\tif (rval != -EEXIST) {\n\t\terror = rval;\n\t\tgoto out_free;\n\t}\n\n\tblk = &state->path.blk[state->path.active - 1];\n\tASSERT(blk->magic == XFS_DIR2_LEAFN_MAGIC);\n\tASSERT(state->extravalid);\n\t/*\n\t * Remove the leaf and data entries.\n\t * Extrablk refers to the data block.\n\t */\n\terror = xfs_dir2_leafn_remove(args, blk->bp, blk->index,\n\t\t&state->extrablk, &rval);\n\tif (error)\n\t\tgoto out_free;\n\t/*\n\t * Fix the hash values up the btree.\n\t */\n\txfs_da3_fixhashpath(state, &state->path);\n\t/*\n\t * If we need to join leaf blocks, do it.\n\t */\n\tif (rval && state->path.active > 1)\n\t\terror = xfs_da3_join(state);\n\t/*\n\t * If no errors so far, try conversion to leaf format.\n\t */\n\tif (!error)\n\t\terror = xfs_dir2_node_to_leaf(state);\nout_free:\n\txfs_da_state_free(state);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);",
      "static int xfs_dir2_leafn_remove(xfs_da_args_t *args, struct xfs_buf *bp,\n\t\t\t\t int index, xfs_da_state_blk_t *dblk,\n\t\t\t\t int *rval);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_da_state_free",
          "args": [
            "state"
          ],
          "line": 2118
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_state_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "120-128",
          "snippet": "void\nxfs_da_state_free(xfs_da_state_t *state)\n{\n\txfs_da_state_kill_altpath(state);\n#ifdef DEBUG\n\tmemset((char *)state, 0, sizeof(*state));\n#endif /* DEBUG */\n\tkmem_zone_free(xfs_da_state_zone, state);\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t *xfs_da_state_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t *xfs_da_state_zone;\n\nvoid\nxfs_da_state_free(xfs_da_state_t *state)\n{\n\txfs_da_state_kill_altpath(state);\n#ifdef DEBUG\n\tmemset((char *)state, 0, sizeof(*state));\n#endif /* DEBUG */\n\tkmem_zone_free(xfs_da_state_zone, state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_node_to_leaf",
          "args": [
            "state"
          ],
          "line": 2116
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_node_to_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "1672-1819",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_node_to_leaf(\n\txfs_da_state_t\t\t*state)\t\t/* directory operation state */\n{\n\txfs_da_args_t\t\t*args;\t\t/* operation arguments */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return code */\n\tstruct xfs_buf\t\t*fbp;\t\t/* buffer for freespace block */\n\txfs_fileoff_t\t\tfo;\t\t/* freespace file offset */\n\txfs_dir2_free_t\t\t*free;\t\t/* freespace structure */\n\tstruct xfs_buf\t\t*lbp;\t\t/* buffer for leaf block */\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* tail of leaf structure */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tint\t\t\trval;\t\t/* successful free trim? */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\tstruct xfs_dir3_icfree_hdr freehdr;\n\n\t/*\n\t * There's more than a leaf level in the btree, so there must\n\t * be multiple leafn blocks.  Give up.\n\t */\n\tif (state->path.active > 1)\n\t\treturn 0;\n\targs = state->args;\n\n\ttrace_xfs_dir2_node_to_leaf(args);\n\n\tmp = state->mp;\n\tdp = args->dp;\n\ttp = args->trans;\n\t/*\n\t * Get the last offset in the file.\n\t */\n\tif ((error = xfs_bmap_last_offset(dp, &fo, XFS_DATA_FORK))) {\n\t\treturn error;\n\t}\n\tfo -= args->geo->fsbcount;\n\t/*\n\t * If there are freespace blocks other than the first one,\n\t * take this opportunity to remove trailing empty freespace blocks\n\t * that may have been left behind during no-space-reservation\n\t * operations.\n\t */\n\twhile (fo > args->geo->freeblk) {\n\t\tif ((error = xfs_dir2_node_trim_free(args, fo, &rval))) {\n\t\t\treturn error;\n\t\t}\n\t\tif (rval)\n\t\t\tfo -= args->geo->fsbcount;\n\t\telse\n\t\t\treturn 0;\n\t}\n\t/*\n\t * Now find the block just before the freespace block.\n\t */\n\tif ((error = xfs_bmap_last_before(tp, dp, &fo, XFS_DATA_FORK))) {\n\t\treturn error;\n\t}\n\t/*\n\t * If it's not the single leaf block, give up.\n\t */\n\tif (XFS_FSB_TO_B(mp, fo) > XFS_DIR2_LEAF_OFFSET + args->geo->blksize)\n\t\treturn 0;\n\tlbp = state->path.blk[0].bp;\n\tleaf = lbp->b_addr;\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\n\tASSERT(leafhdr.magic == XFS_DIR2_LEAFN_MAGIC ||\n\t       leafhdr.magic == XFS_DIR3_LEAFN_MAGIC);\n\n\t/*\n\t * Read the freespace block.\n\t */\n\terror = xfs_dir2_free_read(tp, dp,  args->geo->freeblk, &fbp);\n\tif (error)\n\t\treturn error;\n\tfree = fbp->b_addr;\n\tdp->d_ops->free_hdr_from_disk(&freehdr, free);\n\n\tASSERT(!freehdr.firstdb);\n\n\t/*\n\t * Now see if the leafn and free data will fit in a leaf1.\n\t * If not, release the buffer and give up.\n\t */\n\tif (xfs_dir3_leaf_size(&leafhdr, freehdr.nvalid) > args->geo->blksize) {\n\t\txfs_trans_brelse(tp, fbp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the leaf has any stale entries in it, compress them out.\n\t */\n\tif (leafhdr.stale)\n\t\txfs_dir3_leaf_compact(args, &leafhdr, lbp);\n\n\tlbp->b_ops = &xfs_dir3_leaf1_buf_ops;\n\txfs_trans_buf_set_type(tp, lbp, XFS_BLFT_DIR_LEAF1_BUF);\n\tleafhdr.magic = (leafhdr.magic == XFS_DIR2_LEAFN_MAGIC)\n\t\t\t\t\t? XFS_DIR2_LEAF1_MAGIC\n\t\t\t\t\t: XFS_DIR3_LEAF1_MAGIC;\n\n\t/*\n\t * Set up the leaf tail from the freespace block.\n\t */\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\tltp->bestcount = cpu_to_be32(freehdr.nvalid);\n\n\t/*\n\t * Set up the leaf bests table.\n\t */\n\tmemcpy(xfs_dir2_leaf_bests_p(ltp), dp->d_ops->free_bests_p(free),\n\t\tfreehdr.nvalid * sizeof(xfs_dir2_data_off_t));\n\n\tdp->d_ops->leaf_hdr_to_disk(leaf, &leafhdr);\n\txfs_dir3_leaf_log_header(args, lbp);\n\txfs_dir3_leaf_log_bests(args, lbp, 0, be32_to_cpu(ltp->bestcount) - 1);\n\txfs_dir3_leaf_log_tail(args, lbp);\n\txfs_dir3_leaf_check(dp, lbp);\n\n\t/*\n\t * Get rid of the freespace block.\n\t */\n\terror = xfs_dir2_shrink_inode(args,\n\t\t\txfs_dir2_byte_to_db(args->geo, XFS_DIR2_FREE_OFFSET),\n\t\t\tfbp);\n\tif (error) {\n\t\t/*\n\t\t * This can't fail here because it can only happen when\n\t\t * punching out the middle of an extent, and this is an\n\t\t * isolated block.\n\t\t */\n\t\tASSERT(error != -ENOSPC);\n\t\treturn error;\n\t}\n\tfbp = NULL;\n\t/*\n\t * Now see if we can convert the single-leaf directory\n\t * down to a block form directory.\n\t * This routine always kills the dabuf for the leaf, so\n\t * eliminate it from the path.\n\t */\n\terror = xfs_dir2_leaf_to_block(args, lbp, NULL);\n\tstate->path.blk[0].bp = NULL;\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);",
            "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);",
            "const struct xfs_buf_ops xfs_dir3_leaf1_buf_ops = {\n\t.verify_read = xfs_dir3_leaf1_read_verify,\n\t.verify_write = xfs_dir3_leaf1_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\nconst struct xfs_buf_ops xfs_dir3_leaf1_buf_ops = {\n\t.verify_read = xfs_dir3_leaf1_read_verify,\n\t.verify_write = xfs_dir3_leaf1_write_verify,\n};\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_node_to_leaf(\n\txfs_da_state_t\t\t*state)\t\t/* directory operation state */\n{\n\txfs_da_args_t\t\t*args;\t\t/* operation arguments */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return code */\n\tstruct xfs_buf\t\t*fbp;\t\t/* buffer for freespace block */\n\txfs_fileoff_t\t\tfo;\t\t/* freespace file offset */\n\txfs_dir2_free_t\t\t*free;\t\t/* freespace structure */\n\tstruct xfs_buf\t\t*lbp;\t\t/* buffer for leaf block */\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* tail of leaf structure */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tint\t\t\trval;\t\t/* successful free trim? */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\tstruct xfs_dir3_icfree_hdr freehdr;\n\n\t/*\n\t * There's more than a leaf level in the btree, so there must\n\t * be multiple leafn blocks.  Give up.\n\t */\n\tif (state->path.active > 1)\n\t\treturn 0;\n\targs = state->args;\n\n\ttrace_xfs_dir2_node_to_leaf(args);\n\n\tmp = state->mp;\n\tdp = args->dp;\n\ttp = args->trans;\n\t/*\n\t * Get the last offset in the file.\n\t */\n\tif ((error = xfs_bmap_last_offset(dp, &fo, XFS_DATA_FORK))) {\n\t\treturn error;\n\t}\n\tfo -= args->geo->fsbcount;\n\t/*\n\t * If there are freespace blocks other than the first one,\n\t * take this opportunity to remove trailing empty freespace blocks\n\t * that may have been left behind during no-space-reservation\n\t * operations.\n\t */\n\twhile (fo > args->geo->freeblk) {\n\t\tif ((error = xfs_dir2_node_trim_free(args, fo, &rval))) {\n\t\t\treturn error;\n\t\t}\n\t\tif (rval)\n\t\t\tfo -= args->geo->fsbcount;\n\t\telse\n\t\t\treturn 0;\n\t}\n\t/*\n\t * Now find the block just before the freespace block.\n\t */\n\tif ((error = xfs_bmap_last_before(tp, dp, &fo, XFS_DATA_FORK))) {\n\t\treturn error;\n\t}\n\t/*\n\t * If it's not the single leaf block, give up.\n\t */\n\tif (XFS_FSB_TO_B(mp, fo) > XFS_DIR2_LEAF_OFFSET + args->geo->blksize)\n\t\treturn 0;\n\tlbp = state->path.blk[0].bp;\n\tleaf = lbp->b_addr;\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\n\tASSERT(leafhdr.magic == XFS_DIR2_LEAFN_MAGIC ||\n\t       leafhdr.magic == XFS_DIR3_LEAFN_MAGIC);\n\n\t/*\n\t * Read the freespace block.\n\t */\n\terror = xfs_dir2_free_read(tp, dp,  args->geo->freeblk, &fbp);\n\tif (error)\n\t\treturn error;\n\tfree = fbp->b_addr;\n\tdp->d_ops->free_hdr_from_disk(&freehdr, free);\n\n\tASSERT(!freehdr.firstdb);\n\n\t/*\n\t * Now see if the leafn and free data will fit in a leaf1.\n\t * If not, release the buffer and give up.\n\t */\n\tif (xfs_dir3_leaf_size(&leafhdr, freehdr.nvalid) > args->geo->blksize) {\n\t\txfs_trans_brelse(tp, fbp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the leaf has any stale entries in it, compress them out.\n\t */\n\tif (leafhdr.stale)\n\t\txfs_dir3_leaf_compact(args, &leafhdr, lbp);\n\n\tlbp->b_ops = &xfs_dir3_leaf1_buf_ops;\n\txfs_trans_buf_set_type(tp, lbp, XFS_BLFT_DIR_LEAF1_BUF);\n\tleafhdr.magic = (leafhdr.magic == XFS_DIR2_LEAFN_MAGIC)\n\t\t\t\t\t? XFS_DIR2_LEAF1_MAGIC\n\t\t\t\t\t: XFS_DIR3_LEAF1_MAGIC;\n\n\t/*\n\t * Set up the leaf tail from the freespace block.\n\t */\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\tltp->bestcount = cpu_to_be32(freehdr.nvalid);\n\n\t/*\n\t * Set up the leaf bests table.\n\t */\n\tmemcpy(xfs_dir2_leaf_bests_p(ltp), dp->d_ops->free_bests_p(free),\n\t\tfreehdr.nvalid * sizeof(xfs_dir2_data_off_t));\n\n\tdp->d_ops->leaf_hdr_to_disk(leaf, &leafhdr);\n\txfs_dir3_leaf_log_header(args, lbp);\n\txfs_dir3_leaf_log_bests(args, lbp, 0, be32_to_cpu(ltp->bestcount) - 1);\n\txfs_dir3_leaf_log_tail(args, lbp);\n\txfs_dir3_leaf_check(dp, lbp);\n\n\t/*\n\t * Get rid of the freespace block.\n\t */\n\terror = xfs_dir2_shrink_inode(args,\n\t\t\txfs_dir2_byte_to_db(args->geo, XFS_DIR2_FREE_OFFSET),\n\t\t\tfbp);\n\tif (error) {\n\t\t/*\n\t\t * This can't fail here because it can only happen when\n\t\t * punching out the middle of an extent, and this is an\n\t\t * isolated block.\n\t\t */\n\t\tASSERT(error != -ENOSPC);\n\t\treturn error;\n\t}\n\tfbp = NULL;\n\t/*\n\t * Now see if we can convert the single-leaf directory\n\t * down to a block form directory.\n\t * This routine always kills the dabuf for the leaf, so\n\t * eliminate it from the path.\n\t */\n\terror = xfs_dir2_leaf_to_block(args, lbp, NULL);\n\tstate->path.blk[0].bp = NULL;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da3_join",
          "args": [
            "state"
          ],
          "line": 2111
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_join",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "929-1010",
          "snippet": "int\nxfs_da3_join(\n\tstruct xfs_da_state\t*state)\n{\n\tstruct xfs_da_state_blk\t*drop_blk;\n\tstruct xfs_da_state_blk\t*save_blk;\n\tint\t\t\taction = 0;\n\tint\t\t\terror;\n\n\ttrace_xfs_da_join(state->args);\n\n\tdrop_blk = &state->path.blk[ state->path.active-1 ];\n\tsave_blk = &state->altpath.blk[ state->path.active-1 ];\n\tASSERT(state->path.blk[0].magic == XFS_DA_NODE_MAGIC);\n\tASSERT(drop_blk->magic == XFS_ATTR_LEAF_MAGIC ||\n\t       drop_blk->magic == XFS_DIR2_LEAFN_MAGIC);\n\n\t/*\n\t * Walk back up the tree joining/deallocating as necessary.\n\t * When we stop dropping blocks, break out.\n\t */\n\tfor (  ; state->path.active >= 2; drop_blk--, save_blk--,\n\t\t state->path.active--) {\n\t\t/*\n\t\t * See if we can combine the block with a neighbor.\n\t\t *   (action == 0) => no options, just leave\n\t\t *   (action == 1) => coalesce, then unlink\n\t\t *   (action == 2) => block empty, unlink it\n\t\t */\n\t\tswitch (drop_blk->magic) {\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\t\terror = xfs_attr3_leaf_toosmall(state, &action);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (action == 0)\n\t\t\t\treturn 0;\n\t\t\txfs_attr3_leaf_unbalance(state, drop_blk, save_blk);\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\t\terror = xfs_dir2_leafn_toosmall(state, &action);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (action == 0)\n\t\t\t\treturn 0;\n\t\t\txfs_dir2_leafn_unbalance(state, drop_blk, save_blk);\n\t\t\tbreak;\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\t\t/*\n\t\t\t * Remove the offending node, fixup hashvals,\n\t\t\t * check for a toosmall neighbor.\n\t\t\t */\n\t\t\txfs_da3_node_remove(state, drop_blk);\n\t\t\txfs_da3_fixhashpath(state, &state->path);\n\t\t\terror = xfs_da3_node_toosmall(state, &action);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (action == 0)\n\t\t\t\treturn 0;\n\t\t\txfs_da3_node_unbalance(state, drop_blk, save_blk);\n\t\t\tbreak;\n\t\t}\n\t\txfs_da3_fixhashpath(state, &state->altpath);\n\t\terror = xfs_da3_blk_unlink(state, drop_blk, save_blk);\n\t\txfs_da_state_kill_altpath(state);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = xfs_da_shrink_inode(state->args, drop_blk->blkno,\n\t\t\t\t\t\t\t drop_blk->bp);\n\t\tdrop_blk->bp = NULL;\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\t/*\n\t * We joined all the way to the top.  If it turns out that\n\t * we only have one entry in the root, make the child block\n\t * the new root.\n\t */\n\txfs_da3_node_remove(state, drop_blk);\n\txfs_da3_fixhashpath(state, &state->path);\n\terror = xfs_da3_root_join(state, &state->path.blk[0]);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void xfs_da3_node_remove(xfs_da_state_t *state,\n\t\t\t\t\t      xfs_da_state_blk_t *drop_blk);",
            "STATIC int\txfs_da3_blk_unlink(xfs_da_state_t *state,\n\t\t\t\t  xfs_da_state_blk_t *drop_blk,\n\t\t\t\t  xfs_da_state_blk_t *save_blk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void xfs_da3_node_remove(xfs_da_state_t *state,\n\t\t\t\t\t      xfs_da_state_blk_t *drop_blk);\nSTATIC int\txfs_da3_blk_unlink(xfs_da_state_t *state,\n\t\t\t\t  xfs_da_state_blk_t *drop_blk,\n\t\t\t\t  xfs_da_state_blk_t *save_blk);\n\nint\nxfs_da3_join(\n\tstruct xfs_da_state\t*state)\n{\n\tstruct xfs_da_state_blk\t*drop_blk;\n\tstruct xfs_da_state_blk\t*save_blk;\n\tint\t\t\taction = 0;\n\tint\t\t\terror;\n\n\ttrace_xfs_da_join(state->args);\n\n\tdrop_blk = &state->path.blk[ state->path.active-1 ];\n\tsave_blk = &state->altpath.blk[ state->path.active-1 ];\n\tASSERT(state->path.blk[0].magic == XFS_DA_NODE_MAGIC);\n\tASSERT(drop_blk->magic == XFS_ATTR_LEAF_MAGIC ||\n\t       drop_blk->magic == XFS_DIR2_LEAFN_MAGIC);\n\n\t/*\n\t * Walk back up the tree joining/deallocating as necessary.\n\t * When we stop dropping blocks, break out.\n\t */\n\tfor (  ; state->path.active >= 2; drop_blk--, save_blk--,\n\t\t state->path.active--) {\n\t\t/*\n\t\t * See if we can combine the block with a neighbor.\n\t\t *   (action == 0) => no options, just leave\n\t\t *   (action == 1) => coalesce, then unlink\n\t\t *   (action == 2) => block empty, unlink it\n\t\t */\n\t\tswitch (drop_blk->magic) {\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\t\terror = xfs_attr3_leaf_toosmall(state, &action);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (action == 0)\n\t\t\t\treturn 0;\n\t\t\txfs_attr3_leaf_unbalance(state, drop_blk, save_blk);\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\t\terror = xfs_dir2_leafn_toosmall(state, &action);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (action == 0)\n\t\t\t\treturn 0;\n\t\t\txfs_dir2_leafn_unbalance(state, drop_blk, save_blk);\n\t\t\tbreak;\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\t\t/*\n\t\t\t * Remove the offending node, fixup hashvals,\n\t\t\t * check for a toosmall neighbor.\n\t\t\t */\n\t\t\txfs_da3_node_remove(state, drop_blk);\n\t\t\txfs_da3_fixhashpath(state, &state->path);\n\t\t\terror = xfs_da3_node_toosmall(state, &action);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (action == 0)\n\t\t\t\treturn 0;\n\t\t\txfs_da3_node_unbalance(state, drop_blk, save_blk);\n\t\t\tbreak;\n\t\t}\n\t\txfs_da3_fixhashpath(state, &state->altpath);\n\t\terror = xfs_da3_blk_unlink(state, drop_blk, save_blk);\n\t\txfs_da_state_kill_altpath(state);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = xfs_da_shrink_inode(state->args, drop_blk->blkno,\n\t\t\t\t\t\t\t drop_blk->bp);\n\t\tdrop_blk->bp = NULL;\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\t/*\n\t * We joined all the way to the top.  If it turns out that\n\t * we only have one entry in the root, make the child block\n\t * the new root.\n\t */\n\txfs_da3_node_remove(state, drop_blk);\n\txfs_da3_fixhashpath(state, &state->path);\n\terror = xfs_da3_root_join(state, &state->path.blk[0]);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da3_fixhashpath",
          "args": [
            "state",
            "&state->path"
          ],
          "line": 2106
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_fixhashpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "1256-1306",
          "snippet": "void\nxfs_da3_fixhashpath(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_path *path)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_node_entry *btree;\n\txfs_dahash_t\t\tlasthash=0;\n\tint\t\t\tlevel;\n\tint\t\t\tcount;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_fixhashpath(state->args);\n\n\tlevel = path->active-1;\n\tblk = &path->blk[ level ];\n\tswitch (blk->magic) {\n\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tlasthash = xfs_attr_leaf_lasthash(blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tlasthash = xfs_dir2_leafn_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DA_NODE_MAGIC:\n\t\tlasthash = xfs_da3_node_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\t}\n\tfor (blk--, level--; level >= 0; blk--, level--) {\n\t\tstruct xfs_da3_icnode_hdr nodehdr;\n\n\t\tnode = blk->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\tbtree = dp->d_ops->node_tree_p(node);\n\t\tif (be32_to_cpu(btree[blk->index].hashval) == lasthash)\n\t\t\tbreak;\n\t\tblk->hashval = lasthash;\n\t\tbtree[blk->index].hashval = cpu_to_be32(lasthash);\n\t\txfs_trans_log_buf(state->args->trans, blk->bp,\n\t\t\t\t  XFS_DA_LOGRANGE(node, &btree[blk->index],\n\t\t\t\t\t\t  sizeof(*btree)));\n\n\t\tlasthash = be32_to_cpu(btree[nodehdr.count - 1].hashval);\n\t}\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_da3_fixhashpath(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_path *path)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_node_entry *btree;\n\txfs_dahash_t\t\tlasthash=0;\n\tint\t\t\tlevel;\n\tint\t\t\tcount;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_fixhashpath(state->args);\n\n\tlevel = path->active-1;\n\tblk = &path->blk[ level ];\n\tswitch (blk->magic) {\n\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tlasthash = xfs_attr_leaf_lasthash(blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tlasthash = xfs_dir2_leafn_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DA_NODE_MAGIC:\n\t\tlasthash = xfs_da3_node_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\t}\n\tfor (blk--, level--; level >= 0; blk--, level--) {\n\t\tstruct xfs_da3_icnode_hdr nodehdr;\n\n\t\tnode = blk->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\tbtree = dp->d_ops->node_tree_p(node);\n\t\tif (be32_to_cpu(btree[blk->index].hashval) == lasthash)\n\t\t\tbreak;\n\t\tblk->hashval = lasthash;\n\t\tbtree[blk->index].hashval = cpu_to_be32(lasthash);\n\t\txfs_trans_log_buf(state->args->trans, blk->bp,\n\t\t\t\t  XFS_DA_LOGRANGE(node, &btree[blk->index],\n\t\t\t\t\t\t  sizeof(*btree)));\n\n\t\tlasthash = be32_to_cpu(btree[nodehdr.count - 1].hashval);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leafn_remove",
          "args": [
            "args",
            "blk->bp",
            "blk->index",
            "&state->extrablk",
            "&rval"
          ],
          "line": 2099
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leafn_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
          "lines": "1148-1302",
          "snippet": "static int\t\t\t\t\t/* error */\nxfs_dir2_leafn_remove(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tstruct xfs_buf\t\t*bp,\t\t/* leaf buffer */\n\tint\t\t\tindex,\t\t/* leaf entry index */\n\txfs_da_state_blk_t\t*dblk,\t\t/* data block */\n\tint\t\t\t*rval)\t\t/* resulting block needs join */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_db_t\t\tdb;\t\t/* data block number */\n\tstruct xfs_buf\t\t*dbp;\t\t/* data block buffer */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data block entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\tint\t\t\tlongest;\t/* longest data free entry */\n\tint\t\t\toff;\t\t/* data block entry offset */\n\tint\t\t\tneedlog;\t/* need to log data header */\n\tint\t\t\tneedscan;\t/* need to rescan data frees */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tstruct xfs_dir2_data_free *bf;\t\t/* bestfree table */\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\tstruct xfs_dir2_leaf_entry *ents;\n\n\ttrace_xfs_dir2_leafn_remove(args, index);\n\n\tdp = args->dp;\n\ttp = args->trans;\n\tleaf = bp->b_addr;\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\n\t/*\n\t * Point to the entry we're removing.\n\t */\n\tlep = &ents[index];\n\n\t/*\n\t * Extract the data block and offset from the entry.\n\t */\n\tdb = xfs_dir2_dataptr_to_db(args->geo, be32_to_cpu(lep->address));\n\tASSERT(dblk->blkno == db);\n\toff = xfs_dir2_dataptr_to_off(args->geo, be32_to_cpu(lep->address));\n\tASSERT(dblk->index == off);\n\n\t/*\n\t * Kill the leaf entry by marking it stale.\n\t * Log the leaf block changes.\n\t */\n\tleafhdr.stale++;\n\tdp->d_ops->leaf_hdr_to_disk(leaf, &leafhdr);\n\txfs_dir3_leaf_log_header(args, bp);\n\n\tlep->address = cpu_to_be32(XFS_DIR2_NULL_DATAPTR);\n\txfs_dir3_leaf_log_ents(args, bp, index, index);\n\n\t/*\n\t * Make the data entry free.  Keep track of the longest freespace\n\t * in the data block in case it changes.\n\t */\n\tdbp = dblk->bp;\n\thdr = dbp->b_addr;\n\tdep = (xfs_dir2_data_entry_t *)((char *)hdr + off);\n\tbf = dp->d_ops->data_bestfree_p(hdr);\n\tlongest = be16_to_cpu(bf[0].length);\n\tneedlog = needscan = 0;\n\txfs_dir2_data_make_free(args, dbp, off,\n\t\tdp->d_ops->data_entsize(dep->namelen), &needlog, &needscan);\n\t/*\n\t * Rescan the data block freespaces for bestfree.\n\t * Log the data block header if needed.\n\t */\n\tif (needscan)\n\t\txfs_dir2_data_freescan(dp, hdr, &needlog);\n\tif (needlog)\n\t\txfs_dir2_data_log_header(args, dbp);\n\txfs_dir3_data_check(dp, dbp);\n\t/*\n\t * If the longest data block freespace changes, need to update\n\t * the corresponding freeblock entry.\n\t */\n\tif (longest < be16_to_cpu(bf[0].length)) {\n\t\tint\t\terror;\t\t/* error return value */\n\t\tstruct xfs_buf\t*fbp;\t\t/* freeblock buffer */\n\t\txfs_dir2_db_t\tfdb;\t\t/* freeblock block number */\n\t\tint\t\tfindex;\t\t/* index in freeblock entries */\n\t\txfs_dir2_free_t\t*free;\t\t/* freeblock structure */\n\n\t\t/*\n\t\t * Convert the data block number to a free block,\n\t\t * read in the free block.\n\t\t */\n\t\tfdb = dp->d_ops->db_to_fdb(args->geo, db);\n\t\terror = xfs_dir2_free_read(tp, dp,\n\t\t\t\t\t   xfs_dir2_db_to_da(args->geo, fdb),\n\t\t\t\t\t   &fbp);\n\t\tif (error)\n\t\t\treturn error;\n\t\tfree = fbp->b_addr;\n#ifdef DEBUG\n\t{\n\t\tstruct xfs_dir3_icfree_hdr freehdr;\n\t\tdp->d_ops->free_hdr_from_disk(&freehdr, free);\n\t\tASSERT(freehdr.firstdb == dp->d_ops->free_max_bests(args->geo) *\n\t\t\t(fdb - xfs_dir2_byte_to_db(args->geo,\n\t\t\t\t\t\t   XFS_DIR2_FREE_OFFSET)));\n\t}\n#endif\n\t\t/*\n\t\t * Calculate which entry we need to fix.\n\t\t */\n\t\tfindex = dp->d_ops->db_to_fdindex(args->geo, db);\n\t\tlongest = be16_to_cpu(bf[0].length);\n\t\t/*\n\t\t * If the data block is now empty we can get rid of it\n\t\t * (usually).\n\t\t */\n\t\tif (longest == args->geo->blksize -\n\t\t\t       dp->d_ops->data_entry_offset) {\n\t\t\t/*\n\t\t\t * Try to punch out the data block.\n\t\t\t */\n\t\t\terror = xfs_dir2_shrink_inode(args, db, dbp);\n\t\t\tif (error == 0) {\n\t\t\t\tdblk->bp = NULL;\n\t\t\t\thdr = NULL;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We can get ENOSPC if there's no space reservation.\n\t\t\t * In this case just drop the buffer and some one else\n\t\t\t * will eventually get rid of the empty block.\n\t\t\t */\n\t\t\telse if (!(error == -ENOSPC && args->total == 0))\n\t\t\t\treturn error;\n\t\t}\n\t\t/*\n\t\t * If we got rid of the data block, we can eliminate that entry\n\t\t * in the free block.\n\t\t */\n\t\terror = xfs_dir3_data_block_free(args, hdr, free,\n\t\t\t\t\t\t fdb, findex, fbp, longest);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_dir3_leaf_check(dp, bp);\n\t/*\n\t * Return indication of whether this leaf block is empty enough\n\t * to justify trying to join it with a neighbor.\n\t */\n\t*rval = (dp->d_ops->leaf_hdr_size +\n\t\t (uint)sizeof(ents[0]) * (leafhdr.count - leafhdr.stale)) <\n\t\targs->geo->magicpct;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);",
            "static int xfs_dir2_leafn_remove(xfs_da_args_t *args, struct xfs_buf *bp,\n\t\t\t\t int index, xfs_da_state_blk_t *dblk,\n\t\t\t\t int *rval);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);\nstatic int xfs_dir2_leafn_remove(xfs_da_args_t *args, struct xfs_buf *bp,\n\t\t\t\t int index, xfs_da_state_blk_t *dblk,\n\t\t\t\t int *rval);\n\nstatic int\t\t\t\t\t/* error */\nxfs_dir2_leafn_remove(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tstruct xfs_buf\t\t*bp,\t\t/* leaf buffer */\n\tint\t\t\tindex,\t\t/* leaf entry index */\n\txfs_da_state_blk_t\t*dblk,\t\t/* data block */\n\tint\t\t\t*rval)\t\t/* resulting block needs join */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_db_t\t\tdb;\t\t/* data block number */\n\tstruct xfs_buf\t\t*dbp;\t\t/* data block buffer */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data block entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\tint\t\t\tlongest;\t/* longest data free entry */\n\tint\t\t\toff;\t\t/* data block entry offset */\n\tint\t\t\tneedlog;\t/* need to log data header */\n\tint\t\t\tneedscan;\t/* need to rescan data frees */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tstruct xfs_dir2_data_free *bf;\t\t/* bestfree table */\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\tstruct xfs_dir2_leaf_entry *ents;\n\n\ttrace_xfs_dir2_leafn_remove(args, index);\n\n\tdp = args->dp;\n\ttp = args->trans;\n\tleaf = bp->b_addr;\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\n\t/*\n\t * Point to the entry we're removing.\n\t */\n\tlep = &ents[index];\n\n\t/*\n\t * Extract the data block and offset from the entry.\n\t */\n\tdb = xfs_dir2_dataptr_to_db(args->geo, be32_to_cpu(lep->address));\n\tASSERT(dblk->blkno == db);\n\toff = xfs_dir2_dataptr_to_off(args->geo, be32_to_cpu(lep->address));\n\tASSERT(dblk->index == off);\n\n\t/*\n\t * Kill the leaf entry by marking it stale.\n\t * Log the leaf block changes.\n\t */\n\tleafhdr.stale++;\n\tdp->d_ops->leaf_hdr_to_disk(leaf, &leafhdr);\n\txfs_dir3_leaf_log_header(args, bp);\n\n\tlep->address = cpu_to_be32(XFS_DIR2_NULL_DATAPTR);\n\txfs_dir3_leaf_log_ents(args, bp, index, index);\n\n\t/*\n\t * Make the data entry free.  Keep track of the longest freespace\n\t * in the data block in case it changes.\n\t */\n\tdbp = dblk->bp;\n\thdr = dbp->b_addr;\n\tdep = (xfs_dir2_data_entry_t *)((char *)hdr + off);\n\tbf = dp->d_ops->data_bestfree_p(hdr);\n\tlongest = be16_to_cpu(bf[0].length);\n\tneedlog = needscan = 0;\n\txfs_dir2_data_make_free(args, dbp, off,\n\t\tdp->d_ops->data_entsize(dep->namelen), &needlog, &needscan);\n\t/*\n\t * Rescan the data block freespaces for bestfree.\n\t * Log the data block header if needed.\n\t */\n\tif (needscan)\n\t\txfs_dir2_data_freescan(dp, hdr, &needlog);\n\tif (needlog)\n\t\txfs_dir2_data_log_header(args, dbp);\n\txfs_dir3_data_check(dp, dbp);\n\t/*\n\t * If the longest data block freespace changes, need to update\n\t * the corresponding freeblock entry.\n\t */\n\tif (longest < be16_to_cpu(bf[0].length)) {\n\t\tint\t\terror;\t\t/* error return value */\n\t\tstruct xfs_buf\t*fbp;\t\t/* freeblock buffer */\n\t\txfs_dir2_db_t\tfdb;\t\t/* freeblock block number */\n\t\tint\t\tfindex;\t\t/* index in freeblock entries */\n\t\txfs_dir2_free_t\t*free;\t\t/* freeblock structure */\n\n\t\t/*\n\t\t * Convert the data block number to a free block,\n\t\t * read in the free block.\n\t\t */\n\t\tfdb = dp->d_ops->db_to_fdb(args->geo, db);\n\t\terror = xfs_dir2_free_read(tp, dp,\n\t\t\t\t\t   xfs_dir2_db_to_da(args->geo, fdb),\n\t\t\t\t\t   &fbp);\n\t\tif (error)\n\t\t\treturn error;\n\t\tfree = fbp->b_addr;\n#ifdef DEBUG\n\t{\n\t\tstruct xfs_dir3_icfree_hdr freehdr;\n\t\tdp->d_ops->free_hdr_from_disk(&freehdr, free);\n\t\tASSERT(freehdr.firstdb == dp->d_ops->free_max_bests(args->geo) *\n\t\t\t(fdb - xfs_dir2_byte_to_db(args->geo,\n\t\t\t\t\t\t   XFS_DIR2_FREE_OFFSET)));\n\t}\n#endif\n\t\t/*\n\t\t * Calculate which entry we need to fix.\n\t\t */\n\t\tfindex = dp->d_ops->db_to_fdindex(args->geo, db);\n\t\tlongest = be16_to_cpu(bf[0].length);\n\t\t/*\n\t\t * If the data block is now empty we can get rid of it\n\t\t * (usually).\n\t\t */\n\t\tif (longest == args->geo->blksize -\n\t\t\t       dp->d_ops->data_entry_offset) {\n\t\t\t/*\n\t\t\t * Try to punch out the data block.\n\t\t\t */\n\t\t\terror = xfs_dir2_shrink_inode(args, db, dbp);\n\t\t\tif (error == 0) {\n\t\t\t\tdblk->bp = NULL;\n\t\t\t\thdr = NULL;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We can get ENOSPC if there's no space reservation.\n\t\t\t * In this case just drop the buffer and some one else\n\t\t\t * will eventually get rid of the empty block.\n\t\t\t */\n\t\t\telse if (!(error == -ENOSPC && args->total == 0))\n\t\t\t\treturn error;\n\t\t}\n\t\t/*\n\t\t * If we got rid of the data block, we can eliminate that entry\n\t\t * in the free block.\n\t\t */\n\t\terror = xfs_dir3_data_block_free(args, hdr, free,\n\t\t\t\t\t\t fdb, findex, fbp, longest);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_dir3_leaf_check(dp, bp);\n\t/*\n\t * Return indication of whether this leaf block is empty enough\n\t * to justify trying to join it with a neighbor.\n\t */\n\t*rval = (dp->d_ops->leaf_hdr_size +\n\t\t (uint)sizeof(ents[0]) * (leafhdr.count - leafhdr.stale)) <\n\t\targs->geo->magicpct;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "state->extravalid"
          ],
          "line": 2094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "blk->magic == XFS_DIR2_LEAFN_MAGIC"
          ],
          "line": 2093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_da3_node_lookup_int",
          "args": [
            "state",
            "&rval"
          ],
          "line": 2082
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_node_lookup_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "1445-1597",
          "snippet": "int\t\t\t\t\t\t\t/* error */\nxfs_da3_node_lookup_int(\n\tstruct xfs_da_state\t*state,\n\tint\t\t\t*result)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_blkinfo\t*curr;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\tstruct xfs_da_args\t*args;\n\txfs_dablk_t\t\tblkno;\n\txfs_dahash_t\t\thashval;\n\txfs_dahash_t\t\tbtreehashval;\n\tint\t\t\tprobe;\n\tint\t\t\tspan;\n\tint\t\t\tmax;\n\tint\t\t\terror;\n\tint\t\t\tretval;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\targs = state->args;\n\n\t/*\n\t * Descend thru the B-tree searching each level for the right\n\t * node to use, until the right hashval is found.\n\t */\n\tblkno = (args->whichfork == XFS_DATA_FORK)? args->geo->leafblk : 0;\n\tfor (blk = &state->path.blk[0], state->path.active = 1;\n\t\t\t state->path.active <= XFS_DA_NODE_MAXDEPTH;\n\t\t\t blk++, state->path.active++) {\n\t\t/*\n\t\t * Read the next node down in the tree.\n\t\t */\n\t\tblk->blkno = blkno;\n\t\terror = xfs_da3_node_read(args->trans, args->dp, blkno,\n\t\t\t\t\t-1, &blk->bp, args->whichfork);\n\t\tif (error) {\n\t\t\tblk->blkno = 0;\n\t\t\tstate->path.active--;\n\t\t\treturn error;\n\t\t}\n\t\tcurr = blk->bp->b_addr;\n\t\tblk->magic = be16_to_cpu(curr->magic);\n\n\t\tif (blk->magic == XFS_ATTR_LEAF_MAGIC ||\n\t\t    blk->magic == XFS_ATTR3_LEAF_MAGIC) {\n\t\t\tblk->magic = XFS_ATTR_LEAF_MAGIC;\n\t\t\tblk->hashval = xfs_attr_leaf_lasthash(blk->bp, NULL);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (blk->magic == XFS_DIR2_LEAFN_MAGIC ||\n\t\t    blk->magic == XFS_DIR3_LEAFN_MAGIC) {\n\t\t\tblk->magic = XFS_DIR2_LEAFN_MAGIC;\n\t\t\tblk->hashval = xfs_dir2_leafn_lasthash(args->dp,\n\t\t\t\t\t\t\t       blk->bp, NULL);\n\t\t\tbreak;\n\t\t}\n\n\t\tblk->magic = XFS_DA_NODE_MAGIC;\n\n\n\t\t/*\n\t\t * Search an intermediate node for a match.\n\t\t */\n\t\tnode = blk->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\tbtree = dp->d_ops->node_tree_p(node);\n\n\t\tmax = nodehdr.count;\n\t\tblk->hashval = be32_to_cpu(btree[max - 1].hashval);\n\n\t\t/*\n\t\t * Binary search.  (note: small blocks will skip loop)\n\t\t */\n\t\tprobe = span = max / 2;\n\t\thashval = args->hashval;\n\t\twhile (span > 4) {\n\t\t\tspan /= 2;\n\t\t\tbtreehashval = be32_to_cpu(btree[probe].hashval);\n\t\t\tif (btreehashval < hashval)\n\t\t\t\tprobe += span;\n\t\t\telse if (btreehashval > hashval)\n\t\t\t\tprobe -= span;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tASSERT((probe >= 0) && (probe < max));\n\t\tASSERT((span <= 4) ||\n\t\t\t(be32_to_cpu(btree[probe].hashval) == hashval));\n\n\t\t/*\n\t\t * Since we may have duplicate hashval's, find the first\n\t\t * matching hashval in the node.\n\t\t */\n\t\twhile (probe > 0 &&\n\t\t       be32_to_cpu(btree[probe].hashval) >= hashval) {\n\t\t\tprobe--;\n\t\t}\n\t\twhile (probe < max &&\n\t\t       be32_to_cpu(btree[probe].hashval) < hashval) {\n\t\t\tprobe++;\n\t\t}\n\n\t\t/*\n\t\t * Pick the right block to descend on.\n\t\t */\n\t\tif (probe == max) {\n\t\t\tblk->index = max - 1;\n\t\t\tblkno = be32_to_cpu(btree[max - 1].before);\n\t\t} else {\n\t\t\tblk->index = probe;\n\t\t\tblkno = be32_to_cpu(btree[probe].before);\n\t\t}\n\t}\n\n\t/*\n\t * A leaf block that ends in the hashval that we are interested in\n\t * (final hashval == search hashval) means that the next block may\n\t * contain more entries with the same hashval, shift upward to the\n\t * next leaf and keep searching.\n\t */\n\tfor (;;) {\n\t\tif (blk->magic == XFS_DIR2_LEAFN_MAGIC) {\n\t\t\tretval = xfs_dir2_leafn_lookup_int(blk->bp, args,\n\t\t\t\t\t\t\t&blk->index, state);\n\t\t} else if (blk->magic == XFS_ATTR_LEAF_MAGIC) {\n\t\t\tretval = xfs_attr3_leaf_lookup_int(blk->bp, args);\n\t\t\tblk->index = args->index;\n\t\t\targs->blkno = blk->blkno;\n\t\t} else {\n\t\t\tASSERT(0);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tif (((retval == -ENOENT) || (retval == -ENOATTR)) &&\n\t\t    (blk->hashval == args->hashval)) {\n\t\t\terror = xfs_da3_path_shift(state, &state->path, 1, 1,\n\t\t\t\t\t\t\t &retval);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (retval == 0) {\n\t\t\t\tcontinue;\n\t\t\t} else if (blk->magic == XFS_ATTR_LEAF_MAGIC) {\n\t\t\t\t/* path_shift() gives ENOENT */\n\t\t\t\tretval = -ENOATTR;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\t*result = retval;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_da3_node_split(xfs_da_state_t *state,\n\t\t\t\t\t    xfs_da_state_blk_t *existing_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *split_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *blk_to_add,\n\t\t\t\t\t    int treelevel,\n\t\t\t\t\t    int *result);",
            "STATIC int xfs_da3_node_toosmall(xfs_da_state_t *state, int *retval);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_da3_node_split(xfs_da_state_t *state,\n\t\t\t\t\t    xfs_da_state_blk_t *existing_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *split_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *blk_to_add,\n\t\t\t\t\t    int treelevel,\n\t\t\t\t\t    int *result);\nSTATIC int xfs_da3_node_toosmall(xfs_da_state_t *state, int *retval);\n\nint\t\t\t\t\t\t\t/* error */\nxfs_da3_node_lookup_int(\n\tstruct xfs_da_state\t*state,\n\tint\t\t\t*result)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_blkinfo\t*curr;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\tstruct xfs_da_args\t*args;\n\txfs_dablk_t\t\tblkno;\n\txfs_dahash_t\t\thashval;\n\txfs_dahash_t\t\tbtreehashval;\n\tint\t\t\tprobe;\n\tint\t\t\tspan;\n\tint\t\t\tmax;\n\tint\t\t\terror;\n\tint\t\t\tretval;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\targs = state->args;\n\n\t/*\n\t * Descend thru the B-tree searching each level for the right\n\t * node to use, until the right hashval is found.\n\t */\n\tblkno = (args->whichfork == XFS_DATA_FORK)? args->geo->leafblk : 0;\n\tfor (blk = &state->path.blk[0], state->path.active = 1;\n\t\t\t state->path.active <= XFS_DA_NODE_MAXDEPTH;\n\t\t\t blk++, state->path.active++) {\n\t\t/*\n\t\t * Read the next node down in the tree.\n\t\t */\n\t\tblk->blkno = blkno;\n\t\terror = xfs_da3_node_read(args->trans, args->dp, blkno,\n\t\t\t\t\t-1, &blk->bp, args->whichfork);\n\t\tif (error) {\n\t\t\tblk->blkno = 0;\n\t\t\tstate->path.active--;\n\t\t\treturn error;\n\t\t}\n\t\tcurr = blk->bp->b_addr;\n\t\tblk->magic = be16_to_cpu(curr->magic);\n\n\t\tif (blk->magic == XFS_ATTR_LEAF_MAGIC ||\n\t\t    blk->magic == XFS_ATTR3_LEAF_MAGIC) {\n\t\t\tblk->magic = XFS_ATTR_LEAF_MAGIC;\n\t\t\tblk->hashval = xfs_attr_leaf_lasthash(blk->bp, NULL);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (blk->magic == XFS_DIR2_LEAFN_MAGIC ||\n\t\t    blk->magic == XFS_DIR3_LEAFN_MAGIC) {\n\t\t\tblk->magic = XFS_DIR2_LEAFN_MAGIC;\n\t\t\tblk->hashval = xfs_dir2_leafn_lasthash(args->dp,\n\t\t\t\t\t\t\t       blk->bp, NULL);\n\t\t\tbreak;\n\t\t}\n\n\t\tblk->magic = XFS_DA_NODE_MAGIC;\n\n\n\t\t/*\n\t\t * Search an intermediate node for a match.\n\t\t */\n\t\tnode = blk->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\tbtree = dp->d_ops->node_tree_p(node);\n\n\t\tmax = nodehdr.count;\n\t\tblk->hashval = be32_to_cpu(btree[max - 1].hashval);\n\n\t\t/*\n\t\t * Binary search.  (note: small blocks will skip loop)\n\t\t */\n\t\tprobe = span = max / 2;\n\t\thashval = args->hashval;\n\t\twhile (span > 4) {\n\t\t\tspan /= 2;\n\t\t\tbtreehashval = be32_to_cpu(btree[probe].hashval);\n\t\t\tif (btreehashval < hashval)\n\t\t\t\tprobe += span;\n\t\t\telse if (btreehashval > hashval)\n\t\t\t\tprobe -= span;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tASSERT((probe >= 0) && (probe < max));\n\t\tASSERT((span <= 4) ||\n\t\t\t(be32_to_cpu(btree[probe].hashval) == hashval));\n\n\t\t/*\n\t\t * Since we may have duplicate hashval's, find the first\n\t\t * matching hashval in the node.\n\t\t */\n\t\twhile (probe > 0 &&\n\t\t       be32_to_cpu(btree[probe].hashval) >= hashval) {\n\t\t\tprobe--;\n\t\t}\n\t\twhile (probe < max &&\n\t\t       be32_to_cpu(btree[probe].hashval) < hashval) {\n\t\t\tprobe++;\n\t\t}\n\n\t\t/*\n\t\t * Pick the right block to descend on.\n\t\t */\n\t\tif (probe == max) {\n\t\t\tblk->index = max - 1;\n\t\t\tblkno = be32_to_cpu(btree[max - 1].before);\n\t\t} else {\n\t\t\tblk->index = probe;\n\t\t\tblkno = be32_to_cpu(btree[probe].before);\n\t\t}\n\t}\n\n\t/*\n\t * A leaf block that ends in the hashval that we are interested in\n\t * (final hashval == search hashval) means that the next block may\n\t * contain more entries with the same hashval, shift upward to the\n\t * next leaf and keep searching.\n\t */\n\tfor (;;) {\n\t\tif (blk->magic == XFS_DIR2_LEAFN_MAGIC) {\n\t\t\tretval = xfs_dir2_leafn_lookup_int(blk->bp, args,\n\t\t\t\t\t\t\t&blk->index, state);\n\t\t} else if (blk->magic == XFS_ATTR_LEAF_MAGIC) {\n\t\t\tretval = xfs_attr3_leaf_lookup_int(blk->bp, args);\n\t\t\tblk->index = args->index;\n\t\t\targs->blkno = blk->blkno;\n\t\t} else {\n\t\t\tASSERT(0);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tif (((retval == -ENOENT) || (retval == -ENOATTR)) &&\n\t\t    (blk->hashval == args->hashval)) {\n\t\t\terror = xfs_da3_path_shift(state, &state->path, 1, 1,\n\t\t\t\t\t\t\t &retval);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (retval == 0) {\n\t\t\t\tcontinue;\n\t\t\t} else if (blk->magic == XFS_ATTR_LEAF_MAGIC) {\n\t\t\t\t/* path_shift() gives ENOENT */\n\t\t\t\tretval = -ENOATTR;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\t*result = retval;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da_state_alloc",
          "args": [],
          "line": 2077
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_state_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "98-102",
          "snippet": "xfs_da_state_t *\nxfs_da_state_alloc(void)\n{\n\treturn kmem_zone_zalloc(xfs_da_state_zone, KM_NOFS);\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t *xfs_da_state_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t *xfs_da_state_zone;\n\nxfs_da_state_t *\nxfs_da_state_alloc(void)\n{\n\treturn kmem_zone_zalloc(xfs_da_state_zone, KM_NOFS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_dir2_node_removename",
          "args": [
            "args"
          ],
          "line": 2072
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);\nstatic int xfs_dir2_leafn_remove(xfs_da_args_t *args, struct xfs_buf *bp,\n\t\t\t\t int index, xfs_da_state_blk_t *dblk,\n\t\t\t\t int *rval);\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_node_removename(\n\tstruct xfs_da_args\t*args)\t\t/* operation arguments */\n{\n\tstruct xfs_da_state_blk\t*blk;\t\t/* leaf block */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\trval;\t\t/* operation return value */\n\tstruct xfs_da_state\t*state;\t\t/* btree cursor */\n\n\ttrace_xfs_dir2_node_removename(args);\n\n\t/*\n\t * Allocate and initialize the btree cursor.\n\t */\n\tstate = xfs_da_state_alloc();\n\tstate->args = args;\n\tstate->mp = args->dp->i_mount;\n\n\t/* Look up the entry we're deleting, set up the cursor. */\n\terror = xfs_da3_node_lookup_int(state, &rval);\n\tif (error)\n\t\tgoto out_free;\n\n\t/* Didn't find it, upper layer screwed up. */\n\tif (rval != -EEXIST) {\n\t\terror = rval;\n\t\tgoto out_free;\n\t}\n\n\tblk = &state->path.blk[state->path.active - 1];\n\tASSERT(blk->magic == XFS_DIR2_LEAFN_MAGIC);\n\tASSERT(state->extravalid);\n\t/*\n\t * Remove the leaf and data entries.\n\t * Extrablk refers to the data block.\n\t */\n\terror = xfs_dir2_leafn_remove(args, blk->bp, blk->index,\n\t\t&state->extrablk, &rval);\n\tif (error)\n\t\tgoto out_free;\n\t/*\n\t * Fix the hash values up the btree.\n\t */\n\txfs_da3_fixhashpath(state, &state->path);\n\t/*\n\t * If we need to join leaf blocks, do it.\n\t */\n\tif (rval && state->path.active > 1)\n\t\terror = xfs_da3_join(state);\n\t/*\n\t * If no errors so far, try conversion to leaf format.\n\t */\n\tif (!error)\n\t\terror = xfs_dir2_node_to_leaf(state);\nout_free:\n\txfs_da_state_free(state);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_dir2_node_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
    "lines": "2010-2058",
    "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_node_lookup(\n\txfs_da_args_t\t*args)\t\t\t/* operation arguments */\n{\n\tint\t\terror;\t\t\t/* error return value */\n\tint\t\ti;\t\t\t/* btree level */\n\tint\t\trval;\t\t\t/* operation return value */\n\txfs_da_state_t\t*state;\t\t\t/* btree cursor */\n\n\ttrace_xfs_dir2_node_lookup(args);\n\n\t/*\n\t * Allocate and initialize the btree cursor.\n\t */\n\tstate = xfs_da_state_alloc();\n\tstate->args = args;\n\tstate->mp = args->dp->i_mount;\n\t/*\n\t * Fill in the path to the entry in the cursor.\n\t */\n\terror = xfs_da3_node_lookup_int(state, &rval);\n\tif (error)\n\t\trval = error;\n\telse if (rval == -ENOENT && args->cmpresult == XFS_CMP_CASE) {\n\t\t/* If a CI match, dup the actual name and return -EEXIST */\n\t\txfs_dir2_data_entry_t\t*dep;\n\n\t\tdep = (xfs_dir2_data_entry_t *)\n\t\t\t((char *)state->extrablk.bp->b_addr +\n\t\t\t\t\t\t state->extrablk.index);\n\t\trval = xfs_dir_cilookup_result(args, dep->name, dep->namelen);\n\t}\n\t/*\n\t * Release the btree blocks and leaf block.\n\t */\n\tfor (i = 0; i < state->path.active; i++) {\n\t\txfs_trans_brelse(args->trans, state->path.blk[i].bp);\n\t\tstate->path.blk[i].bp = NULL;\n\t}\n\t/*\n\t * Release the data block if we have it.\n\t */\n\tif (state->extravalid && state->extrablk.bp) {\n\t\txfs_trans_brelse(args->trans, state->extrablk.bp);\n\t\tstate->extrablk.bp = NULL;\n\t}\n\txfs_da_state_free(state);\n\treturn rval;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);",
      "static int xfs_dir2_leafn_remove(xfs_da_args_t *args, struct xfs_buf *bp,\n\t\t\t\t int index, xfs_da_state_blk_t *dblk,\n\t\t\t\t int *rval);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_da_state_free",
          "args": [
            "state"
          ],
          "line": 2056
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_state_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "120-128",
          "snippet": "void\nxfs_da_state_free(xfs_da_state_t *state)\n{\n\txfs_da_state_kill_altpath(state);\n#ifdef DEBUG\n\tmemset((char *)state, 0, sizeof(*state));\n#endif /* DEBUG */\n\tkmem_zone_free(xfs_da_state_zone, state);\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t *xfs_da_state_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t *xfs_da_state_zone;\n\nvoid\nxfs_da_state_free(xfs_da_state_t *state)\n{\n\txfs_da_state_kill_altpath(state);\n#ifdef DEBUG\n\tmemset((char *)state, 0, sizeof(*state));\n#endif /* DEBUG */\n\tkmem_zone_free(xfs_da_state_zone, state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "args->trans",
            "state->extrablk.bp"
          ],
          "line": 2053
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir_cilookup_result",
          "args": [
            "args",
            "dep->name",
            "dep->namelen"
          ],
          "line": 2040
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir_cilookup_result",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
          "lines": "327-346",
          "snippet": "int\nxfs_dir_cilookup_result(\n\tstruct xfs_da_args *args,\n\tconst unsigned char *name,\n\tint\t\tlen)\n{\n\tif (args->cmpresult == XFS_CMP_DIFFERENT)\n\t\treturn -ENOENT;\n\tif (args->cmpresult != XFS_CMP_CASE ||\n\t\t\t\t\t!(args->op_flags & XFS_DA_OP_CILOOKUP))\n\t\treturn -EEXIST;\n\n\targs->value = kmem_alloc(len, KM_NOFS | KM_MAYFAIL);\n\tif (!args->value)\n\t\treturn -ENOMEM;\n\n\tmemcpy(args->value, name, len);\n\targs->valuelen = len;\n\treturn -EEXIST;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir_cilookup_result(\n\tstruct xfs_da_args *args,\n\tconst unsigned char *name,\n\tint\t\tlen)\n{\n\tif (args->cmpresult == XFS_CMP_DIFFERENT)\n\t\treturn -ENOENT;\n\tif (args->cmpresult != XFS_CMP_CASE ||\n\t\t\t\t\t!(args->op_flags & XFS_DA_OP_CILOOKUP))\n\t\treturn -EEXIST;\n\n\targs->value = kmem_alloc(len, KM_NOFS | KM_MAYFAIL);\n\tif (!args->value)\n\t\treturn -ENOMEM;\n\n\tmemcpy(args->value, name, len);\n\targs->valuelen = len;\n\treturn -EEXIST;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da3_node_lookup_int",
          "args": [
            "state",
            "&rval"
          ],
          "line": 2030
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_node_lookup_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "1445-1597",
          "snippet": "int\t\t\t\t\t\t\t/* error */\nxfs_da3_node_lookup_int(\n\tstruct xfs_da_state\t*state,\n\tint\t\t\t*result)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_blkinfo\t*curr;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\tstruct xfs_da_args\t*args;\n\txfs_dablk_t\t\tblkno;\n\txfs_dahash_t\t\thashval;\n\txfs_dahash_t\t\tbtreehashval;\n\tint\t\t\tprobe;\n\tint\t\t\tspan;\n\tint\t\t\tmax;\n\tint\t\t\terror;\n\tint\t\t\tretval;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\targs = state->args;\n\n\t/*\n\t * Descend thru the B-tree searching each level for the right\n\t * node to use, until the right hashval is found.\n\t */\n\tblkno = (args->whichfork == XFS_DATA_FORK)? args->geo->leafblk : 0;\n\tfor (blk = &state->path.blk[0], state->path.active = 1;\n\t\t\t state->path.active <= XFS_DA_NODE_MAXDEPTH;\n\t\t\t blk++, state->path.active++) {\n\t\t/*\n\t\t * Read the next node down in the tree.\n\t\t */\n\t\tblk->blkno = blkno;\n\t\terror = xfs_da3_node_read(args->trans, args->dp, blkno,\n\t\t\t\t\t-1, &blk->bp, args->whichfork);\n\t\tif (error) {\n\t\t\tblk->blkno = 0;\n\t\t\tstate->path.active--;\n\t\t\treturn error;\n\t\t}\n\t\tcurr = blk->bp->b_addr;\n\t\tblk->magic = be16_to_cpu(curr->magic);\n\n\t\tif (blk->magic == XFS_ATTR_LEAF_MAGIC ||\n\t\t    blk->magic == XFS_ATTR3_LEAF_MAGIC) {\n\t\t\tblk->magic = XFS_ATTR_LEAF_MAGIC;\n\t\t\tblk->hashval = xfs_attr_leaf_lasthash(blk->bp, NULL);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (blk->magic == XFS_DIR2_LEAFN_MAGIC ||\n\t\t    blk->magic == XFS_DIR3_LEAFN_MAGIC) {\n\t\t\tblk->magic = XFS_DIR2_LEAFN_MAGIC;\n\t\t\tblk->hashval = xfs_dir2_leafn_lasthash(args->dp,\n\t\t\t\t\t\t\t       blk->bp, NULL);\n\t\t\tbreak;\n\t\t}\n\n\t\tblk->magic = XFS_DA_NODE_MAGIC;\n\n\n\t\t/*\n\t\t * Search an intermediate node for a match.\n\t\t */\n\t\tnode = blk->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\tbtree = dp->d_ops->node_tree_p(node);\n\n\t\tmax = nodehdr.count;\n\t\tblk->hashval = be32_to_cpu(btree[max - 1].hashval);\n\n\t\t/*\n\t\t * Binary search.  (note: small blocks will skip loop)\n\t\t */\n\t\tprobe = span = max / 2;\n\t\thashval = args->hashval;\n\t\twhile (span > 4) {\n\t\t\tspan /= 2;\n\t\t\tbtreehashval = be32_to_cpu(btree[probe].hashval);\n\t\t\tif (btreehashval < hashval)\n\t\t\t\tprobe += span;\n\t\t\telse if (btreehashval > hashval)\n\t\t\t\tprobe -= span;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tASSERT((probe >= 0) && (probe < max));\n\t\tASSERT((span <= 4) ||\n\t\t\t(be32_to_cpu(btree[probe].hashval) == hashval));\n\n\t\t/*\n\t\t * Since we may have duplicate hashval's, find the first\n\t\t * matching hashval in the node.\n\t\t */\n\t\twhile (probe > 0 &&\n\t\t       be32_to_cpu(btree[probe].hashval) >= hashval) {\n\t\t\tprobe--;\n\t\t}\n\t\twhile (probe < max &&\n\t\t       be32_to_cpu(btree[probe].hashval) < hashval) {\n\t\t\tprobe++;\n\t\t}\n\n\t\t/*\n\t\t * Pick the right block to descend on.\n\t\t */\n\t\tif (probe == max) {\n\t\t\tblk->index = max - 1;\n\t\t\tblkno = be32_to_cpu(btree[max - 1].before);\n\t\t} else {\n\t\t\tblk->index = probe;\n\t\t\tblkno = be32_to_cpu(btree[probe].before);\n\t\t}\n\t}\n\n\t/*\n\t * A leaf block that ends in the hashval that we are interested in\n\t * (final hashval == search hashval) means that the next block may\n\t * contain more entries with the same hashval, shift upward to the\n\t * next leaf and keep searching.\n\t */\n\tfor (;;) {\n\t\tif (blk->magic == XFS_DIR2_LEAFN_MAGIC) {\n\t\t\tretval = xfs_dir2_leafn_lookup_int(blk->bp, args,\n\t\t\t\t\t\t\t&blk->index, state);\n\t\t} else if (blk->magic == XFS_ATTR_LEAF_MAGIC) {\n\t\t\tretval = xfs_attr3_leaf_lookup_int(blk->bp, args);\n\t\t\tblk->index = args->index;\n\t\t\targs->blkno = blk->blkno;\n\t\t} else {\n\t\t\tASSERT(0);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tif (((retval == -ENOENT) || (retval == -ENOATTR)) &&\n\t\t    (blk->hashval == args->hashval)) {\n\t\t\terror = xfs_da3_path_shift(state, &state->path, 1, 1,\n\t\t\t\t\t\t\t &retval);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (retval == 0) {\n\t\t\t\tcontinue;\n\t\t\t} else if (blk->magic == XFS_ATTR_LEAF_MAGIC) {\n\t\t\t\t/* path_shift() gives ENOENT */\n\t\t\t\tretval = -ENOATTR;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\t*result = retval;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_da3_node_split(xfs_da_state_t *state,\n\t\t\t\t\t    xfs_da_state_blk_t *existing_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *split_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *blk_to_add,\n\t\t\t\t\t    int treelevel,\n\t\t\t\t\t    int *result);",
            "STATIC int xfs_da3_node_toosmall(xfs_da_state_t *state, int *retval);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_da3_node_split(xfs_da_state_t *state,\n\t\t\t\t\t    xfs_da_state_blk_t *existing_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *split_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *blk_to_add,\n\t\t\t\t\t    int treelevel,\n\t\t\t\t\t    int *result);\nSTATIC int xfs_da3_node_toosmall(xfs_da_state_t *state, int *retval);\n\nint\t\t\t\t\t\t\t/* error */\nxfs_da3_node_lookup_int(\n\tstruct xfs_da_state\t*state,\n\tint\t\t\t*result)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_blkinfo\t*curr;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\tstruct xfs_da_args\t*args;\n\txfs_dablk_t\t\tblkno;\n\txfs_dahash_t\t\thashval;\n\txfs_dahash_t\t\tbtreehashval;\n\tint\t\t\tprobe;\n\tint\t\t\tspan;\n\tint\t\t\tmax;\n\tint\t\t\terror;\n\tint\t\t\tretval;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\targs = state->args;\n\n\t/*\n\t * Descend thru the B-tree searching each level for the right\n\t * node to use, until the right hashval is found.\n\t */\n\tblkno = (args->whichfork == XFS_DATA_FORK)? args->geo->leafblk : 0;\n\tfor (blk = &state->path.blk[0], state->path.active = 1;\n\t\t\t state->path.active <= XFS_DA_NODE_MAXDEPTH;\n\t\t\t blk++, state->path.active++) {\n\t\t/*\n\t\t * Read the next node down in the tree.\n\t\t */\n\t\tblk->blkno = blkno;\n\t\terror = xfs_da3_node_read(args->trans, args->dp, blkno,\n\t\t\t\t\t-1, &blk->bp, args->whichfork);\n\t\tif (error) {\n\t\t\tblk->blkno = 0;\n\t\t\tstate->path.active--;\n\t\t\treturn error;\n\t\t}\n\t\tcurr = blk->bp->b_addr;\n\t\tblk->magic = be16_to_cpu(curr->magic);\n\n\t\tif (blk->magic == XFS_ATTR_LEAF_MAGIC ||\n\t\t    blk->magic == XFS_ATTR3_LEAF_MAGIC) {\n\t\t\tblk->magic = XFS_ATTR_LEAF_MAGIC;\n\t\t\tblk->hashval = xfs_attr_leaf_lasthash(blk->bp, NULL);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (blk->magic == XFS_DIR2_LEAFN_MAGIC ||\n\t\t    blk->magic == XFS_DIR3_LEAFN_MAGIC) {\n\t\t\tblk->magic = XFS_DIR2_LEAFN_MAGIC;\n\t\t\tblk->hashval = xfs_dir2_leafn_lasthash(args->dp,\n\t\t\t\t\t\t\t       blk->bp, NULL);\n\t\t\tbreak;\n\t\t}\n\n\t\tblk->magic = XFS_DA_NODE_MAGIC;\n\n\n\t\t/*\n\t\t * Search an intermediate node for a match.\n\t\t */\n\t\tnode = blk->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\tbtree = dp->d_ops->node_tree_p(node);\n\n\t\tmax = nodehdr.count;\n\t\tblk->hashval = be32_to_cpu(btree[max - 1].hashval);\n\n\t\t/*\n\t\t * Binary search.  (note: small blocks will skip loop)\n\t\t */\n\t\tprobe = span = max / 2;\n\t\thashval = args->hashval;\n\t\twhile (span > 4) {\n\t\t\tspan /= 2;\n\t\t\tbtreehashval = be32_to_cpu(btree[probe].hashval);\n\t\t\tif (btreehashval < hashval)\n\t\t\t\tprobe += span;\n\t\t\telse if (btreehashval > hashval)\n\t\t\t\tprobe -= span;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tASSERT((probe >= 0) && (probe < max));\n\t\tASSERT((span <= 4) ||\n\t\t\t(be32_to_cpu(btree[probe].hashval) == hashval));\n\n\t\t/*\n\t\t * Since we may have duplicate hashval's, find the first\n\t\t * matching hashval in the node.\n\t\t */\n\t\twhile (probe > 0 &&\n\t\t       be32_to_cpu(btree[probe].hashval) >= hashval) {\n\t\t\tprobe--;\n\t\t}\n\t\twhile (probe < max &&\n\t\t       be32_to_cpu(btree[probe].hashval) < hashval) {\n\t\t\tprobe++;\n\t\t}\n\n\t\t/*\n\t\t * Pick the right block to descend on.\n\t\t */\n\t\tif (probe == max) {\n\t\t\tblk->index = max - 1;\n\t\t\tblkno = be32_to_cpu(btree[max - 1].before);\n\t\t} else {\n\t\t\tblk->index = probe;\n\t\t\tblkno = be32_to_cpu(btree[probe].before);\n\t\t}\n\t}\n\n\t/*\n\t * A leaf block that ends in the hashval that we are interested in\n\t * (final hashval == search hashval) means that the next block may\n\t * contain more entries with the same hashval, shift upward to the\n\t * next leaf and keep searching.\n\t */\n\tfor (;;) {\n\t\tif (blk->magic == XFS_DIR2_LEAFN_MAGIC) {\n\t\t\tretval = xfs_dir2_leafn_lookup_int(blk->bp, args,\n\t\t\t\t\t\t\t&blk->index, state);\n\t\t} else if (blk->magic == XFS_ATTR_LEAF_MAGIC) {\n\t\t\tretval = xfs_attr3_leaf_lookup_int(blk->bp, args);\n\t\t\tblk->index = args->index;\n\t\t\targs->blkno = blk->blkno;\n\t\t} else {\n\t\t\tASSERT(0);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tif (((retval == -ENOENT) || (retval == -ENOATTR)) &&\n\t\t    (blk->hashval == args->hashval)) {\n\t\t\terror = xfs_da3_path_shift(state, &state->path, 1, 1,\n\t\t\t\t\t\t\t &retval);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (retval == 0) {\n\t\t\t\tcontinue;\n\t\t\t} else if (blk->magic == XFS_ATTR_LEAF_MAGIC) {\n\t\t\t\t/* path_shift() gives ENOENT */\n\t\t\t\tretval = -ENOATTR;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\t*result = retval;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da_state_alloc",
          "args": [],
          "line": 2024
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_state_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "98-102",
          "snippet": "xfs_da_state_t *\nxfs_da_state_alloc(void)\n{\n\treturn kmem_zone_zalloc(xfs_da_state_zone, KM_NOFS);\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t *xfs_da_state_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t *xfs_da_state_zone;\n\nxfs_da_state_t *\nxfs_da_state_alloc(void)\n{\n\treturn kmem_zone_zalloc(xfs_da_state_zone, KM_NOFS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_dir2_node_lookup",
          "args": [
            "args"
          ],
          "line": 2019
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);\nstatic int xfs_dir2_leafn_remove(xfs_da_args_t *args, struct xfs_buf *bp,\n\t\t\t\t int index, xfs_da_state_blk_t *dblk,\n\t\t\t\t int *rval);\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_node_lookup(\n\txfs_da_args_t\t*args)\t\t\t/* operation arguments */\n{\n\tint\t\terror;\t\t\t/* error return value */\n\tint\t\ti;\t\t\t/* btree level */\n\tint\t\trval;\t\t\t/* operation return value */\n\txfs_da_state_t\t*state;\t\t\t/* btree cursor */\n\n\ttrace_xfs_dir2_node_lookup(args);\n\n\t/*\n\t * Allocate and initialize the btree cursor.\n\t */\n\tstate = xfs_da_state_alloc();\n\tstate->args = args;\n\tstate->mp = args->dp->i_mount;\n\t/*\n\t * Fill in the path to the entry in the cursor.\n\t */\n\terror = xfs_da3_node_lookup_int(state, &rval);\n\tif (error)\n\t\trval = error;\n\telse if (rval == -ENOENT && args->cmpresult == XFS_CMP_CASE) {\n\t\t/* If a CI match, dup the actual name and return -EEXIST */\n\t\txfs_dir2_data_entry_t\t*dep;\n\n\t\tdep = (xfs_dir2_data_entry_t *)\n\t\t\t((char *)state->extrablk.bp->b_addr +\n\t\t\t\t\t\t state->extrablk.index);\n\t\trval = xfs_dir_cilookup_result(args, dep->name, dep->namelen);\n\t}\n\t/*\n\t * Release the btree blocks and leaf block.\n\t */\n\tfor (i = 0; i < state->path.active; i++) {\n\t\txfs_trans_brelse(args->trans, state->path.blk[i].bp);\n\t\tstate->path.blk[i].bp = NULL;\n\t}\n\t/*\n\t * Release the data block if we have it.\n\t */\n\tif (state->extravalid && state->extrablk.bp) {\n\t\txfs_trans_brelse(args->trans, state->extrablk.bp);\n\t\tstate->extrablk.bp = NULL;\n\t}\n\txfs_da_state_free(state);\n\treturn rval;\n}"
  },
  {
    "function_name": "xfs_dir2_node_addname_int",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
    "lines": "1637-2003",
    "snippet": "static int\t\t\t\t\t/* error */\nxfs_dir2_node_addname_int(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\txfs_da_state_blk_t\t*fblk)\t\t/* optional freespace block */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_db_t\t\tdbno;\t\t/* data block number */\n\tstruct xfs_buf\t\t*dbp;\t\t/* data block buffer */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry pointer */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* data unused entry pointer */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_dir2_db_t\t\tfbno;\t\t/* freespace block number */\n\tstruct xfs_buf\t\t*fbp;\t\t/* freespace buffer */\n\tint\t\t\tfindex;\t\t/* freespace entry index */\n\txfs_dir2_free_t\t\t*free=NULL;\t/* freespace block structure */\n\txfs_dir2_db_t\t\tifbno;\t\t/* initial freespace block no */\n\txfs_dir2_db_t\t\tlastfbno=0;\t/* highest freespace block no */\n\tint\t\t\tlength;\t\t/* length of the new entry */\n\tint\t\t\tlogfree;\t/* need to log free entry */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tint\t\t\tneedlog;\t/* need to log data header */\n\tint\t\t\tneedscan;\t/* need to rescan data frees */\n\t__be16\t\t\t*tagp;\t\t/* data entry tag pointer */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\t__be16\t\t\t*bests;\n\tstruct xfs_dir3_icfree_hdr freehdr;\n\tstruct xfs_dir2_data_free *bf;\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\ttp = args->trans;\n\tlength = dp->d_ops->data_entsize(args->namelen);\n\t/*\n\t * If we came in with a freespace block that means that lookup\n\t * found an entry with our hash value.  This is the freespace\n\t * block for that data entry.\n\t */\n\tif (fblk) {\n\t\tfbp = fblk->bp;\n\t\t/*\n\t\t * Remember initial freespace block number.\n\t\t */\n\t\tifbno = fblk->blkno;\n\t\tfree = fbp->b_addr;\n\t\tfindex = fblk->index;\n\t\tbests = dp->d_ops->free_bests_p(free);\n\t\tdp->d_ops->free_hdr_from_disk(&freehdr, free);\n\n\t\t/*\n\t\t * This means the free entry showed that the data block had\n\t\t * space for our entry, so we remembered it.\n\t\t * Use that data block.\n\t\t */\n\t\tif (findex >= 0) {\n\t\t\tASSERT(findex < freehdr.nvalid);\n\t\t\tASSERT(be16_to_cpu(bests[findex]) != NULLDATAOFF);\n\t\t\tASSERT(be16_to_cpu(bests[findex]) >= length);\n\t\t\tdbno = freehdr.firstdb + findex;\n\t\t} else {\n\t\t\t/*\n\t\t\t * The data block looked at didn't have enough room.\n\t\t\t * We'll start at the beginning of the freespace entries.\n\t\t\t */\n\t\t\tdbno = -1;\n\t\t\tfindex = 0;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Didn't come in with a freespace block, so no data block.\n\t\t */\n\t\tifbno = dbno = -1;\n\t\tfbp = NULL;\n\t\tfindex = 0;\n\t}\n\n\t/*\n\t * If we don't have a data block yet, we're going to scan the\n\t * freespace blocks looking for one.  Figure out what the\n\t * highest freespace block number is.\n\t */\n\tif (dbno == -1) {\n\t\txfs_fileoff_t\tfo;\t\t/* freespace block number */\n\n\t\tif ((error = xfs_bmap_last_offset(dp, &fo, XFS_DATA_FORK)))\n\t\t\treturn error;\n\t\tlastfbno = xfs_dir2_da_to_db(args->geo, (xfs_dablk_t)fo);\n\t\tfbno = ifbno;\n\t}\n\t/*\n\t * While we haven't identified a data block, search the freeblock\n\t * data for a good data block.  If we find a null freeblock entry,\n\t * indicating a hole in the data blocks, remember that.\n\t */\n\twhile (dbno == -1) {\n\t\t/*\n\t\t * If we don't have a freeblock in hand, get the next one.\n\t\t */\n\t\tif (fbp == NULL) {\n\t\t\t/*\n\t\t\t * Happens the first time through unless lookup gave\n\t\t\t * us a freespace block to start with.\n\t\t\t */\n\t\t\tif (++fbno == 0)\n\t\t\t\tfbno = xfs_dir2_byte_to_db(args->geo,\n\t\t\t\t\t\t\tXFS_DIR2_FREE_OFFSET);\n\t\t\t/*\n\t\t\t * If it's ifbno we already looked at it.\n\t\t\t */\n\t\t\tif (fbno == ifbno)\n\t\t\t\tfbno++;\n\t\t\t/*\n\t\t\t * If it's off the end we're done.\n\t\t\t */\n\t\t\tif (fbno >= lastfbno)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * Read the block.  There can be holes in the\n\t\t\t * freespace blocks, so this might not succeed.\n\t\t\t * This should be really rare, so there's no reason\n\t\t\t * to avoid it.\n\t\t\t */\n\t\t\terror = xfs_dir2_free_try_read(tp, dp,\n\t\t\t\t\txfs_dir2_db_to_da(args->geo, fbno),\n\t\t\t\t\t&fbp);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (!fbp)\n\t\t\t\tcontinue;\n\t\t\tfree = fbp->b_addr;\n\t\t\tfindex = 0;\n\t\t}\n\t\t/*\n\t\t * Look at the current free entry.  Is it good enough?\n\t\t *\n\t\t * The bests initialisation should be where the bufer is read in\n\t\t * the above branch. But gcc is too stupid to realise that bests\n\t\t * and the freehdr are actually initialised if they are placed\n\t\t * there, so we have to do it here to avoid warnings. Blech.\n\t\t */\n\t\tbests = dp->d_ops->free_bests_p(free);\n\t\tdp->d_ops->free_hdr_from_disk(&freehdr, free);\n\t\tif (be16_to_cpu(bests[findex]) != NULLDATAOFF &&\n\t\t    be16_to_cpu(bests[findex]) >= length)\n\t\t\tdbno = freehdr.firstdb + findex;\n\t\telse {\n\t\t\t/*\n\t\t\t * Are we done with the freeblock?\n\t\t\t */\n\t\t\tif (++findex == freehdr.nvalid) {\n\t\t\t\t/*\n\t\t\t\t * Drop the block.\n\t\t\t\t */\n\t\t\t\txfs_trans_brelse(tp, fbp);\n\t\t\t\tfbp = NULL;\n\t\t\t\tif (fblk && fblk->bp)\n\t\t\t\t\tfblk->bp = NULL;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * If we don't have a data block, we need to allocate one and make\n\t * the freespace entries refer to it.\n\t */\n\tif (unlikely(dbno == -1)) {\n\t\t/*\n\t\t * Not allowed to allocate, return failure.\n\t\t */\n\t\tif ((args->op_flags & XFS_DA_OP_JUSTCHECK) || args->total == 0)\n\t\t\treturn -ENOSPC;\n\n\t\t/*\n\t\t * Allocate and initialize the new data block.\n\t\t */\n\t\tif (unlikely((error = xfs_dir2_grow_inode(args,\n\t\t\t\t\t\t\t XFS_DIR2_DATA_SPACE,\n\t\t\t\t\t\t\t &dbno)) ||\n\t\t    (error = xfs_dir3_data_init(args, dbno, &dbp))))\n\t\t\treturn error;\n\n\t\t/*\n\t\t * If (somehow) we have a freespace block, get rid of it.\n\t\t */\n\t\tif (fbp)\n\t\t\txfs_trans_brelse(tp, fbp);\n\t\tif (fblk && fblk->bp)\n\t\t\tfblk->bp = NULL;\n\n\t\t/*\n\t\t * Get the freespace block corresponding to the data block\n\t\t * that was just allocated.\n\t\t */\n\t\tfbno = dp->d_ops->db_to_fdb(args->geo, dbno);\n\t\terror = xfs_dir2_free_try_read(tp, dp,\n\t\t\t\t       xfs_dir2_db_to_da(args->geo, fbno),\n\t\t\t\t       &fbp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/*\n\t\t * If there wasn't a freespace block, the read will\n\t\t * return a NULL fbp.  Allocate and initialize a new one.\n\t\t */\n\t\tif (!fbp) {\n\t\t\terror = xfs_dir2_grow_inode(args, XFS_DIR2_FREE_SPACE,\n\t\t\t\t\t\t    &fbno);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\tif (dp->d_ops->db_to_fdb(args->geo, dbno) != fbno) {\n\t\t\t\txfs_alert(mp,\n\t\t\t\"%s: dir ino %llu needed freesp block %lld for\\n\"\n\t\t\t\"  data block %lld, got %lld ifbno %llu lastfbno %d\",\n\t\t\t\t\t__func__, (unsigned long long)dp->i_ino,\n\t\t\t\t\t(long long)dp->d_ops->db_to_fdb(\n\t\t\t\t\t\t\t\targs->geo, dbno),\n\t\t\t\t\t(long long)dbno, (long long)fbno,\n\t\t\t\t\t(unsigned long long)ifbno, lastfbno);\n\t\t\t\tif (fblk) {\n\t\t\t\t\txfs_alert(mp,\n\t\t\t\t\" fblk 0x%p blkno %llu index %d magic 0x%x\",\n\t\t\t\t\t\tfblk,\n\t\t\t\t\t\t(unsigned long long)fblk->blkno,\n\t\t\t\t\t\tfblk->index,\n\t\t\t\t\t\tfblk->magic);\n\t\t\t\t} else {\n\t\t\t\t\txfs_alert(mp, \" ... fblk is NULL\");\n\t\t\t\t}\n\t\t\t\tXFS_ERROR_REPORT(\"xfs_dir2_node_addname_int\",\n\t\t\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\t\t\treturn -EFSCORRUPTED;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Get a buffer for the new block.\n\t\t\t */\n\t\t\terror = xfs_dir3_free_get_buf(args, fbno, &fbp);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tfree = fbp->b_addr;\n\t\t\tbests = dp->d_ops->free_bests_p(free);\n\t\t\tdp->d_ops->free_hdr_from_disk(&freehdr, free);\n\n\t\t\t/*\n\t\t\t * Remember the first slot as our empty slot.\n\t\t\t */\n\t\t\tfreehdr.firstdb =\n\t\t\t\t(fbno - xfs_dir2_byte_to_db(args->geo,\n\t\t\t\t\t\t\tXFS_DIR2_FREE_OFFSET)) *\n\t\t\t\t\tdp->d_ops->free_max_bests(args->geo);\n\t\t} else {\n\t\t\tfree = fbp->b_addr;\n\t\t\tbests = dp->d_ops->free_bests_p(free);\n\t\t\tdp->d_ops->free_hdr_from_disk(&freehdr, free);\n\t\t}\n\n\t\t/*\n\t\t * Set the freespace block index from the data block number.\n\t\t */\n\t\tfindex = dp->d_ops->db_to_fdindex(args->geo, dbno);\n\t\t/*\n\t\t * If it's after the end of the current entries in the\n\t\t * freespace block, extend that table.\n\t\t */\n\t\tif (findex >= freehdr.nvalid) {\n\t\t\tASSERT(findex < dp->d_ops->free_max_bests(args->geo));\n\t\t\tfreehdr.nvalid = findex + 1;\n\t\t\t/*\n\t\t\t * Tag new entry so nused will go up.\n\t\t\t */\n\t\t\tbests[findex] = cpu_to_be16(NULLDATAOFF);\n\t\t}\n\t\t/*\n\t\t * If this entry was for an empty data block\n\t\t * (this should always be true) then update the header.\n\t\t */\n\t\tif (bests[findex] == cpu_to_be16(NULLDATAOFF)) {\n\t\t\tfreehdr.nused++;\n\t\t\tdp->d_ops->free_hdr_to_disk(fbp->b_addr, &freehdr);\n\t\t\txfs_dir2_free_log_header(args, fbp);\n\t\t}\n\t\t/*\n\t\t * Update the real value in the table.\n\t\t * We haven't allocated the data entry yet so this will\n\t\t * change again.\n\t\t */\n\t\thdr = dbp->b_addr;\n\t\tbf = dp->d_ops->data_bestfree_p(hdr);\n\t\tbests[findex] = bf[0].length;\n\t\tlogfree = 1;\n\t}\n\t/*\n\t * We had a data block so we don't have to make a new one.\n\t */\n\telse {\n\t\t/*\n\t\t * If just checking, we succeeded.\n\t\t */\n\t\tif (args->op_flags & XFS_DA_OP_JUSTCHECK)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * Read the data block in.\n\t\t */\n\t\terror = xfs_dir3_data_read(tp, dp,\n\t\t\t\t\t   xfs_dir2_db_to_da(args->geo, dbno),\n\t\t\t\t\t   -1, &dbp);\n\t\tif (error)\n\t\t\treturn error;\n\t\thdr = dbp->b_addr;\n\t\tbf = dp->d_ops->data_bestfree_p(hdr);\n\t\tlogfree = 0;\n\t}\n\tASSERT(be16_to_cpu(bf[0].length) >= length);\n\t/*\n\t * Point to the existing unused space.\n\t */\n\tdup = (xfs_dir2_data_unused_t *)\n\t      ((char *)hdr + be16_to_cpu(bf[0].offset));\n\tneedscan = needlog = 0;\n\t/*\n\t * Mark the first part of the unused space, inuse for us.\n\t */\n\txfs_dir2_data_use_free(args, dbp, dup,\n\t\t(xfs_dir2_data_aoff_t)((char *)dup - (char *)hdr), length,\n\t\t&needlog, &needscan);\n\t/*\n\t * Fill in the new entry and log it.\n\t */\n\tdep = (xfs_dir2_data_entry_t *)dup;\n\tdep->inumber = cpu_to_be64(args->inumber);\n\tdep->namelen = args->namelen;\n\tmemcpy(dep->name, args->name, dep->namelen);\n\tdp->d_ops->data_put_ftype(dep, args->filetype);\n\ttagp = dp->d_ops->data_entry_tag_p(dep);\n\t*tagp = cpu_to_be16((char *)dep - (char *)hdr);\n\txfs_dir2_data_log_entry(args, dbp, dep);\n\t/*\n\t * Rescan the block for bestfree if needed.\n\t */\n\tif (needscan)\n\t\txfs_dir2_data_freescan(dp, hdr, &needlog);\n\t/*\n\t * Log the data block header if needed.\n\t */\n\tif (needlog)\n\t\txfs_dir2_data_log_header(args, dbp);\n\t/*\n\t * If the freespace entry is now wrong, update it.\n\t */\n\tbests = dp->d_ops->free_bests_p(free); /* gcc is so stupid */\n\tif (be16_to_cpu(bests[findex]) != be16_to_cpu(bf[0].length)) {\n\t\tbests[findex] = bf[0].length;\n\t\tlogfree = 1;\n\t}\n\t/*\n\t * Log the freespace entry if needed.\n\t */\n\tif (logfree)\n\t\txfs_dir2_free_log_bests(args, fbp, findex, findex);\n\t/*\n\t * Return the data block and offset in args, then drop the data block.\n\t */\n\targs->blkno = (xfs_dablk_t)dbno;\n\targs->index = be16_to_cpu(*tagp);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);",
      "static int xfs_dir2_node_addname_int(xfs_da_args_t *args,\n\t\t\t\t     xfs_da_state_blk_t *fblk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "*tagp"
          ],
          "line": 2001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_free_log_bests",
          "args": [
            "args",
            "fbp",
            "findex",
            "findex"
          ],
          "line": 1996
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_free_log_bests",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
          "lines": "240-258",
          "snippet": "STATIC void\nxfs_dir2_free_log_bests(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\t\t/* first entry to log */\n\tint\t\t\tlast)\t\t/* last entry to log */\n{\n\txfs_dir2_free_t\t\t*free;\t\t/* freespace structure */\n\t__be16\t\t\t*bests;\n\n\tfree = bp->b_addr;\n\tbests = args->dp->d_ops->free_bests_p(free);\n\tASSERT(free->hdr.magic == cpu_to_be32(XFS_DIR2_FREE_MAGIC) ||\n\t       free->hdr.magic == cpu_to_be32(XFS_DIR3_FREE_MAGIC));\n\txfs_trans_log_buf(args->trans, bp,\n\t\t(uint)((char *)&bests[first] - (char *)free),\n\t\t(uint)((char *)&bests[last] - (char *)free +\n\t\t       sizeof(bests[0]) - 1));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_dir2_free_log_bests(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\t\t/* first entry to log */\n\tint\t\t\tlast)\t\t/* last entry to log */\n{\n\txfs_dir2_free_t\t\t*free;\t\t/* freespace structure */\n\t__be16\t\t\t*bests;\n\n\tfree = bp->b_addr;\n\tbests = args->dp->d_ops->free_bests_p(free);\n\tASSERT(free->hdr.magic == cpu_to_be32(XFS_DIR2_FREE_MAGIC) ||\n\t       free->hdr.magic == cpu_to_be32(XFS_DIR3_FREE_MAGIC));\n\txfs_trans_log_buf(args->trans, bp,\n\t\t(uint)((char *)&bests[first] - (char *)free),\n\t\t(uint)((char *)&bests[last] - (char *)free +\n\t\t       sizeof(bests[0]) - 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "bf[0].length"
          ],
          "line": 1988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "bests[findex]"
          ],
          "line": 1988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->free_bests_p",
          "args": [
            "free"
          ],
          "line": 1987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_log_header",
          "args": [
            "args",
            "dbp"
          ],
          "line": 1983
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_log_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "661-677",
          "snippet": "void\nxfs_dir2_data_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n#ifdef DEBUG\n\tstruct xfs_dir2_data_hdr *hdr = bp->b_addr;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n#endif\n\n\txfs_trans_log_buf(args->trans, bp, 0,\n\t\t\t  args->dp->d_ops->data_entry_offset - 1);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dir2_data_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n#ifdef DEBUG\n\tstruct xfs_dir2_data_hdr *hdr = bp->b_addr;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n#endif\n\n\txfs_trans_log_buf(args->trans, bp, 0,\n\t\t\t  args->dp->d_ops->data_entry_offset - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_freescan",
          "args": [
            "dp",
            "hdr",
            "&needlog"
          ],
          "line": 1978
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_freescan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "500-559",
          "snippet": "void\nxfs_dir2_data_freescan(\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_dir2_data_hdr *hdr,\n\tint\t\t\t*loghead)\n{\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* active data entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused data entry */\n\tstruct xfs_dir2_data_free *bf;\n\tchar\t\t\t*endp;\t\t/* end of block's data */\n\tchar\t\t\t*p;\t\t/* current entry pointer */\n\tstruct xfs_da_geometry\t*geo = dp->i_mount->m_dir_geo;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\t/*\n\t * Start by clearing the table.\n\t */\n\tbf = dp->d_ops->data_bestfree_p(hdr);\n\tmemset(bf, 0, sizeof(*bf) * XFS_DIR2_DATA_FD_COUNT);\n\t*loghead = 1;\n\t/*\n\t * Set up pointers.\n\t */\n\tp = (char *)dp->d_ops->data_entry_p(hdr);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tendp = (char *)xfs_dir2_block_leaf_p(btp);\n\t} else\n\t\tendp = (char *)hdr + geo->blksize;\n\t/*\n\t * Loop over the block's entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's a free entry, insert it.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tASSERT((char *)dup - (char *)hdr ==\n\t\t\t       be16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)));\n\t\t\txfs_dir2_data_freeinsert(hdr, bf, dup, loghead);\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t}\n\t\t/*\n\t\t * For active entries, check their tags and skip them.\n\t\t */\n\t\telse {\n\t\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\t\tASSERT((char *)dep - (char *)hdr ==\n\t\t\t       be16_to_cpu(*dp->d_ops->data_entry_tag_p(dep)));\n\t\t\tp += dp->d_ops->data_entsize(dep->namelen);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dir2_data_freescan(\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_dir2_data_hdr *hdr,\n\tint\t\t\t*loghead)\n{\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* active data entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused data entry */\n\tstruct xfs_dir2_data_free *bf;\n\tchar\t\t\t*endp;\t\t/* end of block's data */\n\tchar\t\t\t*p;\t\t/* current entry pointer */\n\tstruct xfs_da_geometry\t*geo = dp->i_mount->m_dir_geo;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\t/*\n\t * Start by clearing the table.\n\t */\n\tbf = dp->d_ops->data_bestfree_p(hdr);\n\tmemset(bf, 0, sizeof(*bf) * XFS_DIR2_DATA_FD_COUNT);\n\t*loghead = 1;\n\t/*\n\t * Set up pointers.\n\t */\n\tp = (char *)dp->d_ops->data_entry_p(hdr);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tendp = (char *)xfs_dir2_block_leaf_p(btp);\n\t} else\n\t\tendp = (char *)hdr + geo->blksize;\n\t/*\n\t * Loop over the block's entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's a free entry, insert it.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tASSERT((char *)dup - (char *)hdr ==\n\t\t\t       be16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)));\n\t\t\txfs_dir2_data_freeinsert(hdr, bf, dup, loghead);\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t}\n\t\t/*\n\t\t * For active entries, check their tags and skip them.\n\t\t */\n\t\telse {\n\t\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\t\tASSERT((char *)dep - (char *)hdr ==\n\t\t\t       be16_to_cpu(*dp->d_ops->data_entry_tag_p(dep)));\n\t\t\tp += dp->d_ops->data_entsize(dep->namelen);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_log_entry",
          "args": [
            "args",
            "dbp",
            "dep"
          ],
          "line": 1973
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_log_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "640-656",
          "snippet": "void\nxfs_dir2_data_log_entry(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_entry_t\t*dep)\t\t/* data entry pointer */\n{\n\tstruct xfs_dir2_data_hdr *hdr = bp->b_addr;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\txfs_trans_log_buf(args->trans, bp, (uint)((char *)dep - (char *)hdr),\n\t\t(uint)((char *)(args->dp->d_ops->data_entry_tag_p(dep) + 1) -\n\t\t       (char *)hdr - 1));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dir2_data_log_entry(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_entry_t\t*dep)\t\t/* data entry pointer */\n{\n\tstruct xfs_dir2_data_hdr *hdr = bp->b_addr;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\txfs_trans_log_buf(args->trans, bp, (uint)((char *)dep - (char *)hdr),\n\t\t(uint)((char *)(args->dp->d_ops->data_entry_tag_p(dep) + 1) -\n\t\t       (char *)hdr - 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "(char *)dep - (char *)hdr"
          ],
          "line": 1972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_entry_tag_p",
          "args": [
            "dep"
          ],
          "line": 1971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_put_ftype",
          "args": [
            "dep",
            "args->filetype"
          ],
          "line": 1970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dep->name",
            "args->name",
            "dep->namelen"
          ],
          "line": 1969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "args->inumber"
          ],
          "line": 1967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_use_free",
          "args": [
            "args",
            "dbp",
            "dup",
            "(xfs_dir2_data_aoff_t)((char *)dup - (char *)hdr)",
            "length",
            "&needlog",
            "&needscan"
          ],
          "line": 1960
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_use_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "899-1048",
          "snippet": "void\nxfs_dir2_data_use_free(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_unused_t\t*dup,\t\t/* unused entry */\n\txfs_dir2_data_aoff_t\toffset,\t\t/* starting offset to use */\n\txfs_dir2_data_aoff_t\tlen,\t\t/* length to use */\n\tint\t\t\t*needlogp,\t/* out: need to log header */\n\tint\t\t\t*needscanp)\t/* out: need regen bestfree */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree pointer */\n\tint\t\t\tmatchback;\t/* matches end of freespace */\n\tint\t\t\tmatchfront;\t/* matches start of freespace */\n\tint\t\t\tneedscan;\t/* need to regen bestfree */\n\txfs_dir2_data_unused_t\t*newdup;\t/* new unused entry */\n\txfs_dir2_data_unused_t\t*newdup2;\t/* another new unused entry */\n\tint\t\t\toldlen;\t\t/* old unused entry's length */\n\tstruct xfs_dir2_data_free *bf;\n\n\thdr = bp->b_addr;\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\tASSERT(be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG);\n\tASSERT(offset >= (char *)dup - (char *)hdr);\n\tASSERT(offset + len <= (char *)dup + be16_to_cpu(dup->length) - (char *)hdr);\n\tASSERT((char *)dup - (char *)hdr == be16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)));\n\t/*\n\t * Look up the entry in the bestfree table.\n\t */\n\toldlen = be16_to_cpu(dup->length);\n\tbf = args->dp->d_ops->data_bestfree_p(hdr);\n\tdfp = xfs_dir2_data_freefind(hdr, bf, dup);\n\tASSERT(dfp || oldlen <= be16_to_cpu(bf[2].length));\n\t/*\n\t * Check for alignment with front and back of the entry.\n\t */\n\tmatchfront = (char *)dup - (char *)hdr == offset;\n\tmatchback = (char *)dup + oldlen - (char *)hdr == offset + len;\n\tASSERT(*needscanp == 0);\n\tneedscan = 0;\n\t/*\n\t * If we matched it exactly we just need to get rid of it from\n\t * the bestfree table.\n\t */\n\tif (matchfront && matchback) {\n\t\tif (dfp) {\n\t\t\tneedscan = (bf[2].offset != 0);\n\t\t\tif (!needscan)\n\t\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp,\n\t\t\t\t\t\t\t needlogp);\n\t\t}\n\t}\n\t/*\n\t * We match the first part of the entry.\n\t * Make a new entry with the remaining freespace.\n\t */\n\telse if (matchfront) {\n\t\tnewdup = (xfs_dir2_data_unused_t *)((char *)hdr + offset + len);\n\t\tnewdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup->length = cpu_to_be16(oldlen - len);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\t/*\n\t\t * If it was in the table, remove it and add the new one.\n\t\t */\n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\tdfp = xfs_dir2_data_freeinsert(hdr, bf, newdup,\n\t\t\t\t\t\t       needlogp);\n\t\t\tASSERT(dfp != NULL);\n\t\t\tASSERT(dfp->length == newdup->length);\n\t\t\tASSERT(be16_to_cpu(dfp->offset) == (char *)newdup - (char *)hdr);\n\t\t\t/*\n\t\t\t * If we got inserted at the last slot,\n\t\t\t * that means we don't know if there was a better\n\t\t\t * choice for the last slot, or not.  Rescan.\n\t\t\t */\n\t\t\tneedscan = dfp == &bf[2];\n\t\t}\n\t}\n\t/*\n\t * We match the last part of the entry.\n\t * Trim the allocated space off the tail of the entry.\n\t */\n\telse if (matchback) {\n\t\tnewdup = dup;\n\t\tnewdup->length = cpu_to_be16(((char *)hdr + offset) - (char *)newdup);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\t/*\n\t\t * If it was in the table, remove it and add the new one.\n\t\t */\n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\tdfp = xfs_dir2_data_freeinsert(hdr, bf, newdup,\n\t\t\t\t\t\t       needlogp);\n\t\t\tASSERT(dfp != NULL);\n\t\t\tASSERT(dfp->length == newdup->length);\n\t\t\tASSERT(be16_to_cpu(dfp->offset) == (char *)newdup - (char *)hdr);\n\t\t\t/*\n\t\t\t * If we got inserted at the last slot,\n\t\t\t * that means we don't know if there was a better\n\t\t\t * choice for the last slot, or not.  Rescan.\n\t\t\t */\n\t\t\tneedscan = dfp == &bf[2];\n\t\t}\n\t}\n\t/*\n\t * Poking out the middle of an entry.\n\t * Make two new entries.\n\t */\n\telse {\n\t\tnewdup = dup;\n\t\tnewdup->length = cpu_to_be16(((char *)hdr + offset) - (char *)newdup);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\tnewdup2 = (xfs_dir2_data_unused_t *)((char *)hdr + offset + len);\n\t\tnewdup2->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup2->length = cpu_to_be16(oldlen - len - be16_to_cpu(newdup->length));\n\t\t*xfs_dir2_data_unused_tag_p(newdup2) =\n\t\t\tcpu_to_be16((char *)newdup2 - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup2);\n\t\t/*\n\t\t * If the old entry was in the table, we need to scan\n\t\t * if the 3rd entry was valid, since these entries\n\t\t * are smaller than the old one.\n\t\t * If we don't need to scan that means there were 1 or 2\n\t\t * entries in the table, and removing the old and adding\n\t\t * the 2 new will work.\n\t\t */\n\t\tif (dfp) {\n\t\t\tneedscan = (bf[2].length != 0);\n\t\t\tif (!needscan) {\n\t\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp,\n\t\t\t\t\t\t\t needlogp);\n\t\t\t\txfs_dir2_data_freeinsert(hdr, bf, newdup,\n\t\t\t\t\t\t\t needlogp);\n\t\t\t\txfs_dir2_data_freeinsert(hdr, bf, newdup2,\n\t\t\t\t\t\t\t needlogp);\n\t\t\t}\n\t\t}\n\t}\n\t*needscanp = needscan;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dir2_data_use_free(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_unused_t\t*dup,\t\t/* unused entry */\n\txfs_dir2_data_aoff_t\toffset,\t\t/* starting offset to use */\n\txfs_dir2_data_aoff_t\tlen,\t\t/* length to use */\n\tint\t\t\t*needlogp,\t/* out: need to log header */\n\tint\t\t\t*needscanp)\t/* out: need regen bestfree */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree pointer */\n\tint\t\t\tmatchback;\t/* matches end of freespace */\n\tint\t\t\tmatchfront;\t/* matches start of freespace */\n\tint\t\t\tneedscan;\t/* need to regen bestfree */\n\txfs_dir2_data_unused_t\t*newdup;\t/* new unused entry */\n\txfs_dir2_data_unused_t\t*newdup2;\t/* another new unused entry */\n\tint\t\t\toldlen;\t\t/* old unused entry's length */\n\tstruct xfs_dir2_data_free *bf;\n\n\thdr = bp->b_addr;\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\tASSERT(be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG);\n\tASSERT(offset >= (char *)dup - (char *)hdr);\n\tASSERT(offset + len <= (char *)dup + be16_to_cpu(dup->length) - (char *)hdr);\n\tASSERT((char *)dup - (char *)hdr == be16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)));\n\t/*\n\t * Look up the entry in the bestfree table.\n\t */\n\toldlen = be16_to_cpu(dup->length);\n\tbf = args->dp->d_ops->data_bestfree_p(hdr);\n\tdfp = xfs_dir2_data_freefind(hdr, bf, dup);\n\tASSERT(dfp || oldlen <= be16_to_cpu(bf[2].length));\n\t/*\n\t * Check for alignment with front and back of the entry.\n\t */\n\tmatchfront = (char *)dup - (char *)hdr == offset;\n\tmatchback = (char *)dup + oldlen - (char *)hdr == offset + len;\n\tASSERT(*needscanp == 0);\n\tneedscan = 0;\n\t/*\n\t * If we matched it exactly we just need to get rid of it from\n\t * the bestfree table.\n\t */\n\tif (matchfront && matchback) {\n\t\tif (dfp) {\n\t\t\tneedscan = (bf[2].offset != 0);\n\t\t\tif (!needscan)\n\t\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp,\n\t\t\t\t\t\t\t needlogp);\n\t\t}\n\t}\n\t/*\n\t * We match the first part of the entry.\n\t * Make a new entry with the remaining freespace.\n\t */\n\telse if (matchfront) {\n\t\tnewdup = (xfs_dir2_data_unused_t *)((char *)hdr + offset + len);\n\t\tnewdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup->length = cpu_to_be16(oldlen - len);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\t/*\n\t\t * If it was in the table, remove it and add the new one.\n\t\t */\n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\tdfp = xfs_dir2_data_freeinsert(hdr, bf, newdup,\n\t\t\t\t\t\t       needlogp);\n\t\t\tASSERT(dfp != NULL);\n\t\t\tASSERT(dfp->length == newdup->length);\n\t\t\tASSERT(be16_to_cpu(dfp->offset) == (char *)newdup - (char *)hdr);\n\t\t\t/*\n\t\t\t * If we got inserted at the last slot,\n\t\t\t * that means we don't know if there was a better\n\t\t\t * choice for the last slot, or not.  Rescan.\n\t\t\t */\n\t\t\tneedscan = dfp == &bf[2];\n\t\t}\n\t}\n\t/*\n\t * We match the last part of the entry.\n\t * Trim the allocated space off the tail of the entry.\n\t */\n\telse if (matchback) {\n\t\tnewdup = dup;\n\t\tnewdup->length = cpu_to_be16(((char *)hdr + offset) - (char *)newdup);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\t/*\n\t\t * If it was in the table, remove it and add the new one.\n\t\t */\n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\tdfp = xfs_dir2_data_freeinsert(hdr, bf, newdup,\n\t\t\t\t\t\t       needlogp);\n\t\t\tASSERT(dfp != NULL);\n\t\t\tASSERT(dfp->length == newdup->length);\n\t\t\tASSERT(be16_to_cpu(dfp->offset) == (char *)newdup - (char *)hdr);\n\t\t\t/*\n\t\t\t * If we got inserted at the last slot,\n\t\t\t * that means we don't know if there was a better\n\t\t\t * choice for the last slot, or not.  Rescan.\n\t\t\t */\n\t\t\tneedscan = dfp == &bf[2];\n\t\t}\n\t}\n\t/*\n\t * Poking out the middle of an entry.\n\t * Make two new entries.\n\t */\n\telse {\n\t\tnewdup = dup;\n\t\tnewdup->length = cpu_to_be16(((char *)hdr + offset) - (char *)newdup);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\tnewdup2 = (xfs_dir2_data_unused_t *)((char *)hdr + offset + len);\n\t\tnewdup2->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup2->length = cpu_to_be16(oldlen - len - be16_to_cpu(newdup->length));\n\t\t*xfs_dir2_data_unused_tag_p(newdup2) =\n\t\t\tcpu_to_be16((char *)newdup2 - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup2);\n\t\t/*\n\t\t * If the old entry was in the table, we need to scan\n\t\t * if the 3rd entry was valid, since these entries\n\t\t * are smaller than the old one.\n\t\t * If we don't need to scan that means there were 1 or 2\n\t\t * entries in the table, and removing the old and adding\n\t\t * the 2 new will work.\n\t\t */\n\t\tif (dfp) {\n\t\t\tneedscan = (bf[2].length != 0);\n\t\t\tif (!needscan) {\n\t\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp,\n\t\t\t\t\t\t\t needlogp);\n\t\t\t\txfs_dir2_data_freeinsert(hdr, bf, newdup,\n\t\t\t\t\t\t\t needlogp);\n\t\t\t\txfs_dir2_data_freeinsert(hdr, bf, newdup2,\n\t\t\t\t\t\t\t needlogp);\n\t\t\t}\n\t\t}\n\t}\n\t*needscanp = needscan;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(char *)dup - (char *)hdr"
          ],
          "line": 1961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "bf[0].offset"
          ],
          "line": 1955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "be16_to_cpu(bf[0].length) >= length"
          ],
          "line": 1950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "bf[0].length"
          ],
          "line": 1950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_bestfree_p",
          "args": [
            "hdr"
          ],
          "line": 1947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_data_read",
          "args": [
            "tp",
            "dp",
            "xfs_dir2_db_to_da(args->geo, dbno)",
            "-1",
            "&dbp"
          ],
          "line": 1941
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_data_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "313-328",
          "snippet": "int\nxfs_dir3_data_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmapped_bno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mapped_bno, bpp,\n\t\t\t\tXFS_DATA_FORK, &xfs_dir3_data_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_DIR_DATA_BUF);\n\treturn err;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_dir3_data_buf_ops = {\n\t.verify_read = xfs_dir3_data_read_verify,\n\t.verify_write = xfs_dir3_data_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_dir3_data_buf_ops = {\n\t.verify_read = xfs_dir3_data_read_verify,\n\t.verify_write = xfs_dir3_data_write_verify,\n};\n\nint\nxfs_dir3_data_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmapped_bno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mapped_bno, bpp,\n\t\t\t\tXFS_DATA_FORK, &xfs_dir3_data_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_DIR_DATA_BUF);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_db_to_da",
          "args": [
            "args->geo",
            "dbno"
          ],
          "line": 1942
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_db_to_da",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "259-263",
          "snippet": "static inline xfs_dablk_t\nxfs_dir2_db_to_da(struct xfs_da_geometry *geo, xfs_dir2_db_t db)\n{\n\treturn (xfs_dablk_t)(db << (geo->blklog - geo->fsblog));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dablk_t\nxfs_dir2_db_to_da(struct xfs_da_geometry *geo, xfs_dir2_db_t db)\n{\n\treturn (xfs_dablk_t)(db << (geo->blklog - geo->fsblog));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_bestfree_p",
          "args": [
            "hdr"
          ],
          "line": 1924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_free_log_header",
          "args": [
            "args",
            "fbp"
          ],
          "line": 1916
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_free_log_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
          "lines": "263-277",
          "snippet": "static void\nxfs_dir2_free_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n#ifdef DEBUG\n\txfs_dir2_free_t\t\t*free;\t\t/* freespace structure */\n\n\tfree = bp->b_addr;\n\tASSERT(free->hdr.magic == cpu_to_be32(XFS_DIR2_FREE_MAGIC) ||\n\t       free->hdr.magic == cpu_to_be32(XFS_DIR3_FREE_MAGIC));\n#endif\n\txfs_trans_log_buf(args->trans, bp, 0,\n\t\t\t  args->dp->d_ops->free_hdr_size - 1);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_dir2_free_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n#ifdef DEBUG\n\txfs_dir2_free_t\t\t*free;\t\t/* freespace structure */\n\n\tfree = bp->b_addr;\n\tASSERT(free->hdr.magic == cpu_to_be32(XFS_DIR2_FREE_MAGIC) ||\n\t       free->hdr.magic == cpu_to_be32(XFS_DIR3_FREE_MAGIC));\n#endif\n\txfs_trans_log_buf(args->trans, bp, 0,\n\t\t\t  args->dp->d_ops->free_hdr_size - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->free_hdr_to_disk",
          "args": [
            "fbp->b_addr",
            "&freehdr"
          ],
          "line": 1915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "NULLDATAOFF"
          ],
          "line": 1913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "NULLDATAOFF"
          ],
          "line": 1907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "findex < dp->d_ops->free_max_bests(args->geo)"
          ],
          "line": 1902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->free_max_bests",
          "args": [
            "args->geo"
          ],
          "line": 1902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->db_to_fdindex",
          "args": [
            "args->geo",
            "dbno"
          ],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->free_hdr_from_disk",
          "args": [
            "&freehdr",
            "free"
          ],
          "line": 1890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->free_bests_p",
          "args": [
            "free"
          ],
          "line": 1889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->free_max_bests",
          "args": [
            "args->geo"
          ],
          "line": 1886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_byte_to_db",
          "args": [
            "args->geo",
            "XFS_DIR2_FREE_OFFSET"
          ],
          "line": 1884
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_byte_to_db",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "213-217",
          "snippet": "static inline xfs_dir2_db_t\nxfs_dir2_byte_to_db(struct xfs_da_geometry *geo, xfs_dir2_off_t by)\n{\n\treturn (xfs_dir2_db_t)(by >> geo->blklog);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_db_t\nxfs_dir2_byte_to_db(struct xfs_da_geometry *geo, xfs_dir2_off_t by)\n{\n\treturn (xfs_dir2_db_t)(by >> geo->blklog);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->free_hdr_from_disk",
          "args": [
            "&freehdr",
            "free"
          ],
          "line": 1878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->free_bests_p",
          "args": [
            "free"
          ],
          "line": 1877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_free_get_buf",
          "args": [
            "args",
            "fbno",
            "&fbp"
          ],
          "line": 1873
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_free_get_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
          "lines": "194-235",
          "snippet": "static int\nxfs_dir3_free_get_buf(\n\txfs_da_args_t\t\t*args,\n\txfs_dir2_db_t\t\tfbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_trans\t*tp = args->trans;\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\tstruct xfs_dir3_icfree_hdr hdr;\n\n\terror = xfs_da_get_buf(tp, dp, xfs_dir2_db_to_da(args->geo, fbno),\n\t\t\t\t   -1, &bp, XFS_DATA_FORK);\n\tif (error)\n\t\treturn error;\n\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DIR_FREE_BUF);\n\tbp->b_ops = &xfs_dir3_free_buf_ops;\n\n\t/*\n\t * Initialize the new block to be empty, and remember\n\t * its first slot as our empty slot.\n\t */\n\tmemset(bp->b_addr, 0, sizeof(struct xfs_dir3_free_hdr));\n\tmemset(&hdr, 0, sizeof(hdr));\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_dir3_free_hdr *hdr3 = bp->b_addr;\n\n\t\thdr.magic = XFS_DIR3_FREE_MAGIC;\n\n\t\thdr3->hdr.blkno = cpu_to_be64(bp->b_bn);\n\t\thdr3->hdr.owner = cpu_to_be64(dp->i_ino);\n\t\tuuid_copy(&hdr3->hdr.uuid, &mp->m_sb.sb_uuid);\n\t} else\n\t\thdr.magic = XFS_DIR2_FREE_MAGIC;\n\tdp->d_ops->free_hdr_to_disk(bp->b_addr, &hdr);\n\t*bpp = bp;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_dir3_free_buf_ops = {\n\t.verify_read = xfs_dir3_free_read_verify,\n\t.verify_write = xfs_dir3_free_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_dir3_free_buf_ops = {\n\t.verify_read = xfs_dir3_free_read_verify,\n\t.verify_write = xfs_dir3_free_write_verify,\n};\n\nstatic int\nxfs_dir3_free_get_buf(\n\txfs_da_args_t\t\t*args,\n\txfs_dir2_db_t\t\tfbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_trans\t*tp = args->trans;\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\tstruct xfs_dir3_icfree_hdr hdr;\n\n\terror = xfs_da_get_buf(tp, dp, xfs_dir2_db_to_da(args->geo, fbno),\n\t\t\t\t   -1, &bp, XFS_DATA_FORK);\n\tif (error)\n\t\treturn error;\n\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DIR_FREE_BUF);\n\tbp->b_ops = &xfs_dir3_free_buf_ops;\n\n\t/*\n\t * Initialize the new block to be empty, and remember\n\t * its first slot as our empty slot.\n\t */\n\tmemset(bp->b_addr, 0, sizeof(struct xfs_dir3_free_hdr));\n\tmemset(&hdr, 0, sizeof(hdr));\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_dir3_free_hdr *hdr3 = bp->b_addr;\n\n\t\thdr.magic = XFS_DIR3_FREE_MAGIC;\n\n\t\thdr3->hdr.blkno = cpu_to_be64(bp->b_bn);\n\t\thdr3->hdr.owner = cpu_to_be64(dp->i_ino);\n\t\tuuid_copy(&hdr3->hdr.uuid, &mp->m_sb.sb_uuid);\n\t} else\n\t\thdr.magic = XFS_DIR2_FREE_MAGIC;\n\tdp->d_ops->free_hdr_to_disk(bp->b_addr, &hdr);\n\t*bpp = bp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_ERROR_REPORT",
          "args": [
            "\"xfs_dir2_node_addname_int\"",
            "XFS_ERRLEVEL_LOW",
            "mp"
          ],
          "line": 1865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alert",
          "args": [
            "mp",
            "\" ... fblk is NULL\""
          ],
          "line": 1863
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alert_fsblock_zero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_iomap.c",
          "lines": "95-110",
          "snippet": "STATIC int\nxfs_alert_fsblock_zero(\n\txfs_inode_t\t*ip,\n\txfs_bmbt_irec_t\t*imap)\n{\n\txfs_alert_tag(ip->i_mount, XFS_PTAG_FSBLOCK_ZERO,\n\t\t\t\"Access to block zero in inode %llu \"\n\t\t\t\"start_block: %llx start_off: %llx \"\n\t\t\t\"blkcnt: %llx extent-state: %x\",\n\t\t(unsigned long long)ip->i_ino,\n\t\t(unsigned long long)imap->br_startblock,\n\t\t(unsigned long long)imap->br_startoff,\n\t\t(unsigned long long)imap->br_blockcount,\n\t\timap->br_state);\n\treturn -EFSCORRUPTED;\n}",
          "includes": [
            "#include \"xfs_dquot.h\"",
            "#include \"xfs_dquot_item.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_iomap.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dquot.h\"\n#include \"xfs_dquot_item.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_iomap.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_alert_fsblock_zero(\n\txfs_inode_t\t*ip,\n\txfs_bmbt_irec_t\t*imap)\n{\n\txfs_alert_tag(ip->i_mount, XFS_PTAG_FSBLOCK_ZERO,\n\t\t\t\"Access to block zero in inode %llu \"\n\t\t\t\"start_block: %llx start_off: %llx \"\n\t\t\t\"blkcnt: %llx extent-state: %x\",\n\t\t(unsigned long long)ip->i_ino,\n\t\t(unsigned long long)imap->br_startblock,\n\t\t(unsigned long long)imap->br_startoff,\n\t\t(unsigned long long)imap->br_blockcount,\n\t\timap->br_state);\n\treturn -EFSCORRUPTED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_alert",
          "args": [
            "mp",
            "\" fblk 0x%p blkno %llu index %d magic 0x%x\"",
            "fblk",
            "(unsigned long long)fblk->blkno",
            "fblk->index",
            "fblk->magic"
          ],
          "line": 1856
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alert_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_message.c",
          "lines": "67-91",
          "snippet": "void\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}",
          "includes": [
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->db_to_fdb",
          "args": [
            "args->geo",
            "dbno"
          ],
          "line": 1851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->db_to_fdb",
          "args": [
            "args->geo",
            "dbno"
          ],
          "line": 1846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_grow_inode",
          "args": [
            "args",
            "XFS_DIR2_FREE_SPACE",
            "&fbno"
          ],
          "line": 1841
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_grow_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
          "lines": "575-614",
          "snippet": "int\nxfs_dir2_grow_inode(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\tspace,\t/* v2 dir's space XFS_DIR2_xxx_SPACE */\n\txfs_dir2_db_t\t\t*dbp)\t/* out: block number added */\n{\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\txfs_fileoff_t\t\tbno;\t/* directory offset of new block */\n\tint\t\t\tcount;\t/* count of filesystem blocks */\n\tint\t\t\terror;\n\n\ttrace_xfs_dir2_grow_inode(args, space);\n\n\t/*\n\t * Set lowest possible block in the space requested.\n\t */\n\tbno = XFS_B_TO_FSBT(mp, space * XFS_DIR2_SPACE_SIZE);\n\tcount = args->geo->fsbcount;\n\n\terror = xfs_da_grow_inode_int(args, &bno, count);\n\tif (error)\n\t\treturn error;\n\n\t*dbp = xfs_dir2_da_to_db(args->geo, (xfs_dablk_t)bno);\n\n\t/*\n\t * Update file's size if this is the data space and it grew.\n\t */\n\tif (space == XFS_DIR2_DATA_SPACE) {\n\t\txfs_fsize_t\tsize;\t\t/* directory file (data) size */\n\n\t\tsize = XFS_FSB_TO_B(mp, bno + count);\n\t\tif (size > dp->i_d.di_size) {\n\t\t\tdp->i_d.di_size = size;\n\t\t\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE);\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir2_grow_inode(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\tspace,\t/* v2 dir's space XFS_DIR2_xxx_SPACE */\n\txfs_dir2_db_t\t\t*dbp)\t/* out: block number added */\n{\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\txfs_fileoff_t\t\tbno;\t/* directory offset of new block */\n\tint\t\t\tcount;\t/* count of filesystem blocks */\n\tint\t\t\terror;\n\n\ttrace_xfs_dir2_grow_inode(args, space);\n\n\t/*\n\t * Set lowest possible block in the space requested.\n\t */\n\tbno = XFS_B_TO_FSBT(mp, space * XFS_DIR2_SPACE_SIZE);\n\tcount = args->geo->fsbcount;\n\n\terror = xfs_da_grow_inode_int(args, &bno, count);\n\tif (error)\n\t\treturn error;\n\n\t*dbp = xfs_dir2_da_to_db(args->geo, (xfs_dablk_t)bno);\n\n\t/*\n\t * Update file's size if this is the data space and it grew.\n\t */\n\tif (space == XFS_DIR2_DATA_SPACE) {\n\t\txfs_fsize_t\tsize;\t\t/* directory file (data) size */\n\n\t\tsize = XFS_FSB_TO_B(mp, bno + count);\n\t\tif (size > dp->i_d.di_size) {\n\t\t\tdp->i_d.di_size = size;\n\t\t\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE);\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_free_try_read",
          "args": [
            "tp",
            "dp",
            "xfs_dir2_db_to_da(args->geo, fbno)",
            "&fbp"
          ],
          "line": 1830
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_free_try_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
          "lines": "184-192",
          "snippet": "static int\nxfs_dir2_free_try_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tfbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\treturn __xfs_dir3_free_read(tp, dp, fbno, -2, bpp);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int\nxfs_dir2_free_try_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tfbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\treturn __xfs_dir3_free_read(tp, dp, fbno, -2, bpp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->db_to_fdb",
          "args": [
            "args->geo",
            "dbno"
          ],
          "line": 1829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "tp",
            "fbp"
          ],
          "line": 1821
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(error = xfs_dir2_grow_inode(args,\n\t\t\t\t\t\t\t XFS_DIR2_DATA_SPACE,\n\t\t\t\t\t\t\t &dbno)) ||\n\t\t    (error = xfs_dir3_data_init(args, dbno, &dbp))"
          ],
          "line": 1811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_data_init",
          "args": [
            "args",
            "dbno",
            "&dbp"
          ],
          "line": 1814
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_data_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "565-635",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir3_data_init(\n\txfs_da_args_t\t\t*args,\t\t/* directory operation args */\n\txfs_dir2_db_t\t\tblkno,\t\t/* logical dir block number */\n\tstruct xfs_buf\t\t**bpp)\t\t/* output block buffer */\n{\n\tstruct xfs_buf\t\t*bp;\t\t/* block buffer */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry pointer */\n\tstruct xfs_dir2_data_free *bf;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\ti;\t\t/* bestfree index */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tint                     t;              /* temp */\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\ttp = args->trans;\n\t/*\n\t * Get the buffer set up for the block.\n\t */\n\terror = xfs_da_get_buf(tp, dp, xfs_dir2_db_to_da(args->geo, blkno),\n\t\t\t       -1, &bp, XFS_DATA_FORK);\n\tif (error)\n\t\treturn error;\n\tbp->b_ops = &xfs_dir3_data_buf_ops;\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DIR_DATA_BUF);\n\n\t/*\n\t * Initialize the header.\n\t */\n\thdr = bp->b_addr;\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_dir3_blk_hdr *hdr3 = bp->b_addr;\n\n\t\tmemset(hdr3, 0, sizeof(*hdr3));\n\t\thdr3->magic = cpu_to_be32(XFS_DIR3_DATA_MAGIC);\n\t\thdr3->blkno = cpu_to_be64(bp->b_bn);\n\t\thdr3->owner = cpu_to_be64(dp->i_ino);\n\t\tuuid_copy(&hdr3->uuid, &mp->m_sb.sb_uuid);\n\n\t} else\n\t\thdr->magic = cpu_to_be32(XFS_DIR2_DATA_MAGIC);\n\n\tbf = dp->d_ops->data_bestfree_p(hdr);\n\tbf[0].offset = cpu_to_be16(dp->d_ops->data_entry_offset);\n\tfor (i = 1; i < XFS_DIR2_DATA_FD_COUNT; i++) {\n\t\tbf[i].length = 0;\n\t\tbf[i].offset = 0;\n\t}\n\n\t/*\n\t * Set up an unused entry for the block's body.\n\t */\n\tdup = dp->d_ops->data_unused_p(hdr);\n\tdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\n\tt = args->geo->blksize - (uint)dp->d_ops->data_entry_offset;\n\tbf[0].length = cpu_to_be16(t);\n\tdup->length = cpu_to_be16(t);\n\t*xfs_dir2_data_unused_tag_p(dup) = cpu_to_be16((char *)dup - (char *)hdr);\n\t/*\n\t * Log it and return it.\n\t */\n\txfs_dir2_data_log_header(args, bp);\n\txfs_dir2_data_log_unused(args, bp, dup);\n\t*bpp = bp;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_dir3_data_buf_ops = {\n\t.verify_read = xfs_dir3_data_read_verify,\n\t.verify_write = xfs_dir3_data_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_dir3_data_buf_ops = {\n\t.verify_read = xfs_dir3_data_read_verify,\n\t.verify_write = xfs_dir3_data_write_verify,\n};\n\nint\t\t\t\t\t\t/* error */\nxfs_dir3_data_init(\n\txfs_da_args_t\t\t*args,\t\t/* directory operation args */\n\txfs_dir2_db_t\t\tblkno,\t\t/* logical dir block number */\n\tstruct xfs_buf\t\t**bpp)\t\t/* output block buffer */\n{\n\tstruct xfs_buf\t\t*bp;\t\t/* block buffer */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry pointer */\n\tstruct xfs_dir2_data_free *bf;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\ti;\t\t/* bestfree index */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tint                     t;              /* temp */\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\ttp = args->trans;\n\t/*\n\t * Get the buffer set up for the block.\n\t */\n\terror = xfs_da_get_buf(tp, dp, xfs_dir2_db_to_da(args->geo, blkno),\n\t\t\t       -1, &bp, XFS_DATA_FORK);\n\tif (error)\n\t\treturn error;\n\tbp->b_ops = &xfs_dir3_data_buf_ops;\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DIR_DATA_BUF);\n\n\t/*\n\t * Initialize the header.\n\t */\n\thdr = bp->b_addr;\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_dir3_blk_hdr *hdr3 = bp->b_addr;\n\n\t\tmemset(hdr3, 0, sizeof(*hdr3));\n\t\thdr3->magic = cpu_to_be32(XFS_DIR3_DATA_MAGIC);\n\t\thdr3->blkno = cpu_to_be64(bp->b_bn);\n\t\thdr3->owner = cpu_to_be64(dp->i_ino);\n\t\tuuid_copy(&hdr3->uuid, &mp->m_sb.sb_uuid);\n\n\t} else\n\t\thdr->magic = cpu_to_be32(XFS_DIR2_DATA_MAGIC);\n\n\tbf = dp->d_ops->data_bestfree_p(hdr);\n\tbf[0].offset = cpu_to_be16(dp->d_ops->data_entry_offset);\n\tfor (i = 1; i < XFS_DIR2_DATA_FD_COUNT; i++) {\n\t\tbf[i].length = 0;\n\t\tbf[i].offset = 0;\n\t}\n\n\t/*\n\t * Set up an unused entry for the block's body.\n\t */\n\tdup = dp->d_ops->data_unused_p(hdr);\n\tdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\n\tt = args->geo->blksize - (uint)dp->d_ops->data_entry_offset;\n\tbf[0].length = cpu_to_be16(t);\n\tdup->length = cpu_to_be16(t);\n\t*xfs_dir2_data_unused_tag_p(dup) = cpu_to_be16((char *)dup - (char *)hdr);\n\t/*\n\t * Log it and return it.\n\t */\n\txfs_dir2_data_log_header(args, bp);\n\txfs_dir2_data_log_unused(args, bp, dup);\n\t*bpp = bp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dbno == -1"
          ],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "bests[findex]"
          ],
          "line": 1780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "bests[findex]"
          ],
          "line": 1779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->free_hdr_from_disk",
          "args": [
            "&freehdr",
            "free"
          ],
          "line": 1778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->free_bests_p",
          "args": [
            "free"
          ],
          "line": 1777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_da_to_db",
          "args": [
            "args->geo",
            "(xfs_dablk_t)fo"
          ],
          "line": 1723
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_da_to_db",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "287-291",
          "snippet": "static inline xfs_dir2_db_t\nxfs_dir2_da_to_db(struct xfs_da_geometry *geo, xfs_dablk_t da)\n{\n\treturn (xfs_dir2_db_t)(da >> (geo->blklog - geo->fsblog));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_db_t\nxfs_dir2_da_to_db(struct xfs_da_geometry *geo, xfs_dablk_t da)\n{\n\treturn (xfs_dir2_db_t)(da >> (geo->blklog - geo->fsblog));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_last_offset",
          "args": [
            "dp",
            "&fo",
            "XFS_DATA_FORK"
          ],
          "line": 1721
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_last_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "1671-1696",
          "snippet": "int\nxfs_bmap_last_offset(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\t*last_block,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_bmbt_irec\trec;\n\tint\t\t\tis_empty;\n\tint\t\t\terror;\n\n\t*last_block = 0;\n\n\tif (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL)\n\t\treturn 0;\n\n\tif (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t       return -EIO;\n\n\terror = xfs_bmap_last_extent(NULL, ip, whichfork, &rec, &is_empty);\n\tif (error || is_empty)\n\t\treturn error;\n\n\t*last_block = rec.br_startoff + rec.br_blockcount;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmap_last_offset(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\t*last_block,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_bmbt_irec\trec;\n\tint\t\t\tis_empty;\n\tint\t\t\terror;\n\n\t*last_block = 0;\n\n\tif (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL)\n\t\treturn 0;\n\n\tif (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t       return -EIO;\n\n\terror = xfs_bmap_last_extent(NULL, ip, whichfork, &rec, &is_empty);\n\tif (error || is_empty)\n\t\treturn error;\n\n\t*last_block = rec.br_startoff + rec.br_blockcount;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "be16_to_cpu(bests[findex]) >= length"
          ],
          "line": 1694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "bests[findex]"
          ],
          "line": 1694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "be16_to_cpu(bests[findex]) != NULLDATAOFF"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "bests[findex]"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "findex < freehdr.nvalid"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->free_hdr_from_disk",
          "args": [
            "&freehdr",
            "free"
          ],
          "line": 1684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->free_bests_p",
          "args": [
            "free"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_entsize",
          "args": [
            "args->namelen"
          ],
          "line": 1669
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);\nstatic int xfs_dir2_node_addname_int(xfs_da_args_t *args,\n\t\t\t\t     xfs_da_state_blk_t *fblk);\n\nstatic int\t\t\t\t\t/* error */\nxfs_dir2_node_addname_int(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\txfs_da_state_blk_t\t*fblk)\t\t/* optional freespace block */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_db_t\t\tdbno;\t\t/* data block number */\n\tstruct xfs_buf\t\t*dbp;\t\t/* data block buffer */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry pointer */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* data unused entry pointer */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_dir2_db_t\t\tfbno;\t\t/* freespace block number */\n\tstruct xfs_buf\t\t*fbp;\t\t/* freespace buffer */\n\tint\t\t\tfindex;\t\t/* freespace entry index */\n\txfs_dir2_free_t\t\t*free=NULL;\t/* freespace block structure */\n\txfs_dir2_db_t\t\tifbno;\t\t/* initial freespace block no */\n\txfs_dir2_db_t\t\tlastfbno=0;\t/* highest freespace block no */\n\tint\t\t\tlength;\t\t/* length of the new entry */\n\tint\t\t\tlogfree;\t/* need to log free entry */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tint\t\t\tneedlog;\t/* need to log data header */\n\tint\t\t\tneedscan;\t/* need to rescan data frees */\n\t__be16\t\t\t*tagp;\t\t/* data entry tag pointer */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\t__be16\t\t\t*bests;\n\tstruct xfs_dir3_icfree_hdr freehdr;\n\tstruct xfs_dir2_data_free *bf;\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\ttp = args->trans;\n\tlength = dp->d_ops->data_entsize(args->namelen);\n\t/*\n\t * If we came in with a freespace block that means that lookup\n\t * found an entry with our hash value.  This is the freespace\n\t * block for that data entry.\n\t */\n\tif (fblk) {\n\t\tfbp = fblk->bp;\n\t\t/*\n\t\t * Remember initial freespace block number.\n\t\t */\n\t\tifbno = fblk->blkno;\n\t\tfree = fbp->b_addr;\n\t\tfindex = fblk->index;\n\t\tbests = dp->d_ops->free_bests_p(free);\n\t\tdp->d_ops->free_hdr_from_disk(&freehdr, free);\n\n\t\t/*\n\t\t * This means the free entry showed that the data block had\n\t\t * space for our entry, so we remembered it.\n\t\t * Use that data block.\n\t\t */\n\t\tif (findex >= 0) {\n\t\t\tASSERT(findex < freehdr.nvalid);\n\t\t\tASSERT(be16_to_cpu(bests[findex]) != NULLDATAOFF);\n\t\t\tASSERT(be16_to_cpu(bests[findex]) >= length);\n\t\t\tdbno = freehdr.firstdb + findex;\n\t\t} else {\n\t\t\t/*\n\t\t\t * The data block looked at didn't have enough room.\n\t\t\t * We'll start at the beginning of the freespace entries.\n\t\t\t */\n\t\t\tdbno = -1;\n\t\t\tfindex = 0;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Didn't come in with a freespace block, so no data block.\n\t\t */\n\t\tifbno = dbno = -1;\n\t\tfbp = NULL;\n\t\tfindex = 0;\n\t}\n\n\t/*\n\t * If we don't have a data block yet, we're going to scan the\n\t * freespace blocks looking for one.  Figure out what the\n\t * highest freespace block number is.\n\t */\n\tif (dbno == -1) {\n\t\txfs_fileoff_t\tfo;\t\t/* freespace block number */\n\n\t\tif ((error = xfs_bmap_last_offset(dp, &fo, XFS_DATA_FORK)))\n\t\t\treturn error;\n\t\tlastfbno = xfs_dir2_da_to_db(args->geo, (xfs_dablk_t)fo);\n\t\tfbno = ifbno;\n\t}\n\t/*\n\t * While we haven't identified a data block, search the freeblock\n\t * data for a good data block.  If we find a null freeblock entry,\n\t * indicating a hole in the data blocks, remember that.\n\t */\n\twhile (dbno == -1) {\n\t\t/*\n\t\t * If we don't have a freeblock in hand, get the next one.\n\t\t */\n\t\tif (fbp == NULL) {\n\t\t\t/*\n\t\t\t * Happens the first time through unless lookup gave\n\t\t\t * us a freespace block to start with.\n\t\t\t */\n\t\t\tif (++fbno == 0)\n\t\t\t\tfbno = xfs_dir2_byte_to_db(args->geo,\n\t\t\t\t\t\t\tXFS_DIR2_FREE_OFFSET);\n\t\t\t/*\n\t\t\t * If it's ifbno we already looked at it.\n\t\t\t */\n\t\t\tif (fbno == ifbno)\n\t\t\t\tfbno++;\n\t\t\t/*\n\t\t\t * If it's off the end we're done.\n\t\t\t */\n\t\t\tif (fbno >= lastfbno)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * Read the block.  There can be holes in the\n\t\t\t * freespace blocks, so this might not succeed.\n\t\t\t * This should be really rare, so there's no reason\n\t\t\t * to avoid it.\n\t\t\t */\n\t\t\terror = xfs_dir2_free_try_read(tp, dp,\n\t\t\t\t\txfs_dir2_db_to_da(args->geo, fbno),\n\t\t\t\t\t&fbp);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (!fbp)\n\t\t\t\tcontinue;\n\t\t\tfree = fbp->b_addr;\n\t\t\tfindex = 0;\n\t\t}\n\t\t/*\n\t\t * Look at the current free entry.  Is it good enough?\n\t\t *\n\t\t * The bests initialisation should be where the bufer is read in\n\t\t * the above branch. But gcc is too stupid to realise that bests\n\t\t * and the freehdr are actually initialised if they are placed\n\t\t * there, so we have to do it here to avoid warnings. Blech.\n\t\t */\n\t\tbests = dp->d_ops->free_bests_p(free);\n\t\tdp->d_ops->free_hdr_from_disk(&freehdr, free);\n\t\tif (be16_to_cpu(bests[findex]) != NULLDATAOFF &&\n\t\t    be16_to_cpu(bests[findex]) >= length)\n\t\t\tdbno = freehdr.firstdb + findex;\n\t\telse {\n\t\t\t/*\n\t\t\t * Are we done with the freeblock?\n\t\t\t */\n\t\t\tif (++findex == freehdr.nvalid) {\n\t\t\t\t/*\n\t\t\t\t * Drop the block.\n\t\t\t\t */\n\t\t\t\txfs_trans_brelse(tp, fbp);\n\t\t\t\tfbp = NULL;\n\t\t\t\tif (fblk && fblk->bp)\n\t\t\t\t\tfblk->bp = NULL;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * If we don't have a data block, we need to allocate one and make\n\t * the freespace entries refer to it.\n\t */\n\tif (unlikely(dbno == -1)) {\n\t\t/*\n\t\t * Not allowed to allocate, return failure.\n\t\t */\n\t\tif ((args->op_flags & XFS_DA_OP_JUSTCHECK) || args->total == 0)\n\t\t\treturn -ENOSPC;\n\n\t\t/*\n\t\t * Allocate and initialize the new data block.\n\t\t */\n\t\tif (unlikely((error = xfs_dir2_grow_inode(args,\n\t\t\t\t\t\t\t XFS_DIR2_DATA_SPACE,\n\t\t\t\t\t\t\t &dbno)) ||\n\t\t    (error = xfs_dir3_data_init(args, dbno, &dbp))))\n\t\t\treturn error;\n\n\t\t/*\n\t\t * If (somehow) we have a freespace block, get rid of it.\n\t\t */\n\t\tif (fbp)\n\t\t\txfs_trans_brelse(tp, fbp);\n\t\tif (fblk && fblk->bp)\n\t\t\tfblk->bp = NULL;\n\n\t\t/*\n\t\t * Get the freespace block corresponding to the data block\n\t\t * that was just allocated.\n\t\t */\n\t\tfbno = dp->d_ops->db_to_fdb(args->geo, dbno);\n\t\terror = xfs_dir2_free_try_read(tp, dp,\n\t\t\t\t       xfs_dir2_db_to_da(args->geo, fbno),\n\t\t\t\t       &fbp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/*\n\t\t * If there wasn't a freespace block, the read will\n\t\t * return a NULL fbp.  Allocate and initialize a new one.\n\t\t */\n\t\tif (!fbp) {\n\t\t\terror = xfs_dir2_grow_inode(args, XFS_DIR2_FREE_SPACE,\n\t\t\t\t\t\t    &fbno);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\tif (dp->d_ops->db_to_fdb(args->geo, dbno) != fbno) {\n\t\t\t\txfs_alert(mp,\n\t\t\t\"%s: dir ino %llu needed freesp block %lld for\\n\"\n\t\t\t\"  data block %lld, got %lld ifbno %llu lastfbno %d\",\n\t\t\t\t\t__func__, (unsigned long long)dp->i_ino,\n\t\t\t\t\t(long long)dp->d_ops->db_to_fdb(\n\t\t\t\t\t\t\t\targs->geo, dbno),\n\t\t\t\t\t(long long)dbno, (long long)fbno,\n\t\t\t\t\t(unsigned long long)ifbno, lastfbno);\n\t\t\t\tif (fblk) {\n\t\t\t\t\txfs_alert(mp,\n\t\t\t\t\" fblk 0x%p blkno %llu index %d magic 0x%x\",\n\t\t\t\t\t\tfblk,\n\t\t\t\t\t\t(unsigned long long)fblk->blkno,\n\t\t\t\t\t\tfblk->index,\n\t\t\t\t\t\tfblk->magic);\n\t\t\t\t} else {\n\t\t\t\t\txfs_alert(mp, \" ... fblk is NULL\");\n\t\t\t\t}\n\t\t\t\tXFS_ERROR_REPORT(\"xfs_dir2_node_addname_int\",\n\t\t\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\t\t\treturn -EFSCORRUPTED;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Get a buffer for the new block.\n\t\t\t */\n\t\t\terror = xfs_dir3_free_get_buf(args, fbno, &fbp);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tfree = fbp->b_addr;\n\t\t\tbests = dp->d_ops->free_bests_p(free);\n\t\t\tdp->d_ops->free_hdr_from_disk(&freehdr, free);\n\n\t\t\t/*\n\t\t\t * Remember the first slot as our empty slot.\n\t\t\t */\n\t\t\tfreehdr.firstdb =\n\t\t\t\t(fbno - xfs_dir2_byte_to_db(args->geo,\n\t\t\t\t\t\t\tXFS_DIR2_FREE_OFFSET)) *\n\t\t\t\t\tdp->d_ops->free_max_bests(args->geo);\n\t\t} else {\n\t\t\tfree = fbp->b_addr;\n\t\t\tbests = dp->d_ops->free_bests_p(free);\n\t\t\tdp->d_ops->free_hdr_from_disk(&freehdr, free);\n\t\t}\n\n\t\t/*\n\t\t * Set the freespace block index from the data block number.\n\t\t */\n\t\tfindex = dp->d_ops->db_to_fdindex(args->geo, dbno);\n\t\t/*\n\t\t * If it's after the end of the current entries in the\n\t\t * freespace block, extend that table.\n\t\t */\n\t\tif (findex >= freehdr.nvalid) {\n\t\t\tASSERT(findex < dp->d_ops->free_max_bests(args->geo));\n\t\t\tfreehdr.nvalid = findex + 1;\n\t\t\t/*\n\t\t\t * Tag new entry so nused will go up.\n\t\t\t */\n\t\t\tbests[findex] = cpu_to_be16(NULLDATAOFF);\n\t\t}\n\t\t/*\n\t\t * If this entry was for an empty data block\n\t\t * (this should always be true) then update the header.\n\t\t */\n\t\tif (bests[findex] == cpu_to_be16(NULLDATAOFF)) {\n\t\t\tfreehdr.nused++;\n\t\t\tdp->d_ops->free_hdr_to_disk(fbp->b_addr, &freehdr);\n\t\t\txfs_dir2_free_log_header(args, fbp);\n\t\t}\n\t\t/*\n\t\t * Update the real value in the table.\n\t\t * We haven't allocated the data entry yet so this will\n\t\t * change again.\n\t\t */\n\t\thdr = dbp->b_addr;\n\t\tbf = dp->d_ops->data_bestfree_p(hdr);\n\t\tbests[findex] = bf[0].length;\n\t\tlogfree = 1;\n\t}\n\t/*\n\t * We had a data block so we don't have to make a new one.\n\t */\n\telse {\n\t\t/*\n\t\t * If just checking, we succeeded.\n\t\t */\n\t\tif (args->op_flags & XFS_DA_OP_JUSTCHECK)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * Read the data block in.\n\t\t */\n\t\terror = xfs_dir3_data_read(tp, dp,\n\t\t\t\t\t   xfs_dir2_db_to_da(args->geo, dbno),\n\t\t\t\t\t   -1, &dbp);\n\t\tif (error)\n\t\t\treturn error;\n\t\thdr = dbp->b_addr;\n\t\tbf = dp->d_ops->data_bestfree_p(hdr);\n\t\tlogfree = 0;\n\t}\n\tASSERT(be16_to_cpu(bf[0].length) >= length);\n\t/*\n\t * Point to the existing unused space.\n\t */\n\tdup = (xfs_dir2_data_unused_t *)\n\t      ((char *)hdr + be16_to_cpu(bf[0].offset));\n\tneedscan = needlog = 0;\n\t/*\n\t * Mark the first part of the unused space, inuse for us.\n\t */\n\txfs_dir2_data_use_free(args, dbp, dup,\n\t\t(xfs_dir2_data_aoff_t)((char *)dup - (char *)hdr), length,\n\t\t&needlog, &needscan);\n\t/*\n\t * Fill in the new entry and log it.\n\t */\n\tdep = (xfs_dir2_data_entry_t *)dup;\n\tdep->inumber = cpu_to_be64(args->inumber);\n\tdep->namelen = args->namelen;\n\tmemcpy(dep->name, args->name, dep->namelen);\n\tdp->d_ops->data_put_ftype(dep, args->filetype);\n\ttagp = dp->d_ops->data_entry_tag_p(dep);\n\t*tagp = cpu_to_be16((char *)dep - (char *)hdr);\n\txfs_dir2_data_log_entry(args, dbp, dep);\n\t/*\n\t * Rescan the block for bestfree if needed.\n\t */\n\tif (needscan)\n\t\txfs_dir2_data_freescan(dp, hdr, &needlog);\n\t/*\n\t * Log the data block header if needed.\n\t */\n\tif (needlog)\n\t\txfs_dir2_data_log_header(args, dbp);\n\t/*\n\t * If the freespace entry is now wrong, update it.\n\t */\n\tbests = dp->d_ops->free_bests_p(free); /* gcc is so stupid */\n\tif (be16_to_cpu(bests[findex]) != be16_to_cpu(bf[0].length)) {\n\t\tbests[findex] = bf[0].length;\n\t\tlogfree = 1;\n\t}\n\t/*\n\t * Log the freespace entry if needed.\n\t */\n\tif (logfree)\n\t\txfs_dir2_free_log_bests(args, fbp, findex, findex);\n\t/*\n\t * Return the data block and offset in args, then drop the data block.\n\t */\n\targs->blkno = (xfs_dablk_t)dbno;\n\targs->index = be16_to_cpu(*tagp);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_dir2_node_addname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
    "lines": "1566-1630",
    "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_node_addname(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\txfs_da_state_blk_t\t*blk;\t\t/* leaf block for insert */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\trval;\t\t/* sub-return value */\n\txfs_da_state_t\t\t*state;\t\t/* btree cursor */\n\n\ttrace_xfs_dir2_node_addname(args);\n\n\t/*\n\t * Allocate and initialize the state (btree cursor).\n\t */\n\tstate = xfs_da_state_alloc();\n\tstate->args = args;\n\tstate->mp = args->dp->i_mount;\n\t/*\n\t * Look up the name.  We're not supposed to find it, but\n\t * this gives us the insertion point.\n\t */\n\terror = xfs_da3_node_lookup_int(state, &rval);\n\tif (error)\n\t\trval = error;\n\tif (rval != -ENOENT) {\n\t\tgoto done;\n\t}\n\t/*\n\t * Add the data entry to a data block.\n\t * Extravalid is set to a freeblock found by lookup.\n\t */\n\trval = xfs_dir2_node_addname_int(args,\n\t\tstate->extravalid ? &state->extrablk : NULL);\n\tif (rval) {\n\t\tgoto done;\n\t}\n\tblk = &state->path.blk[state->path.active - 1];\n\tASSERT(blk->magic == XFS_DIR2_LEAFN_MAGIC);\n\t/*\n\t * Add the new leaf entry.\n\t */\n\trval = xfs_dir2_leafn_add(blk->bp, args, blk->index);\n\tif (rval == 0) {\n\t\t/*\n\t\t * It worked, fix the hash values up the btree.\n\t\t */\n\t\tif (!(args->op_flags & XFS_DA_OP_JUSTCHECK))\n\t\t\txfs_da3_fixhashpath(state, &state->path);\n\t} else {\n\t\t/*\n\t\t * It didn't work, we need to split the leaf block.\n\t\t */\n\t\tif (args->total == 0) {\n\t\t\tASSERT(rval == -ENOSPC);\n\t\t\tgoto done;\n\t\t}\n\t\t/*\n\t\t * Split the leaf block and insert the new entry.\n\t\t */\n\t\trval = xfs_da3_split(state);\n\t}\ndone:\n\txfs_da_state_free(state);\n\treturn rval;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);",
      "static int xfs_dir2_leafn_remove(xfs_da_args_t *args, struct xfs_buf *bp,\n\t\t\t\t int index, xfs_da_state_blk_t *dblk,\n\t\t\t\t int *rval);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_da_state_free",
          "args": [
            "state"
          ],
          "line": 1628
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_state_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "120-128",
          "snippet": "void\nxfs_da_state_free(xfs_da_state_t *state)\n{\n\txfs_da_state_kill_altpath(state);\n#ifdef DEBUG\n\tmemset((char *)state, 0, sizeof(*state));\n#endif /* DEBUG */\n\tkmem_zone_free(xfs_da_state_zone, state);\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t *xfs_da_state_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t *xfs_da_state_zone;\n\nvoid\nxfs_da_state_free(xfs_da_state_t *state)\n{\n\txfs_da_state_kill_altpath(state);\n#ifdef DEBUG\n\tmemset((char *)state, 0, sizeof(*state));\n#endif /* DEBUG */\n\tkmem_zone_free(xfs_da_state_zone, state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da3_split",
          "args": [
            "state"
          ],
          "line": 1625
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_split",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "345-494",
          "snippet": "int\t\t\t\t\t\t\t/* error */\nxfs_da3_split(\n\tstruct xfs_da_state\t*state)\n{\n\tstruct xfs_da_state_blk\t*oldblk;\n\tstruct xfs_da_state_blk\t*newblk;\n\tstruct xfs_da_state_blk\t*addblk;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\tmax;\n\tint\t\t\taction = 0;\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\ttrace_xfs_da_split(state->args);\n\n\t/*\n\t * Walk back up the tree splitting/inserting/adjusting as necessary.\n\t * If we need to insert and there isn't room, split the node, then\n\t * decide which fragment to insert the new block from below into.\n\t * Note that we may split the root this way, but we need more fixup.\n\t */\n\tmax = state->path.active - 1;\n\tASSERT((max >= 0) && (max < XFS_DA_NODE_MAXDEPTH));\n\tASSERT(state->path.blk[max].magic == XFS_ATTR_LEAF_MAGIC ||\n\t       state->path.blk[max].magic == XFS_DIR2_LEAFN_MAGIC);\n\n\taddblk = &state->path.blk[max];\t\t/* initial dummy value */\n\tfor (i = max; (i >= 0) && addblk; state->path.active--, i--) {\n\t\toldblk = &state->path.blk[i];\n\t\tnewblk = &state->altpath.blk[i];\n\n\t\t/*\n\t\t * If a leaf node then\n\t\t *     Allocate a new leaf node, then rebalance across them.\n\t\t * else if an intermediate node then\n\t\t *     We split on the last layer, must we split the node?\n\t\t */\n\t\tswitch (oldblk->magic) {\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\t\terror = xfs_attr3_leaf_split(state, oldblk, newblk);\n\t\t\tif ((error != 0) && (error != -ENOSPC)) {\n\t\t\t\treturn error;\t/* GROT: attr is inconsistent */\n\t\t\t}\n\t\t\tif (!error) {\n\t\t\t\taddblk = newblk;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Entry wouldn't fit, split the leaf again.\n\t\t\t */\n\t\t\tstate->extravalid = 1;\n\t\t\tif (state->inleaf) {\n\t\t\t\tstate->extraafter = 0;\t/* before newblk */\n\t\t\t\ttrace_xfs_attr_leaf_split_before(state->args);\n\t\t\t\terror = xfs_attr3_leaf_split(state, oldblk,\n\t\t\t\t\t\t\t    &state->extrablk);\n\t\t\t} else {\n\t\t\t\tstate->extraafter = 1;\t/* after newblk */\n\t\t\t\ttrace_xfs_attr_leaf_split_after(state->args);\n\t\t\t\terror = xfs_attr3_leaf_split(state, newblk,\n\t\t\t\t\t\t\t    &state->extrablk);\n\t\t\t}\n\t\t\tif (error)\n\t\t\t\treturn error;\t/* GROT: attr inconsistent */\n\t\t\taddblk = newblk;\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\t\terror = xfs_dir2_leafn_split(state, oldblk, newblk);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\taddblk = newblk;\n\t\t\tbreak;\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\t\terror = xfs_da3_node_split(state, oldblk, newblk, addblk,\n\t\t\t\t\t\t\t max - i, &action);\n\t\t\taddblk->bp = NULL;\n\t\t\tif (error)\n\t\t\t\treturn error;\t/* GROT: dir is inconsistent */\n\t\t\t/*\n\t\t\t * Record the newly split block for the next time thru?\n\t\t\t */\n\t\t\tif (action)\n\t\t\t\taddblk = newblk;\n\t\t\telse\n\t\t\t\taddblk = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Update the btree to show the new hashval for this child.\n\t\t */\n\t\txfs_da3_fixhashpath(state, &state->path);\n\t}\n\tif (!addblk)\n\t\treturn 0;\n\n\t/*\n\t * Split the root node.\n\t */\n\tASSERT(state->path.active == 0);\n\toldblk = &state->path.blk[0];\n\terror = xfs_da3_root_split(state, oldblk, addblk);\n\tif (error) {\n\t\taddblk->bp = NULL;\n\t\treturn error;\t/* GROT: dir is inconsistent */\n\t}\n\n\t/*\n\t * Update pointers to the node which used to be block 0 and\n\t * just got bumped because of the addition of a new root node.\n\t * There might be three blocks involved if a double split occurred,\n\t * and the original block 0 could be at any position in the list.\n\t *\n\t * Note: the magic numbers and sibling pointers are in the same\n\t * physical place for both v2 and v3 headers (by design). Hence it\n\t * doesn't matter which version of the xfs_da_intnode structure we use\n\t * here as the result will be the same using either structure.\n\t */\n\tnode = oldblk->bp->b_addr;\n\tif (node->hdr.info.forw) {\n\t\tif (be32_to_cpu(node->hdr.info.forw) == addblk->blkno) {\n\t\t\tbp = addblk->bp;\n\t\t} else {\n\t\t\tASSERT(state->extravalid);\n\t\t\tbp = state->extrablk.bp;\n\t\t}\n\t\tnode = bp->b_addr;\n\t\tnode->hdr.info.back = cpu_to_be32(oldblk->blkno);\n\t\txfs_trans_log_buf(state->args->trans, bp,\n\t\t    XFS_DA_LOGRANGE(node, &node->hdr.info,\n\t\t    sizeof(node->hdr.info)));\n\t}\n\tnode = oldblk->bp->b_addr;\n\tif (node->hdr.info.back) {\n\t\tif (be32_to_cpu(node->hdr.info.back) == addblk->blkno) {\n\t\t\tbp = addblk->bp;\n\t\t} else {\n\t\t\tASSERT(state->extravalid);\n\t\t\tbp = state->extrablk.bp;\n\t\t}\n\t\tnode = bp->b_addr;\n\t\tnode->hdr.info.forw = cpu_to_be32(oldblk->blkno);\n\t\txfs_trans_log_buf(state->args->trans, bp,\n\t\t    XFS_DA_LOGRANGE(node, &node->hdr.info,\n\t\t    sizeof(node->hdr.info)));\n\t}\n\taddblk->bp = NULL;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_da3_node_split(xfs_da_state_t *state,\n\t\t\t\t\t    xfs_da_state_blk_t *existing_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *split_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *blk_to_add,\n\t\t\t\t\t    int treelevel,\n\t\t\t\t\t    int *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_da3_node_split(xfs_da_state_t *state,\n\t\t\t\t\t    xfs_da_state_blk_t *existing_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *split_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *blk_to_add,\n\t\t\t\t\t    int treelevel,\n\t\t\t\t\t    int *result);\n\nint\t\t\t\t\t\t\t/* error */\nxfs_da3_split(\n\tstruct xfs_da_state\t*state)\n{\n\tstruct xfs_da_state_blk\t*oldblk;\n\tstruct xfs_da_state_blk\t*newblk;\n\tstruct xfs_da_state_blk\t*addblk;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\tmax;\n\tint\t\t\taction = 0;\n\tint\t\t\terror;\n\tint\t\t\ti;\n\n\ttrace_xfs_da_split(state->args);\n\n\t/*\n\t * Walk back up the tree splitting/inserting/adjusting as necessary.\n\t * If we need to insert and there isn't room, split the node, then\n\t * decide which fragment to insert the new block from below into.\n\t * Note that we may split the root this way, but we need more fixup.\n\t */\n\tmax = state->path.active - 1;\n\tASSERT((max >= 0) && (max < XFS_DA_NODE_MAXDEPTH));\n\tASSERT(state->path.blk[max].magic == XFS_ATTR_LEAF_MAGIC ||\n\t       state->path.blk[max].magic == XFS_DIR2_LEAFN_MAGIC);\n\n\taddblk = &state->path.blk[max];\t\t/* initial dummy value */\n\tfor (i = max; (i >= 0) && addblk; state->path.active--, i--) {\n\t\toldblk = &state->path.blk[i];\n\t\tnewblk = &state->altpath.blk[i];\n\n\t\t/*\n\t\t * If a leaf node then\n\t\t *     Allocate a new leaf node, then rebalance across them.\n\t\t * else if an intermediate node then\n\t\t *     We split on the last layer, must we split the node?\n\t\t */\n\t\tswitch (oldblk->magic) {\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\t\terror = xfs_attr3_leaf_split(state, oldblk, newblk);\n\t\t\tif ((error != 0) && (error != -ENOSPC)) {\n\t\t\t\treturn error;\t/* GROT: attr is inconsistent */\n\t\t\t}\n\t\t\tif (!error) {\n\t\t\t\taddblk = newblk;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Entry wouldn't fit, split the leaf again.\n\t\t\t */\n\t\t\tstate->extravalid = 1;\n\t\t\tif (state->inleaf) {\n\t\t\t\tstate->extraafter = 0;\t/* before newblk */\n\t\t\t\ttrace_xfs_attr_leaf_split_before(state->args);\n\t\t\t\terror = xfs_attr3_leaf_split(state, oldblk,\n\t\t\t\t\t\t\t    &state->extrablk);\n\t\t\t} else {\n\t\t\t\tstate->extraafter = 1;\t/* after newblk */\n\t\t\t\ttrace_xfs_attr_leaf_split_after(state->args);\n\t\t\t\terror = xfs_attr3_leaf_split(state, newblk,\n\t\t\t\t\t\t\t    &state->extrablk);\n\t\t\t}\n\t\t\tif (error)\n\t\t\t\treturn error;\t/* GROT: attr inconsistent */\n\t\t\taddblk = newblk;\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\t\terror = xfs_dir2_leafn_split(state, oldblk, newblk);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\taddblk = newblk;\n\t\t\tbreak;\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\t\terror = xfs_da3_node_split(state, oldblk, newblk, addblk,\n\t\t\t\t\t\t\t max - i, &action);\n\t\t\taddblk->bp = NULL;\n\t\t\tif (error)\n\t\t\t\treturn error;\t/* GROT: dir is inconsistent */\n\t\t\t/*\n\t\t\t * Record the newly split block for the next time thru?\n\t\t\t */\n\t\t\tif (action)\n\t\t\t\taddblk = newblk;\n\t\t\telse\n\t\t\t\taddblk = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Update the btree to show the new hashval for this child.\n\t\t */\n\t\txfs_da3_fixhashpath(state, &state->path);\n\t}\n\tif (!addblk)\n\t\treturn 0;\n\n\t/*\n\t * Split the root node.\n\t */\n\tASSERT(state->path.active == 0);\n\toldblk = &state->path.blk[0];\n\terror = xfs_da3_root_split(state, oldblk, addblk);\n\tif (error) {\n\t\taddblk->bp = NULL;\n\t\treturn error;\t/* GROT: dir is inconsistent */\n\t}\n\n\t/*\n\t * Update pointers to the node which used to be block 0 and\n\t * just got bumped because of the addition of a new root node.\n\t * There might be three blocks involved if a double split occurred,\n\t * and the original block 0 could be at any position in the list.\n\t *\n\t * Note: the magic numbers and sibling pointers are in the same\n\t * physical place for both v2 and v3 headers (by design). Hence it\n\t * doesn't matter which version of the xfs_da_intnode structure we use\n\t * here as the result will be the same using either structure.\n\t */\n\tnode = oldblk->bp->b_addr;\n\tif (node->hdr.info.forw) {\n\t\tif (be32_to_cpu(node->hdr.info.forw) == addblk->blkno) {\n\t\t\tbp = addblk->bp;\n\t\t} else {\n\t\t\tASSERT(state->extravalid);\n\t\t\tbp = state->extrablk.bp;\n\t\t}\n\t\tnode = bp->b_addr;\n\t\tnode->hdr.info.back = cpu_to_be32(oldblk->blkno);\n\t\txfs_trans_log_buf(state->args->trans, bp,\n\t\t    XFS_DA_LOGRANGE(node, &node->hdr.info,\n\t\t    sizeof(node->hdr.info)));\n\t}\n\tnode = oldblk->bp->b_addr;\n\tif (node->hdr.info.back) {\n\t\tif (be32_to_cpu(node->hdr.info.back) == addblk->blkno) {\n\t\t\tbp = addblk->bp;\n\t\t} else {\n\t\t\tASSERT(state->extravalid);\n\t\t\tbp = state->extrablk.bp;\n\t\t}\n\t\tnode = bp->b_addr;\n\t\tnode->hdr.info.forw = cpu_to_be32(oldblk->blkno);\n\t\txfs_trans_log_buf(state->args->trans, bp,\n\t\t    XFS_DA_LOGRANGE(node, &node->hdr.info,\n\t\t    sizeof(node->hdr.info)));\n\t}\n\taddblk->bp = NULL;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "rval == -ENOSPC"
          ],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_da3_fixhashpath",
          "args": [
            "state",
            "&state->path"
          ],
          "line": 1613
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_fixhashpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "1256-1306",
          "snippet": "void\nxfs_da3_fixhashpath(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_path *path)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_node_entry *btree;\n\txfs_dahash_t\t\tlasthash=0;\n\tint\t\t\tlevel;\n\tint\t\t\tcount;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_fixhashpath(state->args);\n\n\tlevel = path->active-1;\n\tblk = &path->blk[ level ];\n\tswitch (blk->magic) {\n\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tlasthash = xfs_attr_leaf_lasthash(blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tlasthash = xfs_dir2_leafn_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DA_NODE_MAGIC:\n\t\tlasthash = xfs_da3_node_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\t}\n\tfor (blk--, level--; level >= 0; blk--, level--) {\n\t\tstruct xfs_da3_icnode_hdr nodehdr;\n\n\t\tnode = blk->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\tbtree = dp->d_ops->node_tree_p(node);\n\t\tif (be32_to_cpu(btree[blk->index].hashval) == lasthash)\n\t\t\tbreak;\n\t\tblk->hashval = lasthash;\n\t\tbtree[blk->index].hashval = cpu_to_be32(lasthash);\n\t\txfs_trans_log_buf(state->args->trans, blk->bp,\n\t\t\t\t  XFS_DA_LOGRANGE(node, &btree[blk->index],\n\t\t\t\t\t\t  sizeof(*btree)));\n\n\t\tlasthash = be32_to_cpu(btree[nodehdr.count - 1].hashval);\n\t}\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_da3_fixhashpath(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_path *path)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_node_entry *btree;\n\txfs_dahash_t\t\tlasthash=0;\n\tint\t\t\tlevel;\n\tint\t\t\tcount;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_fixhashpath(state->args);\n\n\tlevel = path->active-1;\n\tblk = &path->blk[ level ];\n\tswitch (blk->magic) {\n\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tlasthash = xfs_attr_leaf_lasthash(blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tlasthash = xfs_dir2_leafn_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DA_NODE_MAGIC:\n\t\tlasthash = xfs_da3_node_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\t}\n\tfor (blk--, level--; level >= 0; blk--, level--) {\n\t\tstruct xfs_da3_icnode_hdr nodehdr;\n\n\t\tnode = blk->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\tbtree = dp->d_ops->node_tree_p(node);\n\t\tif (be32_to_cpu(btree[blk->index].hashval) == lasthash)\n\t\t\tbreak;\n\t\tblk->hashval = lasthash;\n\t\tbtree[blk->index].hashval = cpu_to_be32(lasthash);\n\t\txfs_trans_log_buf(state->args->trans, blk->bp,\n\t\t\t\t  XFS_DA_LOGRANGE(node, &btree[blk->index],\n\t\t\t\t\t\t  sizeof(*btree)));\n\n\t\tlasthash = be32_to_cpu(btree[nodehdr.count - 1].hashval);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leafn_add",
          "args": [
            "blk->bp",
            "args",
            "blk->index"
          ],
          "line": 1607
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leafn_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
          "lines": "372-453",
          "snippet": "static int\t\t\t\t\t/* error */\nxfs_dir2_leafn_add(\n\tstruct xfs_buf\t\t*bp,\t\t/* leaf buffer */\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tint\t\t\tindex)\t\t/* insertion pt for new entry */\n{\n\tint\t\t\tcompact;\t/* compacting stale leaves */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\thighstale;\t/* next stale entry */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\tint\t\t\tlfloghigh;\t/* high leaf entry logging */\n\tint\t\t\tlfloglow;\t/* low leaf entry logging */\n\tint\t\t\tlowstale;\t/* previous stale entry */\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\tstruct xfs_dir2_leaf_entry *ents;\n\n\ttrace_xfs_dir2_leafn_add(args, index);\n\n\tdp = args->dp;\n\tleaf = bp->b_addr;\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\n\t/*\n\t * Quick check just to make sure we are not going to index\n\t * into other peoples memory\n\t */\n\tif (index < 0)\n\t\treturn -EFSCORRUPTED;\n\n\t/*\n\t * If there are already the maximum number of leaf entries in\n\t * the block, if there are no stale entries it won't fit.\n\t * Caller will do a split.  If there are stale entries we'll do\n\t * a compact.\n\t */\n\n\tif (leafhdr.count == dp->d_ops->leaf_max_ents(args->geo)) {\n\t\tif (!leafhdr.stale)\n\t\t\treturn -ENOSPC;\n\t\tcompact = leafhdr.stale > 1;\n\t} else\n\t\tcompact = 0;\n\tASSERT(index == 0 || be32_to_cpu(ents[index - 1].hashval) <= args->hashval);\n\tASSERT(index == leafhdr.count ||\n\t       be32_to_cpu(ents[index].hashval) >= args->hashval);\n\n\tif (args->op_flags & XFS_DA_OP_JUSTCHECK)\n\t\treturn 0;\n\n\t/*\n\t * Compact out all but one stale leaf entry.  Leaves behind\n\t * the entry closest to index.\n\t */\n\tif (compact)\n\t\txfs_dir3_leaf_compact_x1(&leafhdr, ents, &index, &lowstale,\n\t\t\t\t\t &highstale, &lfloglow, &lfloghigh);\n\telse if (leafhdr.stale) {\n\t\t/*\n\t\t * Set impossible logging indices for this case.\n\t\t */\n\t\tlfloglow = leafhdr.count;\n\t\tlfloghigh = -1;\n\t}\n\n\t/*\n\t * Insert the new entry, log everything.\n\t */\n\tlep = xfs_dir3_leaf_find_entry(&leafhdr, ents, index, compact, lowstale,\n\t\t\t\t       highstale, &lfloglow, &lfloghigh);\n\n\tlep->hashval = cpu_to_be32(args->hashval);\n\tlep->address = cpu_to_be32(xfs_dir2_db_off_to_dataptr(args->geo,\n\t\t\t\targs->blkno, args->index));\n\n\tdp->d_ops->leaf_hdr_to_disk(leaf, &leafhdr);\n\txfs_dir3_leaf_log_header(args, bp);\n\txfs_dir3_leaf_log_ents(args, bp, lfloglow, lfloghigh);\n\txfs_dir3_leaf_check(dp, bp);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);\n\nstatic int\t\t\t\t\t/* error */\nxfs_dir2_leafn_add(\n\tstruct xfs_buf\t\t*bp,\t\t/* leaf buffer */\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tint\t\t\tindex)\t\t/* insertion pt for new entry */\n{\n\tint\t\t\tcompact;\t/* compacting stale leaves */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\thighstale;\t/* next stale entry */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\tint\t\t\tlfloghigh;\t/* high leaf entry logging */\n\tint\t\t\tlfloglow;\t/* low leaf entry logging */\n\tint\t\t\tlowstale;\t/* previous stale entry */\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\tstruct xfs_dir2_leaf_entry *ents;\n\n\ttrace_xfs_dir2_leafn_add(args, index);\n\n\tdp = args->dp;\n\tleaf = bp->b_addr;\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\n\t/*\n\t * Quick check just to make sure we are not going to index\n\t * into other peoples memory\n\t */\n\tif (index < 0)\n\t\treturn -EFSCORRUPTED;\n\n\t/*\n\t * If there are already the maximum number of leaf entries in\n\t * the block, if there are no stale entries it won't fit.\n\t * Caller will do a split.  If there are stale entries we'll do\n\t * a compact.\n\t */\n\n\tif (leafhdr.count == dp->d_ops->leaf_max_ents(args->geo)) {\n\t\tif (!leafhdr.stale)\n\t\t\treturn -ENOSPC;\n\t\tcompact = leafhdr.stale > 1;\n\t} else\n\t\tcompact = 0;\n\tASSERT(index == 0 || be32_to_cpu(ents[index - 1].hashval) <= args->hashval);\n\tASSERT(index == leafhdr.count ||\n\t       be32_to_cpu(ents[index].hashval) >= args->hashval);\n\n\tif (args->op_flags & XFS_DA_OP_JUSTCHECK)\n\t\treturn 0;\n\n\t/*\n\t * Compact out all but one stale leaf entry.  Leaves behind\n\t * the entry closest to index.\n\t */\n\tif (compact)\n\t\txfs_dir3_leaf_compact_x1(&leafhdr, ents, &index, &lowstale,\n\t\t\t\t\t &highstale, &lfloglow, &lfloghigh);\n\telse if (leafhdr.stale) {\n\t\t/*\n\t\t * Set impossible logging indices for this case.\n\t\t */\n\t\tlfloglow = leafhdr.count;\n\t\tlfloghigh = -1;\n\t}\n\n\t/*\n\t * Insert the new entry, log everything.\n\t */\n\tlep = xfs_dir3_leaf_find_entry(&leafhdr, ents, index, compact, lowstale,\n\t\t\t\t       highstale, &lfloglow, &lfloghigh);\n\n\tlep->hashval = cpu_to_be32(args->hashval);\n\tlep->address = cpu_to_be32(xfs_dir2_db_off_to_dataptr(args->geo,\n\t\t\t\targs->blkno, args->index));\n\n\tdp->d_ops->leaf_hdr_to_disk(leaf, &leafhdr);\n\txfs_dir3_leaf_log_header(args, bp);\n\txfs_dir3_leaf_log_ents(args, bp, lfloglow, lfloghigh);\n\txfs_dir3_leaf_check(dp, bp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "blk->magic == XFS_DIR2_LEAFN_MAGIC"
          ],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_node_addname_int",
          "args": [
            "args",
            "state->extravalid ? &state->extrablk : NULL"
          ],
          "line": 1597
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_node_addname_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
          "lines": "1637-2003",
          "snippet": "static int\t\t\t\t\t/* error */\nxfs_dir2_node_addname_int(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\txfs_da_state_blk_t\t*fblk)\t\t/* optional freespace block */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_db_t\t\tdbno;\t\t/* data block number */\n\tstruct xfs_buf\t\t*dbp;\t\t/* data block buffer */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry pointer */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* data unused entry pointer */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_dir2_db_t\t\tfbno;\t\t/* freespace block number */\n\tstruct xfs_buf\t\t*fbp;\t\t/* freespace buffer */\n\tint\t\t\tfindex;\t\t/* freespace entry index */\n\txfs_dir2_free_t\t\t*free=NULL;\t/* freespace block structure */\n\txfs_dir2_db_t\t\tifbno;\t\t/* initial freespace block no */\n\txfs_dir2_db_t\t\tlastfbno=0;\t/* highest freespace block no */\n\tint\t\t\tlength;\t\t/* length of the new entry */\n\tint\t\t\tlogfree;\t/* need to log free entry */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tint\t\t\tneedlog;\t/* need to log data header */\n\tint\t\t\tneedscan;\t/* need to rescan data frees */\n\t__be16\t\t\t*tagp;\t\t/* data entry tag pointer */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\t__be16\t\t\t*bests;\n\tstruct xfs_dir3_icfree_hdr freehdr;\n\tstruct xfs_dir2_data_free *bf;\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\ttp = args->trans;\n\tlength = dp->d_ops->data_entsize(args->namelen);\n\t/*\n\t * If we came in with a freespace block that means that lookup\n\t * found an entry with our hash value.  This is the freespace\n\t * block for that data entry.\n\t */\n\tif (fblk) {\n\t\tfbp = fblk->bp;\n\t\t/*\n\t\t * Remember initial freespace block number.\n\t\t */\n\t\tifbno = fblk->blkno;\n\t\tfree = fbp->b_addr;\n\t\tfindex = fblk->index;\n\t\tbests = dp->d_ops->free_bests_p(free);\n\t\tdp->d_ops->free_hdr_from_disk(&freehdr, free);\n\n\t\t/*\n\t\t * This means the free entry showed that the data block had\n\t\t * space for our entry, so we remembered it.\n\t\t * Use that data block.\n\t\t */\n\t\tif (findex >= 0) {\n\t\t\tASSERT(findex < freehdr.nvalid);\n\t\t\tASSERT(be16_to_cpu(bests[findex]) != NULLDATAOFF);\n\t\t\tASSERT(be16_to_cpu(bests[findex]) >= length);\n\t\t\tdbno = freehdr.firstdb + findex;\n\t\t} else {\n\t\t\t/*\n\t\t\t * The data block looked at didn't have enough room.\n\t\t\t * We'll start at the beginning of the freespace entries.\n\t\t\t */\n\t\t\tdbno = -1;\n\t\t\tfindex = 0;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Didn't come in with a freespace block, so no data block.\n\t\t */\n\t\tifbno = dbno = -1;\n\t\tfbp = NULL;\n\t\tfindex = 0;\n\t}\n\n\t/*\n\t * If we don't have a data block yet, we're going to scan the\n\t * freespace blocks looking for one.  Figure out what the\n\t * highest freespace block number is.\n\t */\n\tif (dbno == -1) {\n\t\txfs_fileoff_t\tfo;\t\t/* freespace block number */\n\n\t\tif ((error = xfs_bmap_last_offset(dp, &fo, XFS_DATA_FORK)))\n\t\t\treturn error;\n\t\tlastfbno = xfs_dir2_da_to_db(args->geo, (xfs_dablk_t)fo);\n\t\tfbno = ifbno;\n\t}\n\t/*\n\t * While we haven't identified a data block, search the freeblock\n\t * data for a good data block.  If we find a null freeblock entry,\n\t * indicating a hole in the data blocks, remember that.\n\t */\n\twhile (dbno == -1) {\n\t\t/*\n\t\t * If we don't have a freeblock in hand, get the next one.\n\t\t */\n\t\tif (fbp == NULL) {\n\t\t\t/*\n\t\t\t * Happens the first time through unless lookup gave\n\t\t\t * us a freespace block to start with.\n\t\t\t */\n\t\t\tif (++fbno == 0)\n\t\t\t\tfbno = xfs_dir2_byte_to_db(args->geo,\n\t\t\t\t\t\t\tXFS_DIR2_FREE_OFFSET);\n\t\t\t/*\n\t\t\t * If it's ifbno we already looked at it.\n\t\t\t */\n\t\t\tif (fbno == ifbno)\n\t\t\t\tfbno++;\n\t\t\t/*\n\t\t\t * If it's off the end we're done.\n\t\t\t */\n\t\t\tif (fbno >= lastfbno)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * Read the block.  There can be holes in the\n\t\t\t * freespace blocks, so this might not succeed.\n\t\t\t * This should be really rare, so there's no reason\n\t\t\t * to avoid it.\n\t\t\t */\n\t\t\terror = xfs_dir2_free_try_read(tp, dp,\n\t\t\t\t\txfs_dir2_db_to_da(args->geo, fbno),\n\t\t\t\t\t&fbp);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (!fbp)\n\t\t\t\tcontinue;\n\t\t\tfree = fbp->b_addr;\n\t\t\tfindex = 0;\n\t\t}\n\t\t/*\n\t\t * Look at the current free entry.  Is it good enough?\n\t\t *\n\t\t * The bests initialisation should be where the bufer is read in\n\t\t * the above branch. But gcc is too stupid to realise that bests\n\t\t * and the freehdr are actually initialised if they are placed\n\t\t * there, so we have to do it here to avoid warnings. Blech.\n\t\t */\n\t\tbests = dp->d_ops->free_bests_p(free);\n\t\tdp->d_ops->free_hdr_from_disk(&freehdr, free);\n\t\tif (be16_to_cpu(bests[findex]) != NULLDATAOFF &&\n\t\t    be16_to_cpu(bests[findex]) >= length)\n\t\t\tdbno = freehdr.firstdb + findex;\n\t\telse {\n\t\t\t/*\n\t\t\t * Are we done with the freeblock?\n\t\t\t */\n\t\t\tif (++findex == freehdr.nvalid) {\n\t\t\t\t/*\n\t\t\t\t * Drop the block.\n\t\t\t\t */\n\t\t\t\txfs_trans_brelse(tp, fbp);\n\t\t\t\tfbp = NULL;\n\t\t\t\tif (fblk && fblk->bp)\n\t\t\t\t\tfblk->bp = NULL;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * If we don't have a data block, we need to allocate one and make\n\t * the freespace entries refer to it.\n\t */\n\tif (unlikely(dbno == -1)) {\n\t\t/*\n\t\t * Not allowed to allocate, return failure.\n\t\t */\n\t\tif ((args->op_flags & XFS_DA_OP_JUSTCHECK) || args->total == 0)\n\t\t\treturn -ENOSPC;\n\n\t\t/*\n\t\t * Allocate and initialize the new data block.\n\t\t */\n\t\tif (unlikely((error = xfs_dir2_grow_inode(args,\n\t\t\t\t\t\t\t XFS_DIR2_DATA_SPACE,\n\t\t\t\t\t\t\t &dbno)) ||\n\t\t    (error = xfs_dir3_data_init(args, dbno, &dbp))))\n\t\t\treturn error;\n\n\t\t/*\n\t\t * If (somehow) we have a freespace block, get rid of it.\n\t\t */\n\t\tif (fbp)\n\t\t\txfs_trans_brelse(tp, fbp);\n\t\tif (fblk && fblk->bp)\n\t\t\tfblk->bp = NULL;\n\n\t\t/*\n\t\t * Get the freespace block corresponding to the data block\n\t\t * that was just allocated.\n\t\t */\n\t\tfbno = dp->d_ops->db_to_fdb(args->geo, dbno);\n\t\terror = xfs_dir2_free_try_read(tp, dp,\n\t\t\t\t       xfs_dir2_db_to_da(args->geo, fbno),\n\t\t\t\t       &fbp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/*\n\t\t * If there wasn't a freespace block, the read will\n\t\t * return a NULL fbp.  Allocate and initialize a new one.\n\t\t */\n\t\tif (!fbp) {\n\t\t\terror = xfs_dir2_grow_inode(args, XFS_DIR2_FREE_SPACE,\n\t\t\t\t\t\t    &fbno);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\tif (dp->d_ops->db_to_fdb(args->geo, dbno) != fbno) {\n\t\t\t\txfs_alert(mp,\n\t\t\t\"%s: dir ino %llu needed freesp block %lld for\\n\"\n\t\t\t\"  data block %lld, got %lld ifbno %llu lastfbno %d\",\n\t\t\t\t\t__func__, (unsigned long long)dp->i_ino,\n\t\t\t\t\t(long long)dp->d_ops->db_to_fdb(\n\t\t\t\t\t\t\t\targs->geo, dbno),\n\t\t\t\t\t(long long)dbno, (long long)fbno,\n\t\t\t\t\t(unsigned long long)ifbno, lastfbno);\n\t\t\t\tif (fblk) {\n\t\t\t\t\txfs_alert(mp,\n\t\t\t\t\" fblk 0x%p blkno %llu index %d magic 0x%x\",\n\t\t\t\t\t\tfblk,\n\t\t\t\t\t\t(unsigned long long)fblk->blkno,\n\t\t\t\t\t\tfblk->index,\n\t\t\t\t\t\tfblk->magic);\n\t\t\t\t} else {\n\t\t\t\t\txfs_alert(mp, \" ... fblk is NULL\");\n\t\t\t\t}\n\t\t\t\tXFS_ERROR_REPORT(\"xfs_dir2_node_addname_int\",\n\t\t\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\t\t\treturn -EFSCORRUPTED;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Get a buffer for the new block.\n\t\t\t */\n\t\t\terror = xfs_dir3_free_get_buf(args, fbno, &fbp);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tfree = fbp->b_addr;\n\t\t\tbests = dp->d_ops->free_bests_p(free);\n\t\t\tdp->d_ops->free_hdr_from_disk(&freehdr, free);\n\n\t\t\t/*\n\t\t\t * Remember the first slot as our empty slot.\n\t\t\t */\n\t\t\tfreehdr.firstdb =\n\t\t\t\t(fbno - xfs_dir2_byte_to_db(args->geo,\n\t\t\t\t\t\t\tXFS_DIR2_FREE_OFFSET)) *\n\t\t\t\t\tdp->d_ops->free_max_bests(args->geo);\n\t\t} else {\n\t\t\tfree = fbp->b_addr;\n\t\t\tbests = dp->d_ops->free_bests_p(free);\n\t\t\tdp->d_ops->free_hdr_from_disk(&freehdr, free);\n\t\t}\n\n\t\t/*\n\t\t * Set the freespace block index from the data block number.\n\t\t */\n\t\tfindex = dp->d_ops->db_to_fdindex(args->geo, dbno);\n\t\t/*\n\t\t * If it's after the end of the current entries in the\n\t\t * freespace block, extend that table.\n\t\t */\n\t\tif (findex >= freehdr.nvalid) {\n\t\t\tASSERT(findex < dp->d_ops->free_max_bests(args->geo));\n\t\t\tfreehdr.nvalid = findex + 1;\n\t\t\t/*\n\t\t\t * Tag new entry so nused will go up.\n\t\t\t */\n\t\t\tbests[findex] = cpu_to_be16(NULLDATAOFF);\n\t\t}\n\t\t/*\n\t\t * If this entry was for an empty data block\n\t\t * (this should always be true) then update the header.\n\t\t */\n\t\tif (bests[findex] == cpu_to_be16(NULLDATAOFF)) {\n\t\t\tfreehdr.nused++;\n\t\t\tdp->d_ops->free_hdr_to_disk(fbp->b_addr, &freehdr);\n\t\t\txfs_dir2_free_log_header(args, fbp);\n\t\t}\n\t\t/*\n\t\t * Update the real value in the table.\n\t\t * We haven't allocated the data entry yet so this will\n\t\t * change again.\n\t\t */\n\t\thdr = dbp->b_addr;\n\t\tbf = dp->d_ops->data_bestfree_p(hdr);\n\t\tbests[findex] = bf[0].length;\n\t\tlogfree = 1;\n\t}\n\t/*\n\t * We had a data block so we don't have to make a new one.\n\t */\n\telse {\n\t\t/*\n\t\t * If just checking, we succeeded.\n\t\t */\n\t\tif (args->op_flags & XFS_DA_OP_JUSTCHECK)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * Read the data block in.\n\t\t */\n\t\terror = xfs_dir3_data_read(tp, dp,\n\t\t\t\t\t   xfs_dir2_db_to_da(args->geo, dbno),\n\t\t\t\t\t   -1, &dbp);\n\t\tif (error)\n\t\t\treturn error;\n\t\thdr = dbp->b_addr;\n\t\tbf = dp->d_ops->data_bestfree_p(hdr);\n\t\tlogfree = 0;\n\t}\n\tASSERT(be16_to_cpu(bf[0].length) >= length);\n\t/*\n\t * Point to the existing unused space.\n\t */\n\tdup = (xfs_dir2_data_unused_t *)\n\t      ((char *)hdr + be16_to_cpu(bf[0].offset));\n\tneedscan = needlog = 0;\n\t/*\n\t * Mark the first part of the unused space, inuse for us.\n\t */\n\txfs_dir2_data_use_free(args, dbp, dup,\n\t\t(xfs_dir2_data_aoff_t)((char *)dup - (char *)hdr), length,\n\t\t&needlog, &needscan);\n\t/*\n\t * Fill in the new entry and log it.\n\t */\n\tdep = (xfs_dir2_data_entry_t *)dup;\n\tdep->inumber = cpu_to_be64(args->inumber);\n\tdep->namelen = args->namelen;\n\tmemcpy(dep->name, args->name, dep->namelen);\n\tdp->d_ops->data_put_ftype(dep, args->filetype);\n\ttagp = dp->d_ops->data_entry_tag_p(dep);\n\t*tagp = cpu_to_be16((char *)dep - (char *)hdr);\n\txfs_dir2_data_log_entry(args, dbp, dep);\n\t/*\n\t * Rescan the block for bestfree if needed.\n\t */\n\tif (needscan)\n\t\txfs_dir2_data_freescan(dp, hdr, &needlog);\n\t/*\n\t * Log the data block header if needed.\n\t */\n\tif (needlog)\n\t\txfs_dir2_data_log_header(args, dbp);\n\t/*\n\t * If the freespace entry is now wrong, update it.\n\t */\n\tbests = dp->d_ops->free_bests_p(free); /* gcc is so stupid */\n\tif (be16_to_cpu(bests[findex]) != be16_to_cpu(bf[0].length)) {\n\t\tbests[findex] = bf[0].length;\n\t\tlogfree = 1;\n\t}\n\t/*\n\t * Log the freespace entry if needed.\n\t */\n\tif (logfree)\n\t\txfs_dir2_free_log_bests(args, fbp, findex, findex);\n\t/*\n\t * Return the data block and offset in args, then drop the data block.\n\t */\n\targs->blkno = (xfs_dablk_t)dbno;\n\targs->index = be16_to_cpu(*tagp);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);",
            "static int xfs_dir2_node_addname_int(xfs_da_args_t *args,\n\t\t\t\t     xfs_da_state_blk_t *fblk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);\nstatic int xfs_dir2_node_addname_int(xfs_da_args_t *args,\n\t\t\t\t     xfs_da_state_blk_t *fblk);\n\nstatic int\t\t\t\t\t/* error */\nxfs_dir2_node_addname_int(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\txfs_da_state_blk_t\t*fblk)\t\t/* optional freespace block */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_db_t\t\tdbno;\t\t/* data block number */\n\tstruct xfs_buf\t\t*dbp;\t\t/* data block buffer */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry pointer */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* data unused entry pointer */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_dir2_db_t\t\tfbno;\t\t/* freespace block number */\n\tstruct xfs_buf\t\t*fbp;\t\t/* freespace buffer */\n\tint\t\t\tfindex;\t\t/* freespace entry index */\n\txfs_dir2_free_t\t\t*free=NULL;\t/* freespace block structure */\n\txfs_dir2_db_t\t\tifbno;\t\t/* initial freespace block no */\n\txfs_dir2_db_t\t\tlastfbno=0;\t/* highest freespace block no */\n\tint\t\t\tlength;\t\t/* length of the new entry */\n\tint\t\t\tlogfree;\t/* need to log free entry */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tint\t\t\tneedlog;\t/* need to log data header */\n\tint\t\t\tneedscan;\t/* need to rescan data frees */\n\t__be16\t\t\t*tagp;\t\t/* data entry tag pointer */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\t__be16\t\t\t*bests;\n\tstruct xfs_dir3_icfree_hdr freehdr;\n\tstruct xfs_dir2_data_free *bf;\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\ttp = args->trans;\n\tlength = dp->d_ops->data_entsize(args->namelen);\n\t/*\n\t * If we came in with a freespace block that means that lookup\n\t * found an entry with our hash value.  This is the freespace\n\t * block for that data entry.\n\t */\n\tif (fblk) {\n\t\tfbp = fblk->bp;\n\t\t/*\n\t\t * Remember initial freespace block number.\n\t\t */\n\t\tifbno = fblk->blkno;\n\t\tfree = fbp->b_addr;\n\t\tfindex = fblk->index;\n\t\tbests = dp->d_ops->free_bests_p(free);\n\t\tdp->d_ops->free_hdr_from_disk(&freehdr, free);\n\n\t\t/*\n\t\t * This means the free entry showed that the data block had\n\t\t * space for our entry, so we remembered it.\n\t\t * Use that data block.\n\t\t */\n\t\tif (findex >= 0) {\n\t\t\tASSERT(findex < freehdr.nvalid);\n\t\t\tASSERT(be16_to_cpu(bests[findex]) != NULLDATAOFF);\n\t\t\tASSERT(be16_to_cpu(bests[findex]) >= length);\n\t\t\tdbno = freehdr.firstdb + findex;\n\t\t} else {\n\t\t\t/*\n\t\t\t * The data block looked at didn't have enough room.\n\t\t\t * We'll start at the beginning of the freespace entries.\n\t\t\t */\n\t\t\tdbno = -1;\n\t\t\tfindex = 0;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Didn't come in with a freespace block, so no data block.\n\t\t */\n\t\tifbno = dbno = -1;\n\t\tfbp = NULL;\n\t\tfindex = 0;\n\t}\n\n\t/*\n\t * If we don't have a data block yet, we're going to scan the\n\t * freespace blocks looking for one.  Figure out what the\n\t * highest freespace block number is.\n\t */\n\tif (dbno == -1) {\n\t\txfs_fileoff_t\tfo;\t\t/* freespace block number */\n\n\t\tif ((error = xfs_bmap_last_offset(dp, &fo, XFS_DATA_FORK)))\n\t\t\treturn error;\n\t\tlastfbno = xfs_dir2_da_to_db(args->geo, (xfs_dablk_t)fo);\n\t\tfbno = ifbno;\n\t}\n\t/*\n\t * While we haven't identified a data block, search the freeblock\n\t * data for a good data block.  If we find a null freeblock entry,\n\t * indicating a hole in the data blocks, remember that.\n\t */\n\twhile (dbno == -1) {\n\t\t/*\n\t\t * If we don't have a freeblock in hand, get the next one.\n\t\t */\n\t\tif (fbp == NULL) {\n\t\t\t/*\n\t\t\t * Happens the first time through unless lookup gave\n\t\t\t * us a freespace block to start with.\n\t\t\t */\n\t\t\tif (++fbno == 0)\n\t\t\t\tfbno = xfs_dir2_byte_to_db(args->geo,\n\t\t\t\t\t\t\tXFS_DIR2_FREE_OFFSET);\n\t\t\t/*\n\t\t\t * If it's ifbno we already looked at it.\n\t\t\t */\n\t\t\tif (fbno == ifbno)\n\t\t\t\tfbno++;\n\t\t\t/*\n\t\t\t * If it's off the end we're done.\n\t\t\t */\n\t\t\tif (fbno >= lastfbno)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * Read the block.  There can be holes in the\n\t\t\t * freespace blocks, so this might not succeed.\n\t\t\t * This should be really rare, so there's no reason\n\t\t\t * to avoid it.\n\t\t\t */\n\t\t\terror = xfs_dir2_free_try_read(tp, dp,\n\t\t\t\t\txfs_dir2_db_to_da(args->geo, fbno),\n\t\t\t\t\t&fbp);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (!fbp)\n\t\t\t\tcontinue;\n\t\t\tfree = fbp->b_addr;\n\t\t\tfindex = 0;\n\t\t}\n\t\t/*\n\t\t * Look at the current free entry.  Is it good enough?\n\t\t *\n\t\t * The bests initialisation should be where the bufer is read in\n\t\t * the above branch. But gcc is too stupid to realise that bests\n\t\t * and the freehdr are actually initialised if they are placed\n\t\t * there, so we have to do it here to avoid warnings. Blech.\n\t\t */\n\t\tbests = dp->d_ops->free_bests_p(free);\n\t\tdp->d_ops->free_hdr_from_disk(&freehdr, free);\n\t\tif (be16_to_cpu(bests[findex]) != NULLDATAOFF &&\n\t\t    be16_to_cpu(bests[findex]) >= length)\n\t\t\tdbno = freehdr.firstdb + findex;\n\t\telse {\n\t\t\t/*\n\t\t\t * Are we done with the freeblock?\n\t\t\t */\n\t\t\tif (++findex == freehdr.nvalid) {\n\t\t\t\t/*\n\t\t\t\t * Drop the block.\n\t\t\t\t */\n\t\t\t\txfs_trans_brelse(tp, fbp);\n\t\t\t\tfbp = NULL;\n\t\t\t\tif (fblk && fblk->bp)\n\t\t\t\t\tfblk->bp = NULL;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * If we don't have a data block, we need to allocate one and make\n\t * the freespace entries refer to it.\n\t */\n\tif (unlikely(dbno == -1)) {\n\t\t/*\n\t\t * Not allowed to allocate, return failure.\n\t\t */\n\t\tif ((args->op_flags & XFS_DA_OP_JUSTCHECK) || args->total == 0)\n\t\t\treturn -ENOSPC;\n\n\t\t/*\n\t\t * Allocate and initialize the new data block.\n\t\t */\n\t\tif (unlikely((error = xfs_dir2_grow_inode(args,\n\t\t\t\t\t\t\t XFS_DIR2_DATA_SPACE,\n\t\t\t\t\t\t\t &dbno)) ||\n\t\t    (error = xfs_dir3_data_init(args, dbno, &dbp))))\n\t\t\treturn error;\n\n\t\t/*\n\t\t * If (somehow) we have a freespace block, get rid of it.\n\t\t */\n\t\tif (fbp)\n\t\t\txfs_trans_brelse(tp, fbp);\n\t\tif (fblk && fblk->bp)\n\t\t\tfblk->bp = NULL;\n\n\t\t/*\n\t\t * Get the freespace block corresponding to the data block\n\t\t * that was just allocated.\n\t\t */\n\t\tfbno = dp->d_ops->db_to_fdb(args->geo, dbno);\n\t\terror = xfs_dir2_free_try_read(tp, dp,\n\t\t\t\t       xfs_dir2_db_to_da(args->geo, fbno),\n\t\t\t\t       &fbp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/*\n\t\t * If there wasn't a freespace block, the read will\n\t\t * return a NULL fbp.  Allocate and initialize a new one.\n\t\t */\n\t\tif (!fbp) {\n\t\t\terror = xfs_dir2_grow_inode(args, XFS_DIR2_FREE_SPACE,\n\t\t\t\t\t\t    &fbno);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\tif (dp->d_ops->db_to_fdb(args->geo, dbno) != fbno) {\n\t\t\t\txfs_alert(mp,\n\t\t\t\"%s: dir ino %llu needed freesp block %lld for\\n\"\n\t\t\t\"  data block %lld, got %lld ifbno %llu lastfbno %d\",\n\t\t\t\t\t__func__, (unsigned long long)dp->i_ino,\n\t\t\t\t\t(long long)dp->d_ops->db_to_fdb(\n\t\t\t\t\t\t\t\targs->geo, dbno),\n\t\t\t\t\t(long long)dbno, (long long)fbno,\n\t\t\t\t\t(unsigned long long)ifbno, lastfbno);\n\t\t\t\tif (fblk) {\n\t\t\t\t\txfs_alert(mp,\n\t\t\t\t\" fblk 0x%p blkno %llu index %d magic 0x%x\",\n\t\t\t\t\t\tfblk,\n\t\t\t\t\t\t(unsigned long long)fblk->blkno,\n\t\t\t\t\t\tfblk->index,\n\t\t\t\t\t\tfblk->magic);\n\t\t\t\t} else {\n\t\t\t\t\txfs_alert(mp, \" ... fblk is NULL\");\n\t\t\t\t}\n\t\t\t\tXFS_ERROR_REPORT(\"xfs_dir2_node_addname_int\",\n\t\t\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\t\t\treturn -EFSCORRUPTED;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Get a buffer for the new block.\n\t\t\t */\n\t\t\terror = xfs_dir3_free_get_buf(args, fbno, &fbp);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tfree = fbp->b_addr;\n\t\t\tbests = dp->d_ops->free_bests_p(free);\n\t\t\tdp->d_ops->free_hdr_from_disk(&freehdr, free);\n\n\t\t\t/*\n\t\t\t * Remember the first slot as our empty slot.\n\t\t\t */\n\t\t\tfreehdr.firstdb =\n\t\t\t\t(fbno - xfs_dir2_byte_to_db(args->geo,\n\t\t\t\t\t\t\tXFS_DIR2_FREE_OFFSET)) *\n\t\t\t\t\tdp->d_ops->free_max_bests(args->geo);\n\t\t} else {\n\t\t\tfree = fbp->b_addr;\n\t\t\tbests = dp->d_ops->free_bests_p(free);\n\t\t\tdp->d_ops->free_hdr_from_disk(&freehdr, free);\n\t\t}\n\n\t\t/*\n\t\t * Set the freespace block index from the data block number.\n\t\t */\n\t\tfindex = dp->d_ops->db_to_fdindex(args->geo, dbno);\n\t\t/*\n\t\t * If it's after the end of the current entries in the\n\t\t * freespace block, extend that table.\n\t\t */\n\t\tif (findex >= freehdr.nvalid) {\n\t\t\tASSERT(findex < dp->d_ops->free_max_bests(args->geo));\n\t\t\tfreehdr.nvalid = findex + 1;\n\t\t\t/*\n\t\t\t * Tag new entry so nused will go up.\n\t\t\t */\n\t\t\tbests[findex] = cpu_to_be16(NULLDATAOFF);\n\t\t}\n\t\t/*\n\t\t * If this entry was for an empty data block\n\t\t * (this should always be true) then update the header.\n\t\t */\n\t\tif (bests[findex] == cpu_to_be16(NULLDATAOFF)) {\n\t\t\tfreehdr.nused++;\n\t\t\tdp->d_ops->free_hdr_to_disk(fbp->b_addr, &freehdr);\n\t\t\txfs_dir2_free_log_header(args, fbp);\n\t\t}\n\t\t/*\n\t\t * Update the real value in the table.\n\t\t * We haven't allocated the data entry yet so this will\n\t\t * change again.\n\t\t */\n\t\thdr = dbp->b_addr;\n\t\tbf = dp->d_ops->data_bestfree_p(hdr);\n\t\tbests[findex] = bf[0].length;\n\t\tlogfree = 1;\n\t}\n\t/*\n\t * We had a data block so we don't have to make a new one.\n\t */\n\telse {\n\t\t/*\n\t\t * If just checking, we succeeded.\n\t\t */\n\t\tif (args->op_flags & XFS_DA_OP_JUSTCHECK)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * Read the data block in.\n\t\t */\n\t\terror = xfs_dir3_data_read(tp, dp,\n\t\t\t\t\t   xfs_dir2_db_to_da(args->geo, dbno),\n\t\t\t\t\t   -1, &dbp);\n\t\tif (error)\n\t\t\treturn error;\n\t\thdr = dbp->b_addr;\n\t\tbf = dp->d_ops->data_bestfree_p(hdr);\n\t\tlogfree = 0;\n\t}\n\tASSERT(be16_to_cpu(bf[0].length) >= length);\n\t/*\n\t * Point to the existing unused space.\n\t */\n\tdup = (xfs_dir2_data_unused_t *)\n\t      ((char *)hdr + be16_to_cpu(bf[0].offset));\n\tneedscan = needlog = 0;\n\t/*\n\t * Mark the first part of the unused space, inuse for us.\n\t */\n\txfs_dir2_data_use_free(args, dbp, dup,\n\t\t(xfs_dir2_data_aoff_t)((char *)dup - (char *)hdr), length,\n\t\t&needlog, &needscan);\n\t/*\n\t * Fill in the new entry and log it.\n\t */\n\tdep = (xfs_dir2_data_entry_t *)dup;\n\tdep->inumber = cpu_to_be64(args->inumber);\n\tdep->namelen = args->namelen;\n\tmemcpy(dep->name, args->name, dep->namelen);\n\tdp->d_ops->data_put_ftype(dep, args->filetype);\n\ttagp = dp->d_ops->data_entry_tag_p(dep);\n\t*tagp = cpu_to_be16((char *)dep - (char *)hdr);\n\txfs_dir2_data_log_entry(args, dbp, dep);\n\t/*\n\t * Rescan the block for bestfree if needed.\n\t */\n\tif (needscan)\n\t\txfs_dir2_data_freescan(dp, hdr, &needlog);\n\t/*\n\t * Log the data block header if needed.\n\t */\n\tif (needlog)\n\t\txfs_dir2_data_log_header(args, dbp);\n\t/*\n\t * If the freespace entry is now wrong, update it.\n\t */\n\tbests = dp->d_ops->free_bests_p(free); /* gcc is so stupid */\n\tif (be16_to_cpu(bests[findex]) != be16_to_cpu(bf[0].length)) {\n\t\tbests[findex] = bf[0].length;\n\t\tlogfree = 1;\n\t}\n\t/*\n\t * Log the freespace entry if needed.\n\t */\n\tif (logfree)\n\t\txfs_dir2_free_log_bests(args, fbp, findex, findex);\n\t/*\n\t * Return the data block and offset in args, then drop the data block.\n\t */\n\targs->blkno = (xfs_dablk_t)dbno;\n\targs->index = be16_to_cpu(*tagp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da3_node_lookup_int",
          "args": [
            "state",
            "&rval"
          ],
          "line": 1587
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_node_lookup_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "1445-1597",
          "snippet": "int\t\t\t\t\t\t\t/* error */\nxfs_da3_node_lookup_int(\n\tstruct xfs_da_state\t*state,\n\tint\t\t\t*result)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_blkinfo\t*curr;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\tstruct xfs_da_args\t*args;\n\txfs_dablk_t\t\tblkno;\n\txfs_dahash_t\t\thashval;\n\txfs_dahash_t\t\tbtreehashval;\n\tint\t\t\tprobe;\n\tint\t\t\tspan;\n\tint\t\t\tmax;\n\tint\t\t\terror;\n\tint\t\t\tretval;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\targs = state->args;\n\n\t/*\n\t * Descend thru the B-tree searching each level for the right\n\t * node to use, until the right hashval is found.\n\t */\n\tblkno = (args->whichfork == XFS_DATA_FORK)? args->geo->leafblk : 0;\n\tfor (blk = &state->path.blk[0], state->path.active = 1;\n\t\t\t state->path.active <= XFS_DA_NODE_MAXDEPTH;\n\t\t\t blk++, state->path.active++) {\n\t\t/*\n\t\t * Read the next node down in the tree.\n\t\t */\n\t\tblk->blkno = blkno;\n\t\terror = xfs_da3_node_read(args->trans, args->dp, blkno,\n\t\t\t\t\t-1, &blk->bp, args->whichfork);\n\t\tif (error) {\n\t\t\tblk->blkno = 0;\n\t\t\tstate->path.active--;\n\t\t\treturn error;\n\t\t}\n\t\tcurr = blk->bp->b_addr;\n\t\tblk->magic = be16_to_cpu(curr->magic);\n\n\t\tif (blk->magic == XFS_ATTR_LEAF_MAGIC ||\n\t\t    blk->magic == XFS_ATTR3_LEAF_MAGIC) {\n\t\t\tblk->magic = XFS_ATTR_LEAF_MAGIC;\n\t\t\tblk->hashval = xfs_attr_leaf_lasthash(blk->bp, NULL);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (blk->magic == XFS_DIR2_LEAFN_MAGIC ||\n\t\t    blk->magic == XFS_DIR3_LEAFN_MAGIC) {\n\t\t\tblk->magic = XFS_DIR2_LEAFN_MAGIC;\n\t\t\tblk->hashval = xfs_dir2_leafn_lasthash(args->dp,\n\t\t\t\t\t\t\t       blk->bp, NULL);\n\t\t\tbreak;\n\t\t}\n\n\t\tblk->magic = XFS_DA_NODE_MAGIC;\n\n\n\t\t/*\n\t\t * Search an intermediate node for a match.\n\t\t */\n\t\tnode = blk->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\tbtree = dp->d_ops->node_tree_p(node);\n\n\t\tmax = nodehdr.count;\n\t\tblk->hashval = be32_to_cpu(btree[max - 1].hashval);\n\n\t\t/*\n\t\t * Binary search.  (note: small blocks will skip loop)\n\t\t */\n\t\tprobe = span = max / 2;\n\t\thashval = args->hashval;\n\t\twhile (span > 4) {\n\t\t\tspan /= 2;\n\t\t\tbtreehashval = be32_to_cpu(btree[probe].hashval);\n\t\t\tif (btreehashval < hashval)\n\t\t\t\tprobe += span;\n\t\t\telse if (btreehashval > hashval)\n\t\t\t\tprobe -= span;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tASSERT((probe >= 0) && (probe < max));\n\t\tASSERT((span <= 4) ||\n\t\t\t(be32_to_cpu(btree[probe].hashval) == hashval));\n\n\t\t/*\n\t\t * Since we may have duplicate hashval's, find the first\n\t\t * matching hashval in the node.\n\t\t */\n\t\twhile (probe > 0 &&\n\t\t       be32_to_cpu(btree[probe].hashval) >= hashval) {\n\t\t\tprobe--;\n\t\t}\n\t\twhile (probe < max &&\n\t\t       be32_to_cpu(btree[probe].hashval) < hashval) {\n\t\t\tprobe++;\n\t\t}\n\n\t\t/*\n\t\t * Pick the right block to descend on.\n\t\t */\n\t\tif (probe == max) {\n\t\t\tblk->index = max - 1;\n\t\t\tblkno = be32_to_cpu(btree[max - 1].before);\n\t\t} else {\n\t\t\tblk->index = probe;\n\t\t\tblkno = be32_to_cpu(btree[probe].before);\n\t\t}\n\t}\n\n\t/*\n\t * A leaf block that ends in the hashval that we are interested in\n\t * (final hashval == search hashval) means that the next block may\n\t * contain more entries with the same hashval, shift upward to the\n\t * next leaf and keep searching.\n\t */\n\tfor (;;) {\n\t\tif (blk->magic == XFS_DIR2_LEAFN_MAGIC) {\n\t\t\tretval = xfs_dir2_leafn_lookup_int(blk->bp, args,\n\t\t\t\t\t\t\t&blk->index, state);\n\t\t} else if (blk->magic == XFS_ATTR_LEAF_MAGIC) {\n\t\t\tretval = xfs_attr3_leaf_lookup_int(blk->bp, args);\n\t\t\tblk->index = args->index;\n\t\t\targs->blkno = blk->blkno;\n\t\t} else {\n\t\t\tASSERT(0);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tif (((retval == -ENOENT) || (retval == -ENOATTR)) &&\n\t\t    (blk->hashval == args->hashval)) {\n\t\t\terror = xfs_da3_path_shift(state, &state->path, 1, 1,\n\t\t\t\t\t\t\t &retval);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (retval == 0) {\n\t\t\t\tcontinue;\n\t\t\t} else if (blk->magic == XFS_ATTR_LEAF_MAGIC) {\n\t\t\t\t/* path_shift() gives ENOENT */\n\t\t\t\tretval = -ENOATTR;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\t*result = retval;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_da3_node_split(xfs_da_state_t *state,\n\t\t\t\t\t    xfs_da_state_blk_t *existing_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *split_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *blk_to_add,\n\t\t\t\t\t    int treelevel,\n\t\t\t\t\t    int *result);",
            "STATIC int xfs_da3_node_toosmall(xfs_da_state_t *state, int *retval);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_da3_node_split(xfs_da_state_t *state,\n\t\t\t\t\t    xfs_da_state_blk_t *existing_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *split_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *blk_to_add,\n\t\t\t\t\t    int treelevel,\n\t\t\t\t\t    int *result);\nSTATIC int xfs_da3_node_toosmall(xfs_da_state_t *state, int *retval);\n\nint\t\t\t\t\t\t\t/* error */\nxfs_da3_node_lookup_int(\n\tstruct xfs_da_state\t*state,\n\tint\t\t\t*result)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_blkinfo\t*curr;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\tstruct xfs_da_args\t*args;\n\txfs_dablk_t\t\tblkno;\n\txfs_dahash_t\t\thashval;\n\txfs_dahash_t\t\tbtreehashval;\n\tint\t\t\tprobe;\n\tint\t\t\tspan;\n\tint\t\t\tmax;\n\tint\t\t\terror;\n\tint\t\t\tretval;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\targs = state->args;\n\n\t/*\n\t * Descend thru the B-tree searching each level for the right\n\t * node to use, until the right hashval is found.\n\t */\n\tblkno = (args->whichfork == XFS_DATA_FORK)? args->geo->leafblk : 0;\n\tfor (blk = &state->path.blk[0], state->path.active = 1;\n\t\t\t state->path.active <= XFS_DA_NODE_MAXDEPTH;\n\t\t\t blk++, state->path.active++) {\n\t\t/*\n\t\t * Read the next node down in the tree.\n\t\t */\n\t\tblk->blkno = blkno;\n\t\terror = xfs_da3_node_read(args->trans, args->dp, blkno,\n\t\t\t\t\t-1, &blk->bp, args->whichfork);\n\t\tif (error) {\n\t\t\tblk->blkno = 0;\n\t\t\tstate->path.active--;\n\t\t\treturn error;\n\t\t}\n\t\tcurr = blk->bp->b_addr;\n\t\tblk->magic = be16_to_cpu(curr->magic);\n\n\t\tif (blk->magic == XFS_ATTR_LEAF_MAGIC ||\n\t\t    blk->magic == XFS_ATTR3_LEAF_MAGIC) {\n\t\t\tblk->magic = XFS_ATTR_LEAF_MAGIC;\n\t\t\tblk->hashval = xfs_attr_leaf_lasthash(blk->bp, NULL);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (blk->magic == XFS_DIR2_LEAFN_MAGIC ||\n\t\t    blk->magic == XFS_DIR3_LEAFN_MAGIC) {\n\t\t\tblk->magic = XFS_DIR2_LEAFN_MAGIC;\n\t\t\tblk->hashval = xfs_dir2_leafn_lasthash(args->dp,\n\t\t\t\t\t\t\t       blk->bp, NULL);\n\t\t\tbreak;\n\t\t}\n\n\t\tblk->magic = XFS_DA_NODE_MAGIC;\n\n\n\t\t/*\n\t\t * Search an intermediate node for a match.\n\t\t */\n\t\tnode = blk->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\tbtree = dp->d_ops->node_tree_p(node);\n\n\t\tmax = nodehdr.count;\n\t\tblk->hashval = be32_to_cpu(btree[max - 1].hashval);\n\n\t\t/*\n\t\t * Binary search.  (note: small blocks will skip loop)\n\t\t */\n\t\tprobe = span = max / 2;\n\t\thashval = args->hashval;\n\t\twhile (span > 4) {\n\t\t\tspan /= 2;\n\t\t\tbtreehashval = be32_to_cpu(btree[probe].hashval);\n\t\t\tif (btreehashval < hashval)\n\t\t\t\tprobe += span;\n\t\t\telse if (btreehashval > hashval)\n\t\t\t\tprobe -= span;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tASSERT((probe >= 0) && (probe < max));\n\t\tASSERT((span <= 4) ||\n\t\t\t(be32_to_cpu(btree[probe].hashval) == hashval));\n\n\t\t/*\n\t\t * Since we may have duplicate hashval's, find the first\n\t\t * matching hashval in the node.\n\t\t */\n\t\twhile (probe > 0 &&\n\t\t       be32_to_cpu(btree[probe].hashval) >= hashval) {\n\t\t\tprobe--;\n\t\t}\n\t\twhile (probe < max &&\n\t\t       be32_to_cpu(btree[probe].hashval) < hashval) {\n\t\t\tprobe++;\n\t\t}\n\n\t\t/*\n\t\t * Pick the right block to descend on.\n\t\t */\n\t\tif (probe == max) {\n\t\t\tblk->index = max - 1;\n\t\t\tblkno = be32_to_cpu(btree[max - 1].before);\n\t\t} else {\n\t\t\tblk->index = probe;\n\t\t\tblkno = be32_to_cpu(btree[probe].before);\n\t\t}\n\t}\n\n\t/*\n\t * A leaf block that ends in the hashval that we are interested in\n\t * (final hashval == search hashval) means that the next block may\n\t * contain more entries with the same hashval, shift upward to the\n\t * next leaf and keep searching.\n\t */\n\tfor (;;) {\n\t\tif (blk->magic == XFS_DIR2_LEAFN_MAGIC) {\n\t\t\tretval = xfs_dir2_leafn_lookup_int(blk->bp, args,\n\t\t\t\t\t\t\t&blk->index, state);\n\t\t} else if (blk->magic == XFS_ATTR_LEAF_MAGIC) {\n\t\t\tretval = xfs_attr3_leaf_lookup_int(blk->bp, args);\n\t\t\tblk->index = args->index;\n\t\t\targs->blkno = blk->blkno;\n\t\t} else {\n\t\t\tASSERT(0);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tif (((retval == -ENOENT) || (retval == -ENOATTR)) &&\n\t\t    (blk->hashval == args->hashval)) {\n\t\t\terror = xfs_da3_path_shift(state, &state->path, 1, 1,\n\t\t\t\t\t\t\t &retval);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tif (retval == 0) {\n\t\t\t\tcontinue;\n\t\t\t} else if (blk->magic == XFS_ATTR_LEAF_MAGIC) {\n\t\t\t\t/* path_shift() gives ENOENT */\n\t\t\t\tretval = -ENOATTR;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\t*result = retval;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da_state_alloc",
          "args": [],
          "line": 1580
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_state_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "98-102",
          "snippet": "xfs_da_state_t *\nxfs_da_state_alloc(void)\n{\n\treturn kmem_zone_zalloc(xfs_da_state_zone, KM_NOFS);\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t *xfs_da_state_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t *xfs_da_state_zone;\n\nxfs_da_state_t *\nxfs_da_state_alloc(void)\n{\n\treturn kmem_zone_zalloc(xfs_da_state_zone, KM_NOFS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_dir2_node_addname",
          "args": [
            "args"
          ],
          "line": 1575
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);\nstatic int xfs_dir2_leafn_remove(xfs_da_args_t *args, struct xfs_buf *bp,\n\t\t\t\t int index, xfs_da_state_blk_t *dblk,\n\t\t\t\t int *rval);\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_node_addname(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\txfs_da_state_blk_t\t*blk;\t\t/* leaf block for insert */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\trval;\t\t/* sub-return value */\n\txfs_da_state_t\t\t*state;\t\t/* btree cursor */\n\n\ttrace_xfs_dir2_node_addname(args);\n\n\t/*\n\t * Allocate and initialize the state (btree cursor).\n\t */\n\tstate = xfs_da_state_alloc();\n\tstate->args = args;\n\tstate->mp = args->dp->i_mount;\n\t/*\n\t * Look up the name.  We're not supposed to find it, but\n\t * this gives us the insertion point.\n\t */\n\terror = xfs_da3_node_lookup_int(state, &rval);\n\tif (error)\n\t\trval = error;\n\tif (rval != -ENOENT) {\n\t\tgoto done;\n\t}\n\t/*\n\t * Add the data entry to a data block.\n\t * Extravalid is set to a freeblock found by lookup.\n\t */\n\trval = xfs_dir2_node_addname_int(args,\n\t\tstate->extravalid ? &state->extrablk : NULL);\n\tif (rval) {\n\t\tgoto done;\n\t}\n\tblk = &state->path.blk[state->path.active - 1];\n\tASSERT(blk->magic == XFS_DIR2_LEAFN_MAGIC);\n\t/*\n\t * Add the new leaf entry.\n\t */\n\trval = xfs_dir2_leafn_add(blk->bp, args, blk->index);\n\tif (rval == 0) {\n\t\t/*\n\t\t * It worked, fix the hash values up the btree.\n\t\t */\n\t\tif (!(args->op_flags & XFS_DA_OP_JUSTCHECK))\n\t\t\txfs_da3_fixhashpath(state, &state->path);\n\t} else {\n\t\t/*\n\t\t * It didn't work, we need to split the leaf block.\n\t\t */\n\t\tif (args->total == 0) {\n\t\t\tASSERT(rval == -ENOSPC);\n\t\t\tgoto done;\n\t\t}\n\t\t/*\n\t\t * Split the leaf block and insert the new entry.\n\t\t */\n\t\trval = xfs_da3_split(state);\n\t}\ndone:\n\txfs_da_state_free(state);\n\treturn rval;\n}"
  },
  {
    "function_name": "xfs_dir2_leafn_unbalance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
    "lines": "1504-1561",
    "snippet": "void\nxfs_dir2_leafn_unbalance(\n\txfs_da_state_t\t\t*state,\t\t/* cursor */\n\txfs_da_state_blk_t\t*drop_blk,\t/* dead block */\n\txfs_da_state_blk_t\t*save_blk)\t/* surviving block */\n{\n\txfs_da_args_t\t\t*args;\t\t/* operation arguments */\n\txfs_dir2_leaf_t\t\t*drop_leaf;\t/* dead leaf structure */\n\txfs_dir2_leaf_t\t\t*save_leaf;\t/* surviving leaf structure */\n\tstruct xfs_dir3_icleaf_hdr savehdr;\n\tstruct xfs_dir3_icleaf_hdr drophdr;\n\tstruct xfs_dir2_leaf_entry *sents;\n\tstruct xfs_dir2_leaf_entry *dents;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\targs = state->args;\n\tASSERT(drop_blk->magic == XFS_DIR2_LEAFN_MAGIC);\n\tASSERT(save_blk->magic == XFS_DIR2_LEAFN_MAGIC);\n\tdrop_leaf = drop_blk->bp->b_addr;\n\tsave_leaf = save_blk->bp->b_addr;\n\n\tdp->d_ops->leaf_hdr_from_disk(&savehdr, save_leaf);\n\tdp->d_ops->leaf_hdr_from_disk(&drophdr, drop_leaf);\n\tsents = dp->d_ops->leaf_ents_p(save_leaf);\n\tdents = dp->d_ops->leaf_ents_p(drop_leaf);\n\n\t/*\n\t * If there are any stale leaf entries, take this opportunity\n\t * to purge them.\n\t */\n\tif (drophdr.stale)\n\t\txfs_dir3_leaf_compact(args, &drophdr, drop_blk->bp);\n\tif (savehdr.stale)\n\t\txfs_dir3_leaf_compact(args, &savehdr, save_blk->bp);\n\n\t/*\n\t * Move the entries from drop to the appropriate end of save.\n\t */\n\tdrop_blk->hashval = be32_to_cpu(dents[drophdr.count - 1].hashval);\n\tif (xfs_dir2_leafn_order(dp, save_blk->bp, drop_blk->bp))\n\t\txfs_dir3_leafn_moveents(args, drop_blk->bp, &drophdr, dents, 0,\n\t\t\t\t\tsave_blk->bp, &savehdr, sents, 0,\n\t\t\t\t\tdrophdr.count);\n\telse\n\t\txfs_dir3_leafn_moveents(args, drop_blk->bp, &drophdr, dents, 0,\n\t\t\t\t\tsave_blk->bp, &savehdr, sents,\n\t\t\t\t\tsavehdr.count, drophdr.count);\n\tsave_blk->hashval = be32_to_cpu(sents[savehdr.count - 1].hashval);\n\n\t/* log the changes made when moving the entries */\n\tdp->d_ops->leaf_hdr_to_disk(save_leaf, &savehdr);\n\tdp->d_ops->leaf_hdr_to_disk(drop_leaf, &drophdr);\n\txfs_dir3_leaf_log_header(args, save_blk->bp);\n\txfs_dir3_leaf_log_header(args, drop_blk->bp);\n\n\txfs_dir3_leaf_check(dp, save_blk->bp);\n\txfs_dir3_leaf_check(dp, drop_blk->bp);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_check",
          "args": [
            "dp",
            "drop_blk->bp"
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_check",
          "args": [
            "dp",
            "save_blk->bp"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_log_header",
          "args": [
            "args",
            "drop_blk->bp"
          ],
          "line": 1557
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_leaf_log_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "1105-1120",
          "snippet": "void\nxfs_dir3_leaf_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t  (uint)((char *)&leaf->hdr - (char *)leaf),\n\t\t\t  args->dp->d_ops->leaf_hdr_size - 1);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nvoid\nxfs_dir3_leaf_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t  (uint)((char *)&leaf->hdr - (char *)leaf),\n\t\t\t  args->dp->d_ops->leaf_hdr_size - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_hdr_to_disk",
          "args": [
            "drop_leaf",
            "&drophdr"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_hdr_to_disk",
          "args": [
            "save_leaf",
            "&savehdr"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sents[savehdr.count - 1].hashval"
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leafn_moveents",
          "args": [
            "args",
            "drop_blk->bp",
            "&drophdr",
            "dents",
            "0",
            "save_blk->bp",
            "&savehdr",
            "sents",
            "savehdr.count",
            "drophdr.count"
          ],
          "line": 1548
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_leafn_moveents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
          "lines": "832-904",
          "snippet": "static void\nxfs_dir3_leafn_moveents(\n\txfs_da_args_t\t\t\t*args,\t/* operation arguments */\n\tstruct xfs_buf\t\t\t*bp_s,\t/* source */\n\tstruct xfs_dir3_icleaf_hdr\t*shdr,\n\tstruct xfs_dir2_leaf_entry\t*sents,\n\tint\t\t\t\tstart_s,/* source leaf index */\n\tstruct xfs_buf\t\t\t*bp_d,\t/* destination */\n\tstruct xfs_dir3_icleaf_hdr\t*dhdr,\n\tstruct xfs_dir2_leaf_entry\t*dents,\n\tint\t\t\t\tstart_d,/* destination leaf index */\n\tint\t\t\t\tcount)\t/* count of leaves to copy */\n{\n\tint\t\t\t\tstale;\t/* count stale leaves copied */\n\n\ttrace_xfs_dir2_leafn_moveents(args, start_s, start_d, count);\n\n\t/*\n\t * Silently return if nothing to do.\n\t */\n\tif (count == 0)\n\t\treturn;\n\n\t/*\n\t * If the destination index is not the end of the current\n\t * destination leaf entries, open up a hole in the destination\n\t * to hold the new entries.\n\t */\n\tif (start_d < dhdr->count) {\n\t\tmemmove(&dents[start_d + count], &dents[start_d],\n\t\t\t(dhdr->count - start_d) * sizeof(xfs_dir2_leaf_entry_t));\n\t\txfs_dir3_leaf_log_ents(args, bp_d, start_d + count,\n\t\t\t\t       count + dhdr->count - 1);\n\t}\n\t/*\n\t * If the source has stale leaves, count the ones in the copy range\n\t * so we can update the header correctly.\n\t */\n\tif (shdr->stale) {\n\t\tint\ti;\t\t\t/* temp leaf index */\n\n\t\tfor (i = start_s, stale = 0; i < start_s + count; i++) {\n\t\t\tif (sents[i].address ==\n\t\t\t\t\tcpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\t\tstale++;\n\t\t}\n\t} else\n\t\tstale = 0;\n\t/*\n\t * Copy the leaf entries from source to destination.\n\t */\n\tmemcpy(&dents[start_d], &sents[start_s],\n\t\tcount * sizeof(xfs_dir2_leaf_entry_t));\n\txfs_dir3_leaf_log_ents(args, bp_d, start_d, start_d + count - 1);\n\n\t/*\n\t * If there are source entries after the ones we copied,\n\t * delete the ones we copied by sliding the next ones down.\n\t */\n\tif (start_s + count < shdr->count) {\n\t\tmemmove(&sents[start_s], &sents[start_s + count],\n\t\t\tcount * sizeof(xfs_dir2_leaf_entry_t));\n\t\txfs_dir3_leaf_log_ents(args, bp_s, start_s, start_s + count - 1);\n\t}\n\n\t/*\n\t * Update the headers and log them.\n\t */\n\tshdr->count -= count;\n\tshdr->stale -= stale;\n\tdhdr->count += count;\n\tdhdr->stale += stale;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);\n\nstatic void\nxfs_dir3_leafn_moveents(\n\txfs_da_args_t\t\t\t*args,\t/* operation arguments */\n\tstruct xfs_buf\t\t\t*bp_s,\t/* source */\n\tstruct xfs_dir3_icleaf_hdr\t*shdr,\n\tstruct xfs_dir2_leaf_entry\t*sents,\n\tint\t\t\t\tstart_s,/* source leaf index */\n\tstruct xfs_buf\t\t\t*bp_d,\t/* destination */\n\tstruct xfs_dir3_icleaf_hdr\t*dhdr,\n\tstruct xfs_dir2_leaf_entry\t*dents,\n\tint\t\t\t\tstart_d,/* destination leaf index */\n\tint\t\t\t\tcount)\t/* count of leaves to copy */\n{\n\tint\t\t\t\tstale;\t/* count stale leaves copied */\n\n\ttrace_xfs_dir2_leafn_moveents(args, start_s, start_d, count);\n\n\t/*\n\t * Silently return if nothing to do.\n\t */\n\tif (count == 0)\n\t\treturn;\n\n\t/*\n\t * If the destination index is not the end of the current\n\t * destination leaf entries, open up a hole in the destination\n\t * to hold the new entries.\n\t */\n\tif (start_d < dhdr->count) {\n\t\tmemmove(&dents[start_d + count], &dents[start_d],\n\t\t\t(dhdr->count - start_d) * sizeof(xfs_dir2_leaf_entry_t));\n\t\txfs_dir3_leaf_log_ents(args, bp_d, start_d + count,\n\t\t\t\t       count + dhdr->count - 1);\n\t}\n\t/*\n\t * If the source has stale leaves, count the ones in the copy range\n\t * so we can update the header correctly.\n\t */\n\tif (shdr->stale) {\n\t\tint\ti;\t\t\t/* temp leaf index */\n\n\t\tfor (i = start_s, stale = 0; i < start_s + count; i++) {\n\t\t\tif (sents[i].address ==\n\t\t\t\t\tcpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\t\tstale++;\n\t\t}\n\t} else\n\t\tstale = 0;\n\t/*\n\t * Copy the leaf entries from source to destination.\n\t */\n\tmemcpy(&dents[start_d], &sents[start_s],\n\t\tcount * sizeof(xfs_dir2_leaf_entry_t));\n\txfs_dir3_leaf_log_ents(args, bp_d, start_d, start_d + count - 1);\n\n\t/*\n\t * If there are source entries after the ones we copied,\n\t * delete the ones we copied by sliding the next ones down.\n\t */\n\tif (start_s + count < shdr->count) {\n\t\tmemmove(&sents[start_s], &sents[start_s + count],\n\t\t\tcount * sizeof(xfs_dir2_leaf_entry_t));\n\t\txfs_dir3_leaf_log_ents(args, bp_s, start_s, start_s + count - 1);\n\t}\n\n\t/*\n\t * Update the headers and log them.\n\t */\n\tshdr->count -= count;\n\tshdr->stale -= stale;\n\tdhdr->count += count;\n\tdhdr->stale += stale;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leafn_order",
          "args": [
            "dp",
            "save_blk->bp",
            "drop_blk->bp"
          ],
          "line": 1543
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leafn_order",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
          "lines": "910-934",
          "snippet": "int\t\t\t\t\t\t/* sort order */\nxfs_dir2_leafn_order(\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_buf\t\t*leaf1_bp,\t\t/* leaf1 buffer */\n\tstruct xfs_buf\t\t*leaf2_bp)\t\t/* leaf2 buffer */\n{\n\tstruct xfs_dir2_leaf\t*leaf1 = leaf1_bp->b_addr;\n\tstruct xfs_dir2_leaf\t*leaf2 = leaf2_bp->b_addr;\n\tstruct xfs_dir2_leaf_entry *ents1;\n\tstruct xfs_dir2_leaf_entry *ents2;\n\tstruct xfs_dir3_icleaf_hdr hdr1;\n\tstruct xfs_dir3_icleaf_hdr hdr2;\n\n\tdp->d_ops->leaf_hdr_from_disk(&hdr1, leaf1);\n\tdp->d_ops->leaf_hdr_from_disk(&hdr2, leaf2);\n\tents1 = dp->d_ops->leaf_ents_p(leaf1);\n\tents2 = dp->d_ops->leaf_ents_p(leaf2);\n\n\tif (hdr1.count > 0 && hdr2.count > 0 &&\n\t    (be32_to_cpu(ents2[0].hashval) < be32_to_cpu(ents1[0].hashval) ||\n\t     be32_to_cpu(ents2[hdr2.count - 1].hashval) <\n\t\t\t\tbe32_to_cpu(ents1[hdr1.count - 1].hashval)))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* sort order */\nxfs_dir2_leafn_order(\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_buf\t\t*leaf1_bp,\t\t/* leaf1 buffer */\n\tstruct xfs_buf\t\t*leaf2_bp)\t\t/* leaf2 buffer */\n{\n\tstruct xfs_dir2_leaf\t*leaf1 = leaf1_bp->b_addr;\n\tstruct xfs_dir2_leaf\t*leaf2 = leaf2_bp->b_addr;\n\tstruct xfs_dir2_leaf_entry *ents1;\n\tstruct xfs_dir2_leaf_entry *ents2;\n\tstruct xfs_dir3_icleaf_hdr hdr1;\n\tstruct xfs_dir3_icleaf_hdr hdr2;\n\n\tdp->d_ops->leaf_hdr_from_disk(&hdr1, leaf1);\n\tdp->d_ops->leaf_hdr_from_disk(&hdr2, leaf2);\n\tents1 = dp->d_ops->leaf_ents_p(leaf1);\n\tents2 = dp->d_ops->leaf_ents_p(leaf2);\n\n\tif (hdr1.count > 0 && hdr2.count > 0 &&\n\t    (be32_to_cpu(ents2[0].hashval) < be32_to_cpu(ents1[0].hashval) ||\n\t     be32_to_cpu(ents2[hdr2.count - 1].hashval) <\n\t\t\t\tbe32_to_cpu(ents1[hdr1.count - 1].hashval)))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "dents[drophdr.count - 1].hashval"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_compact",
          "args": [
            "args",
            "&savehdr",
            "save_blk->bp"
          ],
          "line": 1537
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_leaf_compact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "907-952",
          "snippet": "void\nxfs_dir3_leaf_compact(\n\txfs_da_args_t\t*args,\t\t/* operation arguments */\n\tstruct xfs_dir3_icleaf_hdr *leafhdr,\n\tstruct xfs_buf\t*bp)\t\t/* leaf buffer */\n{\n\tint\t\tfrom;\t\t/* source leaf index */\n\txfs_dir2_leaf_t\t*leaf;\t\t/* leaf structure */\n\tint\t\tloglow;\t\t/* first leaf entry to log */\n\tint\t\tto;\t\t/* target leaf index */\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_inode *dp = args->dp;\n\n\tleaf = bp->b_addr;\n\tif (!leafhdr->stale)\n\t\treturn;\n\n\t/*\n\t * Compress out the stale entries in place.\n\t */\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\tfor (from = to = 0, loglow = -1; from < leafhdr->count; from++) {\n\t\tif (ents[from].address == cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\tcontinue;\n\t\t/*\n\t\t * Only actually copy the entries that are different.\n\t\t */\n\t\tif (from > to) {\n\t\t\tif (loglow == -1)\n\t\t\t\tloglow = to;\n\t\t\tents[to] = ents[from];\n\t\t}\n\t\tto++;\n\t}\n\t/*\n\t * Update and log the header, log the leaf entries.\n\t */\n\tASSERT(leafhdr->stale == from - to);\n\tleafhdr->count -= leafhdr->stale;\n\tleafhdr->stale = 0;\n\n\tdp->d_ops->leaf_hdr_to_disk(leaf, leafhdr);\n\txfs_dir3_leaf_log_header(args, bp);\n\tif (loglow != -1)\n\t\txfs_dir3_leaf_log_ents(args, bp, loglow, to - 1);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nvoid\nxfs_dir3_leaf_compact(\n\txfs_da_args_t\t*args,\t\t/* operation arguments */\n\tstruct xfs_dir3_icleaf_hdr *leafhdr,\n\tstruct xfs_buf\t*bp)\t\t/* leaf buffer */\n{\n\tint\t\tfrom;\t\t/* source leaf index */\n\txfs_dir2_leaf_t\t*leaf;\t\t/* leaf structure */\n\tint\t\tloglow;\t\t/* first leaf entry to log */\n\tint\t\tto;\t\t/* target leaf index */\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_inode *dp = args->dp;\n\n\tleaf = bp->b_addr;\n\tif (!leafhdr->stale)\n\t\treturn;\n\n\t/*\n\t * Compress out the stale entries in place.\n\t */\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\tfor (from = to = 0, loglow = -1; from < leafhdr->count; from++) {\n\t\tif (ents[from].address == cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\tcontinue;\n\t\t/*\n\t\t * Only actually copy the entries that are different.\n\t\t */\n\t\tif (from > to) {\n\t\t\tif (loglow == -1)\n\t\t\t\tloglow = to;\n\t\t\tents[to] = ents[from];\n\t\t}\n\t\tto++;\n\t}\n\t/*\n\t * Update and log the header, log the leaf entries.\n\t */\n\tASSERT(leafhdr->stale == from - to);\n\tleafhdr->count -= leafhdr->stale;\n\tleafhdr->stale = 0;\n\n\tdp->d_ops->leaf_hdr_to_disk(leaf, leafhdr);\n\txfs_dir3_leaf_log_header(args, bp);\n\tif (loglow != -1)\n\t\txfs_dir3_leaf_log_ents(args, bp, loglow, to - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_ents_p",
          "args": [
            "drop_leaf"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_ents_p",
          "args": [
            "save_leaf"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_hdr_from_disk",
          "args": [
            "&drophdr",
            "drop_leaf"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_hdr_from_disk",
          "args": [
            "&savehdr",
            "save_leaf"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "save_blk->magic == XFS_DIR2_LEAFN_MAGIC"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "drop_blk->magic == XFS_DIR2_LEAFN_MAGIC"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dir2_leafn_unbalance(\n\txfs_da_state_t\t\t*state,\t\t/* cursor */\n\txfs_da_state_blk_t\t*drop_blk,\t/* dead block */\n\txfs_da_state_blk_t\t*save_blk)\t/* surviving block */\n{\n\txfs_da_args_t\t\t*args;\t\t/* operation arguments */\n\txfs_dir2_leaf_t\t\t*drop_leaf;\t/* dead leaf structure */\n\txfs_dir2_leaf_t\t\t*save_leaf;\t/* surviving leaf structure */\n\tstruct xfs_dir3_icleaf_hdr savehdr;\n\tstruct xfs_dir3_icleaf_hdr drophdr;\n\tstruct xfs_dir2_leaf_entry *sents;\n\tstruct xfs_dir2_leaf_entry *dents;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\targs = state->args;\n\tASSERT(drop_blk->magic == XFS_DIR2_LEAFN_MAGIC);\n\tASSERT(save_blk->magic == XFS_DIR2_LEAFN_MAGIC);\n\tdrop_leaf = drop_blk->bp->b_addr;\n\tsave_leaf = save_blk->bp->b_addr;\n\n\tdp->d_ops->leaf_hdr_from_disk(&savehdr, save_leaf);\n\tdp->d_ops->leaf_hdr_from_disk(&drophdr, drop_leaf);\n\tsents = dp->d_ops->leaf_ents_p(save_leaf);\n\tdents = dp->d_ops->leaf_ents_p(drop_leaf);\n\n\t/*\n\t * If there are any stale leaf entries, take this opportunity\n\t * to purge them.\n\t */\n\tif (drophdr.stale)\n\t\txfs_dir3_leaf_compact(args, &drophdr, drop_blk->bp);\n\tif (savehdr.stale)\n\t\txfs_dir3_leaf_compact(args, &savehdr, save_blk->bp);\n\n\t/*\n\t * Move the entries from drop to the appropriate end of save.\n\t */\n\tdrop_blk->hashval = be32_to_cpu(dents[drophdr.count - 1].hashval);\n\tif (xfs_dir2_leafn_order(dp, save_blk->bp, drop_blk->bp))\n\t\txfs_dir3_leafn_moveents(args, drop_blk->bp, &drophdr, dents, 0,\n\t\t\t\t\tsave_blk->bp, &savehdr, sents, 0,\n\t\t\t\t\tdrophdr.count);\n\telse\n\t\txfs_dir3_leafn_moveents(args, drop_blk->bp, &drophdr, dents, 0,\n\t\t\t\t\tsave_blk->bp, &savehdr, sents,\n\t\t\t\t\tsavehdr.count, drophdr.count);\n\tsave_blk->hashval = be32_to_cpu(sents[savehdr.count - 1].hashval);\n\n\t/* log the changes made when moving the entries */\n\tdp->d_ops->leaf_hdr_to_disk(save_leaf, &savehdr);\n\tdp->d_ops->leaf_hdr_to_disk(drop_leaf, &drophdr);\n\txfs_dir3_leaf_log_header(args, save_blk->bp);\n\txfs_dir3_leaf_log_header(args, drop_blk->bp);\n\n\txfs_dir3_leaf_check(dp, save_blk->bp);\n\txfs_dir3_leaf_check(dp, drop_blk->bp);\n}"
  },
  {
    "function_name": "xfs_dir2_leafn_toosmall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
    "lines": "1373-1498",
    "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_leafn_toosmall(\n\txfs_da_state_t\t\t*state,\t\t/* btree cursor */\n\tint\t\t\t*action)\t/* resulting action to take */\n{\n\txfs_da_state_blk_t\t*blk;\t\t/* leaf block */\n\txfs_dablk_t\t\tblkno;\t\t/* leaf block number */\n\tstruct xfs_buf\t\t*bp;\t\t/* leaf buffer */\n\tint\t\t\tbytes;\t\t/* bytes in use */\n\tint\t\t\tcount;\t\t/* leaf live entry count */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tforward;\t/* sibling block direction */\n\tint\t\t\ti;\t\t/* sibling counter */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\tint\t\t\trval;\t\t/* result from path_shift */\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\t/*\n\t * Check for the degenerate case of the block being over 50% full.\n\t * If so, it's not worth even looking to see if we might be able\n\t * to coalesce with a sibling.\n\t */\n\tblk = &state->path.blk[state->path.active - 1];\n\tleaf = blk->bp->b_addr;\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\txfs_dir3_leaf_check(dp, blk->bp);\n\n\tcount = leafhdr.count - leafhdr.stale;\n\tbytes = dp->d_ops->leaf_hdr_size + count * sizeof(ents[0]);\n\tif (bytes > (state->args->geo->blksize >> 1)) {\n\t\t/*\n\t\t * Blk over 50%, don't try to join.\n\t\t */\n\t\t*action = 0;\n\t\treturn 0;\n\t}\n\t/*\n\t * Check for the degenerate case of the block being empty.\n\t * If the block is empty, we'll simply delete it, no need to\n\t * coalesce it with a sibling block.  We choose (arbitrarily)\n\t * to merge with the forward block unless it is NULL.\n\t */\n\tif (count == 0) {\n\t\t/*\n\t\t * Make altpath point to the block we want to keep and\n\t\t * path point to the block we want to drop (this one).\n\t\t */\n\t\tforward = (leafhdr.forw != 0);\n\t\tmemcpy(&state->altpath, &state->path, sizeof(state->path));\n\t\terror = xfs_da3_path_shift(state, &state->altpath, forward, 0,\n\t\t\t&rval);\n\t\tif (error)\n\t\t\treturn error;\n\t\t*action = rval ? 2 : 0;\n\t\treturn 0;\n\t}\n\t/*\n\t * Examine each sibling block to see if we can coalesce with\n\t * at least 25% free space to spare.  We need to figure out\n\t * whether to merge with the forward or the backward block.\n\t * We prefer coalescing with the lower numbered sibling so as\n\t * to shrink a directory over time.\n\t */\n\tforward = leafhdr.forw < leafhdr.back;\n\tfor (i = 0, bp = NULL; i < 2; forward = !forward, i++) {\n\t\tstruct xfs_dir3_icleaf_hdr hdr2;\n\n\t\tblkno = forward ? leafhdr.forw : leafhdr.back;\n\t\tif (blkno == 0)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Read the sibling leaf block.\n\t\t */\n\t\terror = xfs_dir3_leafn_read(state->args->trans, dp,\n\t\t\t\t\t    blkno, -1, &bp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/*\n\t\t * Count bytes in the two blocks combined.\n\t\t */\n\t\tcount = leafhdr.count - leafhdr.stale;\n\t\tbytes = state->args->geo->blksize -\n\t\t\t(state->args->geo->blksize >> 2);\n\n\t\tleaf = bp->b_addr;\n\t\tdp->d_ops->leaf_hdr_from_disk(&hdr2, leaf);\n\t\tents = dp->d_ops->leaf_ents_p(leaf);\n\t\tcount += hdr2.count - hdr2.stale;\n\t\tbytes -= count * sizeof(ents[0]);\n\n\t\t/*\n\t\t * Fits with at least 25% to spare.\n\t\t */\n\t\tif (bytes >= 0)\n\t\t\tbreak;\n\t\txfs_trans_brelse(state->args->trans, bp);\n\t}\n\t/*\n\t * Didn't like either block, give up.\n\t */\n\tif (i >= 2) {\n\t\t*action = 0;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Make altpath point to the block we want to keep (the lower\n\t * numbered block) and path point to the block we want to drop.\n\t */\n\tmemcpy(&state->altpath, &state->path, sizeof(state->path));\n\tif (blkno < blk->blkno)\n\t\terror = xfs_da3_path_shift(state, &state->altpath, forward, 0,\n\t\t\t&rval);\n\telse\n\t\terror = xfs_da3_path_shift(state, &state->path, forward, 0,\n\t\t\t&rval);\n\tif (error) {\n\t\treturn error;\n\t}\n\t*action = rval ? 0 : 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int xfs_dir2_leafn_remove(xfs_da_args_t *args, struct xfs_buf *bp,\n\t\t\t\t int index, xfs_da_state_blk_t *dblk,\n\t\t\t\t int *rval);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_da3_path_shift",
          "args": [
            "state",
            "&state->path",
            "forward",
            "0",
            "&rval"
          ],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_path_shift",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "1811-1932",
          "snippet": "int\t\t\t\t\t\t\t/* error */\nxfs_da3_path_shift(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_path *path,\n\tint\t\t\tforward,\n\tint\t\t\trelease,\n\tint\t\t\t*result)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_blkinfo\t*info;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_args\t*args;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\txfs_dablk_t\t\tblkno = 0;\n\tint\t\t\tlevel;\n\tint\t\t\terror;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_path_shift(state->args);\n\n\t/*\n\t * Roll up the Btree looking for the first block where our\n\t * current index is not at the edge of the block.  Note that\n\t * we skip the bottom layer because we want the sibling block.\n\t */\n\targs = state->args;\n\tASSERT(args != NULL);\n\tASSERT(path != NULL);\n\tASSERT((path->active > 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\n\tlevel = (path->active-1) - 1;\t/* skip bottom layer in path */\n\tfor (blk = &path->blk[level]; level >= 0; blk--, level--) {\n\t\tnode = blk->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\tbtree = dp->d_ops->node_tree_p(node);\n\n\t\tif (forward && (blk->index < nodehdr.count - 1)) {\n\t\t\tblk->index++;\n\t\t\tblkno = be32_to_cpu(btree[blk->index].before);\n\t\t\tbreak;\n\t\t} else if (!forward && (blk->index > 0)) {\n\t\t\tblk->index--;\n\t\t\tblkno = be32_to_cpu(btree[blk->index].before);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (level < 0) {\n\t\t*result = -ENOENT;\t/* we're out of our tree */\n\t\tASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Roll down the edge of the subtree until we reach the\n\t * same depth we were at originally.\n\t */\n\tfor (blk++, level++; level < path->active; blk++, level++) {\n\t\t/*\n\t\t * Release the old block.\n\t\t * (if it's dirty, trans won't actually let go)\n\t\t */\n\t\tif (release)\n\t\t\txfs_trans_brelse(args->trans, blk->bp);\n\n\t\t/*\n\t\t * Read the next child block.\n\t\t */\n\t\tblk->blkno = blkno;\n\t\terror = xfs_da3_node_read(args->trans, dp, blkno, -1,\n\t\t\t\t\t&blk->bp, args->whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t\tinfo = blk->bp->b_addr;\n\t\tASSERT(info->magic == cpu_to_be16(XFS_DA_NODE_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_DA3_NODE_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\n\n\t\t/*\n\t\t * Note: we flatten the magic number to a single type so we\n\t\t * don't have to compare against crc/non-crc types elsewhere.\n\t\t */\n\t\tswitch (be16_to_cpu(info->magic)) {\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\tcase XFS_DA3_NODE_MAGIC:\n\t\t\tblk->magic = XFS_DA_NODE_MAGIC;\n\t\t\tnode = (xfs_da_intnode_t *)info;\n\t\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\t\tbtree = dp->d_ops->node_tree_p(node);\n\t\t\tblk->hashval = be32_to_cpu(btree[nodehdr.count - 1].hashval);\n\t\t\tif (forward)\n\t\t\t\tblk->index = 0;\n\t\t\telse\n\t\t\t\tblk->index = nodehdr.count - 1;\n\t\t\tblkno = be32_to_cpu(btree[blk->index].before);\n\t\t\tbreak;\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tcase XFS_ATTR3_LEAF_MAGIC:\n\t\t\tblk->magic = XFS_ATTR_LEAF_MAGIC;\n\t\t\tASSERT(level == path->active-1);\n\t\t\tblk->index = 0;\n\t\t\tblk->hashval = xfs_attr_leaf_lasthash(blk->bp, NULL);\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tcase XFS_DIR3_LEAFN_MAGIC:\n\t\t\tblk->magic = XFS_DIR2_LEAFN_MAGIC;\n\t\t\tASSERT(level == path->active-1);\n\t\t\tblk->index = 0;\n\t\t\tblk->hashval = xfs_dir2_leafn_lasthash(args->dp,\n\t\t\t\t\t\t\t       blk->bp, NULL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t}\n\t*result = 0;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_da3_node_split(xfs_da_state_t *state,\n\t\t\t\t\t    xfs_da_state_blk_t *existing_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *split_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *blk_to_add,\n\t\t\t\t\t    int treelevel,\n\t\t\t\t\t    int *result);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_da3_node_split(xfs_da_state_t *state,\n\t\t\t\t\t    xfs_da_state_blk_t *existing_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *split_blk,\n\t\t\t\t\t    xfs_da_state_blk_t *blk_to_add,\n\t\t\t\t\t    int treelevel,\n\t\t\t\t\t    int *result);\n\nint\t\t\t\t\t\t\t/* error */\nxfs_da3_path_shift(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_path *path,\n\tint\t\t\tforward,\n\tint\t\t\trelease,\n\tint\t\t\t*result)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_blkinfo\t*info;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_args\t*args;\n\tstruct xfs_da_node_entry *btree;\n\tstruct xfs_da3_icnode_hdr nodehdr;\n\txfs_dablk_t\t\tblkno = 0;\n\tint\t\t\tlevel;\n\tint\t\t\terror;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\ttrace_xfs_da_path_shift(state->args);\n\n\t/*\n\t * Roll up the Btree looking for the first block where our\n\t * current index is not at the edge of the block.  Note that\n\t * we skip the bottom layer because we want the sibling block.\n\t */\n\targs = state->args;\n\tASSERT(args != NULL);\n\tASSERT(path != NULL);\n\tASSERT((path->active > 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\n\tlevel = (path->active-1) - 1;\t/* skip bottom layer in path */\n\tfor (blk = &path->blk[level]; level >= 0; blk--, level--) {\n\t\tnode = blk->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\tbtree = dp->d_ops->node_tree_p(node);\n\n\t\tif (forward && (blk->index < nodehdr.count - 1)) {\n\t\t\tblk->index++;\n\t\t\tblkno = be32_to_cpu(btree[blk->index].before);\n\t\t\tbreak;\n\t\t} else if (!forward && (blk->index > 0)) {\n\t\t\tblk->index--;\n\t\t\tblkno = be32_to_cpu(btree[blk->index].before);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (level < 0) {\n\t\t*result = -ENOENT;\t/* we're out of our tree */\n\t\tASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Roll down the edge of the subtree until we reach the\n\t * same depth we were at originally.\n\t */\n\tfor (blk++, level++; level < path->active; blk++, level++) {\n\t\t/*\n\t\t * Release the old block.\n\t\t * (if it's dirty, trans won't actually let go)\n\t\t */\n\t\tif (release)\n\t\t\txfs_trans_brelse(args->trans, blk->bp);\n\n\t\t/*\n\t\t * Read the next child block.\n\t\t */\n\t\tblk->blkno = blkno;\n\t\terror = xfs_da3_node_read(args->trans, dp, blkno, -1,\n\t\t\t\t\t&blk->bp, args->whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t\tinfo = blk->bp->b_addr;\n\t\tASSERT(info->magic == cpu_to_be16(XFS_DA_NODE_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_DA3_NODE_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC) ||\n\t\t       info->magic == cpu_to_be16(XFS_ATTR3_LEAF_MAGIC));\n\n\n\t\t/*\n\t\t * Note: we flatten the magic number to a single type so we\n\t\t * don't have to compare against crc/non-crc types elsewhere.\n\t\t */\n\t\tswitch (be16_to_cpu(info->magic)) {\n\t\tcase XFS_DA_NODE_MAGIC:\n\t\tcase XFS_DA3_NODE_MAGIC:\n\t\t\tblk->magic = XFS_DA_NODE_MAGIC;\n\t\t\tnode = (xfs_da_intnode_t *)info;\n\t\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\t\tbtree = dp->d_ops->node_tree_p(node);\n\t\t\tblk->hashval = be32_to_cpu(btree[nodehdr.count - 1].hashval);\n\t\t\tif (forward)\n\t\t\t\tblk->index = 0;\n\t\t\telse\n\t\t\t\tblk->index = nodehdr.count - 1;\n\t\t\tblkno = be32_to_cpu(btree[blk->index].before);\n\t\t\tbreak;\n\t\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tcase XFS_ATTR3_LEAF_MAGIC:\n\t\t\tblk->magic = XFS_ATTR_LEAF_MAGIC;\n\t\t\tASSERT(level == path->active-1);\n\t\t\tblk->index = 0;\n\t\t\tblk->hashval = xfs_attr_leaf_lasthash(blk->bp, NULL);\n\t\t\tbreak;\n\t\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tcase XFS_DIR3_LEAFN_MAGIC:\n\t\t\tblk->magic = XFS_DIR2_LEAFN_MAGIC;\n\t\t\tASSERT(level == path->active-1);\n\t\t\tblk->index = 0;\n\t\t\tblk->hashval = xfs_dir2_leafn_lasthash(args->dp,\n\t\t\t\t\t\t\t       blk->bp, NULL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\t}\n\t*result = 0;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&state->altpath",
            "&state->path",
            "sizeof(state->path)"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "state->args->trans",
            "bp"
          ],
          "line": 1472
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_ents_p",
          "args": [
            "leaf"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_hdr_from_disk",
          "args": [
            "&hdr2",
            "leaf"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leafn_read",
          "args": [
            "state->args->trans",
            "dp",
            "blkno",
            "-1",
            "&bp"
          ],
          "line": 1449
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_leafn_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "271-286",
          "snippet": "int\nxfs_dir3_leafn_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tfbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, fbno, mappedbno, bpp,\n\t\t\t\tXFS_DATA_FORK, &xfs_dir3_leafn_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_DIR_LEAFN_BUF);\n\treturn err;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_dir3_leafn_buf_ops = {\n\t.verify_read = xfs_dir3_leafn_read_verify,\n\t.verify_write = xfs_dir3_leafn_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_dir3_leafn_buf_ops = {\n\t.verify_read = xfs_dir3_leafn_read_verify,\n\t.verify_write = xfs_dir3_leafn_write_verify,\n};\n\nint\nxfs_dir3_leafn_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tfbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, fbno, mappedbno, bpp,\n\t\t\t\tXFS_DATA_FORK, &xfs_dir3_leafn_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_DIR_LEAFN_BUF);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&state->altpath",
            "&state->path",
            "sizeof(state->path)"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_check",
          "args": [
            "dp",
            "blk->bp"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_ents_p",
          "args": [
            "leaf"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_hdr_from_disk",
          "args": [
            "&leafhdr",
            "leaf"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int xfs_dir2_leafn_remove(xfs_da_args_t *args, struct xfs_buf *bp,\n\t\t\t\t int index, xfs_da_state_blk_t *dblk,\n\t\t\t\t int *rval);\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_leafn_toosmall(\n\txfs_da_state_t\t\t*state,\t\t/* btree cursor */\n\tint\t\t\t*action)\t/* resulting action to take */\n{\n\txfs_da_state_blk_t\t*blk;\t\t/* leaf block */\n\txfs_dablk_t\t\tblkno;\t\t/* leaf block number */\n\tstruct xfs_buf\t\t*bp;\t\t/* leaf buffer */\n\tint\t\t\tbytes;\t\t/* bytes in use */\n\tint\t\t\tcount;\t\t/* leaf live entry count */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tforward;\t/* sibling block direction */\n\tint\t\t\ti;\t\t/* sibling counter */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\tint\t\t\trval;\t\t/* result from path_shift */\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\t/*\n\t * Check for the degenerate case of the block being over 50% full.\n\t * If so, it's not worth even looking to see if we might be able\n\t * to coalesce with a sibling.\n\t */\n\tblk = &state->path.blk[state->path.active - 1];\n\tleaf = blk->bp->b_addr;\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\txfs_dir3_leaf_check(dp, blk->bp);\n\n\tcount = leafhdr.count - leafhdr.stale;\n\tbytes = dp->d_ops->leaf_hdr_size + count * sizeof(ents[0]);\n\tif (bytes > (state->args->geo->blksize >> 1)) {\n\t\t/*\n\t\t * Blk over 50%, don't try to join.\n\t\t */\n\t\t*action = 0;\n\t\treturn 0;\n\t}\n\t/*\n\t * Check for the degenerate case of the block being empty.\n\t * If the block is empty, we'll simply delete it, no need to\n\t * coalesce it with a sibling block.  We choose (arbitrarily)\n\t * to merge with the forward block unless it is NULL.\n\t */\n\tif (count == 0) {\n\t\t/*\n\t\t * Make altpath point to the block we want to keep and\n\t\t * path point to the block we want to drop (this one).\n\t\t */\n\t\tforward = (leafhdr.forw != 0);\n\t\tmemcpy(&state->altpath, &state->path, sizeof(state->path));\n\t\terror = xfs_da3_path_shift(state, &state->altpath, forward, 0,\n\t\t\t&rval);\n\t\tif (error)\n\t\t\treturn error;\n\t\t*action = rval ? 2 : 0;\n\t\treturn 0;\n\t}\n\t/*\n\t * Examine each sibling block to see if we can coalesce with\n\t * at least 25% free space to spare.  We need to figure out\n\t * whether to merge with the forward or the backward block.\n\t * We prefer coalescing with the lower numbered sibling so as\n\t * to shrink a directory over time.\n\t */\n\tforward = leafhdr.forw < leafhdr.back;\n\tfor (i = 0, bp = NULL; i < 2; forward = !forward, i++) {\n\t\tstruct xfs_dir3_icleaf_hdr hdr2;\n\n\t\tblkno = forward ? leafhdr.forw : leafhdr.back;\n\t\tif (blkno == 0)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Read the sibling leaf block.\n\t\t */\n\t\terror = xfs_dir3_leafn_read(state->args->trans, dp,\n\t\t\t\t\t    blkno, -1, &bp);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\t/*\n\t\t * Count bytes in the two blocks combined.\n\t\t */\n\t\tcount = leafhdr.count - leafhdr.stale;\n\t\tbytes = state->args->geo->blksize -\n\t\t\t(state->args->geo->blksize >> 2);\n\n\t\tleaf = bp->b_addr;\n\t\tdp->d_ops->leaf_hdr_from_disk(&hdr2, leaf);\n\t\tents = dp->d_ops->leaf_ents_p(leaf);\n\t\tcount += hdr2.count - hdr2.stale;\n\t\tbytes -= count * sizeof(ents[0]);\n\n\t\t/*\n\t\t * Fits with at least 25% to spare.\n\t\t */\n\t\tif (bytes >= 0)\n\t\t\tbreak;\n\t\txfs_trans_brelse(state->args->trans, bp);\n\t}\n\t/*\n\t * Didn't like either block, give up.\n\t */\n\tif (i >= 2) {\n\t\t*action = 0;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Make altpath point to the block we want to keep (the lower\n\t * numbered block) and path point to the block we want to drop.\n\t */\n\tmemcpy(&state->altpath, &state->path, sizeof(state->path));\n\tif (blkno < blk->blkno)\n\t\terror = xfs_da3_path_shift(state, &state->altpath, forward, 0,\n\t\t\t&rval);\n\telse\n\t\terror = xfs_da3_path_shift(state, &state->path, forward, 0,\n\t\t\t&rval);\n\tif (error) {\n\t\treturn error;\n\t}\n\t*action = rval ? 0 : 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_dir2_leafn_split",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
    "lines": "1307-1362",
    "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_leafn_split(\n\txfs_da_state_t\t\t*state,\t\t/* btree cursor */\n\txfs_da_state_blk_t\t*oldblk,\t/* original block */\n\txfs_da_state_blk_t\t*newblk)\t/* newly created block */\n{\n\txfs_da_args_t\t\t*args;\t\t/* operation arguments */\n\txfs_dablk_t\t\tblkno;\t\t/* new leaf block number */\n\tint\t\t\terror;\t\t/* error return value */\n\tstruct xfs_inode\t*dp;\n\n\t/*\n\t * Allocate space for a new leaf node.\n\t */\n\targs = state->args;\n\tdp = args->dp;\n\tASSERT(oldblk->magic == XFS_DIR2_LEAFN_MAGIC);\n\terror = xfs_da_grow_inode(args, &blkno);\n\tif (error) {\n\t\treturn error;\n\t}\n\t/*\n\t * Initialize the new leaf block.\n\t */\n\terror = xfs_dir3_leaf_get_buf(args, xfs_dir2_da_to_db(args->geo, blkno),\n\t\t\t\t      &newblk->bp, XFS_DIR2_LEAFN_MAGIC);\n\tif (error)\n\t\treturn error;\n\n\tnewblk->blkno = blkno;\n\tnewblk->magic = XFS_DIR2_LEAFN_MAGIC;\n\t/*\n\t * Rebalance the entries across the two leaves, link the new\n\t * block into the leaves.\n\t */\n\txfs_dir2_leafn_rebalance(state, oldblk, newblk);\n\terror = xfs_da3_blk_link(state, oldblk, newblk);\n\tif (error) {\n\t\treturn error;\n\t}\n\t/*\n\t * Insert the new entry in the correct block.\n\t */\n\tif (state->inleaf)\n\t\terror = xfs_dir2_leafn_add(oldblk->bp, args, oldblk->index);\n\telse\n\t\terror = xfs_dir2_leafn_add(newblk->bp, args, newblk->index);\n\t/*\n\t * Update last hashval in each block since we added the name.\n\t */\n\toldblk->hashval = xfs_dir2_leafn_lasthash(dp, oldblk->bp, NULL);\n\tnewblk->hashval = xfs_dir2_leafn_lasthash(dp, newblk->bp, NULL);\n\txfs_dir3_leaf_check(dp, oldblk->bp);\n\txfs_dir3_leaf_check(dp, newblk->bp);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_check",
          "args": [
            "dp",
            "newblk->bp"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_check",
          "args": [
            "dp",
            "oldblk->bp"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leafn_lasthash",
          "args": [
            "dp",
            "newblk->bp",
            "NULL"
          ],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leafn_lasthash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
          "lines": "479-501",
          "snippet": "xfs_dahash_t\t\t\t\t\t/* hash value */\nxfs_dir2_leafn_lasthash(\n\tstruct xfs_inode *dp,\n\tstruct xfs_buf\t*bp,\t\t\t/* leaf buffer */\n\tint\t\t*count)\t\t\t/* count of entries in leaf */\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\n\tASSERT(leafhdr.magic == XFS_DIR2_LEAFN_MAGIC ||\n\t       leafhdr.magic == XFS_DIR3_LEAFN_MAGIC);\n\n\tif (count)\n\t\t*count = leafhdr.count;\n\tif (!leafhdr.count)\n\t\treturn 0;\n\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\treturn be32_to_cpu(ents[leafhdr.count - 1].hashval);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_dahash_t\t\t\t\t\t/* hash value */\nxfs_dir2_leafn_lasthash(\n\tstruct xfs_inode *dp,\n\tstruct xfs_buf\t*bp,\t\t\t/* leaf buffer */\n\tint\t\t*count)\t\t\t/* count of entries in leaf */\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\n\tASSERT(leafhdr.magic == XFS_DIR2_LEAFN_MAGIC ||\n\t       leafhdr.magic == XFS_DIR3_LEAFN_MAGIC);\n\n\tif (count)\n\t\t*count = leafhdr.count;\n\tif (!leafhdr.count)\n\t\treturn 0;\n\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\treturn be32_to_cpu(ents[leafhdr.count - 1].hashval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leafn_add",
          "args": [
            "newblk->bp",
            "args",
            "newblk->index"
          ],
          "line": 1353
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leafn_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
          "lines": "372-453",
          "snippet": "static int\t\t\t\t\t/* error */\nxfs_dir2_leafn_add(\n\tstruct xfs_buf\t\t*bp,\t\t/* leaf buffer */\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tint\t\t\tindex)\t\t/* insertion pt for new entry */\n{\n\tint\t\t\tcompact;\t/* compacting stale leaves */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\thighstale;\t/* next stale entry */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\tint\t\t\tlfloghigh;\t/* high leaf entry logging */\n\tint\t\t\tlfloglow;\t/* low leaf entry logging */\n\tint\t\t\tlowstale;\t/* previous stale entry */\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\tstruct xfs_dir2_leaf_entry *ents;\n\n\ttrace_xfs_dir2_leafn_add(args, index);\n\n\tdp = args->dp;\n\tleaf = bp->b_addr;\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\n\t/*\n\t * Quick check just to make sure we are not going to index\n\t * into other peoples memory\n\t */\n\tif (index < 0)\n\t\treturn -EFSCORRUPTED;\n\n\t/*\n\t * If there are already the maximum number of leaf entries in\n\t * the block, if there are no stale entries it won't fit.\n\t * Caller will do a split.  If there are stale entries we'll do\n\t * a compact.\n\t */\n\n\tif (leafhdr.count == dp->d_ops->leaf_max_ents(args->geo)) {\n\t\tif (!leafhdr.stale)\n\t\t\treturn -ENOSPC;\n\t\tcompact = leafhdr.stale > 1;\n\t} else\n\t\tcompact = 0;\n\tASSERT(index == 0 || be32_to_cpu(ents[index - 1].hashval) <= args->hashval);\n\tASSERT(index == leafhdr.count ||\n\t       be32_to_cpu(ents[index].hashval) >= args->hashval);\n\n\tif (args->op_flags & XFS_DA_OP_JUSTCHECK)\n\t\treturn 0;\n\n\t/*\n\t * Compact out all but one stale leaf entry.  Leaves behind\n\t * the entry closest to index.\n\t */\n\tif (compact)\n\t\txfs_dir3_leaf_compact_x1(&leafhdr, ents, &index, &lowstale,\n\t\t\t\t\t &highstale, &lfloglow, &lfloghigh);\n\telse if (leafhdr.stale) {\n\t\t/*\n\t\t * Set impossible logging indices for this case.\n\t\t */\n\t\tlfloglow = leafhdr.count;\n\t\tlfloghigh = -1;\n\t}\n\n\t/*\n\t * Insert the new entry, log everything.\n\t */\n\tlep = xfs_dir3_leaf_find_entry(&leafhdr, ents, index, compact, lowstale,\n\t\t\t\t       highstale, &lfloglow, &lfloghigh);\n\n\tlep->hashval = cpu_to_be32(args->hashval);\n\tlep->address = cpu_to_be32(xfs_dir2_db_off_to_dataptr(args->geo,\n\t\t\t\targs->blkno, args->index));\n\n\tdp->d_ops->leaf_hdr_to_disk(leaf, &leafhdr);\n\txfs_dir3_leaf_log_header(args, bp);\n\txfs_dir3_leaf_log_ents(args, bp, lfloglow, lfloghigh);\n\txfs_dir3_leaf_check(dp, bp);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);\n\nstatic int\t\t\t\t\t/* error */\nxfs_dir2_leafn_add(\n\tstruct xfs_buf\t\t*bp,\t\t/* leaf buffer */\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tint\t\t\tindex)\t\t/* insertion pt for new entry */\n{\n\tint\t\t\tcompact;\t/* compacting stale leaves */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\thighstale;\t/* next stale entry */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\tint\t\t\tlfloghigh;\t/* high leaf entry logging */\n\tint\t\t\tlfloglow;\t/* low leaf entry logging */\n\tint\t\t\tlowstale;\t/* previous stale entry */\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\tstruct xfs_dir2_leaf_entry *ents;\n\n\ttrace_xfs_dir2_leafn_add(args, index);\n\n\tdp = args->dp;\n\tleaf = bp->b_addr;\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\n\t/*\n\t * Quick check just to make sure we are not going to index\n\t * into other peoples memory\n\t */\n\tif (index < 0)\n\t\treturn -EFSCORRUPTED;\n\n\t/*\n\t * If there are already the maximum number of leaf entries in\n\t * the block, if there are no stale entries it won't fit.\n\t * Caller will do a split.  If there are stale entries we'll do\n\t * a compact.\n\t */\n\n\tif (leafhdr.count == dp->d_ops->leaf_max_ents(args->geo)) {\n\t\tif (!leafhdr.stale)\n\t\t\treturn -ENOSPC;\n\t\tcompact = leafhdr.stale > 1;\n\t} else\n\t\tcompact = 0;\n\tASSERT(index == 0 || be32_to_cpu(ents[index - 1].hashval) <= args->hashval);\n\tASSERT(index == leafhdr.count ||\n\t       be32_to_cpu(ents[index].hashval) >= args->hashval);\n\n\tif (args->op_flags & XFS_DA_OP_JUSTCHECK)\n\t\treturn 0;\n\n\t/*\n\t * Compact out all but one stale leaf entry.  Leaves behind\n\t * the entry closest to index.\n\t */\n\tif (compact)\n\t\txfs_dir3_leaf_compact_x1(&leafhdr, ents, &index, &lowstale,\n\t\t\t\t\t &highstale, &lfloglow, &lfloghigh);\n\telse if (leafhdr.stale) {\n\t\t/*\n\t\t * Set impossible logging indices for this case.\n\t\t */\n\t\tlfloglow = leafhdr.count;\n\t\tlfloghigh = -1;\n\t}\n\n\t/*\n\t * Insert the new entry, log everything.\n\t */\n\tlep = xfs_dir3_leaf_find_entry(&leafhdr, ents, index, compact, lowstale,\n\t\t\t\t       highstale, &lfloglow, &lfloghigh);\n\n\tlep->hashval = cpu_to_be32(args->hashval);\n\tlep->address = cpu_to_be32(xfs_dir2_db_off_to_dataptr(args->geo,\n\t\t\t\targs->blkno, args->index));\n\n\tdp->d_ops->leaf_hdr_to_disk(leaf, &leafhdr);\n\txfs_dir3_leaf_log_header(args, bp);\n\txfs_dir3_leaf_log_ents(args, bp, lfloglow, lfloghigh);\n\txfs_dir3_leaf_check(dp, bp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da3_blk_link",
          "args": [
            "state",
            "oldblk",
            "newblk"
          ],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da3_blk_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "1638-1726",
          "snippet": "int\t\t\t\t\t\t\t/* error */\nxfs_da3_blk_link(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*old_blk,\n\tstruct xfs_da_state_blk\t*new_blk)\n{\n\tstruct xfs_da_blkinfo\t*old_info;\n\tstruct xfs_da_blkinfo\t*new_info;\n\tstruct xfs_da_blkinfo\t*tmp_info;\n\tstruct xfs_da_args\t*args;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\tbefore = 0;\n\tint\t\t\terror;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\t/*\n\t * Set up environment.\n\t */\n\targs = state->args;\n\tASSERT(args != NULL);\n\told_info = old_blk->bp->b_addr;\n\tnew_info = new_blk->bp->b_addr;\n\tASSERT(old_blk->magic == XFS_DA_NODE_MAGIC ||\n\t       old_blk->magic == XFS_DIR2_LEAFN_MAGIC ||\n\t       old_blk->magic == XFS_ATTR_LEAF_MAGIC);\n\n\tswitch (old_blk->magic) {\n\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tbefore = xfs_attr_leaf_order(old_blk->bp, new_blk->bp);\n\t\tbreak;\n\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tbefore = xfs_dir2_leafn_order(dp, old_blk->bp, new_blk->bp);\n\t\tbreak;\n\tcase XFS_DA_NODE_MAGIC:\n\t\tbefore = xfs_da3_node_order(dp, old_blk->bp, new_blk->bp);\n\t\tbreak;\n\t}\n\n\t/*\n\t * Link blocks in appropriate order.\n\t */\n\tif (before) {\n\t\t/*\n\t\t * Link new block in before existing block.\n\t\t */\n\t\ttrace_xfs_da_link_before(args);\n\t\tnew_info->forw = cpu_to_be32(old_blk->blkno);\n\t\tnew_info->back = old_info->back;\n\t\tif (old_info->back) {\n\t\t\terror = xfs_da3_node_read(args->trans, dp,\n\t\t\t\t\t\tbe32_to_cpu(old_info->back),\n\t\t\t\t\t\t-1, &bp, args->whichfork);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tASSERT(bp != NULL);\n\t\t\ttmp_info = bp->b_addr;\n\t\t\tASSERT(tmp_info->magic == old_info->magic);\n\t\t\tASSERT(be32_to_cpu(tmp_info->forw) == old_blk->blkno);\n\t\t\ttmp_info->forw = cpu_to_be32(new_blk->blkno);\n\t\t\txfs_trans_log_buf(args->trans, bp, 0, sizeof(*tmp_info)-1);\n\t\t}\n\t\told_info->back = cpu_to_be32(new_blk->blkno);\n\t} else {\n\t\t/*\n\t\t * Link new block in after existing block.\n\t\t */\n\t\ttrace_xfs_da_link_after(args);\n\t\tnew_info->forw = old_info->forw;\n\t\tnew_info->back = cpu_to_be32(old_blk->blkno);\n\t\tif (old_info->forw) {\n\t\t\terror = xfs_da3_node_read(args->trans, dp,\n\t\t\t\t\t\tbe32_to_cpu(old_info->forw),\n\t\t\t\t\t\t-1, &bp, args->whichfork);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tASSERT(bp != NULL);\n\t\t\ttmp_info = bp->b_addr;\n\t\t\tASSERT(tmp_info->magic == old_info->magic);\n\t\t\tASSERT(be32_to_cpu(tmp_info->back) == old_blk->blkno);\n\t\t\ttmp_info->back = cpu_to_be32(new_blk->blkno);\n\t\t\txfs_trans_log_buf(args->trans, bp, 0, sizeof(*tmp_info)-1);\n\t\t}\n\t\told_info->forw = cpu_to_be32(new_blk->blkno);\n\t}\n\n\txfs_trans_log_buf(args->trans, old_blk->bp, 0, sizeof(*tmp_info) - 1);\n\txfs_trans_log_buf(args->trans, new_blk->bp, 0, sizeof(*tmp_info) - 1);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t\t/* error */\nxfs_da3_blk_link(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_blk\t*old_blk,\n\tstruct xfs_da_state_blk\t*new_blk)\n{\n\tstruct xfs_da_blkinfo\t*old_info;\n\tstruct xfs_da_blkinfo\t*new_info;\n\tstruct xfs_da_blkinfo\t*tmp_info;\n\tstruct xfs_da_args\t*args;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\tbefore = 0;\n\tint\t\t\terror;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\t/*\n\t * Set up environment.\n\t */\n\targs = state->args;\n\tASSERT(args != NULL);\n\told_info = old_blk->bp->b_addr;\n\tnew_info = new_blk->bp->b_addr;\n\tASSERT(old_blk->magic == XFS_DA_NODE_MAGIC ||\n\t       old_blk->magic == XFS_DIR2_LEAFN_MAGIC ||\n\t       old_blk->magic == XFS_ATTR_LEAF_MAGIC);\n\n\tswitch (old_blk->magic) {\n\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tbefore = xfs_attr_leaf_order(old_blk->bp, new_blk->bp);\n\t\tbreak;\n\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tbefore = xfs_dir2_leafn_order(dp, old_blk->bp, new_blk->bp);\n\t\tbreak;\n\tcase XFS_DA_NODE_MAGIC:\n\t\tbefore = xfs_da3_node_order(dp, old_blk->bp, new_blk->bp);\n\t\tbreak;\n\t}\n\n\t/*\n\t * Link blocks in appropriate order.\n\t */\n\tif (before) {\n\t\t/*\n\t\t * Link new block in before existing block.\n\t\t */\n\t\ttrace_xfs_da_link_before(args);\n\t\tnew_info->forw = cpu_to_be32(old_blk->blkno);\n\t\tnew_info->back = old_info->back;\n\t\tif (old_info->back) {\n\t\t\terror = xfs_da3_node_read(args->trans, dp,\n\t\t\t\t\t\tbe32_to_cpu(old_info->back),\n\t\t\t\t\t\t-1, &bp, args->whichfork);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tASSERT(bp != NULL);\n\t\t\ttmp_info = bp->b_addr;\n\t\t\tASSERT(tmp_info->magic == old_info->magic);\n\t\t\tASSERT(be32_to_cpu(tmp_info->forw) == old_blk->blkno);\n\t\t\ttmp_info->forw = cpu_to_be32(new_blk->blkno);\n\t\t\txfs_trans_log_buf(args->trans, bp, 0, sizeof(*tmp_info)-1);\n\t\t}\n\t\told_info->back = cpu_to_be32(new_blk->blkno);\n\t} else {\n\t\t/*\n\t\t * Link new block in after existing block.\n\t\t */\n\t\ttrace_xfs_da_link_after(args);\n\t\tnew_info->forw = old_info->forw;\n\t\tnew_info->back = cpu_to_be32(old_blk->blkno);\n\t\tif (old_info->forw) {\n\t\t\terror = xfs_da3_node_read(args->trans, dp,\n\t\t\t\t\t\tbe32_to_cpu(old_info->forw),\n\t\t\t\t\t\t-1, &bp, args->whichfork);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tASSERT(bp != NULL);\n\t\t\ttmp_info = bp->b_addr;\n\t\t\tASSERT(tmp_info->magic == old_info->magic);\n\t\t\tASSERT(be32_to_cpu(tmp_info->back) == old_blk->blkno);\n\t\t\ttmp_info->back = cpu_to_be32(new_blk->blkno);\n\t\t\txfs_trans_log_buf(args->trans, bp, 0, sizeof(*tmp_info)-1);\n\t\t}\n\t\told_info->forw = cpu_to_be32(new_blk->blkno);\n\t}\n\n\txfs_trans_log_buf(args->trans, old_blk->bp, 0, sizeof(*tmp_info) - 1);\n\txfs_trans_log_buf(args->trans, new_blk->bp, 0, sizeof(*tmp_info) - 1);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leafn_rebalance",
          "args": [
            "state",
            "oldblk",
            "newblk"
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leafn_rebalance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
          "lines": "943-1062",
          "snippet": "static void\nxfs_dir2_leafn_rebalance(\n\txfs_da_state_t\t\t*state,\t\t/* btree cursor */\n\txfs_da_state_blk_t\t*blk1,\t\t/* first btree block */\n\txfs_da_state_blk_t\t*blk2)\t\t/* second btree block */\n{\n\txfs_da_args_t\t\t*args;\t\t/* operation arguments */\n\tint\t\t\tcount;\t\t/* count (& direction) leaves */\n\tint\t\t\tisleft;\t\t/* new goes in left leaf */\n\txfs_dir2_leaf_t\t\t*leaf1;\t\t/* first leaf structure */\n\txfs_dir2_leaf_t\t\t*leaf2;\t\t/* second leaf structure */\n\tint\t\t\tmid;\t\t/* midpoint leaf index */\n#if defined(DEBUG) || defined(XFS_WARN)\n\tint\t\t\toldstale;\t/* old count of stale leaves */\n#endif\n\tint\t\t\toldsum;\t\t/* old total leaf count */\n\tint\t\t\tswap;\t\t/* swapped leaf blocks */\n\tstruct xfs_dir2_leaf_entry *ents1;\n\tstruct xfs_dir2_leaf_entry *ents2;\n\tstruct xfs_dir3_icleaf_hdr hdr1;\n\tstruct xfs_dir3_icleaf_hdr hdr2;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\targs = state->args;\n\t/*\n\t * If the block order is wrong, swap the arguments.\n\t */\n\tif ((swap = xfs_dir2_leafn_order(dp, blk1->bp, blk2->bp))) {\n\t\txfs_da_state_blk_t\t*tmp;\t/* temp for block swap */\n\n\t\ttmp = blk1;\n\t\tblk1 = blk2;\n\t\tblk2 = tmp;\n\t}\n\tleaf1 = blk1->bp->b_addr;\n\tleaf2 = blk2->bp->b_addr;\n\tdp->d_ops->leaf_hdr_from_disk(&hdr1, leaf1);\n\tdp->d_ops->leaf_hdr_from_disk(&hdr2, leaf2);\n\tents1 = dp->d_ops->leaf_ents_p(leaf1);\n\tents2 = dp->d_ops->leaf_ents_p(leaf2);\n\n\toldsum = hdr1.count + hdr2.count;\n#if defined(DEBUG) || defined(XFS_WARN)\n\toldstale = hdr1.stale + hdr2.stale;\n#endif\n\tmid = oldsum >> 1;\n\n\t/*\n\t * If the old leaf count was odd then the new one will be even,\n\t * so we need to divide the new count evenly.\n\t */\n\tif (oldsum & 1) {\n\t\txfs_dahash_t\tmidhash;\t/* middle entry hash value */\n\n\t\tif (mid >= hdr1.count)\n\t\t\tmidhash = be32_to_cpu(ents2[mid - hdr1.count].hashval);\n\t\telse\n\t\t\tmidhash = be32_to_cpu(ents1[mid].hashval);\n\t\tisleft = args->hashval <= midhash;\n\t}\n\t/*\n\t * If the old count is even then the new count is odd, so there's\n\t * no preferred side for the new entry.\n\t * Pick the left one.\n\t */\n\telse\n\t\tisleft = 1;\n\t/*\n\t * Calculate moved entry count.  Positive means left-to-right,\n\t * negative means right-to-left.  Then move the entries.\n\t */\n\tcount = hdr1.count - mid + (isleft == 0);\n\tif (count > 0)\n\t\txfs_dir3_leafn_moveents(args, blk1->bp, &hdr1, ents1,\n\t\t\t\t\thdr1.count - count, blk2->bp,\n\t\t\t\t\t&hdr2, ents2, 0, count);\n\telse if (count < 0)\n\t\txfs_dir3_leafn_moveents(args, blk2->bp, &hdr2, ents2, 0,\n\t\t\t\t\tblk1->bp, &hdr1, ents1,\n\t\t\t\t\thdr1.count, count);\n\n\tASSERT(hdr1.count + hdr2.count == oldsum);\n\tASSERT(hdr1.stale + hdr2.stale == oldstale);\n\n\t/* log the changes made when moving the entries */\n\tdp->d_ops->leaf_hdr_to_disk(leaf1, &hdr1);\n\tdp->d_ops->leaf_hdr_to_disk(leaf2, &hdr2);\n\txfs_dir3_leaf_log_header(args, blk1->bp);\n\txfs_dir3_leaf_log_header(args, blk2->bp);\n\n\txfs_dir3_leaf_check(dp, blk1->bp);\n\txfs_dir3_leaf_check(dp, blk2->bp);\n\n\t/*\n\t * Mark whether we're inserting into the old or new leaf.\n\t */\n\tif (hdr1.count < hdr2.count)\n\t\tstate->inleaf = swap;\n\telse if (hdr1.count > hdr2.count)\n\t\tstate->inleaf = !swap;\n\telse\n\t\tstate->inleaf = swap ^ (blk1->index <= hdr1.count);\n\t/*\n\t * Adjust the expected index for insertion.\n\t */\n\tif (!state->inleaf)\n\t\tblk2->index = blk1->index - hdr1.count;\n\n\t/*\n\t * Finally sanity check just to make sure we are not returning a\n\t * negative index\n\t */\n\tif (blk2->index < 0) {\n\t\tstate->inleaf = 1;\n\t\tblk2->index = 0;\n\t\txfs_alert(dp->i_mount,\n\t\"%s: picked the wrong leaf? reverting original leaf: blk1->index %d\",\n\t\t\t__func__, blk1->index);\n\t}\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);",
            "static void xfs_dir2_leafn_rebalance(xfs_da_state_t *state,\n\t\t\t\t     xfs_da_state_blk_t *blk1,\n\t\t\t\t     xfs_da_state_blk_t *blk2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);\nstatic void xfs_dir2_leafn_rebalance(xfs_da_state_t *state,\n\t\t\t\t     xfs_da_state_blk_t *blk1,\n\t\t\t\t     xfs_da_state_blk_t *blk2);\n\nstatic void\nxfs_dir2_leafn_rebalance(\n\txfs_da_state_t\t\t*state,\t\t/* btree cursor */\n\txfs_da_state_blk_t\t*blk1,\t\t/* first btree block */\n\txfs_da_state_blk_t\t*blk2)\t\t/* second btree block */\n{\n\txfs_da_args_t\t\t*args;\t\t/* operation arguments */\n\tint\t\t\tcount;\t\t/* count (& direction) leaves */\n\tint\t\t\tisleft;\t\t/* new goes in left leaf */\n\txfs_dir2_leaf_t\t\t*leaf1;\t\t/* first leaf structure */\n\txfs_dir2_leaf_t\t\t*leaf2;\t\t/* second leaf structure */\n\tint\t\t\tmid;\t\t/* midpoint leaf index */\n#if defined(DEBUG) || defined(XFS_WARN)\n\tint\t\t\toldstale;\t/* old count of stale leaves */\n#endif\n\tint\t\t\toldsum;\t\t/* old total leaf count */\n\tint\t\t\tswap;\t\t/* swapped leaf blocks */\n\tstruct xfs_dir2_leaf_entry *ents1;\n\tstruct xfs_dir2_leaf_entry *ents2;\n\tstruct xfs_dir3_icleaf_hdr hdr1;\n\tstruct xfs_dir3_icleaf_hdr hdr2;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\targs = state->args;\n\t/*\n\t * If the block order is wrong, swap the arguments.\n\t */\n\tif ((swap = xfs_dir2_leafn_order(dp, blk1->bp, blk2->bp))) {\n\t\txfs_da_state_blk_t\t*tmp;\t/* temp for block swap */\n\n\t\ttmp = blk1;\n\t\tblk1 = blk2;\n\t\tblk2 = tmp;\n\t}\n\tleaf1 = blk1->bp->b_addr;\n\tleaf2 = blk2->bp->b_addr;\n\tdp->d_ops->leaf_hdr_from_disk(&hdr1, leaf1);\n\tdp->d_ops->leaf_hdr_from_disk(&hdr2, leaf2);\n\tents1 = dp->d_ops->leaf_ents_p(leaf1);\n\tents2 = dp->d_ops->leaf_ents_p(leaf2);\n\n\toldsum = hdr1.count + hdr2.count;\n#if defined(DEBUG) || defined(XFS_WARN)\n\toldstale = hdr1.stale + hdr2.stale;\n#endif\n\tmid = oldsum >> 1;\n\n\t/*\n\t * If the old leaf count was odd then the new one will be even,\n\t * so we need to divide the new count evenly.\n\t */\n\tif (oldsum & 1) {\n\t\txfs_dahash_t\tmidhash;\t/* middle entry hash value */\n\n\t\tif (mid >= hdr1.count)\n\t\t\tmidhash = be32_to_cpu(ents2[mid - hdr1.count].hashval);\n\t\telse\n\t\t\tmidhash = be32_to_cpu(ents1[mid].hashval);\n\t\tisleft = args->hashval <= midhash;\n\t}\n\t/*\n\t * If the old count is even then the new count is odd, so there's\n\t * no preferred side for the new entry.\n\t * Pick the left one.\n\t */\n\telse\n\t\tisleft = 1;\n\t/*\n\t * Calculate moved entry count.  Positive means left-to-right,\n\t * negative means right-to-left.  Then move the entries.\n\t */\n\tcount = hdr1.count - mid + (isleft == 0);\n\tif (count > 0)\n\t\txfs_dir3_leafn_moveents(args, blk1->bp, &hdr1, ents1,\n\t\t\t\t\thdr1.count - count, blk2->bp,\n\t\t\t\t\t&hdr2, ents2, 0, count);\n\telse if (count < 0)\n\t\txfs_dir3_leafn_moveents(args, blk2->bp, &hdr2, ents2, 0,\n\t\t\t\t\tblk1->bp, &hdr1, ents1,\n\t\t\t\t\thdr1.count, count);\n\n\tASSERT(hdr1.count + hdr2.count == oldsum);\n\tASSERT(hdr1.stale + hdr2.stale == oldstale);\n\n\t/* log the changes made when moving the entries */\n\tdp->d_ops->leaf_hdr_to_disk(leaf1, &hdr1);\n\tdp->d_ops->leaf_hdr_to_disk(leaf2, &hdr2);\n\txfs_dir3_leaf_log_header(args, blk1->bp);\n\txfs_dir3_leaf_log_header(args, blk2->bp);\n\n\txfs_dir3_leaf_check(dp, blk1->bp);\n\txfs_dir3_leaf_check(dp, blk2->bp);\n\n\t/*\n\t * Mark whether we're inserting into the old or new leaf.\n\t */\n\tif (hdr1.count < hdr2.count)\n\t\tstate->inleaf = swap;\n\telse if (hdr1.count > hdr2.count)\n\t\tstate->inleaf = !swap;\n\telse\n\t\tstate->inleaf = swap ^ (blk1->index <= hdr1.count);\n\t/*\n\t * Adjust the expected index for insertion.\n\t */\n\tif (!state->inleaf)\n\t\tblk2->index = blk1->index - hdr1.count;\n\n\t/*\n\t * Finally sanity check just to make sure we are not returning a\n\t * negative index\n\t */\n\tif (blk2->index < 0) {\n\t\tstate->inleaf = 1;\n\t\tblk2->index = 0;\n\t\txfs_alert(dp->i_mount,\n\t\"%s: picked the wrong leaf? reverting original leaf: blk1->index %d\",\n\t\t\t__func__, blk1->index);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_get_buf",
          "args": [
            "args",
            "xfs_dir2_da_to_db(args->geo, blkno)",
            "&newblk->bp",
            "XFS_DIR2_LEAFN_MAGIC"
          ],
          "line": 1331
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_leaf_get_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "336-364",
          "snippet": "int\nxfs_dir3_leaf_get_buf(\n\txfs_da_args_t\t\t*args,\n\txfs_dir2_db_t\t\tbno,\n\tstruct xfs_buf\t\t**bpp,\n\t__uint16_t\t\tmagic)\n{\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_trans\t*tp = args->trans;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\n\tASSERT(magic == XFS_DIR2_LEAF1_MAGIC || magic == XFS_DIR2_LEAFN_MAGIC);\n\tASSERT(bno >= xfs_dir2_byte_to_db(args->geo, XFS_DIR2_LEAF_OFFSET) &&\n\t       bno < xfs_dir2_byte_to_db(args->geo, XFS_DIR2_FREE_OFFSET));\n\n\terror = xfs_da_get_buf(tp, dp, xfs_dir2_db_to_da(args->geo, bno),\n\t\t\t       -1, &bp, XFS_DATA_FORK);\n\tif (error)\n\t\treturn error;\n\n\txfs_dir3_leaf_init(mp, tp, bp, dp->i_ino, magic);\n\txfs_dir3_leaf_log_header(args, bp);\n\tif (magic == XFS_DIR2_LEAF1_MAGIC)\n\t\txfs_dir3_leaf_log_tail(args, bp);\n\t*bpp = bp;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nint\nxfs_dir3_leaf_get_buf(\n\txfs_da_args_t\t\t*args,\n\txfs_dir2_db_t\t\tbno,\n\tstruct xfs_buf\t\t**bpp,\n\t__uint16_t\t\tmagic)\n{\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_trans\t*tp = args->trans;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\n\tASSERT(magic == XFS_DIR2_LEAF1_MAGIC || magic == XFS_DIR2_LEAFN_MAGIC);\n\tASSERT(bno >= xfs_dir2_byte_to_db(args->geo, XFS_DIR2_LEAF_OFFSET) &&\n\t       bno < xfs_dir2_byte_to_db(args->geo, XFS_DIR2_FREE_OFFSET));\n\n\terror = xfs_da_get_buf(tp, dp, xfs_dir2_db_to_da(args->geo, bno),\n\t\t\t       -1, &bp, XFS_DATA_FORK);\n\tif (error)\n\t\treturn error;\n\n\txfs_dir3_leaf_init(mp, tp, bp, dp->i_ino, magic);\n\txfs_dir3_leaf_log_header(args, bp);\n\tif (magic == XFS_DIR2_LEAF1_MAGIC)\n\t\txfs_dir3_leaf_log_tail(args, bp);\n\t*bpp = bp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_da_to_db",
          "args": [
            "args->geo",
            "blkno"
          ],
          "line": 1331
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_da_to_db",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "287-291",
          "snippet": "static inline xfs_dir2_db_t\nxfs_dir2_da_to_db(struct xfs_da_geometry *geo, xfs_dablk_t da)\n{\n\treturn (xfs_dir2_db_t)(da >> (geo->blklog - geo->fsblog));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_db_t\nxfs_dir2_da_to_db(struct xfs_da_geometry *geo, xfs_dablk_t da)\n{\n\treturn (xfs_dir2_db_t)(da >> (geo->blklog - geo->fsblog));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da_grow_inode",
          "args": [
            "args",
            "&blkno"
          ],
          "line": 1324
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_grow_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "2084-2099",
          "snippet": "int\nxfs_da_grow_inode(\n\tstruct xfs_da_args\t*args,\n\txfs_dablk_t\t\t*new_blkno)\n{\n\txfs_fileoff_t\t\tbno;\n\tint\t\t\terror;\n\n\ttrace_xfs_da_grow_inode(args);\n\n\tbno = args->geo->leafblk;\n\terror = xfs_da_grow_inode_int(args, &bno, args->geo->fsbcount);\n\tif (!error)\n\t\t*new_blkno = (xfs_dablk_t)bno;\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_da_grow_inode(\n\tstruct xfs_da_args\t*args,\n\txfs_dablk_t\t\t*new_blkno)\n{\n\txfs_fileoff_t\t\tbno;\n\tint\t\t\terror;\n\n\ttrace_xfs_da_grow_inode(args);\n\n\tbno = args->geo->leafblk;\n\terror = xfs_da_grow_inode_int(args, &bno, args->geo->fsbcount);\n\tif (!error)\n\t\t*new_blkno = (xfs_dablk_t)bno;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "oldblk->magic == XFS_DIR2_LEAFN_MAGIC"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_leafn_split(\n\txfs_da_state_t\t\t*state,\t\t/* btree cursor */\n\txfs_da_state_blk_t\t*oldblk,\t/* original block */\n\txfs_da_state_blk_t\t*newblk)\t/* newly created block */\n{\n\txfs_da_args_t\t\t*args;\t\t/* operation arguments */\n\txfs_dablk_t\t\tblkno;\t\t/* new leaf block number */\n\tint\t\t\terror;\t\t/* error return value */\n\tstruct xfs_inode\t*dp;\n\n\t/*\n\t * Allocate space for a new leaf node.\n\t */\n\targs = state->args;\n\tdp = args->dp;\n\tASSERT(oldblk->magic == XFS_DIR2_LEAFN_MAGIC);\n\terror = xfs_da_grow_inode(args, &blkno);\n\tif (error) {\n\t\treturn error;\n\t}\n\t/*\n\t * Initialize the new leaf block.\n\t */\n\terror = xfs_dir3_leaf_get_buf(args, xfs_dir2_da_to_db(args->geo, blkno),\n\t\t\t\t      &newblk->bp, XFS_DIR2_LEAFN_MAGIC);\n\tif (error)\n\t\treturn error;\n\n\tnewblk->blkno = blkno;\n\tnewblk->magic = XFS_DIR2_LEAFN_MAGIC;\n\t/*\n\t * Rebalance the entries across the two leaves, link the new\n\t * block into the leaves.\n\t */\n\txfs_dir2_leafn_rebalance(state, oldblk, newblk);\n\terror = xfs_da3_blk_link(state, oldblk, newblk);\n\tif (error) {\n\t\treturn error;\n\t}\n\t/*\n\t * Insert the new entry in the correct block.\n\t */\n\tif (state->inleaf)\n\t\terror = xfs_dir2_leafn_add(oldblk->bp, args, oldblk->index);\n\telse\n\t\terror = xfs_dir2_leafn_add(newblk->bp, args, newblk->index);\n\t/*\n\t * Update last hashval in each block since we added the name.\n\t */\n\toldblk->hashval = xfs_dir2_leafn_lasthash(dp, oldblk->bp, NULL);\n\tnewblk->hashval = xfs_dir2_leafn_lasthash(dp, newblk->bp, NULL);\n\txfs_dir3_leaf_check(dp, oldblk->bp);\n\txfs_dir3_leaf_check(dp, newblk->bp);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_dir2_leafn_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
    "lines": "1148-1302",
    "snippet": "static int\t\t\t\t\t/* error */\nxfs_dir2_leafn_remove(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tstruct xfs_buf\t\t*bp,\t\t/* leaf buffer */\n\tint\t\t\tindex,\t\t/* leaf entry index */\n\txfs_da_state_blk_t\t*dblk,\t\t/* data block */\n\tint\t\t\t*rval)\t\t/* resulting block needs join */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_db_t\t\tdb;\t\t/* data block number */\n\tstruct xfs_buf\t\t*dbp;\t\t/* data block buffer */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data block entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\tint\t\t\tlongest;\t/* longest data free entry */\n\tint\t\t\toff;\t\t/* data block entry offset */\n\tint\t\t\tneedlog;\t/* need to log data header */\n\tint\t\t\tneedscan;\t/* need to rescan data frees */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tstruct xfs_dir2_data_free *bf;\t\t/* bestfree table */\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\tstruct xfs_dir2_leaf_entry *ents;\n\n\ttrace_xfs_dir2_leafn_remove(args, index);\n\n\tdp = args->dp;\n\ttp = args->trans;\n\tleaf = bp->b_addr;\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\n\t/*\n\t * Point to the entry we're removing.\n\t */\n\tlep = &ents[index];\n\n\t/*\n\t * Extract the data block and offset from the entry.\n\t */\n\tdb = xfs_dir2_dataptr_to_db(args->geo, be32_to_cpu(lep->address));\n\tASSERT(dblk->blkno == db);\n\toff = xfs_dir2_dataptr_to_off(args->geo, be32_to_cpu(lep->address));\n\tASSERT(dblk->index == off);\n\n\t/*\n\t * Kill the leaf entry by marking it stale.\n\t * Log the leaf block changes.\n\t */\n\tleafhdr.stale++;\n\tdp->d_ops->leaf_hdr_to_disk(leaf, &leafhdr);\n\txfs_dir3_leaf_log_header(args, bp);\n\n\tlep->address = cpu_to_be32(XFS_DIR2_NULL_DATAPTR);\n\txfs_dir3_leaf_log_ents(args, bp, index, index);\n\n\t/*\n\t * Make the data entry free.  Keep track of the longest freespace\n\t * in the data block in case it changes.\n\t */\n\tdbp = dblk->bp;\n\thdr = dbp->b_addr;\n\tdep = (xfs_dir2_data_entry_t *)((char *)hdr + off);\n\tbf = dp->d_ops->data_bestfree_p(hdr);\n\tlongest = be16_to_cpu(bf[0].length);\n\tneedlog = needscan = 0;\n\txfs_dir2_data_make_free(args, dbp, off,\n\t\tdp->d_ops->data_entsize(dep->namelen), &needlog, &needscan);\n\t/*\n\t * Rescan the data block freespaces for bestfree.\n\t * Log the data block header if needed.\n\t */\n\tif (needscan)\n\t\txfs_dir2_data_freescan(dp, hdr, &needlog);\n\tif (needlog)\n\t\txfs_dir2_data_log_header(args, dbp);\n\txfs_dir3_data_check(dp, dbp);\n\t/*\n\t * If the longest data block freespace changes, need to update\n\t * the corresponding freeblock entry.\n\t */\n\tif (longest < be16_to_cpu(bf[0].length)) {\n\t\tint\t\terror;\t\t/* error return value */\n\t\tstruct xfs_buf\t*fbp;\t\t/* freeblock buffer */\n\t\txfs_dir2_db_t\tfdb;\t\t/* freeblock block number */\n\t\tint\t\tfindex;\t\t/* index in freeblock entries */\n\t\txfs_dir2_free_t\t*free;\t\t/* freeblock structure */\n\n\t\t/*\n\t\t * Convert the data block number to a free block,\n\t\t * read in the free block.\n\t\t */\n\t\tfdb = dp->d_ops->db_to_fdb(args->geo, db);\n\t\terror = xfs_dir2_free_read(tp, dp,\n\t\t\t\t\t   xfs_dir2_db_to_da(args->geo, fdb),\n\t\t\t\t\t   &fbp);\n\t\tif (error)\n\t\t\treturn error;\n\t\tfree = fbp->b_addr;\n#ifdef DEBUG\n\t{\n\t\tstruct xfs_dir3_icfree_hdr freehdr;\n\t\tdp->d_ops->free_hdr_from_disk(&freehdr, free);\n\t\tASSERT(freehdr.firstdb == dp->d_ops->free_max_bests(args->geo) *\n\t\t\t(fdb - xfs_dir2_byte_to_db(args->geo,\n\t\t\t\t\t\t   XFS_DIR2_FREE_OFFSET)));\n\t}\n#endif\n\t\t/*\n\t\t * Calculate which entry we need to fix.\n\t\t */\n\t\tfindex = dp->d_ops->db_to_fdindex(args->geo, db);\n\t\tlongest = be16_to_cpu(bf[0].length);\n\t\t/*\n\t\t * If the data block is now empty we can get rid of it\n\t\t * (usually).\n\t\t */\n\t\tif (longest == args->geo->blksize -\n\t\t\t       dp->d_ops->data_entry_offset) {\n\t\t\t/*\n\t\t\t * Try to punch out the data block.\n\t\t\t */\n\t\t\terror = xfs_dir2_shrink_inode(args, db, dbp);\n\t\t\tif (error == 0) {\n\t\t\t\tdblk->bp = NULL;\n\t\t\t\thdr = NULL;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We can get ENOSPC if there's no space reservation.\n\t\t\t * In this case just drop the buffer and some one else\n\t\t\t * will eventually get rid of the empty block.\n\t\t\t */\n\t\t\telse if (!(error == -ENOSPC && args->total == 0))\n\t\t\t\treturn error;\n\t\t}\n\t\t/*\n\t\t * If we got rid of the data block, we can eliminate that entry\n\t\t * in the free block.\n\t\t */\n\t\terror = xfs_dir3_data_block_free(args, hdr, free,\n\t\t\t\t\t\t fdb, findex, fbp, longest);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_dir3_leaf_check(dp, bp);\n\t/*\n\t * Return indication of whether this leaf block is empty enough\n\t * to justify trying to join it with a neighbor.\n\t */\n\t*rval = (dp->d_ops->leaf_hdr_size +\n\t\t (uint)sizeof(ents[0]) * (leafhdr.count - leafhdr.stale)) <\n\t\targs->geo->magicpct;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);",
      "static int xfs_dir2_leafn_remove(xfs_da_args_t *args, struct xfs_buf *bp,\n\t\t\t\t int index, xfs_da_state_blk_t *dblk,\n\t\t\t\t int *rval);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_check",
          "args": [
            "dp",
            "bp"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_data_block_free",
          "args": [
            "args",
            "hdr",
            "free",
            "fdb",
            "findex",
            "fbp",
            "longest"
          ],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_data_block_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
          "lines": "1064-1141",
          "snippet": "static int\nxfs_dir3_data_block_free(\n\txfs_da_args_t\t\t*args,\n\tstruct xfs_dir2_data_hdr *hdr,\n\tstruct xfs_dir2_free\t*free,\n\txfs_dir2_db_t\t\tfdb,\n\tint\t\t\tfindex,\n\tstruct xfs_buf\t\t*fbp,\n\tint\t\t\tlongest)\n{\n\tint\t\t\tlogfree = 0;\n\t__be16\t\t\t*bests;\n\tstruct xfs_dir3_icfree_hdr freehdr;\n\tstruct xfs_inode\t*dp = args->dp;\n\n\tdp->d_ops->free_hdr_from_disk(&freehdr, free);\n\tbests = dp->d_ops->free_bests_p(free);\n\tif (hdr) {\n\t\t/*\n\t\t * Data block is not empty, just set the free entry to the new\n\t\t * value.\n\t\t */\n\t\tbests[findex] = cpu_to_be16(longest);\n\t\txfs_dir2_free_log_bests(args, fbp, findex, findex);\n\t\treturn 0;\n\t}\n\n\t/* One less used entry in the free table. */\n\tfreehdr.nused--;\n\n\t/*\n\t * If this was the last entry in the table, we can trim the table size\n\t * back.  There might be other entries at the end referring to\n\t * non-existent data blocks, get those too.\n\t */\n\tif (findex == freehdr.nvalid - 1) {\n\t\tint\ti;\t\t/* free entry index */\n\n\t\tfor (i = findex - 1; i >= 0; i--) {\n\t\t\tif (bests[i] != cpu_to_be16(NULLDATAOFF))\n\t\t\t\tbreak;\n\t\t}\n\t\tfreehdr.nvalid = i + 1;\n\t\tlogfree = 0;\n\t} else {\n\t\t/* Not the last entry, just punch it out.  */\n\t\tbests[findex] = cpu_to_be16(NULLDATAOFF);\n\t\tlogfree = 1;\n\t}\n\n\tdp->d_ops->free_hdr_to_disk(free, &freehdr);\n\txfs_dir2_free_log_header(args, fbp);\n\n\t/*\n\t * If there are no useful entries left in the block, get rid of the\n\t * block if we can.\n\t */\n\tif (!freehdr.nused) {\n\t\tint error;\n\n\t\terror = xfs_dir2_shrink_inode(args, fdb, fbp);\n\t\tif (error == 0) {\n\t\t\tfbp = NULL;\n\t\t\tlogfree = 0;\n\t\t} else if (error != -ENOSPC || args->total != 0)\n\t\t\treturn error;\n\t\t/*\n\t\t * It's possible to get ENOSPC if there is no\n\t\t * space reservation.  In this case some one\n\t\t * else will eventually get rid of this block.\n\t\t */\n\t}\n\n\t/* Log the free entry that changed, unless we got rid of it.  */\n\tif (logfree)\n\t\txfs_dir2_free_log_bests(args, fbp, findex, findex);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);\n\nstatic int\nxfs_dir3_data_block_free(\n\txfs_da_args_t\t\t*args,\n\tstruct xfs_dir2_data_hdr *hdr,\n\tstruct xfs_dir2_free\t*free,\n\txfs_dir2_db_t\t\tfdb,\n\tint\t\t\tfindex,\n\tstruct xfs_buf\t\t*fbp,\n\tint\t\t\tlongest)\n{\n\tint\t\t\tlogfree = 0;\n\t__be16\t\t\t*bests;\n\tstruct xfs_dir3_icfree_hdr freehdr;\n\tstruct xfs_inode\t*dp = args->dp;\n\n\tdp->d_ops->free_hdr_from_disk(&freehdr, free);\n\tbests = dp->d_ops->free_bests_p(free);\n\tif (hdr) {\n\t\t/*\n\t\t * Data block is not empty, just set the free entry to the new\n\t\t * value.\n\t\t */\n\t\tbests[findex] = cpu_to_be16(longest);\n\t\txfs_dir2_free_log_bests(args, fbp, findex, findex);\n\t\treturn 0;\n\t}\n\n\t/* One less used entry in the free table. */\n\tfreehdr.nused--;\n\n\t/*\n\t * If this was the last entry in the table, we can trim the table size\n\t * back.  There might be other entries at the end referring to\n\t * non-existent data blocks, get those too.\n\t */\n\tif (findex == freehdr.nvalid - 1) {\n\t\tint\ti;\t\t/* free entry index */\n\n\t\tfor (i = findex - 1; i >= 0; i--) {\n\t\t\tif (bests[i] != cpu_to_be16(NULLDATAOFF))\n\t\t\t\tbreak;\n\t\t}\n\t\tfreehdr.nvalid = i + 1;\n\t\tlogfree = 0;\n\t} else {\n\t\t/* Not the last entry, just punch it out.  */\n\t\tbests[findex] = cpu_to_be16(NULLDATAOFF);\n\t\tlogfree = 1;\n\t}\n\n\tdp->d_ops->free_hdr_to_disk(free, &freehdr);\n\txfs_dir2_free_log_header(args, fbp);\n\n\t/*\n\t * If there are no useful entries left in the block, get rid of the\n\t * block if we can.\n\t */\n\tif (!freehdr.nused) {\n\t\tint error;\n\n\t\terror = xfs_dir2_shrink_inode(args, fdb, fbp);\n\t\tif (error == 0) {\n\t\t\tfbp = NULL;\n\t\t\tlogfree = 0;\n\t\t} else if (error != -ENOSPC || args->total != 0)\n\t\t\treturn error;\n\t\t/*\n\t\t * It's possible to get ENOSPC if there is no\n\t\t * space reservation.  In this case some one\n\t\t * else will eventually get rid of this block.\n\t\t */\n\t}\n\n\t/* Log the free entry that changed, unless we got rid of it.  */\n\tif (logfree)\n\t\txfs_dir2_free_log_bests(args, fbp, findex, findex);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_shrink_inode",
          "args": [
            "args",
            "db",
            "dbp"
          ],
          "line": 1270
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_shrink_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
          "lines": "657-731",
          "snippet": "int\nxfs_dir2_shrink_inode(\n\txfs_da_args_t\t*args,\n\txfs_dir2_db_t\tdb,\n\tstruct xfs_buf\t*bp)\n{\n\txfs_fileoff_t\tbno;\t\t/* directory file offset */\n\txfs_dablk_t\tda;\t\t/* directory file offset */\n\tint\t\tdone;\t\t/* bunmap is finished */\n\txfs_inode_t\t*dp;\n\tint\t\terror;\n\txfs_mount_t\t*mp;\n\txfs_trans_t\t*tp;\n\n\ttrace_xfs_dir2_shrink_inode(args, db);\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\ttp = args->trans;\n\tda = xfs_dir2_db_to_da(args->geo, db);\n\t/*\n\t * Unmap the fsblock(s).\n\t */\n\tif ((error = xfs_bunmapi(tp, dp, da, args->geo->fsbcount,\n\t\t\tXFS_BMAPI_METADATA, 0, args->firstblock, args->flist,\n\t\t\t&done))) {\n\t\t/*\n\t\t * ENOSPC actually can happen if we're in a removename with\n\t\t * no space reservation, and the resulting block removal\n\t\t * would cause a bmap btree split or conversion from extents\n\t\t * to btree.  This can only happen for un-fragmented\n\t\t * directory blocks, since you need to be punching out\n\t\t * the middle of an extent.\n\t\t * In this case we need to leave the block in the file,\n\t\t * and not binval it.\n\t\t * So the block has to be in a consistent empty state\n\t\t * and appropriately logged.\n\t\t * We don't free up the buffer, the caller can tell it\n\t\t * hasn't happened since it got an error back.\n\t\t */\n\t\treturn error;\n\t}\n\tASSERT(done);\n\t/*\n\t * Invalidate the buffer from the transaction.\n\t */\n\txfs_trans_binval(tp, bp);\n\t/*\n\t * If it's not a data block, we're done.\n\t */\n\tif (db >= xfs_dir2_byte_to_db(args->geo, XFS_DIR2_LEAF_OFFSET))\n\t\treturn 0;\n\t/*\n\t * If the block isn't the last one in the directory, we're done.\n\t */\n\tif (dp->i_d.di_size > xfs_dir2_db_off_to_byte(args->geo, db + 1, 0))\n\t\treturn 0;\n\tbno = da;\n\tif ((error = xfs_bmap_last_before(tp, dp, &bno, XFS_DATA_FORK))) {\n\t\t/*\n\t\t * This can't really happen unless there's kernel corruption.\n\t\t */\n\t\treturn error;\n\t}\n\tif (db == args->geo->datablk)\n\t\tASSERT(bno == 0);\n\telse\n\t\tASSERT(bno > 0);\n\t/*\n\t * Set the size to the new last block.\n\t */\n\tdp->i_d.di_size = XFS_FSB_TO_B(mp, bno);\n\txfs_trans_log_inode(tp, dp, XFS_ILOG_CORE);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir2_shrink_inode(\n\txfs_da_args_t\t*args,\n\txfs_dir2_db_t\tdb,\n\tstruct xfs_buf\t*bp)\n{\n\txfs_fileoff_t\tbno;\t\t/* directory file offset */\n\txfs_dablk_t\tda;\t\t/* directory file offset */\n\tint\t\tdone;\t\t/* bunmap is finished */\n\txfs_inode_t\t*dp;\n\tint\t\terror;\n\txfs_mount_t\t*mp;\n\txfs_trans_t\t*tp;\n\n\ttrace_xfs_dir2_shrink_inode(args, db);\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\ttp = args->trans;\n\tda = xfs_dir2_db_to_da(args->geo, db);\n\t/*\n\t * Unmap the fsblock(s).\n\t */\n\tif ((error = xfs_bunmapi(tp, dp, da, args->geo->fsbcount,\n\t\t\tXFS_BMAPI_METADATA, 0, args->firstblock, args->flist,\n\t\t\t&done))) {\n\t\t/*\n\t\t * ENOSPC actually can happen if we're in a removename with\n\t\t * no space reservation, and the resulting block removal\n\t\t * would cause a bmap btree split or conversion from extents\n\t\t * to btree.  This can only happen for un-fragmented\n\t\t * directory blocks, since you need to be punching out\n\t\t * the middle of an extent.\n\t\t * In this case we need to leave the block in the file,\n\t\t * and not binval it.\n\t\t * So the block has to be in a consistent empty state\n\t\t * and appropriately logged.\n\t\t * We don't free up the buffer, the caller can tell it\n\t\t * hasn't happened since it got an error back.\n\t\t */\n\t\treturn error;\n\t}\n\tASSERT(done);\n\t/*\n\t * Invalidate the buffer from the transaction.\n\t */\n\txfs_trans_binval(tp, bp);\n\t/*\n\t * If it's not a data block, we're done.\n\t */\n\tif (db >= xfs_dir2_byte_to_db(args->geo, XFS_DIR2_LEAF_OFFSET))\n\t\treturn 0;\n\t/*\n\t * If the block isn't the last one in the directory, we're done.\n\t */\n\tif (dp->i_d.di_size > xfs_dir2_db_off_to_byte(args->geo, db + 1, 0))\n\t\treturn 0;\n\tbno = da;\n\tif ((error = xfs_bmap_last_before(tp, dp, &bno, XFS_DATA_FORK))) {\n\t\t/*\n\t\t * This can't really happen unless there's kernel corruption.\n\t\t */\n\t\treturn error;\n\t}\n\tif (db == args->geo->datablk)\n\t\tASSERT(bno == 0);\n\telse\n\t\tASSERT(bno > 0);\n\t/*\n\t * Set the size to the new last block.\n\t */\n\tdp->i_d.di_size = XFS_FSB_TO_B(mp, bno);\n\txfs_trans_log_inode(tp, dp, XFS_ILOG_CORE);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "bf[0].length"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->db_to_fdindex",
          "args": [
            "args->geo",
            "db"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "freehdr.firstdb == dp->d_ops->free_max_bests(args->geo) *\n\t\t\t(fdb - xfs_dir2_byte_to_db(args->geo,\n\t\t\t\t\t\t   XFS_DIR2_FREE_OFFSET))"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_byte_to_db",
          "args": [
            "args->geo",
            "XFS_DIR2_FREE_OFFSET"
          ],
          "line": 1252
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_byte_to_db",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "213-217",
          "snippet": "static inline xfs_dir2_db_t\nxfs_dir2_byte_to_db(struct xfs_da_geometry *geo, xfs_dir2_off_t by)\n{\n\treturn (xfs_dir2_db_t)(by >> geo->blklog);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_db_t\nxfs_dir2_byte_to_db(struct xfs_da_geometry *geo, xfs_dir2_off_t by)\n{\n\treturn (xfs_dir2_db_t)(by >> geo->blklog);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->free_max_bests",
          "args": [
            "args->geo"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->free_hdr_from_disk",
          "args": [
            "&freehdr",
            "free"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_free_read",
          "args": [
            "tp",
            "dp",
            "xfs_dir2_db_to_da(args->geo, fdb)",
            "&fbp"
          ],
          "line": 1241
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_free_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
          "lines": "174-182",
          "snippet": "int\nxfs_dir2_free_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tfbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\treturn __xfs_dir3_free_read(tp, dp, fbno, -1, bpp);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir2_free_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tfbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\treturn __xfs_dir3_free_read(tp, dp, fbno, -1, bpp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_db_to_da",
          "args": [
            "args->geo",
            "fdb"
          ],
          "line": 1242
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_db_to_da",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "259-263",
          "snippet": "static inline xfs_dablk_t\nxfs_dir2_db_to_da(struct xfs_da_geometry *geo, xfs_dir2_db_t db)\n{\n\treturn (xfs_dablk_t)(db << (geo->blklog - geo->fsblog));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dablk_t\nxfs_dir2_db_to_da(struct xfs_da_geometry *geo, xfs_dir2_db_t db)\n{\n\treturn (xfs_dablk_t)(db << (geo->blklog - geo->fsblog));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->db_to_fdb",
          "args": [
            "args->geo",
            "db"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "bf[0].length"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_data_check",
          "args": [
            "dp",
            "dbp"
          ],
          "line": 1224
        },
        "resolved": true,
        "details": {
          "function_name": "__xfs_dir3_data_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "40-210",
          "snippet": "int\n__xfs_dir3_data_check(\n\tstruct xfs_inode\t*dp,\t\t/* incore inode pointer */\n\tstruct xfs_buf\t\t*bp)\t\t/* data block's buffer */\n{\n\txfs_dir2_dataptr_t\taddr;\t\t/* addr for leaf lookup */\n\txfs_dir2_data_free_t\t*bf;\t\t/* bestfree table */\n\txfs_dir2_block_tail_t\t*btp=NULL;\t/* block tail */\n\tint\t\t\tcount;\t\t/* count of entries found */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry */\n\tchar\t\t\t*endp;\t\t/* end of useful data */\n\tint\t\t\tfreeseen;\t/* mask of bestfrees seen */\n\txfs_dahash_t\t\thash;\t\t/* hash of current name */\n\tint\t\t\ti;\t\t/* leaf index */\n\tint\t\t\tlastfree;\t/* last entry was unused */\n\txfs_dir2_leaf_entry_t\t*lep=NULL;\t/* block leaf entries */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tchar\t\t\t*p;\t\t/* current data position */\n\tint\t\t\tstale;\t\t/* count of stale leaves */\n\tstruct xfs_name\t\tname;\n\tconst struct xfs_dir_ops *ops;\n\tstruct xfs_da_geometry\t*geo;\n\n\tmp = bp->b_target->bt_mount;\n\tgeo = mp->m_dir_geo;\n\n\t/*\n\t * We can be passed a null dp here from a verifier, so we need to go the\n\t * hard way to get them.\n\t */\n\tops = xfs_dir_get_ops(mp, dp);\n\n\thdr = bp->b_addr;\n\tp = (char *)ops->data_entry_p(hdr);\n\n\tswitch (hdr->magic) {\n\tcase cpu_to_be32(XFS_DIR3_BLOCK_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_BLOCK_MAGIC):\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tlep = xfs_dir2_block_leaf_p(btp);\n\t\tendp = (char *)lep;\n\n\t\t/*\n\t\t * The number of leaf entries is limited by the size of the\n\t\t * block and the amount of space used by the data entries.\n\t\t * We don't know how much space is used by the data entries yet,\n\t\t * so just ensure that the count falls somewhere inside the\n\t\t * block right now.\n\t\t */\n\t\tXFS_WANT_CORRUPTED_RETURN(be32_to_cpu(btp->count) <\n\t\t\t((char *)btp - p) / sizeof(struct xfs_dir2_leaf_entry));\n\t\tbreak;\n\tcase cpu_to_be32(XFS_DIR3_DATA_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_DATA_MAGIC):\n\t\tendp = (char *)hdr + geo->blksize;\n\t\tbreak;\n\tdefault:\n\t\tXFS_ERROR_REPORT(\"Bad Magic\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/*\n\t * Account for zero bestfree entries.\n\t */\n\tbf = ops->data_bestfree_p(hdr);\n\tcount = lastfree = freeseen = 0;\n\tif (!bf[0].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[0].offset);\n\t\tfreeseen |= 1 << 0;\n\t}\n\tif (!bf[1].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[1].offset);\n\t\tfreeseen |= 1 << 1;\n\t}\n\tif (!bf[2].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[2].offset);\n\t\tfreeseen |= 1 << 2;\n\t}\n\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[0].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[1].length));\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[1].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t/*\n\t * Loop over the data/unused entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's unused, look for the space in the bestfree table.\n\t\t * If we find it, account for that, else make sure it\n\t\t * doesn't need to be there.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tXFS_WANT_CORRUPTED_RETURN(lastfree == 0);\n\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tbe16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)) ==\n\t\t\t\t\t       (char *)dup - (char *)hdr);\n\t\t\tdfp = xfs_dir2_data_freefind(hdr, bf, dup);\n\t\t\tif (dfp) {\n\t\t\t\ti = (int)(dfp - bf);\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\t(freeseen & (1 << i)) == 0);\n\t\t\t\tfreeseen |= 1 << i;\n\t\t\t} else {\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe16_to_cpu(dup->length) <=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t\t\t}\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t\tlastfree = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * It's a real entry.  Validate the fields.\n\t\t * If this is a block directory then make sure it's\n\t\t * in the leaf section of the block.\n\t\t * The linear search is crude but this is DEBUG code.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\tXFS_WANT_CORRUPTED_RETURN(dep->namelen != 0);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t!xfs_dir_ino_validate(mp, be64_to_cpu(dep->inumber)));\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\tbe16_to_cpu(*ops->data_entry_tag_p(dep)) ==\n\t\t\t\t\t       (char *)dep - (char *)hdr);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tops->data_get_ftype(dep) < XFS_DIR3_FT_MAX);\n\t\tcount++;\n\t\tlastfree = 0;\n\t\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\t\taddr = xfs_dir2_db_off_to_dataptr(geo, geo->datablk,\n\t\t\t\t\t\t(xfs_dir2_data_aoff_t)\n\t\t\t\t\t\t((char *)dep - (char *)hdr));\n\t\t\tname.name = dep->name;\n\t\t\tname.len = dep->namelen;\n\t\t\thash = mp->m_dirnameops->hashname(&name);\n\t\t\tfor (i = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\t\tif (be32_to_cpu(lep[i].address) == addr &&\n\t\t\t\t    be32_to_cpu(lep[i].hashval) == hash)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tXFS_WANT_CORRUPTED_RETURN(i < be32_to_cpu(btp->count));\n\t\t}\n\t\tp += ops->data_entsize(dep->namelen);\n\t}\n\t/*\n\t * Need to have seen all the entries and all the bestfree slots.\n\t */\n\tXFS_WANT_CORRUPTED_RETURN(freeseen == 7);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tfor (i = stale = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\tif (lep[i].address ==\n\t\t\t    cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\t\tstale++;\n\t\t\tif (i > 0)\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe32_to_cpu(lep[i].hashval) >=\n\t\t\t\t\t\tbe32_to_cpu(lep[i - 1].hashval));\n\t\t}\n\t\tXFS_WANT_CORRUPTED_RETURN(count ==\n\t\t\tbe32_to_cpu(btp->count) - be32_to_cpu(btp->stale));\n\t\tXFS_WANT_CORRUPTED_RETURN(stale == be32_to_cpu(btp->stale));\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\n__xfs_dir3_data_check(\n\tstruct xfs_inode\t*dp,\t\t/* incore inode pointer */\n\tstruct xfs_buf\t\t*bp)\t\t/* data block's buffer */\n{\n\txfs_dir2_dataptr_t\taddr;\t\t/* addr for leaf lookup */\n\txfs_dir2_data_free_t\t*bf;\t\t/* bestfree table */\n\txfs_dir2_block_tail_t\t*btp=NULL;\t/* block tail */\n\tint\t\t\tcount;\t\t/* count of entries found */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry */\n\tchar\t\t\t*endp;\t\t/* end of useful data */\n\tint\t\t\tfreeseen;\t/* mask of bestfrees seen */\n\txfs_dahash_t\t\thash;\t\t/* hash of current name */\n\tint\t\t\ti;\t\t/* leaf index */\n\tint\t\t\tlastfree;\t/* last entry was unused */\n\txfs_dir2_leaf_entry_t\t*lep=NULL;\t/* block leaf entries */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tchar\t\t\t*p;\t\t/* current data position */\n\tint\t\t\tstale;\t\t/* count of stale leaves */\n\tstruct xfs_name\t\tname;\n\tconst struct xfs_dir_ops *ops;\n\tstruct xfs_da_geometry\t*geo;\n\n\tmp = bp->b_target->bt_mount;\n\tgeo = mp->m_dir_geo;\n\n\t/*\n\t * We can be passed a null dp here from a verifier, so we need to go the\n\t * hard way to get them.\n\t */\n\tops = xfs_dir_get_ops(mp, dp);\n\n\thdr = bp->b_addr;\n\tp = (char *)ops->data_entry_p(hdr);\n\n\tswitch (hdr->magic) {\n\tcase cpu_to_be32(XFS_DIR3_BLOCK_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_BLOCK_MAGIC):\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tlep = xfs_dir2_block_leaf_p(btp);\n\t\tendp = (char *)lep;\n\n\t\t/*\n\t\t * The number of leaf entries is limited by the size of the\n\t\t * block and the amount of space used by the data entries.\n\t\t * We don't know how much space is used by the data entries yet,\n\t\t * so just ensure that the count falls somewhere inside the\n\t\t * block right now.\n\t\t */\n\t\tXFS_WANT_CORRUPTED_RETURN(be32_to_cpu(btp->count) <\n\t\t\t((char *)btp - p) / sizeof(struct xfs_dir2_leaf_entry));\n\t\tbreak;\n\tcase cpu_to_be32(XFS_DIR3_DATA_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_DATA_MAGIC):\n\t\tendp = (char *)hdr + geo->blksize;\n\t\tbreak;\n\tdefault:\n\t\tXFS_ERROR_REPORT(\"Bad Magic\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/*\n\t * Account for zero bestfree entries.\n\t */\n\tbf = ops->data_bestfree_p(hdr);\n\tcount = lastfree = freeseen = 0;\n\tif (!bf[0].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[0].offset);\n\t\tfreeseen |= 1 << 0;\n\t}\n\tif (!bf[1].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[1].offset);\n\t\tfreeseen |= 1 << 1;\n\t}\n\tif (!bf[2].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[2].offset);\n\t\tfreeseen |= 1 << 2;\n\t}\n\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[0].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[1].length));\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[1].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t/*\n\t * Loop over the data/unused entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's unused, look for the space in the bestfree table.\n\t\t * If we find it, account for that, else make sure it\n\t\t * doesn't need to be there.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tXFS_WANT_CORRUPTED_RETURN(lastfree == 0);\n\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tbe16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)) ==\n\t\t\t\t\t       (char *)dup - (char *)hdr);\n\t\t\tdfp = xfs_dir2_data_freefind(hdr, bf, dup);\n\t\t\tif (dfp) {\n\t\t\t\ti = (int)(dfp - bf);\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\t(freeseen & (1 << i)) == 0);\n\t\t\t\tfreeseen |= 1 << i;\n\t\t\t} else {\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe16_to_cpu(dup->length) <=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t\t\t}\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t\tlastfree = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * It's a real entry.  Validate the fields.\n\t\t * If this is a block directory then make sure it's\n\t\t * in the leaf section of the block.\n\t\t * The linear search is crude but this is DEBUG code.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\tXFS_WANT_CORRUPTED_RETURN(dep->namelen != 0);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t!xfs_dir_ino_validate(mp, be64_to_cpu(dep->inumber)));\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\tbe16_to_cpu(*ops->data_entry_tag_p(dep)) ==\n\t\t\t\t\t       (char *)dep - (char *)hdr);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tops->data_get_ftype(dep) < XFS_DIR3_FT_MAX);\n\t\tcount++;\n\t\tlastfree = 0;\n\t\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\t\taddr = xfs_dir2_db_off_to_dataptr(geo, geo->datablk,\n\t\t\t\t\t\t(xfs_dir2_data_aoff_t)\n\t\t\t\t\t\t((char *)dep - (char *)hdr));\n\t\t\tname.name = dep->name;\n\t\t\tname.len = dep->namelen;\n\t\t\thash = mp->m_dirnameops->hashname(&name);\n\t\t\tfor (i = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\t\tif (be32_to_cpu(lep[i].address) == addr &&\n\t\t\t\t    be32_to_cpu(lep[i].hashval) == hash)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tXFS_WANT_CORRUPTED_RETURN(i < be32_to_cpu(btp->count));\n\t\t}\n\t\tp += ops->data_entsize(dep->namelen);\n\t}\n\t/*\n\t * Need to have seen all the entries and all the bestfree slots.\n\t */\n\tXFS_WANT_CORRUPTED_RETURN(freeseen == 7);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tfor (i = stale = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\tif (lep[i].address ==\n\t\t\t    cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\t\tstale++;\n\t\t\tif (i > 0)\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe32_to_cpu(lep[i].hashval) >=\n\t\t\t\t\t\tbe32_to_cpu(lep[i - 1].hashval));\n\t\t}\n\t\tXFS_WANT_CORRUPTED_RETURN(count ==\n\t\t\tbe32_to_cpu(btp->count) - be32_to_cpu(btp->stale));\n\t\tXFS_WANT_CORRUPTED_RETURN(stale == be32_to_cpu(btp->stale));\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_log_header",
          "args": [
            "args",
            "dbp"
          ],
          "line": 1223
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_log_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "661-677",
          "snippet": "void\nxfs_dir2_data_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n#ifdef DEBUG\n\tstruct xfs_dir2_data_hdr *hdr = bp->b_addr;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n#endif\n\n\txfs_trans_log_buf(args->trans, bp, 0,\n\t\t\t  args->dp->d_ops->data_entry_offset - 1);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dir2_data_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n#ifdef DEBUG\n\tstruct xfs_dir2_data_hdr *hdr = bp->b_addr;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n#endif\n\n\txfs_trans_log_buf(args->trans, bp, 0,\n\t\t\t  args->dp->d_ops->data_entry_offset - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_freescan",
          "args": [
            "dp",
            "hdr",
            "&needlog"
          ],
          "line": 1221
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_freescan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "500-559",
          "snippet": "void\nxfs_dir2_data_freescan(\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_dir2_data_hdr *hdr,\n\tint\t\t\t*loghead)\n{\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* active data entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused data entry */\n\tstruct xfs_dir2_data_free *bf;\n\tchar\t\t\t*endp;\t\t/* end of block's data */\n\tchar\t\t\t*p;\t\t/* current entry pointer */\n\tstruct xfs_da_geometry\t*geo = dp->i_mount->m_dir_geo;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\t/*\n\t * Start by clearing the table.\n\t */\n\tbf = dp->d_ops->data_bestfree_p(hdr);\n\tmemset(bf, 0, sizeof(*bf) * XFS_DIR2_DATA_FD_COUNT);\n\t*loghead = 1;\n\t/*\n\t * Set up pointers.\n\t */\n\tp = (char *)dp->d_ops->data_entry_p(hdr);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tendp = (char *)xfs_dir2_block_leaf_p(btp);\n\t} else\n\t\tendp = (char *)hdr + geo->blksize;\n\t/*\n\t * Loop over the block's entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's a free entry, insert it.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tASSERT((char *)dup - (char *)hdr ==\n\t\t\t       be16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)));\n\t\t\txfs_dir2_data_freeinsert(hdr, bf, dup, loghead);\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t}\n\t\t/*\n\t\t * For active entries, check their tags and skip them.\n\t\t */\n\t\telse {\n\t\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\t\tASSERT((char *)dep - (char *)hdr ==\n\t\t\t       be16_to_cpu(*dp->d_ops->data_entry_tag_p(dep)));\n\t\t\tp += dp->d_ops->data_entsize(dep->namelen);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dir2_data_freescan(\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_dir2_data_hdr *hdr,\n\tint\t\t\t*loghead)\n{\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* active data entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused data entry */\n\tstruct xfs_dir2_data_free *bf;\n\tchar\t\t\t*endp;\t\t/* end of block's data */\n\tchar\t\t\t*p;\t\t/* current entry pointer */\n\tstruct xfs_da_geometry\t*geo = dp->i_mount->m_dir_geo;\n\n\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t       hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\n\t/*\n\t * Start by clearing the table.\n\t */\n\tbf = dp->d_ops->data_bestfree_p(hdr);\n\tmemset(bf, 0, sizeof(*bf) * XFS_DIR2_DATA_FD_COUNT);\n\t*loghead = 1;\n\t/*\n\t * Set up pointers.\n\t */\n\tp = (char *)dp->d_ops->data_entry_p(hdr);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tendp = (char *)xfs_dir2_block_leaf_p(btp);\n\t} else\n\t\tendp = (char *)hdr + geo->blksize;\n\t/*\n\t * Loop over the block's entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's a free entry, insert it.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tASSERT((char *)dup - (char *)hdr ==\n\t\t\t       be16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)));\n\t\t\txfs_dir2_data_freeinsert(hdr, bf, dup, loghead);\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t}\n\t\t/*\n\t\t * For active entries, check their tags and skip them.\n\t\t */\n\t\telse {\n\t\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\t\tASSERT((char *)dep - (char *)hdr ==\n\t\t\t       be16_to_cpu(*dp->d_ops->data_entry_tag_p(dep)));\n\t\t\tp += dp->d_ops->data_entsize(dep->namelen);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_data_make_free",
          "args": [
            "args",
            "dbp",
            "off",
            "dp->d_ops->data_entsize(dep->namelen)",
            "&needlog",
            "&needscan"
          ],
          "line": 1214
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_data_make_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "714-894",
          "snippet": "void\nxfs_dir2_data_make_free(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_aoff_t\toffset,\t\t/* starting byte offset */\n\txfs_dir2_data_aoff_t\tlen,\t\t/* length in bytes */\n\tint\t\t\t*needlogp,\t/* out: log header */\n\tint\t\t\t*needscanp)\t/* out: regen bestfree */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block pointer */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree pointer */\n\tchar\t\t\t*endptr;\t/* end of data area */\n\tint\t\t\tneedscan;\t/* need to regen bestfree */\n\txfs_dir2_data_unused_t\t*newdup;\t/* new unused entry */\n\txfs_dir2_data_unused_t\t*postdup;\t/* unused entry after us */\n\txfs_dir2_data_unused_t\t*prevdup;\t/* unused entry before us */\n\tstruct xfs_dir2_data_free *bf;\n\n\thdr = bp->b_addr;\n\n\t/*\n\t * Figure out where the end of the data area is.\n\t */\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC))\n\t\tendptr = (char *)hdr + args->geo->blksize;\n\telse {\n\t\txfs_dir2_block_tail_t\t*btp;\t/* block tail */\n\n\t\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t\t\thdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\t\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\t\tendptr = (char *)xfs_dir2_block_leaf_p(btp);\n\t}\n\t/*\n\t * If this isn't the start of the block, then back up to\n\t * the previous entry and see if it's free.\n\t */\n\tif (offset > args->dp->d_ops->data_entry_offset) {\n\t\t__be16\t\t\t*tagp;\t/* tag just before us */\n\n\t\ttagp = (__be16 *)((char *)hdr + offset) - 1;\n\t\tprevdup = (xfs_dir2_data_unused_t *)((char *)hdr + be16_to_cpu(*tagp));\n\t\tif (be16_to_cpu(prevdup->freetag) != XFS_DIR2_DATA_FREE_TAG)\n\t\t\tprevdup = NULL;\n\t} else\n\t\tprevdup = NULL;\n\t/*\n\t * If this isn't the end of the block, see if the entry after\n\t * us is free.\n\t */\n\tif ((char *)hdr + offset + len < endptr) {\n\t\tpostdup =\n\t\t\t(xfs_dir2_data_unused_t *)((char *)hdr + offset + len);\n\t\tif (be16_to_cpu(postdup->freetag) != XFS_DIR2_DATA_FREE_TAG)\n\t\t\tpostdup = NULL;\n\t} else\n\t\tpostdup = NULL;\n\tASSERT(*needscanp == 0);\n\tneedscan = 0;\n\t/*\n\t * Previous and following entries are both free,\n\t * merge everything into a single free entry.\n\t */\n\tbf = args->dp->d_ops->data_bestfree_p(hdr);\n\tif (prevdup && postdup) {\n\t\txfs_dir2_data_free_t\t*dfp2;\t/* another bestfree pointer */\n\n\t\t/*\n\t\t * See if prevdup and/or postdup are in bestfree table.\n\t\t */\n\t\tdfp = xfs_dir2_data_freefind(hdr, bf, prevdup);\n\t\tdfp2 = xfs_dir2_data_freefind(hdr, bf, postdup);\n\t\t/*\n\t\t * We need a rescan unless there are exactly 2 free entries\n\t\t * namely our two.  Then we know what's happening, otherwise\n\t\t * since the third bestfree is there, there might be more\n\t\t * entries.\n\t\t */\n\t\tneedscan = (bf[2].length != 0);\n\t\t/*\n\t\t * Fix up the new big freespace.\n\t\t */\n\t\tbe16_add_cpu(&prevdup->length, len + be16_to_cpu(postdup->length));\n\t\t*xfs_dir2_data_unused_tag_p(prevdup) =\n\t\t\tcpu_to_be16((char *)prevdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, prevdup);\n\t\tif (!needscan) {\n\t\t\t/*\n\t\t\t * Has to be the case that entries 0 and 1 are\n\t\t\t * dfp and dfp2 (don't know which is which), and\n\t\t\t * entry 2 is empty.\n\t\t\t * Remove entry 1 first then entry 0.\n\t\t\t */\n\t\t\tASSERT(dfp && dfp2);\n\t\t\tif (dfp == &bf[1]) {\n\t\t\t\tdfp = &bf[0];\n\t\t\t\tASSERT(dfp2 == dfp);\n\t\t\t\tdfp2 = &bf[1];\n\t\t\t}\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp2, needlogp);\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\t/*\n\t\t\t * Now insert the new entry.\n\t\t\t */\n\t\t\tdfp = xfs_dir2_data_freeinsert(hdr, bf, prevdup,\n\t\t\t\t\t\t       needlogp);\n\t\t\tASSERT(dfp == &bf[0]);\n\t\t\tASSERT(dfp->length == prevdup->length);\n\t\t\tASSERT(!dfp[1].length);\n\t\t\tASSERT(!dfp[2].length);\n\t\t}\n\t}\n\t/*\n\t * The entry before us is free, merge with it.\n\t */\n\telse if (prevdup) {\n\t\tdfp = xfs_dir2_data_freefind(hdr, bf, prevdup);\n\t\tbe16_add_cpu(&prevdup->length, len);\n\t\t*xfs_dir2_data_unused_tag_p(prevdup) =\n\t\t\tcpu_to_be16((char *)prevdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, prevdup);\n\t\t/*\n\t\t * If the previous entry was in the table, the new entry\n\t\t * is longer, so it will be in the table too.  Remove\n\t\t * the old one and add the new one.\n\t\t */\n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\txfs_dir2_data_freeinsert(hdr, bf, prevdup, needlogp);\n\t\t}\n\t\t/*\n\t\t * Otherwise we need a scan if the new entry is big enough.\n\t\t */\n\t\telse {\n\t\t\tneedscan = be16_to_cpu(prevdup->length) >\n\t\t\t\t   be16_to_cpu(bf[2].length);\n\t\t}\n\t}\n\t/*\n\t * The following entry is free, merge with it.\n\t */\n\telse if (postdup) {\n\t\tdfp = xfs_dir2_data_freefind(hdr, bf, postdup);\n\t\tnewdup = (xfs_dir2_data_unused_t *)((char *)hdr + offset);\n\t\tnewdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup->length = cpu_to_be16(len + be16_to_cpu(postdup->length));\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\t/*\n\t\t * If the following entry was in the table, the new entry\n\t\t * is longer, so it will be in the table too.  Remove\n\t\t * the old one and add the new one.\n\t\t */\n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\txfs_dir2_data_freeinsert(hdr, bf, newdup, needlogp);\n\t\t}\n\t\t/*\n\t\t * Otherwise we need a scan if the new entry is big enough.\n\t\t */\n\t\telse {\n\t\t\tneedscan = be16_to_cpu(newdup->length) >\n\t\t\t\t   be16_to_cpu(bf[2].length);\n\t\t}\n\t}\n\t/*\n\t * Neither neighbor is free.  Make a new entry.\n\t */\n\telse {\n\t\tnewdup = (xfs_dir2_data_unused_t *)((char *)hdr + offset);\n\t\tnewdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup->length = cpu_to_be16(len);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\txfs_dir2_data_freeinsert(hdr, bf, newdup, needlogp);\n\t}\n\t*needscanp = needscan;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_dir2_data_make_free(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\txfs_dir2_data_aoff_t\toffset,\t\t/* starting byte offset */\n\txfs_dir2_data_aoff_t\tlen,\t\t/* length in bytes */\n\tint\t\t\t*needlogp,\t/* out: log header */\n\tint\t\t\t*needscanp)\t/* out: regen bestfree */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block pointer */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree pointer */\n\tchar\t\t\t*endptr;\t/* end of data area */\n\tint\t\t\tneedscan;\t/* need to regen bestfree */\n\txfs_dir2_data_unused_t\t*newdup;\t/* new unused entry */\n\txfs_dir2_data_unused_t\t*postdup;\t/* unused entry after us */\n\txfs_dir2_data_unused_t\t*prevdup;\t/* unused entry before us */\n\tstruct xfs_dir2_data_free *bf;\n\n\thdr = bp->b_addr;\n\n\t/*\n\t * Figure out where the end of the data area is.\n\t */\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC))\n\t\tendptr = (char *)hdr + args->geo->blksize;\n\telse {\n\t\txfs_dir2_block_tail_t\t*btp;\t/* block tail */\n\n\t\tASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t\t\thdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));\n\t\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\t\tendptr = (char *)xfs_dir2_block_leaf_p(btp);\n\t}\n\t/*\n\t * If this isn't the start of the block, then back up to\n\t * the previous entry and see if it's free.\n\t */\n\tif (offset > args->dp->d_ops->data_entry_offset) {\n\t\t__be16\t\t\t*tagp;\t/* tag just before us */\n\n\t\ttagp = (__be16 *)((char *)hdr + offset) - 1;\n\t\tprevdup = (xfs_dir2_data_unused_t *)((char *)hdr + be16_to_cpu(*tagp));\n\t\tif (be16_to_cpu(prevdup->freetag) != XFS_DIR2_DATA_FREE_TAG)\n\t\t\tprevdup = NULL;\n\t} else\n\t\tprevdup = NULL;\n\t/*\n\t * If this isn't the end of the block, see if the entry after\n\t * us is free.\n\t */\n\tif ((char *)hdr + offset + len < endptr) {\n\t\tpostdup =\n\t\t\t(xfs_dir2_data_unused_t *)((char *)hdr + offset + len);\n\t\tif (be16_to_cpu(postdup->freetag) != XFS_DIR2_DATA_FREE_TAG)\n\t\t\tpostdup = NULL;\n\t} else\n\t\tpostdup = NULL;\n\tASSERT(*needscanp == 0);\n\tneedscan = 0;\n\t/*\n\t * Previous and following entries are both free,\n\t * merge everything into a single free entry.\n\t */\n\tbf = args->dp->d_ops->data_bestfree_p(hdr);\n\tif (prevdup && postdup) {\n\t\txfs_dir2_data_free_t\t*dfp2;\t/* another bestfree pointer */\n\n\t\t/*\n\t\t * See if prevdup and/or postdup are in bestfree table.\n\t\t */\n\t\tdfp = xfs_dir2_data_freefind(hdr, bf, prevdup);\n\t\tdfp2 = xfs_dir2_data_freefind(hdr, bf, postdup);\n\t\t/*\n\t\t * We need a rescan unless there are exactly 2 free entries\n\t\t * namely our two.  Then we know what's happening, otherwise\n\t\t * since the third bestfree is there, there might be more\n\t\t * entries.\n\t\t */\n\t\tneedscan = (bf[2].length != 0);\n\t\t/*\n\t\t * Fix up the new big freespace.\n\t\t */\n\t\tbe16_add_cpu(&prevdup->length, len + be16_to_cpu(postdup->length));\n\t\t*xfs_dir2_data_unused_tag_p(prevdup) =\n\t\t\tcpu_to_be16((char *)prevdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, prevdup);\n\t\tif (!needscan) {\n\t\t\t/*\n\t\t\t * Has to be the case that entries 0 and 1 are\n\t\t\t * dfp and dfp2 (don't know which is which), and\n\t\t\t * entry 2 is empty.\n\t\t\t * Remove entry 1 first then entry 0.\n\t\t\t */\n\t\t\tASSERT(dfp && dfp2);\n\t\t\tif (dfp == &bf[1]) {\n\t\t\t\tdfp = &bf[0];\n\t\t\t\tASSERT(dfp2 == dfp);\n\t\t\t\tdfp2 = &bf[1];\n\t\t\t}\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp2, needlogp);\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\t/*\n\t\t\t * Now insert the new entry.\n\t\t\t */\n\t\t\tdfp = xfs_dir2_data_freeinsert(hdr, bf, prevdup,\n\t\t\t\t\t\t       needlogp);\n\t\t\tASSERT(dfp == &bf[0]);\n\t\t\tASSERT(dfp->length == prevdup->length);\n\t\t\tASSERT(!dfp[1].length);\n\t\t\tASSERT(!dfp[2].length);\n\t\t}\n\t}\n\t/*\n\t * The entry before us is free, merge with it.\n\t */\n\telse if (prevdup) {\n\t\tdfp = xfs_dir2_data_freefind(hdr, bf, prevdup);\n\t\tbe16_add_cpu(&prevdup->length, len);\n\t\t*xfs_dir2_data_unused_tag_p(prevdup) =\n\t\t\tcpu_to_be16((char *)prevdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, prevdup);\n\t\t/*\n\t\t * If the previous entry was in the table, the new entry\n\t\t * is longer, so it will be in the table too.  Remove\n\t\t * the old one and add the new one.\n\t\t */\n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\txfs_dir2_data_freeinsert(hdr, bf, prevdup, needlogp);\n\t\t}\n\t\t/*\n\t\t * Otherwise we need a scan if the new entry is big enough.\n\t\t */\n\t\telse {\n\t\t\tneedscan = be16_to_cpu(prevdup->length) >\n\t\t\t\t   be16_to_cpu(bf[2].length);\n\t\t}\n\t}\n\t/*\n\t * The following entry is free, merge with it.\n\t */\n\telse if (postdup) {\n\t\tdfp = xfs_dir2_data_freefind(hdr, bf, postdup);\n\t\tnewdup = (xfs_dir2_data_unused_t *)((char *)hdr + offset);\n\t\tnewdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup->length = cpu_to_be16(len + be16_to_cpu(postdup->length));\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\t/*\n\t\t * If the following entry was in the table, the new entry\n\t\t * is longer, so it will be in the table too.  Remove\n\t\t * the old one and add the new one.\n\t\t */\n\t\tif (dfp) {\n\t\t\txfs_dir2_data_freeremove(hdr, bf, dfp, needlogp);\n\t\t\txfs_dir2_data_freeinsert(hdr, bf, newdup, needlogp);\n\t\t}\n\t\t/*\n\t\t * Otherwise we need a scan if the new entry is big enough.\n\t\t */\n\t\telse {\n\t\t\tneedscan = be16_to_cpu(newdup->length) >\n\t\t\t\t   be16_to_cpu(bf[2].length);\n\t\t}\n\t}\n\t/*\n\t * Neither neighbor is free.  Make a new entry.\n\t */\n\telse {\n\t\tnewdup = (xfs_dir2_data_unused_t *)((char *)hdr + offset);\n\t\tnewdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\tnewdup->length = cpu_to_be16(len);\n\t\t*xfs_dir2_data_unused_tag_p(newdup) =\n\t\t\tcpu_to_be16((char *)newdup - (char *)hdr);\n\t\txfs_dir2_data_log_unused(args, bp, newdup);\n\t\txfs_dir2_data_freeinsert(hdr, bf, newdup, needlogp);\n\t}\n\t*needscanp = needscan;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_entsize",
          "args": [
            "dep->namelen"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "bf[0].length"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_bestfree_p",
          "args": [
            "hdr"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_log_ents",
          "args": [
            "args",
            "bp",
            "index",
            "index"
          ],
          "line": 1202
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_leaf_log_ents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "1077-1100",
          "snippet": "void\nxfs_dir3_leaf_log_ents(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\n\tint\t\t\tlast)\n{\n\txfs_dir2_leaf_entry_t\t*firstlep;\t/* pointer to first entry */\n\txfs_dir2_leaf_entry_t\t*lastlep;\t/* pointer to last entry */\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\tstruct xfs_dir2_leaf_entry *ents;\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\tents = args->dp->d_ops->leaf_ents_p(leaf);\n\tfirstlep = &ents[first];\n\tlastlep = &ents[last];\n\txfs_trans_log_buf(args->trans, bp,\n\t\t(uint)((char *)firstlep - (char *)leaf),\n\t\t(uint)((char *)lastlep - (char *)leaf + sizeof(*lastlep) - 1));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);",
            "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nvoid\nxfs_dir3_leaf_log_ents(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\n\tint\t\t\tlast)\n{\n\txfs_dir2_leaf_entry_t\t*firstlep;\t/* pointer to first entry */\n\txfs_dir2_leaf_entry_t\t*lastlep;\t/* pointer to last entry */\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\tstruct xfs_dir2_leaf_entry *ents;\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\tents = args->dp->d_ops->leaf_ents_p(leaf);\n\tfirstlep = &ents[first];\n\tlastlep = &ents[last];\n\txfs_trans_log_buf(args->trans, bp,\n\t\t(uint)((char *)firstlep - (char *)leaf),\n\t\t(uint)((char *)lastlep - (char *)leaf + sizeof(*lastlep) - 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_NULL_DATAPTR"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_log_header",
          "args": [
            "args",
            "bp"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_leaf_log_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "1105-1120",
          "snippet": "void\nxfs_dir3_leaf_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t  (uint)((char *)&leaf->hdr - (char *)leaf),\n\t\t\t  args->dp->d_ops->leaf_hdr_size - 1);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nvoid\nxfs_dir3_leaf_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t  (uint)((char *)&leaf->hdr - (char *)leaf),\n\t\t\t  args->dp->d_ops->leaf_hdr_size - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_hdr_to_disk",
          "args": [
            "leaf",
            "&leafhdr"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dblk->index == off"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_dataptr_to_off",
          "args": [
            "args->geo",
            "be32_to_cpu(lep->address)"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_dataptr_to_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "240-244",
          "snippet": "static inline xfs_dir2_data_aoff_t\nxfs_dir2_dataptr_to_off(struct xfs_da_geometry *geo, xfs_dir2_dataptr_t dp)\n{\n\treturn xfs_dir2_byte_to_off(geo, xfs_dir2_dataptr_to_byte(dp));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_data_aoff_t\nxfs_dir2_dataptr_to_off(struct xfs_da_geometry *geo, xfs_dir2_dataptr_t dp)\n{\n\treturn xfs_dir2_byte_to_off(geo, xfs_dir2_dataptr_to_byte(dp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "lep->address"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "dblk->blkno == db"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_dataptr_to_db",
          "args": [
            "args->geo",
            "be32_to_cpu(lep->address)"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_dataptr_to_db",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "222-226",
          "snippet": "static inline xfs_dir2_db_t\nxfs_dir2_dataptr_to_db(struct xfs_da_geometry *geo, xfs_dir2_dataptr_t dp)\n{\n\treturn xfs_dir2_byte_to_db(geo, xfs_dir2_dataptr_to_byte(dp));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_db_t\nxfs_dir2_dataptr_to_db(struct xfs_da_geometry *geo, xfs_dir2_dataptr_t dp)\n{\n\treturn xfs_dir2_byte_to_db(geo, xfs_dir2_dataptr_to_byte(dp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "lep->address"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_ents_p",
          "args": [
            "leaf"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_hdr_from_disk",
          "args": [
            "&leafhdr",
            "leaf"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_dir2_leafn_remove",
          "args": [
            "args",
            "index"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);\nstatic int xfs_dir2_leafn_remove(xfs_da_args_t *args, struct xfs_buf *bp,\n\t\t\t\t int index, xfs_da_state_blk_t *dblk,\n\t\t\t\t int *rval);\n\nstatic int\t\t\t\t\t/* error */\nxfs_dir2_leafn_remove(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tstruct xfs_buf\t\t*bp,\t\t/* leaf buffer */\n\tint\t\t\tindex,\t\t/* leaf entry index */\n\txfs_da_state_blk_t\t*dblk,\t\t/* data block */\n\tint\t\t\t*rval)\t\t/* resulting block needs join */\n{\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_db_t\t\tdb;\t\t/* data block number */\n\tstruct xfs_buf\t\t*dbp;\t\t/* data block buffer */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data block entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\tint\t\t\tlongest;\t/* longest data free entry */\n\tint\t\t\toff;\t\t/* data block entry offset */\n\tint\t\t\tneedlog;\t/* need to log data header */\n\tint\t\t\tneedscan;\t/* need to rescan data frees */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tstruct xfs_dir2_data_free *bf;\t\t/* bestfree table */\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\tstruct xfs_dir2_leaf_entry *ents;\n\n\ttrace_xfs_dir2_leafn_remove(args, index);\n\n\tdp = args->dp;\n\ttp = args->trans;\n\tleaf = bp->b_addr;\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\n\t/*\n\t * Point to the entry we're removing.\n\t */\n\tlep = &ents[index];\n\n\t/*\n\t * Extract the data block and offset from the entry.\n\t */\n\tdb = xfs_dir2_dataptr_to_db(args->geo, be32_to_cpu(lep->address));\n\tASSERT(dblk->blkno == db);\n\toff = xfs_dir2_dataptr_to_off(args->geo, be32_to_cpu(lep->address));\n\tASSERT(dblk->index == off);\n\n\t/*\n\t * Kill the leaf entry by marking it stale.\n\t * Log the leaf block changes.\n\t */\n\tleafhdr.stale++;\n\tdp->d_ops->leaf_hdr_to_disk(leaf, &leafhdr);\n\txfs_dir3_leaf_log_header(args, bp);\n\n\tlep->address = cpu_to_be32(XFS_DIR2_NULL_DATAPTR);\n\txfs_dir3_leaf_log_ents(args, bp, index, index);\n\n\t/*\n\t * Make the data entry free.  Keep track of the longest freespace\n\t * in the data block in case it changes.\n\t */\n\tdbp = dblk->bp;\n\thdr = dbp->b_addr;\n\tdep = (xfs_dir2_data_entry_t *)((char *)hdr + off);\n\tbf = dp->d_ops->data_bestfree_p(hdr);\n\tlongest = be16_to_cpu(bf[0].length);\n\tneedlog = needscan = 0;\n\txfs_dir2_data_make_free(args, dbp, off,\n\t\tdp->d_ops->data_entsize(dep->namelen), &needlog, &needscan);\n\t/*\n\t * Rescan the data block freespaces for bestfree.\n\t * Log the data block header if needed.\n\t */\n\tif (needscan)\n\t\txfs_dir2_data_freescan(dp, hdr, &needlog);\n\tif (needlog)\n\t\txfs_dir2_data_log_header(args, dbp);\n\txfs_dir3_data_check(dp, dbp);\n\t/*\n\t * If the longest data block freespace changes, need to update\n\t * the corresponding freeblock entry.\n\t */\n\tif (longest < be16_to_cpu(bf[0].length)) {\n\t\tint\t\terror;\t\t/* error return value */\n\t\tstruct xfs_buf\t*fbp;\t\t/* freeblock buffer */\n\t\txfs_dir2_db_t\tfdb;\t\t/* freeblock block number */\n\t\tint\t\tfindex;\t\t/* index in freeblock entries */\n\t\txfs_dir2_free_t\t*free;\t\t/* freeblock structure */\n\n\t\t/*\n\t\t * Convert the data block number to a free block,\n\t\t * read in the free block.\n\t\t */\n\t\tfdb = dp->d_ops->db_to_fdb(args->geo, db);\n\t\terror = xfs_dir2_free_read(tp, dp,\n\t\t\t\t\t   xfs_dir2_db_to_da(args->geo, fdb),\n\t\t\t\t\t   &fbp);\n\t\tif (error)\n\t\t\treturn error;\n\t\tfree = fbp->b_addr;\n#ifdef DEBUG\n\t{\n\t\tstruct xfs_dir3_icfree_hdr freehdr;\n\t\tdp->d_ops->free_hdr_from_disk(&freehdr, free);\n\t\tASSERT(freehdr.firstdb == dp->d_ops->free_max_bests(args->geo) *\n\t\t\t(fdb - xfs_dir2_byte_to_db(args->geo,\n\t\t\t\t\t\t   XFS_DIR2_FREE_OFFSET)));\n\t}\n#endif\n\t\t/*\n\t\t * Calculate which entry we need to fix.\n\t\t */\n\t\tfindex = dp->d_ops->db_to_fdindex(args->geo, db);\n\t\tlongest = be16_to_cpu(bf[0].length);\n\t\t/*\n\t\t * If the data block is now empty we can get rid of it\n\t\t * (usually).\n\t\t */\n\t\tif (longest == args->geo->blksize -\n\t\t\t       dp->d_ops->data_entry_offset) {\n\t\t\t/*\n\t\t\t * Try to punch out the data block.\n\t\t\t */\n\t\t\terror = xfs_dir2_shrink_inode(args, db, dbp);\n\t\t\tif (error == 0) {\n\t\t\t\tdblk->bp = NULL;\n\t\t\t\thdr = NULL;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We can get ENOSPC if there's no space reservation.\n\t\t\t * In this case just drop the buffer and some one else\n\t\t\t * will eventually get rid of the empty block.\n\t\t\t */\n\t\t\telse if (!(error == -ENOSPC && args->total == 0))\n\t\t\t\treturn error;\n\t\t}\n\t\t/*\n\t\t * If we got rid of the data block, we can eliminate that entry\n\t\t * in the free block.\n\t\t */\n\t\terror = xfs_dir3_data_block_free(args, hdr, free,\n\t\t\t\t\t\t fdb, findex, fbp, longest);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_dir3_leaf_check(dp, bp);\n\t/*\n\t * Return indication of whether this leaf block is empty enough\n\t * to justify trying to join it with a neighbor.\n\t */\n\t*rval = (dp->d_ops->leaf_hdr_size +\n\t\t (uint)sizeof(ents[0]) * (leafhdr.count - leafhdr.stale)) <\n\t\targs->geo->magicpct;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_dir3_data_block_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
    "lines": "1064-1141",
    "snippet": "static int\nxfs_dir3_data_block_free(\n\txfs_da_args_t\t\t*args,\n\tstruct xfs_dir2_data_hdr *hdr,\n\tstruct xfs_dir2_free\t*free,\n\txfs_dir2_db_t\t\tfdb,\n\tint\t\t\tfindex,\n\tstruct xfs_buf\t\t*fbp,\n\tint\t\t\tlongest)\n{\n\tint\t\t\tlogfree = 0;\n\t__be16\t\t\t*bests;\n\tstruct xfs_dir3_icfree_hdr freehdr;\n\tstruct xfs_inode\t*dp = args->dp;\n\n\tdp->d_ops->free_hdr_from_disk(&freehdr, free);\n\tbests = dp->d_ops->free_bests_p(free);\n\tif (hdr) {\n\t\t/*\n\t\t * Data block is not empty, just set the free entry to the new\n\t\t * value.\n\t\t */\n\t\tbests[findex] = cpu_to_be16(longest);\n\t\txfs_dir2_free_log_bests(args, fbp, findex, findex);\n\t\treturn 0;\n\t}\n\n\t/* One less used entry in the free table. */\n\tfreehdr.nused--;\n\n\t/*\n\t * If this was the last entry in the table, we can trim the table size\n\t * back.  There might be other entries at the end referring to\n\t * non-existent data blocks, get those too.\n\t */\n\tif (findex == freehdr.nvalid - 1) {\n\t\tint\ti;\t\t/* free entry index */\n\n\t\tfor (i = findex - 1; i >= 0; i--) {\n\t\t\tif (bests[i] != cpu_to_be16(NULLDATAOFF))\n\t\t\t\tbreak;\n\t\t}\n\t\tfreehdr.nvalid = i + 1;\n\t\tlogfree = 0;\n\t} else {\n\t\t/* Not the last entry, just punch it out.  */\n\t\tbests[findex] = cpu_to_be16(NULLDATAOFF);\n\t\tlogfree = 1;\n\t}\n\n\tdp->d_ops->free_hdr_to_disk(free, &freehdr);\n\txfs_dir2_free_log_header(args, fbp);\n\n\t/*\n\t * If there are no useful entries left in the block, get rid of the\n\t * block if we can.\n\t */\n\tif (!freehdr.nused) {\n\t\tint error;\n\n\t\terror = xfs_dir2_shrink_inode(args, fdb, fbp);\n\t\tif (error == 0) {\n\t\t\tfbp = NULL;\n\t\t\tlogfree = 0;\n\t\t} else if (error != -ENOSPC || args->total != 0)\n\t\t\treturn error;\n\t\t/*\n\t\t * It's possible to get ENOSPC if there is no\n\t\t * space reservation.  In this case some one\n\t\t * else will eventually get rid of this block.\n\t\t */\n\t}\n\n\t/* Log the free entry that changed, unless we got rid of it.  */\n\tif (logfree)\n\t\txfs_dir2_free_log_bests(args, fbp, findex, findex);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_dir2_free_log_bests",
          "args": [
            "args",
            "fbp",
            "findex",
            "findex"
          ],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_free_log_bests",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
          "lines": "240-258",
          "snippet": "STATIC void\nxfs_dir2_free_log_bests(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\t\t/* first entry to log */\n\tint\t\t\tlast)\t\t/* last entry to log */\n{\n\txfs_dir2_free_t\t\t*free;\t\t/* freespace structure */\n\t__be16\t\t\t*bests;\n\n\tfree = bp->b_addr;\n\tbests = args->dp->d_ops->free_bests_p(free);\n\tASSERT(free->hdr.magic == cpu_to_be32(XFS_DIR2_FREE_MAGIC) ||\n\t       free->hdr.magic == cpu_to_be32(XFS_DIR3_FREE_MAGIC));\n\txfs_trans_log_buf(args->trans, bp,\n\t\t(uint)((char *)&bests[first] - (char *)free),\n\t\t(uint)((char *)&bests[last] - (char *)free +\n\t\t       sizeof(bests[0]) - 1));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_dir2_free_log_bests(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\t\t/* first entry to log */\n\tint\t\t\tlast)\t\t/* last entry to log */\n{\n\txfs_dir2_free_t\t\t*free;\t\t/* freespace structure */\n\t__be16\t\t\t*bests;\n\n\tfree = bp->b_addr;\n\tbests = args->dp->d_ops->free_bests_p(free);\n\tASSERT(free->hdr.magic == cpu_to_be32(XFS_DIR2_FREE_MAGIC) ||\n\t       free->hdr.magic == cpu_to_be32(XFS_DIR3_FREE_MAGIC));\n\txfs_trans_log_buf(args->trans, bp,\n\t\t(uint)((char *)&bests[first] - (char *)free),\n\t\t(uint)((char *)&bests[last] - (char *)free +\n\t\t       sizeof(bests[0]) - 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_shrink_inode",
          "args": [
            "args",
            "fdb",
            "fbp"
          ],
          "line": 1124
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_shrink_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
          "lines": "657-731",
          "snippet": "int\nxfs_dir2_shrink_inode(\n\txfs_da_args_t\t*args,\n\txfs_dir2_db_t\tdb,\n\tstruct xfs_buf\t*bp)\n{\n\txfs_fileoff_t\tbno;\t\t/* directory file offset */\n\txfs_dablk_t\tda;\t\t/* directory file offset */\n\tint\t\tdone;\t\t/* bunmap is finished */\n\txfs_inode_t\t*dp;\n\tint\t\terror;\n\txfs_mount_t\t*mp;\n\txfs_trans_t\t*tp;\n\n\ttrace_xfs_dir2_shrink_inode(args, db);\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\ttp = args->trans;\n\tda = xfs_dir2_db_to_da(args->geo, db);\n\t/*\n\t * Unmap the fsblock(s).\n\t */\n\tif ((error = xfs_bunmapi(tp, dp, da, args->geo->fsbcount,\n\t\t\tXFS_BMAPI_METADATA, 0, args->firstblock, args->flist,\n\t\t\t&done))) {\n\t\t/*\n\t\t * ENOSPC actually can happen if we're in a removename with\n\t\t * no space reservation, and the resulting block removal\n\t\t * would cause a bmap btree split or conversion from extents\n\t\t * to btree.  This can only happen for un-fragmented\n\t\t * directory blocks, since you need to be punching out\n\t\t * the middle of an extent.\n\t\t * In this case we need to leave the block in the file,\n\t\t * and not binval it.\n\t\t * So the block has to be in a consistent empty state\n\t\t * and appropriately logged.\n\t\t * We don't free up the buffer, the caller can tell it\n\t\t * hasn't happened since it got an error back.\n\t\t */\n\t\treturn error;\n\t}\n\tASSERT(done);\n\t/*\n\t * Invalidate the buffer from the transaction.\n\t */\n\txfs_trans_binval(tp, bp);\n\t/*\n\t * If it's not a data block, we're done.\n\t */\n\tif (db >= xfs_dir2_byte_to_db(args->geo, XFS_DIR2_LEAF_OFFSET))\n\t\treturn 0;\n\t/*\n\t * If the block isn't the last one in the directory, we're done.\n\t */\n\tif (dp->i_d.di_size > xfs_dir2_db_off_to_byte(args->geo, db + 1, 0))\n\t\treturn 0;\n\tbno = da;\n\tif ((error = xfs_bmap_last_before(tp, dp, &bno, XFS_DATA_FORK))) {\n\t\t/*\n\t\t * This can't really happen unless there's kernel corruption.\n\t\t */\n\t\treturn error;\n\t}\n\tif (db == args->geo->datablk)\n\t\tASSERT(bno == 0);\n\telse\n\t\tASSERT(bno > 0);\n\t/*\n\t * Set the size to the new last block.\n\t */\n\tdp->i_d.di_size = XFS_FSB_TO_B(mp, bno);\n\txfs_trans_log_inode(tp, dp, XFS_ILOG_CORE);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir2_shrink_inode(\n\txfs_da_args_t\t*args,\n\txfs_dir2_db_t\tdb,\n\tstruct xfs_buf\t*bp)\n{\n\txfs_fileoff_t\tbno;\t\t/* directory file offset */\n\txfs_dablk_t\tda;\t\t/* directory file offset */\n\tint\t\tdone;\t\t/* bunmap is finished */\n\txfs_inode_t\t*dp;\n\tint\t\terror;\n\txfs_mount_t\t*mp;\n\txfs_trans_t\t*tp;\n\n\ttrace_xfs_dir2_shrink_inode(args, db);\n\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\ttp = args->trans;\n\tda = xfs_dir2_db_to_da(args->geo, db);\n\t/*\n\t * Unmap the fsblock(s).\n\t */\n\tif ((error = xfs_bunmapi(tp, dp, da, args->geo->fsbcount,\n\t\t\tXFS_BMAPI_METADATA, 0, args->firstblock, args->flist,\n\t\t\t&done))) {\n\t\t/*\n\t\t * ENOSPC actually can happen if we're in a removename with\n\t\t * no space reservation, and the resulting block removal\n\t\t * would cause a bmap btree split or conversion from extents\n\t\t * to btree.  This can only happen for un-fragmented\n\t\t * directory blocks, since you need to be punching out\n\t\t * the middle of an extent.\n\t\t * In this case we need to leave the block in the file,\n\t\t * and not binval it.\n\t\t * So the block has to be in a consistent empty state\n\t\t * and appropriately logged.\n\t\t * We don't free up the buffer, the caller can tell it\n\t\t * hasn't happened since it got an error back.\n\t\t */\n\t\treturn error;\n\t}\n\tASSERT(done);\n\t/*\n\t * Invalidate the buffer from the transaction.\n\t */\n\txfs_trans_binval(tp, bp);\n\t/*\n\t * If it's not a data block, we're done.\n\t */\n\tif (db >= xfs_dir2_byte_to_db(args->geo, XFS_DIR2_LEAF_OFFSET))\n\t\treturn 0;\n\t/*\n\t * If the block isn't the last one in the directory, we're done.\n\t */\n\tif (dp->i_d.di_size > xfs_dir2_db_off_to_byte(args->geo, db + 1, 0))\n\t\treturn 0;\n\tbno = da;\n\tif ((error = xfs_bmap_last_before(tp, dp, &bno, XFS_DATA_FORK))) {\n\t\t/*\n\t\t * This can't really happen unless there's kernel corruption.\n\t\t */\n\t\treturn error;\n\t}\n\tif (db == args->geo->datablk)\n\t\tASSERT(bno == 0);\n\telse\n\t\tASSERT(bno > 0);\n\t/*\n\t * Set the size to the new last block.\n\t */\n\tdp->i_d.di_size = XFS_FSB_TO_B(mp, bno);\n\txfs_trans_log_inode(tp, dp, XFS_ILOG_CORE);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_free_log_header",
          "args": [
            "args",
            "fbp"
          ],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_free_log_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
          "lines": "263-277",
          "snippet": "static void\nxfs_dir2_free_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n#ifdef DEBUG\n\txfs_dir2_free_t\t\t*free;\t\t/* freespace structure */\n\n\tfree = bp->b_addr;\n\tASSERT(free->hdr.magic == cpu_to_be32(XFS_DIR2_FREE_MAGIC) ||\n\t       free->hdr.magic == cpu_to_be32(XFS_DIR3_FREE_MAGIC));\n#endif\n\txfs_trans_log_buf(args->trans, bp, 0,\n\t\t\t  args->dp->d_ops->free_hdr_size - 1);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_dir2_free_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n#ifdef DEBUG\n\txfs_dir2_free_t\t\t*free;\t\t/* freespace structure */\n\n\tfree = bp->b_addr;\n\tASSERT(free->hdr.magic == cpu_to_be32(XFS_DIR2_FREE_MAGIC) ||\n\t       free->hdr.magic == cpu_to_be32(XFS_DIR3_FREE_MAGIC));\n#endif\n\txfs_trans_log_buf(args->trans, bp, 0,\n\t\t\t  args->dp->d_ops->free_hdr_size - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->free_hdr_to_disk",
          "args": [
            "free",
            "&freehdr"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "NULLDATAOFF"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "NULLDATAOFF"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "longest"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->free_bests_p",
          "args": [
            "free"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->free_hdr_from_disk",
          "args": [
            "&freehdr",
            "free"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);\n\nstatic int\nxfs_dir3_data_block_free(\n\txfs_da_args_t\t\t*args,\n\tstruct xfs_dir2_data_hdr *hdr,\n\tstruct xfs_dir2_free\t*free,\n\txfs_dir2_db_t\t\tfdb,\n\tint\t\t\tfindex,\n\tstruct xfs_buf\t\t*fbp,\n\tint\t\t\tlongest)\n{\n\tint\t\t\tlogfree = 0;\n\t__be16\t\t\t*bests;\n\tstruct xfs_dir3_icfree_hdr freehdr;\n\tstruct xfs_inode\t*dp = args->dp;\n\n\tdp->d_ops->free_hdr_from_disk(&freehdr, free);\n\tbests = dp->d_ops->free_bests_p(free);\n\tif (hdr) {\n\t\t/*\n\t\t * Data block is not empty, just set the free entry to the new\n\t\t * value.\n\t\t */\n\t\tbests[findex] = cpu_to_be16(longest);\n\t\txfs_dir2_free_log_bests(args, fbp, findex, findex);\n\t\treturn 0;\n\t}\n\n\t/* One less used entry in the free table. */\n\tfreehdr.nused--;\n\n\t/*\n\t * If this was the last entry in the table, we can trim the table size\n\t * back.  There might be other entries at the end referring to\n\t * non-existent data blocks, get those too.\n\t */\n\tif (findex == freehdr.nvalid - 1) {\n\t\tint\ti;\t\t/* free entry index */\n\n\t\tfor (i = findex - 1; i >= 0; i--) {\n\t\t\tif (bests[i] != cpu_to_be16(NULLDATAOFF))\n\t\t\t\tbreak;\n\t\t}\n\t\tfreehdr.nvalid = i + 1;\n\t\tlogfree = 0;\n\t} else {\n\t\t/* Not the last entry, just punch it out.  */\n\t\tbests[findex] = cpu_to_be16(NULLDATAOFF);\n\t\tlogfree = 1;\n\t}\n\n\tdp->d_ops->free_hdr_to_disk(free, &freehdr);\n\txfs_dir2_free_log_header(args, fbp);\n\n\t/*\n\t * If there are no useful entries left in the block, get rid of the\n\t * block if we can.\n\t */\n\tif (!freehdr.nused) {\n\t\tint error;\n\n\t\terror = xfs_dir2_shrink_inode(args, fdb, fbp);\n\t\tif (error == 0) {\n\t\t\tfbp = NULL;\n\t\t\tlogfree = 0;\n\t\t} else if (error != -ENOSPC || args->total != 0)\n\t\t\treturn error;\n\t\t/*\n\t\t * It's possible to get ENOSPC if there is no\n\t\t * space reservation.  In this case some one\n\t\t * else will eventually get rid of this block.\n\t\t */\n\t}\n\n\t/* Log the free entry that changed, unless we got rid of it.  */\n\tif (logfree)\n\t\txfs_dir2_free_log_bests(args, fbp, findex, findex);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_dir2_leafn_rebalance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
    "lines": "943-1062",
    "snippet": "static void\nxfs_dir2_leafn_rebalance(\n\txfs_da_state_t\t\t*state,\t\t/* btree cursor */\n\txfs_da_state_blk_t\t*blk1,\t\t/* first btree block */\n\txfs_da_state_blk_t\t*blk2)\t\t/* second btree block */\n{\n\txfs_da_args_t\t\t*args;\t\t/* operation arguments */\n\tint\t\t\tcount;\t\t/* count (& direction) leaves */\n\tint\t\t\tisleft;\t\t/* new goes in left leaf */\n\txfs_dir2_leaf_t\t\t*leaf1;\t\t/* first leaf structure */\n\txfs_dir2_leaf_t\t\t*leaf2;\t\t/* second leaf structure */\n\tint\t\t\tmid;\t\t/* midpoint leaf index */\n#if defined(DEBUG) || defined(XFS_WARN)\n\tint\t\t\toldstale;\t/* old count of stale leaves */\n#endif\n\tint\t\t\toldsum;\t\t/* old total leaf count */\n\tint\t\t\tswap;\t\t/* swapped leaf blocks */\n\tstruct xfs_dir2_leaf_entry *ents1;\n\tstruct xfs_dir2_leaf_entry *ents2;\n\tstruct xfs_dir3_icleaf_hdr hdr1;\n\tstruct xfs_dir3_icleaf_hdr hdr2;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\targs = state->args;\n\t/*\n\t * If the block order is wrong, swap the arguments.\n\t */\n\tif ((swap = xfs_dir2_leafn_order(dp, blk1->bp, blk2->bp))) {\n\t\txfs_da_state_blk_t\t*tmp;\t/* temp for block swap */\n\n\t\ttmp = blk1;\n\t\tblk1 = blk2;\n\t\tblk2 = tmp;\n\t}\n\tleaf1 = blk1->bp->b_addr;\n\tleaf2 = blk2->bp->b_addr;\n\tdp->d_ops->leaf_hdr_from_disk(&hdr1, leaf1);\n\tdp->d_ops->leaf_hdr_from_disk(&hdr2, leaf2);\n\tents1 = dp->d_ops->leaf_ents_p(leaf1);\n\tents2 = dp->d_ops->leaf_ents_p(leaf2);\n\n\toldsum = hdr1.count + hdr2.count;\n#if defined(DEBUG) || defined(XFS_WARN)\n\toldstale = hdr1.stale + hdr2.stale;\n#endif\n\tmid = oldsum >> 1;\n\n\t/*\n\t * If the old leaf count was odd then the new one will be even,\n\t * so we need to divide the new count evenly.\n\t */\n\tif (oldsum & 1) {\n\t\txfs_dahash_t\tmidhash;\t/* middle entry hash value */\n\n\t\tif (mid >= hdr1.count)\n\t\t\tmidhash = be32_to_cpu(ents2[mid - hdr1.count].hashval);\n\t\telse\n\t\t\tmidhash = be32_to_cpu(ents1[mid].hashval);\n\t\tisleft = args->hashval <= midhash;\n\t}\n\t/*\n\t * If the old count is even then the new count is odd, so there's\n\t * no preferred side for the new entry.\n\t * Pick the left one.\n\t */\n\telse\n\t\tisleft = 1;\n\t/*\n\t * Calculate moved entry count.  Positive means left-to-right,\n\t * negative means right-to-left.  Then move the entries.\n\t */\n\tcount = hdr1.count - mid + (isleft == 0);\n\tif (count > 0)\n\t\txfs_dir3_leafn_moveents(args, blk1->bp, &hdr1, ents1,\n\t\t\t\t\thdr1.count - count, blk2->bp,\n\t\t\t\t\t&hdr2, ents2, 0, count);\n\telse if (count < 0)\n\t\txfs_dir3_leafn_moveents(args, blk2->bp, &hdr2, ents2, 0,\n\t\t\t\t\tblk1->bp, &hdr1, ents1,\n\t\t\t\t\thdr1.count, count);\n\n\tASSERT(hdr1.count + hdr2.count == oldsum);\n\tASSERT(hdr1.stale + hdr2.stale == oldstale);\n\n\t/* log the changes made when moving the entries */\n\tdp->d_ops->leaf_hdr_to_disk(leaf1, &hdr1);\n\tdp->d_ops->leaf_hdr_to_disk(leaf2, &hdr2);\n\txfs_dir3_leaf_log_header(args, blk1->bp);\n\txfs_dir3_leaf_log_header(args, blk2->bp);\n\n\txfs_dir3_leaf_check(dp, blk1->bp);\n\txfs_dir3_leaf_check(dp, blk2->bp);\n\n\t/*\n\t * Mark whether we're inserting into the old or new leaf.\n\t */\n\tif (hdr1.count < hdr2.count)\n\t\tstate->inleaf = swap;\n\telse if (hdr1.count > hdr2.count)\n\t\tstate->inleaf = !swap;\n\telse\n\t\tstate->inleaf = swap ^ (blk1->index <= hdr1.count);\n\t/*\n\t * Adjust the expected index for insertion.\n\t */\n\tif (!state->inleaf)\n\t\tblk2->index = blk1->index - hdr1.count;\n\n\t/*\n\t * Finally sanity check just to make sure we are not returning a\n\t * negative index\n\t */\n\tif (blk2->index < 0) {\n\t\tstate->inleaf = 1;\n\t\tblk2->index = 0;\n\t\txfs_alert(dp->i_mount,\n\t\"%s: picked the wrong leaf? reverting original leaf: blk1->index %d\",\n\t\t\t__func__, blk1->index);\n\t}\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);",
      "static void xfs_dir2_leafn_rebalance(xfs_da_state_t *state,\n\t\t\t\t     xfs_da_state_blk_t *blk1,\n\t\t\t\t     xfs_da_state_blk_t *blk2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_alert",
          "args": [
            "dp->i_mount",
            "\"%s: picked the wrong leaf? reverting original leaf: blk1->index %d\"",
            "__func__",
            "blk1->index"
          ],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alert_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_message.c",
          "lines": "67-91",
          "snippet": "void\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}",
          "includes": [
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_check",
          "args": [
            "dp",
            "blk2->bp"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_check",
          "args": [
            "dp",
            "blk1->bp"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_log_header",
          "args": [
            "args",
            "blk2->bp"
          ],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_leaf_log_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "1105-1120",
          "snippet": "void\nxfs_dir3_leaf_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t  (uint)((char *)&leaf->hdr - (char *)leaf),\n\t\t\t  args->dp->d_ops->leaf_hdr_size - 1);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nvoid\nxfs_dir3_leaf_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t  (uint)((char *)&leaf->hdr - (char *)leaf),\n\t\t\t  args->dp->d_ops->leaf_hdr_size - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_hdr_to_disk",
          "args": [
            "leaf2",
            "&hdr2"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_hdr_to_disk",
          "args": [
            "leaf1",
            "&hdr1"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "hdr1.stale + hdr2.stale == oldstale"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "hdr1.count + hdr2.count == oldsum"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leafn_moveents",
          "args": [
            "args",
            "blk2->bp",
            "&hdr2",
            "ents2",
            "0",
            "blk1->bp",
            "&hdr1",
            "ents1",
            "hdr1.count",
            "count"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_leafn_moveents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
          "lines": "832-904",
          "snippet": "static void\nxfs_dir3_leafn_moveents(\n\txfs_da_args_t\t\t\t*args,\t/* operation arguments */\n\tstruct xfs_buf\t\t\t*bp_s,\t/* source */\n\tstruct xfs_dir3_icleaf_hdr\t*shdr,\n\tstruct xfs_dir2_leaf_entry\t*sents,\n\tint\t\t\t\tstart_s,/* source leaf index */\n\tstruct xfs_buf\t\t\t*bp_d,\t/* destination */\n\tstruct xfs_dir3_icleaf_hdr\t*dhdr,\n\tstruct xfs_dir2_leaf_entry\t*dents,\n\tint\t\t\t\tstart_d,/* destination leaf index */\n\tint\t\t\t\tcount)\t/* count of leaves to copy */\n{\n\tint\t\t\t\tstale;\t/* count stale leaves copied */\n\n\ttrace_xfs_dir2_leafn_moveents(args, start_s, start_d, count);\n\n\t/*\n\t * Silently return if nothing to do.\n\t */\n\tif (count == 0)\n\t\treturn;\n\n\t/*\n\t * If the destination index is not the end of the current\n\t * destination leaf entries, open up a hole in the destination\n\t * to hold the new entries.\n\t */\n\tif (start_d < dhdr->count) {\n\t\tmemmove(&dents[start_d + count], &dents[start_d],\n\t\t\t(dhdr->count - start_d) * sizeof(xfs_dir2_leaf_entry_t));\n\t\txfs_dir3_leaf_log_ents(args, bp_d, start_d + count,\n\t\t\t\t       count + dhdr->count - 1);\n\t}\n\t/*\n\t * If the source has stale leaves, count the ones in the copy range\n\t * so we can update the header correctly.\n\t */\n\tif (shdr->stale) {\n\t\tint\ti;\t\t\t/* temp leaf index */\n\n\t\tfor (i = start_s, stale = 0; i < start_s + count; i++) {\n\t\t\tif (sents[i].address ==\n\t\t\t\t\tcpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\t\tstale++;\n\t\t}\n\t} else\n\t\tstale = 0;\n\t/*\n\t * Copy the leaf entries from source to destination.\n\t */\n\tmemcpy(&dents[start_d], &sents[start_s],\n\t\tcount * sizeof(xfs_dir2_leaf_entry_t));\n\txfs_dir3_leaf_log_ents(args, bp_d, start_d, start_d + count - 1);\n\n\t/*\n\t * If there are source entries after the ones we copied,\n\t * delete the ones we copied by sliding the next ones down.\n\t */\n\tif (start_s + count < shdr->count) {\n\t\tmemmove(&sents[start_s], &sents[start_s + count],\n\t\t\tcount * sizeof(xfs_dir2_leaf_entry_t));\n\t\txfs_dir3_leaf_log_ents(args, bp_s, start_s, start_s + count - 1);\n\t}\n\n\t/*\n\t * Update the headers and log them.\n\t */\n\tshdr->count -= count;\n\tshdr->stale -= stale;\n\tdhdr->count += count;\n\tdhdr->stale += stale;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);\n\nstatic void\nxfs_dir3_leafn_moveents(\n\txfs_da_args_t\t\t\t*args,\t/* operation arguments */\n\tstruct xfs_buf\t\t\t*bp_s,\t/* source */\n\tstruct xfs_dir3_icleaf_hdr\t*shdr,\n\tstruct xfs_dir2_leaf_entry\t*sents,\n\tint\t\t\t\tstart_s,/* source leaf index */\n\tstruct xfs_buf\t\t\t*bp_d,\t/* destination */\n\tstruct xfs_dir3_icleaf_hdr\t*dhdr,\n\tstruct xfs_dir2_leaf_entry\t*dents,\n\tint\t\t\t\tstart_d,/* destination leaf index */\n\tint\t\t\t\tcount)\t/* count of leaves to copy */\n{\n\tint\t\t\t\tstale;\t/* count stale leaves copied */\n\n\ttrace_xfs_dir2_leafn_moveents(args, start_s, start_d, count);\n\n\t/*\n\t * Silently return if nothing to do.\n\t */\n\tif (count == 0)\n\t\treturn;\n\n\t/*\n\t * If the destination index is not the end of the current\n\t * destination leaf entries, open up a hole in the destination\n\t * to hold the new entries.\n\t */\n\tif (start_d < dhdr->count) {\n\t\tmemmove(&dents[start_d + count], &dents[start_d],\n\t\t\t(dhdr->count - start_d) * sizeof(xfs_dir2_leaf_entry_t));\n\t\txfs_dir3_leaf_log_ents(args, bp_d, start_d + count,\n\t\t\t\t       count + dhdr->count - 1);\n\t}\n\t/*\n\t * If the source has stale leaves, count the ones in the copy range\n\t * so we can update the header correctly.\n\t */\n\tif (shdr->stale) {\n\t\tint\ti;\t\t\t/* temp leaf index */\n\n\t\tfor (i = start_s, stale = 0; i < start_s + count; i++) {\n\t\t\tif (sents[i].address ==\n\t\t\t\t\tcpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\t\tstale++;\n\t\t}\n\t} else\n\t\tstale = 0;\n\t/*\n\t * Copy the leaf entries from source to destination.\n\t */\n\tmemcpy(&dents[start_d], &sents[start_s],\n\t\tcount * sizeof(xfs_dir2_leaf_entry_t));\n\txfs_dir3_leaf_log_ents(args, bp_d, start_d, start_d + count - 1);\n\n\t/*\n\t * If there are source entries after the ones we copied,\n\t * delete the ones we copied by sliding the next ones down.\n\t */\n\tif (start_s + count < shdr->count) {\n\t\tmemmove(&sents[start_s], &sents[start_s + count],\n\t\t\tcount * sizeof(xfs_dir2_leaf_entry_t));\n\t\txfs_dir3_leaf_log_ents(args, bp_s, start_s, start_s + count - 1);\n\t}\n\n\t/*\n\t * Update the headers and log them.\n\t */\n\tshdr->count -= count;\n\tshdr->stale -= stale;\n\tdhdr->count += count;\n\tdhdr->stale += stale;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ents1[mid].hashval"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ents2[mid - hdr1.count].hashval"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_ents_p",
          "args": [
            "leaf2"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_ents_p",
          "args": [
            "leaf1"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_hdr_from_disk",
          "args": [
            "&hdr2",
            "leaf2"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_hdr_from_disk",
          "args": [
            "&hdr1",
            "leaf1"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leafn_order",
          "args": [
            "dp",
            "blk1->bp",
            "blk2->bp"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leafn_order",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
          "lines": "910-934",
          "snippet": "int\t\t\t\t\t\t/* sort order */\nxfs_dir2_leafn_order(\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_buf\t\t*leaf1_bp,\t\t/* leaf1 buffer */\n\tstruct xfs_buf\t\t*leaf2_bp)\t\t/* leaf2 buffer */\n{\n\tstruct xfs_dir2_leaf\t*leaf1 = leaf1_bp->b_addr;\n\tstruct xfs_dir2_leaf\t*leaf2 = leaf2_bp->b_addr;\n\tstruct xfs_dir2_leaf_entry *ents1;\n\tstruct xfs_dir2_leaf_entry *ents2;\n\tstruct xfs_dir3_icleaf_hdr hdr1;\n\tstruct xfs_dir3_icleaf_hdr hdr2;\n\n\tdp->d_ops->leaf_hdr_from_disk(&hdr1, leaf1);\n\tdp->d_ops->leaf_hdr_from_disk(&hdr2, leaf2);\n\tents1 = dp->d_ops->leaf_ents_p(leaf1);\n\tents2 = dp->d_ops->leaf_ents_p(leaf2);\n\n\tif (hdr1.count > 0 && hdr2.count > 0 &&\n\t    (be32_to_cpu(ents2[0].hashval) < be32_to_cpu(ents1[0].hashval) ||\n\t     be32_to_cpu(ents2[hdr2.count - 1].hashval) <\n\t\t\t\tbe32_to_cpu(ents1[hdr1.count - 1].hashval)))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* sort order */\nxfs_dir2_leafn_order(\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_buf\t\t*leaf1_bp,\t\t/* leaf1 buffer */\n\tstruct xfs_buf\t\t*leaf2_bp)\t\t/* leaf2 buffer */\n{\n\tstruct xfs_dir2_leaf\t*leaf1 = leaf1_bp->b_addr;\n\tstruct xfs_dir2_leaf\t*leaf2 = leaf2_bp->b_addr;\n\tstruct xfs_dir2_leaf_entry *ents1;\n\tstruct xfs_dir2_leaf_entry *ents2;\n\tstruct xfs_dir3_icleaf_hdr hdr1;\n\tstruct xfs_dir3_icleaf_hdr hdr2;\n\n\tdp->d_ops->leaf_hdr_from_disk(&hdr1, leaf1);\n\tdp->d_ops->leaf_hdr_from_disk(&hdr2, leaf2);\n\tents1 = dp->d_ops->leaf_ents_p(leaf1);\n\tents2 = dp->d_ops->leaf_ents_p(leaf2);\n\n\tif (hdr1.count > 0 && hdr2.count > 0 &&\n\t    (be32_to_cpu(ents2[0].hashval) < be32_to_cpu(ents1[0].hashval) ||\n\t     be32_to_cpu(ents2[hdr2.count - 1].hashval) <\n\t\t\t\tbe32_to_cpu(ents1[hdr1.count - 1].hashval)))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);\nstatic void xfs_dir2_leafn_rebalance(xfs_da_state_t *state,\n\t\t\t\t     xfs_da_state_blk_t *blk1,\n\t\t\t\t     xfs_da_state_blk_t *blk2);\n\nstatic void\nxfs_dir2_leafn_rebalance(\n\txfs_da_state_t\t\t*state,\t\t/* btree cursor */\n\txfs_da_state_blk_t\t*blk1,\t\t/* first btree block */\n\txfs_da_state_blk_t\t*blk2)\t\t/* second btree block */\n{\n\txfs_da_args_t\t\t*args;\t\t/* operation arguments */\n\tint\t\t\tcount;\t\t/* count (& direction) leaves */\n\tint\t\t\tisleft;\t\t/* new goes in left leaf */\n\txfs_dir2_leaf_t\t\t*leaf1;\t\t/* first leaf structure */\n\txfs_dir2_leaf_t\t\t*leaf2;\t\t/* second leaf structure */\n\tint\t\t\tmid;\t\t/* midpoint leaf index */\n#if defined(DEBUG) || defined(XFS_WARN)\n\tint\t\t\toldstale;\t/* old count of stale leaves */\n#endif\n\tint\t\t\toldsum;\t\t/* old total leaf count */\n\tint\t\t\tswap;\t\t/* swapped leaf blocks */\n\tstruct xfs_dir2_leaf_entry *ents1;\n\tstruct xfs_dir2_leaf_entry *ents2;\n\tstruct xfs_dir3_icleaf_hdr hdr1;\n\tstruct xfs_dir3_icleaf_hdr hdr2;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\n\targs = state->args;\n\t/*\n\t * If the block order is wrong, swap the arguments.\n\t */\n\tif ((swap = xfs_dir2_leafn_order(dp, blk1->bp, blk2->bp))) {\n\t\txfs_da_state_blk_t\t*tmp;\t/* temp for block swap */\n\n\t\ttmp = blk1;\n\t\tblk1 = blk2;\n\t\tblk2 = tmp;\n\t}\n\tleaf1 = blk1->bp->b_addr;\n\tleaf2 = blk2->bp->b_addr;\n\tdp->d_ops->leaf_hdr_from_disk(&hdr1, leaf1);\n\tdp->d_ops->leaf_hdr_from_disk(&hdr2, leaf2);\n\tents1 = dp->d_ops->leaf_ents_p(leaf1);\n\tents2 = dp->d_ops->leaf_ents_p(leaf2);\n\n\toldsum = hdr1.count + hdr2.count;\n#if defined(DEBUG) || defined(XFS_WARN)\n\toldstale = hdr1.stale + hdr2.stale;\n#endif\n\tmid = oldsum >> 1;\n\n\t/*\n\t * If the old leaf count was odd then the new one will be even,\n\t * so we need to divide the new count evenly.\n\t */\n\tif (oldsum & 1) {\n\t\txfs_dahash_t\tmidhash;\t/* middle entry hash value */\n\n\t\tif (mid >= hdr1.count)\n\t\t\tmidhash = be32_to_cpu(ents2[mid - hdr1.count].hashval);\n\t\telse\n\t\t\tmidhash = be32_to_cpu(ents1[mid].hashval);\n\t\tisleft = args->hashval <= midhash;\n\t}\n\t/*\n\t * If the old count is even then the new count is odd, so there's\n\t * no preferred side for the new entry.\n\t * Pick the left one.\n\t */\n\telse\n\t\tisleft = 1;\n\t/*\n\t * Calculate moved entry count.  Positive means left-to-right,\n\t * negative means right-to-left.  Then move the entries.\n\t */\n\tcount = hdr1.count - mid + (isleft == 0);\n\tif (count > 0)\n\t\txfs_dir3_leafn_moveents(args, blk1->bp, &hdr1, ents1,\n\t\t\t\t\thdr1.count - count, blk2->bp,\n\t\t\t\t\t&hdr2, ents2, 0, count);\n\telse if (count < 0)\n\t\txfs_dir3_leafn_moveents(args, blk2->bp, &hdr2, ents2, 0,\n\t\t\t\t\tblk1->bp, &hdr1, ents1,\n\t\t\t\t\thdr1.count, count);\n\n\tASSERT(hdr1.count + hdr2.count == oldsum);\n\tASSERT(hdr1.stale + hdr2.stale == oldstale);\n\n\t/* log the changes made when moving the entries */\n\tdp->d_ops->leaf_hdr_to_disk(leaf1, &hdr1);\n\tdp->d_ops->leaf_hdr_to_disk(leaf2, &hdr2);\n\txfs_dir3_leaf_log_header(args, blk1->bp);\n\txfs_dir3_leaf_log_header(args, blk2->bp);\n\n\txfs_dir3_leaf_check(dp, blk1->bp);\n\txfs_dir3_leaf_check(dp, blk2->bp);\n\n\t/*\n\t * Mark whether we're inserting into the old or new leaf.\n\t */\n\tif (hdr1.count < hdr2.count)\n\t\tstate->inleaf = swap;\n\telse if (hdr1.count > hdr2.count)\n\t\tstate->inleaf = !swap;\n\telse\n\t\tstate->inleaf = swap ^ (blk1->index <= hdr1.count);\n\t/*\n\t * Adjust the expected index for insertion.\n\t */\n\tif (!state->inleaf)\n\t\tblk2->index = blk1->index - hdr1.count;\n\n\t/*\n\t * Finally sanity check just to make sure we are not returning a\n\t * negative index\n\t */\n\tif (blk2->index < 0) {\n\t\tstate->inleaf = 1;\n\t\tblk2->index = 0;\n\t\txfs_alert(dp->i_mount,\n\t\"%s: picked the wrong leaf? reverting original leaf: blk1->index %d\",\n\t\t\t__func__, blk1->index);\n\t}\n}"
  },
  {
    "function_name": "xfs_dir2_leafn_order",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
    "lines": "910-934",
    "snippet": "int\t\t\t\t\t\t/* sort order */\nxfs_dir2_leafn_order(\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_buf\t\t*leaf1_bp,\t\t/* leaf1 buffer */\n\tstruct xfs_buf\t\t*leaf2_bp)\t\t/* leaf2 buffer */\n{\n\tstruct xfs_dir2_leaf\t*leaf1 = leaf1_bp->b_addr;\n\tstruct xfs_dir2_leaf\t*leaf2 = leaf2_bp->b_addr;\n\tstruct xfs_dir2_leaf_entry *ents1;\n\tstruct xfs_dir2_leaf_entry *ents2;\n\tstruct xfs_dir3_icleaf_hdr hdr1;\n\tstruct xfs_dir3_icleaf_hdr hdr2;\n\n\tdp->d_ops->leaf_hdr_from_disk(&hdr1, leaf1);\n\tdp->d_ops->leaf_hdr_from_disk(&hdr2, leaf2);\n\tents1 = dp->d_ops->leaf_ents_p(leaf1);\n\tents2 = dp->d_ops->leaf_ents_p(leaf2);\n\n\tif (hdr1.count > 0 && hdr2.count > 0 &&\n\t    (be32_to_cpu(ents2[0].hashval) < be32_to_cpu(ents1[0].hashval) ||\n\t     be32_to_cpu(ents2[hdr2.count - 1].hashval) <\n\t\t\t\tbe32_to_cpu(ents1[hdr1.count - 1].hashval)))\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ents1[hdr1.count - 1].hashval"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ents2[hdr2.count - 1].hashval"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ents1[0].hashval"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ents2[0].hashval"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_ents_p",
          "args": [
            "leaf2"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_ents_p",
          "args": [
            "leaf1"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_hdr_from_disk",
          "args": [
            "&hdr2",
            "leaf2"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_hdr_from_disk",
          "args": [
            "&hdr1",
            "leaf1"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* sort order */\nxfs_dir2_leafn_order(\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_buf\t\t*leaf1_bp,\t\t/* leaf1 buffer */\n\tstruct xfs_buf\t\t*leaf2_bp)\t\t/* leaf2 buffer */\n{\n\tstruct xfs_dir2_leaf\t*leaf1 = leaf1_bp->b_addr;\n\tstruct xfs_dir2_leaf\t*leaf2 = leaf2_bp->b_addr;\n\tstruct xfs_dir2_leaf_entry *ents1;\n\tstruct xfs_dir2_leaf_entry *ents2;\n\tstruct xfs_dir3_icleaf_hdr hdr1;\n\tstruct xfs_dir3_icleaf_hdr hdr2;\n\n\tdp->d_ops->leaf_hdr_from_disk(&hdr1, leaf1);\n\tdp->d_ops->leaf_hdr_from_disk(&hdr2, leaf2);\n\tents1 = dp->d_ops->leaf_ents_p(leaf1);\n\tents2 = dp->d_ops->leaf_ents_p(leaf2);\n\n\tif (hdr1.count > 0 && hdr2.count > 0 &&\n\t    (be32_to_cpu(ents2[0].hashval) < be32_to_cpu(ents1[0].hashval) ||\n\t     be32_to_cpu(ents2[hdr2.count - 1].hashval) <\n\t\t\t\tbe32_to_cpu(ents1[hdr1.count - 1].hashval)))\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_dir3_leafn_moveents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
    "lines": "832-904",
    "snippet": "static void\nxfs_dir3_leafn_moveents(\n\txfs_da_args_t\t\t\t*args,\t/* operation arguments */\n\tstruct xfs_buf\t\t\t*bp_s,\t/* source */\n\tstruct xfs_dir3_icleaf_hdr\t*shdr,\n\tstruct xfs_dir2_leaf_entry\t*sents,\n\tint\t\t\t\tstart_s,/* source leaf index */\n\tstruct xfs_buf\t\t\t*bp_d,\t/* destination */\n\tstruct xfs_dir3_icleaf_hdr\t*dhdr,\n\tstruct xfs_dir2_leaf_entry\t*dents,\n\tint\t\t\t\tstart_d,/* destination leaf index */\n\tint\t\t\t\tcount)\t/* count of leaves to copy */\n{\n\tint\t\t\t\tstale;\t/* count stale leaves copied */\n\n\ttrace_xfs_dir2_leafn_moveents(args, start_s, start_d, count);\n\n\t/*\n\t * Silently return if nothing to do.\n\t */\n\tif (count == 0)\n\t\treturn;\n\n\t/*\n\t * If the destination index is not the end of the current\n\t * destination leaf entries, open up a hole in the destination\n\t * to hold the new entries.\n\t */\n\tif (start_d < dhdr->count) {\n\t\tmemmove(&dents[start_d + count], &dents[start_d],\n\t\t\t(dhdr->count - start_d) * sizeof(xfs_dir2_leaf_entry_t));\n\t\txfs_dir3_leaf_log_ents(args, bp_d, start_d + count,\n\t\t\t\t       count + dhdr->count - 1);\n\t}\n\t/*\n\t * If the source has stale leaves, count the ones in the copy range\n\t * so we can update the header correctly.\n\t */\n\tif (shdr->stale) {\n\t\tint\ti;\t\t\t/* temp leaf index */\n\n\t\tfor (i = start_s, stale = 0; i < start_s + count; i++) {\n\t\t\tif (sents[i].address ==\n\t\t\t\t\tcpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\t\tstale++;\n\t\t}\n\t} else\n\t\tstale = 0;\n\t/*\n\t * Copy the leaf entries from source to destination.\n\t */\n\tmemcpy(&dents[start_d], &sents[start_s],\n\t\tcount * sizeof(xfs_dir2_leaf_entry_t));\n\txfs_dir3_leaf_log_ents(args, bp_d, start_d, start_d + count - 1);\n\n\t/*\n\t * If there are source entries after the ones we copied,\n\t * delete the ones we copied by sliding the next ones down.\n\t */\n\tif (start_s + count < shdr->count) {\n\t\tmemmove(&sents[start_s], &sents[start_s + count],\n\t\t\tcount * sizeof(xfs_dir2_leaf_entry_t));\n\t\txfs_dir3_leaf_log_ents(args, bp_s, start_s, start_s + count - 1);\n\t}\n\n\t/*\n\t * Update the headers and log them.\n\t */\n\tshdr->count -= count;\n\tshdr->stale -= stale;\n\tdhdr->count += count;\n\tdhdr->stale += stale;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_log_ents",
          "args": [
            "args",
            "bp_s",
            "start_s",
            "start_s + count - 1"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_leaf_log_ents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "1077-1100",
          "snippet": "void\nxfs_dir3_leaf_log_ents(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\n\tint\t\t\tlast)\n{\n\txfs_dir2_leaf_entry_t\t*firstlep;\t/* pointer to first entry */\n\txfs_dir2_leaf_entry_t\t*lastlep;\t/* pointer to last entry */\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\tstruct xfs_dir2_leaf_entry *ents;\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\tents = args->dp->d_ops->leaf_ents_p(leaf);\n\tfirstlep = &ents[first];\n\tlastlep = &ents[last];\n\txfs_trans_log_buf(args->trans, bp,\n\t\t(uint)((char *)firstlep - (char *)leaf),\n\t\t(uint)((char *)lastlep - (char *)leaf + sizeof(*lastlep) - 1));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);",
            "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nvoid\nxfs_dir3_leaf_log_ents(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\n\tint\t\t\tlast)\n{\n\txfs_dir2_leaf_entry_t\t*firstlep;\t/* pointer to first entry */\n\txfs_dir2_leaf_entry_t\t*lastlep;\t/* pointer to last entry */\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\tstruct xfs_dir2_leaf_entry *ents;\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\tents = args->dp->d_ops->leaf_ents_p(leaf);\n\tfirstlep = &ents[first];\n\tlastlep = &ents[last];\n\txfs_trans_log_buf(args->trans, bp,\n\t\t(uint)((char *)firstlep - (char *)leaf),\n\t\t(uint)((char *)lastlep - (char *)leaf + sizeof(*lastlep) - 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&sents[start_s]",
            "&sents[start_s + count]",
            "count * sizeof(xfs_dir2_leaf_entry_t)"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&dents[start_d]",
            "&sents[start_s]",
            "count * sizeof(xfs_dir2_leaf_entry_t)"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_NULL_DATAPTR"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&dents[start_d + count]",
            "&dents[start_d]",
            "(dhdr->count - start_d) * sizeof(xfs_dir2_leaf_entry_t)"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_dir2_leafn_moveents",
          "args": [
            "args",
            "start_s",
            "start_d",
            "count"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);\n\nstatic void\nxfs_dir3_leafn_moveents(\n\txfs_da_args_t\t\t\t*args,\t/* operation arguments */\n\tstruct xfs_buf\t\t\t*bp_s,\t/* source */\n\tstruct xfs_dir3_icleaf_hdr\t*shdr,\n\tstruct xfs_dir2_leaf_entry\t*sents,\n\tint\t\t\t\tstart_s,/* source leaf index */\n\tstruct xfs_buf\t\t\t*bp_d,\t/* destination */\n\tstruct xfs_dir3_icleaf_hdr\t*dhdr,\n\tstruct xfs_dir2_leaf_entry\t*dents,\n\tint\t\t\t\tstart_d,/* destination leaf index */\n\tint\t\t\t\tcount)\t/* count of leaves to copy */\n{\n\tint\t\t\t\tstale;\t/* count stale leaves copied */\n\n\ttrace_xfs_dir2_leafn_moveents(args, start_s, start_d, count);\n\n\t/*\n\t * Silently return if nothing to do.\n\t */\n\tif (count == 0)\n\t\treturn;\n\n\t/*\n\t * If the destination index is not the end of the current\n\t * destination leaf entries, open up a hole in the destination\n\t * to hold the new entries.\n\t */\n\tif (start_d < dhdr->count) {\n\t\tmemmove(&dents[start_d + count], &dents[start_d],\n\t\t\t(dhdr->count - start_d) * sizeof(xfs_dir2_leaf_entry_t));\n\t\txfs_dir3_leaf_log_ents(args, bp_d, start_d + count,\n\t\t\t\t       count + dhdr->count - 1);\n\t}\n\t/*\n\t * If the source has stale leaves, count the ones in the copy range\n\t * so we can update the header correctly.\n\t */\n\tif (shdr->stale) {\n\t\tint\ti;\t\t\t/* temp leaf index */\n\n\t\tfor (i = start_s, stale = 0; i < start_s + count; i++) {\n\t\t\tif (sents[i].address ==\n\t\t\t\t\tcpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\t\tstale++;\n\t\t}\n\t} else\n\t\tstale = 0;\n\t/*\n\t * Copy the leaf entries from source to destination.\n\t */\n\tmemcpy(&dents[start_d], &sents[start_s],\n\t\tcount * sizeof(xfs_dir2_leaf_entry_t));\n\txfs_dir3_leaf_log_ents(args, bp_d, start_d, start_d + count - 1);\n\n\t/*\n\t * If there are source entries after the ones we copied,\n\t * delete the ones we copied by sliding the next ones down.\n\t */\n\tif (start_s + count < shdr->count) {\n\t\tmemmove(&sents[start_s], &sents[start_s + count],\n\t\t\tcount * sizeof(xfs_dir2_leaf_entry_t));\n\t\txfs_dir3_leaf_log_ents(args, bp_s, start_s, start_s + count - 1);\n\t}\n\n\t/*\n\t * Update the headers and log them.\n\t */\n\tshdr->count -= count;\n\tshdr->stale -= stale;\n\tdhdr->count += count;\n\tdhdr->stale += stale;\n}"
  },
  {
    "function_name": "xfs_dir2_leafn_lookup_int",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
    "lines": "815-826",
    "snippet": "int\nxfs_dir2_leafn_lookup_int(\n\tstruct xfs_buf\t\t*bp,\t\t/* leaf buffer */\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tint\t\t\t*indexp,\t/* out: leaf entry index */\n\txfs_da_state_t\t\t*state)\t\t/* state to fill in */\n{\n\tif (args->op_flags & XFS_DA_OP_ADDNAME)\n\t\treturn xfs_dir2_leafn_lookup_for_addname(bp, args, indexp,\n\t\t\t\t\t\t\tstate);\n\treturn xfs_dir2_leafn_lookup_for_entry(bp, args, indexp, state);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_dir2_leafn_lookup_for_entry",
          "args": [
            "bp",
            "args",
            "indexp",
            "state"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leafn_lookup_for_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
          "lines": "662-808",
          "snippet": "STATIC int\nxfs_dir2_leafn_lookup_for_entry(\n\tstruct xfs_buf\t\t*bp,\t\t/* leaf buffer */\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tint\t\t\t*indexp,\t/* out: leaf entry index */\n\txfs_da_state_t\t\t*state)\t\t/* state to fill in */\n{\n\tstruct xfs_buf\t\t*curbp = NULL;\t/* current data/free buffer */\n\txfs_dir2_db_t\t\tcurdb = -1;\t/* current data block number */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data block entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tindex;\t\t/* leaf entry index */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\txfs_dir2_db_t\t\tnewdb;\t\t/* new data block number */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tenum xfs_dacmp\t\tcmp;\t\t/* comparison result */\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\tdp = args->dp;\n\ttp = args->trans;\n\tmp = dp->i_mount;\n\tleaf = bp->b_addr;\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\n\txfs_dir3_leaf_check(dp, bp);\n\tASSERT(leafhdr.count > 0);\n\n\t/*\n\t * Look up the hash value in the leaf entries.\n\t */\n\tindex = xfs_dir2_leaf_search_hash(args, bp);\n\t/*\n\t * Do we have a buffer coming in?\n\t */\n\tif (state->extravalid) {\n\t\tcurbp = state->extrablk.bp;\n\t\tcurdb = state->extrablk.blkno;\n\t}\n\t/*\n\t * Loop over leaf entries with the right hash value.\n\t */\n\tfor (lep = &ents[index];\n\t     index < leafhdr.count && be32_to_cpu(lep->hashval) == args->hashval;\n\t     lep++, index++) {\n\t\t/*\n\t\t * Skip stale leaf entries.\n\t\t */\n\t\tif (be32_to_cpu(lep->address) == XFS_DIR2_NULL_DATAPTR)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Pull the data block number from the entry.\n\t\t */\n\t\tnewdb = xfs_dir2_dataptr_to_db(args->geo,\n\t\t\t\t\t       be32_to_cpu(lep->address));\n\t\t/*\n\t\t * Not adding a new entry, so we really want to find\n\t\t * the name given to us.\n\t\t *\n\t\t * If it's a different data block, go get it.\n\t\t */\n\t\tif (newdb != curdb) {\n\t\t\t/*\n\t\t\t * If we had a block before that we aren't saving\n\t\t\t * for a CI name, drop it\n\t\t\t */\n\t\t\tif (curbp && (args->cmpresult == XFS_CMP_DIFFERENT ||\n\t\t\t\t\t\tcurdb != state->extrablk.blkno))\n\t\t\t\txfs_trans_brelse(tp, curbp);\n\t\t\t/*\n\t\t\t * If needing the block that is saved with a CI match,\n\t\t\t * use it otherwise read in the new data block.\n\t\t\t */\n\t\t\tif (args->cmpresult != XFS_CMP_DIFFERENT &&\n\t\t\t\t\tnewdb == state->extrablk.blkno) {\n\t\t\t\tASSERT(state->extravalid);\n\t\t\t\tcurbp = state->extrablk.bp;\n\t\t\t} else {\n\t\t\t\terror = xfs_dir3_data_read(tp, dp,\n\t\t\t\t\t\txfs_dir2_db_to_da(args->geo,\n\t\t\t\t\t\t\t\t  newdb),\n\t\t\t\t\t\t-1, &curbp);\n\t\t\t\tif (error)\n\t\t\t\t\treturn error;\n\t\t\t}\n\t\t\txfs_dir3_data_check(dp, curbp);\n\t\t\tcurdb = newdb;\n\t\t}\n\t\t/*\n\t\t * Point to the data entry.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)((char *)curbp->b_addr +\n\t\t\txfs_dir2_dataptr_to_off(args->geo,\n\t\t\t\t\t\tbe32_to_cpu(lep->address)));\n\t\t/*\n\t\t * Compare the entry and if it's an exact match, return\n\t\t * EEXIST immediately. If it's the first case-insensitive\n\t\t * match, store the block & inode number and continue looking.\n\t\t */\n\t\tcmp = mp->m_dirnameops->compname(args, dep->name, dep->namelen);\n\t\tif (cmp != XFS_CMP_DIFFERENT && cmp != args->cmpresult) {\n\t\t\t/* If there is a CI match block, drop it */\n\t\t\tif (args->cmpresult != XFS_CMP_DIFFERENT &&\n\t\t\t\t\t\tcurdb != state->extrablk.blkno)\n\t\t\t\txfs_trans_brelse(tp, state->extrablk.bp);\n\t\t\targs->cmpresult = cmp;\n\t\t\targs->inumber = be64_to_cpu(dep->inumber);\n\t\t\targs->filetype = dp->d_ops->data_get_ftype(dep);\n\t\t\t*indexp = index;\n\t\t\tstate->extravalid = 1;\n\t\t\tstate->extrablk.bp = curbp;\n\t\t\tstate->extrablk.blkno = curdb;\n\t\t\tstate->extrablk.index = (int)((char *)dep -\n\t\t\t\t\t\t\t(char *)curbp->b_addr);\n\t\t\tstate->extrablk.magic = XFS_DIR2_DATA_MAGIC;\n\t\t\tcurbp->b_ops = &xfs_dir3_data_buf_ops;\n\t\t\txfs_trans_buf_set_type(tp, curbp, XFS_BLFT_DIR_DATA_BUF);\n\t\t\tif (cmp == XFS_CMP_EXACT)\n\t\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\tASSERT(index == leafhdr.count || (args->op_flags & XFS_DA_OP_OKNOENT));\n\tif (curbp) {\n\t\tif (args->cmpresult == XFS_CMP_DIFFERENT) {\n\t\t\t/* Giving back last used data block. */\n\t\t\tstate->extravalid = 1;\n\t\t\tstate->extrablk.bp = curbp;\n\t\t\tstate->extrablk.index = -1;\n\t\t\tstate->extrablk.blkno = curdb;\n\t\t\tstate->extrablk.magic = XFS_DIR2_DATA_MAGIC;\n\t\t\tcurbp->b_ops = &xfs_dir3_data_buf_ops;\n\t\t\txfs_trans_buf_set_type(tp, curbp, XFS_BLFT_DIR_DATA_BUF);\n\t\t} else {\n\t\t\t/* If the curbp is not the CI match block, drop it */\n\t\t\tif (state->extrablk.bp != curbp)\n\t\t\t\txfs_trans_brelse(tp, curbp);\n\t\t}\n\t} else {\n\t\tstate->extravalid = 0;\n\t}\n\t*indexp = index;\n\treturn -ENOENT;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);\n\nSTATIC int\nxfs_dir2_leafn_lookup_for_entry(\n\tstruct xfs_buf\t\t*bp,\t\t/* leaf buffer */\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tint\t\t\t*indexp,\t/* out: leaf entry index */\n\txfs_da_state_t\t\t*state)\t\t/* state to fill in */\n{\n\tstruct xfs_buf\t\t*curbp = NULL;\t/* current data/free buffer */\n\txfs_dir2_db_t\t\tcurdb = -1;\t/* current data block number */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data block entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tindex;\t\t/* leaf entry index */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\txfs_dir2_db_t\t\tnewdb;\t\t/* new data block number */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tenum xfs_dacmp\t\tcmp;\t\t/* comparison result */\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\tdp = args->dp;\n\ttp = args->trans;\n\tmp = dp->i_mount;\n\tleaf = bp->b_addr;\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\n\txfs_dir3_leaf_check(dp, bp);\n\tASSERT(leafhdr.count > 0);\n\n\t/*\n\t * Look up the hash value in the leaf entries.\n\t */\n\tindex = xfs_dir2_leaf_search_hash(args, bp);\n\t/*\n\t * Do we have a buffer coming in?\n\t */\n\tif (state->extravalid) {\n\t\tcurbp = state->extrablk.bp;\n\t\tcurdb = state->extrablk.blkno;\n\t}\n\t/*\n\t * Loop over leaf entries with the right hash value.\n\t */\n\tfor (lep = &ents[index];\n\t     index < leafhdr.count && be32_to_cpu(lep->hashval) == args->hashval;\n\t     lep++, index++) {\n\t\t/*\n\t\t * Skip stale leaf entries.\n\t\t */\n\t\tif (be32_to_cpu(lep->address) == XFS_DIR2_NULL_DATAPTR)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Pull the data block number from the entry.\n\t\t */\n\t\tnewdb = xfs_dir2_dataptr_to_db(args->geo,\n\t\t\t\t\t       be32_to_cpu(lep->address));\n\t\t/*\n\t\t * Not adding a new entry, so we really want to find\n\t\t * the name given to us.\n\t\t *\n\t\t * If it's a different data block, go get it.\n\t\t */\n\t\tif (newdb != curdb) {\n\t\t\t/*\n\t\t\t * If we had a block before that we aren't saving\n\t\t\t * for a CI name, drop it\n\t\t\t */\n\t\t\tif (curbp && (args->cmpresult == XFS_CMP_DIFFERENT ||\n\t\t\t\t\t\tcurdb != state->extrablk.blkno))\n\t\t\t\txfs_trans_brelse(tp, curbp);\n\t\t\t/*\n\t\t\t * If needing the block that is saved with a CI match,\n\t\t\t * use it otherwise read in the new data block.\n\t\t\t */\n\t\t\tif (args->cmpresult != XFS_CMP_DIFFERENT &&\n\t\t\t\t\tnewdb == state->extrablk.blkno) {\n\t\t\t\tASSERT(state->extravalid);\n\t\t\t\tcurbp = state->extrablk.bp;\n\t\t\t} else {\n\t\t\t\terror = xfs_dir3_data_read(tp, dp,\n\t\t\t\t\t\txfs_dir2_db_to_da(args->geo,\n\t\t\t\t\t\t\t\t  newdb),\n\t\t\t\t\t\t-1, &curbp);\n\t\t\t\tif (error)\n\t\t\t\t\treturn error;\n\t\t\t}\n\t\t\txfs_dir3_data_check(dp, curbp);\n\t\t\tcurdb = newdb;\n\t\t}\n\t\t/*\n\t\t * Point to the data entry.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)((char *)curbp->b_addr +\n\t\t\txfs_dir2_dataptr_to_off(args->geo,\n\t\t\t\t\t\tbe32_to_cpu(lep->address)));\n\t\t/*\n\t\t * Compare the entry and if it's an exact match, return\n\t\t * EEXIST immediately. If it's the first case-insensitive\n\t\t * match, store the block & inode number and continue looking.\n\t\t */\n\t\tcmp = mp->m_dirnameops->compname(args, dep->name, dep->namelen);\n\t\tif (cmp != XFS_CMP_DIFFERENT && cmp != args->cmpresult) {\n\t\t\t/* If there is a CI match block, drop it */\n\t\t\tif (args->cmpresult != XFS_CMP_DIFFERENT &&\n\t\t\t\t\t\tcurdb != state->extrablk.blkno)\n\t\t\t\txfs_trans_brelse(tp, state->extrablk.bp);\n\t\t\targs->cmpresult = cmp;\n\t\t\targs->inumber = be64_to_cpu(dep->inumber);\n\t\t\targs->filetype = dp->d_ops->data_get_ftype(dep);\n\t\t\t*indexp = index;\n\t\t\tstate->extravalid = 1;\n\t\t\tstate->extrablk.bp = curbp;\n\t\t\tstate->extrablk.blkno = curdb;\n\t\t\tstate->extrablk.index = (int)((char *)dep -\n\t\t\t\t\t\t\t(char *)curbp->b_addr);\n\t\t\tstate->extrablk.magic = XFS_DIR2_DATA_MAGIC;\n\t\t\tcurbp->b_ops = &xfs_dir3_data_buf_ops;\n\t\t\txfs_trans_buf_set_type(tp, curbp, XFS_BLFT_DIR_DATA_BUF);\n\t\t\tif (cmp == XFS_CMP_EXACT)\n\t\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\tASSERT(index == leafhdr.count || (args->op_flags & XFS_DA_OP_OKNOENT));\n\tif (curbp) {\n\t\tif (args->cmpresult == XFS_CMP_DIFFERENT) {\n\t\t\t/* Giving back last used data block. */\n\t\t\tstate->extravalid = 1;\n\t\t\tstate->extrablk.bp = curbp;\n\t\t\tstate->extrablk.index = -1;\n\t\t\tstate->extrablk.blkno = curdb;\n\t\t\tstate->extrablk.magic = XFS_DIR2_DATA_MAGIC;\n\t\t\tcurbp->b_ops = &xfs_dir3_data_buf_ops;\n\t\t\txfs_trans_buf_set_type(tp, curbp, XFS_BLFT_DIR_DATA_BUF);\n\t\t} else {\n\t\t\t/* If the curbp is not the CI match block, drop it */\n\t\t\tif (state->extrablk.bp != curbp)\n\t\t\t\txfs_trans_brelse(tp, curbp);\n\t\t}\n\t} else {\n\t\tstate->extravalid = 0;\n\t}\n\t*indexp = index;\n\treturn -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leafn_lookup_for_addname",
          "args": [
            "bp",
            "args",
            "indexp",
            "state"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leafn_lookup_for_addname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
          "lines": "507-656",
          "snippet": "STATIC int\nxfs_dir2_leafn_lookup_for_addname(\n\tstruct xfs_buf\t\t*bp,\t\t/* leaf buffer */\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tint\t\t\t*indexp,\t/* out: leaf entry index */\n\txfs_da_state_t\t\t*state)\t\t/* state to fill in */\n{\n\tstruct xfs_buf\t\t*curbp = NULL;\t/* current data/free buffer */\n\txfs_dir2_db_t\t\tcurdb = -1;\t/* current data block number */\n\txfs_dir2_db_t\t\tcurfdb = -1;\t/* current free block number */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tfi;\t\t/* free entry index */\n\txfs_dir2_free_t\t\t*free = NULL;\t/* free block structure */\n\tint\t\t\tindex;\t\t/* leaf entry index */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\tint\t\t\tlength;\t\t/* length of new data entry */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\txfs_dir2_db_t\t\tnewdb;\t\t/* new data block number */\n\txfs_dir2_db_t\t\tnewfdb;\t\t/* new free block number */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\tdp = args->dp;\n\ttp = args->trans;\n\tmp = dp->i_mount;\n\tleaf = bp->b_addr;\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\n\txfs_dir3_leaf_check(dp, bp);\n\tASSERT(leafhdr.count > 0);\n\n\t/*\n\t * Look up the hash value in the leaf entries.\n\t */\n\tindex = xfs_dir2_leaf_search_hash(args, bp);\n\t/*\n\t * Do we have a buffer coming in?\n\t */\n\tif (state->extravalid) {\n\t\t/* If so, it's a free block buffer, get the block number. */\n\t\tcurbp = state->extrablk.bp;\n\t\tcurfdb = state->extrablk.blkno;\n\t\tfree = curbp->b_addr;\n\t\tASSERT(free->hdr.magic == cpu_to_be32(XFS_DIR2_FREE_MAGIC) ||\n\t\t       free->hdr.magic == cpu_to_be32(XFS_DIR3_FREE_MAGIC));\n\t}\n\tlength = dp->d_ops->data_entsize(args->namelen);\n\t/*\n\t * Loop over leaf entries with the right hash value.\n\t */\n\tfor (lep = &ents[index];\n\t     index < leafhdr.count && be32_to_cpu(lep->hashval) == args->hashval;\n\t     lep++, index++) {\n\t\t/*\n\t\t * Skip stale leaf entries.\n\t\t */\n\t\tif (be32_to_cpu(lep->address) == XFS_DIR2_NULL_DATAPTR)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Pull the data block number from the entry.\n\t\t */\n\t\tnewdb = xfs_dir2_dataptr_to_db(args->geo,\n\t\t\t\t\t       be32_to_cpu(lep->address));\n\t\t/*\n\t\t * For addname, we're looking for a place to put the new entry.\n\t\t * We want to use a data block with an entry of equal\n\t\t * hash value to ours if there is one with room.\n\t\t *\n\t\t * If this block isn't the data block we already have\n\t\t * in hand, take a look at it.\n\t\t */\n\t\tif (newdb != curdb) {\n\t\t\t__be16 *bests;\n\n\t\t\tcurdb = newdb;\n\t\t\t/*\n\t\t\t * Convert the data block to the free block\n\t\t\t * holding its freespace information.\n\t\t\t */\n\t\t\tnewfdb = dp->d_ops->db_to_fdb(args->geo, newdb);\n\t\t\t/*\n\t\t\t * If it's not the one we have in hand, read it in.\n\t\t\t */\n\t\t\tif (newfdb != curfdb) {\n\t\t\t\t/*\n\t\t\t\t * If we had one before, drop it.\n\t\t\t\t */\n\t\t\t\tif (curbp)\n\t\t\t\t\txfs_trans_brelse(tp, curbp);\n\n\t\t\t\terror = xfs_dir2_free_read(tp, dp,\n\t\t\t\t\t\txfs_dir2_db_to_da(args->geo,\n\t\t\t\t\t\t\t\t  newfdb),\n\t\t\t\t\t\t&curbp);\n\t\t\t\tif (error)\n\t\t\t\t\treturn error;\n\t\t\t\tfree = curbp->b_addr;\n\n\t\t\t\txfs_dir2_free_hdr_check(dp, curbp, curdb);\n\t\t\t}\n\t\t\t/*\n\t\t\t * Get the index for our entry.\n\t\t\t */\n\t\t\tfi = dp->d_ops->db_to_fdindex(args->geo, curdb);\n\t\t\t/*\n\t\t\t * If it has room, return it.\n\t\t\t */\n\t\t\tbests = dp->d_ops->free_bests_p(free);\n\t\t\tif (unlikely(bests[fi] == cpu_to_be16(NULLDATAOFF))) {\n\t\t\t\tXFS_ERROR_REPORT(\"xfs_dir2_leafn_lookup_int\",\n\t\t\t\t\t\t\tXFS_ERRLEVEL_LOW, mp);\n\t\t\t\tif (curfdb != newfdb)\n\t\t\t\t\txfs_trans_brelse(tp, curbp);\n\t\t\t\treturn -EFSCORRUPTED;\n\t\t\t}\n\t\t\tcurfdb = newfdb;\n\t\t\tif (be16_to_cpu(bests[fi]) >= length)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\t/* Didn't find any space */\n\tfi = -1;\nout:\n\tASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\n\tif (curbp) {\n\t\t/* Giving back a free block. */\n\t\tstate->extravalid = 1;\n\t\tstate->extrablk.bp = curbp;\n\t\tstate->extrablk.index = fi;\n\t\tstate->extrablk.blkno = curfdb;\n\n\t\t/*\n\t\t * Important: this magic number is not in the buffer - it's for\n\t\t * buffer type information and therefore only the free/data type\n\t\t * matters here, not whether CRCs are enabled or not.\n\t\t */\n\t\tstate->extrablk.magic = XFS_DIR2_FREE_MAGIC;\n\t} else {\n\t\tstate->extravalid = 0;\n\t}\n\t/*\n\t * Return the index, that will be the insertion point.\n\t */\n\t*indexp = index;\n\treturn -ENOENT;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);\n\nSTATIC int\nxfs_dir2_leafn_lookup_for_addname(\n\tstruct xfs_buf\t\t*bp,\t\t/* leaf buffer */\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tint\t\t\t*indexp,\t/* out: leaf entry index */\n\txfs_da_state_t\t\t*state)\t\t/* state to fill in */\n{\n\tstruct xfs_buf\t\t*curbp = NULL;\t/* current data/free buffer */\n\txfs_dir2_db_t\t\tcurdb = -1;\t/* current data block number */\n\txfs_dir2_db_t\t\tcurfdb = -1;\t/* current free block number */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tfi;\t\t/* free entry index */\n\txfs_dir2_free_t\t\t*free = NULL;\t/* free block structure */\n\tint\t\t\tindex;\t\t/* leaf entry index */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\tint\t\t\tlength;\t\t/* length of new data entry */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\txfs_dir2_db_t\t\tnewdb;\t\t/* new data block number */\n\txfs_dir2_db_t\t\tnewfdb;\t\t/* new free block number */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\tdp = args->dp;\n\ttp = args->trans;\n\tmp = dp->i_mount;\n\tleaf = bp->b_addr;\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\n\txfs_dir3_leaf_check(dp, bp);\n\tASSERT(leafhdr.count > 0);\n\n\t/*\n\t * Look up the hash value in the leaf entries.\n\t */\n\tindex = xfs_dir2_leaf_search_hash(args, bp);\n\t/*\n\t * Do we have a buffer coming in?\n\t */\n\tif (state->extravalid) {\n\t\t/* If so, it's a free block buffer, get the block number. */\n\t\tcurbp = state->extrablk.bp;\n\t\tcurfdb = state->extrablk.blkno;\n\t\tfree = curbp->b_addr;\n\t\tASSERT(free->hdr.magic == cpu_to_be32(XFS_DIR2_FREE_MAGIC) ||\n\t\t       free->hdr.magic == cpu_to_be32(XFS_DIR3_FREE_MAGIC));\n\t}\n\tlength = dp->d_ops->data_entsize(args->namelen);\n\t/*\n\t * Loop over leaf entries with the right hash value.\n\t */\n\tfor (lep = &ents[index];\n\t     index < leafhdr.count && be32_to_cpu(lep->hashval) == args->hashval;\n\t     lep++, index++) {\n\t\t/*\n\t\t * Skip stale leaf entries.\n\t\t */\n\t\tif (be32_to_cpu(lep->address) == XFS_DIR2_NULL_DATAPTR)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Pull the data block number from the entry.\n\t\t */\n\t\tnewdb = xfs_dir2_dataptr_to_db(args->geo,\n\t\t\t\t\t       be32_to_cpu(lep->address));\n\t\t/*\n\t\t * For addname, we're looking for a place to put the new entry.\n\t\t * We want to use a data block with an entry of equal\n\t\t * hash value to ours if there is one with room.\n\t\t *\n\t\t * If this block isn't the data block we already have\n\t\t * in hand, take a look at it.\n\t\t */\n\t\tif (newdb != curdb) {\n\t\t\t__be16 *bests;\n\n\t\t\tcurdb = newdb;\n\t\t\t/*\n\t\t\t * Convert the data block to the free block\n\t\t\t * holding its freespace information.\n\t\t\t */\n\t\t\tnewfdb = dp->d_ops->db_to_fdb(args->geo, newdb);\n\t\t\t/*\n\t\t\t * If it's not the one we have in hand, read it in.\n\t\t\t */\n\t\t\tif (newfdb != curfdb) {\n\t\t\t\t/*\n\t\t\t\t * If we had one before, drop it.\n\t\t\t\t */\n\t\t\t\tif (curbp)\n\t\t\t\t\txfs_trans_brelse(tp, curbp);\n\n\t\t\t\terror = xfs_dir2_free_read(tp, dp,\n\t\t\t\t\t\txfs_dir2_db_to_da(args->geo,\n\t\t\t\t\t\t\t\t  newfdb),\n\t\t\t\t\t\t&curbp);\n\t\t\t\tif (error)\n\t\t\t\t\treturn error;\n\t\t\t\tfree = curbp->b_addr;\n\n\t\t\t\txfs_dir2_free_hdr_check(dp, curbp, curdb);\n\t\t\t}\n\t\t\t/*\n\t\t\t * Get the index for our entry.\n\t\t\t */\n\t\t\tfi = dp->d_ops->db_to_fdindex(args->geo, curdb);\n\t\t\t/*\n\t\t\t * If it has room, return it.\n\t\t\t */\n\t\t\tbests = dp->d_ops->free_bests_p(free);\n\t\t\tif (unlikely(bests[fi] == cpu_to_be16(NULLDATAOFF))) {\n\t\t\t\tXFS_ERROR_REPORT(\"xfs_dir2_leafn_lookup_int\",\n\t\t\t\t\t\t\tXFS_ERRLEVEL_LOW, mp);\n\t\t\t\tif (curfdb != newfdb)\n\t\t\t\t\txfs_trans_brelse(tp, curbp);\n\t\t\t\treturn -EFSCORRUPTED;\n\t\t\t}\n\t\t\tcurfdb = newfdb;\n\t\t\tif (be16_to_cpu(bests[fi]) >= length)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\t/* Didn't find any space */\n\tfi = -1;\nout:\n\tASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\n\tif (curbp) {\n\t\t/* Giving back a free block. */\n\t\tstate->extravalid = 1;\n\t\tstate->extrablk.bp = curbp;\n\t\tstate->extrablk.index = fi;\n\t\tstate->extrablk.blkno = curfdb;\n\n\t\t/*\n\t\t * Important: this magic number is not in the buffer - it's for\n\t\t * buffer type information and therefore only the free/data type\n\t\t * matters here, not whether CRCs are enabled or not.\n\t\t */\n\t\tstate->extrablk.magic = XFS_DIR2_FREE_MAGIC;\n\t} else {\n\t\tstate->extravalid = 0;\n\t}\n\t/*\n\t * Return the index, that will be the insertion point.\n\t */\n\t*indexp = index;\n\treturn -ENOENT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);\n\nint\nxfs_dir2_leafn_lookup_int(\n\tstruct xfs_buf\t\t*bp,\t\t/* leaf buffer */\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tint\t\t\t*indexp,\t/* out: leaf entry index */\n\txfs_da_state_t\t\t*state)\t\t/* state to fill in */\n{\n\tif (args->op_flags & XFS_DA_OP_ADDNAME)\n\t\treturn xfs_dir2_leafn_lookup_for_addname(bp, args, indexp,\n\t\t\t\t\t\t\tstate);\n\treturn xfs_dir2_leafn_lookup_for_entry(bp, args, indexp, state);\n}"
  },
  {
    "function_name": "xfs_dir2_leafn_lookup_for_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
    "lines": "662-808",
    "snippet": "STATIC int\nxfs_dir2_leafn_lookup_for_entry(\n\tstruct xfs_buf\t\t*bp,\t\t/* leaf buffer */\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tint\t\t\t*indexp,\t/* out: leaf entry index */\n\txfs_da_state_t\t\t*state)\t\t/* state to fill in */\n{\n\tstruct xfs_buf\t\t*curbp = NULL;\t/* current data/free buffer */\n\txfs_dir2_db_t\t\tcurdb = -1;\t/* current data block number */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data block entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tindex;\t\t/* leaf entry index */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\txfs_dir2_db_t\t\tnewdb;\t\t/* new data block number */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tenum xfs_dacmp\t\tcmp;\t\t/* comparison result */\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\tdp = args->dp;\n\ttp = args->trans;\n\tmp = dp->i_mount;\n\tleaf = bp->b_addr;\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\n\txfs_dir3_leaf_check(dp, bp);\n\tASSERT(leafhdr.count > 0);\n\n\t/*\n\t * Look up the hash value in the leaf entries.\n\t */\n\tindex = xfs_dir2_leaf_search_hash(args, bp);\n\t/*\n\t * Do we have a buffer coming in?\n\t */\n\tif (state->extravalid) {\n\t\tcurbp = state->extrablk.bp;\n\t\tcurdb = state->extrablk.blkno;\n\t}\n\t/*\n\t * Loop over leaf entries with the right hash value.\n\t */\n\tfor (lep = &ents[index];\n\t     index < leafhdr.count && be32_to_cpu(lep->hashval) == args->hashval;\n\t     lep++, index++) {\n\t\t/*\n\t\t * Skip stale leaf entries.\n\t\t */\n\t\tif (be32_to_cpu(lep->address) == XFS_DIR2_NULL_DATAPTR)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Pull the data block number from the entry.\n\t\t */\n\t\tnewdb = xfs_dir2_dataptr_to_db(args->geo,\n\t\t\t\t\t       be32_to_cpu(lep->address));\n\t\t/*\n\t\t * Not adding a new entry, so we really want to find\n\t\t * the name given to us.\n\t\t *\n\t\t * If it's a different data block, go get it.\n\t\t */\n\t\tif (newdb != curdb) {\n\t\t\t/*\n\t\t\t * If we had a block before that we aren't saving\n\t\t\t * for a CI name, drop it\n\t\t\t */\n\t\t\tif (curbp && (args->cmpresult == XFS_CMP_DIFFERENT ||\n\t\t\t\t\t\tcurdb != state->extrablk.blkno))\n\t\t\t\txfs_trans_brelse(tp, curbp);\n\t\t\t/*\n\t\t\t * If needing the block that is saved with a CI match,\n\t\t\t * use it otherwise read in the new data block.\n\t\t\t */\n\t\t\tif (args->cmpresult != XFS_CMP_DIFFERENT &&\n\t\t\t\t\tnewdb == state->extrablk.blkno) {\n\t\t\t\tASSERT(state->extravalid);\n\t\t\t\tcurbp = state->extrablk.bp;\n\t\t\t} else {\n\t\t\t\terror = xfs_dir3_data_read(tp, dp,\n\t\t\t\t\t\txfs_dir2_db_to_da(args->geo,\n\t\t\t\t\t\t\t\t  newdb),\n\t\t\t\t\t\t-1, &curbp);\n\t\t\t\tif (error)\n\t\t\t\t\treturn error;\n\t\t\t}\n\t\t\txfs_dir3_data_check(dp, curbp);\n\t\t\tcurdb = newdb;\n\t\t}\n\t\t/*\n\t\t * Point to the data entry.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)((char *)curbp->b_addr +\n\t\t\txfs_dir2_dataptr_to_off(args->geo,\n\t\t\t\t\t\tbe32_to_cpu(lep->address)));\n\t\t/*\n\t\t * Compare the entry and if it's an exact match, return\n\t\t * EEXIST immediately. If it's the first case-insensitive\n\t\t * match, store the block & inode number and continue looking.\n\t\t */\n\t\tcmp = mp->m_dirnameops->compname(args, dep->name, dep->namelen);\n\t\tif (cmp != XFS_CMP_DIFFERENT && cmp != args->cmpresult) {\n\t\t\t/* If there is a CI match block, drop it */\n\t\t\tif (args->cmpresult != XFS_CMP_DIFFERENT &&\n\t\t\t\t\t\tcurdb != state->extrablk.blkno)\n\t\t\t\txfs_trans_brelse(tp, state->extrablk.bp);\n\t\t\targs->cmpresult = cmp;\n\t\t\targs->inumber = be64_to_cpu(dep->inumber);\n\t\t\targs->filetype = dp->d_ops->data_get_ftype(dep);\n\t\t\t*indexp = index;\n\t\t\tstate->extravalid = 1;\n\t\t\tstate->extrablk.bp = curbp;\n\t\t\tstate->extrablk.blkno = curdb;\n\t\t\tstate->extrablk.index = (int)((char *)dep -\n\t\t\t\t\t\t\t(char *)curbp->b_addr);\n\t\t\tstate->extrablk.magic = XFS_DIR2_DATA_MAGIC;\n\t\t\tcurbp->b_ops = &xfs_dir3_data_buf_ops;\n\t\t\txfs_trans_buf_set_type(tp, curbp, XFS_BLFT_DIR_DATA_BUF);\n\t\t\tif (cmp == XFS_CMP_EXACT)\n\t\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\tASSERT(index == leafhdr.count || (args->op_flags & XFS_DA_OP_OKNOENT));\n\tif (curbp) {\n\t\tif (args->cmpresult == XFS_CMP_DIFFERENT) {\n\t\t\t/* Giving back last used data block. */\n\t\t\tstate->extravalid = 1;\n\t\t\tstate->extrablk.bp = curbp;\n\t\t\tstate->extrablk.index = -1;\n\t\t\tstate->extrablk.blkno = curdb;\n\t\t\tstate->extrablk.magic = XFS_DIR2_DATA_MAGIC;\n\t\t\tcurbp->b_ops = &xfs_dir3_data_buf_ops;\n\t\t\txfs_trans_buf_set_type(tp, curbp, XFS_BLFT_DIR_DATA_BUF);\n\t\t} else {\n\t\t\t/* If the curbp is not the CI match block, drop it */\n\t\t\tif (state->extrablk.bp != curbp)\n\t\t\t\txfs_trans_brelse(tp, curbp);\n\t\t}\n\t} else {\n\t\tstate->extravalid = 0;\n\t}\n\t*indexp = index;\n\treturn -ENOENT;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "tp",
            "curbp"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_buf_set_type",
          "args": [
            "tp",
            "curbp",
            "XFS_BLFT_DIR_DATA_BUF"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_buf_set_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "730-746",
          "snippet": "void\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "index == leafhdr.count || (args->op_flags & XFS_DA_OP_OKNOENT)"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_get_ftype",
          "args": [
            "dep"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "dep->inumber"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mp->m_dirnameops->compname",
          "args": [
            "args",
            "dep->name",
            "dep->namelen"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_dataptr_to_off",
          "args": [
            "args->geo",
            "be32_to_cpu(lep->address)"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_dataptr_to_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "240-244",
          "snippet": "static inline xfs_dir2_data_aoff_t\nxfs_dir2_dataptr_to_off(struct xfs_da_geometry *geo, xfs_dir2_dataptr_t dp)\n{\n\treturn xfs_dir2_byte_to_off(geo, xfs_dir2_dataptr_to_byte(dp));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_data_aoff_t\nxfs_dir2_dataptr_to_off(struct xfs_da_geometry *geo, xfs_dir2_dataptr_t dp)\n{\n\treturn xfs_dir2_byte_to_off(geo, xfs_dir2_dataptr_to_byte(dp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "lep->address"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_data_check",
          "args": [
            "dp",
            "curbp"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "__xfs_dir3_data_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "40-210",
          "snippet": "int\n__xfs_dir3_data_check(\n\tstruct xfs_inode\t*dp,\t\t/* incore inode pointer */\n\tstruct xfs_buf\t\t*bp)\t\t/* data block's buffer */\n{\n\txfs_dir2_dataptr_t\taddr;\t\t/* addr for leaf lookup */\n\txfs_dir2_data_free_t\t*bf;\t\t/* bestfree table */\n\txfs_dir2_block_tail_t\t*btp=NULL;\t/* block tail */\n\tint\t\t\tcount;\t\t/* count of entries found */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry */\n\tchar\t\t\t*endp;\t\t/* end of useful data */\n\tint\t\t\tfreeseen;\t/* mask of bestfrees seen */\n\txfs_dahash_t\t\thash;\t\t/* hash of current name */\n\tint\t\t\ti;\t\t/* leaf index */\n\tint\t\t\tlastfree;\t/* last entry was unused */\n\txfs_dir2_leaf_entry_t\t*lep=NULL;\t/* block leaf entries */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tchar\t\t\t*p;\t\t/* current data position */\n\tint\t\t\tstale;\t\t/* count of stale leaves */\n\tstruct xfs_name\t\tname;\n\tconst struct xfs_dir_ops *ops;\n\tstruct xfs_da_geometry\t*geo;\n\n\tmp = bp->b_target->bt_mount;\n\tgeo = mp->m_dir_geo;\n\n\t/*\n\t * We can be passed a null dp here from a verifier, so we need to go the\n\t * hard way to get them.\n\t */\n\tops = xfs_dir_get_ops(mp, dp);\n\n\thdr = bp->b_addr;\n\tp = (char *)ops->data_entry_p(hdr);\n\n\tswitch (hdr->magic) {\n\tcase cpu_to_be32(XFS_DIR3_BLOCK_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_BLOCK_MAGIC):\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tlep = xfs_dir2_block_leaf_p(btp);\n\t\tendp = (char *)lep;\n\n\t\t/*\n\t\t * The number of leaf entries is limited by the size of the\n\t\t * block and the amount of space used by the data entries.\n\t\t * We don't know how much space is used by the data entries yet,\n\t\t * so just ensure that the count falls somewhere inside the\n\t\t * block right now.\n\t\t */\n\t\tXFS_WANT_CORRUPTED_RETURN(be32_to_cpu(btp->count) <\n\t\t\t((char *)btp - p) / sizeof(struct xfs_dir2_leaf_entry));\n\t\tbreak;\n\tcase cpu_to_be32(XFS_DIR3_DATA_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_DATA_MAGIC):\n\t\tendp = (char *)hdr + geo->blksize;\n\t\tbreak;\n\tdefault:\n\t\tXFS_ERROR_REPORT(\"Bad Magic\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/*\n\t * Account for zero bestfree entries.\n\t */\n\tbf = ops->data_bestfree_p(hdr);\n\tcount = lastfree = freeseen = 0;\n\tif (!bf[0].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[0].offset);\n\t\tfreeseen |= 1 << 0;\n\t}\n\tif (!bf[1].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[1].offset);\n\t\tfreeseen |= 1 << 1;\n\t}\n\tif (!bf[2].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[2].offset);\n\t\tfreeseen |= 1 << 2;\n\t}\n\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[0].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[1].length));\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[1].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t/*\n\t * Loop over the data/unused entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's unused, look for the space in the bestfree table.\n\t\t * If we find it, account for that, else make sure it\n\t\t * doesn't need to be there.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tXFS_WANT_CORRUPTED_RETURN(lastfree == 0);\n\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tbe16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)) ==\n\t\t\t\t\t       (char *)dup - (char *)hdr);\n\t\t\tdfp = xfs_dir2_data_freefind(hdr, bf, dup);\n\t\t\tif (dfp) {\n\t\t\t\ti = (int)(dfp - bf);\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\t(freeseen & (1 << i)) == 0);\n\t\t\t\tfreeseen |= 1 << i;\n\t\t\t} else {\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe16_to_cpu(dup->length) <=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t\t\t}\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t\tlastfree = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * It's a real entry.  Validate the fields.\n\t\t * If this is a block directory then make sure it's\n\t\t * in the leaf section of the block.\n\t\t * The linear search is crude but this is DEBUG code.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\tXFS_WANT_CORRUPTED_RETURN(dep->namelen != 0);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t!xfs_dir_ino_validate(mp, be64_to_cpu(dep->inumber)));\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\tbe16_to_cpu(*ops->data_entry_tag_p(dep)) ==\n\t\t\t\t\t       (char *)dep - (char *)hdr);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tops->data_get_ftype(dep) < XFS_DIR3_FT_MAX);\n\t\tcount++;\n\t\tlastfree = 0;\n\t\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\t\taddr = xfs_dir2_db_off_to_dataptr(geo, geo->datablk,\n\t\t\t\t\t\t(xfs_dir2_data_aoff_t)\n\t\t\t\t\t\t((char *)dep - (char *)hdr));\n\t\t\tname.name = dep->name;\n\t\t\tname.len = dep->namelen;\n\t\t\thash = mp->m_dirnameops->hashname(&name);\n\t\t\tfor (i = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\t\tif (be32_to_cpu(lep[i].address) == addr &&\n\t\t\t\t    be32_to_cpu(lep[i].hashval) == hash)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tXFS_WANT_CORRUPTED_RETURN(i < be32_to_cpu(btp->count));\n\t\t}\n\t\tp += ops->data_entsize(dep->namelen);\n\t}\n\t/*\n\t * Need to have seen all the entries and all the bestfree slots.\n\t */\n\tXFS_WANT_CORRUPTED_RETURN(freeseen == 7);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tfor (i = stale = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\tif (lep[i].address ==\n\t\t\t    cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\t\tstale++;\n\t\t\tif (i > 0)\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe32_to_cpu(lep[i].hashval) >=\n\t\t\t\t\t\tbe32_to_cpu(lep[i - 1].hashval));\n\t\t}\n\t\tXFS_WANT_CORRUPTED_RETURN(count ==\n\t\t\tbe32_to_cpu(btp->count) - be32_to_cpu(btp->stale));\n\t\tXFS_WANT_CORRUPTED_RETURN(stale == be32_to_cpu(btp->stale));\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\n__xfs_dir3_data_check(\n\tstruct xfs_inode\t*dp,\t\t/* incore inode pointer */\n\tstruct xfs_buf\t\t*bp)\t\t/* data block's buffer */\n{\n\txfs_dir2_dataptr_t\taddr;\t\t/* addr for leaf lookup */\n\txfs_dir2_data_free_t\t*bf;\t\t/* bestfree table */\n\txfs_dir2_block_tail_t\t*btp=NULL;\t/* block tail */\n\tint\t\t\tcount;\t\t/* count of entries found */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* data block header */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry */\n\txfs_dir2_data_free_t\t*dfp;\t\t/* bestfree entry */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry */\n\tchar\t\t\t*endp;\t\t/* end of useful data */\n\tint\t\t\tfreeseen;\t/* mask of bestfrees seen */\n\txfs_dahash_t\t\thash;\t\t/* hash of current name */\n\tint\t\t\ti;\t\t/* leaf index */\n\tint\t\t\tlastfree;\t/* last entry was unused */\n\txfs_dir2_leaf_entry_t\t*lep=NULL;\t/* block leaf entries */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tchar\t\t\t*p;\t\t/* current data position */\n\tint\t\t\tstale;\t\t/* count of stale leaves */\n\tstruct xfs_name\t\tname;\n\tconst struct xfs_dir_ops *ops;\n\tstruct xfs_da_geometry\t*geo;\n\n\tmp = bp->b_target->bt_mount;\n\tgeo = mp->m_dir_geo;\n\n\t/*\n\t * We can be passed a null dp here from a verifier, so we need to go the\n\t * hard way to get them.\n\t */\n\tops = xfs_dir_get_ops(mp, dp);\n\n\thdr = bp->b_addr;\n\tp = (char *)ops->data_entry_p(hdr);\n\n\tswitch (hdr->magic) {\n\tcase cpu_to_be32(XFS_DIR3_BLOCK_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_BLOCK_MAGIC):\n\t\tbtp = xfs_dir2_block_tail_p(geo, hdr);\n\t\tlep = xfs_dir2_block_leaf_p(btp);\n\t\tendp = (char *)lep;\n\n\t\t/*\n\t\t * The number of leaf entries is limited by the size of the\n\t\t * block and the amount of space used by the data entries.\n\t\t * We don't know how much space is used by the data entries yet,\n\t\t * so just ensure that the count falls somewhere inside the\n\t\t * block right now.\n\t\t */\n\t\tXFS_WANT_CORRUPTED_RETURN(be32_to_cpu(btp->count) <\n\t\t\t((char *)btp - p) / sizeof(struct xfs_dir2_leaf_entry));\n\t\tbreak;\n\tcase cpu_to_be32(XFS_DIR3_DATA_MAGIC):\n\tcase cpu_to_be32(XFS_DIR2_DATA_MAGIC):\n\t\tendp = (char *)hdr + geo->blksize;\n\t\tbreak;\n\tdefault:\n\t\tXFS_ERROR_REPORT(\"Bad Magic\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/*\n\t * Account for zero bestfree entries.\n\t */\n\tbf = ops->data_bestfree_p(hdr);\n\tcount = lastfree = freeseen = 0;\n\tif (!bf[0].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[0].offset);\n\t\tfreeseen |= 1 << 0;\n\t}\n\tif (!bf[1].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[1].offset);\n\t\tfreeseen |= 1 << 1;\n\t}\n\tif (!bf[2].length) {\n\t\tXFS_WANT_CORRUPTED_RETURN(!bf[2].offset);\n\t\tfreeseen |= 1 << 2;\n\t}\n\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[0].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[1].length));\n\tXFS_WANT_CORRUPTED_RETURN(be16_to_cpu(bf[1].length) >=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t/*\n\t * Loop over the data/unused entries.\n\t */\n\twhile (p < endp) {\n\t\tdup = (xfs_dir2_data_unused_t *)p;\n\t\t/*\n\t\t * If it's unused, look for the space in the bestfree table.\n\t\t * If we find it, account for that, else make sure it\n\t\t * doesn't need to be there.\n\t\t */\n\t\tif (be16_to_cpu(dup->freetag) == XFS_DIR2_DATA_FREE_TAG) {\n\t\t\tXFS_WANT_CORRUPTED_RETURN(lastfree == 0);\n\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tbe16_to_cpu(*xfs_dir2_data_unused_tag_p(dup)) ==\n\t\t\t\t\t       (char *)dup - (char *)hdr);\n\t\t\tdfp = xfs_dir2_data_freefind(hdr, bf, dup);\n\t\t\tif (dfp) {\n\t\t\t\ti = (int)(dfp - bf);\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\t(freeseen & (1 << i)) == 0);\n\t\t\t\tfreeseen |= 1 << i;\n\t\t\t} else {\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe16_to_cpu(dup->length) <=\n\t\t\t\t\t\tbe16_to_cpu(bf[2].length));\n\t\t\t}\n\t\t\tp += be16_to_cpu(dup->length);\n\t\t\tlastfree = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * It's a real entry.  Validate the fields.\n\t\t * If this is a block directory then make sure it's\n\t\t * in the leaf section of the block.\n\t\t * The linear search is crude but this is DEBUG code.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)p;\n\t\tXFS_WANT_CORRUPTED_RETURN(dep->namelen != 0);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t!xfs_dir_ino_validate(mp, be64_to_cpu(dep->inumber)));\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\tbe16_to_cpu(*ops->data_entry_tag_p(dep)) ==\n\t\t\t\t\t       (char *)dep - (char *)hdr);\n\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\tops->data_get_ftype(dep) < XFS_DIR3_FT_MAX);\n\t\tcount++;\n\t\tlastfree = 0;\n\t\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\t\taddr = xfs_dir2_db_off_to_dataptr(geo, geo->datablk,\n\t\t\t\t\t\t(xfs_dir2_data_aoff_t)\n\t\t\t\t\t\t((char *)dep - (char *)hdr));\n\t\t\tname.name = dep->name;\n\t\t\tname.len = dep->namelen;\n\t\t\thash = mp->m_dirnameops->hashname(&name);\n\t\t\tfor (i = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\t\tif (be32_to_cpu(lep[i].address) == addr &&\n\t\t\t\t    be32_to_cpu(lep[i].hashval) == hash)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tXFS_WANT_CORRUPTED_RETURN(i < be32_to_cpu(btp->count));\n\t\t}\n\t\tp += ops->data_entsize(dep->namelen);\n\t}\n\t/*\n\t * Need to have seen all the entries and all the bestfree slots.\n\t */\n\tXFS_WANT_CORRUPTED_RETURN(freeseen == 7);\n\tif (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||\n\t    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {\n\t\tfor (i = stale = 0; i < be32_to_cpu(btp->count); i++) {\n\t\t\tif (lep[i].address ==\n\t\t\t    cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\t\tstale++;\n\t\t\tif (i > 0)\n\t\t\t\tXFS_WANT_CORRUPTED_RETURN(\n\t\t\t\t\tbe32_to_cpu(lep[i].hashval) >=\n\t\t\t\t\t\tbe32_to_cpu(lep[i - 1].hashval));\n\t\t}\n\t\tXFS_WANT_CORRUPTED_RETURN(count ==\n\t\t\tbe32_to_cpu(btp->count) - be32_to_cpu(btp->stale));\n\t\tXFS_WANT_CORRUPTED_RETURN(stale == be32_to_cpu(btp->stale));\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir3_data_read",
          "args": [
            "tp",
            "dp",
            "xfs_dir2_db_to_da(args->geo,\n\t\t\t\t\t\t\t\t  newdb)",
            "-1",
            "&curbp"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_data_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_data.c",
          "lines": "313-328",
          "snippet": "int\nxfs_dir3_data_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmapped_bno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mapped_bno, bpp,\n\t\t\t\tXFS_DATA_FORK, &xfs_dir3_data_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_DIR_DATA_BUF);\n\treturn err;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_dir3_data_buf_ops = {\n\t.verify_read = xfs_dir3_data_read_verify,\n\t.verify_write = xfs_dir3_data_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_dir3_data_buf_ops = {\n\t.verify_read = xfs_dir3_data_read_verify,\n\t.verify_write = xfs_dir3_data_write_verify,\n};\n\nint\nxfs_dir3_data_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmapped_bno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, bno, mapped_bno, bpp,\n\t\t\t\tXFS_DATA_FORK, &xfs_dir3_data_buf_ops);\n\tif (!err && tp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_DIR_DATA_BUF);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_db_to_da",
          "args": [
            "args->geo",
            "newdb"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_db_to_da",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "259-263",
          "snippet": "static inline xfs_dablk_t\nxfs_dir2_db_to_da(struct xfs_da_geometry *geo, xfs_dir2_db_t db)\n{\n\treturn (xfs_dablk_t)(db << (geo->blklog - geo->fsblog));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dablk_t\nxfs_dir2_db_to_da(struct xfs_da_geometry *geo, xfs_dir2_db_t db)\n{\n\treturn (xfs_dablk_t)(db << (geo->blklog - geo->fsblog));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "state->extravalid"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_dataptr_to_db",
          "args": [
            "args->geo",
            "be32_to_cpu(lep->address)"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_dataptr_to_db",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "222-226",
          "snippet": "static inline xfs_dir2_db_t\nxfs_dir2_dataptr_to_db(struct xfs_da_geometry *geo, xfs_dir2_dataptr_t dp)\n{\n\treturn xfs_dir2_byte_to_db(geo, xfs_dir2_dataptr_to_byte(dp));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_db_t\nxfs_dir2_dataptr_to_db(struct xfs_da_geometry *geo, xfs_dir2_dataptr_t dp)\n{\n\treturn xfs_dir2_byte_to_db(geo, xfs_dir2_dataptr_to_byte(dp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "lep->address"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "lep->address"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "lep->hashval"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leaf_search_hash",
          "args": [
            "args",
            "bp"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leaf_search_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "1534-1582",
          "snippet": "int\t\t\t\t\t\t/* index value */\nxfs_dir2_leaf_search_hash(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tstruct xfs_buf\t\t*lbp)\t\t/* leaf buffer */\n{\n\txfs_dahash_t\t\thash=0;\t\t/* hash from this entry */\n\txfs_dahash_t\t\thashwant;\t/* hash value looking for */\n\tint\t\t\thigh;\t\t/* high leaf index */\n\tint\t\t\tlow;\t\t/* low leaf index */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\tint\t\t\tmid=0;\t\t/* current leaf index */\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\tleaf = lbp->b_addr;\n\tents = args->dp->d_ops->leaf_ents_p(leaf);\n\targs->dp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\n\t/*\n\t * Note, the table cannot be empty, so we have to go through the loop.\n\t * Binary search the leaf entries looking for our hash value.\n\t */\n\tfor (lep = ents, low = 0, high = leafhdr.count - 1,\n\t\thashwant = args->hashval;\n\t     low <= high; ) {\n\t\tmid = (low + high) >> 1;\n\t\tif ((hash = be32_to_cpu(lep[mid].hashval)) == hashwant)\n\t\t\tbreak;\n\t\tif (hash < hashwant)\n\t\t\tlow = mid + 1;\n\t\telse\n\t\t\thigh = mid - 1;\n\t}\n\t/*\n\t * Found one, back up through all the equal hash values.\n\t */\n\tif (hash == hashwant) {\n\t\twhile (mid > 0 && be32_to_cpu(lep[mid - 1].hashval) == hashwant) {\n\t\t\tmid--;\n\t\t}\n\t}\n\t/*\n\t * Need to point to an entry higher than ours.\n\t */\n\telse if (hash < hashwant)\n\t\tmid++;\n\treturn mid;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* index value */\nxfs_dir2_leaf_search_hash(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tstruct xfs_buf\t\t*lbp)\t\t/* leaf buffer */\n{\n\txfs_dahash_t\t\thash=0;\t\t/* hash from this entry */\n\txfs_dahash_t\t\thashwant;\t/* hash value looking for */\n\tint\t\t\thigh;\t\t/* high leaf index */\n\tint\t\t\tlow;\t\t/* low leaf index */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\tint\t\t\tmid=0;\t\t/* current leaf index */\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\tleaf = lbp->b_addr;\n\tents = args->dp->d_ops->leaf_ents_p(leaf);\n\targs->dp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\n\t/*\n\t * Note, the table cannot be empty, so we have to go through the loop.\n\t * Binary search the leaf entries looking for our hash value.\n\t */\n\tfor (lep = ents, low = 0, high = leafhdr.count - 1,\n\t\thashwant = args->hashval;\n\t     low <= high; ) {\n\t\tmid = (low + high) >> 1;\n\t\tif ((hash = be32_to_cpu(lep[mid].hashval)) == hashwant)\n\t\t\tbreak;\n\t\tif (hash < hashwant)\n\t\t\tlow = mid + 1;\n\t\telse\n\t\t\thigh = mid - 1;\n\t}\n\t/*\n\t * Found one, back up through all the equal hash values.\n\t */\n\tif (hash == hashwant) {\n\t\twhile (mid > 0 && be32_to_cpu(lep[mid - 1].hashval) == hashwant) {\n\t\t\tmid--;\n\t\t}\n\t}\n\t/*\n\t * Need to point to an entry higher than ours.\n\t */\n\telse if (hash < hashwant)\n\t\tmid++;\n\treturn mid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "leafhdr.count > 0"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_check",
          "args": [
            "dp",
            "bp"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_ents_p",
          "args": [
            "leaf"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_hdr_from_disk",
          "args": [
            "&leafhdr",
            "leaf"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);\n\nSTATIC int\nxfs_dir2_leafn_lookup_for_entry(\n\tstruct xfs_buf\t\t*bp,\t\t/* leaf buffer */\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tint\t\t\t*indexp,\t/* out: leaf entry index */\n\txfs_da_state_t\t\t*state)\t\t/* state to fill in */\n{\n\tstruct xfs_buf\t\t*curbp = NULL;\t/* current data/free buffer */\n\txfs_dir2_db_t\t\tcurdb = -1;\t/* current data block number */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data block entry */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tindex;\t\t/* leaf entry index */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\txfs_dir2_db_t\t\tnewdb;\t\t/* new data block number */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tenum xfs_dacmp\t\tcmp;\t\t/* comparison result */\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\tdp = args->dp;\n\ttp = args->trans;\n\tmp = dp->i_mount;\n\tleaf = bp->b_addr;\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\n\txfs_dir3_leaf_check(dp, bp);\n\tASSERT(leafhdr.count > 0);\n\n\t/*\n\t * Look up the hash value in the leaf entries.\n\t */\n\tindex = xfs_dir2_leaf_search_hash(args, bp);\n\t/*\n\t * Do we have a buffer coming in?\n\t */\n\tif (state->extravalid) {\n\t\tcurbp = state->extrablk.bp;\n\t\tcurdb = state->extrablk.blkno;\n\t}\n\t/*\n\t * Loop over leaf entries with the right hash value.\n\t */\n\tfor (lep = &ents[index];\n\t     index < leafhdr.count && be32_to_cpu(lep->hashval) == args->hashval;\n\t     lep++, index++) {\n\t\t/*\n\t\t * Skip stale leaf entries.\n\t\t */\n\t\tif (be32_to_cpu(lep->address) == XFS_DIR2_NULL_DATAPTR)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Pull the data block number from the entry.\n\t\t */\n\t\tnewdb = xfs_dir2_dataptr_to_db(args->geo,\n\t\t\t\t\t       be32_to_cpu(lep->address));\n\t\t/*\n\t\t * Not adding a new entry, so we really want to find\n\t\t * the name given to us.\n\t\t *\n\t\t * If it's a different data block, go get it.\n\t\t */\n\t\tif (newdb != curdb) {\n\t\t\t/*\n\t\t\t * If we had a block before that we aren't saving\n\t\t\t * for a CI name, drop it\n\t\t\t */\n\t\t\tif (curbp && (args->cmpresult == XFS_CMP_DIFFERENT ||\n\t\t\t\t\t\tcurdb != state->extrablk.blkno))\n\t\t\t\txfs_trans_brelse(tp, curbp);\n\t\t\t/*\n\t\t\t * If needing the block that is saved with a CI match,\n\t\t\t * use it otherwise read in the new data block.\n\t\t\t */\n\t\t\tif (args->cmpresult != XFS_CMP_DIFFERENT &&\n\t\t\t\t\tnewdb == state->extrablk.blkno) {\n\t\t\t\tASSERT(state->extravalid);\n\t\t\t\tcurbp = state->extrablk.bp;\n\t\t\t} else {\n\t\t\t\terror = xfs_dir3_data_read(tp, dp,\n\t\t\t\t\t\txfs_dir2_db_to_da(args->geo,\n\t\t\t\t\t\t\t\t  newdb),\n\t\t\t\t\t\t-1, &curbp);\n\t\t\t\tif (error)\n\t\t\t\t\treturn error;\n\t\t\t}\n\t\t\txfs_dir3_data_check(dp, curbp);\n\t\t\tcurdb = newdb;\n\t\t}\n\t\t/*\n\t\t * Point to the data entry.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)((char *)curbp->b_addr +\n\t\t\txfs_dir2_dataptr_to_off(args->geo,\n\t\t\t\t\t\tbe32_to_cpu(lep->address)));\n\t\t/*\n\t\t * Compare the entry and if it's an exact match, return\n\t\t * EEXIST immediately. If it's the first case-insensitive\n\t\t * match, store the block & inode number and continue looking.\n\t\t */\n\t\tcmp = mp->m_dirnameops->compname(args, dep->name, dep->namelen);\n\t\tif (cmp != XFS_CMP_DIFFERENT && cmp != args->cmpresult) {\n\t\t\t/* If there is a CI match block, drop it */\n\t\t\tif (args->cmpresult != XFS_CMP_DIFFERENT &&\n\t\t\t\t\t\tcurdb != state->extrablk.blkno)\n\t\t\t\txfs_trans_brelse(tp, state->extrablk.bp);\n\t\t\targs->cmpresult = cmp;\n\t\t\targs->inumber = be64_to_cpu(dep->inumber);\n\t\t\targs->filetype = dp->d_ops->data_get_ftype(dep);\n\t\t\t*indexp = index;\n\t\t\tstate->extravalid = 1;\n\t\t\tstate->extrablk.bp = curbp;\n\t\t\tstate->extrablk.blkno = curdb;\n\t\t\tstate->extrablk.index = (int)((char *)dep -\n\t\t\t\t\t\t\t(char *)curbp->b_addr);\n\t\t\tstate->extrablk.magic = XFS_DIR2_DATA_MAGIC;\n\t\t\tcurbp->b_ops = &xfs_dir3_data_buf_ops;\n\t\t\txfs_trans_buf_set_type(tp, curbp, XFS_BLFT_DIR_DATA_BUF);\n\t\t\tif (cmp == XFS_CMP_EXACT)\n\t\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\tASSERT(index == leafhdr.count || (args->op_flags & XFS_DA_OP_OKNOENT));\n\tif (curbp) {\n\t\tif (args->cmpresult == XFS_CMP_DIFFERENT) {\n\t\t\t/* Giving back last used data block. */\n\t\t\tstate->extravalid = 1;\n\t\t\tstate->extrablk.bp = curbp;\n\t\t\tstate->extrablk.index = -1;\n\t\t\tstate->extrablk.blkno = curdb;\n\t\t\tstate->extrablk.magic = XFS_DIR2_DATA_MAGIC;\n\t\t\tcurbp->b_ops = &xfs_dir3_data_buf_ops;\n\t\t\txfs_trans_buf_set_type(tp, curbp, XFS_BLFT_DIR_DATA_BUF);\n\t\t} else {\n\t\t\t/* If the curbp is not the CI match block, drop it */\n\t\t\tif (state->extrablk.bp != curbp)\n\t\t\t\txfs_trans_brelse(tp, curbp);\n\t\t}\n\t} else {\n\t\tstate->extravalid = 0;\n\t}\n\t*indexp = index;\n\treturn -ENOENT;\n}"
  },
  {
    "function_name": "xfs_dir2_leafn_lookup_for_addname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
    "lines": "507-656",
    "snippet": "STATIC int\nxfs_dir2_leafn_lookup_for_addname(\n\tstruct xfs_buf\t\t*bp,\t\t/* leaf buffer */\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tint\t\t\t*indexp,\t/* out: leaf entry index */\n\txfs_da_state_t\t\t*state)\t\t/* state to fill in */\n{\n\tstruct xfs_buf\t\t*curbp = NULL;\t/* current data/free buffer */\n\txfs_dir2_db_t\t\tcurdb = -1;\t/* current data block number */\n\txfs_dir2_db_t\t\tcurfdb = -1;\t/* current free block number */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tfi;\t\t/* free entry index */\n\txfs_dir2_free_t\t\t*free = NULL;\t/* free block structure */\n\tint\t\t\tindex;\t\t/* leaf entry index */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\tint\t\t\tlength;\t\t/* length of new data entry */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\txfs_dir2_db_t\t\tnewdb;\t\t/* new data block number */\n\txfs_dir2_db_t\t\tnewfdb;\t\t/* new free block number */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\tdp = args->dp;\n\ttp = args->trans;\n\tmp = dp->i_mount;\n\tleaf = bp->b_addr;\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\n\txfs_dir3_leaf_check(dp, bp);\n\tASSERT(leafhdr.count > 0);\n\n\t/*\n\t * Look up the hash value in the leaf entries.\n\t */\n\tindex = xfs_dir2_leaf_search_hash(args, bp);\n\t/*\n\t * Do we have a buffer coming in?\n\t */\n\tif (state->extravalid) {\n\t\t/* If so, it's a free block buffer, get the block number. */\n\t\tcurbp = state->extrablk.bp;\n\t\tcurfdb = state->extrablk.blkno;\n\t\tfree = curbp->b_addr;\n\t\tASSERT(free->hdr.magic == cpu_to_be32(XFS_DIR2_FREE_MAGIC) ||\n\t\t       free->hdr.magic == cpu_to_be32(XFS_DIR3_FREE_MAGIC));\n\t}\n\tlength = dp->d_ops->data_entsize(args->namelen);\n\t/*\n\t * Loop over leaf entries with the right hash value.\n\t */\n\tfor (lep = &ents[index];\n\t     index < leafhdr.count && be32_to_cpu(lep->hashval) == args->hashval;\n\t     lep++, index++) {\n\t\t/*\n\t\t * Skip stale leaf entries.\n\t\t */\n\t\tif (be32_to_cpu(lep->address) == XFS_DIR2_NULL_DATAPTR)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Pull the data block number from the entry.\n\t\t */\n\t\tnewdb = xfs_dir2_dataptr_to_db(args->geo,\n\t\t\t\t\t       be32_to_cpu(lep->address));\n\t\t/*\n\t\t * For addname, we're looking for a place to put the new entry.\n\t\t * We want to use a data block with an entry of equal\n\t\t * hash value to ours if there is one with room.\n\t\t *\n\t\t * If this block isn't the data block we already have\n\t\t * in hand, take a look at it.\n\t\t */\n\t\tif (newdb != curdb) {\n\t\t\t__be16 *bests;\n\n\t\t\tcurdb = newdb;\n\t\t\t/*\n\t\t\t * Convert the data block to the free block\n\t\t\t * holding its freespace information.\n\t\t\t */\n\t\t\tnewfdb = dp->d_ops->db_to_fdb(args->geo, newdb);\n\t\t\t/*\n\t\t\t * If it's not the one we have in hand, read it in.\n\t\t\t */\n\t\t\tif (newfdb != curfdb) {\n\t\t\t\t/*\n\t\t\t\t * If we had one before, drop it.\n\t\t\t\t */\n\t\t\t\tif (curbp)\n\t\t\t\t\txfs_trans_brelse(tp, curbp);\n\n\t\t\t\terror = xfs_dir2_free_read(tp, dp,\n\t\t\t\t\t\txfs_dir2_db_to_da(args->geo,\n\t\t\t\t\t\t\t\t  newfdb),\n\t\t\t\t\t\t&curbp);\n\t\t\t\tif (error)\n\t\t\t\t\treturn error;\n\t\t\t\tfree = curbp->b_addr;\n\n\t\t\t\txfs_dir2_free_hdr_check(dp, curbp, curdb);\n\t\t\t}\n\t\t\t/*\n\t\t\t * Get the index for our entry.\n\t\t\t */\n\t\t\tfi = dp->d_ops->db_to_fdindex(args->geo, curdb);\n\t\t\t/*\n\t\t\t * If it has room, return it.\n\t\t\t */\n\t\t\tbests = dp->d_ops->free_bests_p(free);\n\t\t\tif (unlikely(bests[fi] == cpu_to_be16(NULLDATAOFF))) {\n\t\t\t\tXFS_ERROR_REPORT(\"xfs_dir2_leafn_lookup_int\",\n\t\t\t\t\t\t\tXFS_ERRLEVEL_LOW, mp);\n\t\t\t\tif (curfdb != newfdb)\n\t\t\t\t\txfs_trans_brelse(tp, curbp);\n\t\t\t\treturn -EFSCORRUPTED;\n\t\t\t}\n\t\t\tcurfdb = newfdb;\n\t\t\tif (be16_to_cpu(bests[fi]) >= length)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\t/* Didn't find any space */\n\tfi = -1;\nout:\n\tASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\n\tif (curbp) {\n\t\t/* Giving back a free block. */\n\t\tstate->extravalid = 1;\n\t\tstate->extrablk.bp = curbp;\n\t\tstate->extrablk.index = fi;\n\t\tstate->extrablk.blkno = curfdb;\n\n\t\t/*\n\t\t * Important: this magic number is not in the buffer - it's for\n\t\t * buffer type information and therefore only the free/data type\n\t\t * matters here, not whether CRCs are enabled or not.\n\t\t */\n\t\tstate->extrablk.magic = XFS_DIR2_FREE_MAGIC;\n\t} else {\n\t\tstate->extravalid = 0;\n\t}\n\t/*\n\t * Return the index, that will be the insertion point.\n\t */\n\t*indexp = index;\n\treturn -ENOENT;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args->op_flags & XFS_DA_OP_OKNOENT"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "bests[fi]"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "tp",
            "curbp"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_ERROR_REPORT",
          "args": [
            "\"xfs_dir2_leafn_lookup_int\"",
            "XFS_ERRLEVEL_LOW",
            "mp"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "bests[fi] == cpu_to_be16(NULLDATAOFF)"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "NULLDATAOFF"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->free_bests_p",
          "args": [
            "free"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->db_to_fdindex",
          "args": [
            "args->geo",
            "curdb"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_free_hdr_check",
          "args": [
            "dp",
            "curbp",
            "curdb"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_free_hdr_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
          "lines": "456-470",
          "snippet": "static void\nxfs_dir2_free_hdr_check(\n\tstruct xfs_inode *dp,\n\tstruct xfs_buf\t*bp,\n\txfs_dir2_db_t\tdb)\n{\n\tstruct xfs_dir3_icfree_hdr hdr;\n\n\tdp->d_ops->free_hdr_from_disk(&hdr, bp->b_addr);\n\n\tASSERT((hdr.firstdb %\n\t\tdp->d_ops->free_max_bests(dp->i_mount->m_dir_geo)) == 0);\n\tASSERT(hdr.firstdb <= db);\n\tASSERT(db < hdr.firstdb + hdr.nvalid);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_dir2_free_hdr_check(\n\tstruct xfs_inode *dp,\n\tstruct xfs_buf\t*bp,\n\txfs_dir2_db_t\tdb)\n{\n\tstruct xfs_dir3_icfree_hdr hdr;\n\n\tdp->d_ops->free_hdr_from_disk(&hdr, bp->b_addr);\n\n\tASSERT((hdr.firstdb %\n\t\tdp->d_ops->free_max_bests(dp->i_mount->m_dir_geo)) == 0);\n\tASSERT(hdr.firstdb <= db);\n\tASSERT(db < hdr.firstdb + hdr.nvalid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_free_read",
          "args": [
            "tp",
            "dp",
            "xfs_dir2_db_to_da(args->geo,\n\t\t\t\t\t\t\t\t  newfdb)",
            "&curbp"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_free_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
          "lines": "174-182",
          "snippet": "int\nxfs_dir2_free_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tfbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\treturn __xfs_dir3_free_read(tp, dp, fbno, -1, bpp);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir2_free_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tfbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\treturn __xfs_dir3_free_read(tp, dp, fbno, -1, bpp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_db_to_da",
          "args": [
            "args->geo",
            "newfdb"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_db_to_da",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "259-263",
          "snippet": "static inline xfs_dablk_t\nxfs_dir2_db_to_da(struct xfs_da_geometry *geo, xfs_dir2_db_t db)\n{\n\treturn (xfs_dablk_t)(db << (geo->blklog - geo->fsblog));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dablk_t\nxfs_dir2_db_to_da(struct xfs_da_geometry *geo, xfs_dir2_db_t db)\n{\n\treturn (xfs_dablk_t)(db << (geo->blklog - geo->fsblog));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->db_to_fdb",
          "args": [
            "args->geo",
            "newdb"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_dataptr_to_db",
          "args": [
            "args->geo",
            "be32_to_cpu(lep->address)"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_dataptr_to_db",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "222-226",
          "snippet": "static inline xfs_dir2_db_t\nxfs_dir2_dataptr_to_db(struct xfs_da_geometry *geo, xfs_dir2_dataptr_t dp)\n{\n\treturn xfs_dir2_byte_to_db(geo, xfs_dir2_dataptr_to_byte(dp));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_db_t\nxfs_dir2_dataptr_to_db(struct xfs_da_geometry *geo, xfs_dir2_dataptr_t dp)\n{\n\treturn xfs_dir2_byte_to_db(geo, xfs_dir2_dataptr_to_byte(dp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "lep->address"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "lep->address"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "lep->hashval"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->data_entsize",
          "args": [
            "args->namelen"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "free->hdr.magic == cpu_to_be32(XFS_DIR2_FREE_MAGIC) ||\n\t\t       free->hdr.magic == cpu_to_be32(XFS_DIR3_FREE_MAGIC)"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR3_FREE_MAGIC"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_FREE_MAGIC"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leaf_search_hash",
          "args": [
            "args",
            "bp"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leaf_search_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "1534-1582",
          "snippet": "int\t\t\t\t\t\t/* index value */\nxfs_dir2_leaf_search_hash(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tstruct xfs_buf\t\t*lbp)\t\t/* leaf buffer */\n{\n\txfs_dahash_t\t\thash=0;\t\t/* hash from this entry */\n\txfs_dahash_t\t\thashwant;\t/* hash value looking for */\n\tint\t\t\thigh;\t\t/* high leaf index */\n\tint\t\t\tlow;\t\t/* low leaf index */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\tint\t\t\tmid=0;\t\t/* current leaf index */\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\tleaf = lbp->b_addr;\n\tents = args->dp->d_ops->leaf_ents_p(leaf);\n\targs->dp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\n\t/*\n\t * Note, the table cannot be empty, so we have to go through the loop.\n\t * Binary search the leaf entries looking for our hash value.\n\t */\n\tfor (lep = ents, low = 0, high = leafhdr.count - 1,\n\t\thashwant = args->hashval;\n\t     low <= high; ) {\n\t\tmid = (low + high) >> 1;\n\t\tif ((hash = be32_to_cpu(lep[mid].hashval)) == hashwant)\n\t\t\tbreak;\n\t\tif (hash < hashwant)\n\t\t\tlow = mid + 1;\n\t\telse\n\t\t\thigh = mid - 1;\n\t}\n\t/*\n\t * Found one, back up through all the equal hash values.\n\t */\n\tif (hash == hashwant) {\n\t\twhile (mid > 0 && be32_to_cpu(lep[mid - 1].hashval) == hashwant) {\n\t\t\tmid--;\n\t\t}\n\t}\n\t/*\n\t * Need to point to an entry higher than ours.\n\t */\n\telse if (hash < hashwant)\n\t\tmid++;\n\treturn mid;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* index value */\nxfs_dir2_leaf_search_hash(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tstruct xfs_buf\t\t*lbp)\t\t/* leaf buffer */\n{\n\txfs_dahash_t\t\thash=0;\t\t/* hash from this entry */\n\txfs_dahash_t\t\thashwant;\t/* hash value looking for */\n\tint\t\t\thigh;\t\t/* high leaf index */\n\tint\t\t\tlow;\t\t/* low leaf index */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\tint\t\t\tmid=0;\t\t/* current leaf index */\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\tleaf = lbp->b_addr;\n\tents = args->dp->d_ops->leaf_ents_p(leaf);\n\targs->dp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\n\t/*\n\t * Note, the table cannot be empty, so we have to go through the loop.\n\t * Binary search the leaf entries looking for our hash value.\n\t */\n\tfor (lep = ents, low = 0, high = leafhdr.count - 1,\n\t\thashwant = args->hashval;\n\t     low <= high; ) {\n\t\tmid = (low + high) >> 1;\n\t\tif ((hash = be32_to_cpu(lep[mid].hashval)) == hashwant)\n\t\t\tbreak;\n\t\tif (hash < hashwant)\n\t\t\tlow = mid + 1;\n\t\telse\n\t\t\thigh = mid - 1;\n\t}\n\t/*\n\t * Found one, back up through all the equal hash values.\n\t */\n\tif (hash == hashwant) {\n\t\twhile (mid > 0 && be32_to_cpu(lep[mid - 1].hashval) == hashwant) {\n\t\t\tmid--;\n\t\t}\n\t}\n\t/*\n\t * Need to point to an entry higher than ours.\n\t */\n\telse if (hash < hashwant)\n\t\tmid++;\n\treturn mid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "leafhdr.count > 0"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_check",
          "args": [
            "dp",
            "bp"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_ents_p",
          "args": [
            "leaf"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_hdr_from_disk",
          "args": [
            "&leafhdr",
            "leaf"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);\n\nSTATIC int\nxfs_dir2_leafn_lookup_for_addname(\n\tstruct xfs_buf\t\t*bp,\t\t/* leaf buffer */\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tint\t\t\t*indexp,\t/* out: leaf entry index */\n\txfs_da_state_t\t\t*state)\t\t/* state to fill in */\n{\n\tstruct xfs_buf\t\t*curbp = NULL;\t/* current data/free buffer */\n\txfs_dir2_db_t\t\tcurdb = -1;\t/* current data block number */\n\txfs_dir2_db_t\t\tcurfdb = -1;\t/* current free block number */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tfi;\t\t/* free entry index */\n\txfs_dir2_free_t\t\t*free = NULL;\t/* free block structure */\n\tint\t\t\tindex;\t\t/* leaf entry index */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\tint\t\t\tlength;\t\t/* length of new data entry */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\txfs_dir2_db_t\t\tnewdb;\t\t/* new data block number */\n\txfs_dir2_db_t\t\tnewfdb;\t\t/* new free block number */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\tdp = args->dp;\n\ttp = args->trans;\n\tmp = dp->i_mount;\n\tleaf = bp->b_addr;\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\n\txfs_dir3_leaf_check(dp, bp);\n\tASSERT(leafhdr.count > 0);\n\n\t/*\n\t * Look up the hash value in the leaf entries.\n\t */\n\tindex = xfs_dir2_leaf_search_hash(args, bp);\n\t/*\n\t * Do we have a buffer coming in?\n\t */\n\tif (state->extravalid) {\n\t\t/* If so, it's a free block buffer, get the block number. */\n\t\tcurbp = state->extrablk.bp;\n\t\tcurfdb = state->extrablk.blkno;\n\t\tfree = curbp->b_addr;\n\t\tASSERT(free->hdr.magic == cpu_to_be32(XFS_DIR2_FREE_MAGIC) ||\n\t\t       free->hdr.magic == cpu_to_be32(XFS_DIR3_FREE_MAGIC));\n\t}\n\tlength = dp->d_ops->data_entsize(args->namelen);\n\t/*\n\t * Loop over leaf entries with the right hash value.\n\t */\n\tfor (lep = &ents[index];\n\t     index < leafhdr.count && be32_to_cpu(lep->hashval) == args->hashval;\n\t     lep++, index++) {\n\t\t/*\n\t\t * Skip stale leaf entries.\n\t\t */\n\t\tif (be32_to_cpu(lep->address) == XFS_DIR2_NULL_DATAPTR)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Pull the data block number from the entry.\n\t\t */\n\t\tnewdb = xfs_dir2_dataptr_to_db(args->geo,\n\t\t\t\t\t       be32_to_cpu(lep->address));\n\t\t/*\n\t\t * For addname, we're looking for a place to put the new entry.\n\t\t * We want to use a data block with an entry of equal\n\t\t * hash value to ours if there is one with room.\n\t\t *\n\t\t * If this block isn't the data block we already have\n\t\t * in hand, take a look at it.\n\t\t */\n\t\tif (newdb != curdb) {\n\t\t\t__be16 *bests;\n\n\t\t\tcurdb = newdb;\n\t\t\t/*\n\t\t\t * Convert the data block to the free block\n\t\t\t * holding its freespace information.\n\t\t\t */\n\t\t\tnewfdb = dp->d_ops->db_to_fdb(args->geo, newdb);\n\t\t\t/*\n\t\t\t * If it's not the one we have in hand, read it in.\n\t\t\t */\n\t\t\tif (newfdb != curfdb) {\n\t\t\t\t/*\n\t\t\t\t * If we had one before, drop it.\n\t\t\t\t */\n\t\t\t\tif (curbp)\n\t\t\t\t\txfs_trans_brelse(tp, curbp);\n\n\t\t\t\terror = xfs_dir2_free_read(tp, dp,\n\t\t\t\t\t\txfs_dir2_db_to_da(args->geo,\n\t\t\t\t\t\t\t\t  newfdb),\n\t\t\t\t\t\t&curbp);\n\t\t\t\tif (error)\n\t\t\t\t\treturn error;\n\t\t\t\tfree = curbp->b_addr;\n\n\t\t\t\txfs_dir2_free_hdr_check(dp, curbp, curdb);\n\t\t\t}\n\t\t\t/*\n\t\t\t * Get the index for our entry.\n\t\t\t */\n\t\t\tfi = dp->d_ops->db_to_fdindex(args->geo, curdb);\n\t\t\t/*\n\t\t\t * If it has room, return it.\n\t\t\t */\n\t\t\tbests = dp->d_ops->free_bests_p(free);\n\t\t\tif (unlikely(bests[fi] == cpu_to_be16(NULLDATAOFF))) {\n\t\t\t\tXFS_ERROR_REPORT(\"xfs_dir2_leafn_lookup_int\",\n\t\t\t\t\t\t\tXFS_ERRLEVEL_LOW, mp);\n\t\t\t\tif (curfdb != newfdb)\n\t\t\t\t\txfs_trans_brelse(tp, curbp);\n\t\t\t\treturn -EFSCORRUPTED;\n\t\t\t}\n\t\t\tcurfdb = newfdb;\n\t\t\tif (be16_to_cpu(bests[fi]) >= length)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\t/* Didn't find any space */\n\tfi = -1;\nout:\n\tASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\n\tif (curbp) {\n\t\t/* Giving back a free block. */\n\t\tstate->extravalid = 1;\n\t\tstate->extrablk.bp = curbp;\n\t\tstate->extrablk.index = fi;\n\t\tstate->extrablk.blkno = curfdb;\n\n\t\t/*\n\t\t * Important: this magic number is not in the buffer - it's for\n\t\t * buffer type information and therefore only the free/data type\n\t\t * matters here, not whether CRCs are enabled or not.\n\t\t */\n\t\tstate->extrablk.magic = XFS_DIR2_FREE_MAGIC;\n\t} else {\n\t\tstate->extravalid = 0;\n\t}\n\t/*\n\t * Return the index, that will be the insertion point.\n\t */\n\t*indexp = index;\n\treturn -ENOENT;\n}"
  },
  {
    "function_name": "xfs_dir2_leafn_lasthash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
    "lines": "479-501",
    "snippet": "xfs_dahash_t\t\t\t\t\t/* hash value */\nxfs_dir2_leafn_lasthash(\n\tstruct xfs_inode *dp,\n\tstruct xfs_buf\t*bp,\t\t\t/* leaf buffer */\n\tint\t\t*count)\t\t\t/* count of entries in leaf */\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\n\tASSERT(leafhdr.magic == XFS_DIR2_LEAFN_MAGIC ||\n\t       leafhdr.magic == XFS_DIR3_LEAFN_MAGIC);\n\n\tif (count)\n\t\t*count = leafhdr.count;\n\tif (!leafhdr.count)\n\t\treturn 0;\n\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\treturn be32_to_cpu(ents[leafhdr.count - 1].hashval);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ents[leafhdr.count - 1].hashval"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_ents_p",
          "args": [
            "leaf"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "leafhdr.magic == XFS_DIR2_LEAFN_MAGIC ||\n\t       leafhdr.magic == XFS_DIR3_LEAFN_MAGIC"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_hdr_from_disk",
          "args": [
            "&leafhdr",
            "leaf"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_dahash_t\t\t\t\t\t/* hash value */\nxfs_dir2_leafn_lasthash(\n\tstruct xfs_inode *dp,\n\tstruct xfs_buf\t*bp,\t\t\t/* leaf buffer */\n\tint\t\t*count)\t\t\t/* count of entries in leaf */\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\tstruct xfs_dir2_leaf_entry *ents;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\n\tASSERT(leafhdr.magic == XFS_DIR2_LEAFN_MAGIC ||\n\t       leafhdr.magic == XFS_DIR3_LEAFN_MAGIC);\n\n\tif (count)\n\t\t*count = leafhdr.count;\n\tif (!leafhdr.count)\n\t\treturn 0;\n\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\treturn be32_to_cpu(ents[leafhdr.count - 1].hashval);\n}"
  },
  {
    "function_name": "xfs_dir2_free_hdr_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
    "lines": "456-470",
    "snippet": "static void\nxfs_dir2_free_hdr_check(\n\tstruct xfs_inode *dp,\n\tstruct xfs_buf\t*bp,\n\txfs_dir2_db_t\tdb)\n{\n\tstruct xfs_dir3_icfree_hdr hdr;\n\n\tdp->d_ops->free_hdr_from_disk(&hdr, bp->b_addr);\n\n\tASSERT((hdr.firstdb %\n\t\tdp->d_ops->free_max_bests(dp->i_mount->m_dir_geo)) == 0);\n\tASSERT(hdr.firstdb <= db);\n\tASSERT(db < hdr.firstdb + hdr.nvalid);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "db < hdr.firstdb + hdr.nvalid"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "hdr.firstdb <= db"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(hdr.firstdb %\n\t\tdp->d_ops->free_max_bests(dp->i_mount->m_dir_geo)) == 0"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->free_max_bests",
          "args": [
            "dp->i_mount->m_dir_geo"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->free_hdr_from_disk",
          "args": [
            "&hdr",
            "bp->b_addr"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_dir2_free_hdr_check(\n\tstruct xfs_inode *dp,\n\tstruct xfs_buf\t*bp,\n\txfs_dir2_db_t\tdb)\n{\n\tstruct xfs_dir3_icfree_hdr hdr;\n\n\tdp->d_ops->free_hdr_from_disk(&hdr, bp->b_addr);\n\n\tASSERT((hdr.firstdb %\n\t\tdp->d_ops->free_max_bests(dp->i_mount->m_dir_geo)) == 0);\n\tASSERT(hdr.firstdb <= db);\n\tASSERT(db < hdr.firstdb + hdr.nvalid);\n}"
  },
  {
    "function_name": "xfs_dir2_leafn_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
    "lines": "372-453",
    "snippet": "static int\t\t\t\t\t/* error */\nxfs_dir2_leafn_add(\n\tstruct xfs_buf\t\t*bp,\t\t/* leaf buffer */\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tint\t\t\tindex)\t\t/* insertion pt for new entry */\n{\n\tint\t\t\tcompact;\t/* compacting stale leaves */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\thighstale;\t/* next stale entry */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\tint\t\t\tlfloghigh;\t/* high leaf entry logging */\n\tint\t\t\tlfloglow;\t/* low leaf entry logging */\n\tint\t\t\tlowstale;\t/* previous stale entry */\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\tstruct xfs_dir2_leaf_entry *ents;\n\n\ttrace_xfs_dir2_leafn_add(args, index);\n\n\tdp = args->dp;\n\tleaf = bp->b_addr;\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\n\t/*\n\t * Quick check just to make sure we are not going to index\n\t * into other peoples memory\n\t */\n\tif (index < 0)\n\t\treturn -EFSCORRUPTED;\n\n\t/*\n\t * If there are already the maximum number of leaf entries in\n\t * the block, if there are no stale entries it won't fit.\n\t * Caller will do a split.  If there are stale entries we'll do\n\t * a compact.\n\t */\n\n\tif (leafhdr.count == dp->d_ops->leaf_max_ents(args->geo)) {\n\t\tif (!leafhdr.stale)\n\t\t\treturn -ENOSPC;\n\t\tcompact = leafhdr.stale > 1;\n\t} else\n\t\tcompact = 0;\n\tASSERT(index == 0 || be32_to_cpu(ents[index - 1].hashval) <= args->hashval);\n\tASSERT(index == leafhdr.count ||\n\t       be32_to_cpu(ents[index].hashval) >= args->hashval);\n\n\tif (args->op_flags & XFS_DA_OP_JUSTCHECK)\n\t\treturn 0;\n\n\t/*\n\t * Compact out all but one stale leaf entry.  Leaves behind\n\t * the entry closest to index.\n\t */\n\tif (compact)\n\t\txfs_dir3_leaf_compact_x1(&leafhdr, ents, &index, &lowstale,\n\t\t\t\t\t &highstale, &lfloglow, &lfloghigh);\n\telse if (leafhdr.stale) {\n\t\t/*\n\t\t * Set impossible logging indices for this case.\n\t\t */\n\t\tlfloglow = leafhdr.count;\n\t\tlfloghigh = -1;\n\t}\n\n\t/*\n\t * Insert the new entry, log everything.\n\t */\n\tlep = xfs_dir3_leaf_find_entry(&leafhdr, ents, index, compact, lowstale,\n\t\t\t\t       highstale, &lfloglow, &lfloghigh);\n\n\tlep->hashval = cpu_to_be32(args->hashval);\n\tlep->address = cpu_to_be32(xfs_dir2_db_off_to_dataptr(args->geo,\n\t\t\t\targs->blkno, args->index));\n\n\tdp->d_ops->leaf_hdr_to_disk(leaf, &leafhdr);\n\txfs_dir3_leaf_log_header(args, bp);\n\txfs_dir3_leaf_log_ents(args, bp, lfloglow, lfloghigh);\n\txfs_dir3_leaf_check(dp, bp);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_check",
          "args": [
            "dp",
            "bp"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_log_ents",
          "args": [
            "args",
            "bp",
            "lfloglow",
            "lfloghigh"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_leaf_log_ents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "1077-1100",
          "snippet": "void\nxfs_dir3_leaf_log_ents(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\n\tint\t\t\tlast)\n{\n\txfs_dir2_leaf_entry_t\t*firstlep;\t/* pointer to first entry */\n\txfs_dir2_leaf_entry_t\t*lastlep;\t/* pointer to last entry */\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\tstruct xfs_dir2_leaf_entry *ents;\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\tents = args->dp->d_ops->leaf_ents_p(leaf);\n\tfirstlep = &ents[first];\n\tlastlep = &ents[last];\n\txfs_trans_log_buf(args->trans, bp,\n\t\t(uint)((char *)firstlep - (char *)leaf),\n\t\t(uint)((char *)lastlep - (char *)leaf + sizeof(*lastlep) - 1));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);",
            "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nvoid\nxfs_dir3_leaf_log_ents(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\n\tint\t\t\tlast)\n{\n\txfs_dir2_leaf_entry_t\t*firstlep;\t/* pointer to first entry */\n\txfs_dir2_leaf_entry_t\t*lastlep;\t/* pointer to last entry */\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\tstruct xfs_dir2_leaf_entry *ents;\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\tents = args->dp->d_ops->leaf_ents_p(leaf);\n\tfirstlep = &ents[first];\n\tlastlep = &ents[last];\n\txfs_trans_log_buf(args->trans, bp,\n\t\t(uint)((char *)firstlep - (char *)leaf),\n\t\t(uint)((char *)lastlep - (char *)leaf + sizeof(*lastlep) - 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_log_header",
          "args": [
            "args",
            "bp"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_leaf_log_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "1105-1120",
          "snippet": "void\nxfs_dir3_leaf_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t  (uint)((char *)&leaf->hdr - (char *)leaf),\n\t\t\t  args->dp->d_ops->leaf_hdr_size - 1);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nvoid\nxfs_dir3_leaf_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t  (uint)((char *)&leaf->hdr - (char *)leaf),\n\t\t\t  args->dp->d_ops->leaf_hdr_size - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_hdr_to_disk",
          "args": [
            "leaf",
            "&leafhdr"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "xfs_dir2_db_off_to_dataptr(args->geo,\n\t\t\t\targs->blkno, args->index)"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_db_off_to_dataptr",
          "args": [
            "args->geo",
            "args->blkno",
            "args->index"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_db_off_to_dataptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "277-282",
          "snippet": "static inline xfs_dir2_dataptr_t\nxfs_dir2_db_off_to_dataptr(struct xfs_da_geometry *geo, xfs_dir2_db_t db,\n\t\t\t   xfs_dir2_data_aoff_t o)\n{\n\treturn xfs_dir2_byte_to_dataptr(xfs_dir2_db_off_to_byte(geo, db, o));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_dataptr_t\nxfs_dir2_db_off_to_dataptr(struct xfs_da_geometry *geo, xfs_dir2_db_t db,\n\t\t\t   xfs_dir2_data_aoff_t o)\n{\n\treturn xfs_dir2_byte_to_dataptr(xfs_dir2_db_off_to_byte(geo, db, o));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "args->hashval"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_find_entry",
          "args": [
            "&leafhdr",
            "ents",
            "index",
            "compact",
            "lowstale",
            "highstale",
            "&lfloglow",
            "&lfloghigh"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_leaf_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "508-596",
          "snippet": "struct xfs_dir2_leaf_entry *\nxfs_dir3_leaf_find_entry(\n\tstruct xfs_dir3_icleaf_hdr *leafhdr,\n\tstruct xfs_dir2_leaf_entry *ents,\n\tint\t\t\tindex,\t\t/* leaf table position */\n\tint\t\t\tcompact,\t/* need to compact leaves */\n\tint\t\t\tlowstale,\t/* index of prev stale leaf */\n\tint\t\t\thighstale,\t/* index of next stale leaf */\n\tint\t\t\t*lfloglow,\t/* low leaf logging index */\n\tint\t\t\t*lfloghigh)\t/* high leaf logging index */\n{\n\tif (!leafhdr->stale) {\n\t\txfs_dir2_leaf_entry_t\t*lep;\t/* leaf entry table pointer */\n\n\t\t/*\n\t\t * Now we need to make room to insert the leaf entry.\n\t\t *\n\t\t * If there are no stale entries, just insert a hole at index.\n\t\t */\n\t\tlep = &ents[index];\n\t\tif (index < leafhdr->count)\n\t\t\tmemmove(lep + 1, lep,\n\t\t\t\t(leafhdr->count - index) * sizeof(*lep));\n\n\t\t/*\n\t\t * Record low and high logging indices for the leaf.\n\t\t */\n\t\t*lfloglow = index;\n\t\t*lfloghigh = leafhdr->count++;\n\t\treturn lep;\n\t}\n\n\t/*\n\t * There are stale entries.\n\t *\n\t * We will use one of them for the new entry.  It's probably not at\n\t * the right location, so we'll have to shift some up or down first.\n\t *\n\t * If we didn't compact before, we need to find the nearest stale\n\t * entries before and after our insertion point.\n\t */\n\tif (compact == 0)\n\t\txfs_dir3_leaf_find_stale(leafhdr, ents, index,\n\t\t\t\t\t &lowstale, &highstale);\n\n\t/*\n\t * If the low one is better, use it.\n\t */\n\tif (lowstale >= 0 &&\n\t    (highstale == leafhdr->count ||\n\t     index - lowstale - 1 < highstale - index)) {\n\t\tASSERT(index - lowstale - 1 >= 0);\n\t\tASSERT(ents[lowstale].address ==\n\t\t       cpu_to_be32(XFS_DIR2_NULL_DATAPTR));\n\n\t\t/*\n\t\t * Copy entries up to cover the stale entry and make room\n\t\t * for the new entry.\n\t\t */\n\t\tif (index - lowstale - 1 > 0) {\n\t\t\tmemmove(&ents[lowstale], &ents[lowstale + 1],\n\t\t\t\t(index - lowstale - 1) *\n\t\t\t\t\tsizeof(xfs_dir2_leaf_entry_t));\n\t\t}\n\t\t*lfloglow = MIN(lowstale, *lfloglow);\n\t\t*lfloghigh = MAX(index - 1, *lfloghigh);\n\t\tleafhdr->stale--;\n\t\treturn &ents[index - 1];\n\t}\n\n\t/*\n\t * The high one is better, so use that one.\n\t */\n\tASSERT(highstale - index >= 0);\n\tASSERT(ents[highstale].address == cpu_to_be32(XFS_DIR2_NULL_DATAPTR));\n\n\t/*\n\t * Copy entries down to cover the stale entry and make room for the\n\t * new entry.\n\t */\n\tif (highstale - index > 0) {\n\t\tmemmove(&ents[index + 1], &ents[index],\n\t\t\t(highstale - index) * sizeof(xfs_dir2_leaf_entry_t));\n\t}\n\t*lfloglow = MIN(index, *lfloglow);\n\t*lfloghigh = MAX(highstale, *lfloghigh);\n\tleafhdr->stale--;\n\treturn &ents[index];\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_dir2_leaf_entry *\nxfs_dir3_leaf_find_entry(\n\tstruct xfs_dir3_icleaf_hdr *leafhdr,\n\tstruct xfs_dir2_leaf_entry *ents,\n\tint\t\t\tindex,\t\t/* leaf table position */\n\tint\t\t\tcompact,\t/* need to compact leaves */\n\tint\t\t\tlowstale,\t/* index of prev stale leaf */\n\tint\t\t\thighstale,\t/* index of next stale leaf */\n\tint\t\t\t*lfloglow,\t/* low leaf logging index */\n\tint\t\t\t*lfloghigh)\t/* high leaf logging index */\n{\n\tif (!leafhdr->stale) {\n\t\txfs_dir2_leaf_entry_t\t*lep;\t/* leaf entry table pointer */\n\n\t\t/*\n\t\t * Now we need to make room to insert the leaf entry.\n\t\t *\n\t\t * If there are no stale entries, just insert a hole at index.\n\t\t */\n\t\tlep = &ents[index];\n\t\tif (index < leafhdr->count)\n\t\t\tmemmove(lep + 1, lep,\n\t\t\t\t(leafhdr->count - index) * sizeof(*lep));\n\n\t\t/*\n\t\t * Record low and high logging indices for the leaf.\n\t\t */\n\t\t*lfloglow = index;\n\t\t*lfloghigh = leafhdr->count++;\n\t\treturn lep;\n\t}\n\n\t/*\n\t * There are stale entries.\n\t *\n\t * We will use one of them for the new entry.  It's probably not at\n\t * the right location, so we'll have to shift some up or down first.\n\t *\n\t * If we didn't compact before, we need to find the nearest stale\n\t * entries before and after our insertion point.\n\t */\n\tif (compact == 0)\n\t\txfs_dir3_leaf_find_stale(leafhdr, ents, index,\n\t\t\t\t\t &lowstale, &highstale);\n\n\t/*\n\t * If the low one is better, use it.\n\t */\n\tif (lowstale >= 0 &&\n\t    (highstale == leafhdr->count ||\n\t     index - lowstale - 1 < highstale - index)) {\n\t\tASSERT(index - lowstale - 1 >= 0);\n\t\tASSERT(ents[lowstale].address ==\n\t\t       cpu_to_be32(XFS_DIR2_NULL_DATAPTR));\n\n\t\t/*\n\t\t * Copy entries up to cover the stale entry and make room\n\t\t * for the new entry.\n\t\t */\n\t\tif (index - lowstale - 1 > 0) {\n\t\t\tmemmove(&ents[lowstale], &ents[lowstale + 1],\n\t\t\t\t(index - lowstale - 1) *\n\t\t\t\t\tsizeof(xfs_dir2_leaf_entry_t));\n\t\t}\n\t\t*lfloglow = MIN(lowstale, *lfloglow);\n\t\t*lfloghigh = MAX(index - 1, *lfloghigh);\n\t\tleafhdr->stale--;\n\t\treturn &ents[index - 1];\n\t}\n\n\t/*\n\t * The high one is better, so use that one.\n\t */\n\tASSERT(highstale - index >= 0);\n\tASSERT(ents[highstale].address == cpu_to_be32(XFS_DIR2_NULL_DATAPTR));\n\n\t/*\n\t * Copy entries down to cover the stale entry and make room for the\n\t * new entry.\n\t */\n\tif (highstale - index > 0) {\n\t\tmemmove(&ents[index + 1], &ents[index],\n\t\t\t(highstale - index) * sizeof(xfs_dir2_leaf_entry_t));\n\t}\n\t*lfloglow = MIN(index, *lfloglow);\n\t*lfloghigh = MAX(highstale, *lfloghigh);\n\tleafhdr->stale--;\n\treturn &ents[index];\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_compact_x1",
          "args": [
            "&leafhdr",
            "ents",
            "&index",
            "&lowstale",
            "&highstale",
            "&lfloglow",
            "&lfloghigh"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_leaf_compact_x1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "962-1046",
          "snippet": "void\nxfs_dir3_leaf_compact_x1(\n\tstruct xfs_dir3_icleaf_hdr *leafhdr,\n\tstruct xfs_dir2_leaf_entry *ents,\n\tint\t\t*indexp,\t/* insertion index */\n\tint\t\t*lowstalep,\t/* out: stale entry before us */\n\tint\t\t*highstalep,\t/* out: stale entry after us */\n\tint\t\t*lowlogp,\t/* out: low log index */\n\tint\t\t*highlogp)\t/* out: high log index */\n{\n\tint\t\tfrom;\t\t/* source copy index */\n\tint\t\thighstale;\t/* stale entry at/after index */\n\tint\t\tindex;\t\t/* insertion index */\n\tint\t\tkeepstale;\t/* source index of kept stale */\n\tint\t\tlowstale;\t/* stale entry before index */\n\tint\t\tnewindex=0;\t/* new insertion index */\n\tint\t\tto;\t\t/* destination copy index */\n\n\tASSERT(leafhdr->stale > 1);\n\tindex = *indexp;\n\n\txfs_dir3_leaf_find_stale(leafhdr, ents, index, &lowstale, &highstale);\n\n\t/*\n\t * Pick the better of lowstale and highstale.\n\t */\n\tif (lowstale >= 0 &&\n\t    (highstale == leafhdr->count ||\n\t     index - lowstale <= highstale - index))\n\t\tkeepstale = lowstale;\n\telse\n\t\tkeepstale = highstale;\n\t/*\n\t * Copy the entries in place, removing all the stale entries\n\t * except keepstale.\n\t */\n\tfor (from = to = 0; from < leafhdr->count; from++) {\n\t\t/*\n\t\t * Notice the new value of index.\n\t\t */\n\t\tif (index == from)\n\t\t\tnewindex = to;\n\t\tif (from != keepstale &&\n\t\t    ents[from].address == cpu_to_be32(XFS_DIR2_NULL_DATAPTR)) {\n\t\t\tif (from == to)\n\t\t\t\t*lowlogp = to;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Record the new keepstale value for the insertion.\n\t\t */\n\t\tif (from == keepstale)\n\t\t\tlowstale = highstale = to;\n\t\t/*\n\t\t * Copy only the entries that have moved.\n\t\t */\n\t\tif (from > to)\n\t\t\tents[to] = ents[from];\n\t\tto++;\n\t}\n\tASSERT(from > to);\n\t/*\n\t * If the insertion point was past the last entry,\n\t * set the new insertion point accordingly.\n\t */\n\tif (index == from)\n\t\tnewindex = to;\n\t*indexp = newindex;\n\t/*\n\t * Adjust the leaf header values.\n\t */\n\tleafhdr->count -= from - to;\n\tleafhdr->stale = 1;\n\t/*\n\t * Remember the low/high stale value only in the \"right\"\n\t * direction.\n\t */\n\tif (lowstale >= newindex)\n\t\tlowstale = -1;\n\telse\n\t\thighstale = leafhdr->count;\n\t*highlogp = leafhdr->count - 1;\n\t*lowstalep = lowstale;\n\t*highstalep = highstale;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_bests(struct xfs_da_args *args,\n\t\t\t\t    struct xfs_buf *bp, int first, int last);\n\nvoid\nxfs_dir3_leaf_compact_x1(\n\tstruct xfs_dir3_icleaf_hdr *leafhdr,\n\tstruct xfs_dir2_leaf_entry *ents,\n\tint\t\t*indexp,\t/* insertion index */\n\tint\t\t*lowstalep,\t/* out: stale entry before us */\n\tint\t\t*highstalep,\t/* out: stale entry after us */\n\tint\t\t*lowlogp,\t/* out: low log index */\n\tint\t\t*highlogp)\t/* out: high log index */\n{\n\tint\t\tfrom;\t\t/* source copy index */\n\tint\t\thighstale;\t/* stale entry at/after index */\n\tint\t\tindex;\t\t/* insertion index */\n\tint\t\tkeepstale;\t/* source index of kept stale */\n\tint\t\tlowstale;\t/* stale entry before index */\n\tint\t\tnewindex=0;\t/* new insertion index */\n\tint\t\tto;\t\t/* destination copy index */\n\n\tASSERT(leafhdr->stale > 1);\n\tindex = *indexp;\n\n\txfs_dir3_leaf_find_stale(leafhdr, ents, index, &lowstale, &highstale);\n\n\t/*\n\t * Pick the better of lowstale and highstale.\n\t */\n\tif (lowstale >= 0 &&\n\t    (highstale == leafhdr->count ||\n\t     index - lowstale <= highstale - index))\n\t\tkeepstale = lowstale;\n\telse\n\t\tkeepstale = highstale;\n\t/*\n\t * Copy the entries in place, removing all the stale entries\n\t * except keepstale.\n\t */\n\tfor (from = to = 0; from < leafhdr->count; from++) {\n\t\t/*\n\t\t * Notice the new value of index.\n\t\t */\n\t\tif (index == from)\n\t\t\tnewindex = to;\n\t\tif (from != keepstale &&\n\t\t    ents[from].address == cpu_to_be32(XFS_DIR2_NULL_DATAPTR)) {\n\t\t\tif (from == to)\n\t\t\t\t*lowlogp = to;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Record the new keepstale value for the insertion.\n\t\t */\n\t\tif (from == keepstale)\n\t\t\tlowstale = highstale = to;\n\t\t/*\n\t\t * Copy only the entries that have moved.\n\t\t */\n\t\tif (from > to)\n\t\t\tents[to] = ents[from];\n\t\tto++;\n\t}\n\tASSERT(from > to);\n\t/*\n\t * If the insertion point was past the last entry,\n\t * set the new insertion point accordingly.\n\t */\n\tif (index == from)\n\t\tnewindex = to;\n\t*indexp = newindex;\n\t/*\n\t * Adjust the leaf header values.\n\t */\n\tleafhdr->count -= from - to;\n\tleafhdr->stale = 1;\n\t/*\n\t * Remember the low/high stale value only in the \"right\"\n\t * direction.\n\t */\n\tif (lowstale >= newindex)\n\t\tlowstale = -1;\n\telse\n\t\thighstale = leafhdr->count;\n\t*highlogp = leafhdr->count - 1;\n\t*lowstalep = lowstale;\n\t*highstalep = highstale;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "index == leafhdr.count ||\n\t       be32_to_cpu(ents[index].hashval) >= args->hashval"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ents[index].hashval"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "index == 0 || be32_to_cpu(ents[index - 1].hashval) <= args->hashval"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ents[index - 1].hashval"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_max_ents",
          "args": [
            "args->geo"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_ents_p",
          "args": [
            "leaf"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_hdr_from_disk",
          "args": [
            "&leafhdr",
            "leaf"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_dir2_leafn_add",
          "args": [
            "args",
            "index"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);\n\nstatic int\t\t\t\t\t/* error */\nxfs_dir2_leafn_add(\n\tstruct xfs_buf\t\t*bp,\t\t/* leaf buffer */\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tint\t\t\tindex)\t\t/* insertion pt for new entry */\n{\n\tint\t\t\tcompact;\t/* compacting stale leaves */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\thighstale;\t/* next stale entry */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_entry_t\t*lep;\t\t/* leaf entry */\n\tint\t\t\tlfloghigh;\t/* high leaf entry logging */\n\tint\t\t\tlfloglow;\t/* low leaf entry logging */\n\tint\t\t\tlowstale;\t/* previous stale entry */\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\tstruct xfs_dir2_leaf_entry *ents;\n\n\ttrace_xfs_dir2_leafn_add(args, index);\n\n\tdp = args->dp;\n\tleaf = bp->b_addr;\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\tents = dp->d_ops->leaf_ents_p(leaf);\n\n\t/*\n\t * Quick check just to make sure we are not going to index\n\t * into other peoples memory\n\t */\n\tif (index < 0)\n\t\treturn -EFSCORRUPTED;\n\n\t/*\n\t * If there are already the maximum number of leaf entries in\n\t * the block, if there are no stale entries it won't fit.\n\t * Caller will do a split.  If there are stale entries we'll do\n\t * a compact.\n\t */\n\n\tif (leafhdr.count == dp->d_ops->leaf_max_ents(args->geo)) {\n\t\tif (!leafhdr.stale)\n\t\t\treturn -ENOSPC;\n\t\tcompact = leafhdr.stale > 1;\n\t} else\n\t\tcompact = 0;\n\tASSERT(index == 0 || be32_to_cpu(ents[index - 1].hashval) <= args->hashval);\n\tASSERT(index == leafhdr.count ||\n\t       be32_to_cpu(ents[index].hashval) >= args->hashval);\n\n\tif (args->op_flags & XFS_DA_OP_JUSTCHECK)\n\t\treturn 0;\n\n\t/*\n\t * Compact out all but one stale leaf entry.  Leaves behind\n\t * the entry closest to index.\n\t */\n\tif (compact)\n\t\txfs_dir3_leaf_compact_x1(&leafhdr, ents, &index, &lowstale,\n\t\t\t\t\t &highstale, &lfloglow, &lfloghigh);\n\telse if (leafhdr.stale) {\n\t\t/*\n\t\t * Set impossible logging indices for this case.\n\t\t */\n\t\tlfloglow = leafhdr.count;\n\t\tlfloghigh = -1;\n\t}\n\n\t/*\n\t * Insert the new entry, log everything.\n\t */\n\tlep = xfs_dir3_leaf_find_entry(&leafhdr, ents, index, compact, lowstale,\n\t\t\t\t       highstale, &lfloglow, &lfloghigh);\n\n\tlep->hashval = cpu_to_be32(args->hashval);\n\tlep->address = cpu_to_be32(xfs_dir2_db_off_to_dataptr(args->geo,\n\t\t\t\targs->blkno, args->index));\n\n\tdp->d_ops->leaf_hdr_to_disk(leaf, &leafhdr);\n\txfs_dir3_leaf_log_header(args, bp);\n\txfs_dir3_leaf_log_ents(args, bp, lfloglow, lfloghigh);\n\txfs_dir3_leaf_check(dp, bp);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_dir2_leaf_to_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
    "lines": "284-366",
    "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_leaf_to_node(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tstruct xfs_buf\t\t*lbp)\t\t/* leaf buffer */\n{\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return value */\n\tstruct xfs_buf\t\t*fbp;\t\t/* freespace buffer */\n\txfs_dir2_db_t\t\tfdb;\t\t/* freespace block number */\n\txfs_dir2_free_t\t\t*free;\t\t/* freespace structure */\n\t__be16\t\t\t*from;\t\t/* pointer to freespace entry */\n\tint\t\t\ti;\t\t/* leaf freespace index */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf tail structure */\n\tint\t\t\tn;\t\t/* count of live freespc ents */\n\txfs_dir2_data_off_t\toff;\t\t/* freespace entry value */\n\t__be16\t\t\t*to;\t\t/* pointer to freespace entry */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tstruct xfs_dir3_icfree_hdr freehdr;\n\n\ttrace_xfs_dir2_leaf_to_node(args);\n\n\tdp = args->dp;\n\ttp = args->trans;\n\t/*\n\t * Add a freespace block to the directory.\n\t */\n\tif ((error = xfs_dir2_grow_inode(args, XFS_DIR2_FREE_SPACE, &fdb))) {\n\t\treturn error;\n\t}\n\tASSERT(fdb == xfs_dir2_byte_to_db(args->geo, XFS_DIR2_FREE_OFFSET));\n\t/*\n\t * Get the buffer for the new freespace block.\n\t */\n\terror = xfs_dir3_free_get_buf(args, fdb, &fbp);\n\tif (error)\n\t\treturn error;\n\n\tfree = fbp->b_addr;\n\tdp->d_ops->free_hdr_from_disk(&freehdr, free);\n\tleaf = lbp->b_addr;\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\tASSERT(be32_to_cpu(ltp->bestcount) <=\n\t\t\t\t(uint)dp->i_d.di_size / args->geo->blksize);\n\n\t/*\n\t * Copy freespace entries from the leaf block to the new block.\n\t * Count active entries.\n\t */\n\tfrom = xfs_dir2_leaf_bests_p(ltp);\n\tto = dp->d_ops->free_bests_p(free);\n\tfor (i = n = 0; i < be32_to_cpu(ltp->bestcount); i++, from++, to++) {\n\t\tif ((off = be16_to_cpu(*from)) != NULLDATAOFF)\n\t\t\tn++;\n\t\t*to = cpu_to_be16(off);\n\t}\n\n\t/*\n\t * Now initialize the freespace block header.\n\t */\n\tfreehdr.nused = n;\n\tfreehdr.nvalid = be32_to_cpu(ltp->bestcount);\n\n\tdp->d_ops->free_hdr_to_disk(fbp->b_addr, &freehdr);\n\txfs_dir2_free_log_bests(args, fbp, 0, freehdr.nvalid - 1);\n\txfs_dir2_free_log_header(args, fbp);\n\n\t/*\n\t * Converting the leaf to a leafnode is just a matter of changing the\n\t * magic number and the ops. Do the change directly to the buffer as\n\t * it's less work (and less code) than decoding the header to host\n\t * format and back again.\n\t */\n\tif (leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC))\n\t\tleaf->hdr.info.magic = cpu_to_be16(XFS_DIR2_LEAFN_MAGIC);\n\telse\n\t\tleaf->hdr.info.magic = cpu_to_be16(XFS_DIR3_LEAFN_MAGIC);\n\tlbp->b_ops = &xfs_dir3_leafn_buf_ops;\n\txfs_trans_buf_set_type(tp, lbp, XFS_BLFT_DIR_LEAFN_BUF);\n\txfs_dir3_leaf_log_header(args, lbp);\n\txfs_dir3_leaf_check(dp, lbp);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_check",
          "args": [
            "dp",
            "lbp"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_log_header",
          "args": [
            "args",
            "lbp"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_leaf_log_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "1105-1120",
          "snippet": "void\nxfs_dir3_leaf_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t  (uint)((char *)&leaf->hdr - (char *)leaf),\n\t\t\t  args->dp->d_ops->leaf_hdr_size - 1);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir3_leaf_log_tail(struct xfs_da_args *args,\n\t\t\t\t   struct xfs_buf *bp);\n\nvoid\nxfs_dir3_leaf_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\n\tASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAF1_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC) ||\n\t       leaf->hdr.info.magic == cpu_to_be16(XFS_DIR3_LEAFN_MAGIC));\n\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t  (uint)((char *)&leaf->hdr - (char *)leaf),\n\t\t\t  args->dp->d_ops->leaf_hdr_size - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_buf_set_type",
          "args": [
            "tp",
            "lbp",
            "XFS_BLFT_DIR_LEAFN_BUF"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_buf_set_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "730-746",
          "snippet": "void\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DIR3_LEAFN_MAGIC"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DIR2_LEAFN_MAGIC"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "XFS_DIR2_LEAF1_MAGIC"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_free_log_header",
          "args": [
            "args",
            "fbp"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_free_log_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
          "lines": "263-277",
          "snippet": "static void\nxfs_dir2_free_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n#ifdef DEBUG\n\txfs_dir2_free_t\t\t*free;\t\t/* freespace structure */\n\n\tfree = bp->b_addr;\n\tASSERT(free->hdr.magic == cpu_to_be32(XFS_DIR2_FREE_MAGIC) ||\n\t       free->hdr.magic == cpu_to_be32(XFS_DIR3_FREE_MAGIC));\n#endif\n\txfs_trans_log_buf(args->trans, bp, 0,\n\t\t\t  args->dp->d_ops->free_hdr_size - 1);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_dir2_free_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n#ifdef DEBUG\n\txfs_dir2_free_t\t\t*free;\t\t/* freespace structure */\n\n\tfree = bp->b_addr;\n\tASSERT(free->hdr.magic == cpu_to_be32(XFS_DIR2_FREE_MAGIC) ||\n\t       free->hdr.magic == cpu_to_be32(XFS_DIR3_FREE_MAGIC));\n#endif\n\txfs_trans_log_buf(args->trans, bp, 0,\n\t\t\t  args->dp->d_ops->free_hdr_size - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_free_log_bests",
          "args": [
            "args",
            "fbp",
            "0",
            "freehdr.nvalid - 1"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_free_log_bests",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
          "lines": "240-258",
          "snippet": "STATIC void\nxfs_dir2_free_log_bests(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\t\t/* first entry to log */\n\tint\t\t\tlast)\t\t/* last entry to log */\n{\n\txfs_dir2_free_t\t\t*free;\t\t/* freespace structure */\n\t__be16\t\t\t*bests;\n\n\tfree = bp->b_addr;\n\tbests = args->dp->d_ops->free_bests_p(free);\n\tASSERT(free->hdr.magic == cpu_to_be32(XFS_DIR2_FREE_MAGIC) ||\n\t       free->hdr.magic == cpu_to_be32(XFS_DIR3_FREE_MAGIC));\n\txfs_trans_log_buf(args->trans, bp,\n\t\t(uint)((char *)&bests[first] - (char *)free),\n\t\t(uint)((char *)&bests[last] - (char *)free +\n\t\t       sizeof(bests[0]) - 1));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_dir2_free_log_bests(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\t\t/* first entry to log */\n\tint\t\t\tlast)\t\t/* last entry to log */\n{\n\txfs_dir2_free_t\t\t*free;\t\t/* freespace structure */\n\t__be16\t\t\t*bests;\n\n\tfree = bp->b_addr;\n\tbests = args->dp->d_ops->free_bests_p(free);\n\tASSERT(free->hdr.magic == cpu_to_be32(XFS_DIR2_FREE_MAGIC) ||\n\t       free->hdr.magic == cpu_to_be32(XFS_DIR3_FREE_MAGIC));\n\txfs_trans_log_buf(args->trans, bp,\n\t\t(uint)((char *)&bests[first] - (char *)free),\n\t\t(uint)((char *)&bests[last] - (char *)free +\n\t\t       sizeof(bests[0]) - 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->free_hdr_to_disk",
          "args": [
            "fbp->b_addr",
            "&freehdr"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ltp->bestcount"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "off"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "*from"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ltp->bestcount"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->free_bests_p",
          "args": [
            "free"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leaf_bests_p",
          "args": [
            "ltp"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leaf_bests_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_format.h",
          "lines": "509-513",
          "snippet": "static inline __be16 *\nxfs_dir2_leaf_bests_p(struct xfs_dir2_leaf_tail *ltp)\n{\n\treturn (__be16 *)ltp - be32_to_cpu(ltp->bestcount);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __be16 *\nxfs_dir2_leaf_bests_p(struct xfs_dir2_leaf_tail *ltp)\n{\n\treturn (__be16 *)ltp - be32_to_cpu(ltp->bestcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "be32_to_cpu(ltp->bestcount) <=\n\t\t\t\t(uint)dp->i_d.di_size / args->geo->blksize"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ltp->bestcount"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_leaf_tail_p",
          "args": [
            "args->geo",
            "leaf"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_leaf_tail_p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "312-318",
          "snippet": "static inline struct xfs_dir2_leaf_tail *\nxfs_dir2_leaf_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_leaf *lp)\n{\n\treturn (struct xfs_dir2_leaf_tail *)\n\t\t((char *)lp + geo->blksize -\n\t\t  sizeof(struct xfs_dir2_leaf_tail));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_dir2_leaf_tail *\nxfs_dir2_leaf_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_leaf *lp)\n{\n\treturn (struct xfs_dir2_leaf_tail *)\n\t\t((char *)lp + geo->blksize -\n\t\t  sizeof(struct xfs_dir2_leaf_tail));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dp->d_ops->free_hdr_from_disk",
          "args": [
            "&freehdr",
            "free"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir3_free_get_buf",
          "args": [
            "args",
            "fdb",
            "&fbp"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_free_get_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
          "lines": "194-235",
          "snippet": "static int\nxfs_dir3_free_get_buf(\n\txfs_da_args_t\t\t*args,\n\txfs_dir2_db_t\t\tfbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_trans\t*tp = args->trans;\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\tstruct xfs_dir3_icfree_hdr hdr;\n\n\terror = xfs_da_get_buf(tp, dp, xfs_dir2_db_to_da(args->geo, fbno),\n\t\t\t\t   -1, &bp, XFS_DATA_FORK);\n\tif (error)\n\t\treturn error;\n\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DIR_FREE_BUF);\n\tbp->b_ops = &xfs_dir3_free_buf_ops;\n\n\t/*\n\t * Initialize the new block to be empty, and remember\n\t * its first slot as our empty slot.\n\t */\n\tmemset(bp->b_addr, 0, sizeof(struct xfs_dir3_free_hdr));\n\tmemset(&hdr, 0, sizeof(hdr));\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_dir3_free_hdr *hdr3 = bp->b_addr;\n\n\t\thdr.magic = XFS_DIR3_FREE_MAGIC;\n\n\t\thdr3->hdr.blkno = cpu_to_be64(bp->b_bn);\n\t\thdr3->hdr.owner = cpu_to_be64(dp->i_ino);\n\t\tuuid_copy(&hdr3->hdr.uuid, &mp->m_sb.sb_uuid);\n\t} else\n\t\thdr.magic = XFS_DIR2_FREE_MAGIC;\n\tdp->d_ops->free_hdr_to_disk(bp->b_addr, &hdr);\n\t*bpp = bp;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_dir3_free_buf_ops = {\n\t.verify_read = xfs_dir3_free_read_verify,\n\t.verify_write = xfs_dir3_free_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_dir3_free_buf_ops = {\n\t.verify_read = xfs_dir3_free_read_verify,\n\t.verify_write = xfs_dir3_free_write_verify,\n};\n\nstatic int\nxfs_dir3_free_get_buf(\n\txfs_da_args_t\t\t*args,\n\txfs_dir2_db_t\t\tfbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_trans\t*tp = args->trans;\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\tstruct xfs_dir3_icfree_hdr hdr;\n\n\terror = xfs_da_get_buf(tp, dp, xfs_dir2_db_to_da(args->geo, fbno),\n\t\t\t\t   -1, &bp, XFS_DATA_FORK);\n\tif (error)\n\t\treturn error;\n\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DIR_FREE_BUF);\n\tbp->b_ops = &xfs_dir3_free_buf_ops;\n\n\t/*\n\t * Initialize the new block to be empty, and remember\n\t * its first slot as our empty slot.\n\t */\n\tmemset(bp->b_addr, 0, sizeof(struct xfs_dir3_free_hdr));\n\tmemset(&hdr, 0, sizeof(hdr));\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_dir3_free_hdr *hdr3 = bp->b_addr;\n\n\t\thdr.magic = XFS_DIR3_FREE_MAGIC;\n\n\t\thdr3->hdr.blkno = cpu_to_be64(bp->b_bn);\n\t\thdr3->hdr.owner = cpu_to_be64(dp->i_ino);\n\t\tuuid_copy(&hdr3->hdr.uuid, &mp->m_sb.sb_uuid);\n\t} else\n\t\thdr.magic = XFS_DIR2_FREE_MAGIC;\n\tdp->d_ops->free_hdr_to_disk(bp->b_addr, &hdr);\n\t*bpp = bp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "fdb == xfs_dir2_byte_to_db(args->geo, XFS_DIR2_FREE_OFFSET)"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_byte_to_db",
          "args": [
            "args->geo",
            "XFS_DIR2_FREE_OFFSET"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_byte_to_db",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "213-217",
          "snippet": "static inline xfs_dir2_db_t\nxfs_dir2_byte_to_db(struct xfs_da_geometry *geo, xfs_dir2_off_t by)\n{\n\treturn (xfs_dir2_db_t)(by >> geo->blklog);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dir2_db_t\nxfs_dir2_byte_to_db(struct xfs_da_geometry *geo, xfs_dir2_off_t by)\n{\n\treturn (xfs_dir2_db_t)(by >> geo->blklog);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_grow_inode",
          "args": [
            "args",
            "XFS_DIR2_FREE_SPACE",
            "&fdb"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_grow_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
          "lines": "575-614",
          "snippet": "int\nxfs_dir2_grow_inode(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\tspace,\t/* v2 dir's space XFS_DIR2_xxx_SPACE */\n\txfs_dir2_db_t\t\t*dbp)\t/* out: block number added */\n{\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\txfs_fileoff_t\t\tbno;\t/* directory offset of new block */\n\tint\t\t\tcount;\t/* count of filesystem blocks */\n\tint\t\t\terror;\n\n\ttrace_xfs_dir2_grow_inode(args, space);\n\n\t/*\n\t * Set lowest possible block in the space requested.\n\t */\n\tbno = XFS_B_TO_FSBT(mp, space * XFS_DIR2_SPACE_SIZE);\n\tcount = args->geo->fsbcount;\n\n\terror = xfs_da_grow_inode_int(args, &bno, count);\n\tif (error)\n\t\treturn error;\n\n\t*dbp = xfs_dir2_da_to_db(args->geo, (xfs_dablk_t)bno);\n\n\t/*\n\t * Update file's size if this is the data space and it grew.\n\t */\n\tif (space == XFS_DIR2_DATA_SPACE) {\n\t\txfs_fsize_t\tsize;\t\t/* directory file (data) size */\n\n\t\tsize = XFS_FSB_TO_B(mp, bno + count);\n\t\tif (size > dp->i_d.di_size) {\n\t\t\tdp->i_d.di_size = size;\n\t\t\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE);\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir2_grow_inode(\n\tstruct xfs_da_args\t*args,\n\tint\t\t\tspace,\t/* v2 dir's space XFS_DIR2_xxx_SPACE */\n\txfs_dir2_db_t\t\t*dbp)\t/* out: block number added */\n{\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\txfs_fileoff_t\t\tbno;\t/* directory offset of new block */\n\tint\t\t\tcount;\t/* count of filesystem blocks */\n\tint\t\t\terror;\n\n\ttrace_xfs_dir2_grow_inode(args, space);\n\n\t/*\n\t * Set lowest possible block in the space requested.\n\t */\n\tbno = XFS_B_TO_FSBT(mp, space * XFS_DIR2_SPACE_SIZE);\n\tcount = args->geo->fsbcount;\n\n\terror = xfs_da_grow_inode_int(args, &bno, count);\n\tif (error)\n\t\treturn error;\n\n\t*dbp = xfs_dir2_da_to_db(args->geo, (xfs_dablk_t)bno);\n\n\t/*\n\t * Update file's size if this is the data space and it grew.\n\t */\n\tif (space == XFS_DIR2_DATA_SPACE) {\n\t\txfs_fsize_t\tsize;\t\t/* directory file (data) size */\n\n\t\tsize = XFS_FSB_TO_B(mp, bno + count);\n\t\tif (size > dp->i_d.di_size) {\n\t\t\tdp->i_d.di_size = size;\n\t\t\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE);\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_dir2_leaf_to_node",
          "args": [
            "args"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int xfs_dir2_leafn_add(struct xfs_buf *bp, xfs_da_args_t *args,\n\t\t\t      int index);\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_leaf_to_node(\n\txfs_da_args_t\t\t*args,\t\t/* operation arguments */\n\tstruct xfs_buf\t\t*lbp)\t\t/* leaf buffer */\n{\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\terror;\t\t/* error return value */\n\tstruct xfs_buf\t\t*fbp;\t\t/* freespace buffer */\n\txfs_dir2_db_t\t\tfdb;\t\t/* freespace block number */\n\txfs_dir2_free_t\t\t*free;\t\t/* freespace structure */\n\t__be16\t\t\t*from;\t\t/* pointer to freespace entry */\n\tint\t\t\ti;\t\t/* leaf freespace index */\n\txfs_dir2_leaf_t\t\t*leaf;\t\t/* leaf structure */\n\txfs_dir2_leaf_tail_t\t*ltp;\t\t/* leaf tail structure */\n\tint\t\t\tn;\t\t/* count of live freespc ents */\n\txfs_dir2_data_off_t\toff;\t\t/* freespace entry value */\n\t__be16\t\t\t*to;\t\t/* pointer to freespace entry */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tstruct xfs_dir3_icfree_hdr freehdr;\n\n\ttrace_xfs_dir2_leaf_to_node(args);\n\n\tdp = args->dp;\n\ttp = args->trans;\n\t/*\n\t * Add a freespace block to the directory.\n\t */\n\tif ((error = xfs_dir2_grow_inode(args, XFS_DIR2_FREE_SPACE, &fdb))) {\n\t\treturn error;\n\t}\n\tASSERT(fdb == xfs_dir2_byte_to_db(args->geo, XFS_DIR2_FREE_OFFSET));\n\t/*\n\t * Get the buffer for the new freespace block.\n\t */\n\terror = xfs_dir3_free_get_buf(args, fdb, &fbp);\n\tif (error)\n\t\treturn error;\n\n\tfree = fbp->b_addr;\n\tdp->d_ops->free_hdr_from_disk(&freehdr, free);\n\tleaf = lbp->b_addr;\n\tltp = xfs_dir2_leaf_tail_p(args->geo, leaf);\n\tASSERT(be32_to_cpu(ltp->bestcount) <=\n\t\t\t\t(uint)dp->i_d.di_size / args->geo->blksize);\n\n\t/*\n\t * Copy freespace entries from the leaf block to the new block.\n\t * Count active entries.\n\t */\n\tfrom = xfs_dir2_leaf_bests_p(ltp);\n\tto = dp->d_ops->free_bests_p(free);\n\tfor (i = n = 0; i < be32_to_cpu(ltp->bestcount); i++, from++, to++) {\n\t\tif ((off = be16_to_cpu(*from)) != NULLDATAOFF)\n\t\t\tn++;\n\t\t*to = cpu_to_be16(off);\n\t}\n\n\t/*\n\t * Now initialize the freespace block header.\n\t */\n\tfreehdr.nused = n;\n\tfreehdr.nvalid = be32_to_cpu(ltp->bestcount);\n\n\tdp->d_ops->free_hdr_to_disk(fbp->b_addr, &freehdr);\n\txfs_dir2_free_log_bests(args, fbp, 0, freehdr.nvalid - 1);\n\txfs_dir2_free_log_header(args, fbp);\n\n\t/*\n\t * Converting the leaf to a leafnode is just a matter of changing the\n\t * magic number and the ops. Do the change directly to the buffer as\n\t * it's less work (and less code) than decoding the header to host\n\t * format and back again.\n\t */\n\tif (leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAF1_MAGIC))\n\t\tleaf->hdr.info.magic = cpu_to_be16(XFS_DIR2_LEAFN_MAGIC);\n\telse\n\t\tleaf->hdr.info.magic = cpu_to_be16(XFS_DIR3_LEAFN_MAGIC);\n\tlbp->b_ops = &xfs_dir3_leafn_buf_ops;\n\txfs_trans_buf_set_type(tp, lbp, XFS_BLFT_DIR_LEAFN_BUF);\n\txfs_dir3_leaf_log_header(args, lbp);\n\txfs_dir3_leaf_check(dp, lbp);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_dir2_free_log_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
    "lines": "263-277",
    "snippet": "static void\nxfs_dir2_free_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n#ifdef DEBUG\n\txfs_dir2_free_t\t\t*free;\t\t/* freespace structure */\n\n\tfree = bp->b_addr;\n\tASSERT(free->hdr.magic == cpu_to_be32(XFS_DIR2_FREE_MAGIC) ||\n\t       free->hdr.magic == cpu_to_be32(XFS_DIR3_FREE_MAGIC));\n#endif\n\txfs_trans_log_buf(args->trans, bp, 0,\n\t\t\t  args->dp->d_ops->free_hdr_size - 1);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "args->trans",
            "bp",
            "0",
            "args->dp->d_ops->free_hdr_size - 1"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "497-552",
          "snippet": "void\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "free->hdr.magic == cpu_to_be32(XFS_DIR2_FREE_MAGIC) ||\n\t       free->hdr.magic == cpu_to_be32(XFS_DIR3_FREE_MAGIC)"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR3_FREE_MAGIC"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_FREE_MAGIC"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_dir2_free_log_header(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp)\n{\n#ifdef DEBUG\n\txfs_dir2_free_t\t\t*free;\t\t/* freespace structure */\n\n\tfree = bp->b_addr;\n\tASSERT(free->hdr.magic == cpu_to_be32(XFS_DIR2_FREE_MAGIC) ||\n\t       free->hdr.magic == cpu_to_be32(XFS_DIR3_FREE_MAGIC));\n#endif\n\txfs_trans_log_buf(args->trans, bp, 0,\n\t\t\t  args->dp->d_ops->free_hdr_size - 1);\n}"
  },
  {
    "function_name": "xfs_dir2_free_log_bests",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
    "lines": "240-258",
    "snippet": "STATIC void\nxfs_dir2_free_log_bests(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\t\t/* first entry to log */\n\tint\t\t\tlast)\t\t/* last entry to log */\n{\n\txfs_dir2_free_t\t\t*free;\t\t/* freespace structure */\n\t__be16\t\t\t*bests;\n\n\tfree = bp->b_addr;\n\tbests = args->dp->d_ops->free_bests_p(free);\n\tASSERT(free->hdr.magic == cpu_to_be32(XFS_DIR2_FREE_MAGIC) ||\n\t       free->hdr.magic == cpu_to_be32(XFS_DIR3_FREE_MAGIC));\n\txfs_trans_log_buf(args->trans, bp,\n\t\t(uint)((char *)&bests[first] - (char *)free),\n\t\t(uint)((char *)&bests[last] - (char *)free +\n\t\t       sizeof(bests[0]) - 1));\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "args->trans",
            "bp",
            "(uint)((char *)&bests[first] - (char *)free)",
            "(uint)((char *)&bests[last] - (char *)free +\n\t\t       sizeof(bests[0]) - 1)"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "497-552",
          "snippet": "void\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(char *)&bests[last] - (char *)free +\n\t\t       sizeof(bests[0]) - 1"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(char *)&bests[first] - (char *)free"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "free->hdr.magic == cpu_to_be32(XFS_DIR2_FREE_MAGIC) ||\n\t       free->hdr.magic == cpu_to_be32(XFS_DIR3_FREE_MAGIC)"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR3_FREE_MAGIC"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_FREE_MAGIC"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "args->dp->d_ops->free_bests_p",
          "args": [
            "free"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_dir2_free_log_bests(\n\tstruct xfs_da_args\t*args,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\t\t/* first entry to log */\n\tint\t\t\tlast)\t\t/* last entry to log */\n{\n\txfs_dir2_free_t\t\t*free;\t\t/* freespace structure */\n\t__be16\t\t\t*bests;\n\n\tfree = bp->b_addr;\n\tbests = args->dp->d_ops->free_bests_p(free);\n\tASSERT(free->hdr.magic == cpu_to_be32(XFS_DIR2_FREE_MAGIC) ||\n\t       free->hdr.magic == cpu_to_be32(XFS_DIR3_FREE_MAGIC));\n\txfs_trans_log_buf(args->trans, bp,\n\t\t(uint)((char *)&bests[first] - (char *)free),\n\t\t(uint)((char *)&bests[last] - (char *)free +\n\t\t       sizeof(bests[0]) - 1));\n}"
  },
  {
    "function_name": "xfs_dir3_free_get_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
    "lines": "194-235",
    "snippet": "static int\nxfs_dir3_free_get_buf(\n\txfs_da_args_t\t\t*args,\n\txfs_dir2_db_t\t\tfbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_trans\t*tp = args->trans;\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\tstruct xfs_dir3_icfree_hdr hdr;\n\n\terror = xfs_da_get_buf(tp, dp, xfs_dir2_db_to_da(args->geo, fbno),\n\t\t\t\t   -1, &bp, XFS_DATA_FORK);\n\tif (error)\n\t\treturn error;\n\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DIR_FREE_BUF);\n\tbp->b_ops = &xfs_dir3_free_buf_ops;\n\n\t/*\n\t * Initialize the new block to be empty, and remember\n\t * its first slot as our empty slot.\n\t */\n\tmemset(bp->b_addr, 0, sizeof(struct xfs_dir3_free_hdr));\n\tmemset(&hdr, 0, sizeof(hdr));\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_dir3_free_hdr *hdr3 = bp->b_addr;\n\n\t\thdr.magic = XFS_DIR3_FREE_MAGIC;\n\n\t\thdr3->hdr.blkno = cpu_to_be64(bp->b_bn);\n\t\thdr3->hdr.owner = cpu_to_be64(dp->i_ino);\n\t\tuuid_copy(&hdr3->hdr.uuid, &mp->m_sb.sb_uuid);\n\t} else\n\t\thdr.magic = XFS_DIR2_FREE_MAGIC;\n\tdp->d_ops->free_hdr_to_disk(bp->b_addr, &hdr);\n\t*bpp = bp;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "const struct xfs_buf_ops xfs_dir3_free_buf_ops = {\n\t.verify_read = xfs_dir3_free_read_verify,\n\t.verify_write = xfs_dir3_free_write_verify,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dp->d_ops->free_hdr_to_disk",
          "args": [
            "bp->b_addr",
            "&hdr"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uuid_copy",
          "args": [
            "&hdr3->hdr.uuid",
            "&mp->m_sb.sb_uuid"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.h",
          "lines": "29-33",
          "snippet": "static inline void\nuuid_copy(uuid_t *dst, uuid_t *src)\n{\n\tmemcpy(dst, src, sizeof(uuid_t));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nuuid_copy(uuid_t *dst, uuid_t *src)\n{\n\tmemcpy(dst, src, sizeof(uuid_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "dp->i_ino"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "bp->b_bn"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&hdr",
            "0",
            "sizeof(hdr)"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bp->b_addr",
            "0",
            "sizeof(struct xfs_dir3_free_hdr)"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_buf_set_type",
          "args": [
            "tp",
            "bp",
            "XFS_BLFT_DIR_FREE_BUF"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_buf_set_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "730-746",
          "snippet": "void\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da_get_buf",
          "args": [
            "tp",
            "dp",
            "xfs_dir2_db_to_da(args->geo, fbno)",
            "-1",
            "&bp",
            "XFS_DATA_FORK"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_get_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "2529-2572",
          "snippet": "int\nxfs_da_get_buf(\n\tstruct xfs_trans\t*trans,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_buf_map\tmap;\n\tstruct xfs_buf_map\t*mapp;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\n\t*bpp = NULL;\n\tmapp = &map;\n\tnmap = 1;\n\terror = xfs_dabuf_map(dp, bno, mappedbno, whichfork,\n\t\t\t\t&mapp, &nmap);\n\tif (error) {\n\t\t/* mapping a hole is not an error, but we don't continue */\n\t\tif (error == -1)\n\t\t\terror = 0;\n\t\tgoto out_free;\n\t}\n\n\tbp = xfs_trans_get_buf_map(trans, dp->i_mount->m_ddev_targp,\n\t\t\t\t    mapp, nmap, 0);\n\terror = bp ? bp->b_error : -EIO;\n\tif (error) {\n\t\tif (bp)\n\t\t\txfs_trans_brelse(trans, bp);\n\t\tgoto out_free;\n\t}\n\n\t*bpp = bp;\n\nout_free:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_da_get_buf(\n\tstruct xfs_trans\t*trans,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_buf_map\tmap;\n\tstruct xfs_buf_map\t*mapp;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\n\t*bpp = NULL;\n\tmapp = &map;\n\tnmap = 1;\n\terror = xfs_dabuf_map(dp, bno, mappedbno, whichfork,\n\t\t\t\t&mapp, &nmap);\n\tif (error) {\n\t\t/* mapping a hole is not an error, but we don't continue */\n\t\tif (error == -1)\n\t\t\terror = 0;\n\t\tgoto out_free;\n\t}\n\n\tbp = xfs_trans_get_buf_map(trans, dp->i_mount->m_ddev_targp,\n\t\t\t\t    mapp, nmap, 0);\n\terror = bp ? bp->b_error : -EIO;\n\tif (error) {\n\t\tif (bp)\n\t\t\txfs_trans_brelse(trans, bp);\n\t\tgoto out_free;\n\t}\n\n\t*bpp = bp;\n\nout_free:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir2_db_to_da",
          "args": [
            "args->geo",
            "fbno"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_db_to_da",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.h",
          "lines": "259-263",
          "snippet": "static inline xfs_dablk_t\nxfs_dir2_db_to_da(struct xfs_da_geometry *geo, xfs_dir2_db_t db)\n{\n\treturn (xfs_dablk_t)(db << (geo->blklog - geo->fsblog));\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline xfs_dablk_t\nxfs_dir2_db_to_da(struct xfs_da_geometry *geo, xfs_dir2_db_t db)\n{\n\treturn (xfs_dablk_t)(db << (geo->blklog - geo->fsblog));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_dir3_free_buf_ops = {\n\t.verify_read = xfs_dir3_free_read_verify,\n\t.verify_write = xfs_dir3_free_write_verify,\n};\n\nstatic int\nxfs_dir3_free_get_buf(\n\txfs_da_args_t\t\t*args,\n\txfs_dir2_db_t\t\tfbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tstruct xfs_trans\t*tp = args->trans;\n\tstruct xfs_inode\t*dp = args->dp;\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\tstruct xfs_dir3_icfree_hdr hdr;\n\n\terror = xfs_da_get_buf(tp, dp, xfs_dir2_db_to_da(args->geo, fbno),\n\t\t\t\t   -1, &bp, XFS_DATA_FORK);\n\tif (error)\n\t\treturn error;\n\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_DIR_FREE_BUF);\n\tbp->b_ops = &xfs_dir3_free_buf_ops;\n\n\t/*\n\t * Initialize the new block to be empty, and remember\n\t * its first slot as our empty slot.\n\t */\n\tmemset(bp->b_addr, 0, sizeof(struct xfs_dir3_free_hdr));\n\tmemset(&hdr, 0, sizeof(hdr));\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_dir3_free_hdr *hdr3 = bp->b_addr;\n\n\t\thdr.magic = XFS_DIR3_FREE_MAGIC;\n\n\t\thdr3->hdr.blkno = cpu_to_be64(bp->b_bn);\n\t\thdr3->hdr.owner = cpu_to_be64(dp->i_ino);\n\t\tuuid_copy(&hdr3->hdr.uuid, &mp->m_sb.sb_uuid);\n\t} else\n\t\thdr.magic = XFS_DIR2_FREE_MAGIC;\n\tdp->d_ops->free_hdr_to_disk(bp->b_addr, &hdr);\n\t*bpp = bp;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_dir2_free_try_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
    "lines": "184-192",
    "snippet": "static int\nxfs_dir2_free_try_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tfbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\treturn __xfs_dir3_free_read(tp, dp, fbno, -2, bpp);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__xfs_dir3_free_read",
          "args": [
            "tp",
            "dp",
            "fbno",
            "-2",
            "bpp"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "__xfs_dir3_free_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
          "lines": "155-172",
          "snippet": "static int\n__xfs_dir3_free_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tfbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, fbno, mappedbno, bpp,\n\t\t\t\tXFS_DATA_FORK, &xfs_dir3_free_buf_ops);\n\n\t/* try read returns without an error or *bpp if it lands in a hole */\n\tif (!err && tp && *bpp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_DIR_FREE_BUF);\n\treturn err;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_dir3_free_buf_ops = {\n\t.verify_read = xfs_dir3_free_read_verify,\n\t.verify_write = xfs_dir3_free_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_dir3_free_buf_ops = {\n\t.verify_read = xfs_dir3_free_read_verify,\n\t.verify_write = xfs_dir3_free_write_verify,\n};\n\nstatic int\n__xfs_dir3_free_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tfbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, fbno, mappedbno, bpp,\n\t\t\t\tXFS_DATA_FORK, &xfs_dir3_free_buf_ops);\n\n\t/* try read returns without an error or *bpp if it lands in a hole */\n\tif (!err && tp && *bpp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_DIR_FREE_BUF);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int\nxfs_dir2_free_try_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tfbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\treturn __xfs_dir3_free_read(tp, dp, fbno, -2, bpp);\n}"
  },
  {
    "function_name": "xfs_dir2_free_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
    "lines": "174-182",
    "snippet": "int\nxfs_dir2_free_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tfbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\treturn __xfs_dir3_free_read(tp, dp, fbno, -1, bpp);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__xfs_dir3_free_read",
          "args": [
            "tp",
            "dp",
            "fbno",
            "-1",
            "bpp"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "__xfs_dir3_free_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
          "lines": "155-172",
          "snippet": "static int\n__xfs_dir3_free_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tfbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, fbno, mappedbno, bpp,\n\t\t\t\tXFS_DATA_FORK, &xfs_dir3_free_buf_ops);\n\n\t/* try read returns without an error or *bpp if it lands in a hole */\n\tif (!err && tp && *bpp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_DIR_FREE_BUF);\n\treturn err;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_dir3_free_buf_ops = {\n\t.verify_read = xfs_dir3_free_read_verify,\n\t.verify_write = xfs_dir3_free_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_dir3_free_buf_ops = {\n\t.verify_read = xfs_dir3_free_read_verify,\n\t.verify_write = xfs_dir3_free_write_verify,\n};\n\nstatic int\n__xfs_dir3_free_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tfbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, fbno, mappedbno, bpp,\n\t\t\t\tXFS_DATA_FORK, &xfs_dir3_free_buf_ops);\n\n\t/* try read returns without an error or *bpp if it lands in a hole */\n\tif (!err && tp && *bpp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_DIR_FREE_BUF);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir2_free_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tfbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\treturn __xfs_dir3_free_read(tp, dp, fbno, -1, bpp);\n}"
  },
  {
    "function_name": "__xfs_dir3_free_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
    "lines": "155-172",
    "snippet": "static int\n__xfs_dir3_free_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tfbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, fbno, mappedbno, bpp,\n\t\t\t\tXFS_DATA_FORK, &xfs_dir3_free_buf_ops);\n\n\t/* try read returns without an error or *bpp if it lands in a hole */\n\tif (!err && tp && *bpp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_DIR_FREE_BUF);\n\treturn err;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "const struct xfs_buf_ops xfs_dir3_free_buf_ops = {\n\t.verify_read = xfs_dir3_free_read_verify,\n\t.verify_write = xfs_dir3_free_write_verify,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_buf_set_type",
          "args": [
            "tp",
            "*bpp",
            "XFS_BLFT_DIR_FREE_BUF"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_buf_set_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "730-746",
          "snippet": "void\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_da_read_buf",
          "args": [
            "tp",
            "dp",
            "fbno",
            "mappedbno",
            "bpp",
            "XFS_DATA_FORK",
            "&xfs_dir3_free_buf_ops"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_da_read_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_da_btree.c",
          "lines": "2577-2621",
          "snippet": "int\nxfs_da_read_buf(\n\tstruct xfs_trans\t*trans,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhichfork,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_buf_map\tmap;\n\tstruct xfs_buf_map\t*mapp;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\n\t*bpp = NULL;\n\tmapp = &map;\n\tnmap = 1;\n\terror = xfs_dabuf_map(dp, bno, mappedbno, whichfork,\n\t\t\t\t&mapp, &nmap);\n\tif (error) {\n\t\t/* mapping a hole is not an error, but we don't continue */\n\t\tif (error == -1)\n\t\t\terror = 0;\n\t\tgoto out_free;\n\t}\n\n\terror = xfs_trans_read_buf_map(dp->i_mount, trans,\n\t\t\t\t\tdp->i_mount->m_ddev_targp,\n\t\t\t\t\tmapp, nmap, 0, &bp, ops);\n\tif (error)\n\t\tgoto out_free;\n\n\tif (whichfork == XFS_ATTR_FORK)\n\t\txfs_buf_set_ref(bp, XFS_ATTR_BTREE_REF);\n\telse\n\t\txfs_buf_set_ref(bp, XFS_DIR_BTREE_REF);\n\t*bpp = bp;\nout_free:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_da_read_buf(\n\tstruct xfs_trans\t*trans,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp,\n\tint\t\t\twhichfork,\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\n\tstruct xfs_buf_map\tmap;\n\tstruct xfs_buf_map\t*mapp;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\n\t*bpp = NULL;\n\tmapp = &map;\n\tnmap = 1;\n\terror = xfs_dabuf_map(dp, bno, mappedbno, whichfork,\n\t\t\t\t&mapp, &nmap);\n\tif (error) {\n\t\t/* mapping a hole is not an error, but we don't continue */\n\t\tif (error == -1)\n\t\t\terror = 0;\n\t\tgoto out_free;\n\t}\n\n\terror = xfs_trans_read_buf_map(dp->i_mount, trans,\n\t\t\t\t\tdp->i_mount->m_ddev_targp,\n\t\t\t\t\tmapp, nmap, 0, &bp, ops);\n\tif (error)\n\t\tgoto out_free;\n\n\tif (whichfork == XFS_ATTR_FORK)\n\t\txfs_buf_set_ref(bp, XFS_ATTR_BTREE_REF);\n\telse\n\t\txfs_buf_set_ref(bp, XFS_DIR_BTREE_REF);\n\t*bpp = bp;\nout_free:\n\tif (mapp != &map)\n\t\tkmem_free(mapp);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_dir3_free_buf_ops = {\n\t.verify_read = xfs_dir3_free_read_verify,\n\t.verify_write = xfs_dir3_free_write_verify,\n};\n\nstatic int\n__xfs_dir3_free_read(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*dp,\n\txfs_dablk_t\t\tfbno,\n\txfs_daddr_t\t\tmappedbno,\n\tstruct xfs_buf\t\t**bpp)\n{\n\tint\t\t\terr;\n\n\terr = xfs_da_read_buf(tp, dp, fbno, mappedbno, bpp,\n\t\t\t\tXFS_DATA_FORK, &xfs_dir3_free_buf_ops);\n\n\t/* try read returns without an error or *bpp if it lands in a hole */\n\tif (!err && tp && *bpp)\n\t\txfs_trans_buf_set_type(tp, *bpp, XFS_BLFT_DIR_FREE_BUF);\n\treturn err;\n}"
  },
  {
    "function_name": "xfs_dir3_free_write_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
    "lines": "126-147",
    "snippet": "static void\nxfs_dir3_free_write_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\tstruct xfs_dir3_blk_hdr\t*hdr3 = bp->b_addr;\n\n\tif (!xfs_dir3_free_verify(bp)) {\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\t\txfs_verifier_error(bp);\n\t\treturn;\n\t}\n\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn;\n\n\tif (bip)\n\t\thdr3->lsn = cpu_to_be64(bip->bli_item.li_lsn);\n\n\txfs_buf_update_cksum(bp, XFS_DIR3_FREE_CRC_OFF);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_update_cksum",
          "args": [
            "bp",
            "XFS_DIR3_FREE_CRC_OFF"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_update_cksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "374-379",
          "snippet": "static inline void\nxfs_buf_update_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\txfs_update_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t cksum_offset);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void\nxfs_buf_update_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\txfs_update_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t cksum_offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "bip->bli_item.li_lsn"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_verifier_error",
          "args": [
            "bp"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_verifier_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_error.c",
          "lines": "161-180",
          "snippet": "void\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioerror",
          "args": [
            "bp",
            "-EFSCORRUPTED"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir3_free_verify",
          "args": [
            "bp"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_free_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
          "lines": "84-108",
          "snippet": "static bool\nxfs_dir3_free_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_dir2_free_hdr *hdr = bp->b_addr;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_dir3_blk_hdr *hdr3 = bp->b_addr;\n\n\t\tif (hdr3->magic != cpu_to_be32(XFS_DIR3_FREE_MAGIC))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&hdr3->uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (be64_to_cpu(hdr3->blkno) != bp->b_bn)\n\t\t\treturn false;\n\t} else {\n\t\tif (hdr->magic != cpu_to_be32(XFS_DIR2_FREE_MAGIC))\n\t\t\treturn false;\n\t}\n\n\t/* XXX: should bounds check the xfs_dir3_icfree_hdr here */\n\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic bool\nxfs_dir3_free_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_dir2_free_hdr *hdr = bp->b_addr;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_dir3_blk_hdr *hdr3 = bp->b_addr;\n\n\t\tif (hdr3->magic != cpu_to_be32(XFS_DIR3_FREE_MAGIC))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&hdr3->uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (be64_to_cpu(hdr3->blkno) != bp->b_bn)\n\t\t\treturn false;\n\t} else {\n\t\tif (hdr->magic != cpu_to_be32(XFS_DIR2_FREE_MAGIC))\n\t\t\treturn false;\n\t}\n\n\t/* XXX: should bounds check the xfs_dir3_icfree_hdr here */\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_dir3_free_write_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\tstruct xfs_dir3_blk_hdr\t*hdr3 = bp->b_addr;\n\n\tif (!xfs_dir3_free_verify(bp)) {\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\t\txfs_verifier_error(bp);\n\t\treturn;\n\t}\n\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn;\n\n\tif (bip)\n\t\thdr3->lsn = cpu_to_be64(bip->bli_item.li_lsn);\n\n\txfs_buf_update_cksum(bp, XFS_DIR3_FREE_CRC_OFF);\n}"
  },
  {
    "function_name": "xfs_dir3_free_read_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
    "lines": "110-124",
    "snippet": "static void\nxfs_dir3_free_read_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb) &&\n\t    !xfs_buf_verify_cksum(bp, XFS_DIR3_FREE_CRC_OFF))\n\t\txfs_buf_ioerror(bp, -EFSBADCRC);\n\telse if (!xfs_dir3_free_verify(bp))\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\n\tif (bp->b_error)\n\t\txfs_verifier_error(bp);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_verifier_error",
          "args": [
            "bp"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_verifier_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_error.c",
          "lines": "161-180",
          "snippet": "void\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioerror",
          "args": [
            "bp",
            "-EFSCORRUPTED"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir3_free_verify",
          "args": [
            "bp"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_free_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
          "lines": "84-108",
          "snippet": "static bool\nxfs_dir3_free_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_dir2_free_hdr *hdr = bp->b_addr;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_dir3_blk_hdr *hdr3 = bp->b_addr;\n\n\t\tif (hdr3->magic != cpu_to_be32(XFS_DIR3_FREE_MAGIC))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&hdr3->uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (be64_to_cpu(hdr3->blkno) != bp->b_bn)\n\t\t\treturn false;\n\t} else {\n\t\tif (hdr->magic != cpu_to_be32(XFS_DIR2_FREE_MAGIC))\n\t\t\treturn false;\n\t}\n\n\t/* XXX: should bounds check the xfs_dir3_icfree_hdr here */\n\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic bool\nxfs_dir3_free_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_dir2_free_hdr *hdr = bp->b_addr;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_dir3_blk_hdr *hdr3 = bp->b_addr;\n\n\t\tif (hdr3->magic != cpu_to_be32(XFS_DIR3_FREE_MAGIC))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&hdr3->uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (be64_to_cpu(hdr3->blkno) != bp->b_bn)\n\t\t\treturn false;\n\t} else {\n\t\tif (hdr->magic != cpu_to_be32(XFS_DIR2_FREE_MAGIC))\n\t\t\treturn false;\n\t}\n\n\t/* XXX: should bounds check the xfs_dir3_icfree_hdr here */\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_verify_cksum",
          "args": [
            "bp",
            "XFS_DIR3_FREE_CRC_OFF"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_verify_cksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "367-372",
          "snippet": "static inline int\nxfs_buf_verify_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\treturn xfs_verify_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t\tcksum_offset);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline int\nxfs_buf_verify_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\treturn xfs_verify_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t\tcksum_offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_dir3_free_read_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb) &&\n\t    !xfs_buf_verify_cksum(bp, XFS_DIR3_FREE_CRC_OFF))\n\t\txfs_buf_ioerror(bp, -EFSBADCRC);\n\telse if (!xfs_dir3_free_verify(bp))\n\t\txfs_buf_ioerror(bp, -EFSCORRUPTED);\n\n\tif (bp->b_error)\n\t\txfs_verifier_error(bp);\n}"
  },
  {
    "function_name": "xfs_dir3_free_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
    "lines": "84-108",
    "snippet": "static bool\nxfs_dir3_free_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_dir2_free_hdr *hdr = bp->b_addr;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_dir3_blk_hdr *hdr3 = bp->b_addr;\n\n\t\tif (hdr3->magic != cpu_to_be32(XFS_DIR3_FREE_MAGIC))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&hdr3->uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (be64_to_cpu(hdr3->blkno) != bp->b_bn)\n\t\t\treturn false;\n\t} else {\n\t\tif (hdr->magic != cpu_to_be32(XFS_DIR2_FREE_MAGIC))\n\t\t\treturn false;\n\t}\n\n\t/* XXX: should bounds check the xfs_dir3_icfree_hdr here */\n\n\treturn true;\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR2_FREE_MAGIC"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "hdr3->blkno"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uuid_equal",
          "args": [
            "&hdr3->uuid",
            "&mp->m_sb.sb_uuid"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_DIR3_FREE_MAGIC"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic bool\nxfs_dir3_free_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_dir2_free_hdr *hdr = bp->b_addr;\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tstruct xfs_dir3_blk_hdr *hdr3 = bp->b_addr;\n\n\t\tif (hdr3->magic != cpu_to_be32(XFS_DIR3_FREE_MAGIC))\n\t\t\treturn false;\n\t\tif (!uuid_equal(&hdr3->uuid, &mp->m_sb.sb_uuid))\n\t\t\treturn false;\n\t\tif (be64_to_cpu(hdr3->blkno) != bp->b_bn)\n\t\t\treturn false;\n\t} else {\n\t\tif (hdr->magic != cpu_to_be32(XFS_DIR2_FREE_MAGIC))\n\t\t\treturn false;\n\t}\n\n\t/* XXX: should bounds check the xfs_dir3_icfree_hdr here */\n\n\treturn true;\n}"
  },
  {
    "function_name": "xfs_dir3_leafn_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_node.c",
    "lines": "61-79",
    "snippet": "static bool\nxfs_dir3_leafn_check(\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\n\tif (leafhdr.magic == XFS_DIR3_LEAFN_MAGIC) {\n\t\tstruct xfs_dir3_leaf_hdr *leaf3 = bp->b_addr;\n\t\tif (be64_to_cpu(leaf3->info.blkno) != bp->b_bn)\n\t\t\treturn false;\n\t} else if (leafhdr.magic != XFS_DIR2_LEAFN_MAGIC)\n\t\treturn false;\n\n\treturn xfs_dir3_leaf_check_int(dp->i_mount, dp, &leafhdr, leaf);\n}",
    "includes": [
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_dir2_priv.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_dir3_leaf_check_int",
          "args": [
            "dp->i_mount",
            "dp",
            "&leafhdr",
            "leaf"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir3_leaf_check_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_leaf.c",
          "lines": "81-137",
          "snippet": "bool\nxfs_dir3_leaf_check_int(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_dir3_icleaf_hdr *hdr,\n\tstruct xfs_dir2_leaf\t*leaf)\n{\n\tstruct xfs_dir2_leaf_entry *ents;\n\txfs_dir2_leaf_tail_t\t*ltp;\n\tint\t\t\tstale;\n\tint\t\t\ti;\n\tconst struct xfs_dir_ops *ops;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\tstruct xfs_da_geometry\t*geo = mp->m_dir_geo;\n\n\t/*\n\t * we can be passed a null dp here from a verifier, so we need to go the\n\t * hard way to get them.\n\t */\n\tops = xfs_dir_get_ops(mp, dp);\n\n\tif (!hdr) {\n\t\tops->leaf_hdr_from_disk(&leafhdr, leaf);\n\t\thdr = &leafhdr;\n\t}\n\n\tents = ops->leaf_ents_p(leaf);\n\tltp = xfs_dir2_leaf_tail_p(geo, leaf);\n\n\t/*\n\t * XXX (dgc): This value is not restrictive enough.\n\t * Should factor in the size of the bests table as well.\n\t * We can deduce a value for that from di_size.\n\t */\n\tif (hdr->count > ops->leaf_max_ents(geo))\n\t\treturn false;\n\n\t/* Leaves and bests don't overlap in leaf format. */\n\tif ((hdr->magic == XFS_DIR2_LEAF1_MAGIC ||\n\t     hdr->magic == XFS_DIR3_LEAF1_MAGIC) &&\n\t    (char *)&ents[hdr->count] > (char *)xfs_dir2_leaf_bests_p(ltp))\n\t\treturn false;\n\n\t/* Check hash value order, count stale entries.  */\n\tfor (i = stale = 0; i < hdr->count; i++) {\n\t\tif (i + 1 < hdr->count) {\n\t\t\tif (be32_to_cpu(ents[i].hashval) >\n\t\t\t\t\tbe32_to_cpu(ents[i + 1].hashval))\n\t\t\t\treturn false;\n\t\t}\n\t\tif (ents[i].address == cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\tstale++;\n\t}\n\tif (hdr->stale != stale)\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nbool\nxfs_dir3_leaf_check_int(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_dir3_icleaf_hdr *hdr,\n\tstruct xfs_dir2_leaf\t*leaf)\n{\n\tstruct xfs_dir2_leaf_entry *ents;\n\txfs_dir2_leaf_tail_t\t*ltp;\n\tint\t\t\tstale;\n\tint\t\t\ti;\n\tconst struct xfs_dir_ops *ops;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\tstruct xfs_da_geometry\t*geo = mp->m_dir_geo;\n\n\t/*\n\t * we can be passed a null dp here from a verifier, so we need to go the\n\t * hard way to get them.\n\t */\n\tops = xfs_dir_get_ops(mp, dp);\n\n\tif (!hdr) {\n\t\tops->leaf_hdr_from_disk(&leafhdr, leaf);\n\t\thdr = &leafhdr;\n\t}\n\n\tents = ops->leaf_ents_p(leaf);\n\tltp = xfs_dir2_leaf_tail_p(geo, leaf);\n\n\t/*\n\t * XXX (dgc): This value is not restrictive enough.\n\t * Should factor in the size of the bests table as well.\n\t * We can deduce a value for that from di_size.\n\t */\n\tif (hdr->count > ops->leaf_max_ents(geo))\n\t\treturn false;\n\n\t/* Leaves and bests don't overlap in leaf format. */\n\tif ((hdr->magic == XFS_DIR2_LEAF1_MAGIC ||\n\t     hdr->magic == XFS_DIR3_LEAF1_MAGIC) &&\n\t    (char *)&ents[hdr->count] > (char *)xfs_dir2_leaf_bests_p(ltp))\n\t\treturn false;\n\n\t/* Check hash value order, count stale entries.  */\n\tfor (i = stale = 0; i < hdr->count; i++) {\n\t\tif (i + 1 < hdr->count) {\n\t\t\tif (be32_to_cpu(ents[i].hashval) >\n\t\t\t\t\tbe32_to_cpu(ents[i + 1].hashval))\n\t\t\t\treturn false;\n\t\t}\n\t\tif (ents[i].address == cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\n\t\t\tstale++;\n\t}\n\tif (hdr->stale != stale)\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "leaf3->info.blkno"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dp->d_ops->leaf_hdr_from_disk",
          "args": [
            "&leafhdr",
            "leaf"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic bool\nxfs_dir3_leafn_check(\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dir2_leaf\t*leaf = bp->b_addr;\n\tstruct xfs_dir3_icleaf_hdr leafhdr;\n\n\tdp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);\n\n\tif (leafhdr.magic == XFS_DIR3_LEAFN_MAGIC) {\n\t\tstruct xfs_dir3_leaf_hdr *leaf3 = bp->b_addr;\n\t\tif (be64_to_cpu(leaf3->info.blkno) != bp->b_bn)\n\t\t\treturn false;\n\t} else if (leafhdr.magic != XFS_DIR2_LEAFN_MAGIC)\n\t\treturn false;\n\n\treturn xfs_dir3_leaf_check_int(dp->i_mount, dp, &leafhdr, leaf);\n}"
  }
]