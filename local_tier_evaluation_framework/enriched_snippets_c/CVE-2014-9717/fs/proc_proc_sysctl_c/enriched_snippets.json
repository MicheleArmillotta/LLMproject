[
  {
    "function_name": "proc_sys_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "1572-1582",
    "snippet": "int __init proc_sys_init(void)\n{\n\tstruct proc_dir_entry *proc_sys_root;\n\n\tproc_sys_root = proc_mkdir(\"sys\", NULL);\n\tproc_sys_root->proc_iops = &proc_sys_dir_operations;\n\tproc_sys_root->proc_fops = &proc_sys_dir_file_operations;\n\tproc_sys_root->nlink = 0;\n\n\treturn sysctl_init();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations proc_sys_dir_file_operations;",
      "static const struct inode_operations proc_sys_dir_operations;",
      "static const struct file_operations proc_sys_dir_file_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= proc_sys_readdir,\n\t.llseek\t\t= generic_file_llseek,\n};",
      "static const struct inode_operations proc_sys_dir_operations = {\n\t.lookup\t\t= proc_sys_lookup,\n\t.permission\t= proc_sys_permission,\n\t.setattr\t= proc_sys_setattr,\n\t.getattr\t= proc_sys_getattr,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysctl_init",
          "args": [],
          "line": 1581
        },
        "resolved": true,
        "details": {
          "function_name": "coda_sysctl_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/sysctl.c",
          "lines": "66-68",
          "snippet": "void coda_sysctl_init(void)\n{\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include <linux/sysctl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include <linux/sysctl.h>\n\nvoid coda_sysctl_init(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_mkdir",
          "args": [
            "\"sys\"",
            "NULL"
          ],
          "line": 1576
        },
        "resolved": true,
        "details": {
          "function_name": "proc_mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "451-455",
          "snippet": "struct proc_dir_entry *proc_mkdir(const char *name,\n\t\tstruct proc_dir_entry *parent)\n{\n\treturn proc_mkdir_data(name, 0, parent, NULL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstruct proc_dir_entry *proc_mkdir(const char *name,\n\t\tstruct proc_dir_entry *parent)\n{\n\treturn proc_mkdir_data(name, 0, parent, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic const struct file_operations proc_sys_dir_file_operations;\nstatic const struct inode_operations proc_sys_dir_operations;\nstatic const struct file_operations proc_sys_dir_file_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= proc_sys_readdir,\n\t.llseek\t\t= generic_file_llseek,\n};\nstatic const struct inode_operations proc_sys_dir_operations = {\n\t.lookup\t\t= proc_sys_lookup,\n\t.permission\t= proc_sys_permission,\n\t.setattr\t= proc_sys_setattr,\n\t.getattr\t= proc_sys_getattr,\n};\n\nint __init proc_sys_init(void)\n{\n\tstruct proc_dir_entry *proc_sys_root;\n\n\tproc_sys_root = proc_mkdir(\"sys\", NULL);\n\tproc_sys_root->proc_iops = &proc_sys_dir_operations;\n\tproc_sys_root->proc_fops = &proc_sys_dir_file_operations;\n\tproc_sys_root->nlink = 0;\n\n\treturn sysctl_init();\n}"
  },
  {
    "function_name": "retire_sysctl_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "1567-1570",
    "snippet": "void retire_sysctl_set(struct ctl_table_set *set)\n{\n\tWARN_ON(!RB_EMPTY_ROOT(&set->dir.root));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!RB_EMPTY_ROOT(&set->dir.root)"
          ],
          "line": 1569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_ROOT",
          "args": [
            "&set->dir.root"
          ],
          "line": 1569
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nvoid retire_sysctl_set(struct ctl_table_set *set)\n{\n\tWARN_ON(!RB_EMPTY_ROOT(&set->dir.root));\n}"
  },
  {
    "function_name": "setup_sysctl_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "1558-1565",
    "snippet": "void setup_sysctl_set(struct ctl_table_set *set,\n\tstruct ctl_table_root *root,\n\tint (*is_seen)(struct ctl_table_set *))\n{\n\tmemset(set, 0, sizeof(*set));\n\tset->is_seen = is_seen;\n\tinit_header(&set->dir.header, root, set, NULL, root_table);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ctl_table root_table[] = {\n\t{\n\t\t.procname = \"\",\n\t\t.mode = S_IFDIR|S_IRUGO|S_IXUGO,\n\t},\n\t{ }\n};",
      "static void drop_sysctl_table(struct ctl_table_header *header);",
      "static void put_links(struct ctl_table_header *header);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_header",
          "args": [
            "&set->dir.header",
            "root",
            "set",
            "NULL",
            "root_table"
          ],
          "line": 1564
        },
        "resolved": true,
        "details": {
          "function_name": "init_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "157-176",
          "snippet": "static void init_header(struct ctl_table_header *head,\n\tstruct ctl_table_root *root, struct ctl_table_set *set,\n\tstruct ctl_node *node, struct ctl_table *table)\n{\n\thead->ctl_table = table;\n\thead->ctl_table_arg = table;\n\thead->used = 0;\n\thead->count = 1;\n\thead->nreg = 1;\n\thead->unregistering = NULL;\n\thead->root = root;\n\thead->set = set;\n\thead->parent = NULL;\n\thead->node = node;\n\tif (node) {\n\t\tstruct ctl_table *entry;\n\t\tfor (entry = table; entry->procname; entry++, node++)\n\t\t\tnode->header = head;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static int insert_links(struct ctl_table_header *head);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic int insert_links(struct ctl_table_header *head);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic void init_header(struct ctl_table_header *head,\n\tstruct ctl_table_root *root, struct ctl_table_set *set,\n\tstruct ctl_node *node, struct ctl_table *table)\n{\n\thead->ctl_table = table;\n\thead->ctl_table_arg = table;\n\thead->used = 0;\n\thead->count = 1;\n\thead->nreg = 1;\n\thead->unregistering = NULL;\n\thead->root = root;\n\thead->set = set;\n\thead->parent = NULL;\n\thead->node = node;\n\tif (node) {\n\t\tstruct ctl_table *entry;\n\t\tfor (entry = table; entry->procname; entry++, node++)\n\t\t\tnode->header = head;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "set",
            "0",
            "sizeof(*set)"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic struct ctl_table root_table[] = {\n\t{\n\t\t.procname = \"\",\n\t\t.mode = S_IFDIR|S_IRUGO|S_IXUGO,\n\t},\n\t{ }\n};\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic void put_links(struct ctl_table_header *header);\n\nvoid setup_sysctl_set(struct ctl_table_set *set,\n\tstruct ctl_table_root *root,\n\tint (*is_seen)(struct ctl_table_set *))\n{\n\tmemset(set, 0, sizeof(*set));\n\tset->is_seen = is_seen;\n\tinit_header(&set->dir.header, root, set, NULL, root_table);\n}"
  },
  {
    "function_name": "unregister_sysctl_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "1528-1555",
    "snippet": "void unregister_sysctl_table(struct ctl_table_header * header)\n{\n\tint nr_subheaders;\n\tmight_sleep();\n\n\tif (header == NULL)\n\t\treturn;\n\n\tnr_subheaders = count_subheaders(header->ctl_table_arg);\n\tif (unlikely(nr_subheaders > 1)) {\n\t\tstruct ctl_table_header **subheaders;\n\t\tint i;\n\n\t\tsubheaders = (struct ctl_table_header **)(header + 1);\n\t\tfor (i = nr_subheaders -1; i >= 0; i--) {\n\t\t\tstruct ctl_table_header *subh = subheaders[i];\n\t\t\tstruct ctl_table *table = subh->ctl_table_arg;\n\t\t\tunregister_sysctl_table(subh);\n\t\t\tkfree(table);\n\t\t}\n\t\tkfree(header);\n\t\treturn;\n\t}\n\n\tspin_lock(&sysctl_lock);\n\tdrop_sysctl_table(header);\n\tspin_unlock(&sysctl_lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(sysctl_lock);",
      "static void drop_sysctl_table(struct ctl_table_header *header);",
      "static void put_links(struct ctl_table_header *header);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sysctl_lock"
          ],
          "line": 1554
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_sysctl_table",
          "args": [
            "header"
          ],
          "line": 1553
        },
        "resolved": true,
        "details": {
          "function_name": "drop_sysctl_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "1505-1519",
          "snippet": "static void drop_sysctl_table(struct ctl_table_header *header)\n{\n\tstruct ctl_dir *parent = header->parent;\n\n\tif (--header->nreg)\n\t\treturn;\n\n\tput_links(header);\n\tstart_unregistering(header);\n\tif (!--header->count)\n\t\tkfree_rcu(header, rcu);\n\n\tif (parent)\n\t\tdrop_sysctl_table(&parent->header);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic void drop_sysctl_table(struct ctl_table_header *header)\n{\n\tstruct ctl_dir *parent = header->parent;\n\n\tif (--header->nreg)\n\t\treturn;\n\n\tput_links(header);\n\tstart_unregistering(header);\n\tif (!--header->count)\n\t\tkfree_rcu(header, rcu);\n\n\tif (parent)\n\t\tdrop_sysctl_table(&parent->header);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sysctl_lock"
          ],
          "line": 1552
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "header"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "table"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_sysctl_table",
          "args": [
            "subh"
          ],
          "line": 1545
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_sysctl_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "1528-1555",
          "snippet": "void unregister_sysctl_table(struct ctl_table_header * header)\n{\n\tint nr_subheaders;\n\tmight_sleep();\n\n\tif (header == NULL)\n\t\treturn;\n\n\tnr_subheaders = count_subheaders(header->ctl_table_arg);\n\tif (unlikely(nr_subheaders > 1)) {\n\t\tstruct ctl_table_header **subheaders;\n\t\tint i;\n\n\t\tsubheaders = (struct ctl_table_header **)(header + 1);\n\t\tfor (i = nr_subheaders -1; i >= 0; i--) {\n\t\t\tstruct ctl_table_header *subh = subheaders[i];\n\t\t\tstruct ctl_table *table = subh->ctl_table_arg;\n\t\t\tunregister_sysctl_table(subh);\n\t\t\tkfree(table);\n\t\t}\n\t\tkfree(header);\n\t\treturn;\n\t}\n\n\tspin_lock(&sysctl_lock);\n\tdrop_sysctl_table(header);\n\tspin_unlock(&sysctl_lock);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "nr_subheaders > 1"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_subheaders",
          "args": [
            "header->ctl_table_arg"
          ],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "count_subheaders",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "1271-1288",
          "snippet": "static int count_subheaders(struct ctl_table *table)\n{\n\tint has_files = 0;\n\tint nr_subheaders = 0;\n\tstruct ctl_table *entry;\n\n\t/* special case: no directory and empty directory */\n\tif (!table || !table->procname)\n\t\treturn 1;\n\n\tfor (entry = table; entry->procname; entry++) {\n\t\tif (entry->child)\n\t\t\tnr_subheaders += count_subheaders(entry->child);\n\t\telse\n\t\t\thas_files = 1;\n\t}\n\treturn nr_subheaders + has_files;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic int count_subheaders(struct ctl_table *table)\n{\n\tint has_files = 0;\n\tint nr_subheaders = 0;\n\tstruct ctl_table *entry;\n\n\t/* special case: no directory and empty directory */\n\tif (!table || !table->procname)\n\t\treturn 1;\n\n\tfor (entry = table; entry->procname; entry++) {\n\t\tif (entry->child)\n\t\t\tnr_subheaders += count_subheaders(entry->child);\n\t\telse\n\t\t\thas_files = 1;\n\t}\n\treturn nr_subheaders + has_files;\n}"
        }
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(sysctl_lock);\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic void put_links(struct ctl_table_header *header);\n\nvoid unregister_sysctl_table(struct ctl_table_header * header)\n{\n\tint nr_subheaders;\n\tmight_sleep();\n\n\tif (header == NULL)\n\t\treturn;\n\n\tnr_subheaders = count_subheaders(header->ctl_table_arg);\n\tif (unlikely(nr_subheaders > 1)) {\n\t\tstruct ctl_table_header **subheaders;\n\t\tint i;\n\n\t\tsubheaders = (struct ctl_table_header **)(header + 1);\n\t\tfor (i = nr_subheaders -1; i >= 0; i--) {\n\t\t\tstruct ctl_table_header *subh = subheaders[i];\n\t\t\tstruct ctl_table *table = subh->ctl_table_arg;\n\t\t\tunregister_sysctl_table(subh);\n\t\t\tkfree(table);\n\t\t}\n\t\tkfree(header);\n\t\treturn;\n\t}\n\n\tspin_lock(&sysctl_lock);\n\tdrop_sysctl_table(header);\n\tspin_unlock(&sysctl_lock);\n}"
  },
  {
    "function_name": "drop_sysctl_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "1505-1519",
    "snippet": "static void drop_sysctl_table(struct ctl_table_header *header)\n{\n\tstruct ctl_dir *parent = header->parent;\n\n\tif (--header->nreg)\n\t\treturn;\n\n\tput_links(header);\n\tstart_unregistering(header);\n\tif (!--header->count)\n\t\tkfree_rcu(header, rcu);\n\n\tif (parent)\n\t\tdrop_sysctl_table(&parent->header);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void drop_sysctl_table(struct ctl_table_header *header);",
      "static void put_links(struct ctl_table_header *header);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "drop_sysctl_table",
          "args": [
            "&parent->header"
          ],
          "line": 1518
        },
        "resolved": true,
        "details": {
          "function_name": "drop_sysctl_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "1505-1519",
          "snippet": "static void drop_sysctl_table(struct ctl_table_header *header)\n{\n\tstruct ctl_dir *parent = header->parent;\n\n\tif (--header->nreg)\n\t\treturn;\n\n\tput_links(header);\n\tstart_unregistering(header);\n\tif (!--header->count)\n\t\tkfree_rcu(header, rcu);\n\n\tif (parent)\n\t\tdrop_sysctl_table(&parent->header);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "kfree_rcu",
          "args": [
            "header",
            "rcu"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "start_unregistering",
          "args": [
            "header"
          ],
          "line": 1513
        },
        "resolved": true,
        "details": {
          "function_name": "start_unregistering",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "228-250",
          "snippet": "static void start_unregistering(struct ctl_table_header *p)\n{\n\t/*\n\t * if p->used is 0, nobody will ever touch that entry again;\n\t * we'll eliminate all paths to it before dropping sysctl_lock\n\t */\n\tif (unlikely(p->used)) {\n\t\tstruct completion wait;\n\t\tinit_completion(&wait);\n\t\tp->unregistering = &wait;\n\t\tspin_unlock(&sysctl_lock);\n\t\twait_for_completion(&wait);\n\t\tspin_lock(&sysctl_lock);\n\t} else {\n\t\t/* anything non-NULL; we'll never dereference it */\n\t\tp->unregistering = ERR_PTR(-EINVAL);\n\t}\n\t/*\n\t * do not remove from the list until nobody holds it; walking the\n\t * list in do_sysctl() relies on that.\n\t */\n\terase_header(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(sysctl_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(sysctl_lock);\n\nstatic void start_unregistering(struct ctl_table_header *p)\n{\n\t/*\n\t * if p->used is 0, nobody will ever touch that entry again;\n\t * we'll eliminate all paths to it before dropping sysctl_lock\n\t */\n\tif (unlikely(p->used)) {\n\t\tstruct completion wait;\n\t\tinit_completion(&wait);\n\t\tp->unregistering = &wait;\n\t\tspin_unlock(&sysctl_lock);\n\t\twait_for_completion(&wait);\n\t\tspin_lock(&sysctl_lock);\n\t} else {\n\t\t/* anything non-NULL; we'll never dereference it */\n\t\tp->unregistering = ERR_PTR(-EINVAL);\n\t}\n\t/*\n\t * do not remove from the list until nobody holds it; walking the\n\t * list in do_sysctl() relies on that.\n\t */\n\terase_header(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_links",
          "args": [
            "header"
          ],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "put_links",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "1471-1503",
          "snippet": "static void put_links(struct ctl_table_header *header)\n{\n\tstruct ctl_table_set *root_set = &sysctl_table_root.default_set;\n\tstruct ctl_table_root *root = header->root;\n\tstruct ctl_dir *parent = header->parent;\n\tstruct ctl_dir *core_parent;\n\tstruct ctl_table *entry;\n\n\tif (header->set == root_set)\n\t\treturn;\n\n\tcore_parent = xlate_dir(root_set, parent);\n\tif (IS_ERR(core_parent))\n\t\treturn;\n\n\tfor (entry = header->ctl_table; entry->procname; entry++) {\n\t\tstruct ctl_table_header *link_head;\n\t\tstruct ctl_table *link;\n\t\tconst char *name = entry->procname;\n\n\t\tlink = find_entry(&link_head, core_parent, name, strlen(name));\n\t\tif (link &&\n\t\t    ((S_ISDIR(link->mode) && S_ISDIR(entry->mode)) ||\n\t\t     (S_ISLNK(link->mode) && (link->data == root)))) {\n\t\t\tdrop_sysctl_table(link_head);\n\t\t}\n\t\telse {\n\t\t\tpr_err(\"sysctl link missing during unregister: \");\n\t\t\tsysctl_print_dir(parent);\n\t\t\tpr_cont(\"/%s\\n\", name);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ctl_table_root sysctl_table_root = {\n\t.default_set.dir.header = {\n\t\t{{.count = 1,\n\t\t  .nreg = 1,\n\t\t  .ctl_table = root_table }},\n\t\t.ctl_table_arg = root_table,\n\t\t.root = &sysctl_table_root,\n\t\t.set = &sysctl_table_root.default_set,\n\t},\n};",
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic struct ctl_table_root sysctl_table_root = {\n\t.default_set.dir.header = {\n\t\t{{.count = 1,\n\t\t  .nreg = 1,\n\t\t  .ctl_table = root_table }},\n\t\t.ctl_table_arg = root_table,\n\t\t.root = &sysctl_table_root,\n\t\t.set = &sysctl_table_root.default_set,\n\t},\n};\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic void put_links(struct ctl_table_header *header)\n{\n\tstruct ctl_table_set *root_set = &sysctl_table_root.default_set;\n\tstruct ctl_table_root *root = header->root;\n\tstruct ctl_dir *parent = header->parent;\n\tstruct ctl_dir *core_parent;\n\tstruct ctl_table *entry;\n\n\tif (header->set == root_set)\n\t\treturn;\n\n\tcore_parent = xlate_dir(root_set, parent);\n\tif (IS_ERR(core_parent))\n\t\treturn;\n\n\tfor (entry = header->ctl_table; entry->procname; entry++) {\n\t\tstruct ctl_table_header *link_head;\n\t\tstruct ctl_table *link;\n\t\tconst char *name = entry->procname;\n\n\t\tlink = find_entry(&link_head, core_parent, name, strlen(name));\n\t\tif (link &&\n\t\t    ((S_ISDIR(link->mode) && S_ISDIR(entry->mode)) ||\n\t\t     (S_ISLNK(link->mode) && (link->data == root)))) {\n\t\t\tdrop_sysctl_table(link_head);\n\t\t}\n\t\telse {\n\t\t\tpr_err(\"sysctl link missing during unregister: \");\n\t\t\tsysctl_print_dir(parent);\n\t\t\tpr_cont(\"/%s\\n\", name);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic void drop_sysctl_table(struct ctl_table_header *header)\n{\n\tstruct ctl_dir *parent = header->parent;\n\n\tif (--header->nreg)\n\t\treturn;\n\n\tput_links(header);\n\tstart_unregistering(header);\n\tif (!--header->count)\n\t\tkfree_rcu(header, rcu);\n\n\tif (parent)\n\t\tdrop_sysctl_table(&parent->header);\n}"
  },
  {
    "function_name": "put_links",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "1471-1503",
    "snippet": "static void put_links(struct ctl_table_header *header)\n{\n\tstruct ctl_table_set *root_set = &sysctl_table_root.default_set;\n\tstruct ctl_table_root *root = header->root;\n\tstruct ctl_dir *parent = header->parent;\n\tstruct ctl_dir *core_parent;\n\tstruct ctl_table *entry;\n\n\tif (header->set == root_set)\n\t\treturn;\n\n\tcore_parent = xlate_dir(root_set, parent);\n\tif (IS_ERR(core_parent))\n\t\treturn;\n\n\tfor (entry = header->ctl_table; entry->procname; entry++) {\n\t\tstruct ctl_table_header *link_head;\n\t\tstruct ctl_table *link;\n\t\tconst char *name = entry->procname;\n\n\t\tlink = find_entry(&link_head, core_parent, name, strlen(name));\n\t\tif (link &&\n\t\t    ((S_ISDIR(link->mode) && S_ISDIR(entry->mode)) ||\n\t\t     (S_ISLNK(link->mode) && (link->data == root)))) {\n\t\t\tdrop_sysctl_table(link_head);\n\t\t}\n\t\telse {\n\t\t\tpr_err(\"sysctl link missing during unregister: \");\n\t\t\tsysctl_print_dir(parent);\n\t\t\tpr_cont(\"/%s\\n\", name);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ctl_table_root sysctl_table_root = {\n\t.default_set.dir.header = {\n\t\t{{.count = 1,\n\t\t  .nreg = 1,\n\t\t  .ctl_table = root_table }},\n\t\t.ctl_table_arg = root_table,\n\t\t.root = &sysctl_table_root,\n\t\t.set = &sysctl_table_root.default_set,\n\t},\n};",
      "static void drop_sysctl_table(struct ctl_table_header *header);",
      "static void put_links(struct ctl_table_header *header);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"/%s\\n\"",
            "name"
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysctl_print_dir",
          "args": [
            "parent"
          ],
          "line": 1499
        },
        "resolved": true,
        "details": {
          "function_name": "sysctl_print_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "57-62",
          "snippet": "static void sysctl_print_dir(struct ctl_dir *dir)\n{\n\tif (dir->header.parent)\n\t\tsysctl_print_dir(dir->header.parent);\n\tpr_cont(\"%s/\", dir->header.ctl_table[0].procname);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic void sysctl_print_dir(struct ctl_dir *dir)\n{\n\tif (dir->header.parent)\n\t\tsysctl_print_dir(dir->header.parent);\n\tpr_cont(\"%s/\", dir->header.ctl_table[0].procname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"sysctl link missing during unregister: \""
          ],
          "line": 1498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drop_sysctl_table",
          "args": [
            "link_head"
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "drop_sysctl_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "1505-1519",
          "snippet": "static void drop_sysctl_table(struct ctl_table_header *header)\n{\n\tstruct ctl_dir *parent = header->parent;\n\n\tif (--header->nreg)\n\t\treturn;\n\n\tput_links(header);\n\tstart_unregistering(header);\n\tif (!--header->count)\n\t\tkfree_rcu(header, rcu);\n\n\tif (parent)\n\t\tdrop_sysctl_table(&parent->header);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic void drop_sysctl_table(struct ctl_table_header *header)\n{\n\tstruct ctl_dir *parent = header->parent;\n\n\tif (--header->nreg)\n\t\treturn;\n\n\tput_links(header);\n\tstart_unregistering(header);\n\tif (!--header->count)\n\t\tkfree_rcu(header, rcu);\n\n\tif (parent)\n\t\tdrop_sysctl_table(&parent->header);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "link->mode"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "entry->mode"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "link->mode"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_entry",
          "args": [
            "&link_head",
            "core_parent",
            "name",
            "strlen(name)"
          ],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "80-109",
          "snippet": "static struct ctl_table *find_entry(struct ctl_table_header **phead,\n\tstruct ctl_dir *dir, const char *name, int namelen)\n{\n\tstruct ctl_table_header *head;\n\tstruct ctl_table *entry;\n\tstruct rb_node *node = dir->root.rb_node;\n\n\twhile (node)\n\t{\n\t\tstruct ctl_node *ctl_node;\n\t\tconst char *procname;\n\t\tint cmp;\n\n\t\tctl_node = rb_entry(node, struct ctl_node, node);\n\t\thead = ctl_node->header;\n\t\tentry = &head->ctl_table[ctl_node - head->node];\n\t\tprocname = entry->procname;\n\n\t\tcmp = namecmp(name, namelen, procname, strlen(procname));\n\t\tif (cmp < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (cmp > 0)\n\t\t\tnode = node->rb_right;\n\t\telse {\n\t\t\t*phead = head;\n\t\t\treturn entry;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static int insert_links(struct ctl_table_header *head);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic int insert_links(struct ctl_table_header *head);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic struct ctl_table *find_entry(struct ctl_table_header **phead,\n\tstruct ctl_dir *dir, const char *name, int namelen)\n{\n\tstruct ctl_table_header *head;\n\tstruct ctl_table *entry;\n\tstruct rb_node *node = dir->root.rb_node;\n\n\twhile (node)\n\t{\n\t\tstruct ctl_node *ctl_node;\n\t\tconst char *procname;\n\t\tint cmp;\n\n\t\tctl_node = rb_entry(node, struct ctl_node, node);\n\t\thead = ctl_node->header;\n\t\tentry = &head->ctl_table[ctl_node - head->node];\n\t\tprocname = entry->procname;\n\n\t\tcmp = namecmp(name, namelen, procname, strlen(procname));\n\t\tif (cmp < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (cmp > 0)\n\t\t\tnode = node->rb_right;\n\t\telse {\n\t\t\t*phead = head;\n\t\t\treturn entry;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "core_parent"
          ],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlate_dir",
          "args": [
            "root_set",
            "parent"
          ],
          "line": 1482
        },
        "resolved": true,
        "details": {
          "function_name": "xlate_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "927-938",
          "snippet": "static struct ctl_dir *xlate_dir(struct ctl_table_set *set, struct ctl_dir *dir)\n{\n\tstruct ctl_dir *parent;\n\tconst char *procname;\n\tif (!dir->header.parent)\n\t\treturn &set->dir;\n\tparent = xlate_dir(set, dir->header.parent);\n\tif (IS_ERR(parent))\n\t\treturn parent;\n\tprocname = dir->header.ctl_table[0].procname;\n\treturn find_subdir(parent, procname, strlen(procname));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic struct ctl_dir *xlate_dir(struct ctl_table_set *set, struct ctl_dir *dir)\n{\n\tstruct ctl_dir *parent;\n\tconst char *procname;\n\tif (!dir->header.parent)\n\t\treturn &set->dir;\n\tparent = xlate_dir(set, dir->header.parent);\n\tif (IS_ERR(parent))\n\t\treturn parent;\n\tprocname = dir->header.ctl_table[0].procname;\n\treturn find_subdir(parent, procname, strlen(procname));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic struct ctl_table_root sysctl_table_root = {\n\t.default_set.dir.header = {\n\t\t{{.count = 1,\n\t\t  .nreg = 1,\n\t\t  .ctl_table = root_table }},\n\t\t.ctl_table_arg = root_table,\n\t\t.root = &sysctl_table_root,\n\t\t.set = &sysctl_table_root.default_set,\n\t},\n};\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic void put_links(struct ctl_table_header *header)\n{\n\tstruct ctl_table_set *root_set = &sysctl_table_root.default_set;\n\tstruct ctl_table_root *root = header->root;\n\tstruct ctl_dir *parent = header->parent;\n\tstruct ctl_dir *core_parent;\n\tstruct ctl_table *entry;\n\n\tif (header->set == root_set)\n\t\treturn;\n\n\tcore_parent = xlate_dir(root_set, parent);\n\tif (IS_ERR(core_parent))\n\t\treturn;\n\n\tfor (entry = header->ctl_table; entry->procname; entry++) {\n\t\tstruct ctl_table_header *link_head;\n\t\tstruct ctl_table *link;\n\t\tconst char *name = entry->procname;\n\n\t\tlink = find_entry(&link_head, core_parent, name, strlen(name));\n\t\tif (link &&\n\t\t    ((S_ISDIR(link->mode) && S_ISDIR(entry->mode)) ||\n\t\t     (S_ISLNK(link->mode) && (link->data == root)))) {\n\t\t\tdrop_sysctl_table(link_head);\n\t\t}\n\t\telse {\n\t\t\tpr_err(\"sysctl link missing during unregister: \");\n\t\t\tsysctl_print_dir(parent);\n\t\t\tpr_cont(\"/%s\\n\", name);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "register_sysctl_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "1463-1468",
    "snippet": "struct ctl_table_header *register_sysctl_table(struct ctl_table *table)\n{\n\tstatic const struct ctl_path null_path[] = { {} };\n\n\treturn register_sysctl_paths(null_path, table);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_sysctl_paths",
          "args": [
            "null_path",
            "table"
          ],
          "line": 1467
        },
        "resolved": true,
        "details": {
          "function_name": "register_sysctl_paths",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "1446-1451",
          "snippet": "struct ctl_table_header *register_sysctl_paths(const struct ctl_path *path,\n\t\t\t\t\t\tstruct ctl_table *table)\n{\n\treturn __register_sysctl_paths(&sysctl_table_root.default_set,\n\t\t\t\t\tpath, table);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ctl_table_root sysctl_table_root = {\n\t.default_set.dir.header = {\n\t\t{{.count = 1,\n\t\t  .nreg = 1,\n\t\t  .ctl_table = root_table }},\n\t\t.ctl_table_arg = root_table,\n\t\t.root = &sysctl_table_root,\n\t\t.set = &sysctl_table_root.default_set,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic struct ctl_table_root sysctl_table_root = {\n\t.default_set.dir.header = {\n\t\t{{.count = 1,\n\t\t  .nreg = 1,\n\t\t  .ctl_table = root_table }},\n\t\t.ctl_table_arg = root_table,\n\t\t.root = &sysctl_table_root,\n\t\t.set = &sysctl_table_root.default_set,\n\t},\n};\n\nstruct ctl_table_header *register_sysctl_paths(const struct ctl_path *path,\n\t\t\t\t\t\tstruct ctl_table *table)\n{\n\treturn __register_sysctl_paths(&sysctl_table_root.default_set,\n\t\t\t\t\tpath, table);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstruct ctl_table_header *register_sysctl_table(struct ctl_table *table)\n{\n\tstatic const struct ctl_path null_path[] = { {} };\n\n\treturn register_sysctl_paths(null_path, table);\n}"
  },
  {
    "function_name": "register_sysctl_paths",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "1446-1451",
    "snippet": "struct ctl_table_header *register_sysctl_paths(const struct ctl_path *path,\n\t\t\t\t\t\tstruct ctl_table *table)\n{\n\treturn __register_sysctl_paths(&sysctl_table_root.default_set,\n\t\t\t\t\tpath, table);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ctl_table_root sysctl_table_root = {\n\t.default_set.dir.header = {\n\t\t{{.count = 1,\n\t\t  .nreg = 1,\n\t\t  .ctl_table = root_table }},\n\t\t.ctl_table_arg = root_table,\n\t\t.root = &sysctl_table_root,\n\t\t.set = &sysctl_table_root.default_set,\n\t},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__register_sysctl_paths",
          "args": [
            "&sysctl_table_root.default_set",
            "path",
            "table"
          ],
          "line": 1449
        },
        "resolved": true,
        "details": {
          "function_name": "__register_sysctl_paths",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "1375-1434",
          "snippet": "struct ctl_table_header *__register_sysctl_paths(\n\tstruct ctl_table_set *set,\n\tconst struct ctl_path *path, struct ctl_table *table)\n{\n\tstruct ctl_table *ctl_table_arg = table;\n\tint nr_subheaders = count_subheaders(table);\n\tstruct ctl_table_header *header = NULL, **subheaders, **subheader;\n\tconst struct ctl_path *component;\n\tchar *new_path, *pos;\n\n\tpos = new_path = kmalloc(PATH_MAX, GFP_KERNEL);\n\tif (!new_path)\n\t\treturn NULL;\n\n\tpos[0] = '\\0';\n\tfor (component = path; component->procname; component++) {\n\t\tpos = append_path(new_path, pos, component->procname);\n\t\tif (!pos)\n\t\t\tgoto out;\n\t}\n\twhile (table->procname && table->child && !table[1].procname) {\n\t\tpos = append_path(new_path, pos, table->procname);\n\t\tif (!pos)\n\t\t\tgoto out;\n\t\ttable = table->child;\n\t}\n\tif (nr_subheaders == 1) {\n\t\theader = __register_sysctl_table(set, new_path, table);\n\t\tif (header)\n\t\t\theader->ctl_table_arg = ctl_table_arg;\n\t} else {\n\t\theader = kzalloc(sizeof(*header) +\n\t\t\t\t sizeof(*subheaders)*nr_subheaders, GFP_KERNEL);\n\t\tif (!header)\n\t\t\tgoto out;\n\n\t\tsubheaders = (struct ctl_table_header **) (header + 1);\n\t\tsubheader = subheaders;\n\t\theader->ctl_table_arg = ctl_table_arg;\n\n\t\tif (register_leaf_sysctl_tables(new_path, pos, &subheader,\n\t\t\t\t\t\tset, table))\n\t\t\tgoto err_register_leaves;\n\t}\n\nout:\n\tkfree(new_path);\n\treturn header;\n\nerr_register_leaves:\n\twhile (subheader > subheaders) {\n\t\tstruct ctl_table_header *subh = *(--subheader);\n\t\tstruct ctl_table *table = subh->ctl_table_arg;\n\t\tunregister_sysctl_table(subh);\n\t\tkfree(table);\n\t}\n\tkfree(header);\n\theader = NULL;\n\tgoto out;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic void put_links(struct ctl_table_header *header);\n\nstruct ctl_table_header *__register_sysctl_paths(\n\tstruct ctl_table_set *set,\n\tconst struct ctl_path *path, struct ctl_table *table)\n{\n\tstruct ctl_table *ctl_table_arg = table;\n\tint nr_subheaders = count_subheaders(table);\n\tstruct ctl_table_header *header = NULL, **subheaders, **subheader;\n\tconst struct ctl_path *component;\n\tchar *new_path, *pos;\n\n\tpos = new_path = kmalloc(PATH_MAX, GFP_KERNEL);\n\tif (!new_path)\n\t\treturn NULL;\n\n\tpos[0] = '\\0';\n\tfor (component = path; component->procname; component++) {\n\t\tpos = append_path(new_path, pos, component->procname);\n\t\tif (!pos)\n\t\t\tgoto out;\n\t}\n\twhile (table->procname && table->child && !table[1].procname) {\n\t\tpos = append_path(new_path, pos, table->procname);\n\t\tif (!pos)\n\t\t\tgoto out;\n\t\ttable = table->child;\n\t}\n\tif (nr_subheaders == 1) {\n\t\theader = __register_sysctl_table(set, new_path, table);\n\t\tif (header)\n\t\t\theader->ctl_table_arg = ctl_table_arg;\n\t} else {\n\t\theader = kzalloc(sizeof(*header) +\n\t\t\t\t sizeof(*subheaders)*nr_subheaders, GFP_KERNEL);\n\t\tif (!header)\n\t\t\tgoto out;\n\n\t\tsubheaders = (struct ctl_table_header **) (header + 1);\n\t\tsubheader = subheaders;\n\t\theader->ctl_table_arg = ctl_table_arg;\n\n\t\tif (register_leaf_sysctl_tables(new_path, pos, &subheader,\n\t\t\t\t\t\tset, table))\n\t\t\tgoto err_register_leaves;\n\t}\n\nout:\n\tkfree(new_path);\n\treturn header;\n\nerr_register_leaves:\n\twhile (subheader > subheaders) {\n\t\tstruct ctl_table_header *subh = *(--subheader);\n\t\tstruct ctl_table *table = subh->ctl_table_arg;\n\t\tunregister_sysctl_table(subh);\n\t\tkfree(table);\n\t}\n\tkfree(header);\n\theader = NULL;\n\tgoto out;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic struct ctl_table_root sysctl_table_root = {\n\t.default_set.dir.header = {\n\t\t{{.count = 1,\n\t\t  .nreg = 1,\n\t\t  .ctl_table = root_table }},\n\t\t.ctl_table_arg = root_table,\n\t\t.root = &sysctl_table_root,\n\t\t.set = &sysctl_table_root.default_set,\n\t},\n};\n\nstruct ctl_table_header *register_sysctl_paths(const struct ctl_path *path,\n\t\t\t\t\t\tstruct ctl_table *table)\n{\n\treturn __register_sysctl_paths(&sysctl_table_root.default_set,\n\t\t\t\t\tpath, table);\n}"
  },
  {
    "function_name": "__register_sysctl_paths",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "1375-1434",
    "snippet": "struct ctl_table_header *__register_sysctl_paths(\n\tstruct ctl_table_set *set,\n\tconst struct ctl_path *path, struct ctl_table *table)\n{\n\tstruct ctl_table *ctl_table_arg = table;\n\tint nr_subheaders = count_subheaders(table);\n\tstruct ctl_table_header *header = NULL, **subheaders, **subheader;\n\tconst struct ctl_path *component;\n\tchar *new_path, *pos;\n\n\tpos = new_path = kmalloc(PATH_MAX, GFP_KERNEL);\n\tif (!new_path)\n\t\treturn NULL;\n\n\tpos[0] = '\\0';\n\tfor (component = path; component->procname; component++) {\n\t\tpos = append_path(new_path, pos, component->procname);\n\t\tif (!pos)\n\t\t\tgoto out;\n\t}\n\twhile (table->procname && table->child && !table[1].procname) {\n\t\tpos = append_path(new_path, pos, table->procname);\n\t\tif (!pos)\n\t\t\tgoto out;\n\t\ttable = table->child;\n\t}\n\tif (nr_subheaders == 1) {\n\t\theader = __register_sysctl_table(set, new_path, table);\n\t\tif (header)\n\t\t\theader->ctl_table_arg = ctl_table_arg;\n\t} else {\n\t\theader = kzalloc(sizeof(*header) +\n\t\t\t\t sizeof(*subheaders)*nr_subheaders, GFP_KERNEL);\n\t\tif (!header)\n\t\t\tgoto out;\n\n\t\tsubheaders = (struct ctl_table_header **) (header + 1);\n\t\tsubheader = subheaders;\n\t\theader->ctl_table_arg = ctl_table_arg;\n\n\t\tif (register_leaf_sysctl_tables(new_path, pos, &subheader,\n\t\t\t\t\t\tset, table))\n\t\t\tgoto err_register_leaves;\n\t}\n\nout:\n\tkfree(new_path);\n\treturn header;\n\nerr_register_leaves:\n\twhile (subheader > subheaders) {\n\t\tstruct ctl_table_header *subh = *(--subheader);\n\t\tstruct ctl_table *table = subh->ctl_table_arg;\n\t\tunregister_sysctl_table(subh);\n\t\tkfree(table);\n\t}\n\tkfree(header);\n\theader = NULL;\n\tgoto out;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void drop_sysctl_table(struct ctl_table_header *header);",
      "static void put_links(struct ctl_table_header *header);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "header"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "table"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_sysctl_table",
          "args": [
            "subh"
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_sysctl_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "1528-1555",
          "snippet": "void unregister_sysctl_table(struct ctl_table_header * header)\n{\n\tint nr_subheaders;\n\tmight_sleep();\n\n\tif (header == NULL)\n\t\treturn;\n\n\tnr_subheaders = count_subheaders(header->ctl_table_arg);\n\tif (unlikely(nr_subheaders > 1)) {\n\t\tstruct ctl_table_header **subheaders;\n\t\tint i;\n\n\t\tsubheaders = (struct ctl_table_header **)(header + 1);\n\t\tfor (i = nr_subheaders -1; i >= 0; i--) {\n\t\t\tstruct ctl_table_header *subh = subheaders[i];\n\t\t\tstruct ctl_table *table = subh->ctl_table_arg;\n\t\t\tunregister_sysctl_table(subh);\n\t\t\tkfree(table);\n\t\t}\n\t\tkfree(header);\n\t\treturn;\n\t}\n\n\tspin_lock(&sysctl_lock);\n\tdrop_sysctl_table(header);\n\tspin_unlock(&sysctl_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(sysctl_lock);",
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(sysctl_lock);\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic void put_links(struct ctl_table_header *header);\n\nvoid unregister_sysctl_table(struct ctl_table_header * header)\n{\n\tint nr_subheaders;\n\tmight_sleep();\n\n\tif (header == NULL)\n\t\treturn;\n\n\tnr_subheaders = count_subheaders(header->ctl_table_arg);\n\tif (unlikely(nr_subheaders > 1)) {\n\t\tstruct ctl_table_header **subheaders;\n\t\tint i;\n\n\t\tsubheaders = (struct ctl_table_header **)(header + 1);\n\t\tfor (i = nr_subheaders -1; i >= 0; i--) {\n\t\t\tstruct ctl_table_header *subh = subheaders[i];\n\t\t\tstruct ctl_table *table = subh->ctl_table_arg;\n\t\t\tunregister_sysctl_table(subh);\n\t\t\tkfree(table);\n\t\t}\n\t\tkfree(header);\n\t\treturn;\n\t}\n\n\tspin_lock(&sysctl_lock);\n\tdrop_sysctl_table(header);\n\tspin_unlock(&sysctl_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "new_path"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_leaf_sysctl_tables",
          "args": [
            "new_path",
            "pos",
            "&subheader",
            "set",
            "table"
          ],
          "line": 1415
        },
        "resolved": true,
        "details": {
          "function_name": "register_leaf_sysctl_tables",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "1290-1362",
          "snippet": "static int register_leaf_sysctl_tables(const char *path, char *pos,\n\tstruct ctl_table_header ***subheader, struct ctl_table_set *set,\n\tstruct ctl_table *table)\n{\n\tstruct ctl_table *ctl_table_arg = NULL;\n\tstruct ctl_table *entry, *files;\n\tint nr_files = 0;\n\tint nr_dirs = 0;\n\tint err = -ENOMEM;\n\n\tfor (entry = table; entry->procname; entry++) {\n\t\tif (entry->child)\n\t\t\tnr_dirs++;\n\t\telse\n\t\t\tnr_files++;\n\t}\n\n\tfiles = table;\n\t/* If there are mixed files and directories we need a new table */\n\tif (nr_dirs && nr_files) {\n\t\tstruct ctl_table *new;\n\t\tfiles = kzalloc(sizeof(struct ctl_table) * (nr_files + 1),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!files)\n\t\t\tgoto out;\n\n\t\tctl_table_arg = files;\n\t\tfor (new = files, entry = table; entry->procname; entry++) {\n\t\t\tif (entry->child)\n\t\t\t\tcontinue;\n\t\t\t*new = *entry;\n\t\t\tnew++;\n\t\t}\n\t}\n\n\t/* Register everything except a directory full of subdirectories */\n\tif (nr_files || !nr_dirs) {\n\t\tstruct ctl_table_header *header;\n\t\theader = __register_sysctl_table(set, path, files);\n\t\tif (!header) {\n\t\t\tkfree(ctl_table_arg);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Remember if we need to free the file table */\n\t\theader->ctl_table_arg = ctl_table_arg;\n\t\t**subheader = header;\n\t\t(*subheader)++;\n\t}\n\n\t/* Recurse into the subdirectories. */\n\tfor (entry = table; entry->procname; entry++) {\n\t\tchar *child_pos;\n\n\t\tif (!entry->child)\n\t\t\tcontinue;\n\n\t\terr = -ENAMETOOLONG;\n\t\tchild_pos = append_path(path, pos, entry->procname);\n\t\tif (!child_pos)\n\t\t\tgoto out;\n\n\t\terr = register_leaf_sysctl_tables(path, child_pos, subheader,\n\t\t\t\t\t\t  set, entry->child);\n\t\tpos[0] = '\\0';\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\terr = 0;\nout:\n\t/* On failure our caller will unregister all registered subheaders */\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic int register_leaf_sysctl_tables(const char *path, char *pos,\n\tstruct ctl_table_header ***subheader, struct ctl_table_set *set,\n\tstruct ctl_table *table)\n{\n\tstruct ctl_table *ctl_table_arg = NULL;\n\tstruct ctl_table *entry, *files;\n\tint nr_files = 0;\n\tint nr_dirs = 0;\n\tint err = -ENOMEM;\n\n\tfor (entry = table; entry->procname; entry++) {\n\t\tif (entry->child)\n\t\t\tnr_dirs++;\n\t\telse\n\t\t\tnr_files++;\n\t}\n\n\tfiles = table;\n\t/* If there are mixed files and directories we need a new table */\n\tif (nr_dirs && nr_files) {\n\t\tstruct ctl_table *new;\n\t\tfiles = kzalloc(sizeof(struct ctl_table) * (nr_files + 1),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!files)\n\t\t\tgoto out;\n\n\t\tctl_table_arg = files;\n\t\tfor (new = files, entry = table; entry->procname; entry++) {\n\t\t\tif (entry->child)\n\t\t\t\tcontinue;\n\t\t\t*new = *entry;\n\t\t\tnew++;\n\t\t}\n\t}\n\n\t/* Register everything except a directory full of subdirectories */\n\tif (nr_files || !nr_dirs) {\n\t\tstruct ctl_table_header *header;\n\t\theader = __register_sysctl_table(set, path, files);\n\t\tif (!header) {\n\t\t\tkfree(ctl_table_arg);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Remember if we need to free the file table */\n\t\theader->ctl_table_arg = ctl_table_arg;\n\t\t**subheader = header;\n\t\t(*subheader)++;\n\t}\n\n\t/* Recurse into the subdirectories. */\n\tfor (entry = table; entry->procname; entry++) {\n\t\tchar *child_pos;\n\n\t\tif (!entry->child)\n\t\t\tcontinue;\n\n\t\terr = -ENAMETOOLONG;\n\t\tchild_pos = append_path(path, pos, entry->procname);\n\t\tif (!child_pos)\n\t\t\tgoto out;\n\n\t\terr = register_leaf_sysctl_tables(path, child_pos, subheader,\n\t\t\t\t\t\t  set, entry->child);\n\t\tpos[0] = '\\0';\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\terr = 0;\nout:\n\t/* On failure our caller will unregister all registered subheaders */\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*header) +\n\t\t\t\t sizeof(*subheaders)*nr_subheaders",
            "GFP_KERNEL"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__register_sysctl_table",
          "args": [
            "set",
            "new_path",
            "table"
          ],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "__register_sysctl_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "1174-1239",
          "snippet": "struct ctl_table_header *__register_sysctl_table(\n\tstruct ctl_table_set *set,\n\tconst char *path, struct ctl_table *table)\n{\n\tstruct ctl_table_root *root = set->dir.header.root;\n\tstruct ctl_table_header *header;\n\tconst char *name, *nextname;\n\tstruct ctl_dir *dir;\n\tstruct ctl_table *entry;\n\tstruct ctl_node *node;\n\tint nr_entries = 0;\n\n\tfor (entry = table; entry->procname; entry++)\n\t\tnr_entries++;\n\n\theader = kzalloc(sizeof(struct ctl_table_header) +\n\t\t\t sizeof(struct ctl_node)*nr_entries, GFP_KERNEL);\n\tif (!header)\n\t\treturn NULL;\n\n\tnode = (struct ctl_node *)(header + 1);\n\tinit_header(header, root, set, node, table);\n\tif (sysctl_check_table(path, table))\n\t\tgoto fail;\n\n\tspin_lock(&sysctl_lock);\n\tdir = &set->dir;\n\t/* Reference moved down the diretory tree get_subdir */\n\tdir->header.nreg++;\n\tspin_unlock(&sysctl_lock);\n\n\t/* Find the directory for the ctl_table */\n\tfor (name = path; name; name = nextname) {\n\t\tint namelen;\n\t\tnextname = strchr(name, '/');\n\t\tif (nextname) {\n\t\t\tnamelen = nextname - name;\n\t\t\tnextname++;\n\t\t} else {\n\t\t\tnamelen = strlen(name);\n\t\t}\n\t\tif (namelen == 0)\n\t\t\tcontinue;\n\n\t\tdir = get_subdir(dir, name, namelen);\n\t\tif (IS_ERR(dir))\n\t\t\tgoto fail;\n\t}\n\n\tspin_lock(&sysctl_lock);\n\tif (insert_header(dir, header))\n\t\tgoto fail_put_dir_locked;\n\n\tdrop_sysctl_table(&dir->header);\n\tspin_unlock(&sysctl_lock);\n\n\treturn header;\n\nfail_put_dir_locked:\n\tdrop_sysctl_table(&dir->header);\n\tspin_unlock(&sysctl_lock);\nfail:\n\tkfree(header);\n\tdump_stack();\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(sysctl_lock);",
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(sysctl_lock);\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic void put_links(struct ctl_table_header *header);\n\nstruct ctl_table_header *__register_sysctl_table(\n\tstruct ctl_table_set *set,\n\tconst char *path, struct ctl_table *table)\n{\n\tstruct ctl_table_root *root = set->dir.header.root;\n\tstruct ctl_table_header *header;\n\tconst char *name, *nextname;\n\tstruct ctl_dir *dir;\n\tstruct ctl_table *entry;\n\tstruct ctl_node *node;\n\tint nr_entries = 0;\n\n\tfor (entry = table; entry->procname; entry++)\n\t\tnr_entries++;\n\n\theader = kzalloc(sizeof(struct ctl_table_header) +\n\t\t\t sizeof(struct ctl_node)*nr_entries, GFP_KERNEL);\n\tif (!header)\n\t\treturn NULL;\n\n\tnode = (struct ctl_node *)(header + 1);\n\tinit_header(header, root, set, node, table);\n\tif (sysctl_check_table(path, table))\n\t\tgoto fail;\n\n\tspin_lock(&sysctl_lock);\n\tdir = &set->dir;\n\t/* Reference moved down the diretory tree get_subdir */\n\tdir->header.nreg++;\n\tspin_unlock(&sysctl_lock);\n\n\t/* Find the directory for the ctl_table */\n\tfor (name = path; name; name = nextname) {\n\t\tint namelen;\n\t\tnextname = strchr(name, '/');\n\t\tif (nextname) {\n\t\t\tnamelen = nextname - name;\n\t\t\tnextname++;\n\t\t} else {\n\t\t\tnamelen = strlen(name);\n\t\t}\n\t\tif (namelen == 0)\n\t\t\tcontinue;\n\n\t\tdir = get_subdir(dir, name, namelen);\n\t\tif (IS_ERR(dir))\n\t\t\tgoto fail;\n\t}\n\n\tspin_lock(&sysctl_lock);\n\tif (insert_header(dir, header))\n\t\tgoto fail_put_dir_locked;\n\n\tdrop_sysctl_table(&dir->header);\n\tspin_unlock(&sysctl_lock);\n\n\treturn header;\n\nfail_put_dir_locked:\n\tdrop_sysctl_table(&dir->header);\n\tspin_unlock(&sysctl_lock);\nfail:\n\tkfree(header);\n\tdump_stack();\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "append_path",
          "args": [
            "new_path",
            "pos",
            "table->procname"
          ],
          "line": 1396
        },
        "resolved": true,
        "details": {
          "function_name": "append_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "1258-1269",
          "snippet": "static char *append_path(const char *path, char *pos, const char *name)\n{\n\tint namelen;\n\tnamelen = strlen(name);\n\tif (((pos - path) + namelen + 2) >= PATH_MAX)\n\t\treturn NULL;\n\tmemcpy(pos, name, namelen);\n\tpos[namelen] = '/';\n\tpos[namelen + 1] = '\\0';\n\tpos += namelen + 1;\n\treturn pos;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic char *append_path(const char *path, char *pos, const char *name)\n{\n\tint namelen;\n\tnamelen = strlen(name);\n\tif (((pos - path) + namelen + 2) >= PATH_MAX)\n\t\treturn NULL;\n\tmemcpy(pos, name, namelen);\n\tpos[namelen] = '/';\n\tpos[namelen + 1] = '\\0';\n\tpos += namelen + 1;\n\treturn pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "PATH_MAX",
            "GFP_KERNEL"
          ],
          "line": 1385
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "count_subheaders",
          "args": [
            "table"
          ],
          "line": 1380
        },
        "resolved": true,
        "details": {
          "function_name": "count_subheaders",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "1271-1288",
          "snippet": "static int count_subheaders(struct ctl_table *table)\n{\n\tint has_files = 0;\n\tint nr_subheaders = 0;\n\tstruct ctl_table *entry;\n\n\t/* special case: no directory and empty directory */\n\tif (!table || !table->procname)\n\t\treturn 1;\n\n\tfor (entry = table; entry->procname; entry++) {\n\t\tif (entry->child)\n\t\t\tnr_subheaders += count_subheaders(entry->child);\n\t\telse\n\t\t\thas_files = 1;\n\t}\n\treturn nr_subheaders + has_files;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic int count_subheaders(struct ctl_table *table)\n{\n\tint has_files = 0;\n\tint nr_subheaders = 0;\n\tstruct ctl_table *entry;\n\n\t/* special case: no directory and empty directory */\n\tif (!table || !table->procname)\n\t\treturn 1;\n\n\tfor (entry = table; entry->procname; entry++) {\n\t\tif (entry->child)\n\t\t\tnr_subheaders += count_subheaders(entry->child);\n\t\telse\n\t\t\thas_files = 1;\n\t}\n\treturn nr_subheaders + has_files;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic void put_links(struct ctl_table_header *header);\n\nstruct ctl_table_header *__register_sysctl_paths(\n\tstruct ctl_table_set *set,\n\tconst struct ctl_path *path, struct ctl_table *table)\n{\n\tstruct ctl_table *ctl_table_arg = table;\n\tint nr_subheaders = count_subheaders(table);\n\tstruct ctl_table_header *header = NULL, **subheaders, **subheader;\n\tconst struct ctl_path *component;\n\tchar *new_path, *pos;\n\n\tpos = new_path = kmalloc(PATH_MAX, GFP_KERNEL);\n\tif (!new_path)\n\t\treturn NULL;\n\n\tpos[0] = '\\0';\n\tfor (component = path; component->procname; component++) {\n\t\tpos = append_path(new_path, pos, component->procname);\n\t\tif (!pos)\n\t\t\tgoto out;\n\t}\n\twhile (table->procname && table->child && !table[1].procname) {\n\t\tpos = append_path(new_path, pos, table->procname);\n\t\tif (!pos)\n\t\t\tgoto out;\n\t\ttable = table->child;\n\t}\n\tif (nr_subheaders == 1) {\n\t\theader = __register_sysctl_table(set, new_path, table);\n\t\tif (header)\n\t\t\theader->ctl_table_arg = ctl_table_arg;\n\t} else {\n\t\theader = kzalloc(sizeof(*header) +\n\t\t\t\t sizeof(*subheaders)*nr_subheaders, GFP_KERNEL);\n\t\tif (!header)\n\t\t\tgoto out;\n\n\t\tsubheaders = (struct ctl_table_header **) (header + 1);\n\t\tsubheader = subheaders;\n\t\theader->ctl_table_arg = ctl_table_arg;\n\n\t\tif (register_leaf_sysctl_tables(new_path, pos, &subheader,\n\t\t\t\t\t\tset, table))\n\t\t\tgoto err_register_leaves;\n\t}\n\nout:\n\tkfree(new_path);\n\treturn header;\n\nerr_register_leaves:\n\twhile (subheader > subheaders) {\n\t\tstruct ctl_table_header *subh = *(--subheader);\n\t\tstruct ctl_table *table = subh->ctl_table_arg;\n\t\tunregister_sysctl_table(subh);\n\t\tkfree(table);\n\t}\n\tkfree(header);\n\theader = NULL;\n\tgoto out;\n}"
  },
  {
    "function_name": "register_leaf_sysctl_tables",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "1290-1362",
    "snippet": "static int register_leaf_sysctl_tables(const char *path, char *pos,\n\tstruct ctl_table_header ***subheader, struct ctl_table_set *set,\n\tstruct ctl_table *table)\n{\n\tstruct ctl_table *ctl_table_arg = NULL;\n\tstruct ctl_table *entry, *files;\n\tint nr_files = 0;\n\tint nr_dirs = 0;\n\tint err = -ENOMEM;\n\n\tfor (entry = table; entry->procname; entry++) {\n\t\tif (entry->child)\n\t\t\tnr_dirs++;\n\t\telse\n\t\t\tnr_files++;\n\t}\n\n\tfiles = table;\n\t/* If there are mixed files and directories we need a new table */\n\tif (nr_dirs && nr_files) {\n\t\tstruct ctl_table *new;\n\t\tfiles = kzalloc(sizeof(struct ctl_table) * (nr_files + 1),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!files)\n\t\t\tgoto out;\n\n\t\tctl_table_arg = files;\n\t\tfor (new = files, entry = table; entry->procname; entry++) {\n\t\t\tif (entry->child)\n\t\t\t\tcontinue;\n\t\t\t*new = *entry;\n\t\t\tnew++;\n\t\t}\n\t}\n\n\t/* Register everything except a directory full of subdirectories */\n\tif (nr_files || !nr_dirs) {\n\t\tstruct ctl_table_header *header;\n\t\theader = __register_sysctl_table(set, path, files);\n\t\tif (!header) {\n\t\t\tkfree(ctl_table_arg);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Remember if we need to free the file table */\n\t\theader->ctl_table_arg = ctl_table_arg;\n\t\t**subheader = header;\n\t\t(*subheader)++;\n\t}\n\n\t/* Recurse into the subdirectories. */\n\tfor (entry = table; entry->procname; entry++) {\n\t\tchar *child_pos;\n\n\t\tif (!entry->child)\n\t\t\tcontinue;\n\n\t\terr = -ENAMETOOLONG;\n\t\tchild_pos = append_path(path, pos, entry->procname);\n\t\tif (!child_pos)\n\t\t\tgoto out;\n\n\t\terr = register_leaf_sysctl_tables(path, child_pos, subheader,\n\t\t\t\t\t\t  set, entry->child);\n\t\tpos[0] = '\\0';\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\terr = 0;\nout:\n\t/* On failure our caller will unregister all registered subheaders */\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void drop_sysctl_table(struct ctl_table_header *header);",
      "static void put_links(struct ctl_table_header *header);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_leaf_sysctl_tables",
          "args": [
            "path",
            "child_pos",
            "subheader",
            "set",
            "entry->child"
          ],
          "line": 1352
        },
        "resolved": true,
        "details": {
          "function_name": "register_leaf_sysctl_tables",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "1290-1362",
          "snippet": "static int register_leaf_sysctl_tables(const char *path, char *pos,\n\tstruct ctl_table_header ***subheader, struct ctl_table_set *set,\n\tstruct ctl_table *table)\n{\n\tstruct ctl_table *ctl_table_arg = NULL;\n\tstruct ctl_table *entry, *files;\n\tint nr_files = 0;\n\tint nr_dirs = 0;\n\tint err = -ENOMEM;\n\n\tfor (entry = table; entry->procname; entry++) {\n\t\tif (entry->child)\n\t\t\tnr_dirs++;\n\t\telse\n\t\t\tnr_files++;\n\t}\n\n\tfiles = table;\n\t/* If there are mixed files and directories we need a new table */\n\tif (nr_dirs && nr_files) {\n\t\tstruct ctl_table *new;\n\t\tfiles = kzalloc(sizeof(struct ctl_table) * (nr_files + 1),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!files)\n\t\t\tgoto out;\n\n\t\tctl_table_arg = files;\n\t\tfor (new = files, entry = table; entry->procname; entry++) {\n\t\t\tif (entry->child)\n\t\t\t\tcontinue;\n\t\t\t*new = *entry;\n\t\t\tnew++;\n\t\t}\n\t}\n\n\t/* Register everything except a directory full of subdirectories */\n\tif (nr_files || !nr_dirs) {\n\t\tstruct ctl_table_header *header;\n\t\theader = __register_sysctl_table(set, path, files);\n\t\tif (!header) {\n\t\t\tkfree(ctl_table_arg);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Remember if we need to free the file table */\n\t\theader->ctl_table_arg = ctl_table_arg;\n\t\t**subheader = header;\n\t\t(*subheader)++;\n\t}\n\n\t/* Recurse into the subdirectories. */\n\tfor (entry = table; entry->procname; entry++) {\n\t\tchar *child_pos;\n\n\t\tif (!entry->child)\n\t\t\tcontinue;\n\n\t\terr = -ENAMETOOLONG;\n\t\tchild_pos = append_path(path, pos, entry->procname);\n\t\tif (!child_pos)\n\t\t\tgoto out;\n\n\t\terr = register_leaf_sysctl_tables(path, child_pos, subheader,\n\t\t\t\t\t\t  set, entry->child);\n\t\tpos[0] = '\\0';\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\terr = 0;\nout:\n\t/* On failure our caller will unregister all registered subheaders */\n\treturn err;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "append_path",
          "args": [
            "path",
            "pos",
            "entry->procname"
          ],
          "line": 1348
        },
        "resolved": true,
        "details": {
          "function_name": "append_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "1258-1269",
          "snippet": "static char *append_path(const char *path, char *pos, const char *name)\n{\n\tint namelen;\n\tnamelen = strlen(name);\n\tif (((pos - path) + namelen + 2) >= PATH_MAX)\n\t\treturn NULL;\n\tmemcpy(pos, name, namelen);\n\tpos[namelen] = '/';\n\tpos[namelen + 1] = '\\0';\n\tpos += namelen + 1;\n\treturn pos;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic char *append_path(const char *path, char *pos, const char *name)\n{\n\tint namelen;\n\tnamelen = strlen(name);\n\tif (((pos - path) + namelen + 2) >= PATH_MAX)\n\t\treturn NULL;\n\tmemcpy(pos, name, namelen);\n\tpos[namelen] = '/';\n\tpos[namelen + 1] = '\\0';\n\tpos += namelen + 1;\n\treturn pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ctl_table_arg"
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__register_sysctl_table",
          "args": [
            "set",
            "path",
            "files"
          ],
          "line": 1328
        },
        "resolved": true,
        "details": {
          "function_name": "__register_sysctl_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "1174-1239",
          "snippet": "struct ctl_table_header *__register_sysctl_table(\n\tstruct ctl_table_set *set,\n\tconst char *path, struct ctl_table *table)\n{\n\tstruct ctl_table_root *root = set->dir.header.root;\n\tstruct ctl_table_header *header;\n\tconst char *name, *nextname;\n\tstruct ctl_dir *dir;\n\tstruct ctl_table *entry;\n\tstruct ctl_node *node;\n\tint nr_entries = 0;\n\n\tfor (entry = table; entry->procname; entry++)\n\t\tnr_entries++;\n\n\theader = kzalloc(sizeof(struct ctl_table_header) +\n\t\t\t sizeof(struct ctl_node)*nr_entries, GFP_KERNEL);\n\tif (!header)\n\t\treturn NULL;\n\n\tnode = (struct ctl_node *)(header + 1);\n\tinit_header(header, root, set, node, table);\n\tif (sysctl_check_table(path, table))\n\t\tgoto fail;\n\n\tspin_lock(&sysctl_lock);\n\tdir = &set->dir;\n\t/* Reference moved down the diretory tree get_subdir */\n\tdir->header.nreg++;\n\tspin_unlock(&sysctl_lock);\n\n\t/* Find the directory for the ctl_table */\n\tfor (name = path; name; name = nextname) {\n\t\tint namelen;\n\t\tnextname = strchr(name, '/');\n\t\tif (nextname) {\n\t\t\tnamelen = nextname - name;\n\t\t\tnextname++;\n\t\t} else {\n\t\t\tnamelen = strlen(name);\n\t\t}\n\t\tif (namelen == 0)\n\t\t\tcontinue;\n\n\t\tdir = get_subdir(dir, name, namelen);\n\t\tif (IS_ERR(dir))\n\t\t\tgoto fail;\n\t}\n\n\tspin_lock(&sysctl_lock);\n\tif (insert_header(dir, header))\n\t\tgoto fail_put_dir_locked;\n\n\tdrop_sysctl_table(&dir->header);\n\tspin_unlock(&sysctl_lock);\n\n\treturn header;\n\nfail_put_dir_locked:\n\tdrop_sysctl_table(&dir->header);\n\tspin_unlock(&sysctl_lock);\nfail:\n\tkfree(header);\n\tdump_stack();\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(sysctl_lock);",
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(sysctl_lock);\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic void put_links(struct ctl_table_header *header);\n\nstruct ctl_table_header *__register_sysctl_table(\n\tstruct ctl_table_set *set,\n\tconst char *path, struct ctl_table *table)\n{\n\tstruct ctl_table_root *root = set->dir.header.root;\n\tstruct ctl_table_header *header;\n\tconst char *name, *nextname;\n\tstruct ctl_dir *dir;\n\tstruct ctl_table *entry;\n\tstruct ctl_node *node;\n\tint nr_entries = 0;\n\n\tfor (entry = table; entry->procname; entry++)\n\t\tnr_entries++;\n\n\theader = kzalloc(sizeof(struct ctl_table_header) +\n\t\t\t sizeof(struct ctl_node)*nr_entries, GFP_KERNEL);\n\tif (!header)\n\t\treturn NULL;\n\n\tnode = (struct ctl_node *)(header + 1);\n\tinit_header(header, root, set, node, table);\n\tif (sysctl_check_table(path, table))\n\t\tgoto fail;\n\n\tspin_lock(&sysctl_lock);\n\tdir = &set->dir;\n\t/* Reference moved down the diretory tree get_subdir */\n\tdir->header.nreg++;\n\tspin_unlock(&sysctl_lock);\n\n\t/* Find the directory for the ctl_table */\n\tfor (name = path; name; name = nextname) {\n\t\tint namelen;\n\t\tnextname = strchr(name, '/');\n\t\tif (nextname) {\n\t\t\tnamelen = nextname - name;\n\t\t\tnextname++;\n\t\t} else {\n\t\t\tnamelen = strlen(name);\n\t\t}\n\t\tif (namelen == 0)\n\t\t\tcontinue;\n\n\t\tdir = get_subdir(dir, name, namelen);\n\t\tif (IS_ERR(dir))\n\t\t\tgoto fail;\n\t}\n\n\tspin_lock(&sysctl_lock);\n\tif (insert_header(dir, header))\n\t\tgoto fail_put_dir_locked;\n\n\tdrop_sysctl_table(&dir->header);\n\tspin_unlock(&sysctl_lock);\n\n\treturn header;\n\nfail_put_dir_locked:\n\tdrop_sysctl_table(&dir->header);\n\tspin_unlock(&sysctl_lock);\nfail:\n\tkfree(header);\n\tdump_stack();\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct ctl_table) * (nr_files + 1)",
            "GFP_KERNEL"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic int register_leaf_sysctl_tables(const char *path, char *pos,\n\tstruct ctl_table_header ***subheader, struct ctl_table_set *set,\n\tstruct ctl_table *table)\n{\n\tstruct ctl_table *ctl_table_arg = NULL;\n\tstruct ctl_table *entry, *files;\n\tint nr_files = 0;\n\tint nr_dirs = 0;\n\tint err = -ENOMEM;\n\n\tfor (entry = table; entry->procname; entry++) {\n\t\tif (entry->child)\n\t\t\tnr_dirs++;\n\t\telse\n\t\t\tnr_files++;\n\t}\n\n\tfiles = table;\n\t/* If there are mixed files and directories we need a new table */\n\tif (nr_dirs && nr_files) {\n\t\tstruct ctl_table *new;\n\t\tfiles = kzalloc(sizeof(struct ctl_table) * (nr_files + 1),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!files)\n\t\t\tgoto out;\n\n\t\tctl_table_arg = files;\n\t\tfor (new = files, entry = table; entry->procname; entry++) {\n\t\t\tif (entry->child)\n\t\t\t\tcontinue;\n\t\t\t*new = *entry;\n\t\t\tnew++;\n\t\t}\n\t}\n\n\t/* Register everything except a directory full of subdirectories */\n\tif (nr_files || !nr_dirs) {\n\t\tstruct ctl_table_header *header;\n\t\theader = __register_sysctl_table(set, path, files);\n\t\tif (!header) {\n\t\t\tkfree(ctl_table_arg);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Remember if we need to free the file table */\n\t\theader->ctl_table_arg = ctl_table_arg;\n\t\t**subheader = header;\n\t\t(*subheader)++;\n\t}\n\n\t/* Recurse into the subdirectories. */\n\tfor (entry = table; entry->procname; entry++) {\n\t\tchar *child_pos;\n\n\t\tif (!entry->child)\n\t\t\tcontinue;\n\n\t\terr = -ENAMETOOLONG;\n\t\tchild_pos = append_path(path, pos, entry->procname);\n\t\tif (!child_pos)\n\t\t\tgoto out;\n\n\t\terr = register_leaf_sysctl_tables(path, child_pos, subheader,\n\t\t\t\t\t\t  set, entry->child);\n\t\tpos[0] = '\\0';\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\terr = 0;\nout:\n\t/* On failure our caller will unregister all registered subheaders */\n\treturn err;\n}"
  },
  {
    "function_name": "count_subheaders",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "1271-1288",
    "snippet": "static int count_subheaders(struct ctl_table *table)\n{\n\tint has_files = 0;\n\tint nr_subheaders = 0;\n\tstruct ctl_table *entry;\n\n\t/* special case: no directory and empty directory */\n\tif (!table || !table->procname)\n\t\treturn 1;\n\n\tfor (entry = table; entry->procname; entry++) {\n\t\tif (entry->child)\n\t\t\tnr_subheaders += count_subheaders(entry->child);\n\t\telse\n\t\t\thas_files = 1;\n\t}\n\treturn nr_subheaders + has_files;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "count_subheaders",
          "args": [
            "entry->child"
          ],
          "line": 1283
        },
        "resolved": true,
        "details": {
          "function_name": "count_subheaders",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "1271-1288",
          "snippet": "static int count_subheaders(struct ctl_table *table)\n{\n\tint has_files = 0;\n\tint nr_subheaders = 0;\n\tstruct ctl_table *entry;\n\n\t/* special case: no directory and empty directory */\n\tif (!table || !table->procname)\n\t\treturn 1;\n\n\tfor (entry = table; entry->procname; entry++) {\n\t\tif (entry->child)\n\t\t\tnr_subheaders += count_subheaders(entry->child);\n\t\telse\n\t\t\thas_files = 1;\n\t}\n\treturn nr_subheaders + has_files;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic int count_subheaders(struct ctl_table *table)\n{\n\tint has_files = 0;\n\tint nr_subheaders = 0;\n\tstruct ctl_table *entry;\n\n\t/* special case: no directory and empty directory */\n\tif (!table || !table->procname)\n\t\treturn 1;\n\n\tfor (entry = table; entry->procname; entry++) {\n\t\tif (entry->child)\n\t\t\tnr_subheaders += count_subheaders(entry->child);\n\t\telse\n\t\t\thas_files = 1;\n\t}\n\treturn nr_subheaders + has_files;\n}"
  },
  {
    "function_name": "append_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "1258-1269",
    "snippet": "static char *append_path(const char *path, char *pos, const char *name)\n{\n\tint namelen;\n\tnamelen = strlen(name);\n\tif (((pos - path) + namelen + 2) >= PATH_MAX)\n\t\treturn NULL;\n\tmemcpy(pos, name, namelen);\n\tpos[namelen] = '/';\n\tpos[namelen + 1] = '\\0';\n\tpos += namelen + 1;\n\treturn pos;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "pos",
            "name",
            "namelen"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 1261
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic char *append_path(const char *path, char *pos, const char *name)\n{\n\tint namelen;\n\tnamelen = strlen(name);\n\tif (((pos - path) + namelen + 2) >= PATH_MAX)\n\t\treturn NULL;\n\tmemcpy(pos, name, namelen);\n\tpos[namelen] = '/';\n\tpos[namelen + 1] = '\\0';\n\tpos += namelen + 1;\n\treturn pos;\n}"
  },
  {
    "function_name": "register_sysctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "1251-1255",
    "snippet": "struct ctl_table_header *register_sysctl(const char *path, struct ctl_table *table)\n{\n\treturn __register_sysctl_table(&sysctl_table_root.default_set,\n\t\t\t\t\tpath, table);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ctl_table_root sysctl_table_root = {\n\t.default_set.dir.header = {\n\t\t{{.count = 1,\n\t\t  .nreg = 1,\n\t\t  .ctl_table = root_table }},\n\t\t.ctl_table_arg = root_table,\n\t\t.root = &sysctl_table_root,\n\t\t.set = &sysctl_table_root.default_set,\n\t},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__register_sysctl_table",
          "args": [
            "&sysctl_table_root.default_set",
            "path",
            "table"
          ],
          "line": 1253
        },
        "resolved": true,
        "details": {
          "function_name": "__register_sysctl_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "1174-1239",
          "snippet": "struct ctl_table_header *__register_sysctl_table(\n\tstruct ctl_table_set *set,\n\tconst char *path, struct ctl_table *table)\n{\n\tstruct ctl_table_root *root = set->dir.header.root;\n\tstruct ctl_table_header *header;\n\tconst char *name, *nextname;\n\tstruct ctl_dir *dir;\n\tstruct ctl_table *entry;\n\tstruct ctl_node *node;\n\tint nr_entries = 0;\n\n\tfor (entry = table; entry->procname; entry++)\n\t\tnr_entries++;\n\n\theader = kzalloc(sizeof(struct ctl_table_header) +\n\t\t\t sizeof(struct ctl_node)*nr_entries, GFP_KERNEL);\n\tif (!header)\n\t\treturn NULL;\n\n\tnode = (struct ctl_node *)(header + 1);\n\tinit_header(header, root, set, node, table);\n\tif (sysctl_check_table(path, table))\n\t\tgoto fail;\n\n\tspin_lock(&sysctl_lock);\n\tdir = &set->dir;\n\t/* Reference moved down the diretory tree get_subdir */\n\tdir->header.nreg++;\n\tspin_unlock(&sysctl_lock);\n\n\t/* Find the directory for the ctl_table */\n\tfor (name = path; name; name = nextname) {\n\t\tint namelen;\n\t\tnextname = strchr(name, '/');\n\t\tif (nextname) {\n\t\t\tnamelen = nextname - name;\n\t\t\tnextname++;\n\t\t} else {\n\t\t\tnamelen = strlen(name);\n\t\t}\n\t\tif (namelen == 0)\n\t\t\tcontinue;\n\n\t\tdir = get_subdir(dir, name, namelen);\n\t\tif (IS_ERR(dir))\n\t\t\tgoto fail;\n\t}\n\n\tspin_lock(&sysctl_lock);\n\tif (insert_header(dir, header))\n\t\tgoto fail_put_dir_locked;\n\n\tdrop_sysctl_table(&dir->header);\n\tspin_unlock(&sysctl_lock);\n\n\treturn header;\n\nfail_put_dir_locked:\n\tdrop_sysctl_table(&dir->header);\n\tspin_unlock(&sysctl_lock);\nfail:\n\tkfree(header);\n\tdump_stack();\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(sysctl_lock);",
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(sysctl_lock);\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic void put_links(struct ctl_table_header *header);\n\nstruct ctl_table_header *__register_sysctl_table(\n\tstruct ctl_table_set *set,\n\tconst char *path, struct ctl_table *table)\n{\n\tstruct ctl_table_root *root = set->dir.header.root;\n\tstruct ctl_table_header *header;\n\tconst char *name, *nextname;\n\tstruct ctl_dir *dir;\n\tstruct ctl_table *entry;\n\tstruct ctl_node *node;\n\tint nr_entries = 0;\n\n\tfor (entry = table; entry->procname; entry++)\n\t\tnr_entries++;\n\n\theader = kzalloc(sizeof(struct ctl_table_header) +\n\t\t\t sizeof(struct ctl_node)*nr_entries, GFP_KERNEL);\n\tif (!header)\n\t\treturn NULL;\n\n\tnode = (struct ctl_node *)(header + 1);\n\tinit_header(header, root, set, node, table);\n\tif (sysctl_check_table(path, table))\n\t\tgoto fail;\n\n\tspin_lock(&sysctl_lock);\n\tdir = &set->dir;\n\t/* Reference moved down the diretory tree get_subdir */\n\tdir->header.nreg++;\n\tspin_unlock(&sysctl_lock);\n\n\t/* Find the directory for the ctl_table */\n\tfor (name = path; name; name = nextname) {\n\t\tint namelen;\n\t\tnextname = strchr(name, '/');\n\t\tif (nextname) {\n\t\t\tnamelen = nextname - name;\n\t\t\tnextname++;\n\t\t} else {\n\t\t\tnamelen = strlen(name);\n\t\t}\n\t\tif (namelen == 0)\n\t\t\tcontinue;\n\n\t\tdir = get_subdir(dir, name, namelen);\n\t\tif (IS_ERR(dir))\n\t\t\tgoto fail;\n\t}\n\n\tspin_lock(&sysctl_lock);\n\tif (insert_header(dir, header))\n\t\tgoto fail_put_dir_locked;\n\n\tdrop_sysctl_table(&dir->header);\n\tspin_unlock(&sysctl_lock);\n\n\treturn header;\n\nfail_put_dir_locked:\n\tdrop_sysctl_table(&dir->header);\n\tspin_unlock(&sysctl_lock);\nfail:\n\tkfree(header);\n\tdump_stack();\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic struct ctl_table_root sysctl_table_root = {\n\t.default_set.dir.header = {\n\t\t{{.count = 1,\n\t\t  .nreg = 1,\n\t\t  .ctl_table = root_table }},\n\t\t.ctl_table_arg = root_table,\n\t\t.root = &sysctl_table_root,\n\t\t.set = &sysctl_table_root.default_set,\n\t},\n};\n\nstruct ctl_table_header *register_sysctl(const char *path, struct ctl_table *table)\n{\n\treturn __register_sysctl_table(&sysctl_table_root.default_set,\n\t\t\t\t\tpath, table);\n}"
  },
  {
    "function_name": "__register_sysctl_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "1174-1239",
    "snippet": "struct ctl_table_header *__register_sysctl_table(\n\tstruct ctl_table_set *set,\n\tconst char *path, struct ctl_table *table)\n{\n\tstruct ctl_table_root *root = set->dir.header.root;\n\tstruct ctl_table_header *header;\n\tconst char *name, *nextname;\n\tstruct ctl_dir *dir;\n\tstruct ctl_table *entry;\n\tstruct ctl_node *node;\n\tint nr_entries = 0;\n\n\tfor (entry = table; entry->procname; entry++)\n\t\tnr_entries++;\n\n\theader = kzalloc(sizeof(struct ctl_table_header) +\n\t\t\t sizeof(struct ctl_node)*nr_entries, GFP_KERNEL);\n\tif (!header)\n\t\treturn NULL;\n\n\tnode = (struct ctl_node *)(header + 1);\n\tinit_header(header, root, set, node, table);\n\tif (sysctl_check_table(path, table))\n\t\tgoto fail;\n\n\tspin_lock(&sysctl_lock);\n\tdir = &set->dir;\n\t/* Reference moved down the diretory tree get_subdir */\n\tdir->header.nreg++;\n\tspin_unlock(&sysctl_lock);\n\n\t/* Find the directory for the ctl_table */\n\tfor (name = path; name; name = nextname) {\n\t\tint namelen;\n\t\tnextname = strchr(name, '/');\n\t\tif (nextname) {\n\t\t\tnamelen = nextname - name;\n\t\t\tnextname++;\n\t\t} else {\n\t\t\tnamelen = strlen(name);\n\t\t}\n\t\tif (namelen == 0)\n\t\t\tcontinue;\n\n\t\tdir = get_subdir(dir, name, namelen);\n\t\tif (IS_ERR(dir))\n\t\t\tgoto fail;\n\t}\n\n\tspin_lock(&sysctl_lock);\n\tif (insert_header(dir, header))\n\t\tgoto fail_put_dir_locked;\n\n\tdrop_sysctl_table(&dir->header);\n\tspin_unlock(&sysctl_lock);\n\n\treturn header;\n\nfail_put_dir_locked:\n\tdrop_sysctl_table(&dir->header);\n\tspin_unlock(&sysctl_lock);\nfail:\n\tkfree(header);\n\tdump_stack();\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(sysctl_lock);",
      "static void drop_sysctl_table(struct ctl_table_header *header);",
      "static void put_links(struct ctl_table_header *header);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "header"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sysctl_lock"
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_sysctl_table",
          "args": [
            "&dir->header"
          ],
          "line": 1233
        },
        "resolved": true,
        "details": {
          "function_name": "drop_sysctl_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "1505-1519",
          "snippet": "static void drop_sysctl_table(struct ctl_table_header *header)\n{\n\tstruct ctl_dir *parent = header->parent;\n\n\tif (--header->nreg)\n\t\treturn;\n\n\tput_links(header);\n\tstart_unregistering(header);\n\tif (!--header->count)\n\t\tkfree_rcu(header, rcu);\n\n\tif (parent)\n\t\tdrop_sysctl_table(&parent->header);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic void drop_sysctl_table(struct ctl_table_header *header)\n{\n\tstruct ctl_dir *parent = header->parent;\n\n\tif (--header->nreg)\n\t\treturn;\n\n\tput_links(header);\n\tstart_unregistering(header);\n\tif (!--header->count)\n\t\tkfree_rcu(header, rcu);\n\n\tif (parent)\n\t\tdrop_sysctl_table(&parent->header);\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_header",
          "args": [
            "dir",
            "header"
          ],
          "line": 1224
        },
        "resolved": true,
        "details": {
          "function_name": "insert_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "185-208",
          "snippet": "static int insert_header(struct ctl_dir *dir, struct ctl_table_header *header)\n{\n\tstruct ctl_table *entry;\n\tint err;\n\n\tdir->header.nreg++;\n\theader->parent = dir;\n\terr = insert_links(header);\n\tif (err)\n\t\tgoto fail_links;\n\tfor (entry = header->ctl_table; entry->procname; entry++) {\n\t\terr = insert_entry(header, entry);\n\t\tif (err)\n\t\t\tgoto fail;\n\t}\n\treturn 0;\nfail:\n\terase_header(header);\n\tput_links(header);\nfail_links:\n\theader->parent = NULL;\n\tdrop_sysctl_table(&dir->header);\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic int insert_header(struct ctl_dir *dir, struct ctl_table_header *header)\n{\n\tstruct ctl_table *entry;\n\tint err;\n\n\tdir->header.nreg++;\n\theader->parent = dir;\n\terr = insert_links(header);\n\tif (err)\n\t\tgoto fail_links;\n\tfor (entry = header->ctl_table; entry->procname; entry++) {\n\t\terr = insert_entry(header, entry);\n\t\tif (err)\n\t\t\tgoto fail;\n\t}\n\treturn 0;\nfail:\n\terase_header(header);\n\tput_links(header);\nfail_links:\n\theader->parent = NULL;\n\tdrop_sysctl_table(&dir->header);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sysctl_lock"
          ],
          "line": 1223
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dir"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_subdir",
          "args": [
            "dir",
            "name",
            "namelen"
          ],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "get_subdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "877-925",
          "snippet": "static struct ctl_dir *get_subdir(struct ctl_dir *dir,\n\t\t\t\t  const char *name, int namelen)\n{\n\tstruct ctl_table_set *set = dir->header.set;\n\tstruct ctl_dir *subdir, *new = NULL;\n\tint err;\n\n\tspin_lock(&sysctl_lock);\n\tsubdir = find_subdir(dir, name, namelen);\n\tif (!IS_ERR(subdir))\n\t\tgoto found;\n\tif (PTR_ERR(subdir) != -ENOENT)\n\t\tgoto failed;\n\n\tspin_unlock(&sysctl_lock);\n\tnew = new_dir(set, name, namelen);\n\tspin_lock(&sysctl_lock);\n\tsubdir = ERR_PTR(-ENOMEM);\n\tif (!new)\n\t\tgoto failed;\n\n\t/* Was the subdir added while we dropped the lock? */\n\tsubdir = find_subdir(dir, name, namelen);\n\tif (!IS_ERR(subdir))\n\t\tgoto found;\n\tif (PTR_ERR(subdir) != -ENOENT)\n\t\tgoto failed;\n\n\t/* Nope.  Use the our freshly made directory entry. */\n\terr = insert_header(dir, &new->header);\n\tsubdir = ERR_PTR(err);\n\tif (err)\n\t\tgoto failed;\n\tsubdir = new;\nfound:\n\tsubdir->header.nreg++;\nfailed:\n\tif (unlikely(IS_ERR(subdir))) {\n\t\tpr_err(\"sysctl could not get directory: \");\n\t\tsysctl_print_dir(dir);\n\t\tpr_cont(\"/%*.*s %ld\\n\",\n\t\t\tnamelen, namelen, name, PTR_ERR(subdir));\n\t}\n\tdrop_sysctl_table(&dir->header);\n\tif (new)\n\t\tdrop_sysctl_table(&new->header);\n\tspin_unlock(&sysctl_lock);\n\treturn subdir;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(sysctl_lock);",
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(sysctl_lock);\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic struct ctl_dir *get_subdir(struct ctl_dir *dir,\n\t\t\t\t  const char *name, int namelen)\n{\n\tstruct ctl_table_set *set = dir->header.set;\n\tstruct ctl_dir *subdir, *new = NULL;\n\tint err;\n\n\tspin_lock(&sysctl_lock);\n\tsubdir = find_subdir(dir, name, namelen);\n\tif (!IS_ERR(subdir))\n\t\tgoto found;\n\tif (PTR_ERR(subdir) != -ENOENT)\n\t\tgoto failed;\n\n\tspin_unlock(&sysctl_lock);\n\tnew = new_dir(set, name, namelen);\n\tspin_lock(&sysctl_lock);\n\tsubdir = ERR_PTR(-ENOMEM);\n\tif (!new)\n\t\tgoto failed;\n\n\t/* Was the subdir added while we dropped the lock? */\n\tsubdir = find_subdir(dir, name, namelen);\n\tif (!IS_ERR(subdir))\n\t\tgoto found;\n\tif (PTR_ERR(subdir) != -ENOENT)\n\t\tgoto failed;\n\n\t/* Nope.  Use the our freshly made directory entry. */\n\terr = insert_header(dir, &new->header);\n\tsubdir = ERR_PTR(err);\n\tif (err)\n\t\tgoto failed;\n\tsubdir = new;\nfound:\n\tsubdir->header.nreg++;\nfailed:\n\tif (unlikely(IS_ERR(subdir))) {\n\t\tpr_err(\"sysctl could not get directory: \");\n\t\tsysctl_print_dir(dir);\n\t\tpr_cont(\"/%*.*s %ld\\n\",\n\t\t\tnamelen, namelen, name, PTR_ERR(subdir));\n\t}\n\tdrop_sysctl_table(&dir->header);\n\tif (new)\n\t\tdrop_sysctl_table(&new->header);\n\tspin_unlock(&sysctl_lock);\n\treturn subdir;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "name",
            "'/'"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysctl_check_table",
          "args": [
            "path",
            "table"
          ],
          "line": 1196
        },
        "resolved": true,
        "details": {
          "function_name": "sysctl_check_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "990-1018",
          "snippet": "static int sysctl_check_table(const char *path, struct ctl_table *table)\n{\n\tint err = 0;\n\tfor (; table->procname; table++) {\n\t\tif (table->child)\n\t\t\terr = sysctl_err(path, table, \"Not a file\");\n\n\t\tif ((table->proc_handler == proc_dostring) ||\n\t\t    (table->proc_handler == proc_dointvec) ||\n\t\t    (table->proc_handler == proc_dointvec_minmax) ||\n\t\t    (table->proc_handler == proc_dointvec_jiffies) ||\n\t\t    (table->proc_handler == proc_dointvec_userhz_jiffies) ||\n\t\t    (table->proc_handler == proc_dointvec_ms_jiffies) ||\n\t\t    (table->proc_handler == proc_doulongvec_minmax) ||\n\t\t    (table->proc_handler == proc_doulongvec_ms_jiffies_minmax)) {\n\t\t\tif (!table->data)\n\t\t\t\terr = sysctl_err(path, table, \"No data\");\n\t\t\tif (!table->maxlen)\n\t\t\t\terr = sysctl_err(path, table, \"No maxlen\");\n\t\t}\n\t\tif (!table->proc_handler)\n\t\t\terr = sysctl_err(path, table, \"No proc_handler\");\n\n\t\tif ((table->mode & (S_IRUGO|S_IWUGO)) != table->mode)\n\t\t\terr = sysctl_err(path, table, \"bogus .mode 0%o\",\n\t\t\t\ttable->mode);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic int sysctl_check_table(const char *path, struct ctl_table *table)\n{\n\tint err = 0;\n\tfor (; table->procname; table++) {\n\t\tif (table->child)\n\t\t\terr = sysctl_err(path, table, \"Not a file\");\n\n\t\tif ((table->proc_handler == proc_dostring) ||\n\t\t    (table->proc_handler == proc_dointvec) ||\n\t\t    (table->proc_handler == proc_dointvec_minmax) ||\n\t\t    (table->proc_handler == proc_dointvec_jiffies) ||\n\t\t    (table->proc_handler == proc_dointvec_userhz_jiffies) ||\n\t\t    (table->proc_handler == proc_dointvec_ms_jiffies) ||\n\t\t    (table->proc_handler == proc_doulongvec_minmax) ||\n\t\t    (table->proc_handler == proc_doulongvec_ms_jiffies_minmax)) {\n\t\t\tif (!table->data)\n\t\t\t\terr = sysctl_err(path, table, \"No data\");\n\t\t\tif (!table->maxlen)\n\t\t\t\terr = sysctl_err(path, table, \"No maxlen\");\n\t\t}\n\t\tif (!table->proc_handler)\n\t\t\terr = sysctl_err(path, table, \"No proc_handler\");\n\n\t\tif ((table->mode & (S_IRUGO|S_IWUGO)) != table->mode)\n\t\t\terr = sysctl_err(path, table, \"bogus .mode 0%o\",\n\t\t\t\ttable->mode);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_header",
          "args": [
            "header",
            "root",
            "set",
            "node",
            "table"
          ],
          "line": 1195
        },
        "resolved": true,
        "details": {
          "function_name": "init_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "157-176",
          "snippet": "static void init_header(struct ctl_table_header *head,\n\tstruct ctl_table_root *root, struct ctl_table_set *set,\n\tstruct ctl_node *node, struct ctl_table *table)\n{\n\thead->ctl_table = table;\n\thead->ctl_table_arg = table;\n\thead->used = 0;\n\thead->count = 1;\n\thead->nreg = 1;\n\thead->unregistering = NULL;\n\thead->root = root;\n\thead->set = set;\n\thead->parent = NULL;\n\thead->node = node;\n\tif (node) {\n\t\tstruct ctl_table *entry;\n\t\tfor (entry = table; entry->procname; entry++, node++)\n\t\t\tnode->header = head;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static int insert_links(struct ctl_table_header *head);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic int insert_links(struct ctl_table_header *head);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic void init_header(struct ctl_table_header *head,\n\tstruct ctl_table_root *root, struct ctl_table_set *set,\n\tstruct ctl_node *node, struct ctl_table *table)\n{\n\thead->ctl_table = table;\n\thead->ctl_table_arg = table;\n\thead->used = 0;\n\thead->count = 1;\n\thead->nreg = 1;\n\thead->unregistering = NULL;\n\thead->root = root;\n\thead->set = set;\n\thead->parent = NULL;\n\thead->node = node;\n\tif (node) {\n\t\tstruct ctl_table *entry;\n\t\tfor (entry = table; entry->procname; entry++, node++)\n\t\t\tnode->header = head;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct ctl_table_header) +\n\t\t\t sizeof(struct ctl_node)*nr_entries",
            "GFP_KERNEL"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(sysctl_lock);\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic void put_links(struct ctl_table_header *header);\n\nstruct ctl_table_header *__register_sysctl_table(\n\tstruct ctl_table_set *set,\n\tconst char *path, struct ctl_table *table)\n{\n\tstruct ctl_table_root *root = set->dir.header.root;\n\tstruct ctl_table_header *header;\n\tconst char *name, *nextname;\n\tstruct ctl_dir *dir;\n\tstruct ctl_table *entry;\n\tstruct ctl_node *node;\n\tint nr_entries = 0;\n\n\tfor (entry = table; entry->procname; entry++)\n\t\tnr_entries++;\n\n\theader = kzalloc(sizeof(struct ctl_table_header) +\n\t\t\t sizeof(struct ctl_node)*nr_entries, GFP_KERNEL);\n\tif (!header)\n\t\treturn NULL;\n\n\tnode = (struct ctl_node *)(header + 1);\n\tinit_header(header, root, set, node, table);\n\tif (sysctl_check_table(path, table))\n\t\tgoto fail;\n\n\tspin_lock(&sysctl_lock);\n\tdir = &set->dir;\n\t/* Reference moved down the diretory tree get_subdir */\n\tdir->header.nreg++;\n\tspin_unlock(&sysctl_lock);\n\n\t/* Find the directory for the ctl_table */\n\tfor (name = path; name; name = nextname) {\n\t\tint namelen;\n\t\tnextname = strchr(name, '/');\n\t\tif (nextname) {\n\t\t\tnamelen = nextname - name;\n\t\t\tnextname++;\n\t\t} else {\n\t\t\tnamelen = strlen(name);\n\t\t}\n\t\tif (namelen == 0)\n\t\t\tcontinue;\n\n\t\tdir = get_subdir(dir, name, namelen);\n\t\tif (IS_ERR(dir))\n\t\t\tgoto fail;\n\t}\n\n\tspin_lock(&sysctl_lock);\n\tif (insert_header(dir, header))\n\t\tgoto fail_put_dir_locked;\n\n\tdrop_sysctl_table(&dir->header);\n\tspin_unlock(&sysctl_lock);\n\n\treturn header;\n\nfail_put_dir_locked:\n\tdrop_sysctl_table(&dir->header);\n\tspin_unlock(&sysctl_lock);\nfail:\n\tkfree(header);\n\tdump_stack();\n\treturn NULL;\n}"
  },
  {
    "function_name": "insert_links",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "1091-1130",
    "snippet": "static int insert_links(struct ctl_table_header *head)\n{\n\tstruct ctl_table_set *root_set = &sysctl_table_root.default_set;\n\tstruct ctl_dir *core_parent = NULL;\n\tstruct ctl_table_header *links;\n\tint err;\n\n\tif (head->set == root_set)\n\t\treturn 0;\n\n\tcore_parent = xlate_dir(root_set, head->parent);\n\tif (IS_ERR(core_parent))\n\t\treturn 0;\n\n\tif (get_links(core_parent, head->ctl_table, head->root))\n\t\treturn 0;\n\n\tcore_parent->header.nreg++;\n\tspin_unlock(&sysctl_lock);\n\n\tlinks = new_links(core_parent, head->ctl_table, head->root);\n\n\tspin_lock(&sysctl_lock);\n\terr = -ENOMEM;\n\tif (!links)\n\t\tgoto out;\n\n\terr = 0;\n\tif (get_links(core_parent, head->ctl_table, head->root)) {\n\t\tkfree(links);\n\t\tgoto out;\n\t}\n\n\terr = insert_header(core_parent, links);\n\tif (err)\n\t\tkfree(links);\nout:\n\tdrop_sysctl_table(&core_parent->header);\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ctl_table_root sysctl_table_root = {\n\t.default_set.dir.header = {\n\t\t{{.count = 1,\n\t\t  .nreg = 1,\n\t\t  .ctl_table = root_table }},\n\t\t.ctl_table_arg = root_table,\n\t\t.root = &sysctl_table_root,\n\t\t.set = &sysctl_table_root.default_set,\n\t},\n};",
      "static DEFINE_SPINLOCK(sysctl_lock);",
      "static void drop_sysctl_table(struct ctl_table_header *header);",
      "static int insert_links(struct ctl_table_header *head);",
      "static void put_links(struct ctl_table_header *header);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "drop_sysctl_table",
          "args": [
            "&core_parent->header"
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "drop_sysctl_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "1505-1519",
          "snippet": "static void drop_sysctl_table(struct ctl_table_header *header)\n{\n\tstruct ctl_dir *parent = header->parent;\n\n\tif (--header->nreg)\n\t\treturn;\n\n\tput_links(header);\n\tstart_unregistering(header);\n\tif (!--header->count)\n\t\tkfree_rcu(header, rcu);\n\n\tif (parent)\n\t\tdrop_sysctl_table(&parent->header);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic void drop_sysctl_table(struct ctl_table_header *header)\n{\n\tstruct ctl_dir *parent = header->parent;\n\n\tif (--header->nreg)\n\t\treturn;\n\n\tput_links(header);\n\tstart_unregistering(header);\n\tif (!--header->count)\n\t\tkfree_rcu(header, rcu);\n\n\tif (parent)\n\t\tdrop_sysctl_table(&parent->header);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "links"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "insert_header",
          "args": [
            "core_parent",
            "links"
          ],
          "line": 1124
        },
        "resolved": true,
        "details": {
          "function_name": "insert_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "185-208",
          "snippet": "static int insert_header(struct ctl_dir *dir, struct ctl_table_header *header)\n{\n\tstruct ctl_table *entry;\n\tint err;\n\n\tdir->header.nreg++;\n\theader->parent = dir;\n\terr = insert_links(header);\n\tif (err)\n\t\tgoto fail_links;\n\tfor (entry = header->ctl_table; entry->procname; entry++) {\n\t\terr = insert_entry(header, entry);\n\t\tif (err)\n\t\t\tgoto fail;\n\t}\n\treturn 0;\nfail:\n\terase_header(header);\n\tput_links(header);\nfail_links:\n\theader->parent = NULL;\n\tdrop_sysctl_table(&dir->header);\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic int insert_header(struct ctl_dir *dir, struct ctl_table_header *header)\n{\n\tstruct ctl_table *entry;\n\tint err;\n\n\tdir->header.nreg++;\n\theader->parent = dir;\n\terr = insert_links(header);\n\tif (err)\n\t\tgoto fail_links;\n\tfor (entry = header->ctl_table; entry->procname; entry++) {\n\t\terr = insert_entry(header, entry);\n\t\tif (err)\n\t\t\tgoto fail;\n\t}\n\treturn 0;\nfail:\n\terase_header(header);\n\tput_links(header);\nfail_links:\n\theader->parent = NULL;\n\tdrop_sysctl_table(&dir->header);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "links"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_links",
          "args": [
            "core_parent",
            "head->ctl_table",
            "head->root"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "get_links",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "1063-1089",
          "snippet": "static bool get_links(struct ctl_dir *dir,\n\tstruct ctl_table *table, struct ctl_table_root *link_root)\n{\n\tstruct ctl_table_header *head;\n\tstruct ctl_table *entry, *link;\n\n\t/* Are there links available for every entry in table? */\n\tfor (entry = table; entry->procname; entry++) {\n\t\tconst char *procname = entry->procname;\n\t\tlink = find_entry(&head, dir, procname, strlen(procname));\n\t\tif (!link)\n\t\t\treturn false;\n\t\tif (S_ISDIR(link->mode) && S_ISDIR(entry->mode))\n\t\t\tcontinue;\n\t\tif (S_ISLNK(link->mode) && (link->data == link_root))\n\t\t\tcontinue;\n\t\treturn false;\n\t}\n\n\t/* The checks passed.  Increase the registration count on the links */\n\tfor (entry = table; entry->procname; entry++) {\n\t\tconst char *procname = entry->procname;\n\t\tlink = find_entry(&head, dir, procname, strlen(procname));\n\t\thead->nreg++;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int insert_links(struct ctl_table_header *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic int insert_links(struct ctl_table_header *head);\n\nstatic bool get_links(struct ctl_dir *dir,\n\tstruct ctl_table *table, struct ctl_table_root *link_root)\n{\n\tstruct ctl_table_header *head;\n\tstruct ctl_table *entry, *link;\n\n\t/* Are there links available for every entry in table? */\n\tfor (entry = table; entry->procname; entry++) {\n\t\tconst char *procname = entry->procname;\n\t\tlink = find_entry(&head, dir, procname, strlen(procname));\n\t\tif (!link)\n\t\t\treturn false;\n\t\tif (S_ISDIR(link->mode) && S_ISDIR(entry->mode))\n\t\t\tcontinue;\n\t\tif (S_ISLNK(link->mode) && (link->data == link_root))\n\t\t\tcontinue;\n\t\treturn false;\n\t}\n\n\t/* The checks passed.  Increase the registration count on the links */\n\tfor (entry = table; entry->procname; entry++) {\n\t\tconst char *procname = entry->procname;\n\t\tlink = find_entry(&head, dir, procname, strlen(procname));\n\t\thead->nreg++;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sysctl_lock"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_links",
          "args": [
            "core_parent",
            "head->ctl_table",
            "head->root"
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "new_links",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "1020-1061",
          "snippet": "static struct ctl_table_header *new_links(struct ctl_dir *dir, struct ctl_table *table,\n\tstruct ctl_table_root *link_root)\n{\n\tstruct ctl_table *link_table, *entry, *link;\n\tstruct ctl_table_header *links;\n\tstruct ctl_node *node;\n\tchar *link_name;\n\tint nr_entries, name_bytes;\n\n\tname_bytes = 0;\n\tnr_entries = 0;\n\tfor (entry = table; entry->procname; entry++) {\n\t\tnr_entries++;\n\t\tname_bytes += strlen(entry->procname) + 1;\n\t}\n\n\tlinks = kzalloc(sizeof(struct ctl_table_header) +\n\t\t\tsizeof(struct ctl_node)*nr_entries +\n\t\t\tsizeof(struct ctl_table)*(nr_entries + 1) +\n\t\t\tname_bytes,\n\t\t\tGFP_KERNEL);\n\n\tif (!links)\n\t\treturn NULL;\n\n\tnode = (struct ctl_node *)(links + 1);\n\tlink_table = (struct ctl_table *)(node + nr_entries);\n\tlink_name = (char *)&link_table[nr_entries + 1];\n\n\tfor (link = link_table, entry = table; entry->procname; link++, entry++) {\n\t\tint len = strlen(entry->procname) + 1;\n\t\tmemcpy(link_name, entry->procname, len);\n\t\tlink->procname = link_name;\n\t\tlink->mode = S_IFLNK|S_IRWXUGO;\n\t\tlink->data = link_root;\n\t\tlink_name += len;\n\t}\n\tinit_header(links, dir->header.root, dir->header.set, node, link_table);\n\tlinks->nreg = nr_entries;\n\n\treturn links;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic struct ctl_table_header *new_links(struct ctl_dir *dir, struct ctl_table *table,\n\tstruct ctl_table_root *link_root)\n{\n\tstruct ctl_table *link_table, *entry, *link;\n\tstruct ctl_table_header *links;\n\tstruct ctl_node *node;\n\tchar *link_name;\n\tint nr_entries, name_bytes;\n\n\tname_bytes = 0;\n\tnr_entries = 0;\n\tfor (entry = table; entry->procname; entry++) {\n\t\tnr_entries++;\n\t\tname_bytes += strlen(entry->procname) + 1;\n\t}\n\n\tlinks = kzalloc(sizeof(struct ctl_table_header) +\n\t\t\tsizeof(struct ctl_node)*nr_entries +\n\t\t\tsizeof(struct ctl_table)*(nr_entries + 1) +\n\t\t\tname_bytes,\n\t\t\tGFP_KERNEL);\n\n\tif (!links)\n\t\treturn NULL;\n\n\tnode = (struct ctl_node *)(links + 1);\n\tlink_table = (struct ctl_table *)(node + nr_entries);\n\tlink_name = (char *)&link_table[nr_entries + 1];\n\n\tfor (link = link_table, entry = table; entry->procname; link++, entry++) {\n\t\tint len = strlen(entry->procname) + 1;\n\t\tmemcpy(link_name, entry->procname, len);\n\t\tlink->procname = link_name;\n\t\tlink->mode = S_IFLNK|S_IRWXUGO;\n\t\tlink->data = link_root;\n\t\tlink_name += len;\n\t}\n\tinit_header(links, dir->header.root, dir->header.set, node, link_table);\n\tlinks->nreg = nr_entries;\n\n\treturn links;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sysctl_lock"
          ],
          "line": 1109
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "core_parent"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlate_dir",
          "args": [
            "root_set",
            "head->parent"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "xlate_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "927-938",
          "snippet": "static struct ctl_dir *xlate_dir(struct ctl_table_set *set, struct ctl_dir *dir)\n{\n\tstruct ctl_dir *parent;\n\tconst char *procname;\n\tif (!dir->header.parent)\n\t\treturn &set->dir;\n\tparent = xlate_dir(set, dir->header.parent);\n\tif (IS_ERR(parent))\n\t\treturn parent;\n\tprocname = dir->header.ctl_table[0].procname;\n\treturn find_subdir(parent, procname, strlen(procname));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic struct ctl_dir *xlate_dir(struct ctl_table_set *set, struct ctl_dir *dir)\n{\n\tstruct ctl_dir *parent;\n\tconst char *procname;\n\tif (!dir->header.parent)\n\t\treturn &set->dir;\n\tparent = xlate_dir(set, dir->header.parent);\n\tif (IS_ERR(parent))\n\t\treturn parent;\n\tprocname = dir->header.ctl_table[0].procname;\n\treturn find_subdir(parent, procname, strlen(procname));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic struct ctl_table_root sysctl_table_root = {\n\t.default_set.dir.header = {\n\t\t{{.count = 1,\n\t\t  .nreg = 1,\n\t\t  .ctl_table = root_table }},\n\t\t.ctl_table_arg = root_table,\n\t\t.root = &sysctl_table_root,\n\t\t.set = &sysctl_table_root.default_set,\n\t},\n};\nstatic DEFINE_SPINLOCK(sysctl_lock);\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic int insert_links(struct ctl_table_header *head);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic int insert_links(struct ctl_table_header *head)\n{\n\tstruct ctl_table_set *root_set = &sysctl_table_root.default_set;\n\tstruct ctl_dir *core_parent = NULL;\n\tstruct ctl_table_header *links;\n\tint err;\n\n\tif (head->set == root_set)\n\t\treturn 0;\n\n\tcore_parent = xlate_dir(root_set, head->parent);\n\tif (IS_ERR(core_parent))\n\t\treturn 0;\n\n\tif (get_links(core_parent, head->ctl_table, head->root))\n\t\treturn 0;\n\n\tcore_parent->header.nreg++;\n\tspin_unlock(&sysctl_lock);\n\n\tlinks = new_links(core_parent, head->ctl_table, head->root);\n\n\tspin_lock(&sysctl_lock);\n\terr = -ENOMEM;\n\tif (!links)\n\t\tgoto out;\n\n\terr = 0;\n\tif (get_links(core_parent, head->ctl_table, head->root)) {\n\t\tkfree(links);\n\t\tgoto out;\n\t}\n\n\terr = insert_header(core_parent, links);\n\tif (err)\n\t\tkfree(links);\nout:\n\tdrop_sysctl_table(&core_parent->header);\n\treturn err;\n}"
  },
  {
    "function_name": "get_links",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "1063-1089",
    "snippet": "static bool get_links(struct ctl_dir *dir,\n\tstruct ctl_table *table, struct ctl_table_root *link_root)\n{\n\tstruct ctl_table_header *head;\n\tstruct ctl_table *entry, *link;\n\n\t/* Are there links available for every entry in table? */\n\tfor (entry = table; entry->procname; entry++) {\n\t\tconst char *procname = entry->procname;\n\t\tlink = find_entry(&head, dir, procname, strlen(procname));\n\t\tif (!link)\n\t\t\treturn false;\n\t\tif (S_ISDIR(link->mode) && S_ISDIR(entry->mode))\n\t\t\tcontinue;\n\t\tif (S_ISLNK(link->mode) && (link->data == link_root))\n\t\t\tcontinue;\n\t\treturn false;\n\t}\n\n\t/* The checks passed.  Increase the registration count on the links */\n\tfor (entry = table; entry->procname; entry++) {\n\t\tconst char *procname = entry->procname;\n\t\tlink = find_entry(&head, dir, procname, strlen(procname));\n\t\thead->nreg++;\n\t}\n\treturn true;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int insert_links(struct ctl_table_header *head);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_entry",
          "args": [
            "&head",
            "dir",
            "procname",
            "strlen(procname)"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "80-109",
          "snippet": "static struct ctl_table *find_entry(struct ctl_table_header **phead,\n\tstruct ctl_dir *dir, const char *name, int namelen)\n{\n\tstruct ctl_table_header *head;\n\tstruct ctl_table *entry;\n\tstruct rb_node *node = dir->root.rb_node;\n\n\twhile (node)\n\t{\n\t\tstruct ctl_node *ctl_node;\n\t\tconst char *procname;\n\t\tint cmp;\n\n\t\tctl_node = rb_entry(node, struct ctl_node, node);\n\t\thead = ctl_node->header;\n\t\tentry = &head->ctl_table[ctl_node - head->node];\n\t\tprocname = entry->procname;\n\n\t\tcmp = namecmp(name, namelen, procname, strlen(procname));\n\t\tif (cmp < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (cmp > 0)\n\t\t\tnode = node->rb_right;\n\t\telse {\n\t\t\t*phead = head;\n\t\t\treturn entry;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static int insert_links(struct ctl_table_header *head);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic int insert_links(struct ctl_table_header *head);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic struct ctl_table *find_entry(struct ctl_table_header **phead,\n\tstruct ctl_dir *dir, const char *name, int namelen)\n{\n\tstruct ctl_table_header *head;\n\tstruct ctl_table *entry;\n\tstruct rb_node *node = dir->root.rb_node;\n\n\twhile (node)\n\t{\n\t\tstruct ctl_node *ctl_node;\n\t\tconst char *procname;\n\t\tint cmp;\n\n\t\tctl_node = rb_entry(node, struct ctl_node, node);\n\t\thead = ctl_node->header;\n\t\tentry = &head->ctl_table[ctl_node - head->node];\n\t\tprocname = entry->procname;\n\n\t\tcmp = namecmp(name, namelen, procname, strlen(procname));\n\t\tif (cmp < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (cmp > 0)\n\t\t\tnode = node->rb_right;\n\t\telse {\n\t\t\t*phead = head;\n\t\t\treturn entry;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "procname"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "link->mode"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "entry->mode"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "link->mode"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic int insert_links(struct ctl_table_header *head);\n\nstatic bool get_links(struct ctl_dir *dir,\n\tstruct ctl_table *table, struct ctl_table_root *link_root)\n{\n\tstruct ctl_table_header *head;\n\tstruct ctl_table *entry, *link;\n\n\t/* Are there links available for every entry in table? */\n\tfor (entry = table; entry->procname; entry++) {\n\t\tconst char *procname = entry->procname;\n\t\tlink = find_entry(&head, dir, procname, strlen(procname));\n\t\tif (!link)\n\t\t\treturn false;\n\t\tif (S_ISDIR(link->mode) && S_ISDIR(entry->mode))\n\t\t\tcontinue;\n\t\tif (S_ISLNK(link->mode) && (link->data == link_root))\n\t\t\tcontinue;\n\t\treturn false;\n\t}\n\n\t/* The checks passed.  Increase the registration count on the links */\n\tfor (entry = table; entry->procname; entry++) {\n\t\tconst char *procname = entry->procname;\n\t\tlink = find_entry(&head, dir, procname, strlen(procname));\n\t\thead->nreg++;\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "new_links",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "1020-1061",
    "snippet": "static struct ctl_table_header *new_links(struct ctl_dir *dir, struct ctl_table *table,\n\tstruct ctl_table_root *link_root)\n{\n\tstruct ctl_table *link_table, *entry, *link;\n\tstruct ctl_table_header *links;\n\tstruct ctl_node *node;\n\tchar *link_name;\n\tint nr_entries, name_bytes;\n\n\tname_bytes = 0;\n\tnr_entries = 0;\n\tfor (entry = table; entry->procname; entry++) {\n\t\tnr_entries++;\n\t\tname_bytes += strlen(entry->procname) + 1;\n\t}\n\n\tlinks = kzalloc(sizeof(struct ctl_table_header) +\n\t\t\tsizeof(struct ctl_node)*nr_entries +\n\t\t\tsizeof(struct ctl_table)*(nr_entries + 1) +\n\t\t\tname_bytes,\n\t\t\tGFP_KERNEL);\n\n\tif (!links)\n\t\treturn NULL;\n\n\tnode = (struct ctl_node *)(links + 1);\n\tlink_table = (struct ctl_table *)(node + nr_entries);\n\tlink_name = (char *)&link_table[nr_entries + 1];\n\n\tfor (link = link_table, entry = table; entry->procname; link++, entry++) {\n\t\tint len = strlen(entry->procname) + 1;\n\t\tmemcpy(link_name, entry->procname, len);\n\t\tlink->procname = link_name;\n\t\tlink->mode = S_IFLNK|S_IRWXUGO;\n\t\tlink->data = link_root;\n\t\tlink_name += len;\n\t}\n\tinit_header(links, dir->header.root, dir->header.set, node, link_table);\n\tlinks->nreg = nr_entries;\n\n\treturn links;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void drop_sysctl_table(struct ctl_table_header *header);",
      "static void put_links(struct ctl_table_header *header);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_header",
          "args": [
            "links",
            "dir->header.root",
            "dir->header.set",
            "node",
            "link_table"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "init_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "157-176",
          "snippet": "static void init_header(struct ctl_table_header *head,\n\tstruct ctl_table_root *root, struct ctl_table_set *set,\n\tstruct ctl_node *node, struct ctl_table *table)\n{\n\thead->ctl_table = table;\n\thead->ctl_table_arg = table;\n\thead->used = 0;\n\thead->count = 1;\n\thead->nreg = 1;\n\thead->unregistering = NULL;\n\thead->root = root;\n\thead->set = set;\n\thead->parent = NULL;\n\thead->node = node;\n\tif (node) {\n\t\tstruct ctl_table *entry;\n\t\tfor (entry = table; entry->procname; entry++, node++)\n\t\t\tnode->header = head;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static int insert_links(struct ctl_table_header *head);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic int insert_links(struct ctl_table_header *head);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic void init_header(struct ctl_table_header *head,\n\tstruct ctl_table_root *root, struct ctl_table_set *set,\n\tstruct ctl_node *node, struct ctl_table *table)\n{\n\thead->ctl_table = table;\n\thead->ctl_table_arg = table;\n\thead->used = 0;\n\thead->count = 1;\n\thead->nreg = 1;\n\thead->unregistering = NULL;\n\thead->root = root;\n\thead->set = set;\n\thead->parent = NULL;\n\thead->node = node;\n\tif (node) {\n\t\tstruct ctl_table *entry;\n\t\tfor (entry = table; entry->procname; entry++, node++)\n\t\t\tnode->header = head;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "link_name",
            "entry->procname",
            "len"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "entry->procname"
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct ctl_table_header) +\n\t\t\tsizeof(struct ctl_node)*nr_entries +\n\t\t\tsizeof(struct ctl_table)*(nr_entries + 1) +\n\t\t\tname_bytes",
            "GFP_KERNEL"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic struct ctl_table_header *new_links(struct ctl_dir *dir, struct ctl_table *table,\n\tstruct ctl_table_root *link_root)\n{\n\tstruct ctl_table *link_table, *entry, *link;\n\tstruct ctl_table_header *links;\n\tstruct ctl_node *node;\n\tchar *link_name;\n\tint nr_entries, name_bytes;\n\n\tname_bytes = 0;\n\tnr_entries = 0;\n\tfor (entry = table; entry->procname; entry++) {\n\t\tnr_entries++;\n\t\tname_bytes += strlen(entry->procname) + 1;\n\t}\n\n\tlinks = kzalloc(sizeof(struct ctl_table_header) +\n\t\t\tsizeof(struct ctl_node)*nr_entries +\n\t\t\tsizeof(struct ctl_table)*(nr_entries + 1) +\n\t\t\tname_bytes,\n\t\t\tGFP_KERNEL);\n\n\tif (!links)\n\t\treturn NULL;\n\n\tnode = (struct ctl_node *)(links + 1);\n\tlink_table = (struct ctl_table *)(node + nr_entries);\n\tlink_name = (char *)&link_table[nr_entries + 1];\n\n\tfor (link = link_table, entry = table; entry->procname; link++, entry++) {\n\t\tint len = strlen(entry->procname) + 1;\n\t\tmemcpy(link_name, entry->procname, len);\n\t\tlink->procname = link_name;\n\t\tlink->mode = S_IFLNK|S_IRWXUGO;\n\t\tlink->data = link_root;\n\t\tlink_name += len;\n\t}\n\tinit_header(links, dir->header.root, dir->header.set, node, link_table);\n\tlinks->nreg = nr_entries;\n\n\treturn links;\n}"
  },
  {
    "function_name": "sysctl_check_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "990-1018",
    "snippet": "static int sysctl_check_table(const char *path, struct ctl_table *table)\n{\n\tint err = 0;\n\tfor (; table->procname; table++) {\n\t\tif (table->child)\n\t\t\terr = sysctl_err(path, table, \"Not a file\");\n\n\t\tif ((table->proc_handler == proc_dostring) ||\n\t\t    (table->proc_handler == proc_dointvec) ||\n\t\t    (table->proc_handler == proc_dointvec_minmax) ||\n\t\t    (table->proc_handler == proc_dointvec_jiffies) ||\n\t\t    (table->proc_handler == proc_dointvec_userhz_jiffies) ||\n\t\t    (table->proc_handler == proc_dointvec_ms_jiffies) ||\n\t\t    (table->proc_handler == proc_doulongvec_minmax) ||\n\t\t    (table->proc_handler == proc_doulongvec_ms_jiffies_minmax)) {\n\t\t\tif (!table->data)\n\t\t\t\terr = sysctl_err(path, table, \"No data\");\n\t\t\tif (!table->maxlen)\n\t\t\t\terr = sysctl_err(path, table, \"No maxlen\");\n\t\t}\n\t\tif (!table->proc_handler)\n\t\t\terr = sysctl_err(path, table, \"No proc_handler\");\n\n\t\tif ((table->mode & (S_IRUGO|S_IWUGO)) != table->mode)\n\t\t\terr = sysctl_err(path, table, \"bogus .mode 0%o\",\n\t\t\t\ttable->mode);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysctl_err",
          "args": [
            "path",
            "table",
            "\"bogus .mode 0%o\"",
            "table->mode"
          ],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "sysctl_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "974-988",
          "snippet": "static int sysctl_err(const char *path, struct ctl_table *table, char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"sysctl table check failed: %s/%s %pV\\n\",\n\t       path, table->procname, &vaf);\n\n\tva_end(args);\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic int sysctl_err(const char *path, struct ctl_table *table, char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"sysctl table check failed: %s/%s %pV\\n\",\n\t       path, table->procname, &vaf);\n\n\tva_end(args);\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic int sysctl_check_table(const char *path, struct ctl_table *table)\n{\n\tint err = 0;\n\tfor (; table->procname; table++) {\n\t\tif (table->child)\n\t\t\terr = sysctl_err(path, table, \"Not a file\");\n\n\t\tif ((table->proc_handler == proc_dostring) ||\n\t\t    (table->proc_handler == proc_dointvec) ||\n\t\t    (table->proc_handler == proc_dointvec_minmax) ||\n\t\t    (table->proc_handler == proc_dointvec_jiffies) ||\n\t\t    (table->proc_handler == proc_dointvec_userhz_jiffies) ||\n\t\t    (table->proc_handler == proc_dointvec_ms_jiffies) ||\n\t\t    (table->proc_handler == proc_doulongvec_minmax) ||\n\t\t    (table->proc_handler == proc_doulongvec_ms_jiffies_minmax)) {\n\t\t\tif (!table->data)\n\t\t\t\terr = sysctl_err(path, table, \"No data\");\n\t\t\tif (!table->maxlen)\n\t\t\t\terr = sysctl_err(path, table, \"No maxlen\");\n\t\t}\n\t\tif (!table->proc_handler)\n\t\t\terr = sysctl_err(path, table, \"No proc_handler\");\n\n\t\tif ((table->mode & (S_IRUGO|S_IWUGO)) != table->mode)\n\t\t\terr = sysctl_err(path, table, \"bogus .mode 0%o\",\n\t\t\t\ttable->mode);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "sysctl_err",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "974-988",
    "snippet": "static int sysctl_err(const char *path, struct ctl_table *table, char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"sysctl table check failed: %s/%s %pV\\n\",\n\t       path, table->procname, &vaf);\n\n\tva_end(args);\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"sysctl table check failed: %s/%s %pV\\n\"",
            "path",
            "table->procname",
            "&vaf"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic int sysctl_err(const char *path, struct ctl_table *table, char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"sysctl table check failed: %s/%s %pV\\n\",\n\t       path, table->procname, &vaf);\n\n\tva_end(args);\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "sysctl_follow_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "940-972",
    "snippet": "static int sysctl_follow_link(struct ctl_table_header **phead,\n\tstruct ctl_table **pentry, struct nsproxy *namespaces)\n{\n\tstruct ctl_table_header *head;\n\tstruct ctl_table_root *root;\n\tstruct ctl_table_set *set;\n\tstruct ctl_table *entry;\n\tstruct ctl_dir *dir;\n\tint ret;\n\n\tret = 0;\n\tspin_lock(&sysctl_lock);\n\troot = (*pentry)->data;\n\tset = lookup_header_set(root, namespaces);\n\tdir = xlate_dir(set, (*phead)->parent);\n\tif (IS_ERR(dir))\n\t\tret = PTR_ERR(dir);\n\telse {\n\t\tconst char *procname = (*pentry)->procname;\n\t\thead = NULL;\n\t\tentry = find_entry(&head, dir, procname, strlen(procname));\n\t\tret = -ENOENT;\n\t\tif (entry && use_table(head)) {\n\t\t\tunuse_table(*phead);\n\t\t\t*phead = head;\n\t\t\t*pentry = entry;\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\tspin_unlock(&sysctl_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(sysctl_lock);",
      "static int sysctl_follow_link(struct ctl_table_header **phead,\n\tstruct ctl_table **pentry, struct nsproxy *namespaces);",
      "static int insert_links(struct ctl_table_header *head);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sysctl_lock"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "unuse_table",
          "args": [
            "*phead"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "unuse_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "220-225",
          "snippet": "static void unuse_table(struct ctl_table_header *p)\n{\n\tif (!--p->used)\n\t\tif (unlikely(p->unregistering))\n\t\t\tcomplete(p->unregistering);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void unuse_table(struct ctl_table_header *p)\n{\n\tif (!--p->used)\n\t\tif (unlikely(p->unregistering))\n\t\t\tcomplete(p->unregistering);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_entry",
          "args": [
            "&head",
            "dir",
            "procname",
            "strlen(procname)"
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "80-109",
          "snippet": "static struct ctl_table *find_entry(struct ctl_table_header **phead,\n\tstruct ctl_dir *dir, const char *name, int namelen)\n{\n\tstruct ctl_table_header *head;\n\tstruct ctl_table *entry;\n\tstruct rb_node *node = dir->root.rb_node;\n\n\twhile (node)\n\t{\n\t\tstruct ctl_node *ctl_node;\n\t\tconst char *procname;\n\t\tint cmp;\n\n\t\tctl_node = rb_entry(node, struct ctl_node, node);\n\t\thead = ctl_node->header;\n\t\tentry = &head->ctl_table[ctl_node - head->node];\n\t\tprocname = entry->procname;\n\n\t\tcmp = namecmp(name, namelen, procname, strlen(procname));\n\t\tif (cmp < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (cmp > 0)\n\t\t\tnode = node->rb_right;\n\t\telse {\n\t\t\t*phead = head;\n\t\t\treturn entry;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static int insert_links(struct ctl_table_header *head);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic int insert_links(struct ctl_table_header *head);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic struct ctl_table *find_entry(struct ctl_table_header **phead,\n\tstruct ctl_dir *dir, const char *name, int namelen)\n{\n\tstruct ctl_table_header *head;\n\tstruct ctl_table *entry;\n\tstruct rb_node *node = dir->root.rb_node;\n\n\twhile (node)\n\t{\n\t\tstruct ctl_node *ctl_node;\n\t\tconst char *procname;\n\t\tint cmp;\n\n\t\tctl_node = rb_entry(node, struct ctl_node, node);\n\t\thead = ctl_node->header;\n\t\tentry = &head->ctl_table[ctl_node - head->node];\n\t\tprocname = entry->procname;\n\n\t\tcmp = namecmp(name, namelen, procname, strlen(procname));\n\t\tif (cmp < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (cmp > 0)\n\t\t\tnode = node->rb_right;\n\t\telse {\n\t\t\t*phead = head;\n\t\t\treturn entry;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "procname"
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dir"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dir"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlate_dir",
          "args": [
            "set",
            "(*phead)->parent"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "xlate_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "927-938",
          "snippet": "static struct ctl_dir *xlate_dir(struct ctl_table_set *set, struct ctl_dir *dir)\n{\n\tstruct ctl_dir *parent;\n\tconst char *procname;\n\tif (!dir->header.parent)\n\t\treturn &set->dir;\n\tparent = xlate_dir(set, dir->header.parent);\n\tif (IS_ERR(parent))\n\t\treturn parent;\n\tprocname = dir->header.ctl_table[0].procname;\n\treturn find_subdir(parent, procname, strlen(procname));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic struct ctl_dir *xlate_dir(struct ctl_table_set *set, struct ctl_dir *dir)\n{\n\tstruct ctl_dir *parent;\n\tconst char *procname;\n\tif (!dir->header.parent)\n\t\treturn &set->dir;\n\tparent = xlate_dir(set, dir->header.parent);\n\tif (IS_ERR(parent))\n\t\treturn parent;\n\tprocname = dir->header.ctl_table[0].procname;\n\treturn find_subdir(parent, procname, strlen(procname));\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_header_set",
          "args": [
            "root",
            "namespaces"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_header_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "286-293",
          "snippet": "static struct ctl_table_set *\nlookup_header_set(struct ctl_table_root *root, struct nsproxy *namespaces)\n{\n\tstruct ctl_table_set *set = &root->default_set;\n\tif (root->lookup)\n\t\tset = root->lookup(root, namespaces);\n\treturn set;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int sysctl_follow_link(struct ctl_table_header **phead,\n\tstruct ctl_table **pentry, struct nsproxy *namespaces);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic int sysctl_follow_link(struct ctl_table_header **phead,\n\tstruct ctl_table **pentry, struct nsproxy *namespaces);\n\nstatic struct ctl_table_set *\nlookup_header_set(struct ctl_table_root *root, struct nsproxy *namespaces)\n{\n\tstruct ctl_table_set *set = &root->default_set;\n\tif (root->lookup)\n\t\tset = root->lookup(root, namespaces);\n\treturn set;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sysctl_lock"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(sysctl_lock);\nstatic int sysctl_follow_link(struct ctl_table_header **phead,\n\tstruct ctl_table **pentry, struct nsproxy *namespaces);\nstatic int insert_links(struct ctl_table_header *head);\n\nstatic int sysctl_follow_link(struct ctl_table_header **phead,\n\tstruct ctl_table **pentry, struct nsproxy *namespaces)\n{\n\tstruct ctl_table_header *head;\n\tstruct ctl_table_root *root;\n\tstruct ctl_table_set *set;\n\tstruct ctl_table *entry;\n\tstruct ctl_dir *dir;\n\tint ret;\n\n\tret = 0;\n\tspin_lock(&sysctl_lock);\n\troot = (*pentry)->data;\n\tset = lookup_header_set(root, namespaces);\n\tdir = xlate_dir(set, (*phead)->parent);\n\tif (IS_ERR(dir))\n\t\tret = PTR_ERR(dir);\n\telse {\n\t\tconst char *procname = (*pentry)->procname;\n\t\thead = NULL;\n\t\tentry = find_entry(&head, dir, procname, strlen(procname));\n\t\tret = -ENOENT;\n\t\tif (entry && use_table(head)) {\n\t\t\tunuse_table(*phead);\n\t\t\t*phead = head;\n\t\t\t*pentry = entry;\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\tspin_unlock(&sysctl_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "xlate_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "927-938",
    "snippet": "static struct ctl_dir *xlate_dir(struct ctl_table_set *set, struct ctl_dir *dir)\n{\n\tstruct ctl_dir *parent;\n\tconst char *procname;\n\tif (!dir->header.parent)\n\t\treturn &set->dir;\n\tparent = xlate_dir(set, dir->header.parent);\n\tif (IS_ERR(parent))\n\t\treturn parent;\n\tprocname = dir->header.ctl_table[0].procname;\n\treturn find_subdir(parent, procname, strlen(procname));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void drop_sysctl_table(struct ctl_table_header *header);",
      "static void put_links(struct ctl_table_header *header);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_subdir",
          "args": [
            "parent",
            "procname",
            "strlen(procname)"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "find_subdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "825-837",
          "snippet": "static struct ctl_dir *find_subdir(struct ctl_dir *dir,\n\t\t\t\t   const char *name, int namelen)\n{\n\tstruct ctl_table_header *head;\n\tstruct ctl_table *entry;\n\n\tentry = find_entry(&head, dir, name, namelen);\n\tif (!entry)\n\t\treturn ERR_PTR(-ENOENT);\n\tif (!S_ISDIR(entry->mode))\n\t\treturn ERR_PTR(-ENOTDIR);\n\treturn container_of(head, struct ctl_dir, header);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static int insert_links(struct ctl_table_header *head);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic int insert_links(struct ctl_table_header *head);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic struct ctl_dir *find_subdir(struct ctl_dir *dir,\n\t\t\t\t   const char *name, int namelen)\n{\n\tstruct ctl_table_header *head;\n\tstruct ctl_table *entry;\n\n\tentry = find_entry(&head, dir, name, namelen);\n\tif (!entry)\n\t\treturn ERR_PTR(-ENOENT);\n\tif (!S_ISDIR(entry->mode))\n\t\treturn ERR_PTR(-ENOTDIR);\n\treturn container_of(head, struct ctl_dir, header);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "procname"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "parent"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlate_dir",
          "args": [
            "set",
            "dir->header.parent"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "xlate_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "927-938",
          "snippet": "static struct ctl_dir *xlate_dir(struct ctl_table_set *set, struct ctl_dir *dir)\n{\n\tstruct ctl_dir *parent;\n\tconst char *procname;\n\tif (!dir->header.parent)\n\t\treturn &set->dir;\n\tparent = xlate_dir(set, dir->header.parent);\n\tif (IS_ERR(parent))\n\t\treturn parent;\n\tprocname = dir->header.ctl_table[0].procname;\n\treturn find_subdir(parent, procname, strlen(procname));\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic struct ctl_dir *xlate_dir(struct ctl_table_set *set, struct ctl_dir *dir)\n{\n\tstruct ctl_dir *parent;\n\tconst char *procname;\n\tif (!dir->header.parent)\n\t\treturn &set->dir;\n\tparent = xlate_dir(set, dir->header.parent);\n\tif (IS_ERR(parent))\n\t\treturn parent;\n\tprocname = dir->header.ctl_table[0].procname;\n\treturn find_subdir(parent, procname, strlen(procname));\n}"
  },
  {
    "function_name": "get_subdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "877-925",
    "snippet": "static struct ctl_dir *get_subdir(struct ctl_dir *dir,\n\t\t\t\t  const char *name, int namelen)\n{\n\tstruct ctl_table_set *set = dir->header.set;\n\tstruct ctl_dir *subdir, *new = NULL;\n\tint err;\n\n\tspin_lock(&sysctl_lock);\n\tsubdir = find_subdir(dir, name, namelen);\n\tif (!IS_ERR(subdir))\n\t\tgoto found;\n\tif (PTR_ERR(subdir) != -ENOENT)\n\t\tgoto failed;\n\n\tspin_unlock(&sysctl_lock);\n\tnew = new_dir(set, name, namelen);\n\tspin_lock(&sysctl_lock);\n\tsubdir = ERR_PTR(-ENOMEM);\n\tif (!new)\n\t\tgoto failed;\n\n\t/* Was the subdir added while we dropped the lock? */\n\tsubdir = find_subdir(dir, name, namelen);\n\tif (!IS_ERR(subdir))\n\t\tgoto found;\n\tif (PTR_ERR(subdir) != -ENOENT)\n\t\tgoto failed;\n\n\t/* Nope.  Use the our freshly made directory entry. */\n\terr = insert_header(dir, &new->header);\n\tsubdir = ERR_PTR(err);\n\tif (err)\n\t\tgoto failed;\n\tsubdir = new;\nfound:\n\tsubdir->header.nreg++;\nfailed:\n\tif (unlikely(IS_ERR(subdir))) {\n\t\tpr_err(\"sysctl could not get directory: \");\n\t\tsysctl_print_dir(dir);\n\t\tpr_cont(\"/%*.*s %ld\\n\",\n\t\t\tnamelen, namelen, name, PTR_ERR(subdir));\n\t}\n\tdrop_sysctl_table(&dir->header);\n\tif (new)\n\t\tdrop_sysctl_table(&new->header);\n\tspin_unlock(&sysctl_lock);\n\treturn subdir;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(sysctl_lock);",
      "static void drop_sysctl_table(struct ctl_table_header *header);",
      "static void put_links(struct ctl_table_header *header);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sysctl_lock"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_sysctl_table",
          "args": [
            "&new->header"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "drop_sysctl_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "1505-1519",
          "snippet": "static void drop_sysctl_table(struct ctl_table_header *header)\n{\n\tstruct ctl_dir *parent = header->parent;\n\n\tif (--header->nreg)\n\t\treturn;\n\n\tput_links(header);\n\tstart_unregistering(header);\n\tif (!--header->count)\n\t\tkfree_rcu(header, rcu);\n\n\tif (parent)\n\t\tdrop_sysctl_table(&parent->header);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic void drop_sysctl_table(struct ctl_table_header *header)\n{\n\tstruct ctl_dir *parent = header->parent;\n\n\tif (--header->nreg)\n\t\treturn;\n\n\tput_links(header);\n\tstart_unregistering(header);\n\tif (!--header->count)\n\t\tkfree_rcu(header, rcu);\n\n\tif (parent)\n\t\tdrop_sysctl_table(&parent->header);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"/%*.*s %ld\\n\"",
            "namelen",
            "namelen",
            "name",
            "PTR_ERR(subdir)"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "subdir"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysctl_print_dir",
          "args": [
            "dir"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "sysctl_print_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "57-62",
          "snippet": "static void sysctl_print_dir(struct ctl_dir *dir)\n{\n\tif (dir->header.parent)\n\t\tsysctl_print_dir(dir->header.parent);\n\tpr_cont(\"%s/\", dir->header.ctl_table[0].procname);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic void sysctl_print_dir(struct ctl_dir *dir)\n{\n\tif (dir->header.parent)\n\t\tsysctl_print_dir(dir->header.parent);\n\tpr_cont(\"%s/\", dir->header.ctl_table[0].procname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"sysctl could not get directory: \""
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "IS_ERR(subdir)"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "subdir"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "insert_header",
          "args": [
            "dir",
            "&new->header"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "insert_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "185-208",
          "snippet": "static int insert_header(struct ctl_dir *dir, struct ctl_table_header *header)\n{\n\tstruct ctl_table *entry;\n\tint err;\n\n\tdir->header.nreg++;\n\theader->parent = dir;\n\terr = insert_links(header);\n\tif (err)\n\t\tgoto fail_links;\n\tfor (entry = header->ctl_table; entry->procname; entry++) {\n\t\terr = insert_entry(header, entry);\n\t\tif (err)\n\t\t\tgoto fail;\n\t}\n\treturn 0;\nfail:\n\terase_header(header);\n\tput_links(header);\nfail_links:\n\theader->parent = NULL;\n\tdrop_sysctl_table(&dir->header);\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic int insert_header(struct ctl_dir *dir, struct ctl_table_header *header)\n{\n\tstruct ctl_table *entry;\n\tint err;\n\n\tdir->header.nreg++;\n\theader->parent = dir;\n\terr = insert_links(header);\n\tif (err)\n\t\tgoto fail_links;\n\tfor (entry = header->ctl_table; entry->procname; entry++) {\n\t\terr = insert_entry(header, entry);\n\t\tif (err)\n\t\t\tgoto fail;\n\t}\n\treturn 0;\nfail:\n\terase_header(header);\n\tput_links(header);\nfail_links:\n\theader->parent = NULL;\n\tdrop_sysctl_table(&dir->header);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "subdir"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "subdir"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_subdir",
          "args": [
            "dir",
            "name",
            "namelen"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "find_subdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "825-837",
          "snippet": "static struct ctl_dir *find_subdir(struct ctl_dir *dir,\n\t\t\t\t   const char *name, int namelen)\n{\n\tstruct ctl_table_header *head;\n\tstruct ctl_table *entry;\n\n\tentry = find_entry(&head, dir, name, namelen);\n\tif (!entry)\n\t\treturn ERR_PTR(-ENOENT);\n\tif (!S_ISDIR(entry->mode))\n\t\treturn ERR_PTR(-ENOTDIR);\n\treturn container_of(head, struct ctl_dir, header);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static int insert_links(struct ctl_table_header *head);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic int insert_links(struct ctl_table_header *head);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic struct ctl_dir *find_subdir(struct ctl_dir *dir,\n\t\t\t\t   const char *name, int namelen)\n{\n\tstruct ctl_table_header *head;\n\tstruct ctl_table *entry;\n\n\tentry = find_entry(&head, dir, name, namelen);\n\tif (!entry)\n\t\treturn ERR_PTR(-ENOENT);\n\tif (!S_ISDIR(entry->mode))\n\t\treturn ERR_PTR(-ENOTDIR);\n\treturn container_of(head, struct ctl_dir, header);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sysctl_lock"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_dir",
          "args": [
            "set",
            "name",
            "namelen"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "new_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "839-863",
          "snippet": "static struct ctl_dir *new_dir(struct ctl_table_set *set,\n\t\t\t       const char *name, int namelen)\n{\n\tstruct ctl_table *table;\n\tstruct ctl_dir *new;\n\tstruct ctl_node *node;\n\tchar *new_name;\n\n\tnew = kzalloc(sizeof(*new) + sizeof(struct ctl_node) +\n\t\t      sizeof(struct ctl_table)*2 +  namelen + 1,\n\t\t      GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\tnode = (struct ctl_node *)(new + 1);\n\ttable = (struct ctl_table *)(node + 1);\n\tnew_name = (char *)(table + 2);\n\tmemcpy(new_name, name, namelen);\n\tnew_name[namelen] = '\\0';\n\ttable[0].procname = new_name;\n\ttable[0].mode = S_IFDIR|S_IRUGO|S_IXUGO;\n\tinit_header(&new->header, set->dir.header.root, set, node, table);\n\n\treturn new;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic struct ctl_dir *new_dir(struct ctl_table_set *set,\n\t\t\t       const char *name, int namelen)\n{\n\tstruct ctl_table *table;\n\tstruct ctl_dir *new;\n\tstruct ctl_node *node;\n\tchar *new_name;\n\n\tnew = kzalloc(sizeof(*new) + sizeof(struct ctl_node) +\n\t\t      sizeof(struct ctl_table)*2 +  namelen + 1,\n\t\t      GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\tnode = (struct ctl_node *)(new + 1);\n\ttable = (struct ctl_table *)(node + 1);\n\tnew_name = (char *)(table + 2);\n\tmemcpy(new_name, name, namelen);\n\tnew_name[namelen] = '\\0';\n\ttable[0].procname = new_name;\n\ttable[0].mode = S_IFDIR|S_IRUGO|S_IXUGO;\n\tinit_header(&new->header, set->dir.header.root, set, node, table);\n\n\treturn new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "subdir"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "subdir"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(sysctl_lock);\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic struct ctl_dir *get_subdir(struct ctl_dir *dir,\n\t\t\t\t  const char *name, int namelen)\n{\n\tstruct ctl_table_set *set = dir->header.set;\n\tstruct ctl_dir *subdir, *new = NULL;\n\tint err;\n\n\tspin_lock(&sysctl_lock);\n\tsubdir = find_subdir(dir, name, namelen);\n\tif (!IS_ERR(subdir))\n\t\tgoto found;\n\tif (PTR_ERR(subdir) != -ENOENT)\n\t\tgoto failed;\n\n\tspin_unlock(&sysctl_lock);\n\tnew = new_dir(set, name, namelen);\n\tspin_lock(&sysctl_lock);\n\tsubdir = ERR_PTR(-ENOMEM);\n\tif (!new)\n\t\tgoto failed;\n\n\t/* Was the subdir added while we dropped the lock? */\n\tsubdir = find_subdir(dir, name, namelen);\n\tif (!IS_ERR(subdir))\n\t\tgoto found;\n\tif (PTR_ERR(subdir) != -ENOENT)\n\t\tgoto failed;\n\n\t/* Nope.  Use the our freshly made directory entry. */\n\terr = insert_header(dir, &new->header);\n\tsubdir = ERR_PTR(err);\n\tif (err)\n\t\tgoto failed;\n\tsubdir = new;\nfound:\n\tsubdir->header.nreg++;\nfailed:\n\tif (unlikely(IS_ERR(subdir))) {\n\t\tpr_err(\"sysctl could not get directory: \");\n\t\tsysctl_print_dir(dir);\n\t\tpr_cont(\"/%*.*s %ld\\n\",\n\t\t\tnamelen, namelen, name, PTR_ERR(subdir));\n\t}\n\tdrop_sysctl_table(&dir->header);\n\tif (new)\n\t\tdrop_sysctl_table(&new->header);\n\tspin_unlock(&sysctl_lock);\n\treturn subdir;\n}"
  },
  {
    "function_name": "new_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "839-863",
    "snippet": "static struct ctl_dir *new_dir(struct ctl_table_set *set,\n\t\t\t       const char *name, int namelen)\n{\n\tstruct ctl_table *table;\n\tstruct ctl_dir *new;\n\tstruct ctl_node *node;\n\tchar *new_name;\n\n\tnew = kzalloc(sizeof(*new) + sizeof(struct ctl_node) +\n\t\t      sizeof(struct ctl_table)*2 +  namelen + 1,\n\t\t      GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\tnode = (struct ctl_node *)(new + 1);\n\ttable = (struct ctl_table *)(node + 1);\n\tnew_name = (char *)(table + 2);\n\tmemcpy(new_name, name, namelen);\n\tnew_name[namelen] = '\\0';\n\ttable[0].procname = new_name;\n\ttable[0].mode = S_IFDIR|S_IRUGO|S_IXUGO;\n\tinit_header(&new->header, set->dir.header.root, set, node, table);\n\n\treturn new;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void drop_sysctl_table(struct ctl_table_header *header);",
      "static void put_links(struct ctl_table_header *header);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_header",
          "args": [
            "&new->header",
            "set->dir.header.root",
            "set",
            "node",
            "table"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "init_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "157-176",
          "snippet": "static void init_header(struct ctl_table_header *head,\n\tstruct ctl_table_root *root, struct ctl_table_set *set,\n\tstruct ctl_node *node, struct ctl_table *table)\n{\n\thead->ctl_table = table;\n\thead->ctl_table_arg = table;\n\thead->used = 0;\n\thead->count = 1;\n\thead->nreg = 1;\n\thead->unregistering = NULL;\n\thead->root = root;\n\thead->set = set;\n\thead->parent = NULL;\n\thead->node = node;\n\tif (node) {\n\t\tstruct ctl_table *entry;\n\t\tfor (entry = table; entry->procname; entry++, node++)\n\t\t\tnode->header = head;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static int insert_links(struct ctl_table_header *head);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic int insert_links(struct ctl_table_header *head);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic void init_header(struct ctl_table_header *head,\n\tstruct ctl_table_root *root, struct ctl_table_set *set,\n\tstruct ctl_node *node, struct ctl_table *table)\n{\n\thead->ctl_table = table;\n\thead->ctl_table_arg = table;\n\thead->used = 0;\n\thead->count = 1;\n\thead->nreg = 1;\n\thead->unregistering = NULL;\n\thead->root = root;\n\thead->set = set;\n\thead->parent = NULL;\n\thead->node = node;\n\tif (node) {\n\t\tstruct ctl_table *entry;\n\t\tfor (entry = table; entry->procname; entry++, node++)\n\t\t\tnode->header = head;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new_name",
            "name",
            "namelen"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*new) + sizeof(struct ctl_node) +\n\t\t      sizeof(struct ctl_table)*2 +  namelen + 1",
            "GFP_KERNEL"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic struct ctl_dir *new_dir(struct ctl_table_set *set,\n\t\t\t       const char *name, int namelen)\n{\n\tstruct ctl_table *table;\n\tstruct ctl_dir *new;\n\tstruct ctl_node *node;\n\tchar *new_name;\n\n\tnew = kzalloc(sizeof(*new) + sizeof(struct ctl_node) +\n\t\t      sizeof(struct ctl_table)*2 +  namelen + 1,\n\t\t      GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\tnode = (struct ctl_node *)(new + 1);\n\ttable = (struct ctl_table *)(node + 1);\n\tnew_name = (char *)(table + 2);\n\tmemcpy(new_name, name, namelen);\n\tnew_name[namelen] = '\\0';\n\ttable[0].procname = new_name;\n\ttable[0].mode = S_IFDIR|S_IRUGO|S_IXUGO;\n\tinit_header(&new->header, set->dir.header.root, set, node, table);\n\n\treturn new;\n}"
  },
  {
    "function_name": "find_subdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "825-837",
    "snippet": "static struct ctl_dir *find_subdir(struct ctl_dir *dir,\n\t\t\t\t   const char *name, int namelen)\n{\n\tstruct ctl_table_header *head;\n\tstruct ctl_table *entry;\n\n\tentry = find_entry(&head, dir, name, namelen);\n\tif (!entry)\n\t\treturn ERR_PTR(-ENOENT);\n\tif (!S_ISDIR(entry->mode))\n\t\treturn ERR_PTR(-ENOTDIR);\n\treturn container_of(head, struct ctl_dir, header);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void drop_sysctl_table(struct ctl_table_header *header);",
      "static int insert_links(struct ctl_table_header *head);",
      "static void put_links(struct ctl_table_header *header);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structctl_dir",
            "header"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOTDIR"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "entry->mode"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_entry",
          "args": [
            "&head",
            "dir",
            "name",
            "namelen"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "80-109",
          "snippet": "static struct ctl_table *find_entry(struct ctl_table_header **phead,\n\tstruct ctl_dir *dir, const char *name, int namelen)\n{\n\tstruct ctl_table_header *head;\n\tstruct ctl_table *entry;\n\tstruct rb_node *node = dir->root.rb_node;\n\n\twhile (node)\n\t{\n\t\tstruct ctl_node *ctl_node;\n\t\tconst char *procname;\n\t\tint cmp;\n\n\t\tctl_node = rb_entry(node, struct ctl_node, node);\n\t\thead = ctl_node->header;\n\t\tentry = &head->ctl_table[ctl_node - head->node];\n\t\tprocname = entry->procname;\n\n\t\tcmp = namecmp(name, namelen, procname, strlen(procname));\n\t\tif (cmp < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (cmp > 0)\n\t\t\tnode = node->rb_right;\n\t\telse {\n\t\t\t*phead = head;\n\t\t\treturn entry;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static int insert_links(struct ctl_table_header *head);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic int insert_links(struct ctl_table_header *head);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic struct ctl_table *find_entry(struct ctl_table_header **phead,\n\tstruct ctl_dir *dir, const char *name, int namelen)\n{\n\tstruct ctl_table_header *head;\n\tstruct ctl_table *entry;\n\tstruct rb_node *node = dir->root.rb_node;\n\n\twhile (node)\n\t{\n\t\tstruct ctl_node *ctl_node;\n\t\tconst char *procname;\n\t\tint cmp;\n\n\t\tctl_node = rb_entry(node, struct ctl_node, node);\n\t\thead = ctl_node->header;\n\t\tentry = &head->ctl_table[ctl_node - head->node];\n\t\tprocname = entry->procname;\n\n\t\tcmp = namecmp(name, namelen, procname, strlen(procname));\n\t\tif (cmp < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (cmp > 0)\n\t\t\tnode = node->rb_right;\n\t\telse {\n\t\t\t*phead = head;\n\t\t\treturn entry;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic int insert_links(struct ctl_table_header *head);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic struct ctl_dir *find_subdir(struct ctl_dir *dir,\n\t\t\t\t   const char *name, int namelen)\n{\n\tstruct ctl_table_header *head;\n\tstruct ctl_table *entry;\n\n\tentry = find_entry(&head, dir, name, namelen);\n\tif (!entry)\n\t\treturn ERR_PTR(-ENOENT);\n\tif (!S_ISDIR(entry->mode))\n\t\treturn ERR_PTR(-ENOTDIR);\n\treturn container_of(head, struct ctl_dir, header);\n}"
  },
  {
    "function_name": "proc_sys_compare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "799-817",
    "snippet": "static int proc_sys_compare(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\tstruct ctl_table_header *head;\n\tstruct inode *inode;\n\n\t/* Although proc doesn't have negative dentries, rcu-walk means\n\t * that inode here can be NULL */\n\t/* AV: can it, indeed? */\n\tinode = ACCESS_ONCE(dentry->d_inode);\n\tif (!inode)\n\t\treturn 1;\n\tif (name->len != len)\n\t\treturn 1;\n\tif (memcmp(name->name, str, len))\n\t\treturn 1;\n\thead = rcu_dereference(PROC_I(inode)->sysctl);\n\treturn !head || !sysctl_is_seen(head);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int insert_links(struct ctl_table_header *head);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysctl_is_seen",
          "args": [
            "head"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "sysctl_is_seen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "784-797",
          "snippet": "static int sysctl_is_seen(struct ctl_table_header *p)\n{\n\tstruct ctl_table_set *set = p->set;\n\tint res;\n\tspin_lock(&sysctl_lock);\n\tif (p->unregistering)\n\t\tres = 0;\n\telse if (!set->is_seen)\n\t\tres = 1;\n\telse\n\t\tres = set->is_seen(set);\n\tspin_unlock(&sysctl_lock);\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(sysctl_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(sysctl_lock);\n\nstatic int sysctl_is_seen(struct ctl_table_header *p)\n{\n\tstruct ctl_table_set *set = p->set;\n\tint res;\n\tspin_lock(&sysctl_lock);\n\tif (p->unregistering)\n\t\tres = 0;\n\telse if (!set->is_seen)\n\t\tres = 1;\n\telse\n\t\tres = set->is_seen(set);\n\tspin_unlock(&sysctl_lock);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "PROC_I(inode)->sysctl"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROC_I",
          "args": [
            "inode"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "PROC_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "75-78",
          "snippet": "static inline struct proc_inode *PROC_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct proc_inode, vfs_inode);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nstatic inline struct proc_inode *PROC_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct proc_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "name->name",
            "str",
            "len"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACCESS_ONCE",
          "args": [
            "dentry->d_inode"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic int insert_links(struct ctl_table_header *head);\n\nstatic int proc_sys_compare(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\tstruct ctl_table_header *head;\n\tstruct inode *inode;\n\n\t/* Although proc doesn't have negative dentries, rcu-walk means\n\t * that inode here can be NULL */\n\t/* AV: can it, indeed? */\n\tinode = ACCESS_ONCE(dentry->d_inode);\n\tif (!inode)\n\t\treturn 1;\n\tif (name->len != len)\n\t\treturn 1;\n\tif (memcmp(name->name, str, len))\n\t\treturn 1;\n\thead = rcu_dereference(PROC_I(inode)->sysctl);\n\treturn !head || !sysctl_is_seen(head);\n}"
  },
  {
    "function_name": "sysctl_is_seen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "784-797",
    "snippet": "static int sysctl_is_seen(struct ctl_table_header *p)\n{\n\tstruct ctl_table_set *set = p->set;\n\tint res;\n\tspin_lock(&sysctl_lock);\n\tif (p->unregistering)\n\t\tres = 0;\n\telse if (!set->is_seen)\n\t\tres = 1;\n\telse\n\t\tres = set->is_seen(set);\n\tspin_unlock(&sysctl_lock);\n\treturn res;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(sysctl_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sysctl_lock"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "set->is_seen",
          "args": [
            "set"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sysctl_lock"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(sysctl_lock);\n\nstatic int sysctl_is_seen(struct ctl_table_header *p)\n{\n\tstruct ctl_table_set *set = p->set;\n\tint res;\n\tspin_lock(&sysctl_lock);\n\tif (p->unregistering)\n\t\tres = 0;\n\telse if (!set->is_seen)\n\t\tres = 1;\n\telse\n\t\tres = set->is_seen(set);\n\tspin_unlock(&sysctl_lock);\n\treturn res;\n}"
  },
  {
    "function_name": "proc_sys_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "779-782",
    "snippet": "static int proc_sys_delete(const struct dentry *dentry)\n{\n\treturn !!PROC_I(dentry->d_inode)->sysctl->unregistering;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PROC_I",
          "args": [
            "dentry->d_inode"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "PROC_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "75-78",
          "snippet": "static inline struct proc_inode *PROC_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct proc_inode, vfs_inode);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nstatic inline struct proc_inode *PROC_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct proc_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic int proc_sys_delete(const struct dentry *dentry)\n{\n\treturn !!PROC_I(dentry->d_inode)->sysctl->unregistering;\n}"
  },
  {
    "function_name": "proc_sys_revalidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "772-777",
    "snippet": "static int proc_sys_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\treturn !PROC_I(dentry->d_inode)->sysctl->unregistering;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PROC_I",
          "args": [
            "dentry->d_inode"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "PROC_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "75-78",
          "snippet": "static inline struct proc_inode *PROC_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct proc_inode, vfs_inode);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nstatic inline struct proc_inode *PROC_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct proc_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic int proc_sys_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\treturn !PROC_I(dentry->d_inode)->sysctl->unregistering;\n}"
  },
  {
    "function_name": "proc_sys_getattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "728-743",
    "snippet": "static int proc_sys_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ctl_table_header *head = grab_header(inode);\n\tstruct ctl_table *table = PROC_I(inode)->sysctl_entry;\n\n\tif (IS_ERR(head))\n\t\treturn PTR_ERR(head);\n\n\tgeneric_fillattr(inode, stat);\n\tif (table)\n\t\tstat->mode = (stat->mode & S_IFMT) | table->mode;\n\n\tsysctl_head_finish(head);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int insert_links(struct ctl_table_header *head);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysctl_head_finish",
          "args": [
            "head"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "sysctl_head_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "277-284",
          "snippet": "static void sysctl_head_finish(struct ctl_table_header *head)\n{\n\tif (!head)\n\t\treturn;\n\tspin_lock(&sysctl_lock);\n\tunuse_table(head);\n\tspin_unlock(&sysctl_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(sysctl_lock);",
            "static int insert_links(struct ctl_table_header *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(sysctl_lock);\nstatic int insert_links(struct ctl_table_header *head);\n\nstatic void sysctl_head_finish(struct ctl_table_header *head)\n{\n\tif (!head)\n\t\treturn;\n\tspin_lock(&sysctl_lock);\n\tunuse_table(head);\n\tspin_unlock(&sysctl_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_fillattr",
          "args": [
            "inode",
            "stat"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "generic_fillattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "21-36",
          "snippet": "void generic_fillattr(struct inode *inode, struct kstat *stat)\n{\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = inode->i_ino;\n\tstat->mode = inode->i_mode;\n\tstat->nlink = inode->i_nlink;\n\tstat->uid = inode->i_uid;\n\tstat->gid = inode->i_gid;\n\tstat->rdev = inode->i_rdev;\n\tstat->size = i_size_read(inode);\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode->i_ctime;\n\tstat->blksize = (1 << inode->i_blkbits);\n\tstat->blocks = inode->i_blocks;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid generic_fillattr(struct inode *inode, struct kstat *stat)\n{\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = inode->i_ino;\n\tstat->mode = inode->i_mode;\n\tstat->nlink = inode->i_nlink;\n\tstat->uid = inode->i_uid;\n\tstat->gid = inode->i_gid;\n\tstat->rdev = inode->i_rdev;\n\tstat->size = i_size_read(inode);\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode->i_ctime;\n\tstat->blksize = (1 << inode->i_blkbits);\n\tstat->blocks = inode->i_blocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "head"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "head"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROC_I",
          "args": [
            "inode"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "PROC_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "75-78",
          "snippet": "static inline struct proc_inode *PROC_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct proc_inode, vfs_inode);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nstatic inline struct proc_inode *PROC_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct proc_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "grab_header",
          "args": [
            "inode"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "grab_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "427-433",
          "snippet": "static struct ctl_table_header *grab_header(struct inode *inode)\n{\n\tstruct ctl_table_header *head = PROC_I(inode)->sysctl;\n\tif (!head)\n\t\thead = &sysctl_table_root.default_set.dir.header;\n\treturn sysctl_head_grab(head);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ctl_table_root sysctl_table_root = {\n\t.default_set.dir.header = {\n\t\t{{.count = 1,\n\t\t  .nreg = 1,\n\t\t  .ctl_table = root_table }},\n\t\t.ctl_table_arg = root_table,\n\t\t.root = &sysctl_table_root,\n\t\t.set = &sysctl_table_root.default_set,\n\t},\n};",
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static int insert_links(struct ctl_table_header *head);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic struct ctl_table_root sysctl_table_root = {\n\t.default_set.dir.header = {\n\t\t{{.count = 1,\n\t\t  .nreg = 1,\n\t\t  .ctl_table = root_table }},\n\t\t.ctl_table_arg = root_table,\n\t\t.root = &sysctl_table_root,\n\t\t.set = &sysctl_table_root.default_set,\n\t},\n};\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic int insert_links(struct ctl_table_header *head);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic struct ctl_table_header *grab_header(struct inode *inode)\n{\n\tstruct ctl_table_header *head = PROC_I(inode)->sysctl;\n\tif (!head)\n\t\thead = &sysctl_table_root.default_set.dir.header;\n\treturn sysctl_head_grab(head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic int insert_links(struct ctl_table_header *head);\n\nstatic int proc_sys_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ctl_table_header *head = grab_header(inode);\n\tstruct ctl_table *table = PROC_I(inode)->sysctl_entry;\n\n\tif (IS_ERR(head))\n\t\treturn PTR_ERR(head);\n\n\tgeneric_fillattr(inode, stat);\n\tif (table)\n\t\tstat->mode = (stat->mode & S_IFMT) | table->mode;\n\n\tsysctl_head_finish(head);\n\treturn 0;\n}"
  },
  {
    "function_name": "proc_sys_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "711-726",
    "snippet": "static int proc_sys_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\tif (attr->ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID))\n\t\treturn -EPERM;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "setattr_copy",
          "args": [
            "inode",
            "attr"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "setattr_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "142-167",
          "snippet": "void setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nvoid setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_change_ok",
          "args": [
            "inode",
            "attr"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "inode_change_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "31-81",
          "snippet": "int inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic int proc_sys_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\tif (attr->ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID))\n\t\treturn -EPERM;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}"
  },
  {
    "function_name": "proc_sys_permission",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "683-709",
    "snippet": "static int proc_sys_permission(struct inode *inode, int mask)\n{\n\t/*\n\t * sysctl entries that are not writeable,\n\t * are _NOT_ writeable, capabilities or not.\n\t */\n\tstruct ctl_table_header *head;\n\tstruct ctl_table *table;\n\tint error;\n\n\t/* Executable files are not allowed under /proc/sys/ */\n\tif ((mask & MAY_EXEC) && S_ISREG(inode->i_mode))\n\t\treturn -EACCES;\n\n\thead = grab_header(inode);\n\tif (IS_ERR(head))\n\t\treturn PTR_ERR(head);\n\n\ttable = PROC_I(inode)->sysctl_entry;\n\tif (!table) /* global root - r-xr-xr-x */\n\t\terror = mask & MAY_WRITE ? -EACCES : 0;\n\telse /* Use the permissions on the sysctl table entry */\n\t\terror = sysctl_perm(head, table, mask & ~MAY_NOT_BLOCK);\n\n\tsysctl_head_finish(head);\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int insert_links(struct ctl_table_header *head);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysctl_head_finish",
          "args": [
            "head"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "sysctl_head_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "277-284",
          "snippet": "static void sysctl_head_finish(struct ctl_table_header *head)\n{\n\tif (!head)\n\t\treturn;\n\tspin_lock(&sysctl_lock);\n\tunuse_table(head);\n\tspin_unlock(&sysctl_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(sysctl_lock);",
            "static int insert_links(struct ctl_table_header *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(sysctl_lock);\nstatic int insert_links(struct ctl_table_header *head);\n\nstatic void sysctl_head_finish(struct ctl_table_header *head)\n{\n\tif (!head)\n\t\treturn;\n\tspin_lock(&sysctl_lock);\n\tunuse_table(head);\n\tspin_unlock(&sysctl_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysctl_perm",
          "args": [
            "head",
            "table",
            "mask & ~MAY_NOT_BLOCK"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "sysctl_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "382-393",
          "snippet": "static int sysctl_perm(struct ctl_table_header *head, struct ctl_table *table, int op)\n{\n\tstruct ctl_table_root *root = head->root;\n\tint mode;\n\n\tif (root->permissions)\n\t\tmode = root->permissions(head, table);\n\telse\n\t\tmode = table->mode;\n\n\treturn test_perm(mode, op);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int insert_links(struct ctl_table_header *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic int insert_links(struct ctl_table_header *head);\n\nstatic int sysctl_perm(struct ctl_table_header *head, struct ctl_table *table, int op)\n{\n\tstruct ctl_table_root *root = head->root;\n\tint mode;\n\n\tif (root->permissions)\n\t\tmode = root->permissions(head, table);\n\telse\n\t\tmode = table->mode;\n\n\treturn test_perm(mode, op);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PROC_I",
          "args": [
            "inode"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "PROC_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "75-78",
          "snippet": "static inline struct proc_inode *PROC_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct proc_inode, vfs_inode);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nstatic inline struct proc_inode *PROC_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct proc_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "head"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "head"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_header",
          "args": [
            "inode"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "grab_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "427-433",
          "snippet": "static struct ctl_table_header *grab_header(struct inode *inode)\n{\n\tstruct ctl_table_header *head = PROC_I(inode)->sysctl;\n\tif (!head)\n\t\thead = &sysctl_table_root.default_set.dir.header;\n\treturn sysctl_head_grab(head);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ctl_table_root sysctl_table_root = {\n\t.default_set.dir.header = {\n\t\t{{.count = 1,\n\t\t  .nreg = 1,\n\t\t  .ctl_table = root_table }},\n\t\t.ctl_table_arg = root_table,\n\t\t.root = &sysctl_table_root,\n\t\t.set = &sysctl_table_root.default_set,\n\t},\n};",
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static int insert_links(struct ctl_table_header *head);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic struct ctl_table_root sysctl_table_root = {\n\t.default_set.dir.header = {\n\t\t{{.count = 1,\n\t\t  .nreg = 1,\n\t\t  .ctl_table = root_table }},\n\t\t.ctl_table_arg = root_table,\n\t\t.root = &sysctl_table_root,\n\t\t.set = &sysctl_table_root.default_set,\n\t},\n};\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic int insert_links(struct ctl_table_header *head);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic struct ctl_table_header *grab_header(struct inode *inode)\n{\n\tstruct ctl_table_header *head = PROC_I(inode)->sysctl;\n\tif (!head)\n\t\thead = &sysctl_table_root.default_set.dir.header;\n\treturn sysctl_head_grab(head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic int insert_links(struct ctl_table_header *head);\n\nstatic int proc_sys_permission(struct inode *inode, int mask)\n{\n\t/*\n\t * sysctl entries that are not writeable,\n\t * are _NOT_ writeable, capabilities or not.\n\t */\n\tstruct ctl_table_header *head;\n\tstruct ctl_table *table;\n\tint error;\n\n\t/* Executable files are not allowed under /proc/sys/ */\n\tif ((mask & MAY_EXEC) && S_ISREG(inode->i_mode))\n\t\treturn -EACCES;\n\n\thead = grab_header(inode);\n\tif (IS_ERR(head))\n\t\treturn PTR_ERR(head);\n\n\ttable = PROC_I(inode)->sysctl_entry;\n\tif (!table) /* global root - r-xr-xr-x */\n\t\terror = mask & MAY_WRITE ? -EACCES : 0;\n\telse /* Use the permissions on the sysctl table entry */\n\t\terror = sysctl_perm(head, table, mask & ~MAY_NOT_BLOCK);\n\n\tsysctl_head_finish(head);\n\treturn error;\n}"
  },
  {
    "function_name": "proc_sys_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "655-681",
    "snippet": "static int proc_sys_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct ctl_table_header *head = grab_header(file_inode(file));\n\tstruct ctl_table_header *h = NULL;\n\tstruct ctl_table *entry;\n\tstruct ctl_dir *ctl_dir;\n\tunsigned long pos;\n\n\tif (IS_ERR(head))\n\t\treturn PTR_ERR(head);\n\n\tctl_dir = container_of(head, struct ctl_dir, header);\n\n\tif (!dir_emit_dots(file, ctx))\n\t\treturn 0;\n\n\tpos = 2;\n\n\tfor (first_entry(ctl_dir, &h, &entry); h; next_entry(&h, &entry)) {\n\t\tif (!scan(h, entry, &pos, file, ctx)) {\n\t\t\tsysctl_head_finish(h);\n\t\t\tbreak;\n\t\t}\n\t}\n\tsysctl_head_finish(head);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void drop_sysctl_table(struct ctl_table_header *header);",
      "static int insert_links(struct ctl_table_header *head);",
      "static void put_links(struct ctl_table_header *header);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysctl_head_finish",
          "args": [
            "head"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "sysctl_head_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "277-284",
          "snippet": "static void sysctl_head_finish(struct ctl_table_header *head)\n{\n\tif (!head)\n\t\treturn;\n\tspin_lock(&sysctl_lock);\n\tunuse_table(head);\n\tspin_unlock(&sysctl_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(sysctl_lock);",
            "static int insert_links(struct ctl_table_header *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(sysctl_lock);\nstatic int insert_links(struct ctl_table_header *head);\n\nstatic void sysctl_head_finish(struct ctl_table_header *head)\n{\n\tif (!head)\n\t\treturn;\n\tspin_lock(&sysctl_lock);\n\tunuse_table(head);\n\tspin_unlock(&sysctl_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "scan",
          "args": [
            "h",
            "entry",
            "&pos",
            "file",
            "ctx"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "scan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "635-653",
          "snippet": "static int scan(struct ctl_table_header *head, struct ctl_table *table,\n\t\tunsigned long *pos, struct file *file,\n\t\tstruct dir_context *ctx)\n{\n\tbool res;\n\n\tif ((*pos)++ < ctx->pos)\n\t\treturn true;\n\n\tif (unlikely(S_ISLNK(table->mode)))\n\t\tres = proc_sys_link_fill_cache(file, ctx, head, table);\n\telse\n\t\tres = proc_sys_fill_cache(file, ctx, head, table);\n\n\tif (res)\n\t\tctx->pos = *pos;\n\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int insert_links(struct ctl_table_header *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic int insert_links(struct ctl_table_header *head);\n\nstatic int scan(struct ctl_table_header *head, struct ctl_table *table,\n\t\tunsigned long *pos, struct file *file,\n\t\tstruct dir_context *ctx)\n{\n\tbool res;\n\n\tif ((*pos)++ < ctx->pos)\n\t\treturn true;\n\n\tif (unlikely(S_ISLNK(table->mode)))\n\t\tres = proc_sys_link_fill_cache(file, ctx, head, table);\n\telse\n\t\tres = proc_sys_fill_cache(file, ctx, head, table);\n\n\tif (res)\n\t\tctx->pos = *pos;\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "next_entry",
          "args": [
            "&h",
            "&entry"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "342-360",
          "snippet": "static void next_entry(struct ctl_table_header **phead, struct ctl_table **pentry)\n{\n\tstruct ctl_table_header *head = *phead;\n\tstruct ctl_table *entry = *pentry;\n\tstruct ctl_node *ctl_node = &head->node[entry - head->ctl_table];\n\n\tspin_lock(&sysctl_lock);\n\tunuse_table(head);\n\n\tctl_node = first_usable_entry(rb_next(&ctl_node->node));\n\tspin_unlock(&sysctl_lock);\n\thead = NULL;\n\tif (ctl_node) {\n\t\thead = ctl_node->header;\n\t\tentry = &head->ctl_table[ctl_node - head->node];\n\t}\n\t*phead = head;\n\t*pentry = entry;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(sysctl_lock);",
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static int insert_links(struct ctl_table_header *head);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(sysctl_lock);\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic int insert_links(struct ctl_table_header *head);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic void next_entry(struct ctl_table_header **phead, struct ctl_table **pentry)\n{\n\tstruct ctl_table_header *head = *phead;\n\tstruct ctl_table *entry = *pentry;\n\tstruct ctl_node *ctl_node = &head->node[entry - head->ctl_table];\n\n\tspin_lock(&sysctl_lock);\n\tunuse_table(head);\n\n\tctl_node = first_usable_entry(rb_next(&ctl_node->node));\n\tspin_unlock(&sysctl_lock);\n\thead = NULL;\n\tif (ctl_node) {\n\t\thead = ctl_node->header;\n\t\tentry = &head->ctl_table[ctl_node - head->node];\n\t}\n\t*phead = head;\n\t*pentry = entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "first_entry",
          "args": [
            "ctl_dir",
            "&h",
            "&entry"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "first_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "324-340",
          "snippet": "static void first_entry(struct ctl_dir *dir,\n\tstruct ctl_table_header **phead, struct ctl_table **pentry)\n{\n\tstruct ctl_table_header *head = NULL;\n\tstruct ctl_table *entry = NULL;\n\tstruct ctl_node *ctl_node;\n\n\tspin_lock(&sysctl_lock);\n\tctl_node = first_usable_entry(rb_first(&dir->root));\n\tspin_unlock(&sysctl_lock);\n\tif (ctl_node) {\n\t\thead = ctl_node->header;\n\t\tentry = &head->ctl_table[ctl_node - head->node];\n\t}\n\t*phead = head;\n\t*pentry = entry;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(sysctl_lock);",
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static int insert_links(struct ctl_table_header *head);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(sysctl_lock);\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic int insert_links(struct ctl_table_header *head);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic void first_entry(struct ctl_dir *dir,\n\tstruct ctl_table_header **phead, struct ctl_table **pentry)\n{\n\tstruct ctl_table_header *head = NULL;\n\tstruct ctl_table *entry = NULL;\n\tstruct ctl_node *ctl_node;\n\n\tspin_lock(&sysctl_lock);\n\tctl_node = first_usable_entry(rb_first(&dir->root));\n\tspin_unlock(&sysctl_lock);\n\tif (ctl_node) {\n\t\thead = ctl_node->header;\n\t\tentry = &head->ctl_table[ctl_node - head->node];\n\t}\n\t*phead = head;\n\t*pentry = entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_emit_dots",
          "args": [
            "file",
            "ctx"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structctl_dir",
            "header"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "head"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "head"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_header",
          "args": [
            "file_inode(file)"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "grab_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "427-433",
          "snippet": "static struct ctl_table_header *grab_header(struct inode *inode)\n{\n\tstruct ctl_table_header *head = PROC_I(inode)->sysctl;\n\tif (!head)\n\t\thead = &sysctl_table_root.default_set.dir.header;\n\treturn sysctl_head_grab(head);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ctl_table_root sysctl_table_root = {\n\t.default_set.dir.header = {\n\t\t{{.count = 1,\n\t\t  .nreg = 1,\n\t\t  .ctl_table = root_table }},\n\t\t.ctl_table_arg = root_table,\n\t\t.root = &sysctl_table_root,\n\t\t.set = &sysctl_table_root.default_set,\n\t},\n};",
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static int insert_links(struct ctl_table_header *head);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic struct ctl_table_root sysctl_table_root = {\n\t.default_set.dir.header = {\n\t\t{{.count = 1,\n\t\t  .nreg = 1,\n\t\t  .ctl_table = root_table }},\n\t\t.ctl_table_arg = root_table,\n\t\t.root = &sysctl_table_root,\n\t\t.set = &sysctl_table_root.default_set,\n\t},\n};\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic int insert_links(struct ctl_table_header *head);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic struct ctl_table_header *grab_header(struct inode *inode)\n{\n\tstruct ctl_table_header *head = PROC_I(inode)->sysctl;\n\tif (!head)\n\t\thead = &sysctl_table_root.default_set.dir.header;\n\treturn sysctl_head_grab(head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic int insert_links(struct ctl_table_header *head);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic int proc_sys_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct ctl_table_header *head = grab_header(file_inode(file));\n\tstruct ctl_table_header *h = NULL;\n\tstruct ctl_table *entry;\n\tstruct ctl_dir *ctl_dir;\n\tunsigned long pos;\n\n\tif (IS_ERR(head))\n\t\treturn PTR_ERR(head);\n\n\tctl_dir = container_of(head, struct ctl_dir, header);\n\n\tif (!dir_emit_dots(file, ctx))\n\t\treturn 0;\n\n\tpos = 2;\n\n\tfor (first_entry(ctl_dir, &h, &entry); h; next_entry(&h, &entry)) {\n\t\tif (!scan(h, entry, &pos, file, ctx)) {\n\t\t\tsysctl_head_finish(h);\n\t\t\tbreak;\n\t\t}\n\t}\n\tsysctl_head_finish(head);\n\treturn 0;\n}"
  },
  {
    "function_name": "scan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "635-653",
    "snippet": "static int scan(struct ctl_table_header *head, struct ctl_table *table,\n\t\tunsigned long *pos, struct file *file,\n\t\tstruct dir_context *ctx)\n{\n\tbool res;\n\n\tif ((*pos)++ < ctx->pos)\n\t\treturn true;\n\n\tif (unlikely(S_ISLNK(table->mode)))\n\t\tres = proc_sys_link_fill_cache(file, ctx, head, table);\n\telse\n\t\tres = proc_sys_fill_cache(file, ctx, head, table);\n\n\tif (res)\n\t\tctx->pos = *pos;\n\n\treturn res;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int insert_links(struct ctl_table_header *head);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_sys_fill_cache",
          "args": [
            "file",
            "ctx",
            "head",
            "table"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "proc_sys_fill_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "576-612",
          "snippet": "static bool proc_sys_fill_cache(struct file *file,\n\t\t\t\tstruct dir_context *ctx,\n\t\t\t\tstruct ctl_table_header *head,\n\t\t\t\tstruct ctl_table *table)\n{\n\tstruct dentry *child, *dir = file->f_path.dentry;\n\tstruct inode *inode;\n\tstruct qstr qname;\n\tino_t ino = 0;\n\tunsigned type = DT_UNKNOWN;\n\n\tqname.name = table->procname;\n\tqname.len  = strlen(table->procname);\n\tqname.hash = full_name_hash(qname.name, qname.len);\n\n\tchild = d_lookup(dir, &qname);\n\tif (!child) {\n\t\tchild = d_alloc(dir, &qname);\n\t\tif (child) {\n\t\t\tinode = proc_sys_make_inode(dir->d_sb, head, table);\n\t\t\tif (!inode) {\n\t\t\t\tdput(child);\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\td_set_d_op(child, &proc_sys_dentry_operations);\n\t\t\t\td_add(child, inode);\n\t\t\t}\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\tinode = child->d_inode;\n\tino  = inode->i_ino;\n\ttype = inode->i_mode >> 12;\n\tdput(child);\n\treturn dir_emit(ctx, qname.name, qname.len, ino, type);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct dentry_operations proc_sys_dentry_operations;",
            "static int insert_links(struct ctl_table_header *head);",
            "static const struct dentry_operations proc_sys_dentry_operations = {\n\t.d_revalidate\t= proc_sys_revalidate,\n\t.d_delete\t= proc_sys_delete,\n\t.d_compare\t= proc_sys_compare,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic const struct dentry_operations proc_sys_dentry_operations;\nstatic int insert_links(struct ctl_table_header *head);\nstatic const struct dentry_operations proc_sys_dentry_operations = {\n\t.d_revalidate\t= proc_sys_revalidate,\n\t.d_delete\t= proc_sys_delete,\n\t.d_compare\t= proc_sys_compare,\n};\n\nstatic bool proc_sys_fill_cache(struct file *file,\n\t\t\t\tstruct dir_context *ctx,\n\t\t\t\tstruct ctl_table_header *head,\n\t\t\t\tstruct ctl_table *table)\n{\n\tstruct dentry *child, *dir = file->f_path.dentry;\n\tstruct inode *inode;\n\tstruct qstr qname;\n\tino_t ino = 0;\n\tunsigned type = DT_UNKNOWN;\n\n\tqname.name = table->procname;\n\tqname.len  = strlen(table->procname);\n\tqname.hash = full_name_hash(qname.name, qname.len);\n\n\tchild = d_lookup(dir, &qname);\n\tif (!child) {\n\t\tchild = d_alloc(dir, &qname);\n\t\tif (child) {\n\t\t\tinode = proc_sys_make_inode(dir->d_sb, head, table);\n\t\t\tif (!inode) {\n\t\t\t\tdput(child);\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\td_set_d_op(child, &proc_sys_dentry_operations);\n\t\t\t\td_add(child, inode);\n\t\t\t}\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\tinode = child->d_inode;\n\tino  = inode->i_ino;\n\ttype = inode->i_mode >> 12;\n\tdput(child);\n\treturn dir_emit(ctx, qname.name, qname.len, ino, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_sys_link_fill_cache",
          "args": [
            "file",
            "ctx",
            "head",
            "table"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "proc_sys_link_fill_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "614-633",
          "snippet": "static bool proc_sys_link_fill_cache(struct file *file,\n\t\t\t\t    struct dir_context *ctx,\n\t\t\t\t    struct ctl_table_header *head,\n\t\t\t\t    struct ctl_table *table)\n{\n\tbool ret = true;\n\thead = sysctl_head_grab(head);\n\n\tif (S_ISLNK(table->mode)) {\n\t\t/* It is not an error if we can not follow the link ignore it */\n\t\tint err = sysctl_follow_link(&head, &table, current->nsproxy);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tret = proc_sys_fill_cache(file, ctx, head, table);\nout:\n\tsysctl_head_finish(head);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int insert_links(struct ctl_table_header *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic int insert_links(struct ctl_table_header *head);\n\nstatic bool proc_sys_link_fill_cache(struct file *file,\n\t\t\t\t    struct dir_context *ctx,\n\t\t\t\t    struct ctl_table_header *head,\n\t\t\t\t    struct ctl_table *table)\n{\n\tbool ret = true;\n\thead = sysctl_head_grab(head);\n\n\tif (S_ISLNK(table->mode)) {\n\t\t/* It is not an error if we can not follow the link ignore it */\n\t\tint err = sysctl_follow_link(&head, &table, current->nsproxy);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tret = proc_sys_fill_cache(file, ctx, head, table);\nout:\n\tsysctl_head_finish(head);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "S_ISLNK(table->mode)"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "table->mode"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic int insert_links(struct ctl_table_header *head);\n\nstatic int scan(struct ctl_table_header *head, struct ctl_table *table,\n\t\tunsigned long *pos, struct file *file,\n\t\tstruct dir_context *ctx)\n{\n\tbool res;\n\n\tif ((*pos)++ < ctx->pos)\n\t\treturn true;\n\n\tif (unlikely(S_ISLNK(table->mode)))\n\t\tres = proc_sys_link_fill_cache(file, ctx, head, table);\n\telse\n\t\tres = proc_sys_fill_cache(file, ctx, head, table);\n\n\tif (res)\n\t\tctx->pos = *pos;\n\n\treturn res;\n}"
  },
  {
    "function_name": "proc_sys_link_fill_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "614-633",
    "snippet": "static bool proc_sys_link_fill_cache(struct file *file,\n\t\t\t\t    struct dir_context *ctx,\n\t\t\t\t    struct ctl_table_header *head,\n\t\t\t\t    struct ctl_table *table)\n{\n\tbool ret = true;\n\thead = sysctl_head_grab(head);\n\n\tif (S_ISLNK(table->mode)) {\n\t\t/* It is not an error if we can not follow the link ignore it */\n\t\tint err = sysctl_follow_link(&head, &table, current->nsproxy);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tret = proc_sys_fill_cache(file, ctx, head, table);\nout:\n\tsysctl_head_finish(head);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int insert_links(struct ctl_table_header *head);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysctl_head_finish",
          "args": [
            "head"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "sysctl_head_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "277-284",
          "snippet": "static void sysctl_head_finish(struct ctl_table_header *head)\n{\n\tif (!head)\n\t\treturn;\n\tspin_lock(&sysctl_lock);\n\tunuse_table(head);\n\tspin_unlock(&sysctl_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(sysctl_lock);",
            "static int insert_links(struct ctl_table_header *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(sysctl_lock);\nstatic int insert_links(struct ctl_table_header *head);\n\nstatic void sysctl_head_finish(struct ctl_table_header *head)\n{\n\tif (!head)\n\t\treturn;\n\tspin_lock(&sysctl_lock);\n\tunuse_table(head);\n\tspin_unlock(&sysctl_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_sys_fill_cache",
          "args": [
            "file",
            "ctx",
            "head",
            "table"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "proc_sys_fill_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "576-612",
          "snippet": "static bool proc_sys_fill_cache(struct file *file,\n\t\t\t\tstruct dir_context *ctx,\n\t\t\t\tstruct ctl_table_header *head,\n\t\t\t\tstruct ctl_table *table)\n{\n\tstruct dentry *child, *dir = file->f_path.dentry;\n\tstruct inode *inode;\n\tstruct qstr qname;\n\tino_t ino = 0;\n\tunsigned type = DT_UNKNOWN;\n\n\tqname.name = table->procname;\n\tqname.len  = strlen(table->procname);\n\tqname.hash = full_name_hash(qname.name, qname.len);\n\n\tchild = d_lookup(dir, &qname);\n\tif (!child) {\n\t\tchild = d_alloc(dir, &qname);\n\t\tif (child) {\n\t\t\tinode = proc_sys_make_inode(dir->d_sb, head, table);\n\t\t\tif (!inode) {\n\t\t\t\tdput(child);\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\td_set_d_op(child, &proc_sys_dentry_operations);\n\t\t\t\td_add(child, inode);\n\t\t\t}\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\tinode = child->d_inode;\n\tino  = inode->i_ino;\n\ttype = inode->i_mode >> 12;\n\tdput(child);\n\treturn dir_emit(ctx, qname.name, qname.len, ino, type);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct dentry_operations proc_sys_dentry_operations;",
            "static int insert_links(struct ctl_table_header *head);",
            "static const struct dentry_operations proc_sys_dentry_operations = {\n\t.d_revalidate\t= proc_sys_revalidate,\n\t.d_delete\t= proc_sys_delete,\n\t.d_compare\t= proc_sys_compare,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic const struct dentry_operations proc_sys_dentry_operations;\nstatic int insert_links(struct ctl_table_header *head);\nstatic const struct dentry_operations proc_sys_dentry_operations = {\n\t.d_revalidate\t= proc_sys_revalidate,\n\t.d_delete\t= proc_sys_delete,\n\t.d_compare\t= proc_sys_compare,\n};\n\nstatic bool proc_sys_fill_cache(struct file *file,\n\t\t\t\tstruct dir_context *ctx,\n\t\t\t\tstruct ctl_table_header *head,\n\t\t\t\tstruct ctl_table *table)\n{\n\tstruct dentry *child, *dir = file->f_path.dentry;\n\tstruct inode *inode;\n\tstruct qstr qname;\n\tino_t ino = 0;\n\tunsigned type = DT_UNKNOWN;\n\n\tqname.name = table->procname;\n\tqname.len  = strlen(table->procname);\n\tqname.hash = full_name_hash(qname.name, qname.len);\n\n\tchild = d_lookup(dir, &qname);\n\tif (!child) {\n\t\tchild = d_alloc(dir, &qname);\n\t\tif (child) {\n\t\t\tinode = proc_sys_make_inode(dir->d_sb, head, table);\n\t\t\tif (!inode) {\n\t\t\t\tdput(child);\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\td_set_d_op(child, &proc_sys_dentry_operations);\n\t\t\t\td_add(child, inode);\n\t\t\t}\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\tinode = child->d_inode;\n\tino  = inode->i_ino;\n\ttype = inode->i_mode >> 12;\n\tdput(child);\n\treturn dir_emit(ctx, qname.name, qname.len, ino, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysctl_follow_link",
          "args": [
            "&head",
            "&table",
            "current->nsproxy"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "sysctl_follow_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "940-972",
          "snippet": "static int sysctl_follow_link(struct ctl_table_header **phead,\n\tstruct ctl_table **pentry, struct nsproxy *namespaces)\n{\n\tstruct ctl_table_header *head;\n\tstruct ctl_table_root *root;\n\tstruct ctl_table_set *set;\n\tstruct ctl_table *entry;\n\tstruct ctl_dir *dir;\n\tint ret;\n\n\tret = 0;\n\tspin_lock(&sysctl_lock);\n\troot = (*pentry)->data;\n\tset = lookup_header_set(root, namespaces);\n\tdir = xlate_dir(set, (*phead)->parent);\n\tif (IS_ERR(dir))\n\t\tret = PTR_ERR(dir);\n\telse {\n\t\tconst char *procname = (*pentry)->procname;\n\t\thead = NULL;\n\t\tentry = find_entry(&head, dir, procname, strlen(procname));\n\t\tret = -ENOENT;\n\t\tif (entry && use_table(head)) {\n\t\t\tunuse_table(*phead);\n\t\t\t*phead = head;\n\t\t\t*pentry = entry;\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\tspin_unlock(&sysctl_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(sysctl_lock);",
            "static int sysctl_follow_link(struct ctl_table_header **phead,\n\tstruct ctl_table **pentry, struct nsproxy *namespaces);",
            "static int insert_links(struct ctl_table_header *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(sysctl_lock);\nstatic int sysctl_follow_link(struct ctl_table_header **phead,\n\tstruct ctl_table **pentry, struct nsproxy *namespaces);\nstatic int insert_links(struct ctl_table_header *head);\n\nstatic int sysctl_follow_link(struct ctl_table_header **phead,\n\tstruct ctl_table **pentry, struct nsproxy *namespaces)\n{\n\tstruct ctl_table_header *head;\n\tstruct ctl_table_root *root;\n\tstruct ctl_table_set *set;\n\tstruct ctl_table *entry;\n\tstruct ctl_dir *dir;\n\tint ret;\n\n\tret = 0;\n\tspin_lock(&sysctl_lock);\n\troot = (*pentry)->data;\n\tset = lookup_header_set(root, namespaces);\n\tdir = xlate_dir(set, (*phead)->parent);\n\tif (IS_ERR(dir))\n\t\tret = PTR_ERR(dir);\n\telse {\n\t\tconst char *procname = (*pentry)->procname;\n\t\thead = NULL;\n\t\tentry = find_entry(&head, dir, procname, strlen(procname));\n\t\tret = -ENOENT;\n\t\tif (entry && use_table(head)) {\n\t\t\tunuse_table(*phead);\n\t\t\t*phead = head;\n\t\t\t*pentry = entry;\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\tspin_unlock(&sysctl_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "table->mode"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysctl_head_grab",
          "args": [
            "head"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "sysctl_head_grab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "267-275",
          "snippet": "static struct ctl_table_header *sysctl_head_grab(struct ctl_table_header *head)\n{\n\tBUG_ON(!head);\n\tspin_lock(&sysctl_lock);\n\tif (!use_table(head))\n\t\thead = ERR_PTR(-ENOENT);\n\tspin_unlock(&sysctl_lock);\n\treturn head;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(sysctl_lock);",
            "static int insert_links(struct ctl_table_header *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(sysctl_lock);\nstatic int insert_links(struct ctl_table_header *head);\n\nstatic struct ctl_table_header *sysctl_head_grab(struct ctl_table_header *head)\n{\n\tBUG_ON(!head);\n\tspin_lock(&sysctl_lock);\n\tif (!use_table(head))\n\t\thead = ERR_PTR(-ENOENT);\n\tspin_unlock(&sysctl_lock);\n\treturn head;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic int insert_links(struct ctl_table_header *head);\n\nstatic bool proc_sys_link_fill_cache(struct file *file,\n\t\t\t\t    struct dir_context *ctx,\n\t\t\t\t    struct ctl_table_header *head,\n\t\t\t\t    struct ctl_table *table)\n{\n\tbool ret = true;\n\thead = sysctl_head_grab(head);\n\n\tif (S_ISLNK(table->mode)) {\n\t\t/* It is not an error if we can not follow the link ignore it */\n\t\tint err = sysctl_follow_link(&head, &table, current->nsproxy);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tret = proc_sys_fill_cache(file, ctx, head, table);\nout:\n\tsysctl_head_finish(head);\n\treturn ret;\n}"
  },
  {
    "function_name": "proc_sys_fill_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "576-612",
    "snippet": "static bool proc_sys_fill_cache(struct file *file,\n\t\t\t\tstruct dir_context *ctx,\n\t\t\t\tstruct ctl_table_header *head,\n\t\t\t\tstruct ctl_table *table)\n{\n\tstruct dentry *child, *dir = file->f_path.dentry;\n\tstruct inode *inode;\n\tstruct qstr qname;\n\tino_t ino = 0;\n\tunsigned type = DT_UNKNOWN;\n\n\tqname.name = table->procname;\n\tqname.len  = strlen(table->procname);\n\tqname.hash = full_name_hash(qname.name, qname.len);\n\n\tchild = d_lookup(dir, &qname);\n\tif (!child) {\n\t\tchild = d_alloc(dir, &qname);\n\t\tif (child) {\n\t\t\tinode = proc_sys_make_inode(dir->d_sb, head, table);\n\t\t\tif (!inode) {\n\t\t\t\tdput(child);\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\td_set_d_op(child, &proc_sys_dentry_operations);\n\t\t\t\td_add(child, inode);\n\t\t\t}\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\tinode = child->d_inode;\n\tino  = inode->i_ino;\n\ttype = inode->i_mode >> 12;\n\tdput(child);\n\treturn dir_emit(ctx, qname.name, qname.len, ino, type);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct dentry_operations proc_sys_dentry_operations;",
      "static int insert_links(struct ctl_table_header *head);",
      "static const struct dentry_operations proc_sys_dentry_operations = {\n\t.d_revalidate\t= proc_sys_revalidate,\n\t.d_delete\t= proc_sys_delete,\n\t.d_compare\t= proc_sys_compare,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "qname.name",
            "qname.len",
            "ino",
            "type"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "child"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "child",
            "inode"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_set_d_op",
          "args": [
            "child",
            "&proc_sys_dentry_operations"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "d_set_d_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1635-1659",
          "snippet": "void d_set_d_op(struct dentry *dentry, const struct dentry_operations *op)\n{\n\tWARN_ON_ONCE(dentry->d_op);\n\tWARN_ON_ONCE(dentry->d_flags & (DCACHE_OP_HASH\t|\n\t\t\t\tDCACHE_OP_COMPARE\t|\n\t\t\t\tDCACHE_OP_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_WEAK_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_DELETE ));\n\tdentry->d_op = op;\n\tif (!op)\n\t\treturn;\n\tif (op->d_hash)\n\t\tdentry->d_flags |= DCACHE_OP_HASH;\n\tif (op->d_compare)\n\t\tdentry->d_flags |= DCACHE_OP_COMPARE;\n\tif (op->d_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_REVALIDATE;\n\tif (op->d_weak_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_WEAK_REVALIDATE;\n\tif (op->d_delete)\n\t\tdentry->d_flags |= DCACHE_OP_DELETE;\n\tif (op->d_prune)\n\t\tdentry->d_flags |= DCACHE_OP_PRUNE;\n\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid d_set_d_op(struct dentry *dentry, const struct dentry_operations *op)\n{\n\tWARN_ON_ONCE(dentry->d_op);\n\tWARN_ON_ONCE(dentry->d_flags & (DCACHE_OP_HASH\t|\n\t\t\t\tDCACHE_OP_COMPARE\t|\n\t\t\t\tDCACHE_OP_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_WEAK_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_DELETE ));\n\tdentry->d_op = op;\n\tif (!op)\n\t\treturn;\n\tif (op->d_hash)\n\t\tdentry->d_flags |= DCACHE_OP_HASH;\n\tif (op->d_compare)\n\t\tdentry->d_flags |= DCACHE_OP_COMPARE;\n\tif (op->d_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_REVALIDATE;\n\tif (op->d_weak_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_WEAK_REVALIDATE;\n\tif (op->d_delete)\n\t\tdentry->d_flags |= DCACHE_OP_DELETE;\n\tif (op->d_prune)\n\t\tdentry->d_flags |= DCACHE_OP_PRUNE;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_sys_make_inode",
          "args": [
            "dir->d_sb",
            "head",
            "table"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "proc_sys_make_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "395-425",
          "snippet": "static struct inode *proc_sys_make_inode(struct super_block *sb,\n\t\tstruct ctl_table_header *head, struct ctl_table *table)\n{\n\tstruct inode *inode;\n\tstruct proc_inode *ei;\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\tgoto out;\n\n\tinode->i_ino = get_next_ino();\n\n\tsysctl_head_get(head);\n\tei = PROC_I(inode);\n\tei->sysctl = head;\n\tei->sysctl_entry = table;\n\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_mode = table->mode;\n\tif (!S_ISDIR(table->mode)) {\n\t\tinode->i_mode |= S_IFREG;\n\t\tinode->i_op = &proc_sys_inode_operations;\n\t\tinode->i_fop = &proc_sys_file_operations;\n\t} else {\n\t\tinode->i_mode |= S_IFDIR;\n\t\tinode->i_op = &proc_sys_dir_operations;\n\t\tinode->i_fop = &proc_sys_dir_file_operations;\n\t}\nout:\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations proc_sys_file_operations;",
            "static const struct inode_operations proc_sys_inode_operations;",
            "static const struct file_operations proc_sys_dir_file_operations;",
            "static const struct inode_operations proc_sys_dir_operations;",
            "static int insert_links(struct ctl_table_header *head);",
            "static const struct file_operations proc_sys_file_operations = {\n\t.open\t\t= proc_sys_open,\n\t.poll\t\t= proc_sys_poll,\n\t.read\t\t= proc_sys_read,\n\t.write\t\t= proc_sys_write,\n\t.llseek\t\t= default_llseek,\n};",
            "static const struct file_operations proc_sys_dir_file_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= proc_sys_readdir,\n\t.llseek\t\t= generic_file_llseek,\n};",
            "static const struct inode_operations proc_sys_inode_operations = {\n\t.permission\t= proc_sys_permission,\n\t.setattr\t= proc_sys_setattr,\n\t.getattr\t= proc_sys_getattr,\n};",
            "static const struct inode_operations proc_sys_dir_operations = {\n\t.lookup\t\t= proc_sys_lookup,\n\t.permission\t= proc_sys_permission,\n\t.setattr\t= proc_sys_setattr,\n\t.getattr\t= proc_sys_getattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic const struct file_operations proc_sys_file_operations;\nstatic const struct inode_operations proc_sys_inode_operations;\nstatic const struct file_operations proc_sys_dir_file_operations;\nstatic const struct inode_operations proc_sys_dir_operations;\nstatic int insert_links(struct ctl_table_header *head);\nstatic const struct file_operations proc_sys_file_operations = {\n\t.open\t\t= proc_sys_open,\n\t.poll\t\t= proc_sys_poll,\n\t.read\t\t= proc_sys_read,\n\t.write\t\t= proc_sys_write,\n\t.llseek\t\t= default_llseek,\n};\nstatic const struct file_operations proc_sys_dir_file_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= proc_sys_readdir,\n\t.llseek\t\t= generic_file_llseek,\n};\nstatic const struct inode_operations proc_sys_inode_operations = {\n\t.permission\t= proc_sys_permission,\n\t.setattr\t= proc_sys_setattr,\n\t.getattr\t= proc_sys_getattr,\n};\nstatic const struct inode_operations proc_sys_dir_operations = {\n\t.lookup\t\t= proc_sys_lookup,\n\t.permission\t= proc_sys_permission,\n\t.setattr\t= proc_sys_setattr,\n\t.getattr\t= proc_sys_getattr,\n};\n\nstatic struct inode *proc_sys_make_inode(struct super_block *sb,\n\t\tstruct ctl_table_header *head, struct ctl_table *table)\n{\n\tstruct inode *inode;\n\tstruct proc_inode *ei;\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\tgoto out;\n\n\tinode->i_ino = get_next_ino();\n\n\tsysctl_head_get(head);\n\tei = PROC_I(inode);\n\tei->sysctl = head;\n\tei->sysctl_entry = table;\n\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_mode = table->mode;\n\tif (!S_ISDIR(table->mode)) {\n\t\tinode->i_mode |= S_IFREG;\n\t\tinode->i_op = &proc_sys_inode_operations;\n\t\tinode->i_fop = &proc_sys_file_operations;\n\t} else {\n\t\tinode->i_mode |= S_IFDIR;\n\t\tinode->i_op = &proc_sys_dir_operations;\n\t\tinode->i_fop = &proc_sys_dir_file_operations;\n\t}\nout:\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_alloc",
          "args": [
            "dir",
            "&qname"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "d_alloc_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1624-1632",
          "snippet": "struct dentry *d_alloc_name(struct dentry *parent, const char *name)\n{\n\tstruct qstr q;\n\n\tq.name = name;\n\tq.len = strlen(name);\n\tq.hash = full_name_hash(q.name, q.len);\n\treturn d_alloc(parent, &q);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_alloc_name(struct dentry *parent, const char *name)\n{\n\tstruct qstr q;\n\n\tq.name = name;\n\tq.len = strlen(name);\n\tq.hash = full_name_hash(q.name, q.len);\n\treturn d_alloc(parent, &q);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_lookup",
          "args": [
            "dir",
            "&qname"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "d_hash_and_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2312-2326",
          "snippet": "struct dentry *d_hash_and_lookup(struct dentry *dir, struct qstr *name)\n{\n\t/*\n\t * Check for a fs-specific hash function. Note that we must\n\t * calculate the standard hash first, as the d_op->d_hash()\n\t * routine may choose to leave the hash value unchanged.\n\t */\n\tname->hash = full_name_hash(name->name, name->len);\n\tif (dir->d_flags & DCACHE_OP_HASH) {\n\t\tint err = dir->d_op->d_hash(dir, name);\n\t\tif (unlikely(err < 0))\n\t\t\treturn ERR_PTR(err);\n\t}\n\treturn d_lookup(dir, name);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_hash_and_lookup(struct dentry *dir, struct qstr *name)\n{\n\t/*\n\t * Check for a fs-specific hash function. Note that we must\n\t * calculate the standard hash first, as the d_op->d_hash()\n\t * routine may choose to leave the hash value unchanged.\n\t */\n\tname->hash = full_name_hash(name->name, name->len);\n\tif (dir->d_flags & DCACHE_OP_HASH) {\n\t\tint err = dir->d_op->d_hash(dir, name);\n\t\tif (unlikely(err < 0))\n\t\t\treturn ERR_PTR(err);\n\t}\n\treturn d_lookup(dir, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "full_name_hash",
          "args": [
            "qname.name",
            "qname.len"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "full_name_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "1737-1743",
          "snippet": "unsigned int full_name_hash(const unsigned char *name, unsigned int len)\n{\n\tunsigned long hash = init_name_hash();\n\twhile (len--)\n\t\thash = partial_name_hash(*name++, hash);\n\treturn end_name_hash(hash);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nunsigned int full_name_hash(const unsigned char *name, unsigned int len)\n{\n\tunsigned long hash = init_name_hash();\n\twhile (len--)\n\t\thash = partial_name_hash(*name++, hash);\n\treturn end_name_hash(hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "table->procname"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic const struct dentry_operations proc_sys_dentry_operations;\nstatic int insert_links(struct ctl_table_header *head);\nstatic const struct dentry_operations proc_sys_dentry_operations = {\n\t.d_revalidate\t= proc_sys_revalidate,\n\t.d_delete\t= proc_sys_delete,\n\t.d_compare\t= proc_sys_compare,\n};\n\nstatic bool proc_sys_fill_cache(struct file *file,\n\t\t\t\tstruct dir_context *ctx,\n\t\t\t\tstruct ctl_table_header *head,\n\t\t\t\tstruct ctl_table *table)\n{\n\tstruct dentry *child, *dir = file->f_path.dentry;\n\tstruct inode *inode;\n\tstruct qstr qname;\n\tino_t ino = 0;\n\tunsigned type = DT_UNKNOWN;\n\n\tqname.name = table->procname;\n\tqname.len  = strlen(table->procname);\n\tqname.hash = full_name_hash(qname.name, qname.len);\n\n\tchild = d_lookup(dir, &qname);\n\tif (!child) {\n\t\tchild = d_alloc(dir, &qname);\n\t\tif (child) {\n\t\t\tinode = proc_sys_make_inode(dir->d_sb, head, table);\n\t\t\tif (!inode) {\n\t\t\t\tdput(child);\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\td_set_d_op(child, &proc_sys_dentry_operations);\n\t\t\t\td_add(child, inode);\n\t\t\t}\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\tinode = child->d_inode;\n\tino  = inode->i_ino;\n\ttype = inode->i_mode >> 12;\n\tdput(child);\n\treturn dir_emit(ctx, qname.name, qname.len, ino, type);\n}"
  },
  {
    "function_name": "proc_sys_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "544-574",
    "snippet": "static unsigned int proc_sys_poll(struct file *filp, poll_table *wait)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct ctl_table_header *head = grab_header(inode);\n\tstruct ctl_table *table = PROC_I(inode)->sysctl_entry;\n\tunsigned int ret = DEFAULT_POLLMASK;\n\tunsigned long event;\n\n\t/* sysctl was unregistered */\n\tif (IS_ERR(head))\n\t\treturn POLLERR | POLLHUP;\n\n\tif (!table->proc_handler)\n\t\tgoto out;\n\n\tif (!table->poll)\n\t\tgoto out;\n\n\tevent = (unsigned long)filp->private_data;\n\tpoll_wait(filp, &table->poll->wait, wait);\n\n\tif (event != atomic_read(&table->poll->event)) {\n\t\tfilp->private_data = proc_sys_poll_event(table->poll);\n\t\tret = POLLIN | POLLRDNORM | POLLERR | POLLPRI;\n\t}\n\nout:\n\tsysctl_head_finish(head);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int insert_links(struct ctl_table_header *head);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysctl_head_finish",
          "args": [
            "head"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "sysctl_head_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "277-284",
          "snippet": "static void sysctl_head_finish(struct ctl_table_header *head)\n{\n\tif (!head)\n\t\treturn;\n\tspin_lock(&sysctl_lock);\n\tunuse_table(head);\n\tspin_unlock(&sysctl_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(sysctl_lock);",
            "static int insert_links(struct ctl_table_header *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(sysctl_lock);\nstatic int insert_links(struct ctl_table_header *head);\n\nstatic void sysctl_head_finish(struct ctl_table_header *head)\n{\n\tif (!head)\n\t\treturn;\n\tspin_lock(&sysctl_lock);\n\tunuse_table(head);\n\tspin_unlock(&sysctl_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_sys_poll_event",
          "args": [
            "table->poll"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&table->poll->event"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "poll_wait",
          "args": [
            "filp",
            "&table->poll->wait",
            "wait"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "head"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROC_I",
          "args": [
            "inode"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "PROC_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "75-78",
          "snippet": "static inline struct proc_inode *PROC_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct proc_inode, vfs_inode);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nstatic inline struct proc_inode *PROC_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct proc_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "grab_header",
          "args": [
            "inode"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "grab_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "427-433",
          "snippet": "static struct ctl_table_header *grab_header(struct inode *inode)\n{\n\tstruct ctl_table_header *head = PROC_I(inode)->sysctl;\n\tif (!head)\n\t\thead = &sysctl_table_root.default_set.dir.header;\n\treturn sysctl_head_grab(head);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ctl_table_root sysctl_table_root = {\n\t.default_set.dir.header = {\n\t\t{{.count = 1,\n\t\t  .nreg = 1,\n\t\t  .ctl_table = root_table }},\n\t\t.ctl_table_arg = root_table,\n\t\t.root = &sysctl_table_root,\n\t\t.set = &sysctl_table_root.default_set,\n\t},\n};",
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static int insert_links(struct ctl_table_header *head);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic struct ctl_table_root sysctl_table_root = {\n\t.default_set.dir.header = {\n\t\t{{.count = 1,\n\t\t  .nreg = 1,\n\t\t  .ctl_table = root_table }},\n\t\t.ctl_table_arg = root_table,\n\t\t.root = &sysctl_table_root,\n\t\t.set = &sysctl_table_root.default_set,\n\t},\n};\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic int insert_links(struct ctl_table_header *head);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic struct ctl_table_header *grab_header(struct inode *inode)\n{\n\tstruct ctl_table_header *head = PROC_I(inode)->sysctl;\n\tif (!head)\n\t\thead = &sysctl_table_root.default_set.dir.header;\n\treturn sysctl_head_grab(head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic int insert_links(struct ctl_table_header *head);\n\nstatic unsigned int proc_sys_poll(struct file *filp, poll_table *wait)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct ctl_table_header *head = grab_header(inode);\n\tstruct ctl_table *table = PROC_I(inode)->sysctl_entry;\n\tunsigned int ret = DEFAULT_POLLMASK;\n\tunsigned long event;\n\n\t/* sysctl was unregistered */\n\tif (IS_ERR(head))\n\t\treturn POLLERR | POLLHUP;\n\n\tif (!table->proc_handler)\n\t\tgoto out;\n\n\tif (!table->poll)\n\t\tgoto out;\n\n\tevent = (unsigned long)filp->private_data;\n\tpoll_wait(filp, &table->poll->wait, wait);\n\n\tif (event != atomic_read(&table->poll->event)) {\n\t\tfilp->private_data = proc_sys_poll_event(table->poll);\n\t\tret = POLLIN | POLLRDNORM | POLLERR | POLLPRI;\n\t}\n\nout:\n\tsysctl_head_finish(head);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "proc_sys_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "527-542",
    "snippet": "static int proc_sys_open(struct inode *inode, struct file *filp)\n{\n\tstruct ctl_table_header *head = grab_header(inode);\n\tstruct ctl_table *table = PROC_I(inode)->sysctl_entry;\n\n\t/* sysctl was unregistered */\n\tif (IS_ERR(head))\n\t\treturn PTR_ERR(head);\n\n\tif (table->poll)\n\t\tfilp->private_data = proc_sys_poll_event(table->poll);\n\n\tsysctl_head_finish(head);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int insert_links(struct ctl_table_header *head);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysctl_head_finish",
          "args": [
            "head"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "sysctl_head_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "277-284",
          "snippet": "static void sysctl_head_finish(struct ctl_table_header *head)\n{\n\tif (!head)\n\t\treturn;\n\tspin_lock(&sysctl_lock);\n\tunuse_table(head);\n\tspin_unlock(&sysctl_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(sysctl_lock);",
            "static int insert_links(struct ctl_table_header *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(sysctl_lock);\nstatic int insert_links(struct ctl_table_header *head);\n\nstatic void sysctl_head_finish(struct ctl_table_header *head)\n{\n\tif (!head)\n\t\treturn;\n\tspin_lock(&sysctl_lock);\n\tunuse_table(head);\n\tspin_unlock(&sysctl_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_sys_poll_event",
          "args": [
            "table->poll"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "head"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "head"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROC_I",
          "args": [
            "inode"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "PROC_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "75-78",
          "snippet": "static inline struct proc_inode *PROC_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct proc_inode, vfs_inode);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nstatic inline struct proc_inode *PROC_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct proc_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "grab_header",
          "args": [
            "inode"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "grab_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "427-433",
          "snippet": "static struct ctl_table_header *grab_header(struct inode *inode)\n{\n\tstruct ctl_table_header *head = PROC_I(inode)->sysctl;\n\tif (!head)\n\t\thead = &sysctl_table_root.default_set.dir.header;\n\treturn sysctl_head_grab(head);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ctl_table_root sysctl_table_root = {\n\t.default_set.dir.header = {\n\t\t{{.count = 1,\n\t\t  .nreg = 1,\n\t\t  .ctl_table = root_table }},\n\t\t.ctl_table_arg = root_table,\n\t\t.root = &sysctl_table_root,\n\t\t.set = &sysctl_table_root.default_set,\n\t},\n};",
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static int insert_links(struct ctl_table_header *head);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic struct ctl_table_root sysctl_table_root = {\n\t.default_set.dir.header = {\n\t\t{{.count = 1,\n\t\t  .nreg = 1,\n\t\t  .ctl_table = root_table }},\n\t\t.ctl_table_arg = root_table,\n\t\t.root = &sysctl_table_root,\n\t\t.set = &sysctl_table_root.default_set,\n\t},\n};\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic int insert_links(struct ctl_table_header *head);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic struct ctl_table_header *grab_header(struct inode *inode)\n{\n\tstruct ctl_table_header *head = PROC_I(inode)->sysctl;\n\tif (!head)\n\t\thead = &sysctl_table_root.default_set.dir.header;\n\treturn sysctl_head_grab(head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic int insert_links(struct ctl_table_header *head);\n\nstatic int proc_sys_open(struct inode *inode, struct file *filp)\n{\n\tstruct ctl_table_header *head = grab_header(inode);\n\tstruct ctl_table *table = PROC_I(inode)->sysctl_entry;\n\n\t/* sysctl was unregistered */\n\tif (IS_ERR(head))\n\t\treturn PTR_ERR(head);\n\n\tif (table->poll)\n\t\tfilp->private_data = proc_sys_poll_event(table->poll);\n\n\tsysctl_head_finish(head);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "proc_sys_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "521-525",
    "snippet": "static ssize_t proc_sys_write(struct file *filp, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\treturn proc_sys_call_handler(filp, (void __user *)buf, count, ppos, 1);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_sys_call_handler",
          "args": [
            "filp",
            "(void __user *)buf",
            "count",
            "ppos",
            "1"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "proc_sys_call_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "479-513",
          "snippet": "static ssize_t proc_sys_call_handler(struct file *filp, void __user *buf,\n\t\tsize_t count, loff_t *ppos, int write)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct ctl_table_header *head = grab_header(inode);\n\tstruct ctl_table *table = PROC_I(inode)->sysctl_entry;\n\tssize_t error;\n\tsize_t res;\n\n\tif (IS_ERR(head))\n\t\treturn PTR_ERR(head);\n\n\t/*\n\t * At this point we know that the sysctl was not unregistered\n\t * and won't be until we finish.\n\t */\n\terror = -EPERM;\n\tif (sysctl_perm(head, table, write ? MAY_WRITE : MAY_READ))\n\t\tgoto out;\n\n\t/* if that can happen at all, it should be -EINVAL, not -EISDIR */\n\terror = -EINVAL;\n\tif (!table->proc_handler)\n\t\tgoto out;\n\n\t/* careful: calling conventions are nasty here */\n\tres = count;\n\terror = table->proc_handler(table, write, buf, &res, ppos);\n\tif (!error)\n\t\terror = res;\nout:\n\tsysctl_head_finish(head);\n\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int insert_links(struct ctl_table_header *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic int insert_links(struct ctl_table_header *head);\n\nstatic ssize_t proc_sys_call_handler(struct file *filp, void __user *buf,\n\t\tsize_t count, loff_t *ppos, int write)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct ctl_table_header *head = grab_header(inode);\n\tstruct ctl_table *table = PROC_I(inode)->sysctl_entry;\n\tssize_t error;\n\tsize_t res;\n\n\tif (IS_ERR(head))\n\t\treturn PTR_ERR(head);\n\n\t/*\n\t * At this point we know that the sysctl was not unregistered\n\t * and won't be until we finish.\n\t */\n\terror = -EPERM;\n\tif (sysctl_perm(head, table, write ? MAY_WRITE : MAY_READ))\n\t\tgoto out;\n\n\t/* if that can happen at all, it should be -EINVAL, not -EISDIR */\n\terror = -EINVAL;\n\tif (!table->proc_handler)\n\t\tgoto out;\n\n\t/* careful: calling conventions are nasty here */\n\tres = count;\n\terror = table->proc_handler(table, write, buf, &res, ppos);\n\tif (!error)\n\t\terror = res;\nout:\n\tsysctl_head_finish(head);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic ssize_t proc_sys_write(struct file *filp, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\treturn proc_sys_call_handler(filp, (void __user *)buf, count, ppos, 1);\n}"
  },
  {
    "function_name": "proc_sys_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "515-519",
    "snippet": "static ssize_t proc_sys_read(struct file *filp, char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\treturn proc_sys_call_handler(filp, (void __user *)buf, count, ppos, 0);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_sys_call_handler",
          "args": [
            "filp",
            "(void __user *)buf",
            "count",
            "ppos",
            "0"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "proc_sys_call_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "479-513",
          "snippet": "static ssize_t proc_sys_call_handler(struct file *filp, void __user *buf,\n\t\tsize_t count, loff_t *ppos, int write)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct ctl_table_header *head = grab_header(inode);\n\tstruct ctl_table *table = PROC_I(inode)->sysctl_entry;\n\tssize_t error;\n\tsize_t res;\n\n\tif (IS_ERR(head))\n\t\treturn PTR_ERR(head);\n\n\t/*\n\t * At this point we know that the sysctl was not unregistered\n\t * and won't be until we finish.\n\t */\n\terror = -EPERM;\n\tif (sysctl_perm(head, table, write ? MAY_WRITE : MAY_READ))\n\t\tgoto out;\n\n\t/* if that can happen at all, it should be -EINVAL, not -EISDIR */\n\terror = -EINVAL;\n\tif (!table->proc_handler)\n\t\tgoto out;\n\n\t/* careful: calling conventions are nasty here */\n\tres = count;\n\terror = table->proc_handler(table, write, buf, &res, ppos);\n\tif (!error)\n\t\terror = res;\nout:\n\tsysctl_head_finish(head);\n\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int insert_links(struct ctl_table_header *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic int insert_links(struct ctl_table_header *head);\n\nstatic ssize_t proc_sys_call_handler(struct file *filp, void __user *buf,\n\t\tsize_t count, loff_t *ppos, int write)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct ctl_table_header *head = grab_header(inode);\n\tstruct ctl_table *table = PROC_I(inode)->sysctl_entry;\n\tssize_t error;\n\tsize_t res;\n\n\tif (IS_ERR(head))\n\t\treturn PTR_ERR(head);\n\n\t/*\n\t * At this point we know that the sysctl was not unregistered\n\t * and won't be until we finish.\n\t */\n\terror = -EPERM;\n\tif (sysctl_perm(head, table, write ? MAY_WRITE : MAY_READ))\n\t\tgoto out;\n\n\t/* if that can happen at all, it should be -EINVAL, not -EISDIR */\n\terror = -EINVAL;\n\tif (!table->proc_handler)\n\t\tgoto out;\n\n\t/* careful: calling conventions are nasty here */\n\tres = count;\n\terror = table->proc_handler(table, write, buf, &res, ppos);\n\tif (!error)\n\t\terror = res;\nout:\n\tsysctl_head_finish(head);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic ssize_t proc_sys_read(struct file *filp, char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\treturn proc_sys_call_handler(filp, (void __user *)buf, count, ppos, 0);\n}"
  },
  {
    "function_name": "proc_sys_call_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "479-513",
    "snippet": "static ssize_t proc_sys_call_handler(struct file *filp, void __user *buf,\n\t\tsize_t count, loff_t *ppos, int write)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct ctl_table_header *head = grab_header(inode);\n\tstruct ctl_table *table = PROC_I(inode)->sysctl_entry;\n\tssize_t error;\n\tsize_t res;\n\n\tif (IS_ERR(head))\n\t\treturn PTR_ERR(head);\n\n\t/*\n\t * At this point we know that the sysctl was not unregistered\n\t * and won't be until we finish.\n\t */\n\terror = -EPERM;\n\tif (sysctl_perm(head, table, write ? MAY_WRITE : MAY_READ))\n\t\tgoto out;\n\n\t/* if that can happen at all, it should be -EINVAL, not -EISDIR */\n\terror = -EINVAL;\n\tif (!table->proc_handler)\n\t\tgoto out;\n\n\t/* careful: calling conventions are nasty here */\n\tres = count;\n\terror = table->proc_handler(table, write, buf, &res, ppos);\n\tif (!error)\n\t\terror = res;\nout:\n\tsysctl_head_finish(head);\n\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int insert_links(struct ctl_table_header *head);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysctl_head_finish",
          "args": [
            "head"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "sysctl_head_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "277-284",
          "snippet": "static void sysctl_head_finish(struct ctl_table_header *head)\n{\n\tif (!head)\n\t\treturn;\n\tspin_lock(&sysctl_lock);\n\tunuse_table(head);\n\tspin_unlock(&sysctl_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(sysctl_lock);",
            "static int insert_links(struct ctl_table_header *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(sysctl_lock);\nstatic int insert_links(struct ctl_table_header *head);\n\nstatic void sysctl_head_finish(struct ctl_table_header *head)\n{\n\tif (!head)\n\t\treturn;\n\tspin_lock(&sysctl_lock);\n\tunuse_table(head);\n\tspin_unlock(&sysctl_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "table->proc_handler",
          "args": [
            "table",
            "write",
            "buf",
            "&res",
            "ppos"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysctl_perm",
          "args": [
            "head",
            "table",
            "write ? MAY_WRITE : MAY_READ"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "sysctl_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "382-393",
          "snippet": "static int sysctl_perm(struct ctl_table_header *head, struct ctl_table *table, int op)\n{\n\tstruct ctl_table_root *root = head->root;\n\tint mode;\n\n\tif (root->permissions)\n\t\tmode = root->permissions(head, table);\n\telse\n\t\tmode = table->mode;\n\n\treturn test_perm(mode, op);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int insert_links(struct ctl_table_header *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic int insert_links(struct ctl_table_header *head);\n\nstatic int sysctl_perm(struct ctl_table_header *head, struct ctl_table *table, int op)\n{\n\tstruct ctl_table_root *root = head->root;\n\tint mode;\n\n\tif (root->permissions)\n\t\tmode = root->permissions(head, table);\n\telse\n\t\tmode = table->mode;\n\n\treturn test_perm(mode, op);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "head"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "head"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROC_I",
          "args": [
            "inode"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "PROC_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "75-78",
          "snippet": "static inline struct proc_inode *PROC_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct proc_inode, vfs_inode);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nstatic inline struct proc_inode *PROC_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct proc_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "grab_header",
          "args": [
            "inode"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "grab_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "427-433",
          "snippet": "static struct ctl_table_header *grab_header(struct inode *inode)\n{\n\tstruct ctl_table_header *head = PROC_I(inode)->sysctl;\n\tif (!head)\n\t\thead = &sysctl_table_root.default_set.dir.header;\n\treturn sysctl_head_grab(head);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ctl_table_root sysctl_table_root = {\n\t.default_set.dir.header = {\n\t\t{{.count = 1,\n\t\t  .nreg = 1,\n\t\t  .ctl_table = root_table }},\n\t\t.ctl_table_arg = root_table,\n\t\t.root = &sysctl_table_root,\n\t\t.set = &sysctl_table_root.default_set,\n\t},\n};",
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static int insert_links(struct ctl_table_header *head);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic struct ctl_table_root sysctl_table_root = {\n\t.default_set.dir.header = {\n\t\t{{.count = 1,\n\t\t  .nreg = 1,\n\t\t  .ctl_table = root_table }},\n\t\t.ctl_table_arg = root_table,\n\t\t.root = &sysctl_table_root,\n\t\t.set = &sysctl_table_root.default_set,\n\t},\n};\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic int insert_links(struct ctl_table_header *head);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic struct ctl_table_header *grab_header(struct inode *inode)\n{\n\tstruct ctl_table_header *head = PROC_I(inode)->sysctl;\n\tif (!head)\n\t\thead = &sysctl_table_root.default_set.dir.header;\n\treturn sysctl_head_grab(head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic int insert_links(struct ctl_table_header *head);\n\nstatic ssize_t proc_sys_call_handler(struct file *filp, void __user *buf,\n\t\tsize_t count, loff_t *ppos, int write)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct ctl_table_header *head = grab_header(inode);\n\tstruct ctl_table *table = PROC_I(inode)->sysctl_entry;\n\tssize_t error;\n\tsize_t res;\n\n\tif (IS_ERR(head))\n\t\treturn PTR_ERR(head);\n\n\t/*\n\t * At this point we know that the sysctl was not unregistered\n\t * and won't be until we finish.\n\t */\n\terror = -EPERM;\n\tif (sysctl_perm(head, table, write ? MAY_WRITE : MAY_READ))\n\t\tgoto out;\n\n\t/* if that can happen at all, it should be -EINVAL, not -EISDIR */\n\terror = -EINVAL;\n\tif (!table->proc_handler)\n\t\tgoto out;\n\n\t/* careful: calling conventions are nasty here */\n\tres = count;\n\terror = table->proc_handler(table, write, buf, &res, ppos);\n\tif (!error)\n\t\terror = res;\nout:\n\tsysctl_head_finish(head);\n\n\treturn error;\n}"
  },
  {
    "function_name": "proc_sys_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "435-477",
    "snippet": "static struct dentry *proc_sys_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t\tunsigned int flags)\n{\n\tstruct ctl_table_header *head = grab_header(dir);\n\tstruct ctl_table_header *h = NULL;\n\tstruct qstr *name = &dentry->d_name;\n\tstruct ctl_table *p;\n\tstruct inode *inode;\n\tstruct dentry *err = ERR_PTR(-ENOENT);\n\tstruct ctl_dir *ctl_dir;\n\tint ret;\n\n\tif (IS_ERR(head))\n\t\treturn ERR_CAST(head);\n\n\tctl_dir = container_of(head, struct ctl_dir, header);\n\n\tp = lookup_entry(&h, ctl_dir, name->name, name->len);\n\tif (!p)\n\t\tgoto out;\n\n\tif (S_ISLNK(p->mode)) {\n\t\tret = sysctl_follow_link(&h, &p, current->nsproxy);\n\t\terr = ERR_PTR(ret);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\terr = ERR_PTR(-ENOMEM);\n\tinode = proc_sys_make_inode(dir->i_sb, h ? h : head, p);\n\tif (!inode)\n\t\tgoto out;\n\n\terr = NULL;\n\td_set_d_op(dentry, &proc_sys_dentry_operations);\n\td_add(dentry, inode);\n\nout:\n\tif (h)\n\t\tsysctl_head_finish(h);\n\tsysctl_head_finish(head);\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct dentry_operations proc_sys_dentry_operations;",
      "static void drop_sysctl_table(struct ctl_table_header *header);",
      "static int insert_links(struct ctl_table_header *head);",
      "static void put_links(struct ctl_table_header *header);",
      "static const struct dentry_operations proc_sys_dentry_operations = {\n\t.d_revalidate\t= proc_sys_revalidate,\n\t.d_delete\t= proc_sys_delete,\n\t.d_compare\t= proc_sys_compare,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysctl_head_finish",
          "args": [
            "head"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "sysctl_head_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "277-284",
          "snippet": "static void sysctl_head_finish(struct ctl_table_header *head)\n{\n\tif (!head)\n\t\treturn;\n\tspin_lock(&sysctl_lock);\n\tunuse_table(head);\n\tspin_unlock(&sysctl_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(sysctl_lock);",
            "static int insert_links(struct ctl_table_header *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(sysctl_lock);\nstatic int insert_links(struct ctl_table_header *head);\n\nstatic void sysctl_head_finish(struct ctl_table_header *head)\n{\n\tif (!head)\n\t\treturn;\n\tspin_lock(&sysctl_lock);\n\tunuse_table(head);\n\tspin_unlock(&sysctl_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_set_d_op",
          "args": [
            "dentry",
            "&proc_sys_dentry_operations"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "d_set_d_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1635-1659",
          "snippet": "void d_set_d_op(struct dentry *dentry, const struct dentry_operations *op)\n{\n\tWARN_ON_ONCE(dentry->d_op);\n\tWARN_ON_ONCE(dentry->d_flags & (DCACHE_OP_HASH\t|\n\t\t\t\tDCACHE_OP_COMPARE\t|\n\t\t\t\tDCACHE_OP_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_WEAK_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_DELETE ));\n\tdentry->d_op = op;\n\tif (!op)\n\t\treturn;\n\tif (op->d_hash)\n\t\tdentry->d_flags |= DCACHE_OP_HASH;\n\tif (op->d_compare)\n\t\tdentry->d_flags |= DCACHE_OP_COMPARE;\n\tif (op->d_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_REVALIDATE;\n\tif (op->d_weak_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_WEAK_REVALIDATE;\n\tif (op->d_delete)\n\t\tdentry->d_flags |= DCACHE_OP_DELETE;\n\tif (op->d_prune)\n\t\tdentry->d_flags |= DCACHE_OP_PRUNE;\n\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid d_set_d_op(struct dentry *dentry, const struct dentry_operations *op)\n{\n\tWARN_ON_ONCE(dentry->d_op);\n\tWARN_ON_ONCE(dentry->d_flags & (DCACHE_OP_HASH\t|\n\t\t\t\tDCACHE_OP_COMPARE\t|\n\t\t\t\tDCACHE_OP_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_WEAK_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_DELETE ));\n\tdentry->d_op = op;\n\tif (!op)\n\t\treturn;\n\tif (op->d_hash)\n\t\tdentry->d_flags |= DCACHE_OP_HASH;\n\tif (op->d_compare)\n\t\tdentry->d_flags |= DCACHE_OP_COMPARE;\n\tif (op->d_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_REVALIDATE;\n\tif (op->d_weak_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_WEAK_REVALIDATE;\n\tif (op->d_delete)\n\t\tdentry->d_flags |= DCACHE_OP_DELETE;\n\tif (op->d_prune)\n\t\tdentry->d_flags |= DCACHE_OP_PRUNE;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_sys_make_inode",
          "args": [
            "dir->i_sb",
            "h ? h : head",
            "p"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "proc_sys_make_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "395-425",
          "snippet": "static struct inode *proc_sys_make_inode(struct super_block *sb,\n\t\tstruct ctl_table_header *head, struct ctl_table *table)\n{\n\tstruct inode *inode;\n\tstruct proc_inode *ei;\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\tgoto out;\n\n\tinode->i_ino = get_next_ino();\n\n\tsysctl_head_get(head);\n\tei = PROC_I(inode);\n\tei->sysctl = head;\n\tei->sysctl_entry = table;\n\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_mode = table->mode;\n\tif (!S_ISDIR(table->mode)) {\n\t\tinode->i_mode |= S_IFREG;\n\t\tinode->i_op = &proc_sys_inode_operations;\n\t\tinode->i_fop = &proc_sys_file_operations;\n\t} else {\n\t\tinode->i_mode |= S_IFDIR;\n\t\tinode->i_op = &proc_sys_dir_operations;\n\t\tinode->i_fop = &proc_sys_dir_file_operations;\n\t}\nout:\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations proc_sys_file_operations;",
            "static const struct inode_operations proc_sys_inode_operations;",
            "static const struct file_operations proc_sys_dir_file_operations;",
            "static const struct inode_operations proc_sys_dir_operations;",
            "static int insert_links(struct ctl_table_header *head);",
            "static const struct file_operations proc_sys_file_operations = {\n\t.open\t\t= proc_sys_open,\n\t.poll\t\t= proc_sys_poll,\n\t.read\t\t= proc_sys_read,\n\t.write\t\t= proc_sys_write,\n\t.llseek\t\t= default_llseek,\n};",
            "static const struct file_operations proc_sys_dir_file_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= proc_sys_readdir,\n\t.llseek\t\t= generic_file_llseek,\n};",
            "static const struct inode_operations proc_sys_inode_operations = {\n\t.permission\t= proc_sys_permission,\n\t.setattr\t= proc_sys_setattr,\n\t.getattr\t= proc_sys_getattr,\n};",
            "static const struct inode_operations proc_sys_dir_operations = {\n\t.lookup\t\t= proc_sys_lookup,\n\t.permission\t= proc_sys_permission,\n\t.setattr\t= proc_sys_setattr,\n\t.getattr\t= proc_sys_getattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic const struct file_operations proc_sys_file_operations;\nstatic const struct inode_operations proc_sys_inode_operations;\nstatic const struct file_operations proc_sys_dir_file_operations;\nstatic const struct inode_operations proc_sys_dir_operations;\nstatic int insert_links(struct ctl_table_header *head);\nstatic const struct file_operations proc_sys_file_operations = {\n\t.open\t\t= proc_sys_open,\n\t.poll\t\t= proc_sys_poll,\n\t.read\t\t= proc_sys_read,\n\t.write\t\t= proc_sys_write,\n\t.llseek\t\t= default_llseek,\n};\nstatic const struct file_operations proc_sys_dir_file_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= proc_sys_readdir,\n\t.llseek\t\t= generic_file_llseek,\n};\nstatic const struct inode_operations proc_sys_inode_operations = {\n\t.permission\t= proc_sys_permission,\n\t.setattr\t= proc_sys_setattr,\n\t.getattr\t= proc_sys_getattr,\n};\nstatic const struct inode_operations proc_sys_dir_operations = {\n\t.lookup\t\t= proc_sys_lookup,\n\t.permission\t= proc_sys_permission,\n\t.setattr\t= proc_sys_setattr,\n\t.getattr\t= proc_sys_getattr,\n};\n\nstatic struct inode *proc_sys_make_inode(struct super_block *sb,\n\t\tstruct ctl_table_header *head, struct ctl_table *table)\n{\n\tstruct inode *inode;\n\tstruct proc_inode *ei;\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\tgoto out;\n\n\tinode->i_ino = get_next_ino();\n\n\tsysctl_head_get(head);\n\tei = PROC_I(inode);\n\tei->sysctl = head;\n\tei->sysctl_entry = table;\n\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_mode = table->mode;\n\tif (!S_ISDIR(table->mode)) {\n\t\tinode->i_mode |= S_IFREG;\n\t\tinode->i_op = &proc_sys_inode_operations;\n\t\tinode->i_fop = &proc_sys_file_operations;\n\t} else {\n\t\tinode->i_mode |= S_IFDIR;\n\t\tinode->i_op = &proc_sys_dir_operations;\n\t\tinode->i_fop = &proc_sys_dir_file_operations;\n\t}\nout:\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysctl_follow_link",
          "args": [
            "&h",
            "&p",
            "current->nsproxy"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "sysctl_follow_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "940-972",
          "snippet": "static int sysctl_follow_link(struct ctl_table_header **phead,\n\tstruct ctl_table **pentry, struct nsproxy *namespaces)\n{\n\tstruct ctl_table_header *head;\n\tstruct ctl_table_root *root;\n\tstruct ctl_table_set *set;\n\tstruct ctl_table *entry;\n\tstruct ctl_dir *dir;\n\tint ret;\n\n\tret = 0;\n\tspin_lock(&sysctl_lock);\n\troot = (*pentry)->data;\n\tset = lookup_header_set(root, namespaces);\n\tdir = xlate_dir(set, (*phead)->parent);\n\tif (IS_ERR(dir))\n\t\tret = PTR_ERR(dir);\n\telse {\n\t\tconst char *procname = (*pentry)->procname;\n\t\thead = NULL;\n\t\tentry = find_entry(&head, dir, procname, strlen(procname));\n\t\tret = -ENOENT;\n\t\tif (entry && use_table(head)) {\n\t\t\tunuse_table(*phead);\n\t\t\t*phead = head;\n\t\t\t*pentry = entry;\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\tspin_unlock(&sysctl_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(sysctl_lock);",
            "static int sysctl_follow_link(struct ctl_table_header **phead,\n\tstruct ctl_table **pentry, struct nsproxy *namespaces);",
            "static int insert_links(struct ctl_table_header *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(sysctl_lock);\nstatic int sysctl_follow_link(struct ctl_table_header **phead,\n\tstruct ctl_table **pentry, struct nsproxy *namespaces);\nstatic int insert_links(struct ctl_table_header *head);\n\nstatic int sysctl_follow_link(struct ctl_table_header **phead,\n\tstruct ctl_table **pentry, struct nsproxy *namespaces)\n{\n\tstruct ctl_table_header *head;\n\tstruct ctl_table_root *root;\n\tstruct ctl_table_set *set;\n\tstruct ctl_table *entry;\n\tstruct ctl_dir *dir;\n\tint ret;\n\n\tret = 0;\n\tspin_lock(&sysctl_lock);\n\troot = (*pentry)->data;\n\tset = lookup_header_set(root, namespaces);\n\tdir = xlate_dir(set, (*phead)->parent);\n\tif (IS_ERR(dir))\n\t\tret = PTR_ERR(dir);\n\telse {\n\t\tconst char *procname = (*pentry)->procname;\n\t\thead = NULL;\n\t\tentry = find_entry(&head, dir, procname, strlen(procname));\n\t\tret = -ENOENT;\n\t\tif (entry && use_table(head)) {\n\t\t\tunuse_table(*phead);\n\t\t\t*phead = head;\n\t\t\t*pentry = entry;\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\tspin_unlock(&sysctl_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "p->mode"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_entry",
          "args": [
            "&h",
            "ctl_dir",
            "name->name",
            "name->len"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "295-310",
          "snippet": "static struct ctl_table *lookup_entry(struct ctl_table_header **phead,\n\t\t\t\t      struct ctl_dir *dir,\n\t\t\t\t      const char *name, int namelen)\n{\n\tstruct ctl_table_header *head;\n\tstruct ctl_table *entry;\n\n\tspin_lock(&sysctl_lock);\n\tentry = find_entry(&head, dir, name, namelen);\n\tif (entry && use_table(head))\n\t\t*phead = head;\n\telse\n\t\tentry = NULL;\n\tspin_unlock(&sysctl_lock);\n\treturn entry;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(sysctl_lock);",
            "static int insert_links(struct ctl_table_header *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(sysctl_lock);\nstatic int insert_links(struct ctl_table_header *head);\n\nstatic struct ctl_table *lookup_entry(struct ctl_table_header **phead,\n\t\t\t\t      struct ctl_dir *dir,\n\t\t\t\t      const char *name, int namelen)\n{\n\tstruct ctl_table_header *head;\n\tstruct ctl_table *entry;\n\n\tspin_lock(&sysctl_lock);\n\tentry = find_entry(&head, dir, name, namelen);\n\tif (entry && use_table(head))\n\t\t*phead = head;\n\telse\n\t\tentry = NULL;\n\tspin_unlock(&sysctl_lock);\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structctl_dir",
            "header"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "head"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "head"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_header",
          "args": [
            "dir"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "grab_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "427-433",
          "snippet": "static struct ctl_table_header *grab_header(struct inode *inode)\n{\n\tstruct ctl_table_header *head = PROC_I(inode)->sysctl;\n\tif (!head)\n\t\thead = &sysctl_table_root.default_set.dir.header;\n\treturn sysctl_head_grab(head);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ctl_table_root sysctl_table_root = {\n\t.default_set.dir.header = {\n\t\t{{.count = 1,\n\t\t  .nreg = 1,\n\t\t  .ctl_table = root_table }},\n\t\t.ctl_table_arg = root_table,\n\t\t.root = &sysctl_table_root,\n\t\t.set = &sysctl_table_root.default_set,\n\t},\n};",
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static int insert_links(struct ctl_table_header *head);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic struct ctl_table_root sysctl_table_root = {\n\t.default_set.dir.header = {\n\t\t{{.count = 1,\n\t\t  .nreg = 1,\n\t\t  .ctl_table = root_table }},\n\t\t.ctl_table_arg = root_table,\n\t\t.root = &sysctl_table_root,\n\t\t.set = &sysctl_table_root.default_set,\n\t},\n};\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic int insert_links(struct ctl_table_header *head);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic struct ctl_table_header *grab_header(struct inode *inode)\n{\n\tstruct ctl_table_header *head = PROC_I(inode)->sysctl;\n\tif (!head)\n\t\thead = &sysctl_table_root.default_set.dir.header;\n\treturn sysctl_head_grab(head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic const struct dentry_operations proc_sys_dentry_operations;\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic int insert_links(struct ctl_table_header *head);\nstatic void put_links(struct ctl_table_header *header);\nstatic const struct dentry_operations proc_sys_dentry_operations = {\n\t.d_revalidate\t= proc_sys_revalidate,\n\t.d_delete\t= proc_sys_delete,\n\t.d_compare\t= proc_sys_compare,\n};\n\nstatic struct dentry *proc_sys_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t\tunsigned int flags)\n{\n\tstruct ctl_table_header *head = grab_header(dir);\n\tstruct ctl_table_header *h = NULL;\n\tstruct qstr *name = &dentry->d_name;\n\tstruct ctl_table *p;\n\tstruct inode *inode;\n\tstruct dentry *err = ERR_PTR(-ENOENT);\n\tstruct ctl_dir *ctl_dir;\n\tint ret;\n\n\tif (IS_ERR(head))\n\t\treturn ERR_CAST(head);\n\n\tctl_dir = container_of(head, struct ctl_dir, header);\n\n\tp = lookup_entry(&h, ctl_dir, name->name, name->len);\n\tif (!p)\n\t\tgoto out;\n\n\tif (S_ISLNK(p->mode)) {\n\t\tret = sysctl_follow_link(&h, &p, current->nsproxy);\n\t\terr = ERR_PTR(ret);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\terr = ERR_PTR(-ENOMEM);\n\tinode = proc_sys_make_inode(dir->i_sb, h ? h : head, p);\n\tif (!inode)\n\t\tgoto out;\n\n\terr = NULL;\n\td_set_d_op(dentry, &proc_sys_dentry_operations);\n\td_add(dentry, inode);\n\nout:\n\tif (h)\n\t\tsysctl_head_finish(h);\n\tsysctl_head_finish(head);\n\treturn err;\n}"
  },
  {
    "function_name": "grab_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "427-433",
    "snippet": "static struct ctl_table_header *grab_header(struct inode *inode)\n{\n\tstruct ctl_table_header *head = PROC_I(inode)->sysctl;\n\tif (!head)\n\t\thead = &sysctl_table_root.default_set.dir.header;\n\treturn sysctl_head_grab(head);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ctl_table_root sysctl_table_root = {\n\t.default_set.dir.header = {\n\t\t{{.count = 1,\n\t\t  .nreg = 1,\n\t\t  .ctl_table = root_table }},\n\t\t.ctl_table_arg = root_table,\n\t\t.root = &sysctl_table_root,\n\t\t.set = &sysctl_table_root.default_set,\n\t},\n};",
      "static void drop_sysctl_table(struct ctl_table_header *header);",
      "static int insert_links(struct ctl_table_header *head);",
      "static void put_links(struct ctl_table_header *header);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysctl_head_grab",
          "args": [
            "head"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "sysctl_head_grab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "267-275",
          "snippet": "static struct ctl_table_header *sysctl_head_grab(struct ctl_table_header *head)\n{\n\tBUG_ON(!head);\n\tspin_lock(&sysctl_lock);\n\tif (!use_table(head))\n\t\thead = ERR_PTR(-ENOENT);\n\tspin_unlock(&sysctl_lock);\n\treturn head;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(sysctl_lock);",
            "static int insert_links(struct ctl_table_header *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(sysctl_lock);\nstatic int insert_links(struct ctl_table_header *head);\n\nstatic struct ctl_table_header *sysctl_head_grab(struct ctl_table_header *head)\n{\n\tBUG_ON(!head);\n\tspin_lock(&sysctl_lock);\n\tif (!use_table(head))\n\t\thead = ERR_PTR(-ENOENT);\n\tspin_unlock(&sysctl_lock);\n\treturn head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PROC_I",
          "args": [
            "inode"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "PROC_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "75-78",
          "snippet": "static inline struct proc_inode *PROC_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct proc_inode, vfs_inode);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nstatic inline struct proc_inode *PROC_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct proc_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic struct ctl_table_root sysctl_table_root = {\n\t.default_set.dir.header = {\n\t\t{{.count = 1,\n\t\t  .nreg = 1,\n\t\t  .ctl_table = root_table }},\n\t\t.ctl_table_arg = root_table,\n\t\t.root = &sysctl_table_root,\n\t\t.set = &sysctl_table_root.default_set,\n\t},\n};\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic int insert_links(struct ctl_table_header *head);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic struct ctl_table_header *grab_header(struct inode *inode)\n{\n\tstruct ctl_table_header *head = PROC_I(inode)->sysctl;\n\tif (!head)\n\t\thead = &sysctl_table_root.default_set.dir.header;\n\treturn sysctl_head_grab(head);\n}"
  },
  {
    "function_name": "proc_sys_make_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "395-425",
    "snippet": "static struct inode *proc_sys_make_inode(struct super_block *sb,\n\t\tstruct ctl_table_header *head, struct ctl_table *table)\n{\n\tstruct inode *inode;\n\tstruct proc_inode *ei;\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\tgoto out;\n\n\tinode->i_ino = get_next_ino();\n\n\tsysctl_head_get(head);\n\tei = PROC_I(inode);\n\tei->sysctl = head;\n\tei->sysctl_entry = table;\n\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_mode = table->mode;\n\tif (!S_ISDIR(table->mode)) {\n\t\tinode->i_mode |= S_IFREG;\n\t\tinode->i_op = &proc_sys_inode_operations;\n\t\tinode->i_fop = &proc_sys_file_operations;\n\t} else {\n\t\tinode->i_mode |= S_IFDIR;\n\t\tinode->i_op = &proc_sys_dir_operations;\n\t\tinode->i_fop = &proc_sys_dir_file_operations;\n\t}\nout:\n\treturn inode;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations proc_sys_file_operations;",
      "static const struct inode_operations proc_sys_inode_operations;",
      "static const struct file_operations proc_sys_dir_file_operations;",
      "static const struct inode_operations proc_sys_dir_operations;",
      "static int insert_links(struct ctl_table_header *head);",
      "static const struct file_operations proc_sys_file_operations = {\n\t.open\t\t= proc_sys_open,\n\t.poll\t\t= proc_sys_poll,\n\t.read\t\t= proc_sys_read,\n\t.write\t\t= proc_sys_write,\n\t.llseek\t\t= default_llseek,\n};",
      "static const struct file_operations proc_sys_dir_file_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= proc_sys_readdir,\n\t.llseek\t\t= generic_file_llseek,\n};",
      "static const struct inode_operations proc_sys_inode_operations = {\n\t.permission\t= proc_sys_permission,\n\t.setattr\t= proc_sys_setattr,\n\t.getattr\t= proc_sys_getattr,\n};",
      "static const struct inode_operations proc_sys_dir_operations = {\n\t.lookup\t\t= proc_sys_lookup,\n\t.permission\t= proc_sys_permission,\n\t.setattr\t= proc_sys_setattr,\n\t.getattr\t= proc_sys_getattr,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "table->mode"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROC_I",
          "args": [
            "inode"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "PROC_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "75-78",
          "snippet": "static inline struct proc_inode *PROC_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct proc_inode, vfs_inode);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nstatic inline struct proc_inode *PROC_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct proc_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysctl_head_get",
          "args": [
            "head"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "sysctl_head_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "252-257",
          "snippet": "static void sysctl_head_get(struct ctl_table_header *head)\n{\n\tspin_lock(&sysctl_lock);\n\thead->count++;\n\tspin_unlock(&sysctl_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(sysctl_lock);",
            "static int insert_links(struct ctl_table_header *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(sysctl_lock);\nstatic int insert_links(struct ctl_table_header *head);\n\nstatic void sysctl_head_get(struct ctl_table_header *head)\n{\n\tspin_lock(&sysctl_lock);\n\thead->count++;\n\tspin_unlock(&sysctl_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_next_ino",
          "args": [],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "get_next_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "828-845",
          "snippet": "unsigned int get_next_ino(void)\n{\n\tunsigned int *p = &get_cpu_var(last_ino);\n\tunsigned int res = *p;\n\n#ifdef CONFIG_SMP\n\tif (unlikely((res & (LAST_INO_BATCH-1)) == 0)) {\n\t\tstatic atomic_t shared_last_ino;\n\t\tint next = atomic_add_return(LAST_INO_BATCH, &shared_last_ino);\n\n\t\tres = next - LAST_INO_BATCH;\n\t}\n#endif\n\n\t*p = ++res;\n\tput_cpu_var(last_ino);\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define LAST_INO_BATCH 1024"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned int, last_ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n#define LAST_INO_BATCH 1024\n\nstatic DEFINE_PER_CPU(unsigned int, last_ino);\n\nunsigned int get_next_ino(void)\n{\n\tunsigned int *p = &get_cpu_var(last_ino);\n\tunsigned int res = *p;\n\n#ifdef CONFIG_SMP\n\tif (unlikely((res & (LAST_INO_BATCH-1)) == 0)) {\n\t\tstatic atomic_t shared_last_ino;\n\t\tint next = atomic_add_return(LAST_INO_BATCH, &shared_last_ino);\n\n\t\tres = next - LAST_INO_BATCH;\n\t}\n#endif\n\n\t*p = ++res;\n\tput_cpu_var(last_ino);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "sb"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic const struct file_operations proc_sys_file_operations;\nstatic const struct inode_operations proc_sys_inode_operations;\nstatic const struct file_operations proc_sys_dir_file_operations;\nstatic const struct inode_operations proc_sys_dir_operations;\nstatic int insert_links(struct ctl_table_header *head);\nstatic const struct file_operations proc_sys_file_operations = {\n\t.open\t\t= proc_sys_open,\n\t.poll\t\t= proc_sys_poll,\n\t.read\t\t= proc_sys_read,\n\t.write\t\t= proc_sys_write,\n\t.llseek\t\t= default_llseek,\n};\nstatic const struct file_operations proc_sys_dir_file_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= proc_sys_readdir,\n\t.llseek\t\t= generic_file_llseek,\n};\nstatic const struct inode_operations proc_sys_inode_operations = {\n\t.permission\t= proc_sys_permission,\n\t.setattr\t= proc_sys_setattr,\n\t.getattr\t= proc_sys_getattr,\n};\nstatic const struct inode_operations proc_sys_dir_operations = {\n\t.lookup\t\t= proc_sys_lookup,\n\t.permission\t= proc_sys_permission,\n\t.setattr\t= proc_sys_setattr,\n\t.getattr\t= proc_sys_getattr,\n};\n\nstatic struct inode *proc_sys_make_inode(struct super_block *sb,\n\t\tstruct ctl_table_header *head, struct ctl_table *table)\n{\n\tstruct inode *inode;\n\tstruct proc_inode *ei;\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\tgoto out;\n\n\tinode->i_ino = get_next_ino();\n\n\tsysctl_head_get(head);\n\tei = PROC_I(inode);\n\tei->sysctl = head;\n\tei->sysctl_entry = table;\n\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_mode = table->mode;\n\tif (!S_ISDIR(table->mode)) {\n\t\tinode->i_mode |= S_IFREG;\n\t\tinode->i_op = &proc_sys_inode_operations;\n\t\tinode->i_fop = &proc_sys_file_operations;\n\t} else {\n\t\tinode->i_mode |= S_IFDIR;\n\t\tinode->i_op = &proc_sys_dir_operations;\n\t\tinode->i_fop = &proc_sys_dir_file_operations;\n\t}\nout:\n\treturn inode;\n}"
  },
  {
    "function_name": "sysctl_perm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "382-393",
    "snippet": "static int sysctl_perm(struct ctl_table_header *head, struct ctl_table *table, int op)\n{\n\tstruct ctl_table_root *root = head->root;\n\tint mode;\n\n\tif (root->permissions)\n\t\tmode = root->permissions(head, table);\n\telse\n\t\tmode = table->mode;\n\n\treturn test_perm(mode, op);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int insert_links(struct ctl_table_header *head);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_perm",
          "args": [
            "mode",
            "op"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "test_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "371-380",
          "snippet": "static int test_perm(int mode, int op)\n{\n\tif (uid_eq(current_euid(), GLOBAL_ROOT_UID))\n\t\tmode >>= 6;\n\telse if (in_egroup_p(GLOBAL_ROOT_GID))\n\t\tmode >>= 3;\n\tif ((op & ~mode & (MAY_READ|MAY_WRITE|MAY_EXEC)) == 0)\n\t\treturn 0;\n\treturn -EACCES;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic int test_perm(int mode, int op)\n{\n\tif (uid_eq(current_euid(), GLOBAL_ROOT_UID))\n\t\tmode >>= 6;\n\telse if (in_egroup_p(GLOBAL_ROOT_GID))\n\t\tmode >>= 3;\n\tif ((op & ~mode & (MAY_READ|MAY_WRITE|MAY_EXEC)) == 0)\n\t\treturn 0;\n\treturn -EACCES;\n}"
        }
      },
      {
        "call_info": {
          "callee": "root->permissions",
          "args": [
            "head",
            "table"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic int insert_links(struct ctl_table_header *head);\n\nstatic int sysctl_perm(struct ctl_table_header *head, struct ctl_table *table, int op)\n{\n\tstruct ctl_table_root *root = head->root;\n\tint mode;\n\n\tif (root->permissions)\n\t\tmode = root->permissions(head, table);\n\telse\n\t\tmode = table->mode;\n\n\treturn test_perm(mode, op);\n}"
  },
  {
    "function_name": "test_perm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "371-380",
    "snippet": "static int test_perm(int mode, int op)\n{\n\tif (uid_eq(current_euid(), GLOBAL_ROOT_UID))\n\t\tmode >>= 6;\n\telse if (in_egroup_p(GLOBAL_ROOT_GID))\n\t\tmode >>= 3;\n\tif ((op & ~mode & (MAY_READ|MAY_WRITE|MAY_EXEC)) == 0)\n\t\treturn 0;\n\treturn -EACCES;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "in_egroup_p",
          "args": [
            "GLOBAL_ROOT_GID"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "current_euid()",
            "GLOBAL_ROOT_UID"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_euid",
          "args": [],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic int test_perm(int mode, int op)\n{\n\tif (uid_eq(current_euid(), GLOBAL_ROOT_UID))\n\t\tmode >>= 6;\n\telse if (in_egroup_p(GLOBAL_ROOT_GID))\n\t\tmode >>= 3;\n\tif ((op & ~mode & (MAY_READ|MAY_WRITE|MAY_EXEC)) == 0)\n\t\treturn 0;\n\treturn -EACCES;\n}"
  },
  {
    "function_name": "register_sysctl_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "362-364",
    "snippet": "void register_sysctl_root(struct ctl_table_root *root)\n{\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nvoid register_sysctl_root(struct ctl_table_root *root)\n{\n}"
  },
  {
    "function_name": "next_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "342-360",
    "snippet": "static void next_entry(struct ctl_table_header **phead, struct ctl_table **pentry)\n{\n\tstruct ctl_table_header *head = *phead;\n\tstruct ctl_table *entry = *pentry;\n\tstruct ctl_node *ctl_node = &head->node[entry - head->ctl_table];\n\n\tspin_lock(&sysctl_lock);\n\tunuse_table(head);\n\n\tctl_node = first_usable_entry(rb_next(&ctl_node->node));\n\tspin_unlock(&sysctl_lock);\n\thead = NULL;\n\tif (ctl_node) {\n\t\thead = ctl_node->header;\n\t\tentry = &head->ctl_table[ctl_node - head->node];\n\t}\n\t*phead = head;\n\t*pentry = entry;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(sysctl_lock);",
      "static void drop_sysctl_table(struct ctl_table_header *header);",
      "static int insert_links(struct ctl_table_header *head);",
      "static void put_links(struct ctl_table_header *header);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sysctl_lock"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "first_usable_entry",
          "args": [
            "rb_next(&ctl_node->node)"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "first_usable_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "312-322",
          "snippet": "static struct ctl_node *first_usable_entry(struct rb_node *node)\n{\n\tstruct ctl_node *ctl_node;\n\n\tfor (;node; node = rb_next(node)) {\n\t\tctl_node = rb_entry(node, struct ctl_node, node);\n\t\tif (use_table(ctl_node->header))\n\t\t\treturn ctl_node;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic struct ctl_node *first_usable_entry(struct rb_node *node)\n{\n\tstruct ctl_node *ctl_node;\n\n\tfor (;node; node = rb_next(node)) {\n\t\tctl_node = rb_entry(node, struct ctl_node, node);\n\t\tif (use_table(ctl_node->header))\n\t\t\treturn ctl_node;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "&ctl_node->node"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unuse_table",
          "args": [
            "head"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "unuse_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "220-225",
          "snippet": "static void unuse_table(struct ctl_table_header *p)\n{\n\tif (!--p->used)\n\t\tif (unlikely(p->unregistering))\n\t\t\tcomplete(p->unregistering);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void unuse_table(struct ctl_table_header *p)\n{\n\tif (!--p->used)\n\t\tif (unlikely(p->unregistering))\n\t\t\tcomplete(p->unregistering);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sysctl_lock"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(sysctl_lock);\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic int insert_links(struct ctl_table_header *head);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic void next_entry(struct ctl_table_header **phead, struct ctl_table **pentry)\n{\n\tstruct ctl_table_header *head = *phead;\n\tstruct ctl_table *entry = *pentry;\n\tstruct ctl_node *ctl_node = &head->node[entry - head->ctl_table];\n\n\tspin_lock(&sysctl_lock);\n\tunuse_table(head);\n\n\tctl_node = first_usable_entry(rb_next(&ctl_node->node));\n\tspin_unlock(&sysctl_lock);\n\thead = NULL;\n\tif (ctl_node) {\n\t\thead = ctl_node->header;\n\t\tentry = &head->ctl_table[ctl_node - head->node];\n\t}\n\t*phead = head;\n\t*pentry = entry;\n}"
  },
  {
    "function_name": "first_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "324-340",
    "snippet": "static void first_entry(struct ctl_dir *dir,\n\tstruct ctl_table_header **phead, struct ctl_table **pentry)\n{\n\tstruct ctl_table_header *head = NULL;\n\tstruct ctl_table *entry = NULL;\n\tstruct ctl_node *ctl_node;\n\n\tspin_lock(&sysctl_lock);\n\tctl_node = first_usable_entry(rb_first(&dir->root));\n\tspin_unlock(&sysctl_lock);\n\tif (ctl_node) {\n\t\thead = ctl_node->header;\n\t\tentry = &head->ctl_table[ctl_node - head->node];\n\t}\n\t*phead = head;\n\t*pentry = entry;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(sysctl_lock);",
      "static void drop_sysctl_table(struct ctl_table_header *header);",
      "static int insert_links(struct ctl_table_header *head);",
      "static void put_links(struct ctl_table_header *header);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sysctl_lock"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "first_usable_entry",
          "args": [
            "rb_first(&dir->root)"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "first_usable_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "312-322",
          "snippet": "static struct ctl_node *first_usable_entry(struct rb_node *node)\n{\n\tstruct ctl_node *ctl_node;\n\n\tfor (;node; node = rb_next(node)) {\n\t\tctl_node = rb_entry(node, struct ctl_node, node);\n\t\tif (use_table(ctl_node->header))\n\t\t\treturn ctl_node;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic struct ctl_node *first_usable_entry(struct rb_node *node)\n{\n\tstruct ctl_node *ctl_node;\n\n\tfor (;node; node = rb_next(node)) {\n\t\tctl_node = rb_entry(node, struct ctl_node, node);\n\t\tif (use_table(ctl_node->header))\n\t\t\treturn ctl_node;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&dir->root"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sysctl_lock"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(sysctl_lock);\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic int insert_links(struct ctl_table_header *head);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic void first_entry(struct ctl_dir *dir,\n\tstruct ctl_table_header **phead, struct ctl_table **pentry)\n{\n\tstruct ctl_table_header *head = NULL;\n\tstruct ctl_table *entry = NULL;\n\tstruct ctl_node *ctl_node;\n\n\tspin_lock(&sysctl_lock);\n\tctl_node = first_usable_entry(rb_first(&dir->root));\n\tspin_unlock(&sysctl_lock);\n\tif (ctl_node) {\n\t\thead = ctl_node->header;\n\t\tentry = &head->ctl_table[ctl_node - head->node];\n\t}\n\t*phead = head;\n\t*pentry = entry;\n}"
  },
  {
    "function_name": "first_usable_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "312-322",
    "snippet": "static struct ctl_node *first_usable_entry(struct rb_node *node)\n{\n\tstruct ctl_node *ctl_node;\n\n\tfor (;node; node = rb_next(node)) {\n\t\tctl_node = rb_entry(node, struct ctl_node, node);\n\t\tif (use_table(ctl_node->header))\n\t\t\treturn ctl_node;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void drop_sysctl_table(struct ctl_table_header *header);",
      "static void put_links(struct ctl_table_header *header);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "use_table",
          "args": [
            "ctl_node->header"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "unuse_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "220-225",
          "snippet": "static void unuse_table(struct ctl_table_header *p)\n{\n\tif (!--p->used)\n\t\tif (unlikely(p->unregistering))\n\t\t\tcomplete(p->unregistering);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void unuse_table(struct ctl_table_header *p)\n{\n\tif (!--p->used)\n\t\tif (unlikely(p->unregistering))\n\t\t\tcomplete(p->unregistering);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structctl_node",
            "node"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "node"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic struct ctl_node *first_usable_entry(struct rb_node *node)\n{\n\tstruct ctl_node *ctl_node;\n\n\tfor (;node; node = rb_next(node)) {\n\t\tctl_node = rb_entry(node, struct ctl_node, node);\n\t\tif (use_table(ctl_node->header))\n\t\t\treturn ctl_node;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "lookup_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "295-310",
    "snippet": "static struct ctl_table *lookup_entry(struct ctl_table_header **phead,\n\t\t\t\t      struct ctl_dir *dir,\n\t\t\t\t      const char *name, int namelen)\n{\n\tstruct ctl_table_header *head;\n\tstruct ctl_table *entry;\n\n\tspin_lock(&sysctl_lock);\n\tentry = find_entry(&head, dir, name, namelen);\n\tif (entry && use_table(head))\n\t\t*phead = head;\n\telse\n\t\tentry = NULL;\n\tspin_unlock(&sysctl_lock);\n\treturn entry;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(sysctl_lock);",
      "static int insert_links(struct ctl_table_header *head);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sysctl_lock"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "use_table",
          "args": [
            "head"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "unuse_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "220-225",
          "snippet": "static void unuse_table(struct ctl_table_header *p)\n{\n\tif (!--p->used)\n\t\tif (unlikely(p->unregistering))\n\t\t\tcomplete(p->unregistering);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void unuse_table(struct ctl_table_header *p)\n{\n\tif (!--p->used)\n\t\tif (unlikely(p->unregistering))\n\t\t\tcomplete(p->unregistering);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_entry",
          "args": [
            "&head",
            "dir",
            "name",
            "namelen"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "80-109",
          "snippet": "static struct ctl_table *find_entry(struct ctl_table_header **phead,\n\tstruct ctl_dir *dir, const char *name, int namelen)\n{\n\tstruct ctl_table_header *head;\n\tstruct ctl_table *entry;\n\tstruct rb_node *node = dir->root.rb_node;\n\n\twhile (node)\n\t{\n\t\tstruct ctl_node *ctl_node;\n\t\tconst char *procname;\n\t\tint cmp;\n\n\t\tctl_node = rb_entry(node, struct ctl_node, node);\n\t\thead = ctl_node->header;\n\t\tentry = &head->ctl_table[ctl_node - head->node];\n\t\tprocname = entry->procname;\n\n\t\tcmp = namecmp(name, namelen, procname, strlen(procname));\n\t\tif (cmp < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (cmp > 0)\n\t\t\tnode = node->rb_right;\n\t\telse {\n\t\t\t*phead = head;\n\t\t\treturn entry;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static int insert_links(struct ctl_table_header *head);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic int insert_links(struct ctl_table_header *head);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic struct ctl_table *find_entry(struct ctl_table_header **phead,\n\tstruct ctl_dir *dir, const char *name, int namelen)\n{\n\tstruct ctl_table_header *head;\n\tstruct ctl_table *entry;\n\tstruct rb_node *node = dir->root.rb_node;\n\n\twhile (node)\n\t{\n\t\tstruct ctl_node *ctl_node;\n\t\tconst char *procname;\n\t\tint cmp;\n\n\t\tctl_node = rb_entry(node, struct ctl_node, node);\n\t\thead = ctl_node->header;\n\t\tentry = &head->ctl_table[ctl_node - head->node];\n\t\tprocname = entry->procname;\n\n\t\tcmp = namecmp(name, namelen, procname, strlen(procname));\n\t\tif (cmp < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (cmp > 0)\n\t\t\tnode = node->rb_right;\n\t\telse {\n\t\t\t*phead = head;\n\t\t\treturn entry;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sysctl_lock"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(sysctl_lock);\nstatic int insert_links(struct ctl_table_header *head);\n\nstatic struct ctl_table *lookup_entry(struct ctl_table_header **phead,\n\t\t\t\t      struct ctl_dir *dir,\n\t\t\t\t      const char *name, int namelen)\n{\n\tstruct ctl_table_header *head;\n\tstruct ctl_table *entry;\n\n\tspin_lock(&sysctl_lock);\n\tentry = find_entry(&head, dir, name, namelen);\n\tif (entry && use_table(head))\n\t\t*phead = head;\n\telse\n\t\tentry = NULL;\n\tspin_unlock(&sysctl_lock);\n\treturn entry;\n}"
  },
  {
    "function_name": "lookup_header_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "286-293",
    "snippet": "static struct ctl_table_set *\nlookup_header_set(struct ctl_table_root *root, struct nsproxy *namespaces)\n{\n\tstruct ctl_table_set *set = &root->default_set;\n\tif (root->lookup)\n\t\tset = root->lookup(root, namespaces);\n\treturn set;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int sysctl_follow_link(struct ctl_table_header **phead,\n\tstruct ctl_table **pentry, struct nsproxy *namespaces);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "root->lookup",
          "args": [
            "root",
            "namespaces"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic int sysctl_follow_link(struct ctl_table_header **phead,\n\tstruct ctl_table **pentry, struct nsproxy *namespaces);\n\nstatic struct ctl_table_set *\nlookup_header_set(struct ctl_table_root *root, struct nsproxy *namespaces)\n{\n\tstruct ctl_table_set *set = &root->default_set;\n\tif (root->lookup)\n\t\tset = root->lookup(root, namespaces);\n\treturn set;\n}"
  },
  {
    "function_name": "sysctl_head_finish",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "277-284",
    "snippet": "static void sysctl_head_finish(struct ctl_table_header *head)\n{\n\tif (!head)\n\t\treturn;\n\tspin_lock(&sysctl_lock);\n\tunuse_table(head);\n\tspin_unlock(&sysctl_lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(sysctl_lock);",
      "static int insert_links(struct ctl_table_header *head);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sysctl_lock"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "unuse_table",
          "args": [
            "head"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "unuse_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "220-225",
          "snippet": "static void unuse_table(struct ctl_table_header *p)\n{\n\tif (!--p->used)\n\t\tif (unlikely(p->unregistering))\n\t\t\tcomplete(p->unregistering);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void unuse_table(struct ctl_table_header *p)\n{\n\tif (!--p->used)\n\t\tif (unlikely(p->unregistering))\n\t\t\tcomplete(p->unregistering);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sysctl_lock"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(sysctl_lock);\nstatic int insert_links(struct ctl_table_header *head);\n\nstatic void sysctl_head_finish(struct ctl_table_header *head)\n{\n\tif (!head)\n\t\treturn;\n\tspin_lock(&sysctl_lock);\n\tunuse_table(head);\n\tspin_unlock(&sysctl_lock);\n}"
  },
  {
    "function_name": "sysctl_head_grab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "267-275",
    "snippet": "static struct ctl_table_header *sysctl_head_grab(struct ctl_table_header *head)\n{\n\tBUG_ON(!head);\n\tspin_lock(&sysctl_lock);\n\tif (!use_table(head))\n\t\thead = ERR_PTR(-ENOENT);\n\tspin_unlock(&sysctl_lock);\n\treturn head;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(sysctl_lock);",
      "static int insert_links(struct ctl_table_header *head);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sysctl_lock"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "use_table",
          "args": [
            "head"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "unuse_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "220-225",
          "snippet": "static void unuse_table(struct ctl_table_header *p)\n{\n\tif (!--p->used)\n\t\tif (unlikely(p->unregistering))\n\t\t\tcomplete(p->unregistering);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void unuse_table(struct ctl_table_header *p)\n{\n\tif (!--p->used)\n\t\tif (unlikely(p->unregistering))\n\t\t\tcomplete(p->unregistering);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sysctl_lock"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!head"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(sysctl_lock);\nstatic int insert_links(struct ctl_table_header *head);\n\nstatic struct ctl_table_header *sysctl_head_grab(struct ctl_table_header *head)\n{\n\tBUG_ON(!head);\n\tspin_lock(&sysctl_lock);\n\tif (!use_table(head))\n\t\thead = ERR_PTR(-ENOENT);\n\tspin_unlock(&sysctl_lock);\n\treturn head;\n}"
  },
  {
    "function_name": "sysctl_head_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "259-265",
    "snippet": "void sysctl_head_put(struct ctl_table_header *head)\n{\n\tspin_lock(&sysctl_lock);\n\tif (!--head->count)\n\t\tkfree_rcu(head, rcu);\n\tspin_unlock(&sysctl_lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(sysctl_lock);",
      "static int insert_links(struct ctl_table_header *head);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sysctl_lock"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree_rcu",
          "args": [
            "head",
            "rcu"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sysctl_lock"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(sysctl_lock);\nstatic int insert_links(struct ctl_table_header *head);\n\nvoid sysctl_head_put(struct ctl_table_header *head)\n{\n\tspin_lock(&sysctl_lock);\n\tif (!--head->count)\n\t\tkfree_rcu(head, rcu);\n\tspin_unlock(&sysctl_lock);\n}"
  },
  {
    "function_name": "sysctl_head_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "252-257",
    "snippet": "static void sysctl_head_get(struct ctl_table_header *head)\n{\n\tspin_lock(&sysctl_lock);\n\thead->count++;\n\tspin_unlock(&sysctl_lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(sysctl_lock);",
      "static int insert_links(struct ctl_table_header *head);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sysctl_lock"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sysctl_lock"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(sysctl_lock);\nstatic int insert_links(struct ctl_table_header *head);\n\nstatic void sysctl_head_get(struct ctl_table_header *head)\n{\n\tspin_lock(&sysctl_lock);\n\thead->count++;\n\tspin_unlock(&sysctl_lock);\n}"
  },
  {
    "function_name": "start_unregistering",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "228-250",
    "snippet": "static void start_unregistering(struct ctl_table_header *p)\n{\n\t/*\n\t * if p->used is 0, nobody will ever touch that entry again;\n\t * we'll eliminate all paths to it before dropping sysctl_lock\n\t */\n\tif (unlikely(p->used)) {\n\t\tstruct completion wait;\n\t\tinit_completion(&wait);\n\t\tp->unregistering = &wait;\n\t\tspin_unlock(&sysctl_lock);\n\t\twait_for_completion(&wait);\n\t\tspin_lock(&sysctl_lock);\n\t} else {\n\t\t/* anything non-NULL; we'll never dereference it */\n\t\tp->unregistering = ERR_PTR(-EINVAL);\n\t}\n\t/*\n\t * do not remove from the list until nobody holds it; walking the\n\t * list in do_sysctl() relies on that.\n\t */\n\terase_header(p);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(sysctl_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "erase_header",
          "args": [
            "p"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "erase_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "178-183",
          "snippet": "static void erase_header(struct ctl_table_header *head)\n{\n\tstruct ctl_table *entry;\n\tfor (entry = head->ctl_table; entry->procname; entry++)\n\t\terase_entry(head, entry);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int insert_links(struct ctl_table_header *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic int insert_links(struct ctl_table_header *head);\n\nstatic void erase_header(struct ctl_table_header *head)\n{\n\tstruct ctl_table *entry;\n\tfor (entry = head->ctl_table; entry->procname; entry++)\n\t\terase_entry(head, entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sysctl_lock"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&wait"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_wait_for_completion_rpc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "1116-1122",
          "snippet": "static int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nstatic int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sysctl_lock"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&wait"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p->used"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(sysctl_lock);\n\nstatic void start_unregistering(struct ctl_table_header *p)\n{\n\t/*\n\t * if p->used is 0, nobody will ever touch that entry again;\n\t * we'll eliminate all paths to it before dropping sysctl_lock\n\t */\n\tif (unlikely(p->used)) {\n\t\tstruct completion wait;\n\t\tinit_completion(&wait);\n\t\tp->unregistering = &wait;\n\t\tspin_unlock(&sysctl_lock);\n\t\twait_for_completion(&wait);\n\t\tspin_lock(&sysctl_lock);\n\t} else {\n\t\t/* anything non-NULL; we'll never dereference it */\n\t\tp->unregistering = ERR_PTR(-EINVAL);\n\t}\n\t/*\n\t * do not remove from the list until nobody holds it; walking the\n\t * list in do_sysctl() relies on that.\n\t */\n\terase_header(p);\n}"
  },
  {
    "function_name": "unuse_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "220-225",
    "snippet": "static void unuse_table(struct ctl_table_header *p)\n{\n\tif (!--p->used)\n\t\tif (unlikely(p->unregistering))\n\t\t\tcomplete(p->unregistering);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "p->unregistering"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "dio_aio_complete_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/direct-io.c",
          "lines": "275-280",
          "snippet": "static void dio_aio_complete_work(struct work_struct *work)\n{\n\tstruct dio *dio = container_of(work, struct dio, complete_work);\n\n\tdio_complete(dio, dio->iocb->ki_pos, 0, true);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uio.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/err.h>",
            "#include <linux/wait.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/prefetch.h>\n#include <linux/atomic.h>\n#include <linux/uio.h>\n#include <linux/rwsem.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/err.h>\n#include <linux/wait.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void dio_aio_complete_work(struct work_struct *work)\n{\n\tstruct dio *dio = container_of(work, struct dio, complete_work);\n\n\tdio_complete(dio, dio->iocb->ki_pos, 0, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p->unregistering"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void unuse_table(struct ctl_table_header *p)\n{\n\tif (!--p->used)\n\t\tif (unlikely(p->unregistering))\n\t\t\tcomplete(p->unregistering);\n}"
  },
  {
    "function_name": "use_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "211-217",
    "snippet": "static int use_table(struct ctl_table_header *p)\n{\n\tif (unlikely(p->unregistering))\n\t\treturn 0;\n\tp->used++;\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p->unregistering"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic int use_table(struct ctl_table_header *p)\n{\n\tif (unlikely(p->unregistering))\n\t\treturn 0;\n\tp->used++;\n\treturn 1;\n}"
  },
  {
    "function_name": "insert_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "185-208",
    "snippet": "static int insert_header(struct ctl_dir *dir, struct ctl_table_header *header)\n{\n\tstruct ctl_table *entry;\n\tint err;\n\n\tdir->header.nreg++;\n\theader->parent = dir;\n\terr = insert_links(header);\n\tif (err)\n\t\tgoto fail_links;\n\tfor (entry = header->ctl_table; entry->procname; entry++) {\n\t\terr = insert_entry(header, entry);\n\t\tif (err)\n\t\t\tgoto fail;\n\t}\n\treturn 0;\nfail:\n\terase_header(header);\n\tput_links(header);\nfail_links:\n\theader->parent = NULL;\n\tdrop_sysctl_table(&dir->header);\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void drop_sysctl_table(struct ctl_table_header *header);",
      "static void put_links(struct ctl_table_header *header);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "drop_sysctl_table",
          "args": [
            "&dir->header"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "drop_sysctl_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "1505-1519",
          "snippet": "static void drop_sysctl_table(struct ctl_table_header *header)\n{\n\tstruct ctl_dir *parent = header->parent;\n\n\tif (--header->nreg)\n\t\treturn;\n\n\tput_links(header);\n\tstart_unregistering(header);\n\tif (!--header->count)\n\t\tkfree_rcu(header, rcu);\n\n\tif (parent)\n\t\tdrop_sysctl_table(&parent->header);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic void drop_sysctl_table(struct ctl_table_header *header)\n{\n\tstruct ctl_dir *parent = header->parent;\n\n\tif (--header->nreg)\n\t\treturn;\n\n\tput_links(header);\n\tstart_unregistering(header);\n\tif (!--header->count)\n\t\tkfree_rcu(header, rcu);\n\n\tif (parent)\n\t\tdrop_sysctl_table(&parent->header);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_links",
          "args": [
            "header"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "put_links",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "1471-1503",
          "snippet": "static void put_links(struct ctl_table_header *header)\n{\n\tstruct ctl_table_set *root_set = &sysctl_table_root.default_set;\n\tstruct ctl_table_root *root = header->root;\n\tstruct ctl_dir *parent = header->parent;\n\tstruct ctl_dir *core_parent;\n\tstruct ctl_table *entry;\n\n\tif (header->set == root_set)\n\t\treturn;\n\n\tcore_parent = xlate_dir(root_set, parent);\n\tif (IS_ERR(core_parent))\n\t\treturn;\n\n\tfor (entry = header->ctl_table; entry->procname; entry++) {\n\t\tstruct ctl_table_header *link_head;\n\t\tstruct ctl_table *link;\n\t\tconst char *name = entry->procname;\n\n\t\tlink = find_entry(&link_head, core_parent, name, strlen(name));\n\t\tif (link &&\n\t\t    ((S_ISDIR(link->mode) && S_ISDIR(entry->mode)) ||\n\t\t     (S_ISLNK(link->mode) && (link->data == root)))) {\n\t\t\tdrop_sysctl_table(link_head);\n\t\t}\n\t\telse {\n\t\t\tpr_err(\"sysctl link missing during unregister: \");\n\t\t\tsysctl_print_dir(parent);\n\t\t\tpr_cont(\"/%s\\n\", name);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ctl_table_root sysctl_table_root = {\n\t.default_set.dir.header = {\n\t\t{{.count = 1,\n\t\t  .nreg = 1,\n\t\t  .ctl_table = root_table }},\n\t\t.ctl_table_arg = root_table,\n\t\t.root = &sysctl_table_root,\n\t\t.set = &sysctl_table_root.default_set,\n\t},\n};",
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic struct ctl_table_root sysctl_table_root = {\n\t.default_set.dir.header = {\n\t\t{{.count = 1,\n\t\t  .nreg = 1,\n\t\t  .ctl_table = root_table }},\n\t\t.ctl_table_arg = root_table,\n\t\t.root = &sysctl_table_root,\n\t\t.set = &sysctl_table_root.default_set,\n\t},\n};\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic void put_links(struct ctl_table_header *header)\n{\n\tstruct ctl_table_set *root_set = &sysctl_table_root.default_set;\n\tstruct ctl_table_root *root = header->root;\n\tstruct ctl_dir *parent = header->parent;\n\tstruct ctl_dir *core_parent;\n\tstruct ctl_table *entry;\n\n\tif (header->set == root_set)\n\t\treturn;\n\n\tcore_parent = xlate_dir(root_set, parent);\n\tif (IS_ERR(core_parent))\n\t\treturn;\n\n\tfor (entry = header->ctl_table; entry->procname; entry++) {\n\t\tstruct ctl_table_header *link_head;\n\t\tstruct ctl_table *link;\n\t\tconst char *name = entry->procname;\n\n\t\tlink = find_entry(&link_head, core_parent, name, strlen(name));\n\t\tif (link &&\n\t\t    ((S_ISDIR(link->mode) && S_ISDIR(entry->mode)) ||\n\t\t     (S_ISLNK(link->mode) && (link->data == root)))) {\n\t\t\tdrop_sysctl_table(link_head);\n\t\t}\n\t\telse {\n\t\t\tpr_err(\"sysctl link missing during unregister: \");\n\t\t\tsysctl_print_dir(parent);\n\t\t\tpr_cont(\"/%s\\n\", name);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "erase_header",
          "args": [
            "header"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "erase_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "178-183",
          "snippet": "static void erase_header(struct ctl_table_header *head)\n{\n\tstruct ctl_table *entry;\n\tfor (entry = head->ctl_table; entry->procname; entry++)\n\t\terase_entry(head, entry);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int insert_links(struct ctl_table_header *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic int insert_links(struct ctl_table_header *head);\n\nstatic void erase_header(struct ctl_table_header *head)\n{\n\tstruct ctl_table *entry;\n\tfor (entry = head->ctl_table; entry->procname; entry++)\n\t\terase_entry(head, entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_entry",
          "args": [
            "header",
            "entry"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "insert_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "111-148",
          "snippet": "static int insert_entry(struct ctl_table_header *head, struct ctl_table *entry)\n{\n\tstruct rb_node *node = &head->node[entry - head->ctl_table].node;\n\tstruct rb_node **p = &head->parent->root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tconst char *name = entry->procname;\n\tint namelen = strlen(name);\n\n\twhile (*p) {\n\t\tstruct ctl_table_header *parent_head;\n\t\tstruct ctl_table *parent_entry;\n\t\tstruct ctl_node *parent_node;\n\t\tconst char *parent_name;\n\t\tint cmp;\n\n\t\tparent = *p;\n\t\tparent_node = rb_entry(parent, struct ctl_node, node);\n\t\tparent_head = parent_node->header;\n\t\tparent_entry = &parent_head->ctl_table[parent_node - parent_head->node];\n\t\tparent_name = parent_entry->procname;\n\n\t\tcmp = namecmp(name, namelen, parent_name, strlen(parent_name));\n\t\tif (cmp < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (cmp > 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\tpr_err(\"sysctl duplicate entry: \");\n\t\t\tsysctl_print_dir(head->parent);\n\t\t\tpr_cont(\"/%s\\n\", entry->procname);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, &head->parent->root);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static int insert_links(struct ctl_table_header *head);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic int insert_links(struct ctl_table_header *head);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic int insert_entry(struct ctl_table_header *head, struct ctl_table *entry)\n{\n\tstruct rb_node *node = &head->node[entry - head->ctl_table].node;\n\tstruct rb_node **p = &head->parent->root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tconst char *name = entry->procname;\n\tint namelen = strlen(name);\n\n\twhile (*p) {\n\t\tstruct ctl_table_header *parent_head;\n\t\tstruct ctl_table *parent_entry;\n\t\tstruct ctl_node *parent_node;\n\t\tconst char *parent_name;\n\t\tint cmp;\n\n\t\tparent = *p;\n\t\tparent_node = rb_entry(parent, struct ctl_node, node);\n\t\tparent_head = parent_node->header;\n\t\tparent_entry = &parent_head->ctl_table[parent_node - parent_head->node];\n\t\tparent_name = parent_entry->procname;\n\n\t\tcmp = namecmp(name, namelen, parent_name, strlen(parent_name));\n\t\tif (cmp < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (cmp > 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\tpr_err(\"sysctl duplicate entry: \");\n\t\t\tsysctl_print_dir(head->parent);\n\t\t\tpr_cont(\"/%s\\n\", entry->procname);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, &head->parent->root);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_links",
          "args": [
            "header"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "insert_links",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "1091-1130",
          "snippet": "static int insert_links(struct ctl_table_header *head)\n{\n\tstruct ctl_table_set *root_set = &sysctl_table_root.default_set;\n\tstruct ctl_dir *core_parent = NULL;\n\tstruct ctl_table_header *links;\n\tint err;\n\n\tif (head->set == root_set)\n\t\treturn 0;\n\n\tcore_parent = xlate_dir(root_set, head->parent);\n\tif (IS_ERR(core_parent))\n\t\treturn 0;\n\n\tif (get_links(core_parent, head->ctl_table, head->root))\n\t\treturn 0;\n\n\tcore_parent->header.nreg++;\n\tspin_unlock(&sysctl_lock);\n\n\tlinks = new_links(core_parent, head->ctl_table, head->root);\n\n\tspin_lock(&sysctl_lock);\n\terr = -ENOMEM;\n\tif (!links)\n\t\tgoto out;\n\n\terr = 0;\n\tif (get_links(core_parent, head->ctl_table, head->root)) {\n\t\tkfree(links);\n\t\tgoto out;\n\t}\n\n\terr = insert_header(core_parent, links);\n\tif (err)\n\t\tkfree(links);\nout:\n\tdrop_sysctl_table(&core_parent->header);\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ctl_table_root sysctl_table_root = {\n\t.default_set.dir.header = {\n\t\t{{.count = 1,\n\t\t  .nreg = 1,\n\t\t  .ctl_table = root_table }},\n\t\t.ctl_table_arg = root_table,\n\t\t.root = &sysctl_table_root,\n\t\t.set = &sysctl_table_root.default_set,\n\t},\n};",
            "static DEFINE_SPINLOCK(sysctl_lock);",
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static int insert_links(struct ctl_table_header *head);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic struct ctl_table_root sysctl_table_root = {\n\t.default_set.dir.header = {\n\t\t{{.count = 1,\n\t\t  .nreg = 1,\n\t\t  .ctl_table = root_table }},\n\t\t.ctl_table_arg = root_table,\n\t\t.root = &sysctl_table_root,\n\t\t.set = &sysctl_table_root.default_set,\n\t},\n};\nstatic DEFINE_SPINLOCK(sysctl_lock);\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic int insert_links(struct ctl_table_header *head);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic int insert_links(struct ctl_table_header *head)\n{\n\tstruct ctl_table_set *root_set = &sysctl_table_root.default_set;\n\tstruct ctl_dir *core_parent = NULL;\n\tstruct ctl_table_header *links;\n\tint err;\n\n\tif (head->set == root_set)\n\t\treturn 0;\n\n\tcore_parent = xlate_dir(root_set, head->parent);\n\tif (IS_ERR(core_parent))\n\t\treturn 0;\n\n\tif (get_links(core_parent, head->ctl_table, head->root))\n\t\treturn 0;\n\n\tcore_parent->header.nreg++;\n\tspin_unlock(&sysctl_lock);\n\n\tlinks = new_links(core_parent, head->ctl_table, head->root);\n\n\tspin_lock(&sysctl_lock);\n\terr = -ENOMEM;\n\tif (!links)\n\t\tgoto out;\n\n\terr = 0;\n\tif (get_links(core_parent, head->ctl_table, head->root)) {\n\t\tkfree(links);\n\t\tgoto out;\n\t}\n\n\terr = insert_header(core_parent, links);\n\tif (err)\n\t\tkfree(links);\nout:\n\tdrop_sysctl_table(&core_parent->header);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic int insert_header(struct ctl_dir *dir, struct ctl_table_header *header)\n{\n\tstruct ctl_table *entry;\n\tint err;\n\n\tdir->header.nreg++;\n\theader->parent = dir;\n\terr = insert_links(header);\n\tif (err)\n\t\tgoto fail_links;\n\tfor (entry = header->ctl_table; entry->procname; entry++) {\n\t\terr = insert_entry(header, entry);\n\t\tif (err)\n\t\t\tgoto fail;\n\t}\n\treturn 0;\nfail:\n\terase_header(header);\n\tput_links(header);\nfail_links:\n\theader->parent = NULL;\n\tdrop_sysctl_table(&dir->header);\n\treturn err;\n}"
  },
  {
    "function_name": "erase_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "178-183",
    "snippet": "static void erase_header(struct ctl_table_header *head)\n{\n\tstruct ctl_table *entry;\n\tfor (entry = head->ctl_table; entry->procname; entry++)\n\t\terase_entry(head, entry);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int insert_links(struct ctl_table_header *head);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "erase_entry",
          "args": [
            "head",
            "entry"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "erase_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "150-155",
          "snippet": "static void erase_entry(struct ctl_table_header *head, struct ctl_table *entry)\n{\n\tstruct rb_node *node = &head->node[entry - head->ctl_table].node;\n\n\trb_erase(node, &head->parent->root);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int insert_links(struct ctl_table_header *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic int insert_links(struct ctl_table_header *head);\n\nstatic void erase_entry(struct ctl_table_header *head, struct ctl_table *entry)\n{\n\tstruct rb_node *node = &head->node[entry - head->ctl_table].node;\n\n\trb_erase(node, &head->parent->root);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic int insert_links(struct ctl_table_header *head);\n\nstatic void erase_header(struct ctl_table_header *head)\n{\n\tstruct ctl_table *entry;\n\tfor (entry = head->ctl_table; entry->procname; entry++)\n\t\terase_entry(head, entry);\n}"
  },
  {
    "function_name": "init_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "157-176",
    "snippet": "static void init_header(struct ctl_table_header *head,\n\tstruct ctl_table_root *root, struct ctl_table_set *set,\n\tstruct ctl_node *node, struct ctl_table *table)\n{\n\thead->ctl_table = table;\n\thead->ctl_table_arg = table;\n\thead->used = 0;\n\thead->count = 1;\n\thead->nreg = 1;\n\thead->unregistering = NULL;\n\thead->root = root;\n\thead->set = set;\n\thead->parent = NULL;\n\thead->node = node;\n\tif (node) {\n\t\tstruct ctl_table *entry;\n\t\tfor (entry = table; entry->procname; entry++, node++)\n\t\t\tnode->header = head;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void drop_sysctl_table(struct ctl_table_header *header);",
      "static int insert_links(struct ctl_table_header *head);",
      "static void put_links(struct ctl_table_header *header);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic int insert_links(struct ctl_table_header *head);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic void init_header(struct ctl_table_header *head,\n\tstruct ctl_table_root *root, struct ctl_table_set *set,\n\tstruct ctl_node *node, struct ctl_table *table)\n{\n\thead->ctl_table = table;\n\thead->ctl_table_arg = table;\n\thead->used = 0;\n\thead->count = 1;\n\thead->nreg = 1;\n\thead->unregistering = NULL;\n\thead->root = root;\n\thead->set = set;\n\thead->parent = NULL;\n\thead->node = node;\n\tif (node) {\n\t\tstruct ctl_table *entry;\n\t\tfor (entry = table; entry->procname; entry++, node++)\n\t\t\tnode->header = head;\n\t}\n}"
  },
  {
    "function_name": "erase_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "150-155",
    "snippet": "static void erase_entry(struct ctl_table_header *head, struct ctl_table *entry)\n{\n\tstruct rb_node *node = &head->node[entry - head->ctl_table].node;\n\n\trb_erase(node, &head->parent->root);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int insert_links(struct ctl_table_header *head);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "node",
            "&head->parent->root"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic int insert_links(struct ctl_table_header *head);\n\nstatic void erase_entry(struct ctl_table_header *head, struct ctl_table *entry)\n{\n\tstruct rb_node *node = &head->node[entry - head->ctl_table].node;\n\n\trb_erase(node, &head->parent->root);\n}"
  },
  {
    "function_name": "insert_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "111-148",
    "snippet": "static int insert_entry(struct ctl_table_header *head, struct ctl_table *entry)\n{\n\tstruct rb_node *node = &head->node[entry - head->ctl_table].node;\n\tstruct rb_node **p = &head->parent->root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tconst char *name = entry->procname;\n\tint namelen = strlen(name);\n\n\twhile (*p) {\n\t\tstruct ctl_table_header *parent_head;\n\t\tstruct ctl_table *parent_entry;\n\t\tstruct ctl_node *parent_node;\n\t\tconst char *parent_name;\n\t\tint cmp;\n\n\t\tparent = *p;\n\t\tparent_node = rb_entry(parent, struct ctl_node, node);\n\t\tparent_head = parent_node->header;\n\t\tparent_entry = &parent_head->ctl_table[parent_node - parent_head->node];\n\t\tparent_name = parent_entry->procname;\n\n\t\tcmp = namecmp(name, namelen, parent_name, strlen(parent_name));\n\t\tif (cmp < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (cmp > 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\tpr_err(\"sysctl duplicate entry: \");\n\t\t\tsysctl_print_dir(head->parent);\n\t\t\tpr_cont(\"/%s\\n\", entry->procname);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, &head->parent->root);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void drop_sysctl_table(struct ctl_table_header *header);",
      "static int insert_links(struct ctl_table_header *head);",
      "static void put_links(struct ctl_table_header *header);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "node",
            "&head->parent->root"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "node",
            "parent",
            "p"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"/%s\\n\"",
            "entry->procname"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysctl_print_dir",
          "args": [
            "head->parent"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "sysctl_print_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "57-62",
          "snippet": "static void sysctl_print_dir(struct ctl_dir *dir)\n{\n\tif (dir->header.parent)\n\t\tsysctl_print_dir(dir->header.parent);\n\tpr_cont(\"%s/\", dir->header.ctl_table[0].procname);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void drop_sysctl_table(struct ctl_table_header *header);",
            "static void put_links(struct ctl_table_header *header);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic void sysctl_print_dir(struct ctl_dir *dir)\n{\n\tif (dir->header.parent)\n\t\tsysctl_print_dir(dir->header.parent);\n\tpr_cont(\"%s/\", dir->header.ctl_table[0].procname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"sysctl duplicate entry: \""
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "namecmp",
          "args": [
            "name",
            "namelen",
            "parent_name",
            "strlen(parent_name)"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "namecmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "64-77",
          "snippet": "static int namecmp(const char *name1, int len1, const char *name2, int len2)\n{\n\tint minlen;\n\tint cmp;\n\n\tminlen = len1;\n\tif (minlen > len2)\n\t\tminlen = len2;\n\n\tcmp = memcmp(name1, name2, minlen);\n\tif (cmp == 0)\n\t\tcmp = len1 - len2;\n\treturn cmp;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic int namecmp(const char *name1, int len1, const char *name2, int len2)\n{\n\tint minlen;\n\tint cmp;\n\n\tminlen = len1;\n\tif (minlen > len2)\n\t\tminlen = len2;\n\n\tcmp = memcmp(name1, name2, minlen);\n\tif (cmp == 0)\n\t\tcmp = len1 - len2;\n\treturn cmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "parent_name"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structctl_node",
            "node"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic int insert_links(struct ctl_table_header *head);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic int insert_entry(struct ctl_table_header *head, struct ctl_table *entry)\n{\n\tstruct rb_node *node = &head->node[entry - head->ctl_table].node;\n\tstruct rb_node **p = &head->parent->root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tconst char *name = entry->procname;\n\tint namelen = strlen(name);\n\n\twhile (*p) {\n\t\tstruct ctl_table_header *parent_head;\n\t\tstruct ctl_table *parent_entry;\n\t\tstruct ctl_node *parent_node;\n\t\tconst char *parent_name;\n\t\tint cmp;\n\n\t\tparent = *p;\n\t\tparent_node = rb_entry(parent, struct ctl_node, node);\n\t\tparent_head = parent_node->header;\n\t\tparent_entry = &parent_head->ctl_table[parent_node - parent_head->node];\n\t\tparent_name = parent_entry->procname;\n\n\t\tcmp = namecmp(name, namelen, parent_name, strlen(parent_name));\n\t\tif (cmp < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (cmp > 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\tpr_err(\"sysctl duplicate entry: \");\n\t\t\tsysctl_print_dir(head->parent);\n\t\t\tpr_cont(\"/%s\\n\", entry->procname);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, &head->parent->root);\n\treturn 0;\n}"
  },
  {
    "function_name": "find_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "80-109",
    "snippet": "static struct ctl_table *find_entry(struct ctl_table_header **phead,\n\tstruct ctl_dir *dir, const char *name, int namelen)\n{\n\tstruct ctl_table_header *head;\n\tstruct ctl_table *entry;\n\tstruct rb_node *node = dir->root.rb_node;\n\n\twhile (node)\n\t{\n\t\tstruct ctl_node *ctl_node;\n\t\tconst char *procname;\n\t\tint cmp;\n\n\t\tctl_node = rb_entry(node, struct ctl_node, node);\n\t\thead = ctl_node->header;\n\t\tentry = &head->ctl_table[ctl_node - head->node];\n\t\tprocname = entry->procname;\n\n\t\tcmp = namecmp(name, namelen, procname, strlen(procname));\n\t\tif (cmp < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (cmp > 0)\n\t\t\tnode = node->rb_right;\n\t\telse {\n\t\t\t*phead = head;\n\t\t\treturn entry;\n\t\t}\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void drop_sysctl_table(struct ctl_table_header *header);",
      "static int insert_links(struct ctl_table_header *head);",
      "static void put_links(struct ctl_table_header *header);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "namecmp",
          "args": [
            "name",
            "namelen",
            "procname",
            "strlen(procname)"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "namecmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "64-77",
          "snippet": "static int namecmp(const char *name1, int len1, const char *name2, int len2)\n{\n\tint minlen;\n\tint cmp;\n\n\tminlen = len1;\n\tif (minlen > len2)\n\t\tminlen = len2;\n\n\tcmp = memcmp(name1, name2, minlen);\n\tif (cmp == 0)\n\t\tcmp = len1 - len2;\n\treturn cmp;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic int namecmp(const char *name1, int len1, const char *name2, int len2)\n{\n\tint minlen;\n\tint cmp;\n\n\tminlen = len1;\n\tif (minlen > len2)\n\t\tminlen = len2;\n\n\tcmp = memcmp(name1, name2, minlen);\n\tif (cmp == 0)\n\t\tcmp = len1 - len2;\n\treturn cmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "procname"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structctl_node",
            "node"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic int insert_links(struct ctl_table_header *head);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic struct ctl_table *find_entry(struct ctl_table_header **phead,\n\tstruct ctl_dir *dir, const char *name, int namelen)\n{\n\tstruct ctl_table_header *head;\n\tstruct ctl_table *entry;\n\tstruct rb_node *node = dir->root.rb_node;\n\n\twhile (node)\n\t{\n\t\tstruct ctl_node *ctl_node;\n\t\tconst char *procname;\n\t\tint cmp;\n\n\t\tctl_node = rb_entry(node, struct ctl_node, node);\n\t\thead = ctl_node->header;\n\t\tentry = &head->ctl_table[ctl_node - head->node];\n\t\tprocname = entry->procname;\n\n\t\tcmp = namecmp(name, namelen, procname, strlen(procname));\n\t\tif (cmp < 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (cmp > 0)\n\t\t\tnode = node->rb_right;\n\t\telse {\n\t\t\t*phead = head;\n\t\t\treturn entry;\n\t\t}\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "namecmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "64-77",
    "snippet": "static int namecmp(const char *name1, int len1, const char *name2, int len2)\n{\n\tint minlen;\n\tint cmp;\n\n\tminlen = len1;\n\tif (minlen > len2)\n\t\tminlen = len2;\n\n\tcmp = memcmp(name1, name2, minlen);\n\tif (cmp == 0)\n\t\tcmp = len1 - len2;\n\treturn cmp;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "name1",
            "name2",
            "minlen"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic int namecmp(const char *name1, int len1, const char *name2, int len2)\n{\n\tint minlen;\n\tint cmp;\n\n\tminlen = len1;\n\tif (minlen > len2)\n\t\tminlen = len2;\n\n\tcmp = memcmp(name1, name2, minlen);\n\tif (cmp == 0)\n\t\tcmp = len1 - len2;\n\treturn cmp;\n}"
  },
  {
    "function_name": "sysctl_print_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "57-62",
    "snippet": "static void sysctl_print_dir(struct ctl_dir *dir)\n{\n\tif (dir->header.parent)\n\t\tsysctl_print_dir(dir->header.parent);\n\tpr_cont(\"%s/\", dir->header.ctl_table[0].procname);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void drop_sysctl_table(struct ctl_table_header *header);",
      "static void put_links(struct ctl_table_header *header);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"%s/\"",
            "dir->header.ctl_table[0].procname"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysctl_print_dir",
          "args": [
            "dir->header.parent"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "sysctl_print_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "57-62",
          "snippet": "static void sysctl_print_dir(struct ctl_dir *dir)\n{\n\tif (dir->header.parent)\n\t\tsysctl_print_dir(dir->header.parent);\n\tpr_cont(\"%s/\", dir->header.ctl_table[0].procname);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic void drop_sysctl_table(struct ctl_table_header *header);\nstatic void put_links(struct ctl_table_header *header);\n\nstatic void sysctl_print_dir(struct ctl_dir *dir)\n{\n\tif (dir->header.parent)\n\t\tsysctl_print_dir(dir->header.parent);\n\tpr_cont(\"%s/\", dir->header.ctl_table[0].procname);\n}"
  },
  {
    "function_name": "proc_sys_poll_notify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
    "lines": "22-29",
    "snippet": "void proc_sys_poll_notify(struct ctl_table_poll *poll)\n{\n\tif (!poll)\n\t\treturn;\n\n\tatomic_inc(&poll->event);\n\twake_up_interruptible(&poll->wait);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/sched.h>",
      "#include <linux/security.h>",
      "#include <linux/printk.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poll.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_interruptible",
          "args": [
            "&poll->wait"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&poll->event"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nvoid proc_sys_poll_notify(struct ctl_table_poll *poll)\n{\n\tif (!poll)\n\t\treturn;\n\n\tatomic_inc(&poll->event);\n\twake_up_interruptible(&poll->wait);\n}"
  }
]