[
  {
    "function_name": "xfs_trans_ail_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
    "lines": "786-794",
    "snippet": "void\nxfs_trans_ail_destroy(\n\txfs_mount_t\t*mp)\n{\n\tstruct xfs_ail\t*ailp = mp->m_ail;\n\n\tkthread_stop(ailp->xa_task);\n\tkmem_free(ailp);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "ailp"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "ailp->xa_task"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ail_destroy(\n\txfs_mount_t\t*mp)\n{\n\tstruct xfs_ail\t*ailp = mp->m_ail;\n\n\tkthread_stop(ailp->xa_task);\n\tkmem_free(ailp);\n}"
  },
  {
    "function_name": "xfs_trans_ail_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
    "lines": "756-784",
    "snippet": "int\nxfs_trans_ail_init(\n\txfs_mount_t\t*mp)\n{\n\tstruct xfs_ail\t*ailp;\n\n\tailp = kmem_zalloc(sizeof(struct xfs_ail), KM_MAYFAIL);\n\tif (!ailp)\n\t\treturn -ENOMEM;\n\n\tailp->xa_mount = mp;\n\tINIT_LIST_HEAD(&ailp->xa_ail);\n\tINIT_LIST_HEAD(&ailp->xa_cursors);\n\tspin_lock_init(&ailp->xa_lock);\n\tINIT_LIST_HEAD(&ailp->xa_buf_list);\n\tinit_waitqueue_head(&ailp->xa_empty);\n\n\tailp->xa_task = kthread_run(xfsaild, ailp, \"xfsaild/%s\",\n\t\t\tailp->xa_mount->m_fsname);\n\tif (IS_ERR(ailp->xa_task))\n\t\tgoto out_free_ailp;\n\n\tmp->m_ail = ailp;\n\treturn 0;\n\nout_free_ailp:\n\tkmem_free(ailp);\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "ailp"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ailp->xa_task"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "xfsaild",
            "ailp",
            "\"xfsaild/%s\"",
            "ailp->xa_mount->m_fsname"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&ailp->xa_empty"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ailp->xa_buf_list"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&ailp->xa_lock"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ailp->xa_cursors"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ailp->xa_ail"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_zalloc",
          "args": [
            "sizeof(struct xfs_ail)",
            "KM_MAYFAIL"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zalloc_large",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "64-92",
          "snippet": "void *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_ail_init(\n\txfs_mount_t\t*mp)\n{\n\tstruct xfs_ail\t*ailp;\n\n\tailp = kmem_zalloc(sizeof(struct xfs_ail), KM_MAYFAIL);\n\tif (!ailp)\n\t\treturn -ENOMEM;\n\n\tailp->xa_mount = mp;\n\tINIT_LIST_HEAD(&ailp->xa_ail);\n\tINIT_LIST_HEAD(&ailp->xa_cursors);\n\tspin_lock_init(&ailp->xa_lock);\n\tINIT_LIST_HEAD(&ailp->xa_buf_list);\n\tinit_waitqueue_head(&ailp->xa_empty);\n\n\tailp->xa_task = kthread_run(xfsaild, ailp, \"xfsaild/%s\",\n\t\t\tailp->xa_mount->m_fsname);\n\tif (IS_ERR(ailp->xa_task))\n\t\tgoto out_free_ailp;\n\n\tmp->m_ail = ailp;\n\treturn 0;\n\nout_free_ailp:\n\tkmem_free(ailp);\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "xfs_trans_ail_delete_bulk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
    "lines": "707-754",
    "snippet": "void\nxfs_trans_ail_delete_bulk(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_log_item\t**log_items,\n\tint\t\t\tnr_items,\n\tint\t\t\tshutdown_type) __releases(ailp->xa_lock)\n{\n\txfs_log_item_t\t\t*mlip;\n\tint\t\t\tmlip_changed = 0;\n\tint\t\t\ti;\n\n\tmlip = xfs_ail_min(ailp);\n\n\tfor (i = 0; i < nr_items; i++) {\n\t\tstruct xfs_log_item *lip = log_items[i];\n\t\tif (!(lip->li_flags & XFS_LI_IN_AIL)) {\n\t\t\tstruct xfs_mount\t*mp = ailp->xa_mount;\n\n\t\t\tspin_unlock(&ailp->xa_lock);\n\t\t\tif (!XFS_FORCED_SHUTDOWN(mp)) {\n\t\t\t\txfs_alert_tag(mp, XFS_PTAG_AILDELETE,\n\t\t\"%s: attempting to delete a log item that is not in the AIL\",\n\t\t\t\t\t\t__func__);\n\t\t\t\txfs_force_shutdown(mp, shutdown_type);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\ttrace_xfs_ail_delete(lip, mlip->li_lsn, lip->li_lsn);\n\t\txfs_ail_delete(ailp, lip);\n\t\tlip->li_flags &= ~XFS_LI_IN_AIL;\n\t\tlip->li_lsn = 0;\n\t\tif (mlip == lip)\n\t\t\tmlip_changed = 1;\n\t}\n\n\tif (mlip_changed) {\n\t\tif (!XFS_FORCED_SHUTDOWN(ailp->xa_mount))\n\t\t\txlog_assign_tail_lsn_locked(ailp->xa_mount);\n\t\tif (list_empty(&ailp->xa_ail))\n\t\t\twake_up_all(&ailp->xa_empty);\n\t\tspin_unlock(&ailp->xa_lock);\n\n\t\txfs_log_space_wake(ailp->xa_mount);\n\t} else {\n\t\tspin_unlock(&ailp->xa_lock);\n\t}\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ailp->xa_lock"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_log_space_wake",
          "args": [
            "ailp->xa_mount"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_space_wake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "981-1008",
          "snippet": "void\nxfs_log_space_wake(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tint\t\t\tfree_bytes;\n\n\tif (XLOG_FORCED_SHUTDOWN(log))\n\t\treturn;\n\n\tif (!list_empty_careful(&log->l_write_head.waiters)) {\n\t\tASSERT(!(log->l_flags & XLOG_ACTIVE_RECOVERY));\n\n\t\tspin_lock(&log->l_write_head.lock);\n\t\tfree_bytes = xlog_space_left(log, &log->l_write_head.grant);\n\t\txlog_grant_head_wake(log, &log->l_write_head, &free_bytes);\n\t\tspin_unlock(&log->l_write_head.lock);\n\t}\n\n\tif (!list_empty_careful(&log->l_reserve_head.waiters)) {\n\t\tASSERT(!(log->l_flags & XLOG_ACTIVE_RECOVERY));\n\n\t\tspin_lock(&log->l_reserve_head.lock);\n\t\tfree_bytes = xlog_space_left(log, &log->l_reserve_head.grant);\n\t\txlog_grant_head_wake(log, &log->l_reserve_head, &free_bytes);\n\t\tspin_unlock(&log->l_reserve_head.lock);\n\t}\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nvoid\nxfs_log_space_wake(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tint\t\t\tfree_bytes;\n\n\tif (XLOG_FORCED_SHUTDOWN(log))\n\t\treturn;\n\n\tif (!list_empty_careful(&log->l_write_head.waiters)) {\n\t\tASSERT(!(log->l_flags & XLOG_ACTIVE_RECOVERY));\n\n\t\tspin_lock(&log->l_write_head.lock);\n\t\tfree_bytes = xlog_space_left(log, &log->l_write_head.grant);\n\t\txlog_grant_head_wake(log, &log->l_write_head, &free_bytes);\n\t\tspin_unlock(&log->l_write_head.lock);\n\t}\n\n\tif (!list_empty_careful(&log->l_reserve_head.waiters)) {\n\t\tASSERT(!(log->l_flags & XLOG_ACTIVE_RECOVERY));\n\n\t\tspin_lock(&log->l_reserve_head.lock);\n\t\tfree_bytes = xlog_space_left(log, &log->l_reserve_head.grant);\n\t\txlog_grant_head_wake(log, &log->l_reserve_head, &free_bytes);\n\t\tspin_unlock(&log->l_reserve_head.lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&ailp->xa_empty"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ailp->xa_ail"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_assign_tail_lsn_locked",
          "args": [
            "ailp->xa_mount"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_assign_tail_lsn_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1069-1092",
          "snippet": "xfs_lsn_t\nxlog_assign_tail_lsn_locked(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tstruct xfs_log_item\t*lip;\n\txfs_lsn_t\t\ttail_lsn;\n\n\tassert_spin_locked(&mp->m_ail->xa_lock);\n\n\t/*\n\t * To make sure we always have a valid LSN for the log tail we keep\n\t * track of the last LSN which was committed in log->l_last_sync_lsn,\n\t * and use that when the AIL was empty.\n\t */\n\tlip = xfs_ail_min(mp->m_ail);\n\tif (lip)\n\t\ttail_lsn = lip->li_lsn;\n\telse\n\t\ttail_lsn = atomic64_read(&log->l_last_sync_lsn);\n\ttrace_xfs_log_assign_tail_lsn(log, tail_lsn);\n\tatomic64_set(&log->l_tail_lsn, tail_lsn);\n\treturn tail_lsn;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nxfs_lsn_t\nxlog_assign_tail_lsn_locked(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tstruct xfs_log_item\t*lip;\n\txfs_lsn_t\t\ttail_lsn;\n\n\tassert_spin_locked(&mp->m_ail->xa_lock);\n\n\t/*\n\t * To make sure we always have a valid LSN for the log tail we keep\n\t * track of the last LSN which was committed in log->l_last_sync_lsn,\n\t * and use that when the AIL was empty.\n\t */\n\tlip = xfs_ail_min(mp->m_ail);\n\tif (lip)\n\t\ttail_lsn = lip->li_lsn;\n\telse\n\t\ttail_lsn = atomic64_read(&log->l_last_sync_lsn);\n\ttrace_xfs_log_assign_tail_lsn(log, tail_lsn);\n\tatomic64_set(&log->l_tail_lsn, tail_lsn);\n\treturn tail_lsn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "ailp->xa_mount"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_ail_delete",
          "args": [
            "ailp",
            "lip"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ail_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
          "lines": "318-326",
          "snippet": "static void\nxfs_ail_delete(\n\tstruct xfs_ail  *ailp,\n\txfs_log_item_t  *lip)\n{\n\txfs_ail_check(ailp, lip);\n\tlist_del(&lip->li_ail);\n\txfs_trans_ail_cursor_clear(ailp, lip);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_ail_delete(\n\tstruct xfs_ail  *ailp,\n\txfs_log_item_t  *lip)\n{\n\txfs_ail_check(ailp, lip);\n\tlist_del(&lip->li_ail);\n\txfs_trans_ail_cursor_clear(ailp, lip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_ail_delete",
          "args": [
            "lip",
            "mlip->li_lsn",
            "lip->li_lsn"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_force_shutdown",
          "args": [
            "mp",
            "shutdown_type"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alert_tag",
          "args": [
            "mp",
            "XFS_PTAG_AILDELETE",
            "\"%s: attempting to delete a log item that is not in the AIL\"",
            "__func__"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alert_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_message.c",
          "lines": "67-91",
          "snippet": "void\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}",
          "includes": [
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_ail_min",
          "args": [
            "ailp"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ail_min_lsn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
          "lines": "100-114",
          "snippet": "xfs_lsn_t\nxfs_ail_min_lsn(\n\tstruct xfs_ail\t*ailp)\n{\n\txfs_lsn_t\tlsn = 0;\n\txfs_log_item_t\t*lip;\n\n\tspin_lock(&ailp->xa_lock);\n\tlip = xfs_ail_min(ailp);\n\tif (lip)\n\t\tlsn = lip->li_lsn;\n\tspin_unlock(&ailp->xa_lock);\n\n\treturn lsn;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_lsn_t\nxfs_ail_min_lsn(\n\tstruct xfs_ail\t*ailp)\n{\n\txfs_lsn_t\tlsn = 0;\n\txfs_log_item_t\t*lip;\n\n\tspin_lock(&ailp->xa_lock);\n\tlip = xfs_ail_min(ailp);\n\tif (lip)\n\t\tlsn = lip->li_lsn;\n\tspin_unlock(&ailp->xa_lock);\n\n\treturn lsn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "ailp->xa_lock"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ail_delete_bulk(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_log_item\t**log_items,\n\tint\t\t\tnr_items,\n\tint\t\t\tshutdown_type) __releases(ailp->xa_lock)\n{\n\txfs_log_item_t\t\t*mlip;\n\tint\t\t\tmlip_changed = 0;\n\tint\t\t\ti;\n\n\tmlip = xfs_ail_min(ailp);\n\n\tfor (i = 0; i < nr_items; i++) {\n\t\tstruct xfs_log_item *lip = log_items[i];\n\t\tif (!(lip->li_flags & XFS_LI_IN_AIL)) {\n\t\t\tstruct xfs_mount\t*mp = ailp->xa_mount;\n\n\t\t\tspin_unlock(&ailp->xa_lock);\n\t\t\tif (!XFS_FORCED_SHUTDOWN(mp)) {\n\t\t\t\txfs_alert_tag(mp, XFS_PTAG_AILDELETE,\n\t\t\"%s: attempting to delete a log item that is not in the AIL\",\n\t\t\t\t\t\t__func__);\n\t\t\t\txfs_force_shutdown(mp, shutdown_type);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\ttrace_xfs_ail_delete(lip, mlip->li_lsn, lip->li_lsn);\n\t\txfs_ail_delete(ailp, lip);\n\t\tlip->li_flags &= ~XFS_LI_IN_AIL;\n\t\tlip->li_lsn = 0;\n\t\tif (mlip == lip)\n\t\t\tmlip_changed = 1;\n\t}\n\n\tif (mlip_changed) {\n\t\tif (!XFS_FORCED_SHUTDOWN(ailp->xa_mount))\n\t\t\txlog_assign_tail_lsn_locked(ailp->xa_mount);\n\t\tif (list_empty(&ailp->xa_ail))\n\t\t\twake_up_all(&ailp->xa_empty);\n\t\tspin_unlock(&ailp->xa_lock);\n\n\t\txfs_log_space_wake(ailp->xa_mount);\n\t} else {\n\t\tspin_unlock(&ailp->xa_lock);\n\t}\n}"
  },
  {
    "function_name": "xfs_trans_ail_update_bulk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
    "lines": "637-684",
    "snippet": "void\nxfs_trans_ail_update_bulk(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_ail_cursor\t*cur,\n\tstruct xfs_log_item\t**log_items,\n\tint\t\t\tnr_items,\n\txfs_lsn_t\t\tlsn) __releases(ailp->xa_lock)\n{\n\txfs_log_item_t\t\t*mlip;\n\tint\t\t\tmlip_changed = 0;\n\tint\t\t\ti;\n\tLIST_HEAD(tmp);\n\n\tASSERT(nr_items > 0);\t\t/* Not required, but true. */\n\tmlip = xfs_ail_min(ailp);\n\n\tfor (i = 0; i < nr_items; i++) {\n\t\tstruct xfs_log_item *lip = log_items[i];\n\t\tif (lip->li_flags & XFS_LI_IN_AIL) {\n\t\t\t/* check if we really need to move the item */\n\t\t\tif (XFS_LSN_CMP(lsn, lip->li_lsn) <= 0)\n\t\t\t\tcontinue;\n\n\t\t\ttrace_xfs_ail_move(lip, lip->li_lsn, lsn);\n\t\t\txfs_ail_delete(ailp, lip);\n\t\t\tif (mlip == lip)\n\t\t\t\tmlip_changed = 1;\n\t\t} else {\n\t\t\tlip->li_flags |= XFS_LI_IN_AIL;\n\t\t\ttrace_xfs_ail_insert(lip, 0, lsn);\n\t\t}\n\t\tlip->li_lsn = lsn;\n\t\tlist_add(&lip->li_ail, &tmp);\n\t}\n\n\tif (!list_empty(&tmp))\n\t\txfs_ail_splice(ailp, cur, &tmp, lsn);\n\n\tif (mlip_changed) {\n\t\tif (!XFS_FORCED_SHUTDOWN(ailp->xa_mount))\n\t\t\txlog_assign_tail_lsn_locked(ailp->xa_mount);\n\t\tspin_unlock(&ailp->xa_lock);\n\n\t\txfs_log_space_wake(ailp->xa_mount);\n\t} else {\n\t\tspin_unlock(&ailp->xa_lock);\n\t}\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ailp->xa_lock"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_log_space_wake",
          "args": [
            "ailp->xa_mount"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_space_wake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "981-1008",
          "snippet": "void\nxfs_log_space_wake(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tint\t\t\tfree_bytes;\n\n\tif (XLOG_FORCED_SHUTDOWN(log))\n\t\treturn;\n\n\tif (!list_empty_careful(&log->l_write_head.waiters)) {\n\t\tASSERT(!(log->l_flags & XLOG_ACTIVE_RECOVERY));\n\n\t\tspin_lock(&log->l_write_head.lock);\n\t\tfree_bytes = xlog_space_left(log, &log->l_write_head.grant);\n\t\txlog_grant_head_wake(log, &log->l_write_head, &free_bytes);\n\t\tspin_unlock(&log->l_write_head.lock);\n\t}\n\n\tif (!list_empty_careful(&log->l_reserve_head.waiters)) {\n\t\tASSERT(!(log->l_flags & XLOG_ACTIVE_RECOVERY));\n\n\t\tspin_lock(&log->l_reserve_head.lock);\n\t\tfree_bytes = xlog_space_left(log, &log->l_reserve_head.grant);\n\t\txlog_grant_head_wake(log, &log->l_reserve_head, &free_bytes);\n\t\tspin_unlock(&log->l_reserve_head.lock);\n\t}\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nvoid\nxfs_log_space_wake(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tint\t\t\tfree_bytes;\n\n\tif (XLOG_FORCED_SHUTDOWN(log))\n\t\treturn;\n\n\tif (!list_empty_careful(&log->l_write_head.waiters)) {\n\t\tASSERT(!(log->l_flags & XLOG_ACTIVE_RECOVERY));\n\n\t\tspin_lock(&log->l_write_head.lock);\n\t\tfree_bytes = xlog_space_left(log, &log->l_write_head.grant);\n\t\txlog_grant_head_wake(log, &log->l_write_head, &free_bytes);\n\t\tspin_unlock(&log->l_write_head.lock);\n\t}\n\n\tif (!list_empty_careful(&log->l_reserve_head.waiters)) {\n\t\tASSERT(!(log->l_flags & XLOG_ACTIVE_RECOVERY));\n\n\t\tspin_lock(&log->l_reserve_head.lock);\n\t\tfree_bytes = xlog_space_left(log, &log->l_reserve_head.grant);\n\t\txlog_grant_head_wake(log, &log->l_reserve_head, &free_bytes);\n\t\tspin_unlock(&log->l_reserve_head.lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_assign_tail_lsn_locked",
          "args": [
            "ailp->xa_mount"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_assign_tail_lsn_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1069-1092",
          "snippet": "xfs_lsn_t\nxlog_assign_tail_lsn_locked(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tstruct xfs_log_item\t*lip;\n\txfs_lsn_t\t\ttail_lsn;\n\n\tassert_spin_locked(&mp->m_ail->xa_lock);\n\n\t/*\n\t * To make sure we always have a valid LSN for the log tail we keep\n\t * track of the last LSN which was committed in log->l_last_sync_lsn,\n\t * and use that when the AIL was empty.\n\t */\n\tlip = xfs_ail_min(mp->m_ail);\n\tif (lip)\n\t\ttail_lsn = lip->li_lsn;\n\telse\n\t\ttail_lsn = atomic64_read(&log->l_last_sync_lsn);\n\ttrace_xfs_log_assign_tail_lsn(log, tail_lsn);\n\tatomic64_set(&log->l_tail_lsn, tail_lsn);\n\treturn tail_lsn;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nxfs_lsn_t\nxlog_assign_tail_lsn_locked(\n\tstruct xfs_mount\t*mp)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tstruct xfs_log_item\t*lip;\n\txfs_lsn_t\t\ttail_lsn;\n\n\tassert_spin_locked(&mp->m_ail->xa_lock);\n\n\t/*\n\t * To make sure we always have a valid LSN for the log tail we keep\n\t * track of the last LSN which was committed in log->l_last_sync_lsn,\n\t * and use that when the AIL was empty.\n\t */\n\tlip = xfs_ail_min(mp->m_ail);\n\tif (lip)\n\t\ttail_lsn = lip->li_lsn;\n\telse\n\t\ttail_lsn = atomic64_read(&log->l_last_sync_lsn);\n\ttrace_xfs_log_assign_tail_lsn(log, tail_lsn);\n\tatomic64_set(&log->l_tail_lsn, tail_lsn);\n\treturn tail_lsn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "ailp->xa_mount"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_ail_splice",
          "args": [
            "ailp",
            "cur",
            "&tmp",
            "lsn"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ail_splice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
          "lines": "273-313",
          "snippet": "static void\nxfs_ail_splice(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_ail_cursor\t*cur,\n\tstruct list_head\t*list,\n\txfs_lsn_t\t\tlsn)\n{\n\tstruct xfs_log_item\t*lip;\n\n\tASSERT(!list_empty(list));\n\n\t/*\n\t * Use the cursor to determine the insertion point if one is\n\t * provided.  If not, or if the one we got is not valid,\n\t * find the place in the AIL where the items belong.\n\t */\n\tlip = cur ? cur->item : NULL;\n\tif (!lip || (__psint_t) lip & 1)\n\t\tlip = __xfs_trans_ail_cursor_last(ailp, lsn);\n\n\t/*\n\t * If a cursor is provided, we know we're processing the AIL\n\t * in lsn order, and future items to be spliced in will\n\t * follow the last one being inserted now.  Update the\n\t * cursor to point to that last item, now while we have a\n\t * reliable pointer to it.\n\t */\n\tif (cur)\n\t\tcur->item = list_entry(list->prev, struct xfs_log_item, li_ail);\n\n\t/*\n\t * Finally perform the splice.  Unless the AIL was empty,\n\t * lip points to the item in the AIL _after_ which the new\n\t * items should go.  If lip is null the AIL was empty, so\n\t * the new items go at the head of the AIL.\n\t */\n\tif (lip)\n\t\tlist_splice(list, &lip->li_ail);\n\telse\n\t\tlist_splice(list, &ailp->xa_ail);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_ail_splice(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_ail_cursor\t*cur,\n\tstruct list_head\t*list,\n\txfs_lsn_t\t\tlsn)\n{\n\tstruct xfs_log_item\t*lip;\n\n\tASSERT(!list_empty(list));\n\n\t/*\n\t * Use the cursor to determine the insertion point if one is\n\t * provided.  If not, or if the one we got is not valid,\n\t * find the place in the AIL where the items belong.\n\t */\n\tlip = cur ? cur->item : NULL;\n\tif (!lip || (__psint_t) lip & 1)\n\t\tlip = __xfs_trans_ail_cursor_last(ailp, lsn);\n\n\t/*\n\t * If a cursor is provided, we know we're processing the AIL\n\t * in lsn order, and future items to be spliced in will\n\t * follow the last one being inserted now.  Update the\n\t * cursor to point to that last item, now while we have a\n\t * reliable pointer to it.\n\t */\n\tif (cur)\n\t\tcur->item = list_entry(list->prev, struct xfs_log_item, li_ail);\n\n\t/*\n\t * Finally perform the splice.  Unless the AIL was empty,\n\t * lip points to the item in the AIL _after_ which the new\n\t * items should go.  If lip is null the AIL was empty, so\n\t * the new items go at the head of the AIL.\n\t */\n\tif (lip)\n\t\tlist_splice(list, &lip->li_ail);\n\telse\n\t\tlist_splice(list, &ailp->xa_ail);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&tmp"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&lip->li_ail",
            "&tmp"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_ail_insert",
          "args": [
            "lip",
            "0",
            "lsn"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_ail_delete",
          "args": [
            "ailp",
            "lip"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ail_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
          "lines": "318-326",
          "snippet": "static void\nxfs_ail_delete(\n\tstruct xfs_ail  *ailp,\n\txfs_log_item_t  *lip)\n{\n\txfs_ail_check(ailp, lip);\n\tlist_del(&lip->li_ail);\n\txfs_trans_ail_cursor_clear(ailp, lip);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_ail_delete(\n\tstruct xfs_ail  *ailp,\n\txfs_log_item_t  *lip)\n{\n\txfs_ail_check(ailp, lip);\n\tlist_del(&lip->li_ail);\n\txfs_trans_ail_cursor_clear(ailp, lip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_ail_move",
          "args": [
            "lip",
            "lip->li_lsn",
            "lsn"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_LSN_CMP",
          "args": [
            "lsn",
            "lip->li_lsn"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_ail_min",
          "args": [
            "ailp"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ail_min_lsn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
          "lines": "100-114",
          "snippet": "xfs_lsn_t\nxfs_ail_min_lsn(\n\tstruct xfs_ail\t*ailp)\n{\n\txfs_lsn_t\tlsn = 0;\n\txfs_log_item_t\t*lip;\n\n\tspin_lock(&ailp->xa_lock);\n\tlip = xfs_ail_min(ailp);\n\tif (lip)\n\t\tlsn = lip->li_lsn;\n\tspin_unlock(&ailp->xa_lock);\n\n\treturn lsn;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_lsn_t\nxfs_ail_min_lsn(\n\tstruct xfs_ail\t*ailp)\n{\n\txfs_lsn_t\tlsn = 0;\n\txfs_log_item_t\t*lip;\n\n\tspin_lock(&ailp->xa_lock);\n\tlip = xfs_ail_min(ailp);\n\tif (lip)\n\t\tlsn = lip->li_lsn;\n\tspin_unlock(&ailp->xa_lock);\n\n\treturn lsn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "nr_items > 0"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "tmp"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "ailp->xa_lock"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ail_update_bulk(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_ail_cursor\t*cur,\n\tstruct xfs_log_item\t**log_items,\n\tint\t\t\tnr_items,\n\txfs_lsn_t\t\tlsn) __releases(ailp->xa_lock)\n{\n\txfs_log_item_t\t\t*mlip;\n\tint\t\t\tmlip_changed = 0;\n\tint\t\t\ti;\n\tLIST_HEAD(tmp);\n\n\tASSERT(nr_items > 0);\t\t/* Not required, but true. */\n\tmlip = xfs_ail_min(ailp);\n\n\tfor (i = 0; i < nr_items; i++) {\n\t\tstruct xfs_log_item *lip = log_items[i];\n\t\tif (lip->li_flags & XFS_LI_IN_AIL) {\n\t\t\t/* check if we really need to move the item */\n\t\t\tif (XFS_LSN_CMP(lsn, lip->li_lsn) <= 0)\n\t\t\t\tcontinue;\n\n\t\t\ttrace_xfs_ail_move(lip, lip->li_lsn, lsn);\n\t\t\txfs_ail_delete(ailp, lip);\n\t\t\tif (mlip == lip)\n\t\t\t\tmlip_changed = 1;\n\t\t} else {\n\t\t\tlip->li_flags |= XFS_LI_IN_AIL;\n\t\t\ttrace_xfs_ail_insert(lip, 0, lsn);\n\t\t}\n\t\tlip->li_lsn = lsn;\n\t\tlist_add(&lip->li_ail, &tmp);\n\t}\n\n\tif (!list_empty(&tmp))\n\t\txfs_ail_splice(ailp, cur, &tmp, lsn);\n\n\tif (mlip_changed) {\n\t\tif (!XFS_FORCED_SHUTDOWN(ailp->xa_mount))\n\t\t\txlog_assign_tail_lsn_locked(ailp->xa_mount);\n\t\tspin_unlock(&ailp->xa_lock);\n\n\t\txfs_log_space_wake(ailp->xa_mount);\n\t} else {\n\t\tspin_unlock(&ailp->xa_lock);\n\t}\n}"
  },
  {
    "function_name": "xfs_ail_push_all_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
    "lines": "594-613",
    "snippet": "void\nxfs_ail_push_all_sync(\n\tstruct xfs_ail  *ailp)\n{\n\tstruct xfs_log_item\t*lip;\n\tDEFINE_WAIT(wait);\n\n\tspin_lock(&ailp->xa_lock);\n\twhile ((lip = xfs_ail_max(ailp)) != NULL) {\n\t\tprepare_to_wait(&ailp->xa_empty, &wait, TASK_UNINTERRUPTIBLE);\n\t\tailp->xa_target = lip->li_lsn;\n\t\twake_up_process(ailp->xa_task);\n\t\tspin_unlock(&ailp->xa_lock);\n\t\tschedule();\n\t\tspin_lock(&ailp->xa_lock);\n\t}\n\tspin_unlock(&ailp->xa_lock);\n\n\tfinish_wait(&ailp->xa_empty, &wait);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "&ailp->xa_empty",
            "&wait"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ailp->xa_lock"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ailp->xa_lock"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "ailp->xa_task"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_to_wait",
          "args": [
            "&ailp->xa_empty",
            "&wait",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_ail_max",
          "args": [
            "ailp"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ail_max_lsn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
          "lines": "119-133",
          "snippet": "static xfs_lsn_t\nxfs_ail_max_lsn(\n\tstruct xfs_ail  *ailp)\n{\n\txfs_lsn_t       lsn = 0;\n\txfs_log_item_t  *lip;\n\n\tspin_lock(&ailp->xa_lock);\n\tlip = xfs_ail_max(ailp);\n\tif (lip)\n\t\tlsn = lip->li_lsn;\n\tspin_unlock(&ailp->xa_lock);\n\n\treturn lsn;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic xfs_lsn_t\nxfs_ail_max_lsn(\n\tstruct xfs_ail  *ailp)\n{\n\txfs_lsn_t       lsn = 0;\n\txfs_log_item_t  *lip;\n\n\tspin_lock(&ailp->xa_lock);\n\tlip = xfs_ail_max(ailp);\n\tif (lip)\n\t\tlsn = lip->li_lsn;\n\tspin_unlock(&ailp->xa_lock);\n\n\treturn lsn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT",
          "args": [
            "wait"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_ail_push_all_sync(\n\tstruct xfs_ail  *ailp)\n{\n\tstruct xfs_log_item\t*lip;\n\tDEFINE_WAIT(wait);\n\n\tspin_lock(&ailp->xa_lock);\n\twhile ((lip = xfs_ail_max(ailp)) != NULL) {\n\t\tprepare_to_wait(&ailp->xa_empty, &wait, TASK_UNINTERRUPTIBLE);\n\t\tailp->xa_target = lip->li_lsn;\n\t\twake_up_process(ailp->xa_task);\n\t\tspin_unlock(&ailp->xa_lock);\n\t\tschedule();\n\t\tspin_lock(&ailp->xa_lock);\n\t}\n\tspin_unlock(&ailp->xa_lock);\n\n\tfinish_wait(&ailp->xa_empty, &wait);\n}"
  },
  {
    "function_name": "xfs_ail_push_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
    "lines": "581-589",
    "snippet": "void\nxfs_ail_push_all(\n\tstruct xfs_ail  *ailp)\n{\n\txfs_lsn_t       threshold_lsn = xfs_ail_max_lsn(ailp);\n\n\tif (threshold_lsn)\n\t\txfs_ail_push(ailp, threshold_lsn);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_ail_push",
          "args": [
            "ailp",
            "threshold_lsn"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ail_push",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
          "lines": "555-576",
          "snippet": "void\nxfs_ail_push(\n\tstruct xfs_ail\t*ailp,\n\txfs_lsn_t\tthreshold_lsn)\n{\n\txfs_log_item_t\t*lip;\n\n\tlip = xfs_ail_min(ailp);\n\tif (!lip || XFS_FORCED_SHUTDOWN(ailp->xa_mount) ||\n\t    XFS_LSN_CMP(threshold_lsn, ailp->xa_target) <= 0)\n\t\treturn;\n\n\t/*\n\t * Ensure that the new target is noticed in push code before it clears\n\t * the XFS_AIL_PUSHING_BIT.\n\t */\n\tsmp_wmb();\n\txfs_trans_ail_copy_lsn(ailp, &ailp->xa_target, &threshold_lsn);\n\tsmp_wmb();\n\n\twake_up_process(ailp->xa_task);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_ail_push(\n\tstruct xfs_ail\t*ailp,\n\txfs_lsn_t\tthreshold_lsn)\n{\n\txfs_log_item_t\t*lip;\n\n\tlip = xfs_ail_min(ailp);\n\tif (!lip || XFS_FORCED_SHUTDOWN(ailp->xa_mount) ||\n\t    XFS_LSN_CMP(threshold_lsn, ailp->xa_target) <= 0)\n\t\treturn;\n\n\t/*\n\t * Ensure that the new target is noticed in push code before it clears\n\t * the XFS_AIL_PUSHING_BIT.\n\t */\n\tsmp_wmb();\n\txfs_trans_ail_copy_lsn(ailp, &ailp->xa_target, &threshold_lsn);\n\tsmp_wmb();\n\n\twake_up_process(ailp->xa_task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ail_max_lsn",
          "args": [
            "ailp"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ail_max_lsn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
          "lines": "119-133",
          "snippet": "static xfs_lsn_t\nxfs_ail_max_lsn(\n\tstruct xfs_ail  *ailp)\n{\n\txfs_lsn_t       lsn = 0;\n\txfs_log_item_t  *lip;\n\n\tspin_lock(&ailp->xa_lock);\n\tlip = xfs_ail_max(ailp);\n\tif (lip)\n\t\tlsn = lip->li_lsn;\n\tspin_unlock(&ailp->xa_lock);\n\n\treturn lsn;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic xfs_lsn_t\nxfs_ail_max_lsn(\n\tstruct xfs_ail  *ailp)\n{\n\txfs_lsn_t       lsn = 0;\n\txfs_log_item_t  *lip;\n\n\tspin_lock(&ailp->xa_lock);\n\tlip = xfs_ail_max(ailp);\n\tif (lip)\n\t\tlsn = lip->li_lsn;\n\tspin_unlock(&ailp->xa_lock);\n\n\treturn lsn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_ail_push_all(\n\tstruct xfs_ail  *ailp)\n{\n\txfs_lsn_t       threshold_lsn = xfs_ail_max_lsn(ailp);\n\n\tif (threshold_lsn)\n\t\txfs_ail_push(ailp, threshold_lsn);\n}"
  },
  {
    "function_name": "xfs_ail_push",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
    "lines": "555-576",
    "snippet": "void\nxfs_ail_push(\n\tstruct xfs_ail\t*ailp,\n\txfs_lsn_t\tthreshold_lsn)\n{\n\txfs_log_item_t\t*lip;\n\n\tlip = xfs_ail_min(ailp);\n\tif (!lip || XFS_FORCED_SHUTDOWN(ailp->xa_mount) ||\n\t    XFS_LSN_CMP(threshold_lsn, ailp->xa_target) <= 0)\n\t\treturn;\n\n\t/*\n\t * Ensure that the new target is noticed in push code before it clears\n\t * the XFS_AIL_PUSHING_BIT.\n\t */\n\tsmp_wmb();\n\txfs_trans_ail_copy_lsn(ailp, &ailp->xa_target, &threshold_lsn);\n\tsmp_wmb();\n\n\twake_up_process(ailp->xa_task);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "ailp->xa_task"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_ail_copy_lsn",
          "args": [
            "ailp",
            "&ailp->xa_target",
            "&threshold_lsn"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ail_copy_lsn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_priv.h",
          "lines": "151-159",
          "snippet": "static inline void\nxfs_trans_ail_copy_lsn(\n\tstruct xfs_ail\t*ailp,\n\txfs_lsn_t\t*dst,\n\txfs_lsn_t\t*src)\n{\n\tASSERT(sizeof(xfs_lsn_t) == 8);\n\t*dst = *src;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nxfs_trans_ail_copy_lsn(\n\tstruct xfs_ail\t*ailp,\n\txfs_lsn_t\t*dst,\n\txfs_lsn_t\t*src)\n{\n\tASSERT(sizeof(xfs_lsn_t) == 8);\n\t*dst = *src;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_LSN_CMP",
          "args": [
            "threshold_lsn",
            "ailp->xa_target"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "ailp->xa_mount"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_ail_min",
          "args": [
            "ailp"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ail_min_lsn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
          "lines": "100-114",
          "snippet": "xfs_lsn_t\nxfs_ail_min_lsn(\n\tstruct xfs_ail\t*ailp)\n{\n\txfs_lsn_t\tlsn = 0;\n\txfs_log_item_t\t*lip;\n\n\tspin_lock(&ailp->xa_lock);\n\tlip = xfs_ail_min(ailp);\n\tif (lip)\n\t\tlsn = lip->li_lsn;\n\tspin_unlock(&ailp->xa_lock);\n\n\treturn lsn;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_lsn_t\nxfs_ail_min_lsn(\n\tstruct xfs_ail\t*ailp)\n{\n\txfs_lsn_t\tlsn = 0;\n\txfs_log_item_t\t*lip;\n\n\tspin_lock(&ailp->xa_lock);\n\tlip = xfs_ail_min(ailp);\n\tif (lip)\n\t\tlsn = lip->li_lsn;\n\tspin_unlock(&ailp->xa_lock);\n\n\treturn lsn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_ail_push(\n\tstruct xfs_ail\t*ailp,\n\txfs_lsn_t\tthreshold_lsn)\n{\n\txfs_log_item_t\t*lip;\n\n\tlip = xfs_ail_min(ailp);\n\tif (!lip || XFS_FORCED_SHUTDOWN(ailp->xa_mount) ||\n\t    XFS_LSN_CMP(threshold_lsn, ailp->xa_target) <= 0)\n\t\treturn;\n\n\t/*\n\t * Ensure that the new target is noticed in push code before it clears\n\t * the XFS_AIL_PUSHING_BIT.\n\t */\n\tsmp_wmb();\n\txfs_trans_ail_copy_lsn(ailp, &ailp->xa_target, &threshold_lsn);\n\tsmp_wmb();\n\n\twake_up_process(ailp->xa_task);\n}"
  },
  {
    "function_name": "xfsaild",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
    "lines": "492-539",
    "snippet": "static int\nxfsaild(\n\tvoid\t\t*data)\n{\n\tstruct xfs_ail\t*ailp = data;\n\tlong\t\ttout = 0;\t/* milliseconds */\n\n\tcurrent->flags |= PF_MEMALLOC;\n\n\twhile (!kthread_should_stop()) {\n\t\tif (tout && tout <= 20)\n\t\t\t__set_current_state(TASK_KILLABLE);\n\t\telse\n\t\t\t__set_current_state(TASK_INTERRUPTIBLE);\n\n\t\tspin_lock(&ailp->xa_lock);\n\n\t\t/*\n\t\t * Idle if the AIL is empty and we are not racing with a target\n\t\t * update. We check the AIL after we set the task to a sleep\n\t\t * state to guarantee that we either catch an xa_target update\n\t\t * or that a wake_up resets the state to TASK_RUNNING.\n\t\t * Otherwise, we run the risk of sleeping indefinitely.\n\t\t *\n\t\t * The barrier matches the xa_target update in xfs_ail_push().\n\t\t */\n\t\tsmp_rmb();\n\t\tif (!xfs_ail_min(ailp) &&\n\t\t    ailp->xa_target == ailp->xa_target_prev) {\n\t\t\tspin_unlock(&ailp->xa_lock);\n\t\t\tschedule();\n\t\t\ttout = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&ailp->xa_lock);\n\n\t\tif (tout)\n\t\t\tschedule_timeout(msecs_to_jiffies(tout));\n\n\t\t__set_current_state(TASK_RUNNING);\n\n\t\ttry_to_freeze();\n\n\t\ttout = xfsaild_push(ailp);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfsaild_push",
          "args": [
            "ailp"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "xfsaild_push",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
          "lines": "328-490",
          "snippet": "static long\nxfsaild_push(\n\tstruct xfs_ail\t\t*ailp)\n{\n\txfs_mount_t\t\t*mp = ailp->xa_mount;\n\tstruct xfs_ail_cursor\tcur;\n\txfs_log_item_t\t\t*lip;\n\txfs_lsn_t\t\tlsn;\n\txfs_lsn_t\t\ttarget;\n\tlong\t\t\ttout;\n\tint\t\t\tstuck = 0;\n\tint\t\t\tflushing = 0;\n\tint\t\t\tcount = 0;\n\n\t/*\n\t * If we encountered pinned items or did not finish writing out all\n\t * buffers the last time we ran, force the log first and wait for it\n\t * before pushing again.\n\t */\n\tif (ailp->xa_log_flush && ailp->xa_last_pushed_lsn == 0 &&\n\t    (!list_empty_careful(&ailp->xa_buf_list) ||\n\t     xfs_ail_min_lsn(ailp))) {\n\t\tailp->xa_log_flush = 0;\n\n\t\tXFS_STATS_INC(xs_push_ail_flush);\n\t\txfs_log_force(mp, XFS_LOG_SYNC);\n\t}\n\n\tspin_lock(&ailp->xa_lock);\n\n\t/* barrier matches the xa_target update in xfs_ail_push() */\n\tsmp_rmb();\n\ttarget = ailp->xa_target;\n\tailp->xa_target_prev = target;\n\n\tlip = xfs_trans_ail_cursor_first(ailp, &cur, ailp->xa_last_pushed_lsn);\n\tif (!lip) {\n\t\t/*\n\t\t * If the AIL is empty or our push has reached the end we are\n\t\t * done now.\n\t\t */\n\t\txfs_trans_ail_cursor_done(&cur);\n\t\tspin_unlock(&ailp->xa_lock);\n\t\tgoto out_done;\n\t}\n\n\tXFS_STATS_INC(xs_push_ail);\n\n\tlsn = lip->li_lsn;\n\twhile ((XFS_LSN_CMP(lip->li_lsn, target) <= 0)) {\n\t\tint\tlock_result;\n\n\t\t/*\n\t\t * Note that iop_push may unlock and reacquire the AIL lock.  We\n\t\t * rely on the AIL cursor implementation to be able to deal with\n\t\t * the dropped lock.\n\t\t */\n\t\tlock_result = lip->li_ops->iop_push(lip, &ailp->xa_buf_list);\n\t\tswitch (lock_result) {\n\t\tcase XFS_ITEM_SUCCESS:\n\t\t\tXFS_STATS_INC(xs_push_ail_success);\n\t\t\ttrace_xfs_ail_push(lip);\n\n\t\t\tailp->xa_last_pushed_lsn = lsn;\n\t\t\tbreak;\n\n\t\tcase XFS_ITEM_FLUSHING:\n\t\t\t/*\n\t\t\t * The item or its backing buffer is already beeing\n\t\t\t * flushed.  The typical reason for that is that an\n\t\t\t * inode buffer is locked because we already pushed the\n\t\t\t * updates to it as part of inode clustering.\n\t\t\t *\n\t\t\t * We do not want to to stop flushing just because lots\n\t\t\t * of items are already beeing flushed, but we need to\n\t\t\t * re-try the flushing relatively soon if most of the\n\t\t\t * AIL is beeing flushed.\n\t\t\t */\n\t\t\tXFS_STATS_INC(xs_push_ail_flushing);\n\t\t\ttrace_xfs_ail_flushing(lip);\n\n\t\t\tflushing++;\n\t\t\tailp->xa_last_pushed_lsn = lsn;\n\t\t\tbreak;\n\n\t\tcase XFS_ITEM_PINNED:\n\t\t\tXFS_STATS_INC(xs_push_ail_pinned);\n\t\t\ttrace_xfs_ail_pinned(lip);\n\n\t\t\tstuck++;\n\t\t\tailp->xa_log_flush++;\n\t\t\tbreak;\n\t\tcase XFS_ITEM_LOCKED:\n\t\t\tXFS_STATS_INC(xs_push_ail_locked);\n\t\t\ttrace_xfs_ail_locked(lip);\n\n\t\t\tstuck++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\n\t\tcount++;\n\n\t\t/*\n\t\t * Are there too many items we can't do anything with?\n\t\t *\n\t\t * If we we are skipping too many items because we can't flush\n\t\t * them or they are already being flushed, we back off and\n\t\t * given them time to complete whatever operation is being\n\t\t * done. i.e. remove pressure from the AIL while we can't make\n\t\t * progress so traversals don't slow down further inserts and\n\t\t * removals to/from the AIL.\n\t\t *\n\t\t * The value of 100 is an arbitrary magic number based on\n\t\t * observation.\n\t\t */\n\t\tif (stuck > 100)\n\t\t\tbreak;\n\n\t\tlip = xfs_trans_ail_cursor_next(ailp, &cur);\n\t\tif (lip == NULL)\n\t\t\tbreak;\n\t\tlsn = lip->li_lsn;\n\t}\n\txfs_trans_ail_cursor_done(&cur);\n\tspin_unlock(&ailp->xa_lock);\n\n\tif (xfs_buf_delwri_submit_nowait(&ailp->xa_buf_list))\n\t\tailp->xa_log_flush++;\n\n\tif (!count || XFS_LSN_CMP(lsn, target) >= 0) {\nout_done:\n\t\t/*\n\t\t * We reached the target or the AIL is empty, so wait a bit\n\t\t * longer for I/O to complete and remove pushed items from the\n\t\t * AIL before we start the next scan from the start of the AIL.\n\t\t */\n\t\ttout = 50;\n\t\tailp->xa_last_pushed_lsn = 0;\n\t} else if (((stuck + flushing) * 100) / count > 90) {\n\t\t/*\n\t\t * Either there is a lot of contention on the AIL or we are\n\t\t * stuck due to operations in progress. \"Stuck\" in this case\n\t\t * is defined as >90% of the items we tried to push were stuck.\n\t\t *\n\t\t * Backoff a bit more to allow some I/O to complete before\n\t\t * restarting from the start of the AIL. This prevents us from\n\t\t * spinning on the same items, and if they are pinned will all\n\t\t * the restart to issue a log force to unpin the stuck items.\n\t\t */\n\t\ttout = 20;\n\t\tailp->xa_last_pushed_lsn = 0;\n\t} else {\n\t\t/*\n\t\t * Assume we have more work to do in a short while.\n\t\t */\n\t\ttout = 10;\n\t}\n\n\treturn tout;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic long\nxfsaild_push(\n\tstruct xfs_ail\t\t*ailp)\n{\n\txfs_mount_t\t\t*mp = ailp->xa_mount;\n\tstruct xfs_ail_cursor\tcur;\n\txfs_log_item_t\t\t*lip;\n\txfs_lsn_t\t\tlsn;\n\txfs_lsn_t\t\ttarget;\n\tlong\t\t\ttout;\n\tint\t\t\tstuck = 0;\n\tint\t\t\tflushing = 0;\n\tint\t\t\tcount = 0;\n\n\t/*\n\t * If we encountered pinned items or did not finish writing out all\n\t * buffers the last time we ran, force the log first and wait for it\n\t * before pushing again.\n\t */\n\tif (ailp->xa_log_flush && ailp->xa_last_pushed_lsn == 0 &&\n\t    (!list_empty_careful(&ailp->xa_buf_list) ||\n\t     xfs_ail_min_lsn(ailp))) {\n\t\tailp->xa_log_flush = 0;\n\n\t\tXFS_STATS_INC(xs_push_ail_flush);\n\t\txfs_log_force(mp, XFS_LOG_SYNC);\n\t}\n\n\tspin_lock(&ailp->xa_lock);\n\n\t/* barrier matches the xa_target update in xfs_ail_push() */\n\tsmp_rmb();\n\ttarget = ailp->xa_target;\n\tailp->xa_target_prev = target;\n\n\tlip = xfs_trans_ail_cursor_first(ailp, &cur, ailp->xa_last_pushed_lsn);\n\tif (!lip) {\n\t\t/*\n\t\t * If the AIL is empty or our push has reached the end we are\n\t\t * done now.\n\t\t */\n\t\txfs_trans_ail_cursor_done(&cur);\n\t\tspin_unlock(&ailp->xa_lock);\n\t\tgoto out_done;\n\t}\n\n\tXFS_STATS_INC(xs_push_ail);\n\n\tlsn = lip->li_lsn;\n\twhile ((XFS_LSN_CMP(lip->li_lsn, target) <= 0)) {\n\t\tint\tlock_result;\n\n\t\t/*\n\t\t * Note that iop_push may unlock and reacquire the AIL lock.  We\n\t\t * rely on the AIL cursor implementation to be able to deal with\n\t\t * the dropped lock.\n\t\t */\n\t\tlock_result = lip->li_ops->iop_push(lip, &ailp->xa_buf_list);\n\t\tswitch (lock_result) {\n\t\tcase XFS_ITEM_SUCCESS:\n\t\t\tXFS_STATS_INC(xs_push_ail_success);\n\t\t\ttrace_xfs_ail_push(lip);\n\n\t\t\tailp->xa_last_pushed_lsn = lsn;\n\t\t\tbreak;\n\n\t\tcase XFS_ITEM_FLUSHING:\n\t\t\t/*\n\t\t\t * The item or its backing buffer is already beeing\n\t\t\t * flushed.  The typical reason for that is that an\n\t\t\t * inode buffer is locked because we already pushed the\n\t\t\t * updates to it as part of inode clustering.\n\t\t\t *\n\t\t\t * We do not want to to stop flushing just because lots\n\t\t\t * of items are already beeing flushed, but we need to\n\t\t\t * re-try the flushing relatively soon if most of the\n\t\t\t * AIL is beeing flushed.\n\t\t\t */\n\t\t\tXFS_STATS_INC(xs_push_ail_flushing);\n\t\t\ttrace_xfs_ail_flushing(lip);\n\n\t\t\tflushing++;\n\t\t\tailp->xa_last_pushed_lsn = lsn;\n\t\t\tbreak;\n\n\t\tcase XFS_ITEM_PINNED:\n\t\t\tXFS_STATS_INC(xs_push_ail_pinned);\n\t\t\ttrace_xfs_ail_pinned(lip);\n\n\t\t\tstuck++;\n\t\t\tailp->xa_log_flush++;\n\t\t\tbreak;\n\t\tcase XFS_ITEM_LOCKED:\n\t\t\tXFS_STATS_INC(xs_push_ail_locked);\n\t\t\ttrace_xfs_ail_locked(lip);\n\n\t\t\tstuck++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\n\t\tcount++;\n\n\t\t/*\n\t\t * Are there too many items we can't do anything with?\n\t\t *\n\t\t * If we we are skipping too many items because we can't flush\n\t\t * them or they are already being flushed, we back off and\n\t\t * given them time to complete whatever operation is being\n\t\t * done. i.e. remove pressure from the AIL while we can't make\n\t\t * progress so traversals don't slow down further inserts and\n\t\t * removals to/from the AIL.\n\t\t *\n\t\t * The value of 100 is an arbitrary magic number based on\n\t\t * observation.\n\t\t */\n\t\tif (stuck > 100)\n\t\t\tbreak;\n\n\t\tlip = xfs_trans_ail_cursor_next(ailp, &cur);\n\t\tif (lip == NULL)\n\t\t\tbreak;\n\t\tlsn = lip->li_lsn;\n\t}\n\txfs_trans_ail_cursor_done(&cur);\n\tspin_unlock(&ailp->xa_lock);\n\n\tif (xfs_buf_delwri_submit_nowait(&ailp->xa_buf_list))\n\t\tailp->xa_log_flush++;\n\n\tif (!count || XFS_LSN_CMP(lsn, target) >= 0) {\nout_done:\n\t\t/*\n\t\t * We reached the target or the AIL is empty, so wait a bit\n\t\t * longer for I/O to complete and remove pushed items from the\n\t\t * AIL before we start the next scan from the start of the AIL.\n\t\t */\n\t\ttout = 50;\n\t\tailp->xa_last_pushed_lsn = 0;\n\t} else if (((stuck + flushing) * 100) / count > 90) {\n\t\t/*\n\t\t * Either there is a lot of contention on the AIL or we are\n\t\t * stuck due to operations in progress. \"Stuck\" in this case\n\t\t * is defined as >90% of the items we tried to push were stuck.\n\t\t *\n\t\t * Backoff a bit more to allow some I/O to complete before\n\t\t * restarting from the start of the AIL. This prevents us from\n\t\t * spinning on the same items, and if they are pinned will all\n\t\t * the restart to issue a log force to unpin the stuck items.\n\t\t */\n\t\ttout = 20;\n\t\tailp->xa_last_pushed_lsn = 0;\n\t} else {\n\t\t/*\n\t\t * Assume we have more work to do in a short while.\n\t\t */\n\t\ttout = 10;\n\t}\n\n\treturn tout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_freeze",
          "args": [],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout",
          "args": [
            "msecs_to_jiffies(tout)"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "tout"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ailp->xa_lock"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_ail_min",
          "args": [
            "ailp"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ail_min_lsn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
          "lines": "100-114",
          "snippet": "xfs_lsn_t\nxfs_ail_min_lsn(\n\tstruct xfs_ail\t*ailp)\n{\n\txfs_lsn_t\tlsn = 0;\n\txfs_log_item_t\t*lip;\n\n\tspin_lock(&ailp->xa_lock);\n\tlip = xfs_ail_min(ailp);\n\tif (lip)\n\t\tlsn = lip->li_lsn;\n\tspin_unlock(&ailp->xa_lock);\n\n\treturn lsn;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_lsn_t\nxfs_ail_min_lsn(\n\tstruct xfs_ail\t*ailp)\n{\n\txfs_lsn_t\tlsn = 0;\n\txfs_log_item_t\t*lip;\n\n\tspin_lock(&ailp->xa_lock);\n\tlip = xfs_ail_min(ailp);\n\tif (lip)\n\t\tlsn = lip->li_lsn;\n\tspin_unlock(&ailp->xa_lock);\n\n\treturn lsn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ailp->xa_lock"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_KILLABLE"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int\nxfsaild(\n\tvoid\t\t*data)\n{\n\tstruct xfs_ail\t*ailp = data;\n\tlong\t\ttout = 0;\t/* milliseconds */\n\n\tcurrent->flags |= PF_MEMALLOC;\n\n\twhile (!kthread_should_stop()) {\n\t\tif (tout && tout <= 20)\n\t\t\t__set_current_state(TASK_KILLABLE);\n\t\telse\n\t\t\t__set_current_state(TASK_INTERRUPTIBLE);\n\n\t\tspin_lock(&ailp->xa_lock);\n\n\t\t/*\n\t\t * Idle if the AIL is empty and we are not racing with a target\n\t\t * update. We check the AIL after we set the task to a sleep\n\t\t * state to guarantee that we either catch an xa_target update\n\t\t * or that a wake_up resets the state to TASK_RUNNING.\n\t\t * Otherwise, we run the risk of sleeping indefinitely.\n\t\t *\n\t\t * The barrier matches the xa_target update in xfs_ail_push().\n\t\t */\n\t\tsmp_rmb();\n\t\tif (!xfs_ail_min(ailp) &&\n\t\t    ailp->xa_target == ailp->xa_target_prev) {\n\t\t\tspin_unlock(&ailp->xa_lock);\n\t\t\tschedule();\n\t\t\ttout = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&ailp->xa_lock);\n\n\t\tif (tout)\n\t\t\tschedule_timeout(msecs_to_jiffies(tout));\n\n\t\t__set_current_state(TASK_RUNNING);\n\n\t\ttry_to_freeze();\n\n\t\ttout = xfsaild_push(ailp);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xfsaild_push",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
    "lines": "328-490",
    "snippet": "static long\nxfsaild_push(\n\tstruct xfs_ail\t\t*ailp)\n{\n\txfs_mount_t\t\t*mp = ailp->xa_mount;\n\tstruct xfs_ail_cursor\tcur;\n\txfs_log_item_t\t\t*lip;\n\txfs_lsn_t\t\tlsn;\n\txfs_lsn_t\t\ttarget;\n\tlong\t\t\ttout;\n\tint\t\t\tstuck = 0;\n\tint\t\t\tflushing = 0;\n\tint\t\t\tcount = 0;\n\n\t/*\n\t * If we encountered pinned items or did not finish writing out all\n\t * buffers the last time we ran, force the log first and wait for it\n\t * before pushing again.\n\t */\n\tif (ailp->xa_log_flush && ailp->xa_last_pushed_lsn == 0 &&\n\t    (!list_empty_careful(&ailp->xa_buf_list) ||\n\t     xfs_ail_min_lsn(ailp))) {\n\t\tailp->xa_log_flush = 0;\n\n\t\tXFS_STATS_INC(xs_push_ail_flush);\n\t\txfs_log_force(mp, XFS_LOG_SYNC);\n\t}\n\n\tspin_lock(&ailp->xa_lock);\n\n\t/* barrier matches the xa_target update in xfs_ail_push() */\n\tsmp_rmb();\n\ttarget = ailp->xa_target;\n\tailp->xa_target_prev = target;\n\n\tlip = xfs_trans_ail_cursor_first(ailp, &cur, ailp->xa_last_pushed_lsn);\n\tif (!lip) {\n\t\t/*\n\t\t * If the AIL is empty or our push has reached the end we are\n\t\t * done now.\n\t\t */\n\t\txfs_trans_ail_cursor_done(&cur);\n\t\tspin_unlock(&ailp->xa_lock);\n\t\tgoto out_done;\n\t}\n\n\tXFS_STATS_INC(xs_push_ail);\n\n\tlsn = lip->li_lsn;\n\twhile ((XFS_LSN_CMP(lip->li_lsn, target) <= 0)) {\n\t\tint\tlock_result;\n\n\t\t/*\n\t\t * Note that iop_push may unlock and reacquire the AIL lock.  We\n\t\t * rely on the AIL cursor implementation to be able to deal with\n\t\t * the dropped lock.\n\t\t */\n\t\tlock_result = lip->li_ops->iop_push(lip, &ailp->xa_buf_list);\n\t\tswitch (lock_result) {\n\t\tcase XFS_ITEM_SUCCESS:\n\t\t\tXFS_STATS_INC(xs_push_ail_success);\n\t\t\ttrace_xfs_ail_push(lip);\n\n\t\t\tailp->xa_last_pushed_lsn = lsn;\n\t\t\tbreak;\n\n\t\tcase XFS_ITEM_FLUSHING:\n\t\t\t/*\n\t\t\t * The item or its backing buffer is already beeing\n\t\t\t * flushed.  The typical reason for that is that an\n\t\t\t * inode buffer is locked because we already pushed the\n\t\t\t * updates to it as part of inode clustering.\n\t\t\t *\n\t\t\t * We do not want to to stop flushing just because lots\n\t\t\t * of items are already beeing flushed, but we need to\n\t\t\t * re-try the flushing relatively soon if most of the\n\t\t\t * AIL is beeing flushed.\n\t\t\t */\n\t\t\tXFS_STATS_INC(xs_push_ail_flushing);\n\t\t\ttrace_xfs_ail_flushing(lip);\n\n\t\t\tflushing++;\n\t\t\tailp->xa_last_pushed_lsn = lsn;\n\t\t\tbreak;\n\n\t\tcase XFS_ITEM_PINNED:\n\t\t\tXFS_STATS_INC(xs_push_ail_pinned);\n\t\t\ttrace_xfs_ail_pinned(lip);\n\n\t\t\tstuck++;\n\t\t\tailp->xa_log_flush++;\n\t\t\tbreak;\n\t\tcase XFS_ITEM_LOCKED:\n\t\t\tXFS_STATS_INC(xs_push_ail_locked);\n\t\t\ttrace_xfs_ail_locked(lip);\n\n\t\t\tstuck++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\n\t\tcount++;\n\n\t\t/*\n\t\t * Are there too many items we can't do anything with?\n\t\t *\n\t\t * If we we are skipping too many items because we can't flush\n\t\t * them or they are already being flushed, we back off and\n\t\t * given them time to complete whatever operation is being\n\t\t * done. i.e. remove pressure from the AIL while we can't make\n\t\t * progress so traversals don't slow down further inserts and\n\t\t * removals to/from the AIL.\n\t\t *\n\t\t * The value of 100 is an arbitrary magic number based on\n\t\t * observation.\n\t\t */\n\t\tif (stuck > 100)\n\t\t\tbreak;\n\n\t\tlip = xfs_trans_ail_cursor_next(ailp, &cur);\n\t\tif (lip == NULL)\n\t\t\tbreak;\n\t\tlsn = lip->li_lsn;\n\t}\n\txfs_trans_ail_cursor_done(&cur);\n\tspin_unlock(&ailp->xa_lock);\n\n\tif (xfs_buf_delwri_submit_nowait(&ailp->xa_buf_list))\n\t\tailp->xa_log_flush++;\n\n\tif (!count || XFS_LSN_CMP(lsn, target) >= 0) {\nout_done:\n\t\t/*\n\t\t * We reached the target or the AIL is empty, so wait a bit\n\t\t * longer for I/O to complete and remove pushed items from the\n\t\t * AIL before we start the next scan from the start of the AIL.\n\t\t */\n\t\ttout = 50;\n\t\tailp->xa_last_pushed_lsn = 0;\n\t} else if (((stuck + flushing) * 100) / count > 90) {\n\t\t/*\n\t\t * Either there is a lot of contention on the AIL or we are\n\t\t * stuck due to operations in progress. \"Stuck\" in this case\n\t\t * is defined as >90% of the items we tried to push were stuck.\n\t\t *\n\t\t * Backoff a bit more to allow some I/O to complete before\n\t\t * restarting from the start of the AIL. This prevents us from\n\t\t * spinning on the same items, and if they are pinned will all\n\t\t * the restart to issue a log force to unpin the stuck items.\n\t\t */\n\t\ttout = 20;\n\t\tailp->xa_last_pushed_lsn = 0;\n\t} else {\n\t\t/*\n\t\t * Assume we have more work to do in a short while.\n\t\t */\n\t\ttout = 10;\n\t}\n\n\treturn tout;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_LSN_CMP",
          "args": [
            "lsn",
            "target"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_delwri_submit_nowait",
          "args": [
            "&ailp->xa_buf_list"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_delwri_submit_nowait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1840-1846",
          "snippet": "int\nxfs_buf_delwri_submit_nowait(\n\tstruct list_head\t*buffer_list)\n{\n\tLIST_HEAD\t\t(io_list);\n\treturn __xfs_buf_delwri_submit(buffer_list, &io_list, false);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nint\nxfs_buf_delwri_submit_nowait(\n\tstruct list_head\t*buffer_list)\n{\n\tLIST_HEAD\t\t(io_list);\n\treturn __xfs_buf_delwri_submit(buffer_list, &io_list, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ailp->xa_lock"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ail_cursor_done",
          "args": [
            "&cur"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ail_cursor_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
          "lines": "173-179",
          "snippet": "void\nxfs_trans_ail_cursor_done(\n\tstruct xfs_ail_cursor\t*cur)\n{\n\tcur->item = NULL;\n\tlist_del_init(&cur->list);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ail_cursor_done(\n\tstruct xfs_ail_cursor\t*cur)\n{\n\tcur->item = NULL;\n\tlist_del_init(&cur->list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ail_cursor_next",
          "args": [
            "ailp",
            "&cur"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ail_cursor_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
          "lines": "155-167",
          "snippet": "struct xfs_log_item *\nxfs_trans_ail_cursor_next(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_ail_cursor\t*cur)\n{\n\tstruct xfs_log_item\t*lip = cur->item;\n\n\tif ((__psint_t)lip & 1)\n\t\tlip = xfs_ail_min(ailp);\n\tif (lip)\n\t\tcur->item = xfs_ail_next(ailp, lip);\n\treturn lip;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_log_item *\nxfs_trans_ail_cursor_next(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_ail_cursor\t*cur)\n{\n\tstruct xfs_log_item\t*lip = cur->item;\n\n\tif ((__psint_t)lip & 1)\n\t\tlip = xfs_ail_min(ailp);\n\tif (lip)\n\t\tcur->item = xfs_ail_next(ailp, lip);\n\treturn lip;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_ail_locked",
          "args": [
            "lip"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_push_ail_locked"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_ail_pinned",
          "args": [
            "lip"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_push_ail_pinned"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_ail_flushing",
          "args": [
            "lip"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_push_ail_flushing"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_ail_push",
          "args": [
            "lip"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_push_ail_success"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lip->li_ops->iop_push",
          "args": [
            "lip",
            "&ailp->xa_buf_list"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_LSN_CMP",
          "args": [
            "lip->li_lsn",
            "target"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_push_ail"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_ail_cursor_first",
          "args": [
            "ailp",
            "&cur",
            "ailp->xa_last_pushed_lsn"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ail_cursor_first",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
          "lines": "209-234",
          "snippet": "xfs_log_item_t *\nxfs_trans_ail_cursor_first(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_ail_cursor\t*cur,\n\txfs_lsn_t\t\tlsn)\n{\n\txfs_log_item_t\t\t*lip;\n\n\txfs_trans_ail_cursor_init(ailp, cur);\n\n\tif (lsn == 0) {\n\t\tlip = xfs_ail_min(ailp);\n\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(lip, &ailp->xa_ail, li_ail) {\n\t\tif (XFS_LSN_CMP(lip->li_lsn, lsn) >= 0)\n\t\t\tgoto out;\n\t}\n\treturn NULL;\n\nout:\n\tif (lip)\n\t\tcur->item = xfs_ail_next(ailp, lip);\n\treturn lip;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_log_item_t *\nxfs_trans_ail_cursor_first(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_ail_cursor\t*cur,\n\txfs_lsn_t\t\tlsn)\n{\n\txfs_log_item_t\t\t*lip;\n\n\txfs_trans_ail_cursor_init(ailp, cur);\n\n\tif (lsn == 0) {\n\t\tlip = xfs_ail_min(ailp);\n\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(lip, &ailp->xa_ail, li_ail) {\n\t\tif (XFS_LSN_CMP(lip->li_lsn, lsn) >= 0)\n\t\t\tgoto out;\n\t}\n\treturn NULL;\n\nout:\n\tif (lip)\n\t\tcur->item = xfs_ail_next(ailp, lip);\n\treturn lip;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ailp->xa_lock"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_log_force",
          "args": [
            "mp",
            "XFS_LOG_SYNC"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_force_umount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3896-3988",
          "snippet": "int\nxfs_log_force_umount(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tlogerror)\n{\n\tstruct xlog\t*log;\n\tint\t\tretval;\n\n\tlog = mp->m_log;\n\n\t/*\n\t * If this happens during log recovery, don't worry about\n\t * locking; the log isn't open for business yet.\n\t */\n\tif (!log ||\n\t    log->l_flags & XLOG_ACTIVE_RECOVERY) {\n\t\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\t\tif (mp->m_sb_bp)\n\t\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Somebody could've already done the hard work for us.\n\t * No need to get locks for this.\n\t */\n\tif (logerror && log->l_iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tASSERT(XLOG_FORCED_SHUTDOWN(log));\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Flush all the completed transactions to disk before marking the log\n\t * being shut down. We need to do it in this order to ensure that\n\t * completed operations are safely on disk before we shut down, and that\n\t * we don't have to issue any buffer IO after the shutdown flags are set\n\t * to guarantee this.\n\t */\n\tif (!logerror)\n\t\t_xfs_log_force(mp, XFS_LOG_SYNC, NULL);\n\n\t/*\n\t * mark the filesystem and the as in a shutdown state and wake\n\t * everybody up to tell them the bad news.\n\t */\n\tspin_lock(&log->l_icloglock);\n\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\tif (mp->m_sb_bp)\n\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\n\t/*\n\t * Mark the log and the iclogs with IO error flags to prevent any\n\t * further log IO from being issued or completed.\n\t */\n\tlog->l_flags |= XLOG_IO_ERROR;\n\tretval = xlog_state_ioerror(log);\n\tspin_unlock(&log->l_icloglock);\n\n\t/*\n\t * We don't want anybody waiting for log reservations after this. That\n\t * means we have to wake up everybody queued up on reserveq as well as\n\t * writeq.  In addition, we make sure in xlog_{re}grant_log_space that\n\t * we don't enqueue anything once the SHUTDOWN flag is set, and this\n\t * action is protected by the grant locks.\n\t */\n\txlog_grant_head_wake_all(&log->l_reserve_head);\n\txlog_grant_head_wake_all(&log->l_write_head);\n\n\t/*\n\t * Wake up everybody waiting on xfs_log_force. Wake the CIL push first\n\t * as if the log writes were completed. The abort handling in the log\n\t * item committed callback functions will do this again under lock to\n\t * avoid races.\n\t */\n\twake_up_all(&log->l_cilp->xc_commit_wait);\n\txlog_state_do_callback(log, XFS_LI_ABORTED, NULL);\n\n#ifdef XFSERRORDEBUG\n\t{\n\t\txlog_in_core_t\t*iclog;\n\n\t\tspin_lock(&log->l_icloglock);\n\t\ticlog = log->l_iclog;\n\t\tdo {\n\t\t\tASSERT(iclog->ic_callback == 0);\n\t\t\ticlog = iclog->ic_next;\n\t\t} while (iclog != log->l_iclog);\n\t\tspin_unlock(&log->l_icloglock);\n\t}\n#endif\n\t/* return non-zero if log IOERROR transition had already happened */\n\treturn retval;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nint\nxfs_log_force_umount(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tlogerror)\n{\n\tstruct xlog\t*log;\n\tint\t\tretval;\n\n\tlog = mp->m_log;\n\n\t/*\n\t * If this happens during log recovery, don't worry about\n\t * locking; the log isn't open for business yet.\n\t */\n\tif (!log ||\n\t    log->l_flags & XLOG_ACTIVE_RECOVERY) {\n\t\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\t\tif (mp->m_sb_bp)\n\t\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Somebody could've already done the hard work for us.\n\t * No need to get locks for this.\n\t */\n\tif (logerror && log->l_iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tASSERT(XLOG_FORCED_SHUTDOWN(log));\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Flush all the completed transactions to disk before marking the log\n\t * being shut down. We need to do it in this order to ensure that\n\t * completed operations are safely on disk before we shut down, and that\n\t * we don't have to issue any buffer IO after the shutdown flags are set\n\t * to guarantee this.\n\t */\n\tif (!logerror)\n\t\t_xfs_log_force(mp, XFS_LOG_SYNC, NULL);\n\n\t/*\n\t * mark the filesystem and the as in a shutdown state and wake\n\t * everybody up to tell them the bad news.\n\t */\n\tspin_lock(&log->l_icloglock);\n\tmp->m_flags |= XFS_MOUNT_FS_SHUTDOWN;\n\tif (mp->m_sb_bp)\n\t\tXFS_BUF_DONE(mp->m_sb_bp);\n\n\t/*\n\t * Mark the log and the iclogs with IO error flags to prevent any\n\t * further log IO from being issued or completed.\n\t */\n\tlog->l_flags |= XLOG_IO_ERROR;\n\tretval = xlog_state_ioerror(log);\n\tspin_unlock(&log->l_icloglock);\n\n\t/*\n\t * We don't want anybody waiting for log reservations after this. That\n\t * means we have to wake up everybody queued up on reserveq as well as\n\t * writeq.  In addition, we make sure in xlog_{re}grant_log_space that\n\t * we don't enqueue anything once the SHUTDOWN flag is set, and this\n\t * action is protected by the grant locks.\n\t */\n\txlog_grant_head_wake_all(&log->l_reserve_head);\n\txlog_grant_head_wake_all(&log->l_write_head);\n\n\t/*\n\t * Wake up everybody waiting on xfs_log_force. Wake the CIL push first\n\t * as if the log writes were completed. The abort handling in the log\n\t * item committed callback functions will do this again under lock to\n\t * avoid races.\n\t */\n\twake_up_all(&log->l_cilp->xc_commit_wait);\n\txlog_state_do_callback(log, XFS_LI_ABORTED, NULL);\n\n#ifdef XFSERRORDEBUG\n\t{\n\t\txlog_in_core_t\t*iclog;\n\n\t\tspin_lock(&log->l_icloglock);\n\t\ticlog = log->l_iclog;\n\t\tdo {\n\t\t\tASSERT(iclog->ic_callback == 0);\n\t\t\ticlog = iclog->ic_next;\n\t\t} while (iclog != log->l_iclog);\n\t\tspin_unlock(&log->l_icloglock);\n\t}\n#endif\n\t/* return non-zero if log IOERROR transition had already happened */\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_push_ail_flush"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_ail_min_lsn",
          "args": [
            "ailp"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ail_min_lsn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
          "lines": "100-114",
          "snippet": "xfs_lsn_t\nxfs_ail_min_lsn(\n\tstruct xfs_ail\t*ailp)\n{\n\txfs_lsn_t\tlsn = 0;\n\txfs_log_item_t\t*lip;\n\n\tspin_lock(&ailp->xa_lock);\n\tlip = xfs_ail_min(ailp);\n\tif (lip)\n\t\tlsn = lip->li_lsn;\n\tspin_unlock(&ailp->xa_lock);\n\n\treturn lsn;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_lsn_t\nxfs_ail_min_lsn(\n\tstruct xfs_ail\t*ailp)\n{\n\txfs_lsn_t\tlsn = 0;\n\txfs_log_item_t\t*lip;\n\n\tspin_lock(&ailp->xa_lock);\n\tlip = xfs_ail_min(ailp);\n\tif (lip)\n\t\tlsn = lip->li_lsn;\n\tspin_unlock(&ailp->xa_lock);\n\n\treturn lsn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty_careful",
          "args": [
            "&ailp->xa_buf_list"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic long\nxfsaild_push(\n\tstruct xfs_ail\t\t*ailp)\n{\n\txfs_mount_t\t\t*mp = ailp->xa_mount;\n\tstruct xfs_ail_cursor\tcur;\n\txfs_log_item_t\t\t*lip;\n\txfs_lsn_t\t\tlsn;\n\txfs_lsn_t\t\ttarget;\n\tlong\t\t\ttout;\n\tint\t\t\tstuck = 0;\n\tint\t\t\tflushing = 0;\n\tint\t\t\tcount = 0;\n\n\t/*\n\t * If we encountered pinned items or did not finish writing out all\n\t * buffers the last time we ran, force the log first and wait for it\n\t * before pushing again.\n\t */\n\tif (ailp->xa_log_flush && ailp->xa_last_pushed_lsn == 0 &&\n\t    (!list_empty_careful(&ailp->xa_buf_list) ||\n\t     xfs_ail_min_lsn(ailp))) {\n\t\tailp->xa_log_flush = 0;\n\n\t\tXFS_STATS_INC(xs_push_ail_flush);\n\t\txfs_log_force(mp, XFS_LOG_SYNC);\n\t}\n\n\tspin_lock(&ailp->xa_lock);\n\n\t/* barrier matches the xa_target update in xfs_ail_push() */\n\tsmp_rmb();\n\ttarget = ailp->xa_target;\n\tailp->xa_target_prev = target;\n\n\tlip = xfs_trans_ail_cursor_first(ailp, &cur, ailp->xa_last_pushed_lsn);\n\tif (!lip) {\n\t\t/*\n\t\t * If the AIL is empty or our push has reached the end we are\n\t\t * done now.\n\t\t */\n\t\txfs_trans_ail_cursor_done(&cur);\n\t\tspin_unlock(&ailp->xa_lock);\n\t\tgoto out_done;\n\t}\n\n\tXFS_STATS_INC(xs_push_ail);\n\n\tlsn = lip->li_lsn;\n\twhile ((XFS_LSN_CMP(lip->li_lsn, target) <= 0)) {\n\t\tint\tlock_result;\n\n\t\t/*\n\t\t * Note that iop_push may unlock and reacquire the AIL lock.  We\n\t\t * rely on the AIL cursor implementation to be able to deal with\n\t\t * the dropped lock.\n\t\t */\n\t\tlock_result = lip->li_ops->iop_push(lip, &ailp->xa_buf_list);\n\t\tswitch (lock_result) {\n\t\tcase XFS_ITEM_SUCCESS:\n\t\t\tXFS_STATS_INC(xs_push_ail_success);\n\t\t\ttrace_xfs_ail_push(lip);\n\n\t\t\tailp->xa_last_pushed_lsn = lsn;\n\t\t\tbreak;\n\n\t\tcase XFS_ITEM_FLUSHING:\n\t\t\t/*\n\t\t\t * The item or its backing buffer is already beeing\n\t\t\t * flushed.  The typical reason for that is that an\n\t\t\t * inode buffer is locked because we already pushed the\n\t\t\t * updates to it as part of inode clustering.\n\t\t\t *\n\t\t\t * We do not want to to stop flushing just because lots\n\t\t\t * of items are already beeing flushed, but we need to\n\t\t\t * re-try the flushing relatively soon if most of the\n\t\t\t * AIL is beeing flushed.\n\t\t\t */\n\t\t\tXFS_STATS_INC(xs_push_ail_flushing);\n\t\t\ttrace_xfs_ail_flushing(lip);\n\n\t\t\tflushing++;\n\t\t\tailp->xa_last_pushed_lsn = lsn;\n\t\t\tbreak;\n\n\t\tcase XFS_ITEM_PINNED:\n\t\t\tXFS_STATS_INC(xs_push_ail_pinned);\n\t\t\ttrace_xfs_ail_pinned(lip);\n\n\t\t\tstuck++;\n\t\t\tailp->xa_log_flush++;\n\t\t\tbreak;\n\t\tcase XFS_ITEM_LOCKED:\n\t\t\tXFS_STATS_INC(xs_push_ail_locked);\n\t\t\ttrace_xfs_ail_locked(lip);\n\n\t\t\tstuck++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tASSERT(0);\n\t\t\tbreak;\n\t\t}\n\n\t\tcount++;\n\n\t\t/*\n\t\t * Are there too many items we can't do anything with?\n\t\t *\n\t\t * If we we are skipping too many items because we can't flush\n\t\t * them or they are already being flushed, we back off and\n\t\t * given them time to complete whatever operation is being\n\t\t * done. i.e. remove pressure from the AIL while we can't make\n\t\t * progress so traversals don't slow down further inserts and\n\t\t * removals to/from the AIL.\n\t\t *\n\t\t * The value of 100 is an arbitrary magic number based on\n\t\t * observation.\n\t\t */\n\t\tif (stuck > 100)\n\t\t\tbreak;\n\n\t\tlip = xfs_trans_ail_cursor_next(ailp, &cur);\n\t\tif (lip == NULL)\n\t\t\tbreak;\n\t\tlsn = lip->li_lsn;\n\t}\n\txfs_trans_ail_cursor_done(&cur);\n\tspin_unlock(&ailp->xa_lock);\n\n\tif (xfs_buf_delwri_submit_nowait(&ailp->xa_buf_list))\n\t\tailp->xa_log_flush++;\n\n\tif (!count || XFS_LSN_CMP(lsn, target) >= 0) {\nout_done:\n\t\t/*\n\t\t * We reached the target or the AIL is empty, so wait a bit\n\t\t * longer for I/O to complete and remove pushed items from the\n\t\t * AIL before we start the next scan from the start of the AIL.\n\t\t */\n\t\ttout = 50;\n\t\tailp->xa_last_pushed_lsn = 0;\n\t} else if (((stuck + flushing) * 100) / count > 90) {\n\t\t/*\n\t\t * Either there is a lot of contention on the AIL or we are\n\t\t * stuck due to operations in progress. \"Stuck\" in this case\n\t\t * is defined as >90% of the items we tried to push were stuck.\n\t\t *\n\t\t * Backoff a bit more to allow some I/O to complete before\n\t\t * restarting from the start of the AIL. This prevents us from\n\t\t * spinning on the same items, and if they are pinned will all\n\t\t * the restart to issue a log force to unpin the stuck items.\n\t\t */\n\t\ttout = 20;\n\t\tailp->xa_last_pushed_lsn = 0;\n\t} else {\n\t\t/*\n\t\t * Assume we have more work to do in a short while.\n\t\t */\n\t\ttout = 10;\n\t}\n\n\treturn tout;\n}"
  },
  {
    "function_name": "xfs_ail_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
    "lines": "318-326",
    "snippet": "static void\nxfs_ail_delete(\n\tstruct xfs_ail  *ailp,\n\txfs_log_item_t  *lip)\n{\n\txfs_ail_check(ailp, lip);\n\tlist_del(&lip->li_ail);\n\txfs_trans_ail_cursor_clear(ailp, lip);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_ail_cursor_clear",
          "args": [
            "ailp",
            "lip"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ail_cursor_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
          "lines": "189-201",
          "snippet": "STATIC void\nxfs_trans_ail_cursor_clear(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_log_item\t*lip)\n{\n\tstruct xfs_ail_cursor\t*cur;\n\n\tlist_for_each_entry(cur, &ailp->xa_cursors, list) {\n\t\tif (cur->item == lip)\n\t\t\tcur->item = (struct xfs_log_item *)\n\t\t\t\t\t((__psint_t)cur->item | 1);\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_trans_ail_cursor_clear(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_log_item\t*lip)\n{\n\tstruct xfs_ail_cursor\t*cur;\n\n\tlist_for_each_entry(cur, &ailp->xa_cursors, list) {\n\t\tif (cur->item == lip)\n\t\t\tcur->item = (struct xfs_log_item *)\n\t\t\t\t\t((__psint_t)cur->item | 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&lip->li_ail"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ail_check",
          "args": [
            "ailp",
            "lip"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ail_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
          "lines": "35-58",
          "snippet": "STATIC void\nxfs_ail_check(\n\tstruct xfs_ail\t*ailp,\n\txfs_log_item_t\t*lip)\n{\n\txfs_log_item_t\t*prev_lip;\n\n\tif (list_empty(&ailp->xa_ail))\n\t\treturn;\n\n\t/*\n\t * Check the next and previous entries are valid.\n\t */\n\tASSERT((lip->li_flags & XFS_LI_IN_AIL) != 0);\n\tprev_lip = list_entry(lip->li_ail.prev, xfs_log_item_t, li_ail);\n\tif (&prev_lip->li_ail != &ailp->xa_ail)\n\t\tASSERT(XFS_LSN_CMP(prev_lip->li_lsn, lip->li_lsn) <= 0);\n\n\tprev_lip = list_entry(lip->li_ail.next, xfs_log_item_t, li_ail);\n\tif (&prev_lip->li_ail != &ailp->xa_ail)\n\t\tASSERT(XFS_LSN_CMP(prev_lip->li_lsn, lip->li_lsn) >= 0);\n\n\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_ail_check(\n\tstruct xfs_ail\t*ailp,\n\txfs_log_item_t\t*lip)\n{\n\txfs_log_item_t\t*prev_lip;\n\n\tif (list_empty(&ailp->xa_ail))\n\t\treturn;\n\n\t/*\n\t * Check the next and previous entries are valid.\n\t */\n\tASSERT((lip->li_flags & XFS_LI_IN_AIL) != 0);\n\tprev_lip = list_entry(lip->li_ail.prev, xfs_log_item_t, li_ail);\n\tif (&prev_lip->li_ail != &ailp->xa_ail)\n\t\tASSERT(XFS_LSN_CMP(prev_lip->li_lsn, lip->li_lsn) <= 0);\n\n\tprev_lip = list_entry(lip->li_ail.next, xfs_log_item_t, li_ail);\n\tif (&prev_lip->li_ail != &ailp->xa_ail)\n\t\tASSERT(XFS_LSN_CMP(prev_lip->li_lsn, lip->li_lsn) >= 0);\n\n\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_ail_delete(\n\tstruct xfs_ail  *ailp,\n\txfs_log_item_t  *lip)\n{\n\txfs_ail_check(ailp, lip);\n\tlist_del(&lip->li_ail);\n\txfs_trans_ail_cursor_clear(ailp, lip);\n}"
  },
  {
    "function_name": "xfs_ail_splice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
    "lines": "273-313",
    "snippet": "static void\nxfs_ail_splice(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_ail_cursor\t*cur,\n\tstruct list_head\t*list,\n\txfs_lsn_t\t\tlsn)\n{\n\tstruct xfs_log_item\t*lip;\n\n\tASSERT(!list_empty(list));\n\n\t/*\n\t * Use the cursor to determine the insertion point if one is\n\t * provided.  If not, or if the one we got is not valid,\n\t * find the place in the AIL where the items belong.\n\t */\n\tlip = cur ? cur->item : NULL;\n\tif (!lip || (__psint_t) lip & 1)\n\t\tlip = __xfs_trans_ail_cursor_last(ailp, lsn);\n\n\t/*\n\t * If a cursor is provided, we know we're processing the AIL\n\t * in lsn order, and future items to be spliced in will\n\t * follow the last one being inserted now.  Update the\n\t * cursor to point to that last item, now while we have a\n\t * reliable pointer to it.\n\t */\n\tif (cur)\n\t\tcur->item = list_entry(list->prev, struct xfs_log_item, li_ail);\n\n\t/*\n\t * Finally perform the splice.  Unless the AIL was empty,\n\t * lip points to the item in the AIL _after_ which the new\n\t * items should go.  If lip is null the AIL was empty, so\n\t * the new items go at the head of the AIL.\n\t */\n\tif (lip)\n\t\tlist_splice(list, &lip->li_ail);\n\telse\n\t\tlist_splice(list, &ailp->xa_ail);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_splice",
          "args": [
            "list",
            "&ailp->xa_ail"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_splice",
          "args": [
            "list",
            "&lip->li_ail"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "list->prev",
            "structxfs_log_item",
            "li_ail"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__xfs_trans_ail_cursor_last",
          "args": [
            "ailp",
            "lsn"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "__xfs_trans_ail_cursor_last",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
          "lines": "236-248",
          "snippet": "static struct xfs_log_item *\n__xfs_trans_ail_cursor_last(\n\tstruct xfs_ail\t\t*ailp,\n\txfs_lsn_t\t\tlsn)\n{\n\txfs_log_item_t\t\t*lip;\n\n\tlist_for_each_entry_reverse(lip, &ailp->xa_ail, li_ail) {\n\t\tif (XFS_LSN_CMP(lip->li_lsn, lsn) <= 0)\n\t\t\treturn lip;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic struct xfs_log_item *\n__xfs_trans_ail_cursor_last(\n\tstruct xfs_ail\t\t*ailp,\n\txfs_lsn_t\t\tlsn)\n{\n\txfs_log_item_t\t\t*lip;\n\n\tlist_for_each_entry_reverse(lip, &ailp->xa_ail, li_ail) {\n\t\tif (XFS_LSN_CMP(lip->li_lsn, lsn) <= 0)\n\t\t\treturn lip;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!list_empty(list)"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "list"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_ail_splice(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_ail_cursor\t*cur,\n\tstruct list_head\t*list,\n\txfs_lsn_t\t\tlsn)\n{\n\tstruct xfs_log_item\t*lip;\n\n\tASSERT(!list_empty(list));\n\n\t/*\n\t * Use the cursor to determine the insertion point if one is\n\t * provided.  If not, or if the one we got is not valid,\n\t * find the place in the AIL where the items belong.\n\t */\n\tlip = cur ? cur->item : NULL;\n\tif (!lip || (__psint_t) lip & 1)\n\t\tlip = __xfs_trans_ail_cursor_last(ailp, lsn);\n\n\t/*\n\t * If a cursor is provided, we know we're processing the AIL\n\t * in lsn order, and future items to be spliced in will\n\t * follow the last one being inserted now.  Update the\n\t * cursor to point to that last item, now while we have a\n\t * reliable pointer to it.\n\t */\n\tif (cur)\n\t\tcur->item = list_entry(list->prev, struct xfs_log_item, li_ail);\n\n\t/*\n\t * Finally perform the splice.  Unless the AIL was empty,\n\t * lip points to the item in the AIL _after_ which the new\n\t * items should go.  If lip is null the AIL was empty, so\n\t * the new items go at the head of the AIL.\n\t */\n\tif (lip)\n\t\tlist_splice(list, &lip->li_ail);\n\telse\n\t\tlist_splice(list, &ailp->xa_ail);\n}"
  },
  {
    "function_name": "xfs_trans_ail_cursor_last",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
    "lines": "256-265",
    "snippet": "struct xfs_log_item *\nxfs_trans_ail_cursor_last(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_ail_cursor\t*cur,\n\txfs_lsn_t\t\tlsn)\n{\n\txfs_trans_ail_cursor_init(ailp, cur);\n\tcur->item = __xfs_trans_ail_cursor_last(ailp, lsn);\n\treturn cur->item;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__xfs_trans_ail_cursor_last",
          "args": [
            "ailp",
            "lsn"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "__xfs_trans_ail_cursor_last",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
          "lines": "236-248",
          "snippet": "static struct xfs_log_item *\n__xfs_trans_ail_cursor_last(\n\tstruct xfs_ail\t\t*ailp,\n\txfs_lsn_t\t\tlsn)\n{\n\txfs_log_item_t\t\t*lip;\n\n\tlist_for_each_entry_reverse(lip, &ailp->xa_ail, li_ail) {\n\t\tif (XFS_LSN_CMP(lip->li_lsn, lsn) <= 0)\n\t\t\treturn lip;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic struct xfs_log_item *\n__xfs_trans_ail_cursor_last(\n\tstruct xfs_ail\t\t*ailp,\n\txfs_lsn_t\t\tlsn)\n{\n\txfs_log_item_t\t\t*lip;\n\n\tlist_for_each_entry_reverse(lip, &ailp->xa_ail, li_ail) {\n\t\tif (XFS_LSN_CMP(lip->li_lsn, lsn) <= 0)\n\t\t\treturn lip;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ail_cursor_init",
          "args": [
            "ailp",
            "cur"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ail_cursor_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
          "lines": "142-149",
          "snippet": "STATIC void\nxfs_trans_ail_cursor_init(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_ail_cursor\t*cur)\n{\n\tcur->item = NULL;\n\tlist_add_tail(&cur->list, &ailp->xa_cursors);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_trans_ail_cursor_init(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_ail_cursor\t*cur)\n{\n\tcur->item = NULL;\n\tlist_add_tail(&cur->list, &ailp->xa_cursors);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_log_item *\nxfs_trans_ail_cursor_last(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_ail_cursor\t*cur,\n\txfs_lsn_t\t\tlsn)\n{\n\txfs_trans_ail_cursor_init(ailp, cur);\n\tcur->item = __xfs_trans_ail_cursor_last(ailp, lsn);\n\treturn cur->item;\n}"
  },
  {
    "function_name": "__xfs_trans_ail_cursor_last",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
    "lines": "236-248",
    "snippet": "static struct xfs_log_item *\n__xfs_trans_ail_cursor_last(\n\tstruct xfs_ail\t\t*ailp,\n\txfs_lsn_t\t\tlsn)\n{\n\txfs_log_item_t\t\t*lip;\n\n\tlist_for_each_entry_reverse(lip, &ailp->xa_ail, li_ail) {\n\t\tif (XFS_LSN_CMP(lip->li_lsn, lsn) <= 0)\n\t\t\treturn lip;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_LSN_CMP",
          "args": [
            "lip->li_lsn",
            "lsn"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_reverse",
          "args": [
            "lip",
            "&ailp->xa_ail",
            "li_ail"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic struct xfs_log_item *\n__xfs_trans_ail_cursor_last(\n\tstruct xfs_ail\t\t*ailp,\n\txfs_lsn_t\t\tlsn)\n{\n\txfs_log_item_t\t\t*lip;\n\n\tlist_for_each_entry_reverse(lip, &ailp->xa_ail, li_ail) {\n\t\tif (XFS_LSN_CMP(lip->li_lsn, lsn) <= 0)\n\t\t\treturn lip;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "xfs_trans_ail_cursor_first",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
    "lines": "209-234",
    "snippet": "xfs_log_item_t *\nxfs_trans_ail_cursor_first(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_ail_cursor\t*cur,\n\txfs_lsn_t\t\tlsn)\n{\n\txfs_log_item_t\t\t*lip;\n\n\txfs_trans_ail_cursor_init(ailp, cur);\n\n\tif (lsn == 0) {\n\t\tlip = xfs_ail_min(ailp);\n\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(lip, &ailp->xa_ail, li_ail) {\n\t\tif (XFS_LSN_CMP(lip->li_lsn, lsn) >= 0)\n\t\t\tgoto out;\n\t}\n\treturn NULL;\n\nout:\n\tif (lip)\n\t\tcur->item = xfs_ail_next(ailp, lip);\n\treturn lip;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_ail_next",
          "args": [
            "ailp",
            "lip"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ail_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
          "lines": "81-90",
          "snippet": "static xfs_log_item_t *\nxfs_ail_next(\n\tstruct xfs_ail  *ailp,\n\txfs_log_item_t  *lip)\n{\n\tif (lip->li_ail.next == &ailp->xa_ail)\n\t\treturn NULL;\n\n\treturn list_first_entry(&lip->li_ail, xfs_log_item_t, li_ail);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic xfs_log_item_t *\nxfs_ail_next(\n\tstruct xfs_ail  *ailp,\n\txfs_log_item_t  *lip)\n{\n\tif (lip->li_ail.next == &ailp->xa_ail)\n\t\treturn NULL;\n\n\treturn list_first_entry(&lip->li_ail, xfs_log_item_t, li_ail);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_LSN_CMP",
          "args": [
            "lip->li_lsn",
            "lsn"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lip",
            "&ailp->xa_ail",
            "li_ail"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_ail_min",
          "args": [
            "ailp"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ail_min_lsn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
          "lines": "100-114",
          "snippet": "xfs_lsn_t\nxfs_ail_min_lsn(\n\tstruct xfs_ail\t*ailp)\n{\n\txfs_lsn_t\tlsn = 0;\n\txfs_log_item_t\t*lip;\n\n\tspin_lock(&ailp->xa_lock);\n\tlip = xfs_ail_min(ailp);\n\tif (lip)\n\t\tlsn = lip->li_lsn;\n\tspin_unlock(&ailp->xa_lock);\n\n\treturn lsn;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_lsn_t\nxfs_ail_min_lsn(\n\tstruct xfs_ail\t*ailp)\n{\n\txfs_lsn_t\tlsn = 0;\n\txfs_log_item_t\t*lip;\n\n\tspin_lock(&ailp->xa_lock);\n\tlip = xfs_ail_min(ailp);\n\tif (lip)\n\t\tlsn = lip->li_lsn;\n\tspin_unlock(&ailp->xa_lock);\n\n\treturn lsn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ail_cursor_init",
          "args": [
            "ailp",
            "cur"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ail_cursor_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
          "lines": "142-149",
          "snippet": "STATIC void\nxfs_trans_ail_cursor_init(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_ail_cursor\t*cur)\n{\n\tcur->item = NULL;\n\tlist_add_tail(&cur->list, &ailp->xa_cursors);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_trans_ail_cursor_init(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_ail_cursor\t*cur)\n{\n\tcur->item = NULL;\n\tlist_add_tail(&cur->list, &ailp->xa_cursors);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_log_item_t *\nxfs_trans_ail_cursor_first(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_ail_cursor\t*cur,\n\txfs_lsn_t\t\tlsn)\n{\n\txfs_log_item_t\t\t*lip;\n\n\txfs_trans_ail_cursor_init(ailp, cur);\n\n\tif (lsn == 0) {\n\t\tlip = xfs_ail_min(ailp);\n\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(lip, &ailp->xa_ail, li_ail) {\n\t\tif (XFS_LSN_CMP(lip->li_lsn, lsn) >= 0)\n\t\t\tgoto out;\n\t}\n\treturn NULL;\n\nout:\n\tif (lip)\n\t\tcur->item = xfs_ail_next(ailp, lip);\n\treturn lip;\n}"
  },
  {
    "function_name": "xfs_trans_ail_cursor_clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
    "lines": "189-201",
    "snippet": "STATIC void\nxfs_trans_ail_cursor_clear(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_log_item\t*lip)\n{\n\tstruct xfs_ail_cursor\t*cur;\n\n\tlist_for_each_entry(cur, &ailp->xa_cursors, list) {\n\t\tif (cur->item == lip)\n\t\t\tcur->item = (struct xfs_log_item *)\n\t\t\t\t\t((__psint_t)cur->item | 1);\n\t}\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cur",
            "&ailp->xa_cursors",
            "list"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_trans_ail_cursor_clear(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_log_item\t*lip)\n{\n\tstruct xfs_ail_cursor\t*cur;\n\n\tlist_for_each_entry(cur, &ailp->xa_cursors, list) {\n\t\tif (cur->item == lip)\n\t\t\tcur->item = (struct xfs_log_item *)\n\t\t\t\t\t((__psint_t)cur->item | 1);\n\t}\n}"
  },
  {
    "function_name": "xfs_trans_ail_cursor_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
    "lines": "173-179",
    "snippet": "void\nxfs_trans_ail_cursor_done(\n\tstruct xfs_ail_cursor\t*cur)\n{\n\tcur->item = NULL;\n\tlist_del_init(&cur->list);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&cur->list"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ail_cursor_done(\n\tstruct xfs_ail_cursor\t*cur)\n{\n\tcur->item = NULL;\n\tlist_del_init(&cur->list);\n}"
  },
  {
    "function_name": "xfs_trans_ail_cursor_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
    "lines": "155-167",
    "snippet": "struct xfs_log_item *\nxfs_trans_ail_cursor_next(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_ail_cursor\t*cur)\n{\n\tstruct xfs_log_item\t*lip = cur->item;\n\n\tif ((__psint_t)lip & 1)\n\t\tlip = xfs_ail_min(ailp);\n\tif (lip)\n\t\tcur->item = xfs_ail_next(ailp, lip);\n\treturn lip;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_ail_next",
          "args": [
            "ailp",
            "lip"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ail_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
          "lines": "81-90",
          "snippet": "static xfs_log_item_t *\nxfs_ail_next(\n\tstruct xfs_ail  *ailp,\n\txfs_log_item_t  *lip)\n{\n\tif (lip->li_ail.next == &ailp->xa_ail)\n\t\treturn NULL;\n\n\treturn list_first_entry(&lip->li_ail, xfs_log_item_t, li_ail);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic xfs_log_item_t *\nxfs_ail_next(\n\tstruct xfs_ail  *ailp,\n\txfs_log_item_t  *lip)\n{\n\tif (lip->li_ail.next == &ailp->xa_ail)\n\t\treturn NULL;\n\n\treturn list_first_entry(&lip->li_ail, xfs_log_item_t, li_ail);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ail_min",
          "args": [
            "ailp"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ail_min_lsn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
          "lines": "100-114",
          "snippet": "xfs_lsn_t\nxfs_ail_min_lsn(\n\tstruct xfs_ail\t*ailp)\n{\n\txfs_lsn_t\tlsn = 0;\n\txfs_log_item_t\t*lip;\n\n\tspin_lock(&ailp->xa_lock);\n\tlip = xfs_ail_min(ailp);\n\tif (lip)\n\t\tlsn = lip->li_lsn;\n\tspin_unlock(&ailp->xa_lock);\n\n\treturn lsn;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_lsn_t\nxfs_ail_min_lsn(\n\tstruct xfs_ail\t*ailp)\n{\n\txfs_lsn_t\tlsn = 0;\n\txfs_log_item_t\t*lip;\n\n\tspin_lock(&ailp->xa_lock);\n\tlip = xfs_ail_min(ailp);\n\tif (lip)\n\t\tlsn = lip->li_lsn;\n\tspin_unlock(&ailp->xa_lock);\n\n\treturn lsn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_log_item *\nxfs_trans_ail_cursor_next(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_ail_cursor\t*cur)\n{\n\tstruct xfs_log_item\t*lip = cur->item;\n\n\tif ((__psint_t)lip & 1)\n\t\tlip = xfs_ail_min(ailp);\n\tif (lip)\n\t\tcur->item = xfs_ail_next(ailp, lip);\n\treturn lip;\n}"
  },
  {
    "function_name": "xfs_trans_ail_cursor_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
    "lines": "142-149",
    "snippet": "STATIC void\nxfs_trans_ail_cursor_init(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_ail_cursor\t*cur)\n{\n\tcur->item = NULL;\n\tlist_add_tail(&cur->list, &ailp->xa_cursors);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&cur->list",
            "&ailp->xa_cursors"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_trans_ail_cursor_init(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_ail_cursor\t*cur)\n{\n\tcur->item = NULL;\n\tlist_add_tail(&cur->list, &ailp->xa_cursors);\n}"
  },
  {
    "function_name": "xfs_ail_max_lsn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
    "lines": "119-133",
    "snippet": "static xfs_lsn_t\nxfs_ail_max_lsn(\n\tstruct xfs_ail  *ailp)\n{\n\txfs_lsn_t       lsn = 0;\n\txfs_log_item_t  *lip;\n\n\tspin_lock(&ailp->xa_lock);\n\tlip = xfs_ail_max(ailp);\n\tif (lip)\n\t\tlsn = lip->li_lsn;\n\tspin_unlock(&ailp->xa_lock);\n\n\treturn lsn;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ailp->xa_lock"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ail_max",
          "args": [
            "ailp"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ail_max_lsn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
          "lines": "119-133",
          "snippet": "static xfs_lsn_t\nxfs_ail_max_lsn(\n\tstruct xfs_ail  *ailp)\n{\n\txfs_lsn_t       lsn = 0;\n\txfs_log_item_t  *lip;\n\n\tspin_lock(&ailp->xa_lock);\n\tlip = xfs_ail_max(ailp);\n\tif (lip)\n\t\tlsn = lip->li_lsn;\n\tspin_unlock(&ailp->xa_lock);\n\n\treturn lsn;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ailp->xa_lock"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic xfs_lsn_t\nxfs_ail_max_lsn(\n\tstruct xfs_ail  *ailp)\n{\n\txfs_lsn_t       lsn = 0;\n\txfs_log_item_t  *lip;\n\n\tspin_lock(&ailp->xa_lock);\n\tlip = xfs_ail_max(ailp);\n\tif (lip)\n\t\tlsn = lip->li_lsn;\n\tspin_unlock(&ailp->xa_lock);\n\n\treturn lsn;\n}"
  },
  {
    "function_name": "xfs_ail_min_lsn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
    "lines": "100-114",
    "snippet": "xfs_lsn_t\nxfs_ail_min_lsn(\n\tstruct xfs_ail\t*ailp)\n{\n\txfs_lsn_t\tlsn = 0;\n\txfs_log_item_t\t*lip;\n\n\tspin_lock(&ailp->xa_lock);\n\tlip = xfs_ail_min(ailp);\n\tif (lip)\n\t\tlsn = lip->li_lsn;\n\tspin_unlock(&ailp->xa_lock);\n\n\treturn lsn;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ailp->xa_lock"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ail_min",
          "args": [
            "ailp"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ail_min_lsn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
          "lines": "100-114",
          "snippet": "xfs_lsn_t\nxfs_ail_min_lsn(\n\tstruct xfs_ail\t*ailp)\n{\n\txfs_lsn_t\tlsn = 0;\n\txfs_log_item_t\t*lip;\n\n\tspin_lock(&ailp->xa_lock);\n\tlip = xfs_ail_min(ailp);\n\tif (lip)\n\t\tlsn = lip->li_lsn;\n\tspin_unlock(&ailp->xa_lock);\n\n\treturn lsn;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ailp->xa_lock"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_lsn_t\nxfs_ail_min_lsn(\n\tstruct xfs_ail\t*ailp)\n{\n\txfs_lsn_t\tlsn = 0;\n\txfs_log_item_t\t*lip;\n\n\tspin_lock(&ailp->xa_lock);\n\tlip = xfs_ail_min(ailp);\n\tif (lip)\n\t\tlsn = lip->li_lsn;\n\tspin_unlock(&ailp->xa_lock);\n\n\treturn lsn;\n}"
  },
  {
    "function_name": "xfs_ail_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
    "lines": "81-90",
    "snippet": "static xfs_log_item_t *\nxfs_ail_next(\n\tstruct xfs_ail  *ailp,\n\txfs_log_item_t  *lip)\n{\n\tif (lip->li_ail.next == &ailp->xa_ail)\n\t\treturn NULL;\n\n\treturn list_first_entry(&lip->li_ail, xfs_log_item_t, li_ail);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&lip->li_ail",
            "xfs_log_item_t",
            "li_ail"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic xfs_log_item_t *\nxfs_ail_next(\n\tstruct xfs_ail  *ailp,\n\txfs_log_item_t  *lip)\n{\n\tif (lip->li_ail.next == &ailp->xa_ail)\n\t\treturn NULL;\n\n\treturn list_first_entry(&lip->li_ail, xfs_log_item_t, li_ail);\n}"
  },
  {
    "function_name": "xfs_ail_max",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
    "lines": "67-75",
    "snippet": "static xfs_log_item_t *\nxfs_ail_max(\n\tstruct xfs_ail  *ailp)\n{\n\tif (list_empty(&ailp->xa_ail))\n\t\treturn NULL;\n\n\treturn list_entry(ailp->xa_ail.prev, xfs_log_item_t, li_ail);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "ailp->xa_ail.prev",
            "xfs_log_item_t",
            "li_ail"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ailp->xa_ail"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic xfs_log_item_t *\nxfs_ail_max(\n\tstruct xfs_ail  *ailp)\n{\n\tif (list_empty(&ailp->xa_ail))\n\t\treturn NULL;\n\n\treturn list_entry(ailp->xa_ail.prev, xfs_log_item_t, li_ail);\n}"
  },
  {
    "function_name": "xfs_ail_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
    "lines": "35-58",
    "snippet": "STATIC void\nxfs_ail_check(\n\tstruct xfs_ail\t*ailp,\n\txfs_log_item_t\t*lip)\n{\n\txfs_log_item_t\t*prev_lip;\n\n\tif (list_empty(&ailp->xa_ail))\n\t\treturn;\n\n\t/*\n\t * Check the next and previous entries are valid.\n\t */\n\tASSERT((lip->li_flags & XFS_LI_IN_AIL) != 0);\n\tprev_lip = list_entry(lip->li_ail.prev, xfs_log_item_t, li_ail);\n\tif (&prev_lip->li_ail != &ailp->xa_ail)\n\t\tASSERT(XFS_LSN_CMP(prev_lip->li_lsn, lip->li_lsn) <= 0);\n\n\tprev_lip = list_entry(lip->li_ail.next, xfs_log_item_t, li_ail);\n\tif (&prev_lip->li_ail != &ailp->xa_ail)\n\t\tASSERT(XFS_LSN_CMP(prev_lip->li_lsn, lip->li_lsn) >= 0);\n\n\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_LSN_CMP(prev_lip->li_lsn, lip->li_lsn) >= 0"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_LSN_CMP",
          "args": [
            "prev_lip->li_lsn",
            "lip->li_lsn"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "lip->li_ail.next",
            "xfs_log_item_t",
            "li_ail"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_LSN_CMP(prev_lip->li_lsn, lip->li_lsn) <= 0"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_LSN_CMP",
          "args": [
            "prev_lip->li_lsn",
            "lip->li_lsn"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "lip->li_ail.prev",
            "xfs_log_item_t",
            "li_ail"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(lip->li_flags & XFS_LI_IN_AIL) != 0"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ailp->xa_ail"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_ail_check(\n\tstruct xfs_ail\t*ailp,\n\txfs_log_item_t\t*lip)\n{\n\txfs_log_item_t\t*prev_lip;\n\n\tif (list_empty(&ailp->xa_ail))\n\t\treturn;\n\n\t/*\n\t * Check the next and previous entries are valid.\n\t */\n\tASSERT((lip->li_flags & XFS_LI_IN_AIL) != 0);\n\tprev_lip = list_entry(lip->li_ail.prev, xfs_log_item_t, li_ail);\n\tif (&prev_lip->li_ail != &ailp->xa_ail)\n\t\tASSERT(XFS_LSN_CMP(prev_lip->li_lsn, lip->li_lsn) <= 0);\n\n\tprev_lip = list_entry(lip->li_ail.next, xfs_log_item_t, li_ail);\n\tif (&prev_lip->li_ail != &ailp->xa_ail)\n\t\tASSERT(XFS_LSN_CMP(prev_lip->li_lsn, lip->li_lsn) >= 0);\n\n\n}"
  }
]