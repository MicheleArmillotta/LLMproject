[
  {
    "function_name": "xfs_fs_set_dqblk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_quotaops.c",
    "lines": "161-178",
    "snippet": "STATIC int\nxfs_fs_set_dqblk(\n\tstruct super_block\t*sb,\n\tstruct kqid\t\tqid,\n\tstruct qc_dqblk\t\t*qdq)\n{\n\tstruct xfs_mount\t*mp = XFS_M(sb);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn -EROFS;\n\tif (!XFS_IS_QUOTA_RUNNING(mp))\n\t\treturn -ENOSYS;\n\tif (!XFS_IS_QUOTA_ON(mp))\n\t\treturn -ESRCH;\n\n\treturn xfs_qm_scall_setqlim(mp, from_kqid(&init_user_ns, qid),\n\t\t\t\t     xfs_quota_type(qid.type), qdq);\n}",
    "includes": [
      "#include <linux/quota.h>",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_qm_scall_setqlim",
          "args": [
            "mp",
            "from_kqid(&init_user_ns, qid)",
            "xfs_quota_type(qid.type)",
            "qdq"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_scall_setqlim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm_syscalls.c",
          "lines": "551-712",
          "snippet": "int\nxfs_qm_scall_setqlim(\n\tstruct xfs_mount\t*mp,\n\txfs_dqid_t\t\tid,\n\tuint\t\t\ttype,\n\tstruct qc_dqblk\t\t*newlim)\n{\n\tstruct xfs_quotainfo\t*q = mp->m_quotainfo;\n\tstruct xfs_disk_dquot\t*ddq;\n\tstruct xfs_dquot\t*dqp;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\txfs_qcnt_t\t\thard, soft;\n\n\tif (newlim->d_fieldmask & ~XFS_QC_MASK)\n\t\treturn -EINVAL;\n\tif ((newlim->d_fieldmask & XFS_QC_MASK) == 0)\n\t\treturn 0;\n\n\t/*\n\t * We don't want to race with a quotaoff so take the quotaoff lock.\n\t * We don't hold an inode lock, so there's nothing else to stop\n\t * a quotaoff from happening.\n\t */\n\tmutex_lock(&q->qi_quotaofflock);\n\n\t/*\n\t * Get the dquot (locked) before we start, as we need to do a\n\t * transaction to allocate it if it doesn't exist. Once we have the\n\t * dquot, unlock it so we can start the next transaction safely. We hold\n\t * a reference to the dquot, so it's safe to do this unlock/lock without\n\t * it being reclaimed in the mean time.\n\t */\n\terror = xfs_qm_dqget(mp, NULL, id, type, XFS_QMOPT_DQALLOC, &dqp);\n\tif (error) {\n\t\tASSERT(error != -ENOENT);\n\t\tgoto out_unlock;\n\t}\n\txfs_dqunlock(dqp);\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_QM_SETQLIM);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_qm_setqlim, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\tgoto out_rele;\n\t}\n\n\txfs_dqlock(dqp);\n\txfs_trans_dqjoin(tp, dqp);\n\tddq = &dqp->q_core;\n\n\t/*\n\t * Make sure that hardlimits are >= soft limits before changing.\n\t */\n\thard = (newlim->d_fieldmask & QC_SPC_HARD) ?\n\t\t(xfs_qcnt_t) XFS_B_TO_FSB(mp, newlim->d_spc_hardlimit) :\n\t\t\tbe64_to_cpu(ddq->d_blk_hardlimit);\n\tsoft = (newlim->d_fieldmask & QC_SPC_SOFT) ?\n\t\t(xfs_qcnt_t) XFS_B_TO_FSB(mp, newlim->d_spc_softlimit) :\n\t\t\tbe64_to_cpu(ddq->d_blk_softlimit);\n\tif (hard == 0 || hard >= soft) {\n\t\tddq->d_blk_hardlimit = cpu_to_be64(hard);\n\t\tddq->d_blk_softlimit = cpu_to_be64(soft);\n\t\txfs_dquot_set_prealloc_limits(dqp);\n\t\tif (id == 0) {\n\t\t\tq->qi_bhardlimit = hard;\n\t\t\tq->qi_bsoftlimit = soft;\n\t\t}\n\t} else {\n\t\txfs_debug(mp, \"blkhard %Ld < blksoft %Ld\", hard, soft);\n\t}\n\thard = (newlim->d_fieldmask & QC_RT_SPC_HARD) ?\n\t\t(xfs_qcnt_t) XFS_B_TO_FSB(mp, newlim->d_rt_spc_hardlimit) :\n\t\t\tbe64_to_cpu(ddq->d_rtb_hardlimit);\n\tsoft = (newlim->d_fieldmask & QC_RT_SPC_SOFT) ?\n\t\t(xfs_qcnt_t) XFS_B_TO_FSB(mp, newlim->d_rt_spc_softlimit) :\n\t\t\tbe64_to_cpu(ddq->d_rtb_softlimit);\n\tif (hard == 0 || hard >= soft) {\n\t\tddq->d_rtb_hardlimit = cpu_to_be64(hard);\n\t\tddq->d_rtb_softlimit = cpu_to_be64(soft);\n\t\tif (id == 0) {\n\t\t\tq->qi_rtbhardlimit = hard;\n\t\t\tq->qi_rtbsoftlimit = soft;\n\t\t}\n\t} else {\n\t\txfs_debug(mp, \"rtbhard %Ld < rtbsoft %Ld\", hard, soft);\n\t}\n\n\thard = (newlim->d_fieldmask & QC_INO_HARD) ?\n\t\t(xfs_qcnt_t) newlim->d_ino_hardlimit :\n\t\t\tbe64_to_cpu(ddq->d_ino_hardlimit);\n\tsoft = (newlim->d_fieldmask & QC_INO_SOFT) ?\n\t\t(xfs_qcnt_t) newlim->d_ino_softlimit :\n\t\t\tbe64_to_cpu(ddq->d_ino_softlimit);\n\tif (hard == 0 || hard >= soft) {\n\t\tddq->d_ino_hardlimit = cpu_to_be64(hard);\n\t\tddq->d_ino_softlimit = cpu_to_be64(soft);\n\t\tif (id == 0) {\n\t\t\tq->qi_ihardlimit = hard;\n\t\t\tq->qi_isoftlimit = soft;\n\t\t}\n\t} else {\n\t\txfs_debug(mp, \"ihard %Ld < isoft %Ld\", hard, soft);\n\t}\n\n\t/*\n\t * Update warnings counter(s) if requested\n\t */\n\tif (newlim->d_fieldmask & QC_SPC_WARNS)\n\t\tddq->d_bwarns = cpu_to_be16(newlim->d_spc_warns);\n\tif (newlim->d_fieldmask & QC_INO_WARNS)\n\t\tddq->d_iwarns = cpu_to_be16(newlim->d_ino_warns);\n\tif (newlim->d_fieldmask & QC_RT_SPC_WARNS)\n\t\tddq->d_rtbwarns = cpu_to_be16(newlim->d_rt_spc_warns);\n\n\tif (id == 0) {\n\t\t/*\n\t\t * Timelimits for the super user set the relative time\n\t\t * the other users can be over quota for this file system.\n\t\t * If it is zero a default is used.  Ditto for the default\n\t\t * soft and hard limit values (already done, above), and\n\t\t * for warnings.\n\t\t */\n\t\tif (newlim->d_fieldmask & QC_SPC_TIMER) {\n\t\t\tq->qi_btimelimit = newlim->d_spc_timer;\n\t\t\tddq->d_btimer = cpu_to_be32(newlim->d_spc_timer);\n\t\t}\n\t\tif (newlim->d_fieldmask & QC_INO_TIMER) {\n\t\t\tq->qi_itimelimit = newlim->d_ino_timer;\n\t\t\tddq->d_itimer = cpu_to_be32(newlim->d_ino_timer);\n\t\t}\n\t\tif (newlim->d_fieldmask & QC_RT_SPC_TIMER) {\n\t\t\tq->qi_rtbtimelimit = newlim->d_rt_spc_timer;\n\t\t\tddq->d_rtbtimer = cpu_to_be32(newlim->d_rt_spc_timer);\n\t\t}\n\t\tif (newlim->d_fieldmask & QC_SPC_WARNS)\n\t\t\tq->qi_bwarnlimit = newlim->d_spc_warns;\n\t\tif (newlim->d_fieldmask & QC_INO_WARNS)\n\t\t\tq->qi_iwarnlimit = newlim->d_ino_warns;\n\t\tif (newlim->d_fieldmask & QC_RT_SPC_WARNS)\n\t\t\tq->qi_rtbwarnlimit = newlim->d_rt_spc_warns;\n\t} else {\n\t\t/*\n\t\t * If the user is now over quota, start the timelimit.\n\t\t * The user will not be 'warned'.\n\t\t * Note that we keep the timers ticking, whether enforcement\n\t\t * is on or off. We don't really want to bother with iterating\n\t\t * over all ondisk dquots and turning the timers on/off.\n\t\t */\n\t\txfs_qm_adjust_dqtimers(mp, ddq);\n\t}\n\tdqp->dq_flags |= XFS_DQ_DIRTY;\n\txfs_trans_log_dquot(tp, dqp);\n\n\terror = xfs_trans_commit(tp, 0);\n\nout_rele:\n\txfs_qm_dqrele(dqp);\nout_unlock:\n\tmutex_unlock(&q->qi_quotaofflock);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define XFS_QC_MASK \\\n\t(QC_LIMIT_MASK | QC_TIMER_MASK | QC_WARNS_MASK)"
          ],
          "globals_used": [
            "STATIC int\txfs_qm_log_quotaoff(xfs_mount_t *, xfs_qoff_logitem_t **, uint);",
            "STATIC int\txfs_qm_log_quotaoff_end(xfs_mount_t *, xfs_qoff_logitem_t *,\n\t\t\t\t\tuint);",
            "STATIC uint\txfs_qm_export_flags(uint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/capability.h>\n\n#define XFS_QC_MASK \\\n\t(QC_LIMIT_MASK | QC_TIMER_MASK | QC_WARNS_MASK)\n\nSTATIC int\txfs_qm_log_quotaoff(xfs_mount_t *, xfs_qoff_logitem_t **, uint);\nSTATIC int\txfs_qm_log_quotaoff_end(xfs_mount_t *, xfs_qoff_logitem_t *,\n\t\t\t\t\tuint);\nSTATIC uint\txfs_qm_export_flags(uint);\n\nint\nxfs_qm_scall_setqlim(\n\tstruct xfs_mount\t*mp,\n\txfs_dqid_t\t\tid,\n\tuint\t\t\ttype,\n\tstruct qc_dqblk\t\t*newlim)\n{\n\tstruct xfs_quotainfo\t*q = mp->m_quotainfo;\n\tstruct xfs_disk_dquot\t*ddq;\n\tstruct xfs_dquot\t*dqp;\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\txfs_qcnt_t\t\thard, soft;\n\n\tif (newlim->d_fieldmask & ~XFS_QC_MASK)\n\t\treturn -EINVAL;\n\tif ((newlim->d_fieldmask & XFS_QC_MASK) == 0)\n\t\treturn 0;\n\n\t/*\n\t * We don't want to race with a quotaoff so take the quotaoff lock.\n\t * We don't hold an inode lock, so there's nothing else to stop\n\t * a quotaoff from happening.\n\t */\n\tmutex_lock(&q->qi_quotaofflock);\n\n\t/*\n\t * Get the dquot (locked) before we start, as we need to do a\n\t * transaction to allocate it if it doesn't exist. Once we have the\n\t * dquot, unlock it so we can start the next transaction safely. We hold\n\t * a reference to the dquot, so it's safe to do this unlock/lock without\n\t * it being reclaimed in the mean time.\n\t */\n\terror = xfs_qm_dqget(mp, NULL, id, type, XFS_QMOPT_DQALLOC, &dqp);\n\tif (error) {\n\t\tASSERT(error != -ENOENT);\n\t\tgoto out_unlock;\n\t}\n\txfs_dqunlock(dqp);\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_QM_SETQLIM);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_qm_setqlim, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\tgoto out_rele;\n\t}\n\n\txfs_dqlock(dqp);\n\txfs_trans_dqjoin(tp, dqp);\n\tddq = &dqp->q_core;\n\n\t/*\n\t * Make sure that hardlimits are >= soft limits before changing.\n\t */\n\thard = (newlim->d_fieldmask & QC_SPC_HARD) ?\n\t\t(xfs_qcnt_t) XFS_B_TO_FSB(mp, newlim->d_spc_hardlimit) :\n\t\t\tbe64_to_cpu(ddq->d_blk_hardlimit);\n\tsoft = (newlim->d_fieldmask & QC_SPC_SOFT) ?\n\t\t(xfs_qcnt_t) XFS_B_TO_FSB(mp, newlim->d_spc_softlimit) :\n\t\t\tbe64_to_cpu(ddq->d_blk_softlimit);\n\tif (hard == 0 || hard >= soft) {\n\t\tddq->d_blk_hardlimit = cpu_to_be64(hard);\n\t\tddq->d_blk_softlimit = cpu_to_be64(soft);\n\t\txfs_dquot_set_prealloc_limits(dqp);\n\t\tif (id == 0) {\n\t\t\tq->qi_bhardlimit = hard;\n\t\t\tq->qi_bsoftlimit = soft;\n\t\t}\n\t} else {\n\t\txfs_debug(mp, \"blkhard %Ld < blksoft %Ld\", hard, soft);\n\t}\n\thard = (newlim->d_fieldmask & QC_RT_SPC_HARD) ?\n\t\t(xfs_qcnt_t) XFS_B_TO_FSB(mp, newlim->d_rt_spc_hardlimit) :\n\t\t\tbe64_to_cpu(ddq->d_rtb_hardlimit);\n\tsoft = (newlim->d_fieldmask & QC_RT_SPC_SOFT) ?\n\t\t(xfs_qcnt_t) XFS_B_TO_FSB(mp, newlim->d_rt_spc_softlimit) :\n\t\t\tbe64_to_cpu(ddq->d_rtb_softlimit);\n\tif (hard == 0 || hard >= soft) {\n\t\tddq->d_rtb_hardlimit = cpu_to_be64(hard);\n\t\tddq->d_rtb_softlimit = cpu_to_be64(soft);\n\t\tif (id == 0) {\n\t\t\tq->qi_rtbhardlimit = hard;\n\t\t\tq->qi_rtbsoftlimit = soft;\n\t\t}\n\t} else {\n\t\txfs_debug(mp, \"rtbhard %Ld < rtbsoft %Ld\", hard, soft);\n\t}\n\n\thard = (newlim->d_fieldmask & QC_INO_HARD) ?\n\t\t(xfs_qcnt_t) newlim->d_ino_hardlimit :\n\t\t\tbe64_to_cpu(ddq->d_ino_hardlimit);\n\tsoft = (newlim->d_fieldmask & QC_INO_SOFT) ?\n\t\t(xfs_qcnt_t) newlim->d_ino_softlimit :\n\t\t\tbe64_to_cpu(ddq->d_ino_softlimit);\n\tif (hard == 0 || hard >= soft) {\n\t\tddq->d_ino_hardlimit = cpu_to_be64(hard);\n\t\tddq->d_ino_softlimit = cpu_to_be64(soft);\n\t\tif (id == 0) {\n\t\t\tq->qi_ihardlimit = hard;\n\t\t\tq->qi_isoftlimit = soft;\n\t\t}\n\t} else {\n\t\txfs_debug(mp, \"ihard %Ld < isoft %Ld\", hard, soft);\n\t}\n\n\t/*\n\t * Update warnings counter(s) if requested\n\t */\n\tif (newlim->d_fieldmask & QC_SPC_WARNS)\n\t\tddq->d_bwarns = cpu_to_be16(newlim->d_spc_warns);\n\tif (newlim->d_fieldmask & QC_INO_WARNS)\n\t\tddq->d_iwarns = cpu_to_be16(newlim->d_ino_warns);\n\tif (newlim->d_fieldmask & QC_RT_SPC_WARNS)\n\t\tddq->d_rtbwarns = cpu_to_be16(newlim->d_rt_spc_warns);\n\n\tif (id == 0) {\n\t\t/*\n\t\t * Timelimits for the super user set the relative time\n\t\t * the other users can be over quota for this file system.\n\t\t * If it is zero a default is used.  Ditto for the default\n\t\t * soft and hard limit values (already done, above), and\n\t\t * for warnings.\n\t\t */\n\t\tif (newlim->d_fieldmask & QC_SPC_TIMER) {\n\t\t\tq->qi_btimelimit = newlim->d_spc_timer;\n\t\t\tddq->d_btimer = cpu_to_be32(newlim->d_spc_timer);\n\t\t}\n\t\tif (newlim->d_fieldmask & QC_INO_TIMER) {\n\t\t\tq->qi_itimelimit = newlim->d_ino_timer;\n\t\t\tddq->d_itimer = cpu_to_be32(newlim->d_ino_timer);\n\t\t}\n\t\tif (newlim->d_fieldmask & QC_RT_SPC_TIMER) {\n\t\t\tq->qi_rtbtimelimit = newlim->d_rt_spc_timer;\n\t\t\tddq->d_rtbtimer = cpu_to_be32(newlim->d_rt_spc_timer);\n\t\t}\n\t\tif (newlim->d_fieldmask & QC_SPC_WARNS)\n\t\t\tq->qi_bwarnlimit = newlim->d_spc_warns;\n\t\tif (newlim->d_fieldmask & QC_INO_WARNS)\n\t\t\tq->qi_iwarnlimit = newlim->d_ino_warns;\n\t\tif (newlim->d_fieldmask & QC_RT_SPC_WARNS)\n\t\t\tq->qi_rtbwarnlimit = newlim->d_rt_spc_warns;\n\t} else {\n\t\t/*\n\t\t * If the user is now over quota, start the timelimit.\n\t\t * The user will not be 'warned'.\n\t\t * Note that we keep the timers ticking, whether enforcement\n\t\t * is on or off. We don't really want to bother with iterating\n\t\t * over all ondisk dquots and turning the timers on/off.\n\t\t */\n\t\txfs_qm_adjust_dqtimers(mp, ddq);\n\t}\n\tdqp->dq_flags |= XFS_DQ_DIRTY;\n\txfs_trans_log_dquot(tp, dqp);\n\n\terror = xfs_trans_commit(tp, 0);\n\nout_rele:\n\txfs_qm_dqrele(dqp);\nout_unlock:\n\tmutex_unlock(&q->qi_quotaofflock);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_quota_type",
          "args": [
            "qid.type"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_quota_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_quotaops.c",
          "lines": "30-41",
          "snippet": "STATIC int\nxfs_quota_type(int type)\n{\n\tswitch (type) {\n\tcase USRQUOTA:\n\t\treturn XFS_DQ_USER;\n\tcase GRPQUOTA:\n\t\treturn XFS_DQ_GROUP;\n\tdefault:\n\t\treturn XFS_DQ_PROJ;\n\t}\n}",
          "includes": [
            "#include <linux/quota.h>",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quota.h>\n#include \"xfs_qm.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_quota_type(int type)\n{\n\tswitch (type) {\n\tcase USRQUOTA:\n\t\treturn XFS_DQ_USER;\n\tcase GRPQUOTA:\n\t\treturn XFS_DQ_GROUP;\n\tdefault:\n\t\treturn XFS_DQ_PROJ;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kqid",
          "args": [
            "&init_user_ns",
            "qid"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "from_kqid_munged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/kqid.c",
          "lines": "100-112",
          "snippet": "qid_t from_kqid_munged(struct user_namespace *targ, struct kqid kqid)\n{\n\tswitch (kqid.type) {\n\tcase USRQUOTA:\n\t\treturn from_kuid_munged(targ, kqid.uid);\n\tcase GRPQUOTA:\n\t\treturn from_kgid_munged(targ, kqid.gid);\n\tcase PRJQUOTA:\n\t\treturn from_kprojid_munged(targ, kqid.projid);\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/quota.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/quota.h>\n#include <linux/fs.h>\n\nqid_t from_kqid_munged(struct user_namespace *targ, struct kqid kqid)\n{\n\tswitch (kqid.type) {\n\tcase USRQUOTA:\n\t\treturn from_kuid_munged(targ, kqid.uid);\n\tcase GRPQUOTA:\n\t\treturn from_kgid_munged(targ, kqid.gid);\n\tcase PRJQUOTA:\n\t\treturn from_kprojid_munged(targ, kqid.projid);\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IS_QUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_QUOTA_RUNNING",
          "args": [
            "mp"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_M",
          "args": [
            "sb"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/quota.h>\n#include \"xfs_qm.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_fs_set_dqblk(\n\tstruct super_block\t*sb,\n\tstruct kqid\t\tqid,\n\tstruct qc_dqblk\t\t*qdq)\n{\n\tstruct xfs_mount\t*mp = XFS_M(sb);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn -EROFS;\n\tif (!XFS_IS_QUOTA_RUNNING(mp))\n\t\treturn -ENOSYS;\n\tif (!XFS_IS_QUOTA_ON(mp))\n\t\treturn -ESRCH;\n\n\treturn xfs_qm_scall_setqlim(mp, from_kqid(&init_user_ns, qid),\n\t\t\t\t     xfs_quota_type(qid.type), qdq);\n}"
  },
  {
    "function_name": "xfs_fs_get_dqblk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_quotaops.c",
    "lines": "144-159",
    "snippet": "STATIC int\nxfs_fs_get_dqblk(\n\tstruct super_block\t*sb,\n\tstruct kqid\t\tqid,\n\tstruct qc_dqblk\t\t*qdq)\n{\n\tstruct xfs_mount\t*mp = XFS_M(sb);\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp))\n\t\treturn -ENOSYS;\n\tif (!XFS_IS_QUOTA_ON(mp))\n\t\treturn -ESRCH;\n\n\treturn xfs_qm_scall_getquota(mp, from_kqid(&init_user_ns, qid),\n\t\t\t\t      xfs_quota_type(qid.type), qdq);\n}",
    "includes": [
      "#include <linux/quota.h>",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_qm_scall_getquota",
          "args": [
            "mp",
            "from_kqid(&init_user_ns, qid)",
            "xfs_quota_type(qid.type)",
            "qdq"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_scall_getquota",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm_syscalls.c",
          "lines": "791-874",
          "snippet": "int\nxfs_qm_scall_getquota(\n\tstruct xfs_mount\t*mp,\n\txfs_dqid_t\t\tid,\n\tuint\t\t\ttype,\n\tstruct qc_dqblk\t\t*dst)\n{\n\tstruct xfs_dquot\t*dqp;\n\tint\t\t\terror;\n\n\t/*\n\t * Try to get the dquot. We don't want it allocated on disk, so\n\t * we aren't passing the XFS_QMOPT_DOALLOC flag. If it doesn't\n\t * exist, we'll get ENOENT back.\n\t */\n\terror = xfs_qm_dqget(mp, NULL, id, type, 0, &dqp);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * If everything's NULL, this dquot doesn't quite exist as far as\n\t * our utility programs are concerned.\n\t */\n\tif (XFS_IS_DQUOT_UNINITIALIZED(dqp)) {\n\t\terror = -ENOENT;\n\t\tgoto out_put;\n\t}\n\n\tmemset(dst, 0, sizeof(*dst));\n\tdst->d_spc_hardlimit =\n\t\tXFS_FSB_TO_B(mp, be64_to_cpu(dqp->q_core.d_blk_hardlimit));\n\tdst->d_spc_softlimit =\n\t\tXFS_FSB_TO_B(mp, be64_to_cpu(dqp->q_core.d_blk_softlimit));\n\tdst->d_ino_hardlimit = be64_to_cpu(dqp->q_core.d_ino_hardlimit);\n\tdst->d_ino_softlimit = be64_to_cpu(dqp->q_core.d_ino_softlimit);\n\tdst->d_space = XFS_FSB_TO_B(mp, dqp->q_res_bcount);\n\tdst->d_ino_count = dqp->q_res_icount;\n\tdst->d_spc_timer = be32_to_cpu(dqp->q_core.d_btimer);\n\tdst->d_ino_timer = be32_to_cpu(dqp->q_core.d_itimer);\n\tdst->d_ino_warns = be16_to_cpu(dqp->q_core.d_iwarns);\n\tdst->d_spc_warns = be16_to_cpu(dqp->q_core.d_bwarns);\n\tdst->d_rt_spc_hardlimit =\n\t\tXFS_FSB_TO_B(mp, be64_to_cpu(dqp->q_core.d_rtb_hardlimit));\n\tdst->d_rt_spc_softlimit =\n\t\tXFS_FSB_TO_B(mp, be64_to_cpu(dqp->q_core.d_rtb_softlimit));\n\tdst->d_rt_space = XFS_FSB_TO_B(mp, dqp->q_res_rtbcount);\n\tdst->d_rt_spc_timer = be32_to_cpu(dqp->q_core.d_rtbtimer);\n\tdst->d_rt_spc_warns = be16_to_cpu(dqp->q_core.d_rtbwarns);\n\n\t/*\n\t * Internally, we don't reset all the timers when quota enforcement\n\t * gets turned off. No need to confuse the user level code,\n\t * so return zeroes in that case.\n\t */\n\tif ((!XFS_IS_UQUOTA_ENFORCED(mp) &&\n\t     dqp->q_core.d_flags == XFS_DQ_USER) ||\n\t    (!XFS_IS_GQUOTA_ENFORCED(mp) &&\n\t     dqp->q_core.d_flags == XFS_DQ_GROUP) ||\n\t    (!XFS_IS_PQUOTA_ENFORCED(mp) &&\n\t     dqp->q_core.d_flags == XFS_DQ_PROJ)) {\n\t\tdst->d_spc_timer = 0;\n\t\tdst->d_ino_timer = 0;\n\t\tdst->d_rt_spc_timer = 0;\n\t}\n\n#ifdef DEBUG\n\tif (((XFS_IS_UQUOTA_ENFORCED(mp) && type == XFS_DQ_USER) ||\n\t     (XFS_IS_GQUOTA_ENFORCED(mp) && type == XFS_DQ_GROUP) ||\n\t     (XFS_IS_PQUOTA_ENFORCED(mp) && type == XFS_DQ_PROJ)) &&\n\t    id != 0) {\n\t\tif ((dst->d_space > dst->d_spc_softlimit) &&\n\t\t    (dst->d_spc_softlimit > 0)) {\n\t\t\tASSERT(dst->d_spc_timer != 0);\n\t\t}\n\t\tif ((dst->d_ino_count > dst->d_ino_softlimit) &&\n\t\t    (dst->d_ino_softlimit > 0)) {\n\t\t\tASSERT(dst->d_ino_timer != 0);\n\t\t}\n\t}\n#endif\nout_put:\n\txfs_qm_dqput(dqp);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\txfs_qm_log_quotaoff(xfs_mount_t *, xfs_qoff_logitem_t **, uint);",
            "STATIC int\txfs_qm_log_quotaoff_end(xfs_mount_t *, xfs_qoff_logitem_t *,\n\t\t\t\t\tuint);",
            "STATIC uint\txfs_qm_export_flags(uint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/capability.h>\n\nSTATIC int\txfs_qm_log_quotaoff(xfs_mount_t *, xfs_qoff_logitem_t **, uint);\nSTATIC int\txfs_qm_log_quotaoff_end(xfs_mount_t *, xfs_qoff_logitem_t *,\n\t\t\t\t\tuint);\nSTATIC uint\txfs_qm_export_flags(uint);\n\nint\nxfs_qm_scall_getquota(\n\tstruct xfs_mount\t*mp,\n\txfs_dqid_t\t\tid,\n\tuint\t\t\ttype,\n\tstruct qc_dqblk\t\t*dst)\n{\n\tstruct xfs_dquot\t*dqp;\n\tint\t\t\terror;\n\n\t/*\n\t * Try to get the dquot. We don't want it allocated on disk, so\n\t * we aren't passing the XFS_QMOPT_DOALLOC flag. If it doesn't\n\t * exist, we'll get ENOENT back.\n\t */\n\terror = xfs_qm_dqget(mp, NULL, id, type, 0, &dqp);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * If everything's NULL, this dquot doesn't quite exist as far as\n\t * our utility programs are concerned.\n\t */\n\tif (XFS_IS_DQUOT_UNINITIALIZED(dqp)) {\n\t\terror = -ENOENT;\n\t\tgoto out_put;\n\t}\n\n\tmemset(dst, 0, sizeof(*dst));\n\tdst->d_spc_hardlimit =\n\t\tXFS_FSB_TO_B(mp, be64_to_cpu(dqp->q_core.d_blk_hardlimit));\n\tdst->d_spc_softlimit =\n\t\tXFS_FSB_TO_B(mp, be64_to_cpu(dqp->q_core.d_blk_softlimit));\n\tdst->d_ino_hardlimit = be64_to_cpu(dqp->q_core.d_ino_hardlimit);\n\tdst->d_ino_softlimit = be64_to_cpu(dqp->q_core.d_ino_softlimit);\n\tdst->d_space = XFS_FSB_TO_B(mp, dqp->q_res_bcount);\n\tdst->d_ino_count = dqp->q_res_icount;\n\tdst->d_spc_timer = be32_to_cpu(dqp->q_core.d_btimer);\n\tdst->d_ino_timer = be32_to_cpu(dqp->q_core.d_itimer);\n\tdst->d_ino_warns = be16_to_cpu(dqp->q_core.d_iwarns);\n\tdst->d_spc_warns = be16_to_cpu(dqp->q_core.d_bwarns);\n\tdst->d_rt_spc_hardlimit =\n\t\tXFS_FSB_TO_B(mp, be64_to_cpu(dqp->q_core.d_rtb_hardlimit));\n\tdst->d_rt_spc_softlimit =\n\t\tXFS_FSB_TO_B(mp, be64_to_cpu(dqp->q_core.d_rtb_softlimit));\n\tdst->d_rt_space = XFS_FSB_TO_B(mp, dqp->q_res_rtbcount);\n\tdst->d_rt_spc_timer = be32_to_cpu(dqp->q_core.d_rtbtimer);\n\tdst->d_rt_spc_warns = be16_to_cpu(dqp->q_core.d_rtbwarns);\n\n\t/*\n\t * Internally, we don't reset all the timers when quota enforcement\n\t * gets turned off. No need to confuse the user level code,\n\t * so return zeroes in that case.\n\t */\n\tif ((!XFS_IS_UQUOTA_ENFORCED(mp) &&\n\t     dqp->q_core.d_flags == XFS_DQ_USER) ||\n\t    (!XFS_IS_GQUOTA_ENFORCED(mp) &&\n\t     dqp->q_core.d_flags == XFS_DQ_GROUP) ||\n\t    (!XFS_IS_PQUOTA_ENFORCED(mp) &&\n\t     dqp->q_core.d_flags == XFS_DQ_PROJ)) {\n\t\tdst->d_spc_timer = 0;\n\t\tdst->d_ino_timer = 0;\n\t\tdst->d_rt_spc_timer = 0;\n\t}\n\n#ifdef DEBUG\n\tif (((XFS_IS_UQUOTA_ENFORCED(mp) && type == XFS_DQ_USER) ||\n\t     (XFS_IS_GQUOTA_ENFORCED(mp) && type == XFS_DQ_GROUP) ||\n\t     (XFS_IS_PQUOTA_ENFORCED(mp) && type == XFS_DQ_PROJ)) &&\n\t    id != 0) {\n\t\tif ((dst->d_space > dst->d_spc_softlimit) &&\n\t\t    (dst->d_spc_softlimit > 0)) {\n\t\t\tASSERT(dst->d_spc_timer != 0);\n\t\t}\n\t\tif ((dst->d_ino_count > dst->d_ino_softlimit) &&\n\t\t    (dst->d_ino_softlimit > 0)) {\n\t\t\tASSERT(dst->d_ino_timer != 0);\n\t\t}\n\t}\n#endif\nout_put:\n\txfs_qm_dqput(dqp);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_quota_type",
          "args": [
            "qid.type"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_quota_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_quotaops.c",
          "lines": "30-41",
          "snippet": "STATIC int\nxfs_quota_type(int type)\n{\n\tswitch (type) {\n\tcase USRQUOTA:\n\t\treturn XFS_DQ_USER;\n\tcase GRPQUOTA:\n\t\treturn XFS_DQ_GROUP;\n\tdefault:\n\t\treturn XFS_DQ_PROJ;\n\t}\n}",
          "includes": [
            "#include <linux/quota.h>",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quota.h>\n#include \"xfs_qm.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_quota_type(int type)\n{\n\tswitch (type) {\n\tcase USRQUOTA:\n\t\treturn XFS_DQ_USER;\n\tcase GRPQUOTA:\n\t\treturn XFS_DQ_GROUP;\n\tdefault:\n\t\treturn XFS_DQ_PROJ;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kqid",
          "args": [
            "&init_user_ns",
            "qid"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "from_kqid_munged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/kqid.c",
          "lines": "100-112",
          "snippet": "qid_t from_kqid_munged(struct user_namespace *targ, struct kqid kqid)\n{\n\tswitch (kqid.type) {\n\tcase USRQUOTA:\n\t\treturn from_kuid_munged(targ, kqid.uid);\n\tcase GRPQUOTA:\n\t\treturn from_kgid_munged(targ, kqid.gid);\n\tcase PRJQUOTA:\n\t\treturn from_kprojid_munged(targ, kqid.projid);\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/quota.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/quota.h>\n#include <linux/fs.h>\n\nqid_t from_kqid_munged(struct user_namespace *targ, struct kqid kqid)\n{\n\tswitch (kqid.type) {\n\tcase USRQUOTA:\n\t\treturn from_kuid_munged(targ, kqid.uid);\n\tcase GRPQUOTA:\n\t\treturn from_kgid_munged(targ, kqid.gid);\n\tcase PRJQUOTA:\n\t\treturn from_kprojid_munged(targ, kqid.projid);\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IS_QUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_QUOTA_RUNNING",
          "args": [
            "mp"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_M",
          "args": [
            "sb"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/quota.h>\n#include \"xfs_qm.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_fs_get_dqblk(\n\tstruct super_block\t*sb,\n\tstruct kqid\t\tqid,\n\tstruct qc_dqblk\t\t*qdq)\n{\n\tstruct xfs_mount\t*mp = XFS_M(sb);\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp))\n\t\treturn -ENOSYS;\n\tif (!XFS_IS_QUOTA_ON(mp))\n\t\treturn -ESRCH;\n\n\treturn xfs_qm_scall_getquota(mp, from_kqid(&init_user_ns, qid),\n\t\t\t\t      xfs_quota_type(qid.type), qdq);\n}"
  },
  {
    "function_name": "xfs_fs_rm_xquota",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_quotaops.c",
    "lines": "120-142",
    "snippet": "STATIC int\nxfs_fs_rm_xquota(\n\tstruct super_block\t*sb,\n\tunsigned int\t\tuflags)\n{\n\tstruct xfs_mount\t*mp = XFS_M(sb);\n\tunsigned int\t\tflags = 0;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn -EROFS;\n\n\tif (XFS_IS_QUOTA_ON(mp))\n\t\treturn -EINVAL;\n\n\tif (uflags & FS_USER_QUOTA)\n\t\tflags |= XFS_DQ_USER;\n\tif (uflags & FS_GROUP_QUOTA)\n\t\tflags |= XFS_DQ_GROUP;\n\tif (uflags & FS_PROJ_QUOTA)\n\t\tflags |= XFS_DQ_PROJ;\n\n\treturn xfs_qm_scall_trunc_qfiles(mp, flags);\n}",
    "includes": [
      "#include <linux/quota.h>",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_qm_scall_trunc_qfiles",
          "args": [
            "mp",
            "flags"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_scall_trunc_qfiles",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm_syscalls.c",
          "lines": "273-301",
          "snippet": "int\nxfs_qm_scall_trunc_qfiles(\n\txfs_mount_t\t*mp,\n\tuint\t\tflags)\n{\n\tint\t\terror = -EINVAL;\n\n\tif (!xfs_sb_version_hasquota(&mp->m_sb) || flags == 0 ||\n\t    (flags & ~XFS_DQ_ALLTYPES)) {\n\t\txfs_debug(mp, \"%s: flags=%x m_qflags=%x\",\n\t\t\t__func__, flags, mp->m_qflags);\n\t\treturn -EINVAL;\n\t}\n\n\tif (flags & XFS_DQ_USER) {\n\t\terror = xfs_qm_scall_trunc_qfile(mp, mp->m_sb.sb_uquotino);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif (flags & XFS_DQ_GROUP) {\n\t\terror = xfs_qm_scall_trunc_qfile(mp, mp->m_sb.sb_gquotino);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif (flags & XFS_DQ_PROJ)\n\t\terror = xfs_qm_scall_trunc_qfile(mp, mp->m_sb.sb_pquotino);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\txfs_qm_log_quotaoff(xfs_mount_t *, xfs_qoff_logitem_t **, uint);",
            "STATIC int\txfs_qm_log_quotaoff_end(xfs_mount_t *, xfs_qoff_logitem_t *,\n\t\t\t\t\tuint);",
            "STATIC uint\txfs_qm_export_flags(uint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/capability.h>\n\nSTATIC int\txfs_qm_log_quotaoff(xfs_mount_t *, xfs_qoff_logitem_t **, uint);\nSTATIC int\txfs_qm_log_quotaoff_end(xfs_mount_t *, xfs_qoff_logitem_t *,\n\t\t\t\t\tuint);\nSTATIC uint\txfs_qm_export_flags(uint);\n\nint\nxfs_qm_scall_trunc_qfiles(\n\txfs_mount_t\t*mp,\n\tuint\t\tflags)\n{\n\tint\t\terror = -EINVAL;\n\n\tif (!xfs_sb_version_hasquota(&mp->m_sb) || flags == 0 ||\n\t    (flags & ~XFS_DQ_ALLTYPES)) {\n\t\txfs_debug(mp, \"%s: flags=%x m_qflags=%x\",\n\t\t\t__func__, flags, mp->m_qflags);\n\t\treturn -EINVAL;\n\t}\n\n\tif (flags & XFS_DQ_USER) {\n\t\terror = xfs_qm_scall_trunc_qfile(mp, mp->m_sb.sb_uquotino);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif (flags & XFS_DQ_GROUP) {\n\t\terror = xfs_qm_scall_trunc_qfile(mp, mp->m_sb.sb_gquotino);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif (flags & XFS_DQ_PROJ)\n\t\terror = xfs_qm_scall_trunc_qfile(mp, mp->m_sb.sb_pquotino);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IS_QUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_M",
          "args": [
            "sb"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/quota.h>\n#include \"xfs_qm.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_fs_rm_xquota(\n\tstruct super_block\t*sb,\n\tunsigned int\t\tuflags)\n{\n\tstruct xfs_mount\t*mp = XFS_M(sb);\n\tunsigned int\t\tflags = 0;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn -EROFS;\n\n\tif (XFS_IS_QUOTA_ON(mp))\n\t\treturn -EINVAL;\n\n\tif (uflags & FS_USER_QUOTA)\n\t\tflags |= XFS_DQ_USER;\n\tif (uflags & FS_GROUP_QUOTA)\n\t\tflags |= XFS_DQ_GROUP;\n\tif (uflags & FS_PROJ_QUOTA)\n\t\tflags |= XFS_DQ_PROJ;\n\n\treturn xfs_qm_scall_trunc_qfiles(mp, flags);\n}"
  },
  {
    "function_name": "xfs_quota_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_quotaops.c",
    "lines": "103-118",
    "snippet": "STATIC int\nxfs_quota_disable(\n\tstruct super_block\t*sb,\n\tunsigned int\t\tuflags)\n{\n\tstruct xfs_mount\t*mp = XFS_M(sb);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn -EROFS;\n\tif (!XFS_IS_QUOTA_RUNNING(mp))\n\t\treturn -ENOSYS;\n\tif (!XFS_IS_QUOTA_ON(mp))\n\t\treturn -EINVAL;\n\n\treturn xfs_qm_scall_quotaoff(mp, xfs_quota_flags(uflags));\n}",
    "includes": [
      "#include <linux/quota.h>",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_qm_scall_quotaoff",
          "args": [
            "mp",
            "xfs_quota_flags(uflags)"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_scall_quotaoff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm_syscalls.c",
          "lines": "51-220",
          "snippet": "int\nxfs_qm_scall_quotaoff(\n\txfs_mount_t\t\t*mp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_quotainfo\t*q = mp->m_quotainfo;\n\tuint\t\t\tdqtype;\n\tint\t\t\terror;\n\tuint\t\t\tinactivate_flags;\n\txfs_qoff_logitem_t\t*qoffstart;\n\n\t/*\n\t * No file system can have quotas enabled on disk but not in core.\n\t * Note that quota utilities (like quotaoff) _expect_\n\t * errno == -EEXIST here.\n\t */\n\tif ((mp->m_qflags & flags) == 0)\n\t\treturn -EEXIST;\n\terror = 0;\n\n\tflags &= (XFS_ALL_QUOTA_ACCT | XFS_ALL_QUOTA_ENFD);\n\n\t/*\n\t * We don't want to deal with two quotaoffs messing up each other,\n\t * so we're going to serialize it. quotaoff isn't exactly a performance\n\t * critical thing.\n\t * If quotaoff, then we must be dealing with the root filesystem.\n\t */\n\tASSERT(q);\n\tmutex_lock(&q->qi_quotaofflock);\n\n\t/*\n\t * If we're just turning off quota enforcement, change mp and go.\n\t */\n\tif ((flags & XFS_ALL_QUOTA_ACCT) == 0) {\n\t\tmp->m_qflags &= ~(flags);\n\n\t\tspin_lock(&mp->m_sb_lock);\n\t\tmp->m_sb.sb_qflags = mp->m_qflags;\n\t\tspin_unlock(&mp->m_sb_lock);\n\t\tmutex_unlock(&q->qi_quotaofflock);\n\n\t\t/* XXX what to do if error ? Revert back to old vals incore ? */\n\t\treturn xfs_sync_sb(mp, false);\n\t}\n\n\tdqtype = 0;\n\tinactivate_flags = 0;\n\t/*\n\t * If accounting is off, we must turn enforcement off, clear the\n\t * quota 'CHKD' certificate to make it known that we have to\n\t * do a quotacheck the next time this quota is turned on.\n\t */\n\tif (flags & XFS_UQUOTA_ACCT) {\n\t\tdqtype |= XFS_QMOPT_UQUOTA;\n\t\tflags |= (XFS_UQUOTA_CHKD | XFS_UQUOTA_ENFD);\n\t\tinactivate_flags |= XFS_UQUOTA_ACTIVE;\n\t}\n\tif (flags & XFS_GQUOTA_ACCT) {\n\t\tdqtype |= XFS_QMOPT_GQUOTA;\n\t\tflags |= (XFS_GQUOTA_CHKD | XFS_GQUOTA_ENFD);\n\t\tinactivate_flags |= XFS_GQUOTA_ACTIVE;\n\t}\n\tif (flags & XFS_PQUOTA_ACCT) {\n\t\tdqtype |= XFS_QMOPT_PQUOTA;\n\t\tflags |= (XFS_PQUOTA_CHKD | XFS_PQUOTA_ENFD);\n\t\tinactivate_flags |= XFS_PQUOTA_ACTIVE;\n\t}\n\n\t/*\n\t * Nothing to do?  Don't complain. This happens when we're just\n\t * turning off quota enforcement.\n\t */\n\tif ((mp->m_qflags & flags) == 0)\n\t\tgoto out_unlock;\n\n\t/*\n\t * Write the LI_QUOTAOFF log record, and do SB changes atomically,\n\t * and synchronously. If we fail to write, we should abort the\n\t * operation as it cannot be recovered safely if we crash.\n\t */\n\terror = xfs_qm_log_quotaoff(mp, &qoffstart, flags);\n\tif (error)\n\t\tgoto out_unlock;\n\n\t/*\n\t * Next we clear the XFS_MOUNT_*DQ_ACTIVE bit(s) in the mount struct\n\t * to take care of the race between dqget and quotaoff. We don't take\n\t * any special locks to reset these bits. All processes need to check\n\t * these bits *after* taking inode lock(s) to see if the particular\n\t * quota type is in the process of being turned off. If *ACTIVE, it is\n\t * guaranteed that all dquot structures and all quotainode ptrs will all\n\t * stay valid as long as that inode is kept locked.\n\t *\n\t * There is no turning back after this.\n\t */\n\tmp->m_qflags &= ~inactivate_flags;\n\n\t/*\n\t * Give back all the dquot reference(s) held by inodes.\n\t * Here we go thru every single incore inode in this file system, and\n\t * do a dqrele on the i_udquot/i_gdquot that it may have.\n\t * Essentially, as long as somebody has an inode locked, this guarantees\n\t * that quotas will not be turned off. This is handy because in a\n\t * transaction once we lock the inode(s) and check for quotaon, we can\n\t * depend on the quota inodes (and other things) being valid as long as\n\t * we keep the lock(s).\n\t */\n\txfs_qm_dqrele_all_inodes(mp, flags);\n\n\t/*\n\t * Next we make the changes in the quota flag in the mount struct.\n\t * This isn't protected by a particular lock directly, because we\n\t * don't want to take a mrlock every time we depend on quotas being on.\n\t */\n\tmp->m_qflags &= ~flags;\n\n\t/*\n\t * Go through all the dquots of this file system and purge them,\n\t * according to what was turned off.\n\t */\n\txfs_qm_dqpurge_all(mp, dqtype);\n\n\t/*\n\t * Transactions that had started before ACTIVE state bit was cleared\n\t * could have logged many dquots, so they'd have higher LSNs than\n\t * the first QUOTAOFF log record does. If we happen to crash when\n\t * the tail of the log has gone past the QUOTAOFF record, but\n\t * before the last dquot modification, those dquots __will__\n\t * recover, and that's not good.\n\t *\n\t * So, we have QUOTAOFF start and end logitems; the start\n\t * logitem won't get overwritten until the end logitem appears...\n\t */\n\terror = xfs_qm_log_quotaoff_end(mp, qoffstart, flags);\n\tif (error) {\n\t\t/* We're screwed now. Shutdown is the only option. */\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * If all quotas are completely turned off, close shop.\n\t */\n\tif (mp->m_qflags == 0) {\n\t\tmutex_unlock(&q->qi_quotaofflock);\n\t\txfs_qm_destroy_quotainfo(mp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Release our quotainode references if we don't need them anymore.\n\t */\n\tif ((dqtype & XFS_QMOPT_UQUOTA) && q->qi_uquotaip) {\n\t\tIRELE(q->qi_uquotaip);\n\t\tq->qi_uquotaip = NULL;\n\t}\n\tif ((dqtype & XFS_QMOPT_GQUOTA) && q->qi_gquotaip) {\n\t\tIRELE(q->qi_gquotaip);\n\t\tq->qi_gquotaip = NULL;\n\t}\n\tif ((dqtype & XFS_QMOPT_PQUOTA) && q->qi_pquotaip) {\n\t\tIRELE(q->qi_pquotaip);\n\t\tq->qi_pquotaip = NULL;\n\t}\n\nout_unlock:\n\tmutex_unlock(&q->qi_quotaofflock);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\txfs_qm_log_quotaoff(xfs_mount_t *, xfs_qoff_logitem_t **, uint);",
            "STATIC int\txfs_qm_log_quotaoff_end(xfs_mount_t *, xfs_qoff_logitem_t *,\n\t\t\t\t\tuint);",
            "STATIC uint\txfs_qm_export_flags(uint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/capability.h>\n\nSTATIC int\txfs_qm_log_quotaoff(xfs_mount_t *, xfs_qoff_logitem_t **, uint);\nSTATIC int\txfs_qm_log_quotaoff_end(xfs_mount_t *, xfs_qoff_logitem_t *,\n\t\t\t\t\tuint);\nSTATIC uint\txfs_qm_export_flags(uint);\n\nint\nxfs_qm_scall_quotaoff(\n\txfs_mount_t\t\t*mp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_quotainfo\t*q = mp->m_quotainfo;\n\tuint\t\t\tdqtype;\n\tint\t\t\terror;\n\tuint\t\t\tinactivate_flags;\n\txfs_qoff_logitem_t\t*qoffstart;\n\n\t/*\n\t * No file system can have quotas enabled on disk but not in core.\n\t * Note that quota utilities (like quotaoff) _expect_\n\t * errno == -EEXIST here.\n\t */\n\tif ((mp->m_qflags & flags) == 0)\n\t\treturn -EEXIST;\n\terror = 0;\n\n\tflags &= (XFS_ALL_QUOTA_ACCT | XFS_ALL_QUOTA_ENFD);\n\n\t/*\n\t * We don't want to deal with two quotaoffs messing up each other,\n\t * so we're going to serialize it. quotaoff isn't exactly a performance\n\t * critical thing.\n\t * If quotaoff, then we must be dealing with the root filesystem.\n\t */\n\tASSERT(q);\n\tmutex_lock(&q->qi_quotaofflock);\n\n\t/*\n\t * If we're just turning off quota enforcement, change mp and go.\n\t */\n\tif ((flags & XFS_ALL_QUOTA_ACCT) == 0) {\n\t\tmp->m_qflags &= ~(flags);\n\n\t\tspin_lock(&mp->m_sb_lock);\n\t\tmp->m_sb.sb_qflags = mp->m_qflags;\n\t\tspin_unlock(&mp->m_sb_lock);\n\t\tmutex_unlock(&q->qi_quotaofflock);\n\n\t\t/* XXX what to do if error ? Revert back to old vals incore ? */\n\t\treturn xfs_sync_sb(mp, false);\n\t}\n\n\tdqtype = 0;\n\tinactivate_flags = 0;\n\t/*\n\t * If accounting is off, we must turn enforcement off, clear the\n\t * quota 'CHKD' certificate to make it known that we have to\n\t * do a quotacheck the next time this quota is turned on.\n\t */\n\tif (flags & XFS_UQUOTA_ACCT) {\n\t\tdqtype |= XFS_QMOPT_UQUOTA;\n\t\tflags |= (XFS_UQUOTA_CHKD | XFS_UQUOTA_ENFD);\n\t\tinactivate_flags |= XFS_UQUOTA_ACTIVE;\n\t}\n\tif (flags & XFS_GQUOTA_ACCT) {\n\t\tdqtype |= XFS_QMOPT_GQUOTA;\n\t\tflags |= (XFS_GQUOTA_CHKD | XFS_GQUOTA_ENFD);\n\t\tinactivate_flags |= XFS_GQUOTA_ACTIVE;\n\t}\n\tif (flags & XFS_PQUOTA_ACCT) {\n\t\tdqtype |= XFS_QMOPT_PQUOTA;\n\t\tflags |= (XFS_PQUOTA_CHKD | XFS_PQUOTA_ENFD);\n\t\tinactivate_flags |= XFS_PQUOTA_ACTIVE;\n\t}\n\n\t/*\n\t * Nothing to do?  Don't complain. This happens when we're just\n\t * turning off quota enforcement.\n\t */\n\tif ((mp->m_qflags & flags) == 0)\n\t\tgoto out_unlock;\n\n\t/*\n\t * Write the LI_QUOTAOFF log record, and do SB changes atomically,\n\t * and synchronously. If we fail to write, we should abort the\n\t * operation as it cannot be recovered safely if we crash.\n\t */\n\terror = xfs_qm_log_quotaoff(mp, &qoffstart, flags);\n\tif (error)\n\t\tgoto out_unlock;\n\n\t/*\n\t * Next we clear the XFS_MOUNT_*DQ_ACTIVE bit(s) in the mount struct\n\t * to take care of the race between dqget and quotaoff. We don't take\n\t * any special locks to reset these bits. All processes need to check\n\t * these bits *after* taking inode lock(s) to see if the particular\n\t * quota type is in the process of being turned off. If *ACTIVE, it is\n\t * guaranteed that all dquot structures and all quotainode ptrs will all\n\t * stay valid as long as that inode is kept locked.\n\t *\n\t * There is no turning back after this.\n\t */\n\tmp->m_qflags &= ~inactivate_flags;\n\n\t/*\n\t * Give back all the dquot reference(s) held by inodes.\n\t * Here we go thru every single incore inode in this file system, and\n\t * do a dqrele on the i_udquot/i_gdquot that it may have.\n\t * Essentially, as long as somebody has an inode locked, this guarantees\n\t * that quotas will not be turned off. This is handy because in a\n\t * transaction once we lock the inode(s) and check for quotaon, we can\n\t * depend on the quota inodes (and other things) being valid as long as\n\t * we keep the lock(s).\n\t */\n\txfs_qm_dqrele_all_inodes(mp, flags);\n\n\t/*\n\t * Next we make the changes in the quota flag in the mount struct.\n\t * This isn't protected by a particular lock directly, because we\n\t * don't want to take a mrlock every time we depend on quotas being on.\n\t */\n\tmp->m_qflags &= ~flags;\n\n\t/*\n\t * Go through all the dquots of this file system and purge them,\n\t * according to what was turned off.\n\t */\n\txfs_qm_dqpurge_all(mp, dqtype);\n\n\t/*\n\t * Transactions that had started before ACTIVE state bit was cleared\n\t * could have logged many dquots, so they'd have higher LSNs than\n\t * the first QUOTAOFF log record does. If we happen to crash when\n\t * the tail of the log has gone past the QUOTAOFF record, but\n\t * before the last dquot modification, those dquots __will__\n\t * recover, and that's not good.\n\t *\n\t * So, we have QUOTAOFF start and end logitems; the start\n\t * logitem won't get overwritten until the end logitem appears...\n\t */\n\terror = xfs_qm_log_quotaoff_end(mp, qoffstart, flags);\n\tif (error) {\n\t\t/* We're screwed now. Shutdown is the only option. */\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * If all quotas are completely turned off, close shop.\n\t */\n\tif (mp->m_qflags == 0) {\n\t\tmutex_unlock(&q->qi_quotaofflock);\n\t\txfs_qm_destroy_quotainfo(mp);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Release our quotainode references if we don't need them anymore.\n\t */\n\tif ((dqtype & XFS_QMOPT_UQUOTA) && q->qi_uquotaip) {\n\t\tIRELE(q->qi_uquotaip);\n\t\tq->qi_uquotaip = NULL;\n\t}\n\tif ((dqtype & XFS_QMOPT_GQUOTA) && q->qi_gquotaip) {\n\t\tIRELE(q->qi_gquotaip);\n\t\tq->qi_gquotaip = NULL;\n\t}\n\tif ((dqtype & XFS_QMOPT_PQUOTA) && q->qi_pquotaip) {\n\t\tIRELE(q->qi_pquotaip);\n\t\tq->qi_pquotaip = NULL;\n\t}\n\nout_unlock:\n\tmutex_unlock(&q->qi_quotaofflock);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_quota_flags",
          "args": [
            "uflags"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_quota_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_quotaops.c",
          "lines": "67-86",
          "snippet": "static unsigned int\nxfs_quota_flags(unsigned int uflags)\n{\n\tunsigned int flags = 0;\n\n\tif (uflags & FS_QUOTA_UDQ_ACCT)\n\t\tflags |= XFS_UQUOTA_ACCT;\n\tif (uflags & FS_QUOTA_PDQ_ACCT)\n\t\tflags |= XFS_PQUOTA_ACCT;\n\tif (uflags & FS_QUOTA_GDQ_ACCT)\n\t\tflags |= XFS_GQUOTA_ACCT;\n\tif (uflags & FS_QUOTA_UDQ_ENFD)\n\t\tflags |= XFS_UQUOTA_ENFD;\n\tif (uflags & FS_QUOTA_GDQ_ENFD)\n\t\tflags |= XFS_GQUOTA_ENFD;\n\tif (uflags & FS_QUOTA_PDQ_ENFD)\n\t\tflags |= XFS_PQUOTA_ENFD;\n\n\treturn flags;\n}",
          "includes": [
            "#include <linux/quota.h>",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quota.h>\n#include \"xfs_qm.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nstatic unsigned int\nxfs_quota_flags(unsigned int uflags)\n{\n\tunsigned int flags = 0;\n\n\tif (uflags & FS_QUOTA_UDQ_ACCT)\n\t\tflags |= XFS_UQUOTA_ACCT;\n\tif (uflags & FS_QUOTA_PDQ_ACCT)\n\t\tflags |= XFS_PQUOTA_ACCT;\n\tif (uflags & FS_QUOTA_GDQ_ACCT)\n\t\tflags |= XFS_GQUOTA_ACCT;\n\tif (uflags & FS_QUOTA_UDQ_ENFD)\n\t\tflags |= XFS_UQUOTA_ENFD;\n\tif (uflags & FS_QUOTA_GDQ_ENFD)\n\t\tflags |= XFS_GQUOTA_ENFD;\n\tif (uflags & FS_QUOTA_PDQ_ENFD)\n\t\tflags |= XFS_PQUOTA_ENFD;\n\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IS_QUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_QUOTA_RUNNING",
          "args": [
            "mp"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_M",
          "args": [
            "sb"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/quota.h>\n#include \"xfs_qm.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_quota_disable(\n\tstruct super_block\t*sb,\n\tunsigned int\t\tuflags)\n{\n\tstruct xfs_mount\t*mp = XFS_M(sb);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn -EROFS;\n\tif (!XFS_IS_QUOTA_RUNNING(mp))\n\t\treturn -ENOSYS;\n\tif (!XFS_IS_QUOTA_ON(mp))\n\t\treturn -EINVAL;\n\n\treturn xfs_qm_scall_quotaoff(mp, xfs_quota_flags(uflags));\n}"
  },
  {
    "function_name": "xfs_quota_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_quotaops.c",
    "lines": "88-101",
    "snippet": "STATIC int\nxfs_quota_enable(\n\tstruct super_block\t*sb,\n\tunsigned int\t\tuflags)\n{\n\tstruct xfs_mount\t*mp = XFS_M(sb);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn -EROFS;\n\tif (!XFS_IS_QUOTA_RUNNING(mp))\n\t\treturn -ENOSYS;\n\n\treturn xfs_qm_scall_quotaon(mp, xfs_quota_flags(uflags));\n}",
    "includes": [
      "#include <linux/quota.h>",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_qm_scall_quotaon",
          "args": [
            "mp",
            "xfs_quota_flags(uflags)"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_scall_quotaon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm_syscalls.c",
          "lines": "308-390",
          "snippet": "int\nxfs_qm_scall_quotaon(\n\txfs_mount_t\t*mp,\n\tuint\t\tflags)\n{\n\tint\t\terror;\n\tuint\t\tqf;\n\n\tflags &= (XFS_ALL_QUOTA_ACCT | XFS_ALL_QUOTA_ENFD);\n\t/*\n\t * Switching on quota accounting must be done at mount time.\n\t */\n\tflags &= ~(XFS_ALL_QUOTA_ACCT);\n\n\tif (flags == 0) {\n\t\txfs_debug(mp, \"%s: zero flags, m_qflags=%x\",\n\t\t\t__func__, mp->m_qflags);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Can't enforce without accounting. We check the superblock\n\t * qflags here instead of m_qflags because rootfs can have\n\t * quota acct on ondisk without m_qflags' knowing.\n\t */\n\tif (((mp->m_sb.sb_qflags & XFS_UQUOTA_ACCT) == 0 &&\n\t     (flags & XFS_UQUOTA_ENFD)) ||\n\t    ((mp->m_sb.sb_qflags & XFS_GQUOTA_ACCT) == 0 &&\n\t     (flags & XFS_GQUOTA_ENFD)) ||\n\t    ((mp->m_sb.sb_qflags & XFS_PQUOTA_ACCT) == 0 &&\n\t     (flags & XFS_PQUOTA_ENFD))) {\n\t\txfs_debug(mp,\n\t\t\t\"%s: Can't enforce without acct, flags=%x sbflags=%x\",\n\t\t\t__func__, flags, mp->m_sb.sb_qflags);\n\t\treturn -EINVAL;\n\t}\n\t/*\n\t * If everything's up to-date incore, then don't waste time.\n\t */\n\tif ((mp->m_qflags & flags) == flags)\n\t\treturn -EEXIST;\n\n\t/*\n\t * Change sb_qflags on disk but not incore mp->qflags\n\t * if this is the root filesystem.\n\t */\n\tspin_lock(&mp->m_sb_lock);\n\tqf = mp->m_sb.sb_qflags;\n\tmp->m_sb.sb_qflags = qf | flags;\n\tspin_unlock(&mp->m_sb_lock);\n\n\t/*\n\t * There's nothing to change if it's the same.\n\t */\n\tif ((qf & flags) == flags)\n\t\treturn -EEXIST;\n\n\terror = xfs_sync_sb(mp, false);\n\tif (error)\n\t\treturn error;\n\t/*\n\t * If we aren't trying to switch on quota enforcement, we are done.\n\t */\n\tif  (((mp->m_sb.sb_qflags & XFS_UQUOTA_ACCT) !=\n\t     (mp->m_qflags & XFS_UQUOTA_ACCT)) ||\n\t     ((mp->m_sb.sb_qflags & XFS_PQUOTA_ACCT) !=\n\t     (mp->m_qflags & XFS_PQUOTA_ACCT)) ||\n\t     ((mp->m_sb.sb_qflags & XFS_GQUOTA_ACCT) !=\n\t     (mp->m_qflags & XFS_GQUOTA_ACCT)))\n\t\treturn 0;\n\n\tif (! XFS_IS_QUOTA_RUNNING(mp))\n\t\treturn -ESRCH;\n\n\t/*\n\t * Switch on quota enforcement in core.\n\t */\n\tmutex_lock(&mp->m_quotainfo->qi_quotaofflock);\n\tmp->m_qflags |= (flags & XFS_ALL_QUOTA_ENFD);\n\tmutex_unlock(&mp->m_quotainfo->qi_quotaofflock);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int\txfs_qm_log_quotaoff(xfs_mount_t *, xfs_qoff_logitem_t **, uint);",
            "STATIC int\txfs_qm_log_quotaoff_end(xfs_mount_t *, xfs_qoff_logitem_t *,\n\t\t\t\t\tuint);",
            "STATIC uint\txfs_qm_export_flags(uint);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/capability.h>\n\nSTATIC int\txfs_qm_log_quotaoff(xfs_mount_t *, xfs_qoff_logitem_t **, uint);\nSTATIC int\txfs_qm_log_quotaoff_end(xfs_mount_t *, xfs_qoff_logitem_t *,\n\t\t\t\t\tuint);\nSTATIC uint\txfs_qm_export_flags(uint);\n\nint\nxfs_qm_scall_quotaon(\n\txfs_mount_t\t*mp,\n\tuint\t\tflags)\n{\n\tint\t\terror;\n\tuint\t\tqf;\n\n\tflags &= (XFS_ALL_QUOTA_ACCT | XFS_ALL_QUOTA_ENFD);\n\t/*\n\t * Switching on quota accounting must be done at mount time.\n\t */\n\tflags &= ~(XFS_ALL_QUOTA_ACCT);\n\n\tif (flags == 0) {\n\t\txfs_debug(mp, \"%s: zero flags, m_qflags=%x\",\n\t\t\t__func__, mp->m_qflags);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Can't enforce without accounting. We check the superblock\n\t * qflags here instead of m_qflags because rootfs can have\n\t * quota acct on ondisk without m_qflags' knowing.\n\t */\n\tif (((mp->m_sb.sb_qflags & XFS_UQUOTA_ACCT) == 0 &&\n\t     (flags & XFS_UQUOTA_ENFD)) ||\n\t    ((mp->m_sb.sb_qflags & XFS_GQUOTA_ACCT) == 0 &&\n\t     (flags & XFS_GQUOTA_ENFD)) ||\n\t    ((mp->m_sb.sb_qflags & XFS_PQUOTA_ACCT) == 0 &&\n\t     (flags & XFS_PQUOTA_ENFD))) {\n\t\txfs_debug(mp,\n\t\t\t\"%s: Can't enforce without acct, flags=%x sbflags=%x\",\n\t\t\t__func__, flags, mp->m_sb.sb_qflags);\n\t\treturn -EINVAL;\n\t}\n\t/*\n\t * If everything's up to-date incore, then don't waste time.\n\t */\n\tif ((mp->m_qflags & flags) == flags)\n\t\treturn -EEXIST;\n\n\t/*\n\t * Change sb_qflags on disk but not incore mp->qflags\n\t * if this is the root filesystem.\n\t */\n\tspin_lock(&mp->m_sb_lock);\n\tqf = mp->m_sb.sb_qflags;\n\tmp->m_sb.sb_qflags = qf | flags;\n\tspin_unlock(&mp->m_sb_lock);\n\n\t/*\n\t * There's nothing to change if it's the same.\n\t */\n\tif ((qf & flags) == flags)\n\t\treturn -EEXIST;\n\n\terror = xfs_sync_sb(mp, false);\n\tif (error)\n\t\treturn error;\n\t/*\n\t * If we aren't trying to switch on quota enforcement, we are done.\n\t */\n\tif  (((mp->m_sb.sb_qflags & XFS_UQUOTA_ACCT) !=\n\t     (mp->m_qflags & XFS_UQUOTA_ACCT)) ||\n\t     ((mp->m_sb.sb_qflags & XFS_PQUOTA_ACCT) !=\n\t     (mp->m_qflags & XFS_PQUOTA_ACCT)) ||\n\t     ((mp->m_sb.sb_qflags & XFS_GQUOTA_ACCT) !=\n\t     (mp->m_qflags & XFS_GQUOTA_ACCT)))\n\t\treturn 0;\n\n\tif (! XFS_IS_QUOTA_RUNNING(mp))\n\t\treturn -ESRCH;\n\n\t/*\n\t * Switch on quota enforcement in core.\n\t */\n\tmutex_lock(&mp->m_quotainfo->qi_quotaofflock);\n\tmp->m_qflags |= (flags & XFS_ALL_QUOTA_ENFD);\n\tmutex_unlock(&mp->m_quotainfo->qi_quotaofflock);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_quota_flags",
          "args": [
            "uflags"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_quota_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_quotaops.c",
          "lines": "67-86",
          "snippet": "static unsigned int\nxfs_quota_flags(unsigned int uflags)\n{\n\tunsigned int flags = 0;\n\n\tif (uflags & FS_QUOTA_UDQ_ACCT)\n\t\tflags |= XFS_UQUOTA_ACCT;\n\tif (uflags & FS_QUOTA_PDQ_ACCT)\n\t\tflags |= XFS_PQUOTA_ACCT;\n\tif (uflags & FS_QUOTA_GDQ_ACCT)\n\t\tflags |= XFS_GQUOTA_ACCT;\n\tif (uflags & FS_QUOTA_UDQ_ENFD)\n\t\tflags |= XFS_UQUOTA_ENFD;\n\tif (uflags & FS_QUOTA_GDQ_ENFD)\n\t\tflags |= XFS_GQUOTA_ENFD;\n\tif (uflags & FS_QUOTA_PDQ_ENFD)\n\t\tflags |= XFS_PQUOTA_ENFD;\n\n\treturn flags;\n}",
          "includes": [
            "#include <linux/quota.h>",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quota.h>\n#include \"xfs_qm.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nstatic unsigned int\nxfs_quota_flags(unsigned int uflags)\n{\n\tunsigned int flags = 0;\n\n\tif (uflags & FS_QUOTA_UDQ_ACCT)\n\t\tflags |= XFS_UQUOTA_ACCT;\n\tif (uflags & FS_QUOTA_PDQ_ACCT)\n\t\tflags |= XFS_PQUOTA_ACCT;\n\tif (uflags & FS_QUOTA_GDQ_ACCT)\n\t\tflags |= XFS_GQUOTA_ACCT;\n\tif (uflags & FS_QUOTA_UDQ_ENFD)\n\t\tflags |= XFS_UQUOTA_ENFD;\n\tif (uflags & FS_QUOTA_GDQ_ENFD)\n\t\tflags |= XFS_GQUOTA_ENFD;\n\tif (uflags & FS_QUOTA_PDQ_ENFD)\n\t\tflags |= XFS_PQUOTA_ENFD;\n\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IS_QUOTA_RUNNING",
          "args": [
            "mp"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_M",
          "args": [
            "sb"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/quota.h>\n#include \"xfs_qm.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_quota_enable(\n\tstruct super_block\t*sb,\n\tunsigned int\t\tuflags)\n{\n\tstruct xfs_mount\t*mp = XFS_M(sb);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn -EROFS;\n\tif (!XFS_IS_QUOTA_RUNNING(mp))\n\t\treturn -ENOSYS;\n\n\treturn xfs_qm_scall_quotaon(mp, xfs_quota_flags(uflags));\n}"
  },
  {
    "function_name": "xfs_quota_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_quotaops.c",
    "lines": "67-86",
    "snippet": "static unsigned int\nxfs_quota_flags(unsigned int uflags)\n{\n\tunsigned int flags = 0;\n\n\tif (uflags & FS_QUOTA_UDQ_ACCT)\n\t\tflags |= XFS_UQUOTA_ACCT;\n\tif (uflags & FS_QUOTA_PDQ_ACCT)\n\t\tflags |= XFS_PQUOTA_ACCT;\n\tif (uflags & FS_QUOTA_GDQ_ACCT)\n\t\tflags |= XFS_GQUOTA_ACCT;\n\tif (uflags & FS_QUOTA_UDQ_ENFD)\n\t\tflags |= XFS_UQUOTA_ENFD;\n\tif (uflags & FS_QUOTA_GDQ_ENFD)\n\t\tflags |= XFS_GQUOTA_ENFD;\n\tif (uflags & FS_QUOTA_PDQ_ENFD)\n\t\tflags |= XFS_PQUOTA_ENFD;\n\n\treturn flags;\n}",
    "includes": [
      "#include <linux/quota.h>",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/quota.h>\n#include \"xfs_qm.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nstatic unsigned int\nxfs_quota_flags(unsigned int uflags)\n{\n\tunsigned int flags = 0;\n\n\tif (uflags & FS_QUOTA_UDQ_ACCT)\n\t\tflags |= XFS_UQUOTA_ACCT;\n\tif (uflags & FS_QUOTA_PDQ_ACCT)\n\t\tflags |= XFS_PQUOTA_ACCT;\n\tif (uflags & FS_QUOTA_GDQ_ACCT)\n\t\tflags |= XFS_GQUOTA_ACCT;\n\tif (uflags & FS_QUOTA_UDQ_ENFD)\n\t\tflags |= XFS_UQUOTA_ENFD;\n\tif (uflags & FS_QUOTA_GDQ_ENFD)\n\t\tflags |= XFS_GQUOTA_ENFD;\n\tif (uflags & FS_QUOTA_PDQ_ENFD)\n\t\tflags |= XFS_PQUOTA_ENFD;\n\n\treturn flags;\n}"
  },
  {
    "function_name": "xfs_fs_get_xstatev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_quotaops.c",
    "lines": "55-65",
    "snippet": "STATIC int\nxfs_fs_get_xstatev(\n\tstruct super_block\t*sb,\n\tstruct fs_quota_statv\t*fqs)\n{\n\tstruct xfs_mount\t*mp = XFS_M(sb);\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp))\n\t\treturn -ENOSYS;\n\treturn xfs_qm_scall_getqstatv(mp, fqs);\n}",
    "includes": [
      "#include <linux/quota.h>",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_qm_scall_getqstatv",
          "args": [
            "mp",
            "fqs"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_scall_getqstatv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm_syscalls.c",
          "lines": "478-543",
          "snippet": "int\nxfs_qm_scall_getqstatv(\n\tstruct xfs_mount\t*mp,\n\tstruct fs_quota_statv\t*out)\n{\n\tstruct xfs_quotainfo\t*q = mp->m_quotainfo;\n\tstruct xfs_inode\t*uip = NULL;\n\tstruct xfs_inode\t*gip = NULL;\n\tstruct xfs_inode\t*pip = NULL;\n\tbool                    tempuqip = false;\n\tbool                    tempgqip = false;\n\tbool                    temppqip = false;\n\n\tout->qs_flags = (__uint16_t) xfs_qm_export_flags(mp->m_qflags &\n\t\t\t\t\t\t\t(XFS_ALL_QUOTA_ACCT|\n\t\t\t\t\t\t\t XFS_ALL_QUOTA_ENFD));\n\tout->qs_uquota.qfs_ino = mp->m_sb.sb_uquotino;\n\tout->qs_gquota.qfs_ino = mp->m_sb.sb_gquotino;\n\tout->qs_pquota.qfs_ino = mp->m_sb.sb_pquotino;\n\n\tuip = q->qi_uquotaip;\n\tgip = q->qi_gquotaip;\n\tpip = q->qi_pquotaip;\n\tif (!uip && mp->m_sb.sb_uquotino != NULLFSINO) {\n\t\tif (xfs_iget(mp, NULL, mp->m_sb.sb_uquotino,\n\t\t\t\t\t0, 0, &uip) == 0)\n\t\t\ttempuqip = true;\n\t}\n\tif (!gip && mp->m_sb.sb_gquotino != NULLFSINO) {\n\t\tif (xfs_iget(mp, NULL, mp->m_sb.sb_gquotino,\n\t\t\t\t\t0, 0, &gip) == 0)\n\t\t\ttempgqip = true;\n\t}\n\tif (!pip && mp->m_sb.sb_pquotino != NULLFSINO) {\n\t\tif (xfs_iget(mp, NULL, mp->m_sb.sb_pquotino,\n\t\t\t\t\t0, 0, &pip) == 0)\n\t\t\ttemppqip = true;\n\t}\n\tif (uip) {\n\t\tout->qs_uquota.qfs_nblks = uip->i_d.di_nblocks;\n\t\tout->qs_uquota.qfs_nextents = uip->i_d.di_nextents;\n\t\tif (tempuqip)\n\t\t\tIRELE(uip);\n\t}\n\n\tif (gip) {\n\t\tout->qs_gquota.qfs_nblks = gip->i_d.di_nblocks;\n\t\tout->qs_gquota.qfs_nextents = gip->i_d.di_nextents;\n\t\tif (tempgqip)\n\t\t\tIRELE(gip);\n\t}\n\tif (pip) {\n\t\tout->qs_pquota.qfs_nblks = pip->i_d.di_nblocks;\n\t\tout->qs_pquota.qfs_nextents = pip->i_d.di_nextents;\n\t\tif (temppqip)\n\t\t\tIRELE(pip);\n\t}\n\tout->qs_incoredqs = q->qi_dquots;\n\tout->qs_btimelimit = q->qi_btimelimit;\n\tout->qs_itimelimit = q->qi_itimelimit;\n\tout->qs_rtbtimelimit = q->qi_rtbtimelimit;\n\tout->qs_bwarnlimit = q->qi_bwarnlimit;\n\tout->qs_iwarnlimit = q->qi_iwarnlimit;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/capability.h>\n\nint\nxfs_qm_scall_getqstatv(\n\tstruct xfs_mount\t*mp,\n\tstruct fs_quota_statv\t*out)\n{\n\tstruct xfs_quotainfo\t*q = mp->m_quotainfo;\n\tstruct xfs_inode\t*uip = NULL;\n\tstruct xfs_inode\t*gip = NULL;\n\tstruct xfs_inode\t*pip = NULL;\n\tbool                    tempuqip = false;\n\tbool                    tempgqip = false;\n\tbool                    temppqip = false;\n\n\tout->qs_flags = (__uint16_t) xfs_qm_export_flags(mp->m_qflags &\n\t\t\t\t\t\t\t(XFS_ALL_QUOTA_ACCT|\n\t\t\t\t\t\t\t XFS_ALL_QUOTA_ENFD));\n\tout->qs_uquota.qfs_ino = mp->m_sb.sb_uquotino;\n\tout->qs_gquota.qfs_ino = mp->m_sb.sb_gquotino;\n\tout->qs_pquota.qfs_ino = mp->m_sb.sb_pquotino;\n\n\tuip = q->qi_uquotaip;\n\tgip = q->qi_gquotaip;\n\tpip = q->qi_pquotaip;\n\tif (!uip && mp->m_sb.sb_uquotino != NULLFSINO) {\n\t\tif (xfs_iget(mp, NULL, mp->m_sb.sb_uquotino,\n\t\t\t\t\t0, 0, &uip) == 0)\n\t\t\ttempuqip = true;\n\t}\n\tif (!gip && mp->m_sb.sb_gquotino != NULLFSINO) {\n\t\tif (xfs_iget(mp, NULL, mp->m_sb.sb_gquotino,\n\t\t\t\t\t0, 0, &gip) == 0)\n\t\t\ttempgqip = true;\n\t}\n\tif (!pip && mp->m_sb.sb_pquotino != NULLFSINO) {\n\t\tif (xfs_iget(mp, NULL, mp->m_sb.sb_pquotino,\n\t\t\t\t\t0, 0, &pip) == 0)\n\t\t\ttemppqip = true;\n\t}\n\tif (uip) {\n\t\tout->qs_uquota.qfs_nblks = uip->i_d.di_nblocks;\n\t\tout->qs_uquota.qfs_nextents = uip->i_d.di_nextents;\n\t\tif (tempuqip)\n\t\t\tIRELE(uip);\n\t}\n\n\tif (gip) {\n\t\tout->qs_gquota.qfs_nblks = gip->i_d.di_nblocks;\n\t\tout->qs_gquota.qfs_nextents = gip->i_d.di_nextents;\n\t\tif (tempgqip)\n\t\t\tIRELE(gip);\n\t}\n\tif (pip) {\n\t\tout->qs_pquota.qfs_nblks = pip->i_d.di_nblocks;\n\t\tout->qs_pquota.qfs_nextents = pip->i_d.di_nextents;\n\t\tif (temppqip)\n\t\t\tIRELE(pip);\n\t}\n\tout->qs_incoredqs = q->qi_dquots;\n\tout->qs_btimelimit = q->qi_btimelimit;\n\tout->qs_itimelimit = q->qi_itimelimit;\n\tout->qs_rtbtimelimit = q->qi_rtbtimelimit;\n\tout->qs_bwarnlimit = q->qi_bwarnlimit;\n\tout->qs_iwarnlimit = q->qi_iwarnlimit;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IS_QUOTA_RUNNING",
          "args": [
            "mp"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_M",
          "args": [
            "sb"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/quota.h>\n#include \"xfs_qm.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_fs_get_xstatev(\n\tstruct super_block\t*sb,\n\tstruct fs_quota_statv\t*fqs)\n{\n\tstruct xfs_mount\t*mp = XFS_M(sb);\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp))\n\t\treturn -ENOSYS;\n\treturn xfs_qm_scall_getqstatv(mp, fqs);\n}"
  },
  {
    "function_name": "xfs_fs_get_xstate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_quotaops.c",
    "lines": "43-53",
    "snippet": "STATIC int\nxfs_fs_get_xstate(\n\tstruct super_block\t*sb,\n\tstruct fs_quota_stat\t*fqs)\n{\n\tstruct xfs_mount\t*mp = XFS_M(sb);\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp))\n\t\treturn -ENOSYS;\n\treturn xfs_qm_scall_getqstat(mp, fqs);\n}",
    "includes": [
      "#include <linux/quota.h>",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_qm_scall_getqstat",
          "args": [
            "mp",
            "fqs"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_scall_getqstatv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm_syscalls.c",
          "lines": "478-543",
          "snippet": "int\nxfs_qm_scall_getqstatv(\n\tstruct xfs_mount\t*mp,\n\tstruct fs_quota_statv\t*out)\n{\n\tstruct xfs_quotainfo\t*q = mp->m_quotainfo;\n\tstruct xfs_inode\t*uip = NULL;\n\tstruct xfs_inode\t*gip = NULL;\n\tstruct xfs_inode\t*pip = NULL;\n\tbool                    tempuqip = false;\n\tbool                    tempgqip = false;\n\tbool                    temppqip = false;\n\n\tout->qs_flags = (__uint16_t) xfs_qm_export_flags(mp->m_qflags &\n\t\t\t\t\t\t\t(XFS_ALL_QUOTA_ACCT|\n\t\t\t\t\t\t\t XFS_ALL_QUOTA_ENFD));\n\tout->qs_uquota.qfs_ino = mp->m_sb.sb_uquotino;\n\tout->qs_gquota.qfs_ino = mp->m_sb.sb_gquotino;\n\tout->qs_pquota.qfs_ino = mp->m_sb.sb_pquotino;\n\n\tuip = q->qi_uquotaip;\n\tgip = q->qi_gquotaip;\n\tpip = q->qi_pquotaip;\n\tif (!uip && mp->m_sb.sb_uquotino != NULLFSINO) {\n\t\tif (xfs_iget(mp, NULL, mp->m_sb.sb_uquotino,\n\t\t\t\t\t0, 0, &uip) == 0)\n\t\t\ttempuqip = true;\n\t}\n\tif (!gip && mp->m_sb.sb_gquotino != NULLFSINO) {\n\t\tif (xfs_iget(mp, NULL, mp->m_sb.sb_gquotino,\n\t\t\t\t\t0, 0, &gip) == 0)\n\t\t\ttempgqip = true;\n\t}\n\tif (!pip && mp->m_sb.sb_pquotino != NULLFSINO) {\n\t\tif (xfs_iget(mp, NULL, mp->m_sb.sb_pquotino,\n\t\t\t\t\t0, 0, &pip) == 0)\n\t\t\ttemppqip = true;\n\t}\n\tif (uip) {\n\t\tout->qs_uquota.qfs_nblks = uip->i_d.di_nblocks;\n\t\tout->qs_uquota.qfs_nextents = uip->i_d.di_nextents;\n\t\tif (tempuqip)\n\t\t\tIRELE(uip);\n\t}\n\n\tif (gip) {\n\t\tout->qs_gquota.qfs_nblks = gip->i_d.di_nblocks;\n\t\tout->qs_gquota.qfs_nextents = gip->i_d.di_nextents;\n\t\tif (tempgqip)\n\t\t\tIRELE(gip);\n\t}\n\tif (pip) {\n\t\tout->qs_pquota.qfs_nblks = pip->i_d.di_nblocks;\n\t\tout->qs_pquota.qfs_nextents = pip->i_d.di_nextents;\n\t\tif (temppqip)\n\t\t\tIRELE(pip);\n\t}\n\tout->qs_incoredqs = q->qi_dquots;\n\tout->qs_btimelimit = q->qi_btimelimit;\n\tout->qs_itimelimit = q->qi_itimelimit;\n\tout->qs_rtbtimelimit = q->qi_rtbtimelimit;\n\tout->qs_bwarnlimit = q->qi_bwarnlimit;\n\tout->qs_iwarnlimit = q->qi_iwarnlimit;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/capability.h>\n\nint\nxfs_qm_scall_getqstatv(\n\tstruct xfs_mount\t*mp,\n\tstruct fs_quota_statv\t*out)\n{\n\tstruct xfs_quotainfo\t*q = mp->m_quotainfo;\n\tstruct xfs_inode\t*uip = NULL;\n\tstruct xfs_inode\t*gip = NULL;\n\tstruct xfs_inode\t*pip = NULL;\n\tbool                    tempuqip = false;\n\tbool                    tempgqip = false;\n\tbool                    temppqip = false;\n\n\tout->qs_flags = (__uint16_t) xfs_qm_export_flags(mp->m_qflags &\n\t\t\t\t\t\t\t(XFS_ALL_QUOTA_ACCT|\n\t\t\t\t\t\t\t XFS_ALL_QUOTA_ENFD));\n\tout->qs_uquota.qfs_ino = mp->m_sb.sb_uquotino;\n\tout->qs_gquota.qfs_ino = mp->m_sb.sb_gquotino;\n\tout->qs_pquota.qfs_ino = mp->m_sb.sb_pquotino;\n\n\tuip = q->qi_uquotaip;\n\tgip = q->qi_gquotaip;\n\tpip = q->qi_pquotaip;\n\tif (!uip && mp->m_sb.sb_uquotino != NULLFSINO) {\n\t\tif (xfs_iget(mp, NULL, mp->m_sb.sb_uquotino,\n\t\t\t\t\t0, 0, &uip) == 0)\n\t\t\ttempuqip = true;\n\t}\n\tif (!gip && mp->m_sb.sb_gquotino != NULLFSINO) {\n\t\tif (xfs_iget(mp, NULL, mp->m_sb.sb_gquotino,\n\t\t\t\t\t0, 0, &gip) == 0)\n\t\t\ttempgqip = true;\n\t}\n\tif (!pip && mp->m_sb.sb_pquotino != NULLFSINO) {\n\t\tif (xfs_iget(mp, NULL, mp->m_sb.sb_pquotino,\n\t\t\t\t\t0, 0, &pip) == 0)\n\t\t\ttemppqip = true;\n\t}\n\tif (uip) {\n\t\tout->qs_uquota.qfs_nblks = uip->i_d.di_nblocks;\n\t\tout->qs_uquota.qfs_nextents = uip->i_d.di_nextents;\n\t\tif (tempuqip)\n\t\t\tIRELE(uip);\n\t}\n\n\tif (gip) {\n\t\tout->qs_gquota.qfs_nblks = gip->i_d.di_nblocks;\n\t\tout->qs_gquota.qfs_nextents = gip->i_d.di_nextents;\n\t\tif (tempgqip)\n\t\t\tIRELE(gip);\n\t}\n\tif (pip) {\n\t\tout->qs_pquota.qfs_nblks = pip->i_d.di_nblocks;\n\t\tout->qs_pquota.qfs_nextents = pip->i_d.di_nextents;\n\t\tif (temppqip)\n\t\t\tIRELE(pip);\n\t}\n\tout->qs_incoredqs = q->qi_dquots;\n\tout->qs_btimelimit = q->qi_btimelimit;\n\tout->qs_itimelimit = q->qi_itimelimit;\n\tout->qs_rtbtimelimit = q->qi_rtbtimelimit;\n\tout->qs_bwarnlimit = q->qi_bwarnlimit;\n\tout->qs_iwarnlimit = q->qi_iwarnlimit;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IS_QUOTA_RUNNING",
          "args": [
            "mp"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_M",
          "args": [
            "sb"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/quota.h>\n#include \"xfs_qm.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_fs_get_xstate(\n\tstruct super_block\t*sb,\n\tstruct fs_quota_stat\t*fqs)\n{\n\tstruct xfs_mount\t*mp = XFS_M(sb);\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp))\n\t\treturn -ENOSYS;\n\treturn xfs_qm_scall_getqstat(mp, fqs);\n}"
  },
  {
    "function_name": "xfs_quota_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_quotaops.c",
    "lines": "30-41",
    "snippet": "STATIC int\nxfs_quota_type(int type)\n{\n\tswitch (type) {\n\tcase USRQUOTA:\n\t\treturn XFS_DQ_USER;\n\tcase GRPQUOTA:\n\t\treturn XFS_DQ_GROUP;\n\tdefault:\n\t\treturn XFS_DQ_PROJ;\n\t}\n}",
    "includes": [
      "#include <linux/quota.h>",
      "#include \"xfs_qm.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/quota.h>\n#include \"xfs_qm.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_quota_type(int type)\n{\n\tswitch (type) {\n\tcase USRQUOTA:\n\t\treturn XFS_DQ_USER;\n\tcase GRPQUOTA:\n\t\treturn XFS_DQ_GROUP;\n\tdefault:\n\t\treturn XFS_DQ_PROJ;\n\t}\n}"
  }
]