[
  {
    "function_name": "hfsplus_file_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/extents.c",
    "lines": "531-611",
    "snippet": "void hfsplus_file_truncate(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tstruct hfs_find_data fd;\n\tu32 alloc_cnt, blk_cnt, start;\n\tint res;\n\n\thfs_dbg(INODE, \"truncate: %lu, %llu -> %llu\\n\",\n\t\tinode->i_ino, (long long)hip->phys_size, inode->i_size);\n\n\tif (inode->i_size > hip->phys_size) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tstruct page *page;\n\t\tvoid *fsdata;\n\t\tloff_t size = inode->i_size;\n\n\t\tres = pagecache_write_begin(NULL, mapping, size, 0,\n\t\t\t\t\t\tAOP_FLAG_UNINTERRUPTIBLE,\n\t\t\t\t\t\t&page, &fsdata);\n\t\tif (res)\n\t\t\treturn;\n\t\tres = pagecache_write_end(NULL, mapping, size,\n\t\t\t0, 0, page, fsdata);\n\t\tif (res < 0)\n\t\t\treturn;\n\t\tmark_inode_dirty(inode);\n\t\treturn;\n\t} else if (inode->i_size == hip->phys_size)\n\t\treturn;\n\n\tblk_cnt = (inode->i_size + HFSPLUS_SB(sb)->alloc_blksz - 1) >>\n\t\t\tHFSPLUS_SB(sb)->alloc_blksz_shift;\n\n\tmutex_lock(&hip->extents_lock);\n\n\talloc_cnt = hip->alloc_blocks;\n\tif (blk_cnt == alloc_cnt)\n\t\tgoto out_unlock;\n\n\tres = hfs_find_init(HFSPLUS_SB(sb)->ext_tree, &fd);\n\tif (res) {\n\t\tmutex_unlock(&hip->extents_lock);\n\t\t/* XXX: We lack error handling of hfsplus_file_truncate() */\n\t\treturn;\n\t}\n\twhile (1) {\n\t\tif (alloc_cnt == hip->first_blocks) {\n\t\t\thfsplus_free_extents(sb, hip->first_extents,\n\t\t\t\t\t     alloc_cnt, alloc_cnt - blk_cnt);\n\t\t\thfsplus_dump_extent(hip->first_extents);\n\t\t\thip->first_blocks = blk_cnt;\n\t\t\tbreak;\n\t\t}\n\t\tres = __hfsplus_ext_cache_extent(&fd, inode, alloc_cnt);\n\t\tif (res)\n\t\t\tbreak;\n\t\tstart = hip->cached_start;\n\t\thfsplus_free_extents(sb, hip->cached_extents,\n\t\t\t\t     alloc_cnt - start, alloc_cnt - blk_cnt);\n\t\thfsplus_dump_extent(hip->cached_extents);\n\t\tif (blk_cnt > start) {\n\t\t\thip->extent_state |= HFSPLUS_EXT_DIRTY;\n\t\t\tbreak;\n\t\t}\n\t\talloc_cnt = start;\n\t\thip->cached_start = hip->cached_blocks = 0;\n\t\thip->extent_state &= ~(HFSPLUS_EXT_DIRTY | HFSPLUS_EXT_NEW);\n\t\thfs_brec_remove(&fd);\n\t}\n\thfs_find_exit(&fd);\n\n\thip->alloc_blocks = blk_cnt;\nout_unlock:\n\tmutex_unlock(&hip->extents_lock);\n\thip->phys_size = inode->i_size;\n\thip->fs_blocks = (inode->i_size + sb->s_blocksize - 1) >>\n\t\tsb->s_blocksize_bits;\n\tinode_set_bytes(inode, hip->fs_blocks << sb->s_blocksize_bits);\n\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_ALLOC_DIRTY);\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfsplus_mark_inode_dirty",
          "args": [
            "inode",
            "HFSPLUS_I_ALLOC_DIRTY"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "275-280",
          "snippet": "static inline void hfsplus_mark_inode_dirty(struct inode *inode,\n\t\tunsigned int flag)\n{\n\tset_bit(flag, &HFSPLUS_I(inode)->flags);\n\tmark_inode_dirty(inode);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline void hfsplus_mark_inode_dirty(struct inode *inode,\n\t\tunsigned int flag)\n{\n\tset_bit(flag, &HFSPLUS_I(inode)->flags);\n\tmark_inode_dirty(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_set_bytes",
          "args": [
            "inode",
            "hip->fs_blocks << sb->s_blocksize_bits"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "inode_set_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "503-509",
          "snippet": "void inode_set_bytes(struct inode *inode, loff_t bytes)\n{\n\t/* Caller is here responsible for sufficient locking\n\t * (ie. inode->i_lock) */\n\tinode->i_blocks = bytes >> 9;\n\tinode->i_bytes = bytes & 511;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid inode_set_bytes(struct inode *inode, loff_t bytes)\n{\n\t/* Caller is here responsible for sufficient locking\n\t * (ie. inode->i_lock) */\n\tinode->i_blocks = bytes >> 9;\n\tinode->i_bytes = bytes & 511;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&hip->extents_lock"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_find_exit",
          "args": [
            "&fd"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "43-51",
          "snippet": "void hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nvoid hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_brec_remove",
          "args": [
            "&fd"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/brec.c",
          "lines": "177-231",
          "snippet": "int hfs_brec_remove(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *parent;\n\tint end_off, rec_off, data_off, size;\n\n\ttree = fd->tree;\n\tnode = fd->bnode;\nagain:\n\trec_off = tree->node_size - (fd->record + 2) * 2;\n\tend_off = tree->node_size - (node->num_recs + 1) * 2;\n\n\tif (node->type == HFS_NODE_LEAF) {\n\t\ttree->leaf_count--;\n\t\tmark_inode_dirty(tree->inode);\n\t}\n\thfs_bnode_dump(node);\n\thfs_dbg(BNODE_MOD, \"remove_rec: %d, %d\\n\",\n\t\tfd->record, fd->keylength + fd->entrylength);\n\tif (!--node->num_recs) {\n\t\thfs_bnode_unlink(node);\n\t\tif (!node->parent)\n\t\t\treturn 0;\n\t\tparent = hfs_bnode_find(tree, node->parent);\n\t\tif (IS_ERR(parent))\n\t\t\treturn PTR_ERR(parent);\n\t\thfs_bnode_put(node);\n\t\tnode = fd->bnode = parent;\n\n\t\t__hfs_brec_find(node, fd, hfs_find_rec_by_key);\n\t\tgoto again;\n\t}\n\thfs_bnode_write_u16(node,\n\t\toffsetof(struct hfs_bnode_desc, num_recs),\n\t\tnode->num_recs);\n\n\tif (rec_off == end_off)\n\t\tgoto skip;\n\tsize = fd->keylength + fd->entrylength;\n\n\tdo {\n\t\tdata_off = hfs_bnode_read_u16(node, rec_off);\n\t\thfs_bnode_write_u16(node, rec_off + 2, data_off - size);\n\t\trec_off -= 2;\n\t} while (rec_off >= end_off);\n\n\t/* fill hole */\n\thfs_bnode_move(node, fd->keyoffset, fd->keyoffset + size,\n\t\t       data_off - fd->keyoffset - size);\nskip:\n\thfs_bnode_dump(node);\n\tif (!fd->record)\n\t\thfs_brec_update_parent(fd);\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd);",
            "static int hfs_brec_update_parent(struct hfs_find_data *fd);",
            "static int hfs_btree_inc_height(struct hfs_btree *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd);\nstatic int hfs_brec_update_parent(struct hfs_find_data *fd);\nstatic int hfs_btree_inc_height(struct hfs_btree *);\n\nint hfs_brec_remove(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *parent;\n\tint end_off, rec_off, data_off, size;\n\n\ttree = fd->tree;\n\tnode = fd->bnode;\nagain:\n\trec_off = tree->node_size - (fd->record + 2) * 2;\n\tend_off = tree->node_size - (node->num_recs + 1) * 2;\n\n\tif (node->type == HFS_NODE_LEAF) {\n\t\ttree->leaf_count--;\n\t\tmark_inode_dirty(tree->inode);\n\t}\n\thfs_bnode_dump(node);\n\thfs_dbg(BNODE_MOD, \"remove_rec: %d, %d\\n\",\n\t\tfd->record, fd->keylength + fd->entrylength);\n\tif (!--node->num_recs) {\n\t\thfs_bnode_unlink(node);\n\t\tif (!node->parent)\n\t\t\treturn 0;\n\t\tparent = hfs_bnode_find(tree, node->parent);\n\t\tif (IS_ERR(parent))\n\t\t\treturn PTR_ERR(parent);\n\t\thfs_bnode_put(node);\n\t\tnode = fd->bnode = parent;\n\n\t\t__hfs_brec_find(node, fd, hfs_find_rec_by_key);\n\t\tgoto again;\n\t}\n\thfs_bnode_write_u16(node,\n\t\toffsetof(struct hfs_bnode_desc, num_recs),\n\t\tnode->num_recs);\n\n\tif (rec_off == end_off)\n\t\tgoto skip;\n\tsize = fd->keylength + fd->entrylength;\n\n\tdo {\n\t\tdata_off = hfs_bnode_read_u16(node, rec_off);\n\t\thfs_bnode_write_u16(node, rec_off + 2, data_off - size);\n\t\trec_off -= 2;\n\t} while (rec_off >= end_off);\n\n\t/* fill hole */\n\thfs_bnode_move(node, fd->keyoffset, fd->keyoffset + size,\n\t\t       data_off - fd->keyoffset - size);\nskip:\n\thfs_bnode_dump(node);\n\tif (!fd->record)\n\t\thfs_brec_update_parent(fd);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_dump_extent",
          "args": [
            "hip->cached_extents"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_dump_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/extents.c",
          "lines": "290-300",
          "snippet": "static void hfsplus_dump_extent(struct hfsplus_extent *extent)\n{\n\tint i;\n\n\thfs_dbg(EXTENT, \"   \");\n\tfor (i = 0; i < 8; i++)\n\t\thfs_dbg_cont(EXTENT, \" %u:%u\",\n\t\t\t     be32_to_cpu(extent[i].start_block),\n\t\t\t     be32_to_cpu(extent[i].block_count));\n\thfs_dbg_cont(EXTENT, \"\\n\");\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic void hfsplus_dump_extent(struct hfsplus_extent *extent)\n{\n\tint i;\n\n\thfs_dbg(EXTENT, \"   \");\n\tfor (i = 0; i < 8; i++)\n\t\thfs_dbg_cont(EXTENT, \" %u:%u\",\n\t\t\t     be32_to_cpu(extent[i].start_block),\n\t\t\t     be32_to_cpu(extent[i].block_count));\n\thfs_dbg_cont(EXTENT, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_free_extents",
          "args": [
            "sb",
            "hip->cached_extents",
            "alloc_cnt - start",
            "alloc_cnt - blk_cnt"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_free_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/extents.c",
          "lines": "330-384",
          "snippet": "static int hfsplus_free_extents(struct super_block *sb,\n\t\t\t\tstruct hfsplus_extent *extent,\n\t\t\t\tu32 offset, u32 block_nr)\n{\n\tu32 count, start;\n\tint i;\n\tint err = 0;\n\n\thfsplus_dump_extent(extent);\n\tfor (i = 0; i < 8; extent++, i++) {\n\t\tcount = be32_to_cpu(extent->block_count);\n\t\tif (offset == count)\n\t\t\tgoto found;\n\t\telse if (offset < count)\n\t\t\tbreak;\n\t\toffset -= count;\n\t}\n\t/* panic? */\n\treturn -EIO;\nfound:\n\tfor (;;) {\n\t\tstart = be32_to_cpu(extent->start_block);\n\t\tif (count <= block_nr) {\n\t\t\terr = hfsplus_block_free(sb, start, count);\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"can't free extent\\n\");\n\t\t\t\thfs_dbg(EXTENT, \" start: %u count: %u\\n\",\n\t\t\t\t\tstart, count);\n\t\t\t}\n\t\t\textent->block_count = 0;\n\t\t\textent->start_block = 0;\n\t\t\tblock_nr -= count;\n\t\t} else {\n\t\t\tcount -= block_nr;\n\t\t\terr = hfsplus_block_free(sb, start + count, block_nr);\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"can't free extent\\n\");\n\t\t\t\thfs_dbg(EXTENT, \" start: %u count: %u\\n\",\n\t\t\t\t\tstart, count);\n\t\t\t}\n\t\t\textent->block_count = cpu_to_be32(count);\n\t\t\tblock_nr = 0;\n\t\t}\n\t\tif (!block_nr || !i) {\n\t\t\t/*\n\t\t\t * Try to free all extents and\n\t\t\t * return only last error\n\t\t\t */\n\t\t\treturn err;\n\t\t}\n\t\ti--;\n\t\textent--;\n\t\tcount = be32_to_cpu(extent->block_count);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int hfsplus_free_extents(struct super_block *sb,\n\t\t\t\tstruct hfsplus_extent *extent,\n\t\t\t\tu32 offset, u32 block_nr)\n{\n\tu32 count, start;\n\tint i;\n\tint err = 0;\n\n\thfsplus_dump_extent(extent);\n\tfor (i = 0; i < 8; extent++, i++) {\n\t\tcount = be32_to_cpu(extent->block_count);\n\t\tif (offset == count)\n\t\t\tgoto found;\n\t\telse if (offset < count)\n\t\t\tbreak;\n\t\toffset -= count;\n\t}\n\t/* panic? */\n\treturn -EIO;\nfound:\n\tfor (;;) {\n\t\tstart = be32_to_cpu(extent->start_block);\n\t\tif (count <= block_nr) {\n\t\t\terr = hfsplus_block_free(sb, start, count);\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"can't free extent\\n\");\n\t\t\t\thfs_dbg(EXTENT, \" start: %u count: %u\\n\",\n\t\t\t\t\tstart, count);\n\t\t\t}\n\t\t\textent->block_count = 0;\n\t\t\textent->start_block = 0;\n\t\t\tblock_nr -= count;\n\t\t} else {\n\t\t\tcount -= block_nr;\n\t\t\terr = hfsplus_block_free(sb, start + count, block_nr);\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"can't free extent\\n\");\n\t\t\t\thfs_dbg(EXTENT, \" start: %u count: %u\\n\",\n\t\t\t\t\tstart, count);\n\t\t\t}\n\t\t\textent->block_count = cpu_to_be32(count);\n\t\t\tblock_nr = 0;\n\t\t}\n\t\tif (!block_nr || !i) {\n\t\t\t/*\n\t\t\t * Try to free all extents and\n\t\t\t * return only last error\n\t\t\t */\n\t\t\treturn err;\n\t\t}\n\t\ti--;\n\t\textent--;\n\t\tcount = be32_to_cpu(extent->block_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__hfsplus_ext_cache_extent",
          "args": [
            "&fd",
            "inode",
            "alloc_cnt"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "__hfsplus_ext_cache_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/extents.c",
          "lines": "172-199",
          "snippet": "static inline int __hfsplus_ext_cache_extent(struct hfs_find_data *fd,\n\t\tstruct inode *inode, u32 block)\n{\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tint res;\n\n\tWARN_ON(!mutex_is_locked(&hip->extents_lock));\n\n\tif (hip->extent_state & HFSPLUS_EXT_DIRTY) {\n\t\tres = __hfsplus_ext_write_extent(inode, fd);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\tres = __hfsplus_ext_read_extent(fd, hip->cached_extents, inode->i_ino,\n\t\t\t\t\tblock, HFSPLUS_IS_RSRC(inode) ?\n\t\t\t\t\t\tHFSPLUS_TYPE_RSRC :\n\t\t\t\t\t\tHFSPLUS_TYPE_DATA);\n\tif (!res) {\n\t\thip->cached_start = be32_to_cpu(fd->key->ext.start_block);\n\t\thip->cached_blocks =\n\t\t\thfsplus_ext_block_count(hip->cached_extents);\n\t} else {\n\t\thip->cached_start = hip->cached_blocks = 0;\n\t\thip->extent_state &= ~(HFSPLUS_EXT_DIRTY | HFSPLUS_EXT_NEW);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic inline int __hfsplus_ext_cache_extent(struct hfs_find_data *fd,\n\t\tstruct inode *inode, u32 block)\n{\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tint res;\n\n\tWARN_ON(!mutex_is_locked(&hip->extents_lock));\n\n\tif (hip->extent_state & HFSPLUS_EXT_DIRTY) {\n\t\tres = __hfsplus_ext_write_extent(inode, fd);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\tres = __hfsplus_ext_read_extent(fd, hip->cached_extents, inode->i_ino,\n\t\t\t\t\tblock, HFSPLUS_IS_RSRC(inode) ?\n\t\t\t\t\t\tHFSPLUS_TYPE_RSRC :\n\t\t\t\t\t\tHFSPLUS_TYPE_DATA);\n\tif (!res) {\n\t\thip->cached_start = be32_to_cpu(fd->key->ext.start_block);\n\t\thip->cached_blocks =\n\t\t\thfsplus_ext_block_count(hip->cached_extents);\n\t} else {\n\t\thip->cached_start = hip->cached_blocks = 0;\n\t\thip->extent_state &= ~(HFSPLUS_EXT_DIRTY | HFSPLUS_EXT_NEW);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&hip->extents_lock"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_find_init",
          "args": [
            "HFSPLUS_SB(sb)->ext_tree",
            "&fd"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "14-41",
          "snippet": "int hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tswitch (tree->cnid) {\n\tcase HFSPLUS_CAT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, CATALOG_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_EXT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, EXTENTS_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, ATTR_BTREE_MUTEX);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nint hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tswitch (tree->cnid) {\n\tcase HFSPLUS_CAT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, CATALOG_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_EXT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, EXTENTS_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, ATTR_BTREE_MUTEX);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "sb"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&hip->extents_lock"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pagecache_write_end",
          "args": [
            "NULL",
            "mapping",
            "size",
            "0",
            "0",
            "page",
            "fsdata"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pagecache_write_begin",
          "args": [
            "NULL",
            "mapping",
            "size",
            "0",
            "AOP_FLAG_UNINTERRUPTIBLE",
            "&page",
            "&fsdata"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_dbg",
          "args": [
            "INODE",
            "\"truncate: %lu, %llu -> %llu\\n\"",
            "inode->i_ino",
            "(long long)hip->phys_size",
            "inode->i_size"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFSPLUS_I",
          "args": [
            "inode"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "264-267",
          "snippet": "static inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nvoid hfsplus_file_truncate(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tstruct hfs_find_data fd;\n\tu32 alloc_cnt, blk_cnt, start;\n\tint res;\n\n\thfs_dbg(INODE, \"truncate: %lu, %llu -> %llu\\n\",\n\t\tinode->i_ino, (long long)hip->phys_size, inode->i_size);\n\n\tif (inode->i_size > hip->phys_size) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tstruct page *page;\n\t\tvoid *fsdata;\n\t\tloff_t size = inode->i_size;\n\n\t\tres = pagecache_write_begin(NULL, mapping, size, 0,\n\t\t\t\t\t\tAOP_FLAG_UNINTERRUPTIBLE,\n\t\t\t\t\t\t&page, &fsdata);\n\t\tif (res)\n\t\t\treturn;\n\t\tres = pagecache_write_end(NULL, mapping, size,\n\t\t\t0, 0, page, fsdata);\n\t\tif (res < 0)\n\t\t\treturn;\n\t\tmark_inode_dirty(inode);\n\t\treturn;\n\t} else if (inode->i_size == hip->phys_size)\n\t\treturn;\n\n\tblk_cnt = (inode->i_size + HFSPLUS_SB(sb)->alloc_blksz - 1) >>\n\t\t\tHFSPLUS_SB(sb)->alloc_blksz_shift;\n\n\tmutex_lock(&hip->extents_lock);\n\n\talloc_cnt = hip->alloc_blocks;\n\tif (blk_cnt == alloc_cnt)\n\t\tgoto out_unlock;\n\n\tres = hfs_find_init(HFSPLUS_SB(sb)->ext_tree, &fd);\n\tif (res) {\n\t\tmutex_unlock(&hip->extents_lock);\n\t\t/* XXX: We lack error handling of hfsplus_file_truncate() */\n\t\treturn;\n\t}\n\twhile (1) {\n\t\tif (alloc_cnt == hip->first_blocks) {\n\t\t\thfsplus_free_extents(sb, hip->first_extents,\n\t\t\t\t\t     alloc_cnt, alloc_cnt - blk_cnt);\n\t\t\thfsplus_dump_extent(hip->first_extents);\n\t\t\thip->first_blocks = blk_cnt;\n\t\t\tbreak;\n\t\t}\n\t\tres = __hfsplus_ext_cache_extent(&fd, inode, alloc_cnt);\n\t\tif (res)\n\t\t\tbreak;\n\t\tstart = hip->cached_start;\n\t\thfsplus_free_extents(sb, hip->cached_extents,\n\t\t\t\t     alloc_cnt - start, alloc_cnt - blk_cnt);\n\t\thfsplus_dump_extent(hip->cached_extents);\n\t\tif (blk_cnt > start) {\n\t\t\thip->extent_state |= HFSPLUS_EXT_DIRTY;\n\t\t\tbreak;\n\t\t}\n\t\talloc_cnt = start;\n\t\thip->cached_start = hip->cached_blocks = 0;\n\t\thip->extent_state &= ~(HFSPLUS_EXT_DIRTY | HFSPLUS_EXT_NEW);\n\t\thfs_brec_remove(&fd);\n\t}\n\thfs_find_exit(&fd);\n\n\thip->alloc_blocks = blk_cnt;\nout_unlock:\n\tmutex_unlock(&hip->extents_lock);\n\thip->phys_size = inode->i_size;\n\thip->fs_blocks = (inode->i_size + sb->s_blocksize - 1) >>\n\t\tsb->s_blocksize_bits;\n\tinode_set_bytes(inode, hip->fs_blocks << sb->s_blocksize_bits);\n\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_ALLOC_DIRTY);\n}"
  },
  {
    "function_name": "hfsplus_file_extend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/extents.c",
    "lines": "428-529",
    "snippet": "int hfsplus_file_extend(struct inode *inode, bool zeroout)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tu32 start, len, goal;\n\tint res;\n\n\tif (sbi->alloc_file->i_size * 8 <\n\t    sbi->total_blocks - sbi->free_blocks + 8) {\n\t\t/* extend alloc file */\n\t\tpr_err(\"extend alloc file! (%llu,%u,%u)\\n\",\n\t\t       sbi->alloc_file->i_size * 8,\n\t\t       sbi->total_blocks, sbi->free_blocks);\n\t\treturn -ENOSPC;\n\t}\n\n\tmutex_lock(&hip->extents_lock);\n\tif (hip->alloc_blocks == hip->first_blocks)\n\t\tgoal = hfsplus_ext_lastblock(hip->first_extents);\n\telse {\n\t\tres = hfsplus_ext_read_extent(inode, hip->alloc_blocks);\n\t\tif (res)\n\t\t\tgoto out;\n\t\tgoal = hfsplus_ext_lastblock(hip->cached_extents);\n\t}\n\n\tlen = hip->clump_blocks;\n\tstart = hfsplus_block_allocate(sb, sbi->total_blocks, goal, &len);\n\tif (start >= sbi->total_blocks) {\n\t\tstart = hfsplus_block_allocate(sb, goal, 0, &len);\n\t\tif (start >= goal) {\n\t\t\tres = -ENOSPC;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (zeroout) {\n\t\tres = sb_issue_zeroout(sb, start, len, GFP_NOFS);\n\t\tif (res)\n\t\t\tgoto out;\n\t}\n\n\thfs_dbg(EXTENT, \"extend %lu: %u,%u\\n\", inode->i_ino, start, len);\n\n\tif (hip->alloc_blocks <= hip->first_blocks) {\n\t\tif (!hip->first_blocks) {\n\t\t\thfs_dbg(EXTENT, \"first extents\\n\");\n\t\t\t/* no extents yet */\n\t\t\thip->first_extents[0].start_block = cpu_to_be32(start);\n\t\t\thip->first_extents[0].block_count = cpu_to_be32(len);\n\t\t\tres = 0;\n\t\t} else {\n\t\t\t/* try to append to extents in inode */\n\t\t\tres = hfsplus_add_extent(hip->first_extents,\n\t\t\t\t\t\t hip->alloc_blocks,\n\t\t\t\t\t\t start, len);\n\t\t\tif (res == -ENOSPC)\n\t\t\t\tgoto insert_extent;\n\t\t}\n\t\tif (!res) {\n\t\t\thfsplus_dump_extent(hip->first_extents);\n\t\t\thip->first_blocks += len;\n\t\t}\n\t} else {\n\t\tres = hfsplus_add_extent(hip->cached_extents,\n\t\t\t\t\t hip->alloc_blocks - hip->cached_start,\n\t\t\t\t\t start, len);\n\t\tif (!res) {\n\t\t\thfsplus_dump_extent(hip->cached_extents);\n\t\t\thip->extent_state |= HFSPLUS_EXT_DIRTY;\n\t\t\thip->cached_blocks += len;\n\t\t} else if (res == -ENOSPC)\n\t\t\tgoto insert_extent;\n\t}\nout:\n\tif (!res) {\n\t\thip->alloc_blocks += len;\n\t\tmutex_unlock(&hip->extents_lock);\n\t\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_ALLOC_DIRTY);\n\t\treturn 0;\n\t}\n\tmutex_unlock(&hip->extents_lock);\n\treturn res;\n\ninsert_extent:\n\thfs_dbg(EXTENT, \"insert new extent\\n\");\n\tres = hfsplus_ext_write_extent_locked(inode);\n\tif (res)\n\t\tgoto out;\n\n\tmemset(hip->cached_extents, 0, sizeof(hfsplus_extent_rec));\n\thip->cached_extents[0].start_block = cpu_to_be32(start);\n\thip->cached_extents[0].block_count = cpu_to_be32(len);\n\thfsplus_dump_extent(hip->cached_extents);\n\thip->extent_state |= HFSPLUS_EXT_DIRTY | HFSPLUS_EXT_NEW;\n\thip->cached_start = hip->alloc_blocks;\n\thip->cached_blocks = len;\n\n\tres = 0;\n\tgoto out;\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfsplus_dump_extent",
          "args": [
            "hip->cached_extents"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_dump_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/extents.c",
          "lines": "290-300",
          "snippet": "static void hfsplus_dump_extent(struct hfsplus_extent *extent)\n{\n\tint i;\n\n\thfs_dbg(EXTENT, \"   \");\n\tfor (i = 0; i < 8; i++)\n\t\thfs_dbg_cont(EXTENT, \" %u:%u\",\n\t\t\t     be32_to_cpu(extent[i].start_block),\n\t\t\t     be32_to_cpu(extent[i].block_count));\n\thfs_dbg_cont(EXTENT, \"\\n\");\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic void hfsplus_dump_extent(struct hfsplus_extent *extent)\n{\n\tint i;\n\n\thfs_dbg(EXTENT, \"   \");\n\tfor (i = 0; i < 8; i++)\n\t\thfs_dbg_cont(EXTENT, \" %u:%u\",\n\t\t\t     be32_to_cpu(extent[i].start_block),\n\t\t\t     be32_to_cpu(extent[i].block_count));\n\thfs_dbg_cont(EXTENT, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "len"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "start"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "hip->cached_extents",
            "0",
            "sizeof(hfsplus_extent_rec)"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_ext_write_extent_locked",
          "args": [
            "inode"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_ext_write_extent_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/extents.c",
          "lines": "124-138",
          "snippet": "static int hfsplus_ext_write_extent_locked(struct inode *inode)\n{\n\tint res = 0;\n\n\tif (HFSPLUS_I(inode)->extent_state & HFSPLUS_EXT_DIRTY) {\n\t\tstruct hfs_find_data fd;\n\n\t\tres = hfs_find_init(HFSPLUS_SB(inode->i_sb)->ext_tree, &fd);\n\t\tif (res)\n\t\t\treturn res;\n\t\tres = __hfsplus_ext_write_extent(inode, &fd);\n\t\thfs_find_exit(&fd);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int hfsplus_ext_write_extent_locked(struct inode *inode)\n{\n\tint res = 0;\n\n\tif (HFSPLUS_I(inode)->extent_state & HFSPLUS_EXT_DIRTY) {\n\t\tstruct hfs_find_data fd;\n\n\t\tres = hfs_find_init(HFSPLUS_SB(inode->i_sb)->ext_tree, &fd);\n\t\tif (res)\n\t\t\treturn res;\n\t\tres = __hfsplus_ext_write_extent(inode, &fd);\n\t\thfs_find_exit(&fd);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_dbg",
          "args": [
            "EXTENT",
            "\"insert new extent\\n\""
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&hip->extents_lock"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_mark_inode_dirty",
          "args": [
            "inode",
            "HFSPLUS_I_ALLOC_DIRTY"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "275-280",
          "snippet": "static inline void hfsplus_mark_inode_dirty(struct inode *inode,\n\t\tunsigned int flag)\n{\n\tset_bit(flag, &HFSPLUS_I(inode)->flags);\n\tmark_inode_dirty(inode);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline void hfsplus_mark_inode_dirty(struct inode *inode,\n\t\tunsigned int flag)\n{\n\tset_bit(flag, &HFSPLUS_I(inode)->flags);\n\tmark_inode_dirty(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&hip->extents_lock"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_add_extent",
          "args": [
            "hip->cached_extents",
            "hip->alloc_blocks - hip->cached_start",
            "start",
            "len"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_add_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/extents.c",
          "lines": "302-328",
          "snippet": "static int hfsplus_add_extent(struct hfsplus_extent *extent, u32 offset,\n\t\t\t      u32 alloc_block, u32 block_count)\n{\n\tu32 count, start;\n\tint i;\n\n\thfsplus_dump_extent(extent);\n\tfor (i = 0; i < 8; extent++, i++) {\n\t\tcount = be32_to_cpu(extent->block_count);\n\t\tif (offset == count) {\n\t\t\tstart = be32_to_cpu(extent->start_block);\n\t\t\tif (alloc_block != start + count) {\n\t\t\t\tif (++i >= 8)\n\t\t\t\t\treturn -ENOSPC;\n\t\t\t\textent++;\n\t\t\t\textent->start_block = cpu_to_be32(alloc_block);\n\t\t\t} else\n\t\t\t\tblock_count += count;\n\t\t\textent->block_count = cpu_to_be32(block_count);\n\t\t\treturn 0;\n\t\t} else if (offset < count)\n\t\t\tbreak;\n\t\toffset -= count;\n\t}\n\t/* panic? */\n\treturn -EIO;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int hfsplus_add_extent(struct hfsplus_extent *extent, u32 offset,\n\t\t\t      u32 alloc_block, u32 block_count)\n{\n\tu32 count, start;\n\tint i;\n\n\thfsplus_dump_extent(extent);\n\tfor (i = 0; i < 8; extent++, i++) {\n\t\tcount = be32_to_cpu(extent->block_count);\n\t\tif (offset == count) {\n\t\t\tstart = be32_to_cpu(extent->start_block);\n\t\t\tif (alloc_block != start + count) {\n\t\t\t\tif (++i >= 8)\n\t\t\t\t\treturn -ENOSPC;\n\t\t\t\textent++;\n\t\t\t\textent->start_block = cpu_to_be32(alloc_block);\n\t\t\t} else\n\t\t\t\tblock_count += count;\n\t\t\textent->block_count = cpu_to_be32(block_count);\n\t\t\treturn 0;\n\t\t} else if (offset < count)\n\t\t\tbreak;\n\t\toffset -= count;\n\t}\n\t/* panic? */\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "len"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "start"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_dbg",
          "args": [
            "EXTENT",
            "\"first extents\\n\""
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_dbg",
          "args": [
            "EXTENT",
            "\"extend %lu: %u,%u\\n\"",
            "inode->i_ino",
            "start",
            "len"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_issue_zeroout",
          "args": [
            "sb",
            "start",
            "len",
            "GFP_NOFS"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_block_allocate",
          "args": [
            "sb",
            "goal",
            "0",
            "&len"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_block_allocate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bitmap.c",
          "lines": "18-161",
          "snippet": "int hfsplus_block_allocate(struct super_block *sb, u32 size,\n\t\tu32 offset, u32 *max)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct page *page;\n\tstruct address_space *mapping;\n\t__be32 *pptr, *curr, *end;\n\tu32 mask, start, len, n;\n\t__be32 val;\n\tint i;\n\n\tlen = *max;\n\tif (!len)\n\t\treturn size;\n\n\thfs_dbg(BITMAP, \"block_allocate: %u,%u,%u\\n\", size, offset, len);\n\tmutex_lock(&sbi->alloc_mutex);\n\tmapping = sbi->alloc_file->i_mapping;\n\tpage = read_mapping_page(mapping, offset / PAGE_CACHE_BITS, NULL);\n\tif (IS_ERR(page)) {\n\t\tstart = size;\n\t\tgoto out;\n\t}\n\tpptr = kmap(page);\n\tcurr = pptr + (offset & (PAGE_CACHE_BITS - 1)) / 32;\n\ti = offset % 32;\n\toffset &= ~(PAGE_CACHE_BITS - 1);\n\tif ((size ^ offset) / PAGE_CACHE_BITS)\n\t\tend = pptr + PAGE_CACHE_BITS / 32;\n\telse\n\t\tend = pptr + ((size + 31) & (PAGE_CACHE_BITS - 1)) / 32;\n\n\t/* scan the first partial u32 for zero bits */\n\tval = *curr;\n\tif (~val) {\n\t\tn = be32_to_cpu(val);\n\t\tmask = (1U << 31) >> i;\n\t\tfor (; i < 32; mask >>= 1, i++) {\n\t\t\tif (!(n & mask))\n\t\t\t\tgoto found;\n\t\t}\n\t}\n\tcurr++;\n\n\t/* scan complete u32s for the first zero bit */\n\twhile (1) {\n\t\twhile (curr < end) {\n\t\t\tval = *curr;\n\t\t\tif (~val) {\n\t\t\t\tn = be32_to_cpu(val);\n\t\t\t\tmask = 1 << 31;\n\t\t\t\tfor (i = 0; i < 32; mask >>= 1, i++) {\n\t\t\t\t\tif (!(n & mask))\n\t\t\t\t\t\tgoto found;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurr++;\n\t\t}\n\t\tkunmap(page);\n\t\toffset += PAGE_CACHE_BITS;\n\t\tif (offset >= size)\n\t\t\tbreak;\n\t\tpage = read_mapping_page(mapping, offset / PAGE_CACHE_BITS,\n\t\t\t\t\t NULL);\n\t\tif (IS_ERR(page)) {\n\t\t\tstart = size;\n\t\t\tgoto out;\n\t\t}\n\t\tcurr = pptr = kmap(page);\n\t\tif ((size ^ offset) / PAGE_CACHE_BITS)\n\t\t\tend = pptr + PAGE_CACHE_BITS / 32;\n\t\telse\n\t\t\tend = pptr + ((size + 31) & (PAGE_CACHE_BITS - 1)) / 32;\n\t}\n\thfs_dbg(BITMAP, \"bitmap full\\n\");\n\tstart = size;\n\tgoto out;\n\nfound:\n\tstart = offset + (curr - pptr) * 32 + i;\n\tif (start >= size) {\n\t\thfs_dbg(BITMAP, \"bitmap full\\n\");\n\t\tgoto out;\n\t}\n\t/* do any partial u32 at the start */\n\tlen = min(size - start, len);\n\twhile (1) {\n\t\tn |= mask;\n\t\tif (++i >= 32)\n\t\t\tbreak;\n\t\tmask >>= 1;\n\t\tif (!--len || n & mask)\n\t\t\tgoto done;\n\t}\n\tif (!--len)\n\t\tgoto done;\n\t*curr++ = cpu_to_be32(n);\n\t/* do full u32s */\n\twhile (1) {\n\t\twhile (curr < end) {\n\t\t\tn = be32_to_cpu(*curr);\n\t\t\tif (len < 32)\n\t\t\t\tgoto last;\n\t\t\tif (n) {\n\t\t\t\tlen = 32;\n\t\t\t\tgoto last;\n\t\t\t}\n\t\t\t*curr++ = cpu_to_be32(0xffffffff);\n\t\t\tlen -= 32;\n\t\t}\n\t\tset_page_dirty(page);\n\t\tkunmap(page);\n\t\toffset += PAGE_CACHE_BITS;\n\t\tpage = read_mapping_page(mapping, offset / PAGE_CACHE_BITS,\n\t\t\t\t\t NULL);\n\t\tif (IS_ERR(page)) {\n\t\t\tstart = size;\n\t\t\tgoto out;\n\t\t}\n\t\tpptr = kmap(page);\n\t\tcurr = pptr;\n\t\tend = pptr + PAGE_CACHE_BITS / 32;\n\t}\nlast:\n\t/* do any partial u32 at end */\n\tmask = 1U << 31;\n\tfor (i = 0; i < len; i++) {\n\t\tif (n & mask)\n\t\t\tbreak;\n\t\tn |= mask;\n\t\tmask >>= 1;\n\t}\ndone:\n\t*curr = cpu_to_be32(n);\n\tset_page_dirty(page);\n\tkunmap(page);\n\t*max = offset + (curr - pptr) * 32 + i - start;\n\tsbi->free_blocks -= *max;\n\thfsplus_mark_mdb_dirty(sb);\n\thfs_dbg(BITMAP, \"-> %u,%u\\n\", start, *max);\nout:\n\tmutex_unlock(&sbi->alloc_mutex);\n\treturn start;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define PAGE_CACHE_BITS\t(PAGE_CACHE_SIZE * 8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n\n#define PAGE_CACHE_BITS\t(PAGE_CACHE_SIZE * 8)\n\nint hfsplus_block_allocate(struct super_block *sb, u32 size,\n\t\tu32 offset, u32 *max)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct page *page;\n\tstruct address_space *mapping;\n\t__be32 *pptr, *curr, *end;\n\tu32 mask, start, len, n;\n\t__be32 val;\n\tint i;\n\n\tlen = *max;\n\tif (!len)\n\t\treturn size;\n\n\thfs_dbg(BITMAP, \"block_allocate: %u,%u,%u\\n\", size, offset, len);\n\tmutex_lock(&sbi->alloc_mutex);\n\tmapping = sbi->alloc_file->i_mapping;\n\tpage = read_mapping_page(mapping, offset / PAGE_CACHE_BITS, NULL);\n\tif (IS_ERR(page)) {\n\t\tstart = size;\n\t\tgoto out;\n\t}\n\tpptr = kmap(page);\n\tcurr = pptr + (offset & (PAGE_CACHE_BITS - 1)) / 32;\n\ti = offset % 32;\n\toffset &= ~(PAGE_CACHE_BITS - 1);\n\tif ((size ^ offset) / PAGE_CACHE_BITS)\n\t\tend = pptr + PAGE_CACHE_BITS / 32;\n\telse\n\t\tend = pptr + ((size + 31) & (PAGE_CACHE_BITS - 1)) / 32;\n\n\t/* scan the first partial u32 for zero bits */\n\tval = *curr;\n\tif (~val) {\n\t\tn = be32_to_cpu(val);\n\t\tmask = (1U << 31) >> i;\n\t\tfor (; i < 32; mask >>= 1, i++) {\n\t\t\tif (!(n & mask))\n\t\t\t\tgoto found;\n\t\t}\n\t}\n\tcurr++;\n\n\t/* scan complete u32s for the first zero bit */\n\twhile (1) {\n\t\twhile (curr < end) {\n\t\t\tval = *curr;\n\t\t\tif (~val) {\n\t\t\t\tn = be32_to_cpu(val);\n\t\t\t\tmask = 1 << 31;\n\t\t\t\tfor (i = 0; i < 32; mask >>= 1, i++) {\n\t\t\t\t\tif (!(n & mask))\n\t\t\t\t\t\tgoto found;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurr++;\n\t\t}\n\t\tkunmap(page);\n\t\toffset += PAGE_CACHE_BITS;\n\t\tif (offset >= size)\n\t\t\tbreak;\n\t\tpage = read_mapping_page(mapping, offset / PAGE_CACHE_BITS,\n\t\t\t\t\t NULL);\n\t\tif (IS_ERR(page)) {\n\t\t\tstart = size;\n\t\t\tgoto out;\n\t\t}\n\t\tcurr = pptr = kmap(page);\n\t\tif ((size ^ offset) / PAGE_CACHE_BITS)\n\t\t\tend = pptr + PAGE_CACHE_BITS / 32;\n\t\telse\n\t\t\tend = pptr + ((size + 31) & (PAGE_CACHE_BITS - 1)) / 32;\n\t}\n\thfs_dbg(BITMAP, \"bitmap full\\n\");\n\tstart = size;\n\tgoto out;\n\nfound:\n\tstart = offset + (curr - pptr) * 32 + i;\n\tif (start >= size) {\n\t\thfs_dbg(BITMAP, \"bitmap full\\n\");\n\t\tgoto out;\n\t}\n\t/* do any partial u32 at the start */\n\tlen = min(size - start, len);\n\twhile (1) {\n\t\tn |= mask;\n\t\tif (++i >= 32)\n\t\t\tbreak;\n\t\tmask >>= 1;\n\t\tif (!--len || n & mask)\n\t\t\tgoto done;\n\t}\n\tif (!--len)\n\t\tgoto done;\n\t*curr++ = cpu_to_be32(n);\n\t/* do full u32s */\n\twhile (1) {\n\t\twhile (curr < end) {\n\t\t\tn = be32_to_cpu(*curr);\n\t\t\tif (len < 32)\n\t\t\t\tgoto last;\n\t\t\tif (n) {\n\t\t\t\tlen = 32;\n\t\t\t\tgoto last;\n\t\t\t}\n\t\t\t*curr++ = cpu_to_be32(0xffffffff);\n\t\t\tlen -= 32;\n\t\t}\n\t\tset_page_dirty(page);\n\t\tkunmap(page);\n\t\toffset += PAGE_CACHE_BITS;\n\t\tpage = read_mapping_page(mapping, offset / PAGE_CACHE_BITS,\n\t\t\t\t\t NULL);\n\t\tif (IS_ERR(page)) {\n\t\t\tstart = size;\n\t\t\tgoto out;\n\t\t}\n\t\tpptr = kmap(page);\n\t\tcurr = pptr;\n\t\tend = pptr + PAGE_CACHE_BITS / 32;\n\t}\nlast:\n\t/* do any partial u32 at end */\n\tmask = 1U << 31;\n\tfor (i = 0; i < len; i++) {\n\t\tif (n & mask)\n\t\t\tbreak;\n\t\tn |= mask;\n\t\tmask >>= 1;\n\t}\ndone:\n\t*curr = cpu_to_be32(n);\n\tset_page_dirty(page);\n\tkunmap(page);\n\t*max = offset + (curr - pptr) * 32 + i - start;\n\tsbi->free_blocks -= *max;\n\thfsplus_mark_mdb_dirty(sb);\n\thfs_dbg(BITMAP, \"-> %u,%u\\n\", start, *max);\nout:\n\tmutex_unlock(&sbi->alloc_mutex);\n\treturn start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_ext_lastblock",
          "args": [
            "hip->cached_extents"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_ext_lastblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/extents.c",
          "lines": "75-84",
          "snippet": "static u32 hfsplus_ext_lastblock(struct hfsplus_extent *ext)\n{\n\tint i;\n\n\text += 7;\n\tfor (i = 0; i < 7; ext--, i++)\n\t\tif (ext->block_count)\n\t\t\tbreak;\n\treturn be32_to_cpu(ext->start_block) + be32_to_cpu(ext->block_count);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic u32 hfsplus_ext_lastblock(struct hfsplus_extent *ext)\n{\n\tint i;\n\n\text += 7;\n\tfor (i = 0; i < 7; ext--, i++)\n\t\tif (ext->block_count)\n\t\t\tbreak;\n\treturn be32_to_cpu(ext->start_block) + be32_to_cpu(ext->block_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_ext_read_extent",
          "args": [
            "inode",
            "hip->alloc_blocks"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_ext_read_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/extents.c",
          "lines": "201-217",
          "snippet": "static int hfsplus_ext_read_extent(struct inode *inode, u32 block)\n{\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tstruct hfs_find_data fd;\n\tint res;\n\n\tif (block >= hip->cached_start &&\n\t    block < hip->cached_start + hip->cached_blocks)\n\t\treturn 0;\n\n\tres = hfs_find_init(HFSPLUS_SB(inode->i_sb)->ext_tree, &fd);\n\tif (!res) {\n\t\tres = __hfsplus_ext_cache_extent(&fd, inode, block);\n\t\thfs_find_exit(&fd);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int hfsplus_ext_read_extent(struct inode *inode, u32 block)\n{\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tstruct hfs_find_data fd;\n\tint res;\n\n\tif (block >= hip->cached_start &&\n\t    block < hip->cached_start + hip->cached_blocks)\n\t\treturn 0;\n\n\tres = hfs_find_init(HFSPLUS_SB(inode->i_sb)->ext_tree, &fd);\n\tif (!res) {\n\t\tres = __hfsplus_ext_cache_extent(&fd, inode, block);\n\t\thfs_find_exit(&fd);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&hip->extents_lock"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"extend alloc file! (%llu,%u,%u)\\n\"",
            "sbi->alloc_file->i_size * 8",
            "sbi->total_blocks",
            "sbi->free_blocks"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFSPLUS_I",
          "args": [
            "inode"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "264-267",
          "snippet": "static inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "sb"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nint hfsplus_file_extend(struct inode *inode, bool zeroout)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tu32 start, len, goal;\n\tint res;\n\n\tif (sbi->alloc_file->i_size * 8 <\n\t    sbi->total_blocks - sbi->free_blocks + 8) {\n\t\t/* extend alloc file */\n\t\tpr_err(\"extend alloc file! (%llu,%u,%u)\\n\",\n\t\t       sbi->alloc_file->i_size * 8,\n\t\t       sbi->total_blocks, sbi->free_blocks);\n\t\treturn -ENOSPC;\n\t}\n\n\tmutex_lock(&hip->extents_lock);\n\tif (hip->alloc_blocks == hip->first_blocks)\n\t\tgoal = hfsplus_ext_lastblock(hip->first_extents);\n\telse {\n\t\tres = hfsplus_ext_read_extent(inode, hip->alloc_blocks);\n\t\tif (res)\n\t\t\tgoto out;\n\t\tgoal = hfsplus_ext_lastblock(hip->cached_extents);\n\t}\n\n\tlen = hip->clump_blocks;\n\tstart = hfsplus_block_allocate(sb, sbi->total_blocks, goal, &len);\n\tif (start >= sbi->total_blocks) {\n\t\tstart = hfsplus_block_allocate(sb, goal, 0, &len);\n\t\tif (start >= goal) {\n\t\t\tres = -ENOSPC;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (zeroout) {\n\t\tres = sb_issue_zeroout(sb, start, len, GFP_NOFS);\n\t\tif (res)\n\t\t\tgoto out;\n\t}\n\n\thfs_dbg(EXTENT, \"extend %lu: %u,%u\\n\", inode->i_ino, start, len);\n\n\tif (hip->alloc_blocks <= hip->first_blocks) {\n\t\tif (!hip->first_blocks) {\n\t\t\thfs_dbg(EXTENT, \"first extents\\n\");\n\t\t\t/* no extents yet */\n\t\t\thip->first_extents[0].start_block = cpu_to_be32(start);\n\t\t\thip->first_extents[0].block_count = cpu_to_be32(len);\n\t\t\tres = 0;\n\t\t} else {\n\t\t\t/* try to append to extents in inode */\n\t\t\tres = hfsplus_add_extent(hip->first_extents,\n\t\t\t\t\t\t hip->alloc_blocks,\n\t\t\t\t\t\t start, len);\n\t\t\tif (res == -ENOSPC)\n\t\t\t\tgoto insert_extent;\n\t\t}\n\t\tif (!res) {\n\t\t\thfsplus_dump_extent(hip->first_extents);\n\t\t\thip->first_blocks += len;\n\t\t}\n\t} else {\n\t\tres = hfsplus_add_extent(hip->cached_extents,\n\t\t\t\t\t hip->alloc_blocks - hip->cached_start,\n\t\t\t\t\t start, len);\n\t\tif (!res) {\n\t\t\thfsplus_dump_extent(hip->cached_extents);\n\t\t\thip->extent_state |= HFSPLUS_EXT_DIRTY;\n\t\t\thip->cached_blocks += len;\n\t\t} else if (res == -ENOSPC)\n\t\t\tgoto insert_extent;\n\t}\nout:\n\tif (!res) {\n\t\thip->alloc_blocks += len;\n\t\tmutex_unlock(&hip->extents_lock);\n\t\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_ALLOC_DIRTY);\n\t\treturn 0;\n\t}\n\tmutex_unlock(&hip->extents_lock);\n\treturn res;\n\ninsert_extent:\n\thfs_dbg(EXTENT, \"insert new extent\\n\");\n\tres = hfsplus_ext_write_extent_locked(inode);\n\tif (res)\n\t\tgoto out;\n\n\tmemset(hip->cached_extents, 0, sizeof(hfsplus_extent_rec));\n\thip->cached_extents[0].start_block = cpu_to_be32(start);\n\thip->cached_extents[0].block_count = cpu_to_be32(len);\n\thfsplus_dump_extent(hip->cached_extents);\n\thip->extent_state |= HFSPLUS_EXT_DIRTY | HFSPLUS_EXT_NEW;\n\thip->cached_start = hip->alloc_blocks;\n\thip->cached_blocks = len;\n\n\tres = 0;\n\tgoto out;\n}"
  },
  {
    "function_name": "hfsplus_free_fork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/extents.c",
    "lines": "386-426",
    "snippet": "int hfsplus_free_fork(struct super_block *sb, u32 cnid,\n\t\tstruct hfsplus_fork_raw *fork, int type)\n{\n\tstruct hfs_find_data fd;\n\thfsplus_extent_rec ext_entry;\n\tu32 total_blocks, blocks, start;\n\tint res, i;\n\n\ttotal_blocks = be32_to_cpu(fork->total_blocks);\n\tif (!total_blocks)\n\t\treturn 0;\n\n\tblocks = 0;\n\tfor (i = 0; i < 8; i++)\n\t\tblocks += be32_to_cpu(fork->extents[i].block_count);\n\n\tres = hfsplus_free_extents(sb, fork->extents, blocks, blocks);\n\tif (res)\n\t\treturn res;\n\tif (total_blocks == blocks)\n\t\treturn 0;\n\n\tres = hfs_find_init(HFSPLUS_SB(sb)->ext_tree, &fd);\n\tif (res)\n\t\treturn res;\n\tdo {\n\t\tres = __hfsplus_ext_read_extent(&fd, ext_entry, cnid,\n\t\t\t\t\t\ttotal_blocks, type);\n\t\tif (res)\n\t\t\tbreak;\n\t\tstart = be32_to_cpu(fd.key->ext.start_block);\n\t\thfsplus_free_extents(sb, ext_entry,\n\t\t\t\t     total_blocks - start,\n\t\t\t\t     total_blocks);\n\t\thfs_brec_remove(&fd);\n\t\ttotal_blocks = start;\n\t} while (total_blocks > blocks);\n\thfs_find_exit(&fd);\n\n\treturn res;\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_find_exit",
          "args": [
            "&fd"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "43-51",
          "snippet": "void hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nvoid hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_brec_remove",
          "args": [
            "&fd"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/brec.c",
          "lines": "177-231",
          "snippet": "int hfs_brec_remove(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *parent;\n\tint end_off, rec_off, data_off, size;\n\n\ttree = fd->tree;\n\tnode = fd->bnode;\nagain:\n\trec_off = tree->node_size - (fd->record + 2) * 2;\n\tend_off = tree->node_size - (node->num_recs + 1) * 2;\n\n\tif (node->type == HFS_NODE_LEAF) {\n\t\ttree->leaf_count--;\n\t\tmark_inode_dirty(tree->inode);\n\t}\n\thfs_bnode_dump(node);\n\thfs_dbg(BNODE_MOD, \"remove_rec: %d, %d\\n\",\n\t\tfd->record, fd->keylength + fd->entrylength);\n\tif (!--node->num_recs) {\n\t\thfs_bnode_unlink(node);\n\t\tif (!node->parent)\n\t\t\treturn 0;\n\t\tparent = hfs_bnode_find(tree, node->parent);\n\t\tif (IS_ERR(parent))\n\t\t\treturn PTR_ERR(parent);\n\t\thfs_bnode_put(node);\n\t\tnode = fd->bnode = parent;\n\n\t\t__hfs_brec_find(node, fd, hfs_find_rec_by_key);\n\t\tgoto again;\n\t}\n\thfs_bnode_write_u16(node,\n\t\toffsetof(struct hfs_bnode_desc, num_recs),\n\t\tnode->num_recs);\n\n\tif (rec_off == end_off)\n\t\tgoto skip;\n\tsize = fd->keylength + fd->entrylength;\n\n\tdo {\n\t\tdata_off = hfs_bnode_read_u16(node, rec_off);\n\t\thfs_bnode_write_u16(node, rec_off + 2, data_off - size);\n\t\trec_off -= 2;\n\t} while (rec_off >= end_off);\n\n\t/* fill hole */\n\thfs_bnode_move(node, fd->keyoffset, fd->keyoffset + size,\n\t\t       data_off - fd->keyoffset - size);\nskip:\n\thfs_bnode_dump(node);\n\tif (!fd->record)\n\t\thfs_brec_update_parent(fd);\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd);",
            "static int hfs_brec_update_parent(struct hfs_find_data *fd);",
            "static int hfs_btree_inc_height(struct hfs_btree *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd);\nstatic int hfs_brec_update_parent(struct hfs_find_data *fd);\nstatic int hfs_btree_inc_height(struct hfs_btree *);\n\nint hfs_brec_remove(struct hfs_find_data *fd)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *parent;\n\tint end_off, rec_off, data_off, size;\n\n\ttree = fd->tree;\n\tnode = fd->bnode;\nagain:\n\trec_off = tree->node_size - (fd->record + 2) * 2;\n\tend_off = tree->node_size - (node->num_recs + 1) * 2;\n\n\tif (node->type == HFS_NODE_LEAF) {\n\t\ttree->leaf_count--;\n\t\tmark_inode_dirty(tree->inode);\n\t}\n\thfs_bnode_dump(node);\n\thfs_dbg(BNODE_MOD, \"remove_rec: %d, %d\\n\",\n\t\tfd->record, fd->keylength + fd->entrylength);\n\tif (!--node->num_recs) {\n\t\thfs_bnode_unlink(node);\n\t\tif (!node->parent)\n\t\t\treturn 0;\n\t\tparent = hfs_bnode_find(tree, node->parent);\n\t\tif (IS_ERR(parent))\n\t\t\treturn PTR_ERR(parent);\n\t\thfs_bnode_put(node);\n\t\tnode = fd->bnode = parent;\n\n\t\t__hfs_brec_find(node, fd, hfs_find_rec_by_key);\n\t\tgoto again;\n\t}\n\thfs_bnode_write_u16(node,\n\t\toffsetof(struct hfs_bnode_desc, num_recs),\n\t\tnode->num_recs);\n\n\tif (rec_off == end_off)\n\t\tgoto skip;\n\tsize = fd->keylength + fd->entrylength;\n\n\tdo {\n\t\tdata_off = hfs_bnode_read_u16(node, rec_off);\n\t\thfs_bnode_write_u16(node, rec_off + 2, data_off - size);\n\t\trec_off -= 2;\n\t} while (rec_off >= end_off);\n\n\t/* fill hole */\n\thfs_bnode_move(node, fd->keyoffset, fd->keyoffset + size,\n\t\t       data_off - fd->keyoffset - size);\nskip:\n\thfs_bnode_dump(node);\n\tif (!fd->record)\n\t\thfs_brec_update_parent(fd);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_free_extents",
          "args": [
            "sb",
            "ext_entry",
            "total_blocks - start",
            "total_blocks"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_free_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/extents.c",
          "lines": "330-384",
          "snippet": "static int hfsplus_free_extents(struct super_block *sb,\n\t\t\t\tstruct hfsplus_extent *extent,\n\t\t\t\tu32 offset, u32 block_nr)\n{\n\tu32 count, start;\n\tint i;\n\tint err = 0;\n\n\thfsplus_dump_extent(extent);\n\tfor (i = 0; i < 8; extent++, i++) {\n\t\tcount = be32_to_cpu(extent->block_count);\n\t\tif (offset == count)\n\t\t\tgoto found;\n\t\telse if (offset < count)\n\t\t\tbreak;\n\t\toffset -= count;\n\t}\n\t/* panic? */\n\treturn -EIO;\nfound:\n\tfor (;;) {\n\t\tstart = be32_to_cpu(extent->start_block);\n\t\tif (count <= block_nr) {\n\t\t\terr = hfsplus_block_free(sb, start, count);\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"can't free extent\\n\");\n\t\t\t\thfs_dbg(EXTENT, \" start: %u count: %u\\n\",\n\t\t\t\t\tstart, count);\n\t\t\t}\n\t\t\textent->block_count = 0;\n\t\t\textent->start_block = 0;\n\t\t\tblock_nr -= count;\n\t\t} else {\n\t\t\tcount -= block_nr;\n\t\t\terr = hfsplus_block_free(sb, start + count, block_nr);\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"can't free extent\\n\");\n\t\t\t\thfs_dbg(EXTENT, \" start: %u count: %u\\n\",\n\t\t\t\t\tstart, count);\n\t\t\t}\n\t\t\textent->block_count = cpu_to_be32(count);\n\t\t\tblock_nr = 0;\n\t\t}\n\t\tif (!block_nr || !i) {\n\t\t\t/*\n\t\t\t * Try to free all extents and\n\t\t\t * return only last error\n\t\t\t */\n\t\t\treturn err;\n\t\t}\n\t\ti--;\n\t\textent--;\n\t\tcount = be32_to_cpu(extent->block_count);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int hfsplus_free_extents(struct super_block *sb,\n\t\t\t\tstruct hfsplus_extent *extent,\n\t\t\t\tu32 offset, u32 block_nr)\n{\n\tu32 count, start;\n\tint i;\n\tint err = 0;\n\n\thfsplus_dump_extent(extent);\n\tfor (i = 0; i < 8; extent++, i++) {\n\t\tcount = be32_to_cpu(extent->block_count);\n\t\tif (offset == count)\n\t\t\tgoto found;\n\t\telse if (offset < count)\n\t\t\tbreak;\n\t\toffset -= count;\n\t}\n\t/* panic? */\n\treturn -EIO;\nfound:\n\tfor (;;) {\n\t\tstart = be32_to_cpu(extent->start_block);\n\t\tif (count <= block_nr) {\n\t\t\terr = hfsplus_block_free(sb, start, count);\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"can't free extent\\n\");\n\t\t\t\thfs_dbg(EXTENT, \" start: %u count: %u\\n\",\n\t\t\t\t\tstart, count);\n\t\t\t}\n\t\t\textent->block_count = 0;\n\t\t\textent->start_block = 0;\n\t\t\tblock_nr -= count;\n\t\t} else {\n\t\t\tcount -= block_nr;\n\t\t\terr = hfsplus_block_free(sb, start + count, block_nr);\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"can't free extent\\n\");\n\t\t\t\thfs_dbg(EXTENT, \" start: %u count: %u\\n\",\n\t\t\t\t\tstart, count);\n\t\t\t}\n\t\t\textent->block_count = cpu_to_be32(count);\n\t\t\tblock_nr = 0;\n\t\t}\n\t\tif (!block_nr || !i) {\n\t\t\t/*\n\t\t\t * Try to free all extents and\n\t\t\t * return only last error\n\t\t\t */\n\t\t\treturn err;\n\t\t}\n\t\ti--;\n\t\textent--;\n\t\tcount = be32_to_cpu(extent->block_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "fd.key->ext.start_block"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__hfsplus_ext_read_extent",
          "args": [
            "&fd",
            "ext_entry",
            "cnid",
            "total_blocks",
            "type"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "__hfsplus_ext_read_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/extents.c",
          "lines": "151-170",
          "snippet": "static inline int __hfsplus_ext_read_extent(struct hfs_find_data *fd,\n\t\t\t\t\t    struct hfsplus_extent *extent,\n\t\t\t\t\t    u32 cnid, u32 block, u8 type)\n{\n\tint res;\n\n\thfsplus_ext_build_key(fd->search_key, cnid, block, type);\n\tfd->key->ext.cnid = 0;\n\tres = hfs_brec_find(fd, hfs_find_rec_by_key);\n\tif (res && res != -ENOENT)\n\t\treturn res;\n\tif (fd->key->ext.cnid != fd->search_key->ext.cnid ||\n\t    fd->key->ext.fork_type != fd->search_key->ext.fork_type)\n\t\treturn -ENOENT;\n\tif (fd->entrylength != sizeof(hfsplus_extent_rec))\n\t\treturn -EIO;\n\thfs_bnode_read(fd->bnode, extent, fd->entryoffset,\n\t\tsizeof(hfsplus_extent_rec));\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic inline int __hfsplus_ext_read_extent(struct hfs_find_data *fd,\n\t\t\t\t\t    struct hfsplus_extent *extent,\n\t\t\t\t\t    u32 cnid, u32 block, u8 type)\n{\n\tint res;\n\n\thfsplus_ext_build_key(fd->search_key, cnid, block, type);\n\tfd->key->ext.cnid = 0;\n\tres = hfs_brec_find(fd, hfs_find_rec_by_key);\n\tif (res && res != -ENOENT)\n\t\treturn res;\n\tif (fd->key->ext.cnid != fd->search_key->ext.cnid ||\n\t    fd->key->ext.fork_type != fd->search_key->ext.fork_type)\n\t\treturn -ENOENT;\n\tif (fd->entrylength != sizeof(hfsplus_extent_rec))\n\t\treturn -EIO;\n\thfs_bnode_read(fd->bnode, extent, fd->entryoffset,\n\t\tsizeof(hfsplus_extent_rec));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_find_init",
          "args": [
            "HFSPLUS_SB(sb)->ext_tree",
            "&fd"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "14-41",
          "snippet": "int hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tswitch (tree->cnid) {\n\tcase HFSPLUS_CAT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, CATALOG_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_EXT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, EXTENTS_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, ATTR_BTREE_MUTEX);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nint hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tswitch (tree->cnid) {\n\tcase HFSPLUS_CAT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, CATALOG_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_EXT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, EXTENTS_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, ATTR_BTREE_MUTEX);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "sb"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "fork->extents[i].block_count"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "fork->total_blocks"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nint hfsplus_free_fork(struct super_block *sb, u32 cnid,\n\t\tstruct hfsplus_fork_raw *fork, int type)\n{\n\tstruct hfs_find_data fd;\n\thfsplus_extent_rec ext_entry;\n\tu32 total_blocks, blocks, start;\n\tint res, i;\n\n\ttotal_blocks = be32_to_cpu(fork->total_blocks);\n\tif (!total_blocks)\n\t\treturn 0;\n\n\tblocks = 0;\n\tfor (i = 0; i < 8; i++)\n\t\tblocks += be32_to_cpu(fork->extents[i].block_count);\n\n\tres = hfsplus_free_extents(sb, fork->extents, blocks, blocks);\n\tif (res)\n\t\treturn res;\n\tif (total_blocks == blocks)\n\t\treturn 0;\n\n\tres = hfs_find_init(HFSPLUS_SB(sb)->ext_tree, &fd);\n\tif (res)\n\t\treturn res;\n\tdo {\n\t\tres = __hfsplus_ext_read_extent(&fd, ext_entry, cnid,\n\t\t\t\t\t\ttotal_blocks, type);\n\t\tif (res)\n\t\t\tbreak;\n\t\tstart = be32_to_cpu(fd.key->ext.start_block);\n\t\thfsplus_free_extents(sb, ext_entry,\n\t\t\t\t     total_blocks - start,\n\t\t\t\t     total_blocks);\n\t\thfs_brec_remove(&fd);\n\t\ttotal_blocks = start;\n\t} while (total_blocks > blocks);\n\thfs_find_exit(&fd);\n\n\treturn res;\n}"
  },
  {
    "function_name": "hfsplus_free_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/extents.c",
    "lines": "330-384",
    "snippet": "static int hfsplus_free_extents(struct super_block *sb,\n\t\t\t\tstruct hfsplus_extent *extent,\n\t\t\t\tu32 offset, u32 block_nr)\n{\n\tu32 count, start;\n\tint i;\n\tint err = 0;\n\n\thfsplus_dump_extent(extent);\n\tfor (i = 0; i < 8; extent++, i++) {\n\t\tcount = be32_to_cpu(extent->block_count);\n\t\tif (offset == count)\n\t\t\tgoto found;\n\t\telse if (offset < count)\n\t\t\tbreak;\n\t\toffset -= count;\n\t}\n\t/* panic? */\n\treturn -EIO;\nfound:\n\tfor (;;) {\n\t\tstart = be32_to_cpu(extent->start_block);\n\t\tif (count <= block_nr) {\n\t\t\terr = hfsplus_block_free(sb, start, count);\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"can't free extent\\n\");\n\t\t\t\thfs_dbg(EXTENT, \" start: %u count: %u\\n\",\n\t\t\t\t\tstart, count);\n\t\t\t}\n\t\t\textent->block_count = 0;\n\t\t\textent->start_block = 0;\n\t\t\tblock_nr -= count;\n\t\t} else {\n\t\t\tcount -= block_nr;\n\t\t\terr = hfsplus_block_free(sb, start + count, block_nr);\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"can't free extent\\n\");\n\t\t\t\thfs_dbg(EXTENT, \" start: %u count: %u\\n\",\n\t\t\t\t\tstart, count);\n\t\t\t}\n\t\t\textent->block_count = cpu_to_be32(count);\n\t\t\tblock_nr = 0;\n\t\t}\n\t\tif (!block_nr || !i) {\n\t\t\t/*\n\t\t\t * Try to free all extents and\n\t\t\t * return only last error\n\t\t\t */\n\t\t\treturn err;\n\t\t}\n\t\ti--;\n\t\textent--;\n\t\tcount = be32_to_cpu(extent->block_count);\n\t}\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "extent->block_count"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "count"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_dbg",
          "args": [
            "EXTENT",
            "\" start: %u count: %u\\n\"",
            "start",
            "count"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"can't free extent\\n\""
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_block_free",
          "args": [
            "sb",
            "start + count",
            "block_nr"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_block_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bitmap.c",
          "lines": "163-245",
          "snippet": "int hfsplus_block_free(struct super_block *sb, u32 offset, u32 count)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct page *page;\n\tstruct address_space *mapping;\n\t__be32 *pptr, *curr, *end;\n\tu32 mask, len, pnr;\n\tint i;\n\n\t/* is there any actual work to be done? */\n\tif (!count)\n\t\treturn 0;\n\n\thfs_dbg(BITMAP, \"block_free: %u,%u\\n\", offset, count);\n\t/* are all of the bits in range? */\n\tif ((offset + count) > sbi->total_blocks)\n\t\treturn -ENOENT;\n\n\tmutex_lock(&sbi->alloc_mutex);\n\tmapping = sbi->alloc_file->i_mapping;\n\tpnr = offset / PAGE_CACHE_BITS;\n\tpage = read_mapping_page(mapping, pnr, NULL);\n\tif (IS_ERR(page))\n\t\tgoto kaboom;\n\tpptr = kmap(page);\n\tcurr = pptr + (offset & (PAGE_CACHE_BITS - 1)) / 32;\n\tend = pptr + PAGE_CACHE_BITS / 32;\n\tlen = count;\n\n\t/* do any partial u32 at the start */\n\ti = offset % 32;\n\tif (i) {\n\t\tint j = 32 - i;\n\t\tmask = 0xffffffffU << j;\n\t\tif (j > count) {\n\t\t\tmask |= 0xffffffffU >> (i + count);\n\t\t\t*curr++ &= cpu_to_be32(mask);\n\t\t\tgoto out;\n\t\t}\n\t\t*curr++ &= cpu_to_be32(mask);\n\t\tcount -= j;\n\t}\n\n\t/* do full u32s */\n\twhile (1) {\n\t\twhile (curr < end) {\n\t\t\tif (count < 32)\n\t\t\t\tgoto done;\n\t\t\t*curr++ = 0;\n\t\t\tcount -= 32;\n\t\t}\n\t\tif (!count)\n\t\t\tbreak;\n\t\tset_page_dirty(page);\n\t\tkunmap(page);\n\t\tpage = read_mapping_page(mapping, ++pnr, NULL);\n\t\tif (IS_ERR(page))\n\t\t\tgoto kaboom;\n\t\tpptr = kmap(page);\n\t\tcurr = pptr;\n\t\tend = pptr + PAGE_CACHE_BITS / 32;\n\t}\ndone:\n\t/* do any partial u32 at end */\n\tif (count) {\n\t\tmask = 0xffffffffU >> count;\n\t\t*curr &= cpu_to_be32(mask);\n\t}\nout:\n\tset_page_dirty(page);\n\tkunmap(page);\n\tsbi->free_blocks += len;\n\thfsplus_mark_mdb_dirty(sb);\n\tmutex_unlock(&sbi->alloc_mutex);\n\n\treturn 0;\n\nkaboom:\n\tpr_crit(\"unable to mark blocks free: error %ld\\n\", PTR_ERR(page));\n\tmutex_unlock(&sbi->alloc_mutex);\n\n\treturn -EIO;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define PAGE_CACHE_BITS\t(PAGE_CACHE_SIZE * 8)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n\n#define PAGE_CACHE_BITS\t(PAGE_CACHE_SIZE * 8)\n\nint hfsplus_block_free(struct super_block *sb, u32 offset, u32 count)\n{\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct page *page;\n\tstruct address_space *mapping;\n\t__be32 *pptr, *curr, *end;\n\tu32 mask, len, pnr;\n\tint i;\n\n\t/* is there any actual work to be done? */\n\tif (!count)\n\t\treturn 0;\n\n\thfs_dbg(BITMAP, \"block_free: %u,%u\\n\", offset, count);\n\t/* are all of the bits in range? */\n\tif ((offset + count) > sbi->total_blocks)\n\t\treturn -ENOENT;\n\n\tmutex_lock(&sbi->alloc_mutex);\n\tmapping = sbi->alloc_file->i_mapping;\n\tpnr = offset / PAGE_CACHE_BITS;\n\tpage = read_mapping_page(mapping, pnr, NULL);\n\tif (IS_ERR(page))\n\t\tgoto kaboom;\n\tpptr = kmap(page);\n\tcurr = pptr + (offset & (PAGE_CACHE_BITS - 1)) / 32;\n\tend = pptr + PAGE_CACHE_BITS / 32;\n\tlen = count;\n\n\t/* do any partial u32 at the start */\n\ti = offset % 32;\n\tif (i) {\n\t\tint j = 32 - i;\n\t\tmask = 0xffffffffU << j;\n\t\tif (j > count) {\n\t\t\tmask |= 0xffffffffU >> (i + count);\n\t\t\t*curr++ &= cpu_to_be32(mask);\n\t\t\tgoto out;\n\t\t}\n\t\t*curr++ &= cpu_to_be32(mask);\n\t\tcount -= j;\n\t}\n\n\t/* do full u32s */\n\twhile (1) {\n\t\twhile (curr < end) {\n\t\t\tif (count < 32)\n\t\t\t\tgoto done;\n\t\t\t*curr++ = 0;\n\t\t\tcount -= 32;\n\t\t}\n\t\tif (!count)\n\t\t\tbreak;\n\t\tset_page_dirty(page);\n\t\tkunmap(page);\n\t\tpage = read_mapping_page(mapping, ++pnr, NULL);\n\t\tif (IS_ERR(page))\n\t\t\tgoto kaboom;\n\t\tpptr = kmap(page);\n\t\tcurr = pptr;\n\t\tend = pptr + PAGE_CACHE_BITS / 32;\n\t}\ndone:\n\t/* do any partial u32 at end */\n\tif (count) {\n\t\tmask = 0xffffffffU >> count;\n\t\t*curr &= cpu_to_be32(mask);\n\t}\nout:\n\tset_page_dirty(page);\n\tkunmap(page);\n\tsbi->free_blocks += len;\n\thfsplus_mark_mdb_dirty(sb);\n\tmutex_unlock(&sbi->alloc_mutex);\n\n\treturn 0;\n\nkaboom:\n\tpr_crit(\"unable to mark blocks free: error %ld\\n\", PTR_ERR(page));\n\tmutex_unlock(&sbi->alloc_mutex);\n\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_dbg",
          "args": [
            "EXTENT",
            "\" start: %u count: %u\\n\"",
            "start",
            "count"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"can't free extent\\n\""
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "extent->start_block"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "extent->block_count"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_dump_extent",
          "args": [
            "extent"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_dump_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/extents.c",
          "lines": "290-300",
          "snippet": "static void hfsplus_dump_extent(struct hfsplus_extent *extent)\n{\n\tint i;\n\n\thfs_dbg(EXTENT, \"   \");\n\tfor (i = 0; i < 8; i++)\n\t\thfs_dbg_cont(EXTENT, \" %u:%u\",\n\t\t\t     be32_to_cpu(extent[i].start_block),\n\t\t\t     be32_to_cpu(extent[i].block_count));\n\thfs_dbg_cont(EXTENT, \"\\n\");\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic void hfsplus_dump_extent(struct hfsplus_extent *extent)\n{\n\tint i;\n\n\thfs_dbg(EXTENT, \"   \");\n\tfor (i = 0; i < 8; i++)\n\t\thfs_dbg_cont(EXTENT, \" %u:%u\",\n\t\t\t     be32_to_cpu(extent[i].start_block),\n\t\t\t     be32_to_cpu(extent[i].block_count));\n\thfs_dbg_cont(EXTENT, \"\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int hfsplus_free_extents(struct super_block *sb,\n\t\t\t\tstruct hfsplus_extent *extent,\n\t\t\t\tu32 offset, u32 block_nr)\n{\n\tu32 count, start;\n\tint i;\n\tint err = 0;\n\n\thfsplus_dump_extent(extent);\n\tfor (i = 0; i < 8; extent++, i++) {\n\t\tcount = be32_to_cpu(extent->block_count);\n\t\tif (offset == count)\n\t\t\tgoto found;\n\t\telse if (offset < count)\n\t\t\tbreak;\n\t\toffset -= count;\n\t}\n\t/* panic? */\n\treturn -EIO;\nfound:\n\tfor (;;) {\n\t\tstart = be32_to_cpu(extent->start_block);\n\t\tif (count <= block_nr) {\n\t\t\terr = hfsplus_block_free(sb, start, count);\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"can't free extent\\n\");\n\t\t\t\thfs_dbg(EXTENT, \" start: %u count: %u\\n\",\n\t\t\t\t\tstart, count);\n\t\t\t}\n\t\t\textent->block_count = 0;\n\t\t\textent->start_block = 0;\n\t\t\tblock_nr -= count;\n\t\t} else {\n\t\t\tcount -= block_nr;\n\t\t\terr = hfsplus_block_free(sb, start + count, block_nr);\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"can't free extent\\n\");\n\t\t\t\thfs_dbg(EXTENT, \" start: %u count: %u\\n\",\n\t\t\t\t\tstart, count);\n\t\t\t}\n\t\t\textent->block_count = cpu_to_be32(count);\n\t\t\tblock_nr = 0;\n\t\t}\n\t\tif (!block_nr || !i) {\n\t\t\t/*\n\t\t\t * Try to free all extents and\n\t\t\t * return only last error\n\t\t\t */\n\t\t\treturn err;\n\t\t}\n\t\ti--;\n\t\textent--;\n\t\tcount = be32_to_cpu(extent->block_count);\n\t}\n}"
  },
  {
    "function_name": "hfsplus_add_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/extents.c",
    "lines": "302-328",
    "snippet": "static int hfsplus_add_extent(struct hfsplus_extent *extent, u32 offset,\n\t\t\t      u32 alloc_block, u32 block_count)\n{\n\tu32 count, start;\n\tint i;\n\n\thfsplus_dump_extent(extent);\n\tfor (i = 0; i < 8; extent++, i++) {\n\t\tcount = be32_to_cpu(extent->block_count);\n\t\tif (offset == count) {\n\t\t\tstart = be32_to_cpu(extent->start_block);\n\t\t\tif (alloc_block != start + count) {\n\t\t\t\tif (++i >= 8)\n\t\t\t\t\treturn -ENOSPC;\n\t\t\t\textent++;\n\t\t\t\textent->start_block = cpu_to_be32(alloc_block);\n\t\t\t} else\n\t\t\t\tblock_count += count;\n\t\t\textent->block_count = cpu_to_be32(block_count);\n\t\t\treturn 0;\n\t\t} else if (offset < count)\n\t\t\tbreak;\n\t\toffset -= count;\n\t}\n\t/* panic? */\n\treturn -EIO;\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "block_count"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "alloc_block"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "extent->start_block"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "extent->block_count"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_dump_extent",
          "args": [
            "extent"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_dump_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/extents.c",
          "lines": "290-300",
          "snippet": "static void hfsplus_dump_extent(struct hfsplus_extent *extent)\n{\n\tint i;\n\n\thfs_dbg(EXTENT, \"   \");\n\tfor (i = 0; i < 8; i++)\n\t\thfs_dbg_cont(EXTENT, \" %u:%u\",\n\t\t\t     be32_to_cpu(extent[i].start_block),\n\t\t\t     be32_to_cpu(extent[i].block_count));\n\thfs_dbg_cont(EXTENT, \"\\n\");\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic void hfsplus_dump_extent(struct hfsplus_extent *extent)\n{\n\tint i;\n\n\thfs_dbg(EXTENT, \"   \");\n\tfor (i = 0; i < 8; i++)\n\t\thfs_dbg_cont(EXTENT, \" %u:%u\",\n\t\t\t     be32_to_cpu(extent[i].start_block),\n\t\t\t     be32_to_cpu(extent[i].block_count));\n\thfs_dbg_cont(EXTENT, \"\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int hfsplus_add_extent(struct hfsplus_extent *extent, u32 offset,\n\t\t\t      u32 alloc_block, u32 block_count)\n{\n\tu32 count, start;\n\tint i;\n\n\thfsplus_dump_extent(extent);\n\tfor (i = 0; i < 8; extent++, i++) {\n\t\tcount = be32_to_cpu(extent->block_count);\n\t\tif (offset == count) {\n\t\t\tstart = be32_to_cpu(extent->start_block);\n\t\t\tif (alloc_block != start + count) {\n\t\t\t\tif (++i >= 8)\n\t\t\t\t\treturn -ENOSPC;\n\t\t\t\textent++;\n\t\t\t\textent->start_block = cpu_to_be32(alloc_block);\n\t\t\t} else\n\t\t\t\tblock_count += count;\n\t\t\textent->block_count = cpu_to_be32(block_count);\n\t\t\treturn 0;\n\t\t} else if (offset < count)\n\t\t\tbreak;\n\t\toffset -= count;\n\t}\n\t/* panic? */\n\treturn -EIO;\n}"
  },
  {
    "function_name": "hfsplus_dump_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/extents.c",
    "lines": "290-300",
    "snippet": "static void hfsplus_dump_extent(struct hfsplus_extent *extent)\n{\n\tint i;\n\n\thfs_dbg(EXTENT, \"   \");\n\tfor (i = 0; i < 8; i++)\n\t\thfs_dbg_cont(EXTENT, \" %u:%u\",\n\t\t\t     be32_to_cpu(extent[i].start_block),\n\t\t\t     be32_to_cpu(extent[i].block_count));\n\thfs_dbg_cont(EXTENT, \"\\n\");\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_dbg_cont",
          "args": [
            "EXTENT",
            "\"\\n\""
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_dbg_cont",
          "args": [
            "EXTENT",
            "\" %u:%u\"",
            "be32_to_cpu(extent[i].start_block)",
            "be32_to_cpu(extent[i].block_count)"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "extent[i].block_count"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "extent[i].start_block"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_dbg",
          "args": [
            "EXTENT",
            "\"   \""
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic void hfsplus_dump_extent(struct hfsplus_extent *extent)\n{\n\tint i;\n\n\thfs_dbg(EXTENT, \"   \");\n\tfor (i = 0; i < 8; i++)\n\t\thfs_dbg_cont(EXTENT, \" %u:%u\",\n\t\t\t     be32_to_cpu(extent[i].start_block),\n\t\t\t     be32_to_cpu(extent[i].block_count));\n\thfs_dbg_cont(EXTENT, \"\\n\");\n}"
  },
  {
    "function_name": "hfsplus_get_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/extents.c",
    "lines": "220-288",
    "snippet": "int hfsplus_get_block(struct inode *inode, sector_t iblock,\n\t\t      struct buffer_head *bh_result, int create)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tint res = -EIO;\n\tu32 ablock, dblock, mask;\n\tsector_t sector;\n\tint was_dirty = 0;\n\n\t/* Convert inode block to disk allocation block */\n\tablock = iblock >> sbi->fs_shift;\n\n\tif (iblock >= hip->fs_blocks) {\n\t\tif (iblock > hip->fs_blocks || !create)\n\t\t\treturn -EIO;\n\t\tif (ablock >= hip->alloc_blocks) {\n\t\t\tres = hfsplus_file_extend(inode, false);\n\t\t\tif (res)\n\t\t\t\treturn res;\n\t\t}\n\t} else\n\t\tcreate = 0;\n\n\tif (ablock < hip->first_blocks) {\n\t\tdblock = hfsplus_ext_find_block(hip->first_extents, ablock);\n\t\tgoto done;\n\t}\n\n\tif (inode->i_ino == HFSPLUS_EXT_CNID)\n\t\treturn -EIO;\n\n\tmutex_lock(&hip->extents_lock);\n\n\t/*\n\t * hfsplus_ext_read_extent will write out a cached extent into\n\t * the extents btree.  In that case we may have to mark the inode\n\t * dirty even for a pure read of an extent here.\n\t */\n\twas_dirty = (hip->extent_state & HFSPLUS_EXT_DIRTY);\n\tres = hfsplus_ext_read_extent(inode, ablock);\n\tif (res) {\n\t\tmutex_unlock(&hip->extents_lock);\n\t\treturn -EIO;\n\t}\n\tdblock = hfsplus_ext_find_block(hip->cached_extents,\n\t\t\t\t\tablock - hip->cached_start);\n\tmutex_unlock(&hip->extents_lock);\n\ndone:\n\thfs_dbg(EXTENT, \"get_block(%lu): %llu - %u\\n\",\n\t\tinode->i_ino, (long long)iblock, dblock);\n\n\tmask = (1 << sbi->fs_shift) - 1;\n\tsector = ((sector_t)dblock << sbi->fs_shift) +\n\t\t  sbi->blockoffset + (iblock & mask);\n\tmap_bh(bh_result, sb, sector);\n\n\tif (create) {\n\t\tset_buffer_new(bh_result);\n\t\thip->phys_size += sb->s_blocksize;\n\t\thip->fs_blocks++;\n\t\tinode_add_bytes(inode, sb->s_blocksize);\n\t}\n\tif (create || was_dirty)\n\t\tmark_inode_dirty(inode);\n\treturn 0;\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_add_bytes",
          "args": [
            "inode",
            "sb->s_blocksize"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "inode_add_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "460-465",
          "snippet": "void inode_add_bytes(struct inode *inode, loff_t bytes)\n{\n\tspin_lock(&inode->i_lock);\n\t__inode_add_bytes(inode, bytes);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid inode_add_bytes(struct inode *inode, loff_t bytes)\n{\n\tspin_lock(&inode->i_lock);\n\t__inode_add_bytes(inode, bytes);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_new",
          "args": [
            "bh_result"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_bh",
          "args": [
            "bh_result",
            "sb",
            "sector"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_dbg",
          "args": [
            "EXTENT",
            "\"get_block(%lu): %llu - %u\\n\"",
            "inode->i_ino",
            "(long long)iblock",
            "dblock"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&hip->extents_lock"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_ext_find_block",
          "args": [
            "hip->cached_extents",
            "ablock - hip->cached_start"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_ext_find_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/extents.c",
          "lines": "50-63",
          "snippet": "static u32 hfsplus_ext_find_block(struct hfsplus_extent *ext, u32 off)\n{\n\tint i;\n\tu32 count;\n\n\tfor (i = 0; i < 8; ext++, i++) {\n\t\tcount = be32_to_cpu(ext->block_count);\n\t\tif (off < count)\n\t\t\treturn be32_to_cpu(ext->start_block) + off;\n\t\toff -= count;\n\t}\n\t/* panic? */\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic u32 hfsplus_ext_find_block(struct hfsplus_extent *ext, u32 off)\n{\n\tint i;\n\tu32 count;\n\n\tfor (i = 0; i < 8; ext++, i++) {\n\t\tcount = be32_to_cpu(ext->block_count);\n\t\tif (off < count)\n\t\t\treturn be32_to_cpu(ext->start_block) + off;\n\t\toff -= count;\n\t}\n\t/* panic? */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&hip->extents_lock"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_ext_read_extent",
          "args": [
            "inode",
            "ablock"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_ext_read_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/extents.c",
          "lines": "201-217",
          "snippet": "static int hfsplus_ext_read_extent(struct inode *inode, u32 block)\n{\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tstruct hfs_find_data fd;\n\tint res;\n\n\tif (block >= hip->cached_start &&\n\t    block < hip->cached_start + hip->cached_blocks)\n\t\treturn 0;\n\n\tres = hfs_find_init(HFSPLUS_SB(inode->i_sb)->ext_tree, &fd);\n\tif (!res) {\n\t\tres = __hfsplus_ext_cache_extent(&fd, inode, block);\n\t\thfs_find_exit(&fd);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int hfsplus_ext_read_extent(struct inode *inode, u32 block)\n{\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tstruct hfs_find_data fd;\n\tint res;\n\n\tif (block >= hip->cached_start &&\n\t    block < hip->cached_start + hip->cached_blocks)\n\t\treturn 0;\n\n\tres = hfs_find_init(HFSPLUS_SB(inode->i_sb)->ext_tree, &fd);\n\tif (!res) {\n\t\tres = __hfsplus_ext_cache_extent(&fd, inode, block);\n\t\thfs_find_exit(&fd);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&hip->extents_lock"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_file_extend",
          "args": [
            "inode",
            "false"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_file_extend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/extents.c",
          "lines": "428-529",
          "snippet": "int hfsplus_file_extend(struct inode *inode, bool zeroout)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tu32 start, len, goal;\n\tint res;\n\n\tif (sbi->alloc_file->i_size * 8 <\n\t    sbi->total_blocks - sbi->free_blocks + 8) {\n\t\t/* extend alloc file */\n\t\tpr_err(\"extend alloc file! (%llu,%u,%u)\\n\",\n\t\t       sbi->alloc_file->i_size * 8,\n\t\t       sbi->total_blocks, sbi->free_blocks);\n\t\treturn -ENOSPC;\n\t}\n\n\tmutex_lock(&hip->extents_lock);\n\tif (hip->alloc_blocks == hip->first_blocks)\n\t\tgoal = hfsplus_ext_lastblock(hip->first_extents);\n\telse {\n\t\tres = hfsplus_ext_read_extent(inode, hip->alloc_blocks);\n\t\tif (res)\n\t\t\tgoto out;\n\t\tgoal = hfsplus_ext_lastblock(hip->cached_extents);\n\t}\n\n\tlen = hip->clump_blocks;\n\tstart = hfsplus_block_allocate(sb, sbi->total_blocks, goal, &len);\n\tif (start >= sbi->total_blocks) {\n\t\tstart = hfsplus_block_allocate(sb, goal, 0, &len);\n\t\tif (start >= goal) {\n\t\t\tres = -ENOSPC;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (zeroout) {\n\t\tres = sb_issue_zeroout(sb, start, len, GFP_NOFS);\n\t\tif (res)\n\t\t\tgoto out;\n\t}\n\n\thfs_dbg(EXTENT, \"extend %lu: %u,%u\\n\", inode->i_ino, start, len);\n\n\tif (hip->alloc_blocks <= hip->first_blocks) {\n\t\tif (!hip->first_blocks) {\n\t\t\thfs_dbg(EXTENT, \"first extents\\n\");\n\t\t\t/* no extents yet */\n\t\t\thip->first_extents[0].start_block = cpu_to_be32(start);\n\t\t\thip->first_extents[0].block_count = cpu_to_be32(len);\n\t\t\tres = 0;\n\t\t} else {\n\t\t\t/* try to append to extents in inode */\n\t\t\tres = hfsplus_add_extent(hip->first_extents,\n\t\t\t\t\t\t hip->alloc_blocks,\n\t\t\t\t\t\t start, len);\n\t\t\tif (res == -ENOSPC)\n\t\t\t\tgoto insert_extent;\n\t\t}\n\t\tif (!res) {\n\t\t\thfsplus_dump_extent(hip->first_extents);\n\t\t\thip->first_blocks += len;\n\t\t}\n\t} else {\n\t\tres = hfsplus_add_extent(hip->cached_extents,\n\t\t\t\t\t hip->alloc_blocks - hip->cached_start,\n\t\t\t\t\t start, len);\n\t\tif (!res) {\n\t\t\thfsplus_dump_extent(hip->cached_extents);\n\t\t\thip->extent_state |= HFSPLUS_EXT_DIRTY;\n\t\t\thip->cached_blocks += len;\n\t\t} else if (res == -ENOSPC)\n\t\t\tgoto insert_extent;\n\t}\nout:\n\tif (!res) {\n\t\thip->alloc_blocks += len;\n\t\tmutex_unlock(&hip->extents_lock);\n\t\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_ALLOC_DIRTY);\n\t\treturn 0;\n\t}\n\tmutex_unlock(&hip->extents_lock);\n\treturn res;\n\ninsert_extent:\n\thfs_dbg(EXTENT, \"insert new extent\\n\");\n\tres = hfsplus_ext_write_extent_locked(inode);\n\tif (res)\n\t\tgoto out;\n\n\tmemset(hip->cached_extents, 0, sizeof(hfsplus_extent_rec));\n\thip->cached_extents[0].start_block = cpu_to_be32(start);\n\thip->cached_extents[0].block_count = cpu_to_be32(len);\n\thfsplus_dump_extent(hip->cached_extents);\n\thip->extent_state |= HFSPLUS_EXT_DIRTY | HFSPLUS_EXT_NEW;\n\thip->cached_start = hip->alloc_blocks;\n\thip->cached_blocks = len;\n\n\tres = 0;\n\tgoto out;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nint hfsplus_file_extend(struct inode *inode, bool zeroout)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tu32 start, len, goal;\n\tint res;\n\n\tif (sbi->alloc_file->i_size * 8 <\n\t    sbi->total_blocks - sbi->free_blocks + 8) {\n\t\t/* extend alloc file */\n\t\tpr_err(\"extend alloc file! (%llu,%u,%u)\\n\",\n\t\t       sbi->alloc_file->i_size * 8,\n\t\t       sbi->total_blocks, sbi->free_blocks);\n\t\treturn -ENOSPC;\n\t}\n\n\tmutex_lock(&hip->extents_lock);\n\tif (hip->alloc_blocks == hip->first_blocks)\n\t\tgoal = hfsplus_ext_lastblock(hip->first_extents);\n\telse {\n\t\tres = hfsplus_ext_read_extent(inode, hip->alloc_blocks);\n\t\tif (res)\n\t\t\tgoto out;\n\t\tgoal = hfsplus_ext_lastblock(hip->cached_extents);\n\t}\n\n\tlen = hip->clump_blocks;\n\tstart = hfsplus_block_allocate(sb, sbi->total_blocks, goal, &len);\n\tif (start >= sbi->total_blocks) {\n\t\tstart = hfsplus_block_allocate(sb, goal, 0, &len);\n\t\tif (start >= goal) {\n\t\t\tres = -ENOSPC;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (zeroout) {\n\t\tres = sb_issue_zeroout(sb, start, len, GFP_NOFS);\n\t\tif (res)\n\t\t\tgoto out;\n\t}\n\n\thfs_dbg(EXTENT, \"extend %lu: %u,%u\\n\", inode->i_ino, start, len);\n\n\tif (hip->alloc_blocks <= hip->first_blocks) {\n\t\tif (!hip->first_blocks) {\n\t\t\thfs_dbg(EXTENT, \"first extents\\n\");\n\t\t\t/* no extents yet */\n\t\t\thip->first_extents[0].start_block = cpu_to_be32(start);\n\t\t\thip->first_extents[0].block_count = cpu_to_be32(len);\n\t\t\tres = 0;\n\t\t} else {\n\t\t\t/* try to append to extents in inode */\n\t\t\tres = hfsplus_add_extent(hip->first_extents,\n\t\t\t\t\t\t hip->alloc_blocks,\n\t\t\t\t\t\t start, len);\n\t\t\tif (res == -ENOSPC)\n\t\t\t\tgoto insert_extent;\n\t\t}\n\t\tif (!res) {\n\t\t\thfsplus_dump_extent(hip->first_extents);\n\t\t\thip->first_blocks += len;\n\t\t}\n\t} else {\n\t\tres = hfsplus_add_extent(hip->cached_extents,\n\t\t\t\t\t hip->alloc_blocks - hip->cached_start,\n\t\t\t\t\t start, len);\n\t\tif (!res) {\n\t\t\thfsplus_dump_extent(hip->cached_extents);\n\t\t\thip->extent_state |= HFSPLUS_EXT_DIRTY;\n\t\t\thip->cached_blocks += len;\n\t\t} else if (res == -ENOSPC)\n\t\t\tgoto insert_extent;\n\t}\nout:\n\tif (!res) {\n\t\thip->alloc_blocks += len;\n\t\tmutex_unlock(&hip->extents_lock);\n\t\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_ALLOC_DIRTY);\n\t\treturn 0;\n\t}\n\tmutex_unlock(&hip->extents_lock);\n\treturn res;\n\ninsert_extent:\n\thfs_dbg(EXTENT, \"insert new extent\\n\");\n\tres = hfsplus_ext_write_extent_locked(inode);\n\tif (res)\n\t\tgoto out;\n\n\tmemset(hip->cached_extents, 0, sizeof(hfsplus_extent_rec));\n\thip->cached_extents[0].start_block = cpu_to_be32(start);\n\thip->cached_extents[0].block_count = cpu_to_be32(len);\n\thfsplus_dump_extent(hip->cached_extents);\n\thip->extent_state |= HFSPLUS_EXT_DIRTY | HFSPLUS_EXT_NEW;\n\thip->cached_start = hip->alloc_blocks;\n\thip->cached_blocks = len;\n\n\tres = 0;\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_I",
          "args": [
            "inode"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "264-267",
          "snippet": "static inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "sb"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nint hfsplus_get_block(struct inode *inode, sector_t iblock,\n\t\t      struct buffer_head *bh_result, int create)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tint res = -EIO;\n\tu32 ablock, dblock, mask;\n\tsector_t sector;\n\tint was_dirty = 0;\n\n\t/* Convert inode block to disk allocation block */\n\tablock = iblock >> sbi->fs_shift;\n\n\tif (iblock >= hip->fs_blocks) {\n\t\tif (iblock > hip->fs_blocks || !create)\n\t\t\treturn -EIO;\n\t\tif (ablock >= hip->alloc_blocks) {\n\t\t\tres = hfsplus_file_extend(inode, false);\n\t\t\tif (res)\n\t\t\t\treturn res;\n\t\t}\n\t} else\n\t\tcreate = 0;\n\n\tif (ablock < hip->first_blocks) {\n\t\tdblock = hfsplus_ext_find_block(hip->first_extents, ablock);\n\t\tgoto done;\n\t}\n\n\tif (inode->i_ino == HFSPLUS_EXT_CNID)\n\t\treturn -EIO;\n\n\tmutex_lock(&hip->extents_lock);\n\n\t/*\n\t * hfsplus_ext_read_extent will write out a cached extent into\n\t * the extents btree.  In that case we may have to mark the inode\n\t * dirty even for a pure read of an extent here.\n\t */\n\twas_dirty = (hip->extent_state & HFSPLUS_EXT_DIRTY);\n\tres = hfsplus_ext_read_extent(inode, ablock);\n\tif (res) {\n\t\tmutex_unlock(&hip->extents_lock);\n\t\treturn -EIO;\n\t}\n\tdblock = hfsplus_ext_find_block(hip->cached_extents,\n\t\t\t\t\tablock - hip->cached_start);\n\tmutex_unlock(&hip->extents_lock);\n\ndone:\n\thfs_dbg(EXTENT, \"get_block(%lu): %llu - %u\\n\",\n\t\tinode->i_ino, (long long)iblock, dblock);\n\n\tmask = (1 << sbi->fs_shift) - 1;\n\tsector = ((sector_t)dblock << sbi->fs_shift) +\n\t\t  sbi->blockoffset + (iblock & mask);\n\tmap_bh(bh_result, sb, sector);\n\n\tif (create) {\n\t\tset_buffer_new(bh_result);\n\t\thip->phys_size += sb->s_blocksize;\n\t\thip->fs_blocks++;\n\t\tinode_add_bytes(inode, sb->s_blocksize);\n\t}\n\tif (create || was_dirty)\n\t\tmark_inode_dirty(inode);\n\treturn 0;\n}"
  },
  {
    "function_name": "hfsplus_ext_read_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/extents.c",
    "lines": "201-217",
    "snippet": "static int hfsplus_ext_read_extent(struct inode *inode, u32 block)\n{\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tstruct hfs_find_data fd;\n\tint res;\n\n\tif (block >= hip->cached_start &&\n\t    block < hip->cached_start + hip->cached_blocks)\n\t\treturn 0;\n\n\tres = hfs_find_init(HFSPLUS_SB(inode->i_sb)->ext_tree, &fd);\n\tif (!res) {\n\t\tres = __hfsplus_ext_cache_extent(&fd, inode, block);\n\t\thfs_find_exit(&fd);\n\t}\n\treturn res;\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_find_exit",
          "args": [
            "&fd"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "43-51",
          "snippet": "void hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nvoid hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__hfsplus_ext_cache_extent",
          "args": [
            "&fd",
            "inode",
            "block"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "__hfsplus_ext_cache_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/extents.c",
          "lines": "172-199",
          "snippet": "static inline int __hfsplus_ext_cache_extent(struct hfs_find_data *fd,\n\t\tstruct inode *inode, u32 block)\n{\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tint res;\n\n\tWARN_ON(!mutex_is_locked(&hip->extents_lock));\n\n\tif (hip->extent_state & HFSPLUS_EXT_DIRTY) {\n\t\tres = __hfsplus_ext_write_extent(inode, fd);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\tres = __hfsplus_ext_read_extent(fd, hip->cached_extents, inode->i_ino,\n\t\t\t\t\tblock, HFSPLUS_IS_RSRC(inode) ?\n\t\t\t\t\t\tHFSPLUS_TYPE_RSRC :\n\t\t\t\t\t\tHFSPLUS_TYPE_DATA);\n\tif (!res) {\n\t\thip->cached_start = be32_to_cpu(fd->key->ext.start_block);\n\t\thip->cached_blocks =\n\t\t\thfsplus_ext_block_count(hip->cached_extents);\n\t} else {\n\t\thip->cached_start = hip->cached_blocks = 0;\n\t\thip->extent_state &= ~(HFSPLUS_EXT_DIRTY | HFSPLUS_EXT_NEW);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic inline int __hfsplus_ext_cache_extent(struct hfs_find_data *fd,\n\t\tstruct inode *inode, u32 block)\n{\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tint res;\n\n\tWARN_ON(!mutex_is_locked(&hip->extents_lock));\n\n\tif (hip->extent_state & HFSPLUS_EXT_DIRTY) {\n\t\tres = __hfsplus_ext_write_extent(inode, fd);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\tres = __hfsplus_ext_read_extent(fd, hip->cached_extents, inode->i_ino,\n\t\t\t\t\tblock, HFSPLUS_IS_RSRC(inode) ?\n\t\t\t\t\t\tHFSPLUS_TYPE_RSRC :\n\t\t\t\t\t\tHFSPLUS_TYPE_DATA);\n\tif (!res) {\n\t\thip->cached_start = be32_to_cpu(fd->key->ext.start_block);\n\t\thip->cached_blocks =\n\t\t\thfsplus_ext_block_count(hip->cached_extents);\n\t} else {\n\t\thip->cached_start = hip->cached_blocks = 0;\n\t\thip->extent_state &= ~(HFSPLUS_EXT_DIRTY | HFSPLUS_EXT_NEW);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_find_init",
          "args": [
            "HFSPLUS_SB(inode->i_sb)->ext_tree",
            "&fd"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "14-41",
          "snippet": "int hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tswitch (tree->cnid) {\n\tcase HFSPLUS_CAT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, CATALOG_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_EXT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, EXTENTS_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, ATTR_BTREE_MUTEX);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nint hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tswitch (tree->cnid) {\n\tcase HFSPLUS_CAT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, CATALOG_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_EXT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, EXTENTS_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, ATTR_BTREE_MUTEX);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_I",
          "args": [
            "inode"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "264-267",
          "snippet": "static inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int hfsplus_ext_read_extent(struct inode *inode, u32 block)\n{\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tstruct hfs_find_data fd;\n\tint res;\n\n\tif (block >= hip->cached_start &&\n\t    block < hip->cached_start + hip->cached_blocks)\n\t\treturn 0;\n\n\tres = hfs_find_init(HFSPLUS_SB(inode->i_sb)->ext_tree, &fd);\n\tif (!res) {\n\t\tres = __hfsplus_ext_cache_extent(&fd, inode, block);\n\t\thfs_find_exit(&fd);\n\t}\n\treturn res;\n}"
  },
  {
    "function_name": "__hfsplus_ext_cache_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/extents.c",
    "lines": "172-199",
    "snippet": "static inline int __hfsplus_ext_cache_extent(struct hfs_find_data *fd,\n\t\tstruct inode *inode, u32 block)\n{\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tint res;\n\n\tWARN_ON(!mutex_is_locked(&hip->extents_lock));\n\n\tif (hip->extent_state & HFSPLUS_EXT_DIRTY) {\n\t\tres = __hfsplus_ext_write_extent(inode, fd);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\tres = __hfsplus_ext_read_extent(fd, hip->cached_extents, inode->i_ino,\n\t\t\t\t\tblock, HFSPLUS_IS_RSRC(inode) ?\n\t\t\t\t\t\tHFSPLUS_TYPE_RSRC :\n\t\t\t\t\t\tHFSPLUS_TYPE_DATA);\n\tif (!res) {\n\t\thip->cached_start = be32_to_cpu(fd->key->ext.start_block);\n\t\thip->cached_blocks =\n\t\t\thfsplus_ext_block_count(hip->cached_extents);\n\t} else {\n\t\thip->cached_start = hip->cached_blocks = 0;\n\t\thip->extent_state &= ~(HFSPLUS_EXT_DIRTY | HFSPLUS_EXT_NEW);\n\t}\n\treturn res;\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfsplus_ext_block_count",
          "args": [
            "hip->cached_extents"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_ext_block_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/extents.c",
          "lines": "65-73",
          "snippet": "static int hfsplus_ext_block_count(struct hfsplus_extent *ext)\n{\n\tint i;\n\tu32 count = 0;\n\n\tfor (i = 0; i < 8; ext++, i++)\n\t\tcount += be32_to_cpu(ext->block_count);\n\treturn count;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int hfsplus_ext_block_count(struct hfsplus_extent *ext)\n{\n\tint i;\n\tu32 count = 0;\n\n\tfor (i = 0; i < 8; ext++, i++)\n\t\tcount += be32_to_cpu(ext->block_count);\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "fd->key->ext.start_block"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__hfsplus_ext_read_extent",
          "args": [
            "fd",
            "hip->cached_extents",
            "inode->i_ino",
            "block",
            "HFSPLUS_IS_RSRC(inode) ?\n\t\t\t\t\t\tHFSPLUS_TYPE_RSRC :\n\t\t\t\t\t\tHFSPLUS_TYPE_DATA"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "__hfsplus_ext_read_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/extents.c",
          "lines": "151-170",
          "snippet": "static inline int __hfsplus_ext_read_extent(struct hfs_find_data *fd,\n\t\t\t\t\t    struct hfsplus_extent *extent,\n\t\t\t\t\t    u32 cnid, u32 block, u8 type)\n{\n\tint res;\n\n\thfsplus_ext_build_key(fd->search_key, cnid, block, type);\n\tfd->key->ext.cnid = 0;\n\tres = hfs_brec_find(fd, hfs_find_rec_by_key);\n\tif (res && res != -ENOENT)\n\t\treturn res;\n\tif (fd->key->ext.cnid != fd->search_key->ext.cnid ||\n\t    fd->key->ext.fork_type != fd->search_key->ext.fork_type)\n\t\treturn -ENOENT;\n\tif (fd->entrylength != sizeof(hfsplus_extent_rec))\n\t\treturn -EIO;\n\thfs_bnode_read(fd->bnode, extent, fd->entryoffset,\n\t\tsizeof(hfsplus_extent_rec));\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic inline int __hfsplus_ext_read_extent(struct hfs_find_data *fd,\n\t\t\t\t\t    struct hfsplus_extent *extent,\n\t\t\t\t\t    u32 cnid, u32 block, u8 type)\n{\n\tint res;\n\n\thfsplus_ext_build_key(fd->search_key, cnid, block, type);\n\tfd->key->ext.cnid = 0;\n\tres = hfs_brec_find(fd, hfs_find_rec_by_key);\n\tif (res && res != -ENOENT)\n\t\treturn res;\n\tif (fd->key->ext.cnid != fd->search_key->ext.cnid ||\n\t    fd->key->ext.fork_type != fd->search_key->ext.fork_type)\n\t\treturn -ENOENT;\n\tif (fd->entrylength != sizeof(hfsplus_extent_rec))\n\t\treturn -EIO;\n\thfs_bnode_read(fd->bnode, extent, fd->entryoffset,\n\t\tsizeof(hfsplus_extent_rec));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_IS_RSRC",
          "args": [
            "inode"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__hfsplus_ext_write_extent",
          "args": [
            "inode",
            "fd"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "__hfsplus_ext_write_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/extents.c",
          "lines": "86-122",
          "snippet": "static int __hfsplus_ext_write_extent(struct inode *inode,\n\t\tstruct hfs_find_data *fd)\n{\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tint res;\n\n\tWARN_ON(!mutex_is_locked(&hip->extents_lock));\n\n\thfsplus_ext_build_key(fd->search_key, inode->i_ino, hip->cached_start,\n\t\t\t      HFSPLUS_IS_RSRC(inode) ?\n\t\t\t\tHFSPLUS_TYPE_RSRC : HFSPLUS_TYPE_DATA);\n\n\tres = hfs_brec_find(fd, hfs_find_rec_by_key);\n\tif (hip->extent_state & HFSPLUS_EXT_NEW) {\n\t\tif (res != -ENOENT)\n\t\t\treturn res;\n\t\thfs_brec_insert(fd, hip->cached_extents,\n\t\t\t\tsizeof(hfsplus_extent_rec));\n\t\thip->extent_state &= ~(HFSPLUS_EXT_DIRTY | HFSPLUS_EXT_NEW);\n\t} else {\n\t\tif (res)\n\t\t\treturn res;\n\t\thfs_bnode_write(fd->bnode, hip->cached_extents,\n\t\t\t\tfd->entryoffset, fd->entrylength);\n\t\thip->extent_state &= ~HFSPLUS_EXT_DIRTY;\n\t}\n\n\t/*\n\t * We can't just use hfsplus_mark_inode_dirty here, because we\n\t * also get called from hfsplus_write_inode, which should not\n\t * redirty the inode.  Instead the callers have to be careful\n\t * to explicily mark the inode dirty, too.\n\t */\n\tset_bit(HFSPLUS_I_EXT_DIRTY, &hip->flags);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int __hfsplus_ext_write_extent(struct inode *inode,\n\t\tstruct hfs_find_data *fd)\n{\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tint res;\n\n\tWARN_ON(!mutex_is_locked(&hip->extents_lock));\n\n\thfsplus_ext_build_key(fd->search_key, inode->i_ino, hip->cached_start,\n\t\t\t      HFSPLUS_IS_RSRC(inode) ?\n\t\t\t\tHFSPLUS_TYPE_RSRC : HFSPLUS_TYPE_DATA);\n\n\tres = hfs_brec_find(fd, hfs_find_rec_by_key);\n\tif (hip->extent_state & HFSPLUS_EXT_NEW) {\n\t\tif (res != -ENOENT)\n\t\t\treturn res;\n\t\thfs_brec_insert(fd, hip->cached_extents,\n\t\t\t\tsizeof(hfsplus_extent_rec));\n\t\thip->extent_state &= ~(HFSPLUS_EXT_DIRTY | HFSPLUS_EXT_NEW);\n\t} else {\n\t\tif (res)\n\t\t\treturn res;\n\t\thfs_bnode_write(fd->bnode, hip->cached_extents,\n\t\t\t\tfd->entryoffset, fd->entrylength);\n\t\thip->extent_state &= ~HFSPLUS_EXT_DIRTY;\n\t}\n\n\t/*\n\t * We can't just use hfsplus_mark_inode_dirty here, because we\n\t * also get called from hfsplus_write_inode, which should not\n\t * redirty the inode.  Instead the callers have to be careful\n\t * to explicily mark the inode dirty, too.\n\t */\n\tset_bit(HFSPLUS_I_EXT_DIRTY, &hip->flags);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!mutex_is_locked(&hip->extents_lock)"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&hip->extents_lock"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFSPLUS_I",
          "args": [
            "inode"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "264-267",
          "snippet": "static inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic inline int __hfsplus_ext_cache_extent(struct hfs_find_data *fd,\n\t\tstruct inode *inode, u32 block)\n{\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tint res;\n\n\tWARN_ON(!mutex_is_locked(&hip->extents_lock));\n\n\tif (hip->extent_state & HFSPLUS_EXT_DIRTY) {\n\t\tres = __hfsplus_ext_write_extent(inode, fd);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\tres = __hfsplus_ext_read_extent(fd, hip->cached_extents, inode->i_ino,\n\t\t\t\t\tblock, HFSPLUS_IS_RSRC(inode) ?\n\t\t\t\t\t\tHFSPLUS_TYPE_RSRC :\n\t\t\t\t\t\tHFSPLUS_TYPE_DATA);\n\tif (!res) {\n\t\thip->cached_start = be32_to_cpu(fd->key->ext.start_block);\n\t\thip->cached_blocks =\n\t\t\thfsplus_ext_block_count(hip->cached_extents);\n\t} else {\n\t\thip->cached_start = hip->cached_blocks = 0;\n\t\thip->extent_state &= ~(HFSPLUS_EXT_DIRTY | HFSPLUS_EXT_NEW);\n\t}\n\treturn res;\n}"
  },
  {
    "function_name": "__hfsplus_ext_read_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/extents.c",
    "lines": "151-170",
    "snippet": "static inline int __hfsplus_ext_read_extent(struct hfs_find_data *fd,\n\t\t\t\t\t    struct hfsplus_extent *extent,\n\t\t\t\t\t    u32 cnid, u32 block, u8 type)\n{\n\tint res;\n\n\thfsplus_ext_build_key(fd->search_key, cnid, block, type);\n\tfd->key->ext.cnid = 0;\n\tres = hfs_brec_find(fd, hfs_find_rec_by_key);\n\tif (res && res != -ENOENT)\n\t\treturn res;\n\tif (fd->key->ext.cnid != fd->search_key->ext.cnid ||\n\t    fd->key->ext.fork_type != fd->search_key->ext.fork_type)\n\t\treturn -ENOENT;\n\tif (fd->entrylength != sizeof(hfsplus_extent_rec))\n\t\treturn -EIO;\n\thfs_bnode_read(fd->bnode, extent, fd->entryoffset,\n\t\tsizeof(hfsplus_extent_rec));\n\treturn 0;\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_bnode_read",
          "args": [
            "fd->bnode",
            "extent",
            "fd->entryoffset",
            "sizeof(hfsplus_extent_rec)"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "21-40",
          "snippet": "void hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(buf, kmap(*pagep) + off, l);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(buf, kmap(*++pagep), l);\n\t\tkunmap(*pagep);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(buf, kmap(*pagep) + off, l);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(buf, kmap(*++pagep), l);\n\t\tkunmap(*pagep);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_brec_find",
          "args": [
            "fd",
            "hfs_find_rec_by_key"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "165-217",
          "snippet": "int hfs_brec_find(struct hfs_find_data *fd, search_strategy_t do_key_compare)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\tu32 nidx, parent;\n\t__be32 data;\n\tint height, res;\n\n\ttree = fd->tree;\n\tif (fd->bnode)\n\t\thfs_bnode_put(fd->bnode);\n\tfd->bnode = NULL;\n\tnidx = tree->root;\n\tif (!nidx)\n\t\treturn -ENOENT;\n\theight = tree->depth;\n\tres = 0;\n\tparent = 0;\n\tfor (;;) {\n\t\tbnode = hfs_bnode_find(tree, nidx);\n\t\tif (IS_ERR(bnode)) {\n\t\t\tres = PTR_ERR(bnode);\n\t\t\tbnode = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (bnode->height != height)\n\t\t\tgoto invalid;\n\t\tif (bnode->type != (--height ? HFS_NODE_INDEX : HFS_NODE_LEAF))\n\t\t\tgoto invalid;\n\t\tbnode->parent = parent;\n\n\t\tres = __hfs_brec_find(bnode, fd, do_key_compare);\n\t\tif (!height)\n\t\t\tbreak;\n\t\tif (fd->record < 0)\n\t\t\tgoto release;\n\n\t\tparent = nidx;\n\t\thfs_bnode_read(bnode, &data, fd->entryoffset, 4);\n\t\tnidx = be32_to_cpu(data);\n\t\thfs_bnode_put(bnode);\n\t}\n\tfd->bnode = bnode;\n\treturn res;\n\ninvalid:\n\tpr_err(\"inconsistency in B*Tree (%d,%d,%d,%u,%u)\\n\",\n\t\theight, bnode->height, bnode->type, nidx, parent);\n\tres = -EIO;\nrelease:\n\thfs_bnode_put(bnode);\n\treturn res;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nint hfs_brec_find(struct hfs_find_data *fd, search_strategy_t do_key_compare)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\tu32 nidx, parent;\n\t__be32 data;\n\tint height, res;\n\n\ttree = fd->tree;\n\tif (fd->bnode)\n\t\thfs_bnode_put(fd->bnode);\n\tfd->bnode = NULL;\n\tnidx = tree->root;\n\tif (!nidx)\n\t\treturn -ENOENT;\n\theight = tree->depth;\n\tres = 0;\n\tparent = 0;\n\tfor (;;) {\n\t\tbnode = hfs_bnode_find(tree, nidx);\n\t\tif (IS_ERR(bnode)) {\n\t\t\tres = PTR_ERR(bnode);\n\t\t\tbnode = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (bnode->height != height)\n\t\t\tgoto invalid;\n\t\tif (bnode->type != (--height ? HFS_NODE_INDEX : HFS_NODE_LEAF))\n\t\t\tgoto invalid;\n\t\tbnode->parent = parent;\n\n\t\tres = __hfs_brec_find(bnode, fd, do_key_compare);\n\t\tif (!height)\n\t\t\tbreak;\n\t\tif (fd->record < 0)\n\t\t\tgoto release;\n\n\t\tparent = nidx;\n\t\thfs_bnode_read(bnode, &data, fd->entryoffset, 4);\n\t\tnidx = be32_to_cpu(data);\n\t\thfs_bnode_put(bnode);\n\t}\n\tfd->bnode = bnode;\n\treturn res;\n\ninvalid:\n\tpr_err(\"inconsistency in B*Tree (%d,%d,%d,%u,%u)\\n\",\n\t\theight, bnode->height, bnode->type, nidx, parent);\n\tres = -EIO;\nrelease:\n\thfs_bnode_put(bnode);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_ext_build_key",
          "args": [
            "fd->search_key",
            "cnid",
            "block",
            "type"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_ext_build_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/extents.c",
          "lines": "40-48",
          "snippet": "static void hfsplus_ext_build_key(hfsplus_btree_key *key, u32 cnid,\n\t\t\t\t  u32 block, u8 type)\n{\n\tkey->key_len = cpu_to_be16(HFSPLUS_EXT_KEYLEN - 2);\n\tkey->ext.cnid = cpu_to_be32(cnid);\n\tkey->ext.start_block = cpu_to_be32(block);\n\tkey->ext.fork_type = type;\n\tkey->ext.pad = 0;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic void hfsplus_ext_build_key(hfsplus_btree_key *key, u32 cnid,\n\t\t\t\t  u32 block, u8 type)\n{\n\tkey->key_len = cpu_to_be16(HFSPLUS_EXT_KEYLEN - 2);\n\tkey->ext.cnid = cpu_to_be32(cnid);\n\tkey->ext.start_block = cpu_to_be32(block);\n\tkey->ext.fork_type = type;\n\tkey->ext.pad = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic inline int __hfsplus_ext_read_extent(struct hfs_find_data *fd,\n\t\t\t\t\t    struct hfsplus_extent *extent,\n\t\t\t\t\t    u32 cnid, u32 block, u8 type)\n{\n\tint res;\n\n\thfsplus_ext_build_key(fd->search_key, cnid, block, type);\n\tfd->key->ext.cnid = 0;\n\tres = hfs_brec_find(fd, hfs_find_rec_by_key);\n\tif (res && res != -ENOENT)\n\t\treturn res;\n\tif (fd->key->ext.cnid != fd->search_key->ext.cnid ||\n\t    fd->key->ext.fork_type != fd->search_key->ext.fork_type)\n\t\treturn -ENOENT;\n\tif (fd->entrylength != sizeof(hfsplus_extent_rec))\n\t\treturn -EIO;\n\thfs_bnode_read(fd->bnode, extent, fd->entryoffset,\n\t\tsizeof(hfsplus_extent_rec));\n\treturn 0;\n}"
  },
  {
    "function_name": "hfsplus_ext_write_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/extents.c",
    "lines": "140-149",
    "snippet": "int hfsplus_ext_write_extent(struct inode *inode)\n{\n\tint res;\n\n\tmutex_lock(&HFSPLUS_I(inode)->extents_lock);\n\tres = hfsplus_ext_write_extent_locked(inode);\n\tmutex_unlock(&HFSPLUS_I(inode)->extents_lock);\n\n\treturn res;\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&HFSPLUS_I(inode)->extents_lock"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFSPLUS_I",
          "args": [
            "inode"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "264-267",
          "snippet": "static inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_ext_write_extent_locked",
          "args": [
            "inode"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_ext_write_extent_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/extents.c",
          "lines": "124-138",
          "snippet": "static int hfsplus_ext_write_extent_locked(struct inode *inode)\n{\n\tint res = 0;\n\n\tif (HFSPLUS_I(inode)->extent_state & HFSPLUS_EXT_DIRTY) {\n\t\tstruct hfs_find_data fd;\n\n\t\tres = hfs_find_init(HFSPLUS_SB(inode->i_sb)->ext_tree, &fd);\n\t\tif (res)\n\t\t\treturn res;\n\t\tres = __hfsplus_ext_write_extent(inode, &fd);\n\t\thfs_find_exit(&fd);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int hfsplus_ext_write_extent_locked(struct inode *inode)\n{\n\tint res = 0;\n\n\tif (HFSPLUS_I(inode)->extent_state & HFSPLUS_EXT_DIRTY) {\n\t\tstruct hfs_find_data fd;\n\n\t\tres = hfs_find_init(HFSPLUS_SB(inode->i_sb)->ext_tree, &fd);\n\t\tif (res)\n\t\t\treturn res;\n\t\tres = __hfsplus_ext_write_extent(inode, &fd);\n\t\thfs_find_exit(&fd);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&HFSPLUS_I(inode)->extents_lock"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nint hfsplus_ext_write_extent(struct inode *inode)\n{\n\tint res;\n\n\tmutex_lock(&HFSPLUS_I(inode)->extents_lock);\n\tres = hfsplus_ext_write_extent_locked(inode);\n\tmutex_unlock(&HFSPLUS_I(inode)->extents_lock);\n\n\treturn res;\n}"
  },
  {
    "function_name": "hfsplus_ext_write_extent_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/extents.c",
    "lines": "124-138",
    "snippet": "static int hfsplus_ext_write_extent_locked(struct inode *inode)\n{\n\tint res = 0;\n\n\tif (HFSPLUS_I(inode)->extent_state & HFSPLUS_EXT_DIRTY) {\n\t\tstruct hfs_find_data fd;\n\n\t\tres = hfs_find_init(HFSPLUS_SB(inode->i_sb)->ext_tree, &fd);\n\t\tif (res)\n\t\t\treturn res;\n\t\tres = __hfsplus_ext_write_extent(inode, &fd);\n\t\thfs_find_exit(&fd);\n\t}\n\treturn res;\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_find_exit",
          "args": [
            "&fd"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "43-51",
          "snippet": "void hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nvoid hfs_find_exit(struct hfs_find_data *fd)\n{\n\thfs_bnode_put(fd->bnode);\n\tkfree(fd->search_key);\n\thfs_dbg(BNODE_REFS, \"find_exit: %d (%p)\\n\",\n\t\tfd->tree->cnid, __builtin_return_address(0));\n\tmutex_unlock(&fd->tree->tree_lock);\n\tfd->tree = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__hfsplus_ext_write_extent",
          "args": [
            "inode",
            "&fd"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "__hfsplus_ext_write_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/extents.c",
          "lines": "86-122",
          "snippet": "static int __hfsplus_ext_write_extent(struct inode *inode,\n\t\tstruct hfs_find_data *fd)\n{\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tint res;\n\n\tWARN_ON(!mutex_is_locked(&hip->extents_lock));\n\n\thfsplus_ext_build_key(fd->search_key, inode->i_ino, hip->cached_start,\n\t\t\t      HFSPLUS_IS_RSRC(inode) ?\n\t\t\t\tHFSPLUS_TYPE_RSRC : HFSPLUS_TYPE_DATA);\n\n\tres = hfs_brec_find(fd, hfs_find_rec_by_key);\n\tif (hip->extent_state & HFSPLUS_EXT_NEW) {\n\t\tif (res != -ENOENT)\n\t\t\treturn res;\n\t\thfs_brec_insert(fd, hip->cached_extents,\n\t\t\t\tsizeof(hfsplus_extent_rec));\n\t\thip->extent_state &= ~(HFSPLUS_EXT_DIRTY | HFSPLUS_EXT_NEW);\n\t} else {\n\t\tif (res)\n\t\t\treturn res;\n\t\thfs_bnode_write(fd->bnode, hip->cached_extents,\n\t\t\t\tfd->entryoffset, fd->entrylength);\n\t\thip->extent_state &= ~HFSPLUS_EXT_DIRTY;\n\t}\n\n\t/*\n\t * We can't just use hfsplus_mark_inode_dirty here, because we\n\t * also get called from hfsplus_write_inode, which should not\n\t * redirty the inode.  Instead the callers have to be careful\n\t * to explicily mark the inode dirty, too.\n\t */\n\tset_bit(HFSPLUS_I_EXT_DIRTY, &hip->flags);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int __hfsplus_ext_write_extent(struct inode *inode,\n\t\tstruct hfs_find_data *fd)\n{\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tint res;\n\n\tWARN_ON(!mutex_is_locked(&hip->extents_lock));\n\n\thfsplus_ext_build_key(fd->search_key, inode->i_ino, hip->cached_start,\n\t\t\t      HFSPLUS_IS_RSRC(inode) ?\n\t\t\t\tHFSPLUS_TYPE_RSRC : HFSPLUS_TYPE_DATA);\n\n\tres = hfs_brec_find(fd, hfs_find_rec_by_key);\n\tif (hip->extent_state & HFSPLUS_EXT_NEW) {\n\t\tif (res != -ENOENT)\n\t\t\treturn res;\n\t\thfs_brec_insert(fd, hip->cached_extents,\n\t\t\t\tsizeof(hfsplus_extent_rec));\n\t\thip->extent_state &= ~(HFSPLUS_EXT_DIRTY | HFSPLUS_EXT_NEW);\n\t} else {\n\t\tif (res)\n\t\t\treturn res;\n\t\thfs_bnode_write(fd->bnode, hip->cached_extents,\n\t\t\t\tfd->entryoffset, fd->entrylength);\n\t\thip->extent_state &= ~HFSPLUS_EXT_DIRTY;\n\t}\n\n\t/*\n\t * We can't just use hfsplus_mark_inode_dirty here, because we\n\t * also get called from hfsplus_write_inode, which should not\n\t * redirty the inode.  Instead the callers have to be careful\n\t * to explicily mark the inode dirty, too.\n\t */\n\tset_bit(HFSPLUS_I_EXT_DIRTY, &hip->flags);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_find_init",
          "args": [
            "HFSPLUS_SB(inode->i_sb)->ext_tree",
            "&fd"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_find_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "14-41",
          "snippet": "int hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tswitch (tree->cnid) {\n\tcase HFSPLUS_CAT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, CATALOG_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_EXT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, EXTENTS_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, ATTR_BTREE_MUTEX);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nint hfs_find_init(struct hfs_btree *tree, struct hfs_find_data *fd)\n{\n\tvoid *ptr;\n\n\tfd->tree = tree;\n\tfd->bnode = NULL;\n\tptr = kmalloc(tree->max_key_len * 2 + 4, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\tfd->search_key = ptr;\n\tfd->key = ptr + tree->max_key_len + 2;\n\thfs_dbg(BNODE_REFS, \"find_init: %d (%p)\\n\",\n\t\ttree->cnid, __builtin_return_address(0));\n\tswitch (tree->cnid) {\n\tcase HFSPLUS_CAT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, CATALOG_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_EXT_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, EXTENTS_BTREE_MUTEX);\n\t\tbreak;\n\tcase HFSPLUS_ATTR_CNID:\n\t\tmutex_lock_nested(&tree->tree_lock, ATTR_BTREE_MUTEX);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_I",
          "args": [
            "inode"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "264-267",
          "snippet": "static inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int hfsplus_ext_write_extent_locked(struct inode *inode)\n{\n\tint res = 0;\n\n\tif (HFSPLUS_I(inode)->extent_state & HFSPLUS_EXT_DIRTY) {\n\t\tstruct hfs_find_data fd;\n\n\t\tres = hfs_find_init(HFSPLUS_SB(inode->i_sb)->ext_tree, &fd);\n\t\tif (res)\n\t\t\treturn res;\n\t\tres = __hfsplus_ext_write_extent(inode, &fd);\n\t\thfs_find_exit(&fd);\n\t}\n\treturn res;\n}"
  },
  {
    "function_name": "__hfsplus_ext_write_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/extents.c",
    "lines": "86-122",
    "snippet": "static int __hfsplus_ext_write_extent(struct inode *inode,\n\t\tstruct hfs_find_data *fd)\n{\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tint res;\n\n\tWARN_ON(!mutex_is_locked(&hip->extents_lock));\n\n\thfsplus_ext_build_key(fd->search_key, inode->i_ino, hip->cached_start,\n\t\t\t      HFSPLUS_IS_RSRC(inode) ?\n\t\t\t\tHFSPLUS_TYPE_RSRC : HFSPLUS_TYPE_DATA);\n\n\tres = hfs_brec_find(fd, hfs_find_rec_by_key);\n\tif (hip->extent_state & HFSPLUS_EXT_NEW) {\n\t\tif (res != -ENOENT)\n\t\t\treturn res;\n\t\thfs_brec_insert(fd, hip->cached_extents,\n\t\t\t\tsizeof(hfsplus_extent_rec));\n\t\thip->extent_state &= ~(HFSPLUS_EXT_DIRTY | HFSPLUS_EXT_NEW);\n\t} else {\n\t\tif (res)\n\t\t\treturn res;\n\t\thfs_bnode_write(fd->bnode, hip->cached_extents,\n\t\t\t\tfd->entryoffset, fd->entrylength);\n\t\thip->extent_state &= ~HFSPLUS_EXT_DIRTY;\n\t}\n\n\t/*\n\t * We can't just use hfsplus_mark_inode_dirty here, because we\n\t * also get called from hfsplus_write_inode, which should not\n\t * redirty the inode.  Instead the callers have to be careful\n\t * to explicily mark the inode dirty, too.\n\t */\n\tset_bit(HFSPLUS_I_EXT_DIRTY, &hip->flags);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "HFSPLUS_I_EXT_DIRTY",
            "&hip->flags"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_write",
          "args": [
            "fd->bnode",
            "hip->cached_extents",
            "fd->entryoffset",
            "fd->entrylength"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "74-95",
          "snippet": "void hfs_bnode_write(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(kmap(*pagep) + off, buf, l);\n\tset_page_dirty(*pagep);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(kmap(*++pagep), buf, l);\n\t\tset_page_dirty(*pagep);\n\t\tkunmap(*pagep);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_write(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(kmap(*pagep) + off, buf, l);\n\tset_page_dirty(*pagep);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(kmap(*++pagep), buf, l);\n\t\tset_page_dirty(*pagep);\n\t\tkunmap(*pagep);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_brec_insert",
          "args": [
            "fd",
            "hip->cached_extents",
            "sizeof(hfsplus_extent_rec)"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/brec.c",
          "lines": "62-175",
          "snippet": "int hfs_brec_insert(struct hfs_find_data *fd, void *entry, int entry_len)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *new_node;\n\tint size, key_len, rec;\n\tint data_off, end_off;\n\tint idx_rec_off, data_rec_off, end_rec_off;\n\t__be32 cnid;\n\n\ttree = fd->tree;\n\tif (!fd->bnode) {\n\t\tif (!tree->root)\n\t\t\thfs_btree_inc_height(tree);\n\t\tfd->bnode = hfs_bnode_find(tree, tree->leaf_head);\n\t\tif (IS_ERR(fd->bnode))\n\t\t\treturn PTR_ERR(fd->bnode);\n\t\tfd->record = -1;\n\t}\n\tnew_node = NULL;\n\tkey_len = be16_to_cpu(fd->search_key->key_len) + 2;\nagain:\n\t/* new record idx and complete record size */\n\trec = fd->record + 1;\n\tsize = key_len + entry_len;\n\n\tnode = fd->bnode;\n\thfs_bnode_dump(node);\n\t/* get last offset */\n\tend_rec_off = tree->node_size - (node->num_recs + 1) * 2;\n\tend_off = hfs_bnode_read_u16(node, end_rec_off);\n\tend_rec_off -= 2;\n\thfs_dbg(BNODE_MOD, \"insert_rec: %d, %d, %d, %d\\n\",\n\t\trec, size, end_off, end_rec_off);\n\tif (size > end_rec_off - end_off) {\n\t\tif (new_node)\n\t\t\tpanic(\"not enough room!\\n\");\n\t\tnew_node = hfs_bnode_split(fd);\n\t\tif (IS_ERR(new_node))\n\t\t\treturn PTR_ERR(new_node);\n\t\tgoto again;\n\t}\n\tif (node->type == HFS_NODE_LEAF) {\n\t\ttree->leaf_count++;\n\t\tmark_inode_dirty(tree->inode);\n\t}\n\tnode->num_recs++;\n\t/* write new last offset */\n\thfs_bnode_write_u16(node,\n\t\toffsetof(struct hfs_bnode_desc, num_recs),\n\t\tnode->num_recs);\n\thfs_bnode_write_u16(node, end_rec_off, end_off + size);\n\tdata_off = end_off;\n\tdata_rec_off = end_rec_off + 2;\n\tidx_rec_off = tree->node_size - (rec + 1) * 2;\n\tif (idx_rec_off == data_rec_off)\n\t\tgoto skip;\n\t/* move all following entries */\n\tdo {\n\t\tdata_off = hfs_bnode_read_u16(node, data_rec_off + 2);\n\t\thfs_bnode_write_u16(node, data_rec_off, data_off + size);\n\t\tdata_rec_off += 2;\n\t} while (data_rec_off < idx_rec_off);\n\n\t/* move data away */\n\thfs_bnode_move(node, data_off + size, data_off,\n\t\t       end_off - data_off);\n\nskip:\n\thfs_bnode_write(node, fd->search_key, data_off, key_len);\n\thfs_bnode_write(node, entry, data_off + key_len, entry_len);\n\thfs_bnode_dump(node);\n\n\t/*\n\t * update parent key if we inserted a key\n\t * at the start of the node and it is not the new node\n\t */\n\tif (!rec && new_node != node) {\n\t\thfs_bnode_read_key(node, fd->search_key, data_off + size);\n\t\thfs_brec_update_parent(fd);\n\t}\n\n\tif (new_node) {\n\t\thfs_bnode_put(fd->bnode);\n\t\tif (!new_node->parent) {\n\t\t\thfs_btree_inc_height(tree);\n\t\t\tnew_node->parent = tree->root;\n\t\t}\n\t\tfd->bnode = hfs_bnode_find(tree, new_node->parent);\n\n\t\t/* create index data entry */\n\t\tcnid = cpu_to_be32(new_node->this);\n\t\tentry = &cnid;\n\t\tentry_len = sizeof(cnid);\n\n\t\t/* get index key */\n\t\thfs_bnode_read_key(new_node, fd->search_key, 14);\n\t\t__hfs_brec_find(fd->bnode, fd, hfs_find_rec_by_key);\n\n\t\thfs_bnode_put(new_node);\n\t\tnew_node = NULL;\n\n\t\tif ((tree->attributes & HFS_TREE_VARIDXKEYS) ||\n\t\t\t\t(tree->cnid == HFSPLUS_ATTR_CNID))\n\t\t\tkey_len = be16_to_cpu(fd->search_key->key_len) + 2;\n\t\telse {\n\t\t\tfd->search_key->key_len =\n\t\t\t\tcpu_to_be16(tree->max_key_len);\n\t\t\tkey_len = tree->max_key_len + 2;\n\t\t}\n\t\tgoto again;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd);",
            "static int hfs_brec_update_parent(struct hfs_find_data *fd);",
            "static int hfs_btree_inc_height(struct hfs_btree *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic struct hfs_bnode *hfs_bnode_split(struct hfs_find_data *fd);\nstatic int hfs_brec_update_parent(struct hfs_find_data *fd);\nstatic int hfs_btree_inc_height(struct hfs_btree *);\n\nint hfs_brec_insert(struct hfs_find_data *fd, void *entry, int entry_len)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *node, *new_node;\n\tint size, key_len, rec;\n\tint data_off, end_off;\n\tint idx_rec_off, data_rec_off, end_rec_off;\n\t__be32 cnid;\n\n\ttree = fd->tree;\n\tif (!fd->bnode) {\n\t\tif (!tree->root)\n\t\t\thfs_btree_inc_height(tree);\n\t\tfd->bnode = hfs_bnode_find(tree, tree->leaf_head);\n\t\tif (IS_ERR(fd->bnode))\n\t\t\treturn PTR_ERR(fd->bnode);\n\t\tfd->record = -1;\n\t}\n\tnew_node = NULL;\n\tkey_len = be16_to_cpu(fd->search_key->key_len) + 2;\nagain:\n\t/* new record idx and complete record size */\n\trec = fd->record + 1;\n\tsize = key_len + entry_len;\n\n\tnode = fd->bnode;\n\thfs_bnode_dump(node);\n\t/* get last offset */\n\tend_rec_off = tree->node_size - (node->num_recs + 1) * 2;\n\tend_off = hfs_bnode_read_u16(node, end_rec_off);\n\tend_rec_off -= 2;\n\thfs_dbg(BNODE_MOD, \"insert_rec: %d, %d, %d, %d\\n\",\n\t\trec, size, end_off, end_rec_off);\n\tif (size > end_rec_off - end_off) {\n\t\tif (new_node)\n\t\t\tpanic(\"not enough room!\\n\");\n\t\tnew_node = hfs_bnode_split(fd);\n\t\tif (IS_ERR(new_node))\n\t\t\treturn PTR_ERR(new_node);\n\t\tgoto again;\n\t}\n\tif (node->type == HFS_NODE_LEAF) {\n\t\ttree->leaf_count++;\n\t\tmark_inode_dirty(tree->inode);\n\t}\n\tnode->num_recs++;\n\t/* write new last offset */\n\thfs_bnode_write_u16(node,\n\t\toffsetof(struct hfs_bnode_desc, num_recs),\n\t\tnode->num_recs);\n\thfs_bnode_write_u16(node, end_rec_off, end_off + size);\n\tdata_off = end_off;\n\tdata_rec_off = end_rec_off + 2;\n\tidx_rec_off = tree->node_size - (rec + 1) * 2;\n\tif (idx_rec_off == data_rec_off)\n\t\tgoto skip;\n\t/* move all following entries */\n\tdo {\n\t\tdata_off = hfs_bnode_read_u16(node, data_rec_off + 2);\n\t\thfs_bnode_write_u16(node, data_rec_off, data_off + size);\n\t\tdata_rec_off += 2;\n\t} while (data_rec_off < idx_rec_off);\n\n\t/* move data away */\n\thfs_bnode_move(node, data_off + size, data_off,\n\t\t       end_off - data_off);\n\nskip:\n\thfs_bnode_write(node, fd->search_key, data_off, key_len);\n\thfs_bnode_write(node, entry, data_off + key_len, entry_len);\n\thfs_bnode_dump(node);\n\n\t/*\n\t * update parent key if we inserted a key\n\t * at the start of the node and it is not the new node\n\t */\n\tif (!rec && new_node != node) {\n\t\thfs_bnode_read_key(node, fd->search_key, data_off + size);\n\t\thfs_brec_update_parent(fd);\n\t}\n\n\tif (new_node) {\n\t\thfs_bnode_put(fd->bnode);\n\t\tif (!new_node->parent) {\n\t\t\thfs_btree_inc_height(tree);\n\t\t\tnew_node->parent = tree->root;\n\t\t}\n\t\tfd->bnode = hfs_bnode_find(tree, new_node->parent);\n\n\t\t/* create index data entry */\n\t\tcnid = cpu_to_be32(new_node->this);\n\t\tentry = &cnid;\n\t\tentry_len = sizeof(cnid);\n\n\t\t/* get index key */\n\t\thfs_bnode_read_key(new_node, fd->search_key, 14);\n\t\t__hfs_brec_find(fd->bnode, fd, hfs_find_rec_by_key);\n\n\t\thfs_bnode_put(new_node);\n\t\tnew_node = NULL;\n\n\t\tif ((tree->attributes & HFS_TREE_VARIDXKEYS) ||\n\t\t\t\t(tree->cnid == HFSPLUS_ATTR_CNID))\n\t\t\tkey_len = be16_to_cpu(fd->search_key->key_len) + 2;\n\t\telse {\n\t\t\tfd->search_key->key_len =\n\t\t\t\tcpu_to_be16(tree->max_key_len);\n\t\t\tkey_len = tree->max_key_len + 2;\n\t\t}\n\t\tgoto again;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_brec_find",
          "args": [
            "fd",
            "hfs_find_rec_by_key"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_brec_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bfind.c",
          "lines": "165-217",
          "snippet": "int hfs_brec_find(struct hfs_find_data *fd, search_strategy_t do_key_compare)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\tu32 nidx, parent;\n\t__be32 data;\n\tint height, res;\n\n\ttree = fd->tree;\n\tif (fd->bnode)\n\t\thfs_bnode_put(fd->bnode);\n\tfd->bnode = NULL;\n\tnidx = tree->root;\n\tif (!nidx)\n\t\treturn -ENOENT;\n\theight = tree->depth;\n\tres = 0;\n\tparent = 0;\n\tfor (;;) {\n\t\tbnode = hfs_bnode_find(tree, nidx);\n\t\tif (IS_ERR(bnode)) {\n\t\t\tres = PTR_ERR(bnode);\n\t\t\tbnode = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (bnode->height != height)\n\t\t\tgoto invalid;\n\t\tif (bnode->type != (--height ? HFS_NODE_INDEX : HFS_NODE_LEAF))\n\t\t\tgoto invalid;\n\t\tbnode->parent = parent;\n\n\t\tres = __hfs_brec_find(bnode, fd, do_key_compare);\n\t\tif (!height)\n\t\t\tbreak;\n\t\tif (fd->record < 0)\n\t\t\tgoto release;\n\n\t\tparent = nidx;\n\t\thfs_bnode_read(bnode, &data, fd->entryoffset, 4);\n\t\tnidx = be32_to_cpu(data);\n\t\thfs_bnode_put(bnode);\n\t}\n\tfd->bnode = bnode;\n\treturn res;\n\ninvalid:\n\tpr_err(\"inconsistency in B*Tree (%d,%d,%d,%u,%u)\\n\",\n\t\theight, bnode->height, bnode->type, nidx, parent);\n\tres = -EIO;\nrelease:\n\thfs_bnode_put(bnode);\n\treturn res;\n}",
          "includes": [
            "#include \"hfsplus_fs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_fs.h\"\n#include <linux/slab.h>\n\nint hfs_brec_find(struct hfs_find_data *fd, search_strategy_t do_key_compare)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *bnode;\n\tu32 nidx, parent;\n\t__be32 data;\n\tint height, res;\n\n\ttree = fd->tree;\n\tif (fd->bnode)\n\t\thfs_bnode_put(fd->bnode);\n\tfd->bnode = NULL;\n\tnidx = tree->root;\n\tif (!nidx)\n\t\treturn -ENOENT;\n\theight = tree->depth;\n\tres = 0;\n\tparent = 0;\n\tfor (;;) {\n\t\tbnode = hfs_bnode_find(tree, nidx);\n\t\tif (IS_ERR(bnode)) {\n\t\t\tres = PTR_ERR(bnode);\n\t\t\tbnode = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (bnode->height != height)\n\t\t\tgoto invalid;\n\t\tif (bnode->type != (--height ? HFS_NODE_INDEX : HFS_NODE_LEAF))\n\t\t\tgoto invalid;\n\t\tbnode->parent = parent;\n\n\t\tres = __hfs_brec_find(bnode, fd, do_key_compare);\n\t\tif (!height)\n\t\t\tbreak;\n\t\tif (fd->record < 0)\n\t\t\tgoto release;\n\n\t\tparent = nidx;\n\t\thfs_bnode_read(bnode, &data, fd->entryoffset, 4);\n\t\tnidx = be32_to_cpu(data);\n\t\thfs_bnode_put(bnode);\n\t}\n\tfd->bnode = bnode;\n\treturn res;\n\ninvalid:\n\tpr_err(\"inconsistency in B*Tree (%d,%d,%d,%u,%u)\\n\",\n\t\theight, bnode->height, bnode->type, nidx, parent);\n\tres = -EIO;\nrelease:\n\thfs_bnode_put(bnode);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_ext_build_key",
          "args": [
            "fd->search_key",
            "inode->i_ino",
            "hip->cached_start",
            "HFSPLUS_IS_RSRC(inode) ?\n\t\t\t\tHFSPLUS_TYPE_RSRC : HFSPLUS_TYPE_DATA"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_ext_build_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/extents.c",
          "lines": "40-48",
          "snippet": "static void hfsplus_ext_build_key(hfsplus_btree_key *key, u32 cnid,\n\t\t\t\t  u32 block, u8 type)\n{\n\tkey->key_len = cpu_to_be16(HFSPLUS_EXT_KEYLEN - 2);\n\tkey->ext.cnid = cpu_to_be32(cnid);\n\tkey->ext.start_block = cpu_to_be32(block);\n\tkey->ext.fork_type = type;\n\tkey->ext.pad = 0;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic void hfsplus_ext_build_key(hfsplus_btree_key *key, u32 cnid,\n\t\t\t\t  u32 block, u8 type)\n{\n\tkey->key_len = cpu_to_be16(HFSPLUS_EXT_KEYLEN - 2);\n\tkey->ext.cnid = cpu_to_be32(cnid);\n\tkey->ext.start_block = cpu_to_be32(block);\n\tkey->ext.fork_type = type;\n\tkey->ext.pad = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HFSPLUS_IS_RSRC",
          "args": [
            "inode"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!mutex_is_locked(&hip->extents_lock)"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&hip->extents_lock"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFSPLUS_I",
          "args": [
            "inode"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "264-267",
          "snippet": "static inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_inode_info *HFSPLUS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct hfsplus_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int __hfsplus_ext_write_extent(struct inode *inode,\n\t\tstruct hfs_find_data *fd)\n{\n\tstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\n\tint res;\n\n\tWARN_ON(!mutex_is_locked(&hip->extents_lock));\n\n\thfsplus_ext_build_key(fd->search_key, inode->i_ino, hip->cached_start,\n\t\t\t      HFSPLUS_IS_RSRC(inode) ?\n\t\t\t\tHFSPLUS_TYPE_RSRC : HFSPLUS_TYPE_DATA);\n\n\tres = hfs_brec_find(fd, hfs_find_rec_by_key);\n\tif (hip->extent_state & HFSPLUS_EXT_NEW) {\n\t\tif (res != -ENOENT)\n\t\t\treturn res;\n\t\thfs_brec_insert(fd, hip->cached_extents,\n\t\t\t\tsizeof(hfsplus_extent_rec));\n\t\thip->extent_state &= ~(HFSPLUS_EXT_DIRTY | HFSPLUS_EXT_NEW);\n\t} else {\n\t\tif (res)\n\t\t\treturn res;\n\t\thfs_bnode_write(fd->bnode, hip->cached_extents,\n\t\t\t\tfd->entryoffset, fd->entrylength);\n\t\thip->extent_state &= ~HFSPLUS_EXT_DIRTY;\n\t}\n\n\t/*\n\t * We can't just use hfsplus_mark_inode_dirty here, because we\n\t * also get called from hfsplus_write_inode, which should not\n\t * redirty the inode.  Instead the callers have to be careful\n\t * to explicily mark the inode dirty, too.\n\t */\n\tset_bit(HFSPLUS_I_EXT_DIRTY, &hip->flags);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "hfsplus_ext_lastblock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/extents.c",
    "lines": "75-84",
    "snippet": "static u32 hfsplus_ext_lastblock(struct hfsplus_extent *ext)\n{\n\tint i;\n\n\text += 7;\n\tfor (i = 0; i < 7; ext--, i++)\n\t\tif (ext->block_count)\n\t\t\tbreak;\n\treturn be32_to_cpu(ext->start_block) + be32_to_cpu(ext->block_count);\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ext->block_count"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ext->start_block"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic u32 hfsplus_ext_lastblock(struct hfsplus_extent *ext)\n{\n\tint i;\n\n\text += 7;\n\tfor (i = 0; i < 7; ext--, i++)\n\t\tif (ext->block_count)\n\t\t\tbreak;\n\treturn be32_to_cpu(ext->start_block) + be32_to_cpu(ext->block_count);\n}"
  },
  {
    "function_name": "hfsplus_ext_block_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/extents.c",
    "lines": "65-73",
    "snippet": "static int hfsplus_ext_block_count(struct hfsplus_extent *ext)\n{\n\tint i;\n\tu32 count = 0;\n\n\tfor (i = 0; i < 8; ext++, i++)\n\t\tcount += be32_to_cpu(ext->block_count);\n\treturn count;\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ext->block_count"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic int hfsplus_ext_block_count(struct hfsplus_extent *ext)\n{\n\tint i;\n\tu32 count = 0;\n\n\tfor (i = 0; i < 8; ext++, i++)\n\t\tcount += be32_to_cpu(ext->block_count);\n\treturn count;\n}"
  },
  {
    "function_name": "hfsplus_ext_find_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/extents.c",
    "lines": "50-63",
    "snippet": "static u32 hfsplus_ext_find_block(struct hfsplus_extent *ext, u32 off)\n{\n\tint i;\n\tu32 count;\n\n\tfor (i = 0; i < 8; ext++, i++) {\n\t\tcount = be32_to_cpu(ext->block_count);\n\t\tif (off < count)\n\t\t\treturn be32_to_cpu(ext->start_block) + off;\n\t\toff -= count;\n\t}\n\t/* panic? */\n\treturn 0;\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ext->start_block"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "ext->block_count"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic u32 hfsplus_ext_find_block(struct hfsplus_extent *ext, u32 off)\n{\n\tint i;\n\tu32 count;\n\n\tfor (i = 0; i < 8; ext++, i++) {\n\t\tcount = be32_to_cpu(ext->block_count);\n\t\tif (off < count)\n\t\t\treturn be32_to_cpu(ext->start_block) + off;\n\t\toff -= count;\n\t}\n\t/* panic? */\n\treturn 0;\n}"
  },
  {
    "function_name": "hfsplus_ext_build_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/extents.c",
    "lines": "40-48",
    "snippet": "static void hfsplus_ext_build_key(hfsplus_btree_key *key, u32 cnid,\n\t\t\t\t  u32 block, u8 type)\n{\n\tkey->key_len = cpu_to_be16(HFSPLUS_EXT_KEYLEN - 2);\n\tkey->ext.cnid = cpu_to_be32(cnid);\n\tkey->ext.start_block = cpu_to_be32(block);\n\tkey->ext.fork_type = type;\n\tkey->ext.pad = 0;\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "block"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "cnid"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "HFSPLUS_EXT_KEYLEN - 2"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nstatic void hfsplus_ext_build_key(hfsplus_btree_key *key, u32 cnid,\n\t\t\t\t  u32 block, u8 type)\n{\n\tkey->key_len = cpu_to_be16(HFSPLUS_EXT_KEYLEN - 2);\n\tkey->ext.cnid = cpu_to_be32(cnid);\n\tkey->ext.start_block = cpu_to_be32(block);\n\tkey->ext.fork_type = type;\n\tkey->ext.pad = 0;\n}"
  },
  {
    "function_name": "hfsplus_ext_cmp_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/extents.c",
    "lines": "19-38",
    "snippet": "int hfsplus_ext_cmp_key(const hfsplus_btree_key *k1,\n\t\t\tconst hfsplus_btree_key *k2)\n{\n\t__be32 k1id, k2id;\n\t__be32 k1s, k2s;\n\n\tk1id = k1->ext.cnid;\n\tk2id = k2->ext.cnid;\n\tif (k1id != k2id)\n\t\treturn be32_to_cpu(k1id) < be32_to_cpu(k2id) ? -1 : 1;\n\n\tif (k1->ext.fork_type != k2->ext.fork_type)\n\t\treturn k1->ext.fork_type < k2->ext.fork_type ? -1 : 1;\n\n\tk1s = k1->ext.start_block;\n\tk2s = k2->ext.start_block;\n\tif (k1s == k2s)\n\t\treturn 0;\n\treturn be32_to_cpu(k1s) < be32_to_cpu(k2s) ? -1 : 1;\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "k2s"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "k1s"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "k2id"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "k1id"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n\nint hfsplus_ext_cmp_key(const hfsplus_btree_key *k1,\n\t\t\tconst hfsplus_btree_key *k2)\n{\n\t__be32 k1id, k2id;\n\t__be32 k1s, k2s;\n\n\tk1id = k1->ext.cnid;\n\tk2id = k2->ext.cnid;\n\tif (k1id != k2id)\n\t\treturn be32_to_cpu(k1id) < be32_to_cpu(k2id) ? -1 : 1;\n\n\tif (k1->ext.fork_type != k2->ext.fork_type)\n\t\treturn k1->ext.fork_type < k2->ext.fork_type ? -1 : 1;\n\n\tk1s = k1->ext.start_block;\n\tk2s = k2->ext.start_block;\n\tif (k1s == k2s)\n\t\treturn 0;\n\treturn be32_to_cpu(k1s) < be32_to_cpu(k2s) ? -1 : 1;\n}"
  }
]